/* ex: set ro ft=c: -*- mode: c; buffer-read-only: t -*- */
/*****************************************************************************/
/*  LibreDWG - free implementation of the DWG file format                    */
/*                                                                           */
/*  Copyright (C) 2019 Free Software Foundation, Inc.                        */
/*                                                                           */
/*  This library is free software, licensed under the terms of the GNU       */
/*  General Public License as published by the Free Software Foundation,     */
/*  either version 3 of the License, or (at your option) any later version.  */
/*  You should have received a copy of the GNU General Public License        */
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
/*****************************************************************************/
/* dynapi coverage tests, generated by gen-dynapi.pl from dynapi_test.c.in
   do not modify */
/* written by: Reini Urban */

#line 17 "dynapi_test.c.in"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <sys/stat.h>

#define DWG_LOGLEVEL DWG_LOGLEVEL_NONE
#include "dwg.h"
#include "dwg_api.h"
#include "../../src/dynapi.h"
#include "../../src/common.h"
CLANG_DIAG_IGNORE(-Wformat-nonliteral)
CLANG_DIAG_IGNORE(-Wmissing-prototypes)
#include <dejagnu.h>
CLANG_DIAG_RESTORE
CLANG_DIAG_RESTORE

/* for all objects/entities/header_vars:
   compare direct api vs dynapi values
*/
static int test_header (const Dwg_Data *dwg)
{
  int error = 0;
  BITCODE_RL rl;
  BITCODE_RC rc;
  BITCODE_BLL bll;
  BITCODE_BD bd;
  BITCODE_TV tv;

#line 48 "dynapi_test.c"
  /* @@for test_HEADER@@ */
  {
    BITCODE_RL size;
    if (dwg_dynapi_header_value(dwg, "size", &size, NULL) &&
        size == dwg->header_vars.size)
      pass ("HEADER.size [RL] %u", size);
    else
      {
        fail ("HEADER.size [RL] %u != %u", dwg->header_vars.size, size); error++;
      }
    size++;
    if (dwg_dynapi_header_set_value(dwg, "size", &size) &&
        size == dwg->header_vars.size)
      pass ("HEADER.size [RL] set+1 %u", size);
    else
      {
        fail ("HEADER.size [RL] set+1 %u != %u", dwg->header_vars.size, size); error++;
      }
    size--; dwg_dynapi_header_set_value(dwg, "size", &size);

  }
  {
    BITCODE_RL bitsize_hi;
    if (dwg_dynapi_header_value(dwg, "bitsize_hi", &bitsize_hi, NULL) &&
        bitsize_hi == dwg->header_vars.bitsize_hi)
      pass ("HEADER.bitsize_hi [RL] %u", bitsize_hi);
    else
      {
        fail ("HEADER.bitsize_hi [RL] %u != %u", dwg->header_vars.bitsize_hi, bitsize_hi); error++;
      }
    bitsize_hi++;
    if (dwg_dynapi_header_set_value(dwg, "bitsize_hi", &bitsize_hi) &&
        bitsize_hi == dwg->header_vars.bitsize_hi)
      pass ("HEADER.bitsize_hi [RL] set+1 %u", bitsize_hi);
    else
      {
        fail ("HEADER.bitsize_hi [RL] set+1 %u != %u", dwg->header_vars.bitsize_hi, bitsize_hi); error++;
      }
    bitsize_hi--; dwg_dynapi_header_set_value(dwg, "bitsize_hi", &bitsize_hi);

  }
  {
    BITCODE_RL bitsize;
    if (dwg_dynapi_header_value(dwg, "bitsize", &bitsize, NULL) &&
        bitsize == dwg->header_vars.bitsize)
      pass ("HEADER.bitsize [RL] %u", bitsize);
    else
      {
        fail ("HEADER.bitsize [RL] %u != %u", dwg->header_vars.bitsize, bitsize); error++;
      }
    bitsize++;
    if (dwg_dynapi_header_set_value(dwg, "bitsize", &bitsize) &&
        bitsize == dwg->header_vars.bitsize)
      pass ("HEADER.bitsize [RL] set+1 %u", bitsize);
    else
      {
        fail ("HEADER.bitsize [RL] set+1 %u != %u", dwg->header_vars.bitsize, bitsize); error++;
      }
    bitsize--; dwg_dynapi_header_set_value(dwg, "bitsize", &bitsize);

  }
  {
    BITCODE_RC acadmaintver;
    if (dwg_dynapi_header_value(dwg, "ACADMAINTVER", &acadmaintver, NULL) &&
        acadmaintver == dwg->header_vars.ACADMAINTVER)
      pass ("HEADER.ACADMAINTVER [RC] %u", acadmaintver);
    else
      {
        fail ("HEADER.ACADMAINTVER [RC] %u != %u", dwg->header_vars.ACADMAINTVER, acadmaintver); error++;
      }
    acadmaintver++;
    if (dwg_dynapi_header_set_value(dwg, "ACADMAINTVER", &acadmaintver) &&
        acadmaintver == dwg->header_vars.ACADMAINTVER)
      pass ("HEADER.ACADMAINTVER [RC] set+1 %u", acadmaintver);
    else
      {
        fail ("HEADER.ACADMAINTVER [RC] set+1 %u != %u", dwg->header_vars.ACADMAINTVER, acadmaintver); error++;
      }
    acadmaintver--; dwg_dynapi_header_set_value(dwg, "ACADMAINTVER", &acadmaintver);

  }
  {
    BITCODE_BLL requiredversions;
    if (dwg_dynapi_header_value(dwg, "REQUIREDVERSIONS", &requiredversions, NULL) &&
        requiredversions == dwg->header_vars.REQUIREDVERSIONS)
      pass ("HEADER.REQUIREDVERSIONS [BLL] %lu", requiredversions);
    else
      {
        fail ("HEADER.REQUIREDVERSIONS [BLL] %lu != %lu", dwg->header_vars.REQUIREDVERSIONS, requiredversions); error++;
      }
    requiredversions++;
    if (dwg_dynapi_header_set_value(dwg, "REQUIREDVERSIONS", &requiredversions) &&
        requiredversions == dwg->header_vars.REQUIREDVERSIONS)
      pass ("HEADER.REQUIREDVERSIONS [BLL] set+1 %lu", requiredversions);
    else
      {
        fail ("HEADER.REQUIREDVERSIONS [BLL] set+1 %lu != %lu", dwg->header_vars.REQUIREDVERSIONS, requiredversions); error++;
      }
    requiredversions--; dwg_dynapi_header_set_value(dwg, "REQUIREDVERSIONS", &requiredversions);

  }
  {
    BITCODE_TV dwgcodepage;
    if (dwg_dynapi_header_value(dwg, "DWGCODEPAGE", &dwgcodepage, NULL)
        && !memcmp(&dwgcodepage, &dwg->header_vars.DWGCODEPAGE, sizeof(dwg->header_vars.DWGCODEPAGE))
       )
      pass ("HEADER.DWGCODEPAGE [TV]");
    else
      {
        fail ("HEADER.DWGCODEPAGE [TV]"); error++;
      }
  }
  {
    BITCODE_TU lastsavedby;
    if (dwg_dynapi_header_value(dwg, "LASTSAVEDBY", &lastsavedby, NULL)
        && !memcmp(&lastsavedby, &dwg->header_vars.LASTSAVEDBY, sizeof(dwg->header_vars.LASTSAVEDBY))
       )
      pass ("HEADER.LASTSAVEDBY [TU]");
    else
      {
        fail ("HEADER.LASTSAVEDBY [TU]"); error++;
      }
  }
  {
    BITCODE_BD unknown_0;
    if (dwg_dynapi_header_value(dwg, "unknown_0", &unknown_0, NULL) &&
        unknown_0 == dwg->header_vars.unknown_0)
      pass ("HEADER.unknown_0 [BD] %g", unknown_0);
    else
      {
        fail ("HEADER.unknown_0 [BD] %g != %g", dwg->header_vars.unknown_0, unknown_0); error++;
      }
    unknown_0++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_0", &unknown_0) &&
        unknown_0 == dwg->header_vars.unknown_0)
      pass ("HEADER.unknown_0 [BD] set+1 %g", unknown_0);
    else
      {
        fail ("HEADER.unknown_0 [BD] set+1 %g != %g", dwg->header_vars.unknown_0, unknown_0); error++;
      }
    unknown_0--; dwg_dynapi_header_set_value(dwg, "unknown_0", &unknown_0);

  }
  {
    BITCODE_BD unknown_1;
    if (dwg_dynapi_header_value(dwg, "unknown_1", &unknown_1, NULL) &&
        unknown_1 == dwg->header_vars.unknown_1)
      pass ("HEADER.unknown_1 [BD] %g", unknown_1);
    else
      {
        fail ("HEADER.unknown_1 [BD] %g != %g", dwg->header_vars.unknown_1, unknown_1); error++;
      }
    unknown_1++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_1", &unknown_1) &&
        unknown_1 == dwg->header_vars.unknown_1)
      pass ("HEADER.unknown_1 [BD] set+1 %g", unknown_1);
    else
      {
        fail ("HEADER.unknown_1 [BD] set+1 %g != %g", dwg->header_vars.unknown_1, unknown_1); error++;
      }
    unknown_1--; dwg_dynapi_header_set_value(dwg, "unknown_1", &unknown_1);

  }
  {
    BITCODE_BD unknown_2;
    if (dwg_dynapi_header_value(dwg, "unknown_2", &unknown_2, NULL) &&
        unknown_2 == dwg->header_vars.unknown_2)
      pass ("HEADER.unknown_2 [BD] %g", unknown_2);
    else
      {
        fail ("HEADER.unknown_2 [BD] %g != %g", dwg->header_vars.unknown_2, unknown_2); error++;
      }
    unknown_2++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_2", &unknown_2) &&
        unknown_2 == dwg->header_vars.unknown_2)
      pass ("HEADER.unknown_2 [BD] set+1 %g", unknown_2);
    else
      {
        fail ("HEADER.unknown_2 [BD] set+1 %g != %g", dwg->header_vars.unknown_2, unknown_2); error++;
      }
    unknown_2--; dwg_dynapi_header_set_value(dwg, "unknown_2", &unknown_2);

  }
  {
    BITCODE_BD unknown_3;
    if (dwg_dynapi_header_value(dwg, "unknown_3", &unknown_3, NULL) &&
        unknown_3 == dwg->header_vars.unknown_3)
      pass ("HEADER.unknown_3 [BD] %g", unknown_3);
    else
      {
        fail ("HEADER.unknown_3 [BD] %g != %g", dwg->header_vars.unknown_3, unknown_3); error++;
      }
    unknown_3++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_3", &unknown_3) &&
        unknown_3 == dwg->header_vars.unknown_3)
      pass ("HEADER.unknown_3 [BD] set+1 %g", unknown_3);
    else
      {
        fail ("HEADER.unknown_3 [BD] set+1 %g != %g", dwg->header_vars.unknown_3, unknown_3); error++;
      }
    unknown_3--; dwg_dynapi_header_set_value(dwg, "unknown_3", &unknown_3);

  }
  {
    BITCODE_TV unknown_text1;
    if (dwg_dynapi_header_value(dwg, "unknown_text1", &unknown_text1, NULL)
        && !memcmp(&unknown_text1, &dwg->header_vars.unknown_text1, sizeof(dwg->header_vars.unknown_text1))
       )
      pass ("HEADER.unknown_text1 [TV]");
    else
      {
        fail ("HEADER.unknown_text1 [TV]"); error++;
      }
  }
  {
    BITCODE_TV unknown_text2;
    if (dwg_dynapi_header_value(dwg, "unknown_text2", &unknown_text2, NULL)
        && !memcmp(&unknown_text2, &dwg->header_vars.unknown_text2, sizeof(dwg->header_vars.unknown_text2))
       )
      pass ("HEADER.unknown_text2 [TV]");
    else
      {
        fail ("HEADER.unknown_text2 [TV]"); error++;
      }
  }
  {
    BITCODE_TV unknown_text3;
    if (dwg_dynapi_header_value(dwg, "unknown_text3", &unknown_text3, NULL)
        && !memcmp(&unknown_text3, &dwg->header_vars.unknown_text3, sizeof(dwg->header_vars.unknown_text3))
       )
      pass ("HEADER.unknown_text3 [TV]");
    else
      {
        fail ("HEADER.unknown_text3 [TV]"); error++;
      }
  }
  {
    BITCODE_TV unknown_text4;
    if (dwg_dynapi_header_value(dwg, "unknown_text4", &unknown_text4, NULL)
        && !memcmp(&unknown_text4, &dwg->header_vars.unknown_text4, sizeof(dwg->header_vars.unknown_text4))
       )
      pass ("HEADER.unknown_text4 [TV]");
    else
      {
        fail ("HEADER.unknown_text4 [TV]"); error++;
      }
  }
  {
    BITCODE_BL unknown_8;
    if (dwg_dynapi_header_value(dwg, "unknown_8", &unknown_8, NULL) &&
        unknown_8 == dwg->header_vars.unknown_8)
      pass ("HEADER.unknown_8 [BL] %u", unknown_8);
    else
      {
        fail ("HEADER.unknown_8 [BL] %u != %u", dwg->header_vars.unknown_8, unknown_8); error++;
      }
    unknown_8++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_8", &unknown_8) &&
        unknown_8 == dwg->header_vars.unknown_8)
      pass ("HEADER.unknown_8 [BL] set+1 %u", unknown_8);
    else
      {
        fail ("HEADER.unknown_8 [BL] set+1 %u != %u", dwg->header_vars.unknown_8, unknown_8); error++;
      }
    unknown_8--; dwg_dynapi_header_set_value(dwg, "unknown_8", &unknown_8);

  }
  {
    BITCODE_BL unknown_9;
    if (dwg_dynapi_header_value(dwg, "unknown_9", &unknown_9, NULL) &&
        unknown_9 == dwg->header_vars.unknown_9)
      pass ("HEADER.unknown_9 [BL] %u", unknown_9);
    else
      {
        fail ("HEADER.unknown_9 [BL] %u != %u", dwg->header_vars.unknown_9, unknown_9); error++;
      }
    unknown_9++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_9", &unknown_9) &&
        unknown_9 == dwg->header_vars.unknown_9)
      pass ("HEADER.unknown_9 [BL] set+1 %u", unknown_9);
    else
      {
        fail ("HEADER.unknown_9 [BL] set+1 %u != %u", dwg->header_vars.unknown_9, unknown_9); error++;
      }
    unknown_9--; dwg_dynapi_header_set_value(dwg, "unknown_9", &unknown_9);

  }
  {
    BITCODE_BS unknown_10;
    if (dwg_dynapi_header_value(dwg, "unknown_10", &unknown_10, NULL) &&
        unknown_10 == dwg->header_vars.unknown_10)
      pass ("HEADER.unknown_10 [BS] %hu", unknown_10);
    else
      {
        fail ("HEADER.unknown_10 [BS] %hu != %hu", dwg->header_vars.unknown_10, unknown_10); error++;
      }
    unknown_10++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_10", &unknown_10) &&
        unknown_10 == dwg->header_vars.unknown_10)
      pass ("HEADER.unknown_10 [BS] set+1 %hu", unknown_10);
    else
      {
        fail ("HEADER.unknown_10 [BS] set+1 %hu != %hu", dwg->header_vars.unknown_10, unknown_10); error++;
      }
    unknown_10--; dwg_dynapi_header_set_value(dwg, "unknown_10", &unknown_10);

  }
  {
    BITCODE_H vport_entity_header;
    if (dwg_dynapi_header_value(dwg, "vport_entity_header", &vport_entity_header, NULL)
        && !memcmp(&vport_entity_header, &dwg->header_vars.vport_entity_header, sizeof(dwg->header_vars.vport_entity_header))
       )
      pass ("HEADER.vport_entity_header [H]");
    else
      {
        fail ("HEADER.vport_entity_header [H]"); error++;
      }
  }
  {
    BITCODE_B dimaso;
    if (dwg_dynapi_header_value(dwg, "DIMASO", &dimaso, NULL) &&
        dimaso == dwg->header_vars.DIMASO)
      pass ("HEADER.DIMASO [B] " FORMAT_B "", dimaso);
    else
      {
        fail ("HEADER.DIMASO [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMASO, dimaso); error++;
      }
    dimaso++;
    if (dwg_dynapi_header_set_value(dwg, "DIMASO", &dimaso) &&
        dimaso == dwg->header_vars.DIMASO)
      pass ("HEADER.DIMASO [B] set+1 " FORMAT_B "", dimaso);
    else
      {
        fail ("HEADER.DIMASO [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMASO, dimaso); error++;
      }
    dimaso--; dwg_dynapi_header_set_value(dwg, "DIMASO", &dimaso);

  }
  {
    BITCODE_B dimsho;
    if (dwg_dynapi_header_value(dwg, "DIMSHO", &dimsho, NULL) &&
        dimsho == dwg->header_vars.DIMSHO)
      pass ("HEADER.DIMSHO [B] " FORMAT_B "", dimsho);
    else
      {
        fail ("HEADER.DIMSHO [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSHO, dimsho); error++;
      }
    dimsho++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSHO", &dimsho) &&
        dimsho == dwg->header_vars.DIMSHO)
      pass ("HEADER.DIMSHO [B] set+1 " FORMAT_B "", dimsho);
    else
      {
        fail ("HEADER.DIMSHO [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSHO, dimsho); error++;
      }
    dimsho--; dwg_dynapi_header_set_value(dwg, "DIMSHO", &dimsho);

  }
  {
    BITCODE_B dimsav;
    if (dwg_dynapi_header_value(dwg, "DIMSAV", &dimsav, NULL) &&
        dimsav == dwg->header_vars.DIMSAV)
      pass ("HEADER.DIMSAV [B] " FORMAT_B "", dimsav);
    else
      {
        fail ("HEADER.DIMSAV [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAV, dimsav); error++;
      }
    dimsav++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSAV", &dimsav) &&
        dimsav == dwg->header_vars.DIMSAV)
      pass ("HEADER.DIMSAV [B] set+1 " FORMAT_B "", dimsav);
    else
      {
        fail ("HEADER.DIMSAV [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAV, dimsav); error++;
      }
    dimsav--; dwg_dynapi_header_set_value(dwg, "DIMSAV", &dimsav);

  }
  {
    BITCODE_B plinegen;
    if (dwg_dynapi_header_value(dwg, "PLINEGEN", &plinegen, NULL) &&
        plinegen == dwg->header_vars.PLINEGEN)
      pass ("HEADER.PLINEGEN [B] " FORMAT_B "", plinegen);
    else
      {
        fail ("HEADER.PLINEGEN [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLINEGEN, plinegen); error++;
      }
    plinegen++;
    if (dwg_dynapi_header_set_value(dwg, "PLINEGEN", &plinegen) &&
        plinegen == dwg->header_vars.PLINEGEN)
      pass ("HEADER.PLINEGEN [B] set+1 " FORMAT_B "", plinegen);
    else
      {
        fail ("HEADER.PLINEGEN [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLINEGEN, plinegen); error++;
      }
    plinegen--; dwg_dynapi_header_set_value(dwg, "PLINEGEN", &plinegen);

  }
  {
    BITCODE_B orthomode;
    if (dwg_dynapi_header_value(dwg, "ORTHOMODE", &orthomode, NULL) &&
        orthomode == dwg->header_vars.ORTHOMODE)
      pass ("HEADER.ORTHOMODE [B] " FORMAT_B "", orthomode);
    else
      {
        fail ("HEADER.ORTHOMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ORTHOMODE, orthomode); error++;
      }
    orthomode++;
    if (dwg_dynapi_header_set_value(dwg, "ORTHOMODE", &orthomode) &&
        orthomode == dwg->header_vars.ORTHOMODE)
      pass ("HEADER.ORTHOMODE [B] set+1 " FORMAT_B "", orthomode);
    else
      {
        fail ("HEADER.ORTHOMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ORTHOMODE, orthomode); error++;
      }
    orthomode--; dwg_dynapi_header_set_value(dwg, "ORTHOMODE", &orthomode);

  }
  {
    BITCODE_B regenmode;
    if (dwg_dynapi_header_value(dwg, "REGENMODE", &regenmode, NULL) &&
        regenmode == dwg->header_vars.REGENMODE)
      pass ("HEADER.REGENMODE [B] " FORMAT_B "", regenmode);
    else
      {
        fail ("HEADER.REGENMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REGENMODE, regenmode); error++;
      }
    regenmode++;
    if (dwg_dynapi_header_set_value(dwg, "REGENMODE", &regenmode) &&
        regenmode == dwg->header_vars.REGENMODE)
      pass ("HEADER.REGENMODE [B] set+1 " FORMAT_B "", regenmode);
    else
      {
        fail ("HEADER.REGENMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REGENMODE, regenmode); error++;
      }
    regenmode--; dwg_dynapi_header_set_value(dwg, "REGENMODE", &regenmode);

  }
  {
    BITCODE_B fillmode;
    if (dwg_dynapi_header_value(dwg, "FILLMODE", &fillmode, NULL) &&
        fillmode == dwg->header_vars.FILLMODE)
      pass ("HEADER.FILLMODE [B] " FORMAT_B "", fillmode);
    else
      {
        fail ("HEADER.FILLMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FILLMODE, fillmode); error++;
      }
    fillmode++;
    if (dwg_dynapi_header_set_value(dwg, "FILLMODE", &fillmode) &&
        fillmode == dwg->header_vars.FILLMODE)
      pass ("HEADER.FILLMODE [B] set+1 " FORMAT_B "", fillmode);
    else
      {
        fail ("HEADER.FILLMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FILLMODE, fillmode); error++;
      }
    fillmode--; dwg_dynapi_header_set_value(dwg, "FILLMODE", &fillmode);

  }
  {
    BITCODE_B qtextmode;
    if (dwg_dynapi_header_value(dwg, "QTEXTMODE", &qtextmode, NULL) &&
        qtextmode == dwg->header_vars.QTEXTMODE)
      pass ("HEADER.QTEXTMODE [B] " FORMAT_B "", qtextmode);
    else
      {
        fail ("HEADER.QTEXTMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.QTEXTMODE, qtextmode); error++;
      }
    qtextmode++;
    if (dwg_dynapi_header_set_value(dwg, "QTEXTMODE", &qtextmode) &&
        qtextmode == dwg->header_vars.QTEXTMODE)
      pass ("HEADER.QTEXTMODE [B] set+1 " FORMAT_B "", qtextmode);
    else
      {
        fail ("HEADER.QTEXTMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.QTEXTMODE, qtextmode); error++;
      }
    qtextmode--; dwg_dynapi_header_set_value(dwg, "QTEXTMODE", &qtextmode);

  }
  {
    BITCODE_B psltscale;
    if (dwg_dynapi_header_value(dwg, "PSLTSCALE", &psltscale, NULL) &&
        psltscale == dwg->header_vars.PSLTSCALE)
      pass ("HEADER.PSLTSCALE [B] " FORMAT_B "", psltscale);
    else
      {
        fail ("HEADER.PSLTSCALE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSLTSCALE, psltscale); error++;
      }
    psltscale++;
    if (dwg_dynapi_header_set_value(dwg, "PSLTSCALE", &psltscale) &&
        psltscale == dwg->header_vars.PSLTSCALE)
      pass ("HEADER.PSLTSCALE [B] set+1 " FORMAT_B "", psltscale);
    else
      {
        fail ("HEADER.PSLTSCALE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSLTSCALE, psltscale); error++;
      }
    psltscale--; dwg_dynapi_header_set_value(dwg, "PSLTSCALE", &psltscale);

  }
  {
    BITCODE_B limcheck;
    if (dwg_dynapi_header_value(dwg, "LIMCHECK", &limcheck, NULL) &&
        limcheck == dwg->header_vars.LIMCHECK)
      pass ("HEADER.LIMCHECK [B] " FORMAT_B "", limcheck);
    else
      {
        fail ("HEADER.LIMCHECK [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LIMCHECK, limcheck); error++;
      }
    limcheck++;
    if (dwg_dynapi_header_set_value(dwg, "LIMCHECK", &limcheck) &&
        limcheck == dwg->header_vars.LIMCHECK)
      pass ("HEADER.LIMCHECK [B] set+1 " FORMAT_B "", limcheck);
    else
      {
        fail ("HEADER.LIMCHECK [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LIMCHECK, limcheck); error++;
      }
    limcheck--; dwg_dynapi_header_set_value(dwg, "LIMCHECK", &limcheck);

  }
  {
    BITCODE_B blipmode;
    if (dwg_dynapi_header_value(dwg, "BLIPMODE", &blipmode, NULL) &&
        blipmode == dwg->header_vars.BLIPMODE)
      pass ("HEADER.BLIPMODE [B] " FORMAT_B "", blipmode);
    else
      {
        fail ("HEADER.BLIPMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.BLIPMODE, blipmode); error++;
      }
    blipmode++;
    if (dwg_dynapi_header_set_value(dwg, "BLIPMODE", &blipmode) &&
        blipmode == dwg->header_vars.BLIPMODE)
      pass ("HEADER.BLIPMODE [B] set+1 " FORMAT_B "", blipmode);
    else
      {
        fail ("HEADER.BLIPMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.BLIPMODE, blipmode); error++;
      }
    blipmode--; dwg_dynapi_header_set_value(dwg, "BLIPMODE", &blipmode);

  }
  {
    BITCODE_B unknown_11;
    if (dwg_dynapi_header_value(dwg, "unknown_11", &unknown_11, NULL) &&
        unknown_11 == dwg->header_vars.unknown_11)
      pass ("HEADER.unknown_11 [B] " FORMAT_B "", unknown_11);
    else
      {
        fail ("HEADER.unknown_11 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.unknown_11, unknown_11); error++;
      }
    unknown_11++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_11", &unknown_11) &&
        unknown_11 == dwg->header_vars.unknown_11)
      pass ("HEADER.unknown_11 [B] set+1 " FORMAT_B "", unknown_11);
    else
      {
        fail ("HEADER.unknown_11 [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.unknown_11, unknown_11); error++;
      }
    unknown_11--; dwg_dynapi_header_set_value(dwg, "unknown_11", &unknown_11);

  }
  {
    BITCODE_B usrtimer;
    if (dwg_dynapi_header_value(dwg, "USRTIMER", &usrtimer, NULL) &&
        usrtimer == dwg->header_vars.USRTIMER)
      pass ("HEADER.USRTIMER [B] " FORMAT_B "", usrtimer);
    else
      {
        fail ("HEADER.USRTIMER [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.USRTIMER, usrtimer); error++;
      }
    usrtimer++;
    if (dwg_dynapi_header_set_value(dwg, "USRTIMER", &usrtimer) &&
        usrtimer == dwg->header_vars.USRTIMER)
      pass ("HEADER.USRTIMER [B] set+1 " FORMAT_B "", usrtimer);
    else
      {
        fail ("HEADER.USRTIMER [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.USRTIMER, usrtimer); error++;
      }
    usrtimer--; dwg_dynapi_header_set_value(dwg, "USRTIMER", &usrtimer);

  }
  {
    BITCODE_B skpoly;
    if (dwg_dynapi_header_value(dwg, "SKPOLY", &skpoly, NULL) &&
        skpoly == dwg->header_vars.SKPOLY)
      pass ("HEADER.SKPOLY [B] " FORMAT_B "", skpoly);
    else
      {
        fail ("HEADER.SKPOLY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SKPOLY, skpoly); error++;
      }
    skpoly++;
    if (dwg_dynapi_header_set_value(dwg, "SKPOLY", &skpoly) &&
        skpoly == dwg->header_vars.SKPOLY)
      pass ("HEADER.SKPOLY [B] set+1 " FORMAT_B "", skpoly);
    else
      {
        fail ("HEADER.SKPOLY [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SKPOLY, skpoly); error++;
      }
    skpoly--; dwg_dynapi_header_set_value(dwg, "SKPOLY", &skpoly);

  }
  {
    BITCODE_B angdir;
    if (dwg_dynapi_header_value(dwg, "ANGDIR", &angdir, NULL) &&
        angdir == dwg->header_vars.ANGDIR)
      pass ("HEADER.ANGDIR [B] " FORMAT_B "", angdir);
    else
      {
        fail ("HEADER.ANGDIR [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ANGDIR, angdir); error++;
      }
    angdir++;
    if (dwg_dynapi_header_set_value(dwg, "ANGDIR", &angdir) &&
        angdir == dwg->header_vars.ANGDIR)
      pass ("HEADER.ANGDIR [B] set+1 " FORMAT_B "", angdir);
    else
      {
        fail ("HEADER.ANGDIR [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ANGDIR, angdir); error++;
      }
    angdir--; dwg_dynapi_header_set_value(dwg, "ANGDIR", &angdir);

  }
  {
    BITCODE_B splframe;
    if (dwg_dynapi_header_value(dwg, "SPLFRAME", &splframe, NULL) &&
        splframe == dwg->header_vars.SPLFRAME)
      pass ("HEADER.SPLFRAME [B] " FORMAT_B "", splframe);
    else
      {
        fail ("HEADER.SPLFRAME [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SPLFRAME, splframe); error++;
      }
    splframe++;
    if (dwg_dynapi_header_set_value(dwg, "SPLFRAME", &splframe) &&
        splframe == dwg->header_vars.SPLFRAME)
      pass ("HEADER.SPLFRAME [B] set+1 " FORMAT_B "", splframe);
    else
      {
        fail ("HEADER.SPLFRAME [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SPLFRAME, splframe); error++;
      }
    splframe--; dwg_dynapi_header_set_value(dwg, "SPLFRAME", &splframe);

  }
  {
    BITCODE_B attreq;
    if (dwg_dynapi_header_value(dwg, "ATTREQ", &attreq, NULL) &&
        attreq == dwg->header_vars.ATTREQ)
      pass ("HEADER.ATTREQ [B] " FORMAT_B "", attreq);
    else
      {
        fail ("HEADER.ATTREQ [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTREQ, attreq); error++;
      }
    attreq++;
    if (dwg_dynapi_header_set_value(dwg, "ATTREQ", &attreq) &&
        attreq == dwg->header_vars.ATTREQ)
      pass ("HEADER.ATTREQ [B] set+1 " FORMAT_B "", attreq);
    else
      {
        fail ("HEADER.ATTREQ [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTREQ, attreq); error++;
      }
    attreq--; dwg_dynapi_header_set_value(dwg, "ATTREQ", &attreq);

  }
  {
    BITCODE_B attdia;
    if (dwg_dynapi_header_value(dwg, "ATTDIA", &attdia, NULL) &&
        attdia == dwg->header_vars.ATTDIA)
      pass ("HEADER.ATTDIA [B] " FORMAT_B "", attdia);
    else
      {
        fail ("HEADER.ATTDIA [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTDIA, attdia); error++;
      }
    attdia++;
    if (dwg_dynapi_header_set_value(dwg, "ATTDIA", &attdia) &&
        attdia == dwg->header_vars.ATTDIA)
      pass ("HEADER.ATTDIA [B] set+1 " FORMAT_B "", attdia);
    else
      {
        fail ("HEADER.ATTDIA [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTDIA, attdia); error++;
      }
    attdia--; dwg_dynapi_header_set_value(dwg, "ATTDIA", &attdia);

  }
  {
    BITCODE_B mirrtext;
    if (dwg_dynapi_header_value(dwg, "MIRRTEXT", &mirrtext, NULL) &&
        mirrtext == dwg->header_vars.MIRRTEXT)
      pass ("HEADER.MIRRTEXT [B] " FORMAT_B "", mirrtext);
    else
      {
        fail ("HEADER.MIRRTEXT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.MIRRTEXT, mirrtext); error++;
      }
    mirrtext++;
    if (dwg_dynapi_header_set_value(dwg, "MIRRTEXT", &mirrtext) &&
        mirrtext == dwg->header_vars.MIRRTEXT)
      pass ("HEADER.MIRRTEXT [B] set+1 " FORMAT_B "", mirrtext);
    else
      {
        fail ("HEADER.MIRRTEXT [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.MIRRTEXT, mirrtext); error++;
      }
    mirrtext--; dwg_dynapi_header_set_value(dwg, "MIRRTEXT", &mirrtext);

  }
  {
    BITCODE_B worldview;
    if (dwg_dynapi_header_value(dwg, "WORLDVIEW", &worldview, NULL) &&
        worldview == dwg->header_vars.WORLDVIEW)
      pass ("HEADER.WORLDVIEW [B] " FORMAT_B "", worldview);
    else
      {
        fail ("HEADER.WORLDVIEW [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WORLDVIEW, worldview); error++;
      }
    worldview++;
    if (dwg_dynapi_header_set_value(dwg, "WORLDVIEW", &worldview) &&
        worldview == dwg->header_vars.WORLDVIEW)
      pass ("HEADER.WORLDVIEW [B] set+1 " FORMAT_B "", worldview);
    else
      {
        fail ("HEADER.WORLDVIEW [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WORLDVIEW, worldview); error++;
      }
    worldview--; dwg_dynapi_header_set_value(dwg, "WORLDVIEW", &worldview);

  }
  {
    BITCODE_B wireframe;
    if (dwg_dynapi_header_value(dwg, "WIREFRAME", &wireframe, NULL) &&
        wireframe == dwg->header_vars.WIREFRAME)
      pass ("HEADER.WIREFRAME [B] " FORMAT_B "", wireframe);
    else
      {
        fail ("HEADER.WIREFRAME [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WIREFRAME, wireframe); error++;
      }
    wireframe++;
    if (dwg_dynapi_header_set_value(dwg, "WIREFRAME", &wireframe) &&
        wireframe == dwg->header_vars.WIREFRAME)
      pass ("HEADER.WIREFRAME [B] set+1 " FORMAT_B "", wireframe);
    else
      {
        fail ("HEADER.WIREFRAME [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WIREFRAME, wireframe); error++;
      }
    wireframe--; dwg_dynapi_header_set_value(dwg, "WIREFRAME", &wireframe);

  }
  {
    BITCODE_B tilemode;
    if (dwg_dynapi_header_value(dwg, "TILEMODE", &tilemode, NULL) &&
        tilemode == dwg->header_vars.TILEMODE)
      pass ("HEADER.TILEMODE [B] " FORMAT_B "", tilemode);
    else
      {
        fail ("HEADER.TILEMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.TILEMODE, tilemode); error++;
      }
    tilemode++;
    if (dwg_dynapi_header_set_value(dwg, "TILEMODE", &tilemode) &&
        tilemode == dwg->header_vars.TILEMODE)
      pass ("HEADER.TILEMODE [B] set+1 " FORMAT_B "", tilemode);
    else
      {
        fail ("HEADER.TILEMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.TILEMODE, tilemode); error++;
      }
    tilemode--; dwg_dynapi_header_set_value(dwg, "TILEMODE", &tilemode);

  }
  {
    BITCODE_B plimcheck;
    if (dwg_dynapi_header_value(dwg, "PLIMCHECK", &plimcheck, NULL) &&
        plimcheck == dwg->header_vars.PLIMCHECK)
      pass ("HEADER.PLIMCHECK [B] " FORMAT_B "", plimcheck);
    else
      {
        fail ("HEADER.PLIMCHECK [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLIMCHECK, plimcheck); error++;
      }
    plimcheck++;
    if (dwg_dynapi_header_set_value(dwg, "PLIMCHECK", &plimcheck) &&
        plimcheck == dwg->header_vars.PLIMCHECK)
      pass ("HEADER.PLIMCHECK [B] set+1 " FORMAT_B "", plimcheck);
    else
      {
        fail ("HEADER.PLIMCHECK [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLIMCHECK, plimcheck); error++;
      }
    plimcheck--; dwg_dynapi_header_set_value(dwg, "PLIMCHECK", &plimcheck);

  }
  {
    BITCODE_B visretain;
    if (dwg_dynapi_header_value(dwg, "VISRETAIN", &visretain, NULL) &&
        visretain == dwg->header_vars.VISRETAIN)
      pass ("HEADER.VISRETAIN [B] " FORMAT_B "", visretain);
    else
      {
        fail ("HEADER.VISRETAIN [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.VISRETAIN, visretain); error++;
      }
    visretain++;
    if (dwg_dynapi_header_set_value(dwg, "VISRETAIN", &visretain) &&
        visretain == dwg->header_vars.VISRETAIN)
      pass ("HEADER.VISRETAIN [B] set+1 " FORMAT_B "", visretain);
    else
      {
        fail ("HEADER.VISRETAIN [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.VISRETAIN, visretain); error++;
      }
    visretain--; dwg_dynapi_header_set_value(dwg, "VISRETAIN", &visretain);

  }
  {
    BITCODE_B delobj;
    if (dwg_dynapi_header_value(dwg, "DELOBJ", &delobj, NULL) &&
        delobj == dwg->header_vars.DELOBJ)
      pass ("HEADER.DELOBJ [B] " FORMAT_B "", delobj);
    else
      {
        fail ("HEADER.DELOBJ [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DELOBJ, delobj); error++;
      }
    delobj++;
    if (dwg_dynapi_header_set_value(dwg, "DELOBJ", &delobj) &&
        delobj == dwg->header_vars.DELOBJ)
      pass ("HEADER.DELOBJ [B] set+1 " FORMAT_B "", delobj);
    else
      {
        fail ("HEADER.DELOBJ [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DELOBJ, delobj); error++;
      }
    delobj--; dwg_dynapi_header_set_value(dwg, "DELOBJ", &delobj);

  }
  {
    BITCODE_B dispsilh;
    if (dwg_dynapi_header_value(dwg, "DISPSILH", &dispsilh, NULL) &&
        dispsilh == dwg->header_vars.DISPSILH)
      pass ("HEADER.DISPSILH [B] " FORMAT_B "", dispsilh);
    else
      {
        fail ("HEADER.DISPSILH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DISPSILH, dispsilh); error++;
      }
    dispsilh++;
    if (dwg_dynapi_header_set_value(dwg, "DISPSILH", &dispsilh) &&
        dispsilh == dwg->header_vars.DISPSILH)
      pass ("HEADER.DISPSILH [B] set+1 " FORMAT_B "", dispsilh);
    else
      {
        fail ("HEADER.DISPSILH [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DISPSILH, dispsilh); error++;
      }
    dispsilh--; dwg_dynapi_header_set_value(dwg, "DISPSILH", &dispsilh);

  }
  {
    BITCODE_B pellipse;
    if (dwg_dynapi_header_value(dwg, "PELLIPSE", &pellipse, NULL) &&
        pellipse == dwg->header_vars.PELLIPSE)
      pass ("HEADER.PELLIPSE [B] " FORMAT_B "", pellipse);
    else
      {
        fail ("HEADER.PELLIPSE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PELLIPSE, pellipse); error++;
      }
    pellipse++;
    if (dwg_dynapi_header_set_value(dwg, "PELLIPSE", &pellipse) &&
        pellipse == dwg->header_vars.PELLIPSE)
      pass ("HEADER.PELLIPSE [B] set+1 " FORMAT_B "", pellipse);
    else
      {
        fail ("HEADER.PELLIPSE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PELLIPSE, pellipse); error++;
      }
    pellipse--; dwg_dynapi_header_set_value(dwg, "PELLIPSE", &pellipse);

  }
  {
    BITCODE_BS saveimages;
    if (dwg_dynapi_header_value(dwg, "SAVEIMAGES", &saveimages, NULL) &&
        saveimages == dwg->header_vars.SAVEIMAGES)
      pass ("HEADER.SAVEIMAGES [BS] %hu", saveimages);
    else
      {
        fail ("HEADER.SAVEIMAGES [BS] %hu != %hu", dwg->header_vars.SAVEIMAGES, saveimages); error++;
      }
    saveimages++;
    if (dwg_dynapi_header_set_value(dwg, "SAVEIMAGES", &saveimages) &&
        saveimages == dwg->header_vars.SAVEIMAGES)
      pass ("HEADER.SAVEIMAGES [BS] set+1 %hu", saveimages);
    else
      {
        fail ("HEADER.SAVEIMAGES [BS] set+1 %hu != %hu", dwg->header_vars.SAVEIMAGES, saveimages); error++;
      }
    saveimages--; dwg_dynapi_header_set_value(dwg, "SAVEIMAGES", &saveimages);

  }
  {
    BITCODE_BS proxygraphics;
    if (dwg_dynapi_header_value(dwg, "PROXYGRAPHICS", &proxygraphics, NULL) &&
        proxygraphics == dwg->header_vars.PROXYGRAPHICS)
      pass ("HEADER.PROXYGRAPHICS [BS] %hu", proxygraphics);
    else
      {
        fail ("HEADER.PROXYGRAPHICS [BS] %hu != %hu", dwg->header_vars.PROXYGRAPHICS, proxygraphics); error++;
      }
    proxygraphics++;
    if (dwg_dynapi_header_set_value(dwg, "PROXYGRAPHICS", &proxygraphics) &&
        proxygraphics == dwg->header_vars.PROXYGRAPHICS)
      pass ("HEADER.PROXYGRAPHICS [BS] set+1 %hu", proxygraphics);
    else
      {
        fail ("HEADER.PROXYGRAPHICS [BS] set+1 %hu != %hu", dwg->header_vars.PROXYGRAPHICS, proxygraphics); error++;
      }
    proxygraphics--; dwg_dynapi_header_set_value(dwg, "PROXYGRAPHICS", &proxygraphics);

  }
  {
    BITCODE_BS dragmode;
    if (dwg_dynapi_header_value(dwg, "DRAGMODE", &dragmode, NULL) &&
        dragmode == dwg->header_vars.DRAGMODE)
      pass ("HEADER.DRAGMODE [BS] %hu", dragmode);
    else
      {
        fail ("HEADER.DRAGMODE [BS] %hu != %hu", dwg->header_vars.DRAGMODE, dragmode); error++;
      }
    dragmode++;
    if (dwg_dynapi_header_set_value(dwg, "DRAGMODE", &dragmode) &&
        dragmode == dwg->header_vars.DRAGMODE)
      pass ("HEADER.DRAGMODE [BS] set+1 %hu", dragmode);
    else
      {
        fail ("HEADER.DRAGMODE [BS] set+1 %hu != %hu", dwg->header_vars.DRAGMODE, dragmode); error++;
      }
    dragmode--; dwg_dynapi_header_set_value(dwg, "DRAGMODE", &dragmode);

  }
  {
    BITCODE_BS treedepth;
    if (dwg_dynapi_header_value(dwg, "TREEDEPTH", &treedepth, NULL) &&
        treedepth == dwg->header_vars.TREEDEPTH)
      pass ("HEADER.TREEDEPTH [BS] %hu", treedepth);
    else
      {
        fail ("HEADER.TREEDEPTH [BS] %hu != %hu", dwg->header_vars.TREEDEPTH, treedepth); error++;
      }
    treedepth++;
    if (dwg_dynapi_header_set_value(dwg, "TREEDEPTH", &treedepth) &&
        treedepth == dwg->header_vars.TREEDEPTH)
      pass ("HEADER.TREEDEPTH [BS] set+1 %hu", treedepth);
    else
      {
        fail ("HEADER.TREEDEPTH [BS] set+1 %hu != %hu", dwg->header_vars.TREEDEPTH, treedepth); error++;
      }
    treedepth--; dwg_dynapi_header_set_value(dwg, "TREEDEPTH", &treedepth);

  }
  {
    BITCODE_BS lunits;
    if (dwg_dynapi_header_value(dwg, "LUNITS", &lunits, NULL) &&
        lunits == dwg->header_vars.LUNITS)
      pass ("HEADER.LUNITS [BS] %hu", lunits);
    else
      {
        fail ("HEADER.LUNITS [BS] %hu != %hu", dwg->header_vars.LUNITS, lunits); error++;
      }
    lunits++;
    if (dwg_dynapi_header_set_value(dwg, "LUNITS", &lunits) &&
        lunits == dwg->header_vars.LUNITS)
      pass ("HEADER.LUNITS [BS] set+1 %hu", lunits);
    else
      {
        fail ("HEADER.LUNITS [BS] set+1 %hu != %hu", dwg->header_vars.LUNITS, lunits); error++;
      }
    lunits--; dwg_dynapi_header_set_value(dwg, "LUNITS", &lunits);

  }
  {
    BITCODE_BS luprec;
    if (dwg_dynapi_header_value(dwg, "LUPREC", &luprec, NULL) &&
        luprec == dwg->header_vars.LUPREC)
      pass ("HEADER.LUPREC [BS] %hu", luprec);
    else
      {
        fail ("HEADER.LUPREC [BS] %hu != %hu", dwg->header_vars.LUPREC, luprec); error++;
      }
    luprec++;
    if (dwg_dynapi_header_set_value(dwg, "LUPREC", &luprec) &&
        luprec == dwg->header_vars.LUPREC)
      pass ("HEADER.LUPREC [BS] set+1 %hu", luprec);
    else
      {
        fail ("HEADER.LUPREC [BS] set+1 %hu != %hu", dwg->header_vars.LUPREC, luprec); error++;
      }
    luprec--; dwg_dynapi_header_set_value(dwg, "LUPREC", &luprec);

  }
  {
    BITCODE_BS aunits;
    if (dwg_dynapi_header_value(dwg, "AUNITS", &aunits, NULL) &&
        aunits == dwg->header_vars.AUNITS)
      pass ("HEADER.AUNITS [BS] %hu", aunits);
    else
      {
        fail ("HEADER.AUNITS [BS] %hu != %hu", dwg->header_vars.AUNITS, aunits); error++;
      }
    aunits++;
    if (dwg_dynapi_header_set_value(dwg, "AUNITS", &aunits) &&
        aunits == dwg->header_vars.AUNITS)
      pass ("HEADER.AUNITS [BS] set+1 %hu", aunits);
    else
      {
        fail ("HEADER.AUNITS [BS] set+1 %hu != %hu", dwg->header_vars.AUNITS, aunits); error++;
      }
    aunits--; dwg_dynapi_header_set_value(dwg, "AUNITS", &aunits);

  }
  {
    BITCODE_BS auprec;
    if (dwg_dynapi_header_value(dwg, "AUPREC", &auprec, NULL) &&
        auprec == dwg->header_vars.AUPREC)
      pass ("HEADER.AUPREC [BS] %hu", auprec);
    else
      {
        fail ("HEADER.AUPREC [BS] %hu != %hu", dwg->header_vars.AUPREC, auprec); error++;
      }
    auprec++;
    if (dwg_dynapi_header_set_value(dwg, "AUPREC", &auprec) &&
        auprec == dwg->header_vars.AUPREC)
      pass ("HEADER.AUPREC [BS] set+1 %hu", auprec);
    else
      {
        fail ("HEADER.AUPREC [BS] set+1 %hu != %hu", dwg->header_vars.AUPREC, auprec); error++;
      }
    auprec--; dwg_dynapi_header_set_value(dwg, "AUPREC", &auprec);

  }
  {
    BITCODE_BS osmode;
    if (dwg_dynapi_header_value(dwg, "OSMODE", &osmode, NULL) &&
        osmode == dwg->header_vars.OSMODE)
      pass ("HEADER.OSMODE [BS] %hu", osmode);
    else
      {
        fail ("HEADER.OSMODE [BS] %hu != %hu", dwg->header_vars.OSMODE, osmode); error++;
      }
    osmode++;
    if (dwg_dynapi_header_set_value(dwg, "OSMODE", &osmode) &&
        osmode == dwg->header_vars.OSMODE)
      pass ("HEADER.OSMODE [BS] set+1 %hu", osmode);
    else
      {
        fail ("HEADER.OSMODE [BS] set+1 %hu != %hu", dwg->header_vars.OSMODE, osmode); error++;
      }
    osmode--; dwg_dynapi_header_set_value(dwg, "OSMODE", &osmode);

  }
  {
    BITCODE_BS attmode;
    if (dwg_dynapi_header_value(dwg, "ATTMODE", &attmode, NULL) &&
        attmode == dwg->header_vars.ATTMODE)
      pass ("HEADER.ATTMODE [BS] %hu", attmode);
    else
      {
        fail ("HEADER.ATTMODE [BS] %hu != %hu", dwg->header_vars.ATTMODE, attmode); error++;
      }
    attmode++;
    if (dwg_dynapi_header_set_value(dwg, "ATTMODE", &attmode) &&
        attmode == dwg->header_vars.ATTMODE)
      pass ("HEADER.ATTMODE [BS] set+1 %hu", attmode);
    else
      {
        fail ("HEADER.ATTMODE [BS] set+1 %hu != %hu", dwg->header_vars.ATTMODE, attmode); error++;
      }
    attmode--; dwg_dynapi_header_set_value(dwg, "ATTMODE", &attmode);

  }
  {
    BITCODE_BS coords;
    if (dwg_dynapi_header_value(dwg, "COORDS", &coords, NULL) &&
        coords == dwg->header_vars.COORDS)
      pass ("HEADER.COORDS [BS] %hu", coords);
    else
      {
        fail ("HEADER.COORDS [BS] %hu != %hu", dwg->header_vars.COORDS, coords); error++;
      }
    coords++;
    if (dwg_dynapi_header_set_value(dwg, "COORDS", &coords) &&
        coords == dwg->header_vars.COORDS)
      pass ("HEADER.COORDS [BS] set+1 %hu", coords);
    else
      {
        fail ("HEADER.COORDS [BS] set+1 %hu != %hu", dwg->header_vars.COORDS, coords); error++;
      }
    coords--; dwg_dynapi_header_set_value(dwg, "COORDS", &coords);

  }
  {
    BITCODE_BS pdmode;
    if (dwg_dynapi_header_value(dwg, "PDMODE", &pdmode, NULL) &&
        pdmode == dwg->header_vars.PDMODE)
      pass ("HEADER.PDMODE [BS] %hu", pdmode);
    else
      {
        fail ("HEADER.PDMODE [BS] %hu != %hu", dwg->header_vars.PDMODE, pdmode); error++;
      }
    pdmode++;
    if (dwg_dynapi_header_set_value(dwg, "PDMODE", &pdmode) &&
        pdmode == dwg->header_vars.PDMODE)
      pass ("HEADER.PDMODE [BS] set+1 %hu", pdmode);
    else
      {
        fail ("HEADER.PDMODE [BS] set+1 %hu != %hu", dwg->header_vars.PDMODE, pdmode); error++;
      }
    pdmode--; dwg_dynapi_header_set_value(dwg, "PDMODE", &pdmode);

  }
  {
    BITCODE_BS pickstyle;
    if (dwg_dynapi_header_value(dwg, "PICKSTYLE", &pickstyle, NULL) &&
        pickstyle == dwg->header_vars.PICKSTYLE)
      pass ("HEADER.PICKSTYLE [BS] %hu", pickstyle);
    else
      {
        fail ("HEADER.PICKSTYLE [BS] %hu != %hu", dwg->header_vars.PICKSTYLE, pickstyle); error++;
      }
    pickstyle++;
    if (dwg_dynapi_header_set_value(dwg, "PICKSTYLE", &pickstyle) &&
        pickstyle == dwg->header_vars.PICKSTYLE)
      pass ("HEADER.PICKSTYLE [BS] set+1 %hu", pickstyle);
    else
      {
        fail ("HEADER.PICKSTYLE [BS] set+1 %hu != %hu", dwg->header_vars.PICKSTYLE, pickstyle); error++;
      }
    pickstyle--; dwg_dynapi_header_set_value(dwg, "PICKSTYLE", &pickstyle);

  }
  {
    BITCODE_BL unknown_12;
    if (dwg_dynapi_header_value(dwg, "unknown_12", &unknown_12, NULL) &&
        unknown_12 == dwg->header_vars.unknown_12)
      pass ("HEADER.unknown_12 [BL] %u", unknown_12);
    else
      {
        fail ("HEADER.unknown_12 [BL] %u != %u", dwg->header_vars.unknown_12, unknown_12); error++;
      }
    unknown_12++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_12", &unknown_12) &&
        unknown_12 == dwg->header_vars.unknown_12)
      pass ("HEADER.unknown_12 [BL] set+1 %u", unknown_12);
    else
      {
        fail ("HEADER.unknown_12 [BL] set+1 %u != %u", dwg->header_vars.unknown_12, unknown_12); error++;
      }
    unknown_12--; dwg_dynapi_header_set_value(dwg, "unknown_12", &unknown_12);

  }
  {
    BITCODE_BL unknown_13;
    if (dwg_dynapi_header_value(dwg, "unknown_13", &unknown_13, NULL) &&
        unknown_13 == dwg->header_vars.unknown_13)
      pass ("HEADER.unknown_13 [BL] %u", unknown_13);
    else
      {
        fail ("HEADER.unknown_13 [BL] %u != %u", dwg->header_vars.unknown_13, unknown_13); error++;
      }
    unknown_13++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_13", &unknown_13) &&
        unknown_13 == dwg->header_vars.unknown_13)
      pass ("HEADER.unknown_13 [BL] set+1 %u", unknown_13);
    else
      {
        fail ("HEADER.unknown_13 [BL] set+1 %u != %u", dwg->header_vars.unknown_13, unknown_13); error++;
      }
    unknown_13--; dwg_dynapi_header_set_value(dwg, "unknown_13", &unknown_13);

  }
  {
    BITCODE_BL unknown_14;
    if (dwg_dynapi_header_value(dwg, "unknown_14", &unknown_14, NULL) &&
        unknown_14 == dwg->header_vars.unknown_14)
      pass ("HEADER.unknown_14 [BL] %u", unknown_14);
    else
      {
        fail ("HEADER.unknown_14 [BL] %u != %u", dwg->header_vars.unknown_14, unknown_14); error++;
      }
    unknown_14++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_14", &unknown_14) &&
        unknown_14 == dwg->header_vars.unknown_14)
      pass ("HEADER.unknown_14 [BL] set+1 %u", unknown_14);
    else
      {
        fail ("HEADER.unknown_14 [BL] set+1 %u != %u", dwg->header_vars.unknown_14, unknown_14); error++;
      }
    unknown_14--; dwg_dynapi_header_set_value(dwg, "unknown_14", &unknown_14);

  }
  {
    BITCODE_BS useri1;
    if (dwg_dynapi_header_value(dwg, "USERI1", &useri1, NULL) &&
        useri1 == dwg->header_vars.USERI1)
      pass ("HEADER.USERI1 [BS] %hu", useri1);
    else
      {
        fail ("HEADER.USERI1 [BS] %hu != %hu", dwg->header_vars.USERI1, useri1); error++;
      }
    useri1++;
    if (dwg_dynapi_header_set_value(dwg, "USERI1", &useri1) &&
        useri1 == dwg->header_vars.USERI1)
      pass ("HEADER.USERI1 [BS] set+1 %hu", useri1);
    else
      {
        fail ("HEADER.USERI1 [BS] set+1 %hu != %hu", dwg->header_vars.USERI1, useri1); error++;
      }
    useri1--; dwg_dynapi_header_set_value(dwg, "USERI1", &useri1);

  }
  {
    BITCODE_BS useri2;
    if (dwg_dynapi_header_value(dwg, "USERI2", &useri2, NULL) &&
        useri2 == dwg->header_vars.USERI2)
      pass ("HEADER.USERI2 [BS] %hu", useri2);
    else
      {
        fail ("HEADER.USERI2 [BS] %hu != %hu", dwg->header_vars.USERI2, useri2); error++;
      }
    useri2++;
    if (dwg_dynapi_header_set_value(dwg, "USERI2", &useri2) &&
        useri2 == dwg->header_vars.USERI2)
      pass ("HEADER.USERI2 [BS] set+1 %hu", useri2);
    else
      {
        fail ("HEADER.USERI2 [BS] set+1 %hu != %hu", dwg->header_vars.USERI2, useri2); error++;
      }
    useri2--; dwg_dynapi_header_set_value(dwg, "USERI2", &useri2);

  }
  {
    BITCODE_BS useri3;
    if (dwg_dynapi_header_value(dwg, "USERI3", &useri3, NULL) &&
        useri3 == dwg->header_vars.USERI3)
      pass ("HEADER.USERI3 [BS] %hu", useri3);
    else
      {
        fail ("HEADER.USERI3 [BS] %hu != %hu", dwg->header_vars.USERI3, useri3); error++;
      }
    useri3++;
    if (dwg_dynapi_header_set_value(dwg, "USERI3", &useri3) &&
        useri3 == dwg->header_vars.USERI3)
      pass ("HEADER.USERI3 [BS] set+1 %hu", useri3);
    else
      {
        fail ("HEADER.USERI3 [BS] set+1 %hu != %hu", dwg->header_vars.USERI3, useri3); error++;
      }
    useri3--; dwg_dynapi_header_set_value(dwg, "USERI3", &useri3);

  }
  {
    BITCODE_BS useri4;
    if (dwg_dynapi_header_value(dwg, "USERI4", &useri4, NULL) &&
        useri4 == dwg->header_vars.USERI4)
      pass ("HEADER.USERI4 [BS] %hu", useri4);
    else
      {
        fail ("HEADER.USERI4 [BS] %hu != %hu", dwg->header_vars.USERI4, useri4); error++;
      }
    useri4++;
    if (dwg_dynapi_header_set_value(dwg, "USERI4", &useri4) &&
        useri4 == dwg->header_vars.USERI4)
      pass ("HEADER.USERI4 [BS] set+1 %hu", useri4);
    else
      {
        fail ("HEADER.USERI4 [BS] set+1 %hu != %hu", dwg->header_vars.USERI4, useri4); error++;
      }
    useri4--; dwg_dynapi_header_set_value(dwg, "USERI4", &useri4);

  }
  {
    BITCODE_BS useri5;
    if (dwg_dynapi_header_value(dwg, "USERI5", &useri5, NULL) &&
        useri5 == dwg->header_vars.USERI5)
      pass ("HEADER.USERI5 [BS] %hu", useri5);
    else
      {
        fail ("HEADER.USERI5 [BS] %hu != %hu", dwg->header_vars.USERI5, useri5); error++;
      }
    useri5++;
    if (dwg_dynapi_header_set_value(dwg, "USERI5", &useri5) &&
        useri5 == dwg->header_vars.USERI5)
      pass ("HEADER.USERI5 [BS] set+1 %hu", useri5);
    else
      {
        fail ("HEADER.USERI5 [BS] set+1 %hu != %hu", dwg->header_vars.USERI5, useri5); error++;
      }
    useri5--; dwg_dynapi_header_set_value(dwg, "USERI5", &useri5);

  }
  {
    BITCODE_BS splinesegs;
    if (dwg_dynapi_header_value(dwg, "SPLINESEGS", &splinesegs, NULL) &&
        splinesegs == dwg->header_vars.SPLINESEGS)
      pass ("HEADER.SPLINESEGS [BS] %hu", splinesegs);
    else
      {
        fail ("HEADER.SPLINESEGS [BS] %hu != %hu", dwg->header_vars.SPLINESEGS, splinesegs); error++;
      }
    splinesegs++;
    if (dwg_dynapi_header_set_value(dwg, "SPLINESEGS", &splinesegs) &&
        splinesegs == dwg->header_vars.SPLINESEGS)
      pass ("HEADER.SPLINESEGS [BS] set+1 %hu", splinesegs);
    else
      {
        fail ("HEADER.SPLINESEGS [BS] set+1 %hu != %hu", dwg->header_vars.SPLINESEGS, splinesegs); error++;
      }
    splinesegs--; dwg_dynapi_header_set_value(dwg, "SPLINESEGS", &splinesegs);

  }
  {
    BITCODE_BS surfu;
    if (dwg_dynapi_header_value(dwg, "SURFU", &surfu, NULL) &&
        surfu == dwg->header_vars.SURFU)
      pass ("HEADER.SURFU [BS] %hu", surfu);
    else
      {
        fail ("HEADER.SURFU [BS] %hu != %hu", dwg->header_vars.SURFU, surfu); error++;
      }
    surfu++;
    if (dwg_dynapi_header_set_value(dwg, "SURFU", &surfu) &&
        surfu == dwg->header_vars.SURFU)
      pass ("HEADER.SURFU [BS] set+1 %hu", surfu);
    else
      {
        fail ("HEADER.SURFU [BS] set+1 %hu != %hu", dwg->header_vars.SURFU, surfu); error++;
      }
    surfu--; dwg_dynapi_header_set_value(dwg, "SURFU", &surfu);

  }
  {
    BITCODE_BS surfv;
    if (dwg_dynapi_header_value(dwg, "SURFV", &surfv, NULL) &&
        surfv == dwg->header_vars.SURFV)
      pass ("HEADER.SURFV [BS] %hu", surfv);
    else
      {
        fail ("HEADER.SURFV [BS] %hu != %hu", dwg->header_vars.SURFV, surfv); error++;
      }
    surfv++;
    if (dwg_dynapi_header_set_value(dwg, "SURFV", &surfv) &&
        surfv == dwg->header_vars.SURFV)
      pass ("HEADER.SURFV [BS] set+1 %hu", surfv);
    else
      {
        fail ("HEADER.SURFV [BS] set+1 %hu != %hu", dwg->header_vars.SURFV, surfv); error++;
      }
    surfv--; dwg_dynapi_header_set_value(dwg, "SURFV", &surfv);

  }
  {
    BITCODE_BS surftype;
    if (dwg_dynapi_header_value(dwg, "SURFTYPE", &surftype, NULL) &&
        surftype == dwg->header_vars.SURFTYPE)
      pass ("HEADER.SURFTYPE [BS] %hu", surftype);
    else
      {
        fail ("HEADER.SURFTYPE [BS] %hu != %hu", dwg->header_vars.SURFTYPE, surftype); error++;
      }
    surftype++;
    if (dwg_dynapi_header_set_value(dwg, "SURFTYPE", &surftype) &&
        surftype == dwg->header_vars.SURFTYPE)
      pass ("HEADER.SURFTYPE [BS] set+1 %hu", surftype);
    else
      {
        fail ("HEADER.SURFTYPE [BS] set+1 %hu != %hu", dwg->header_vars.SURFTYPE, surftype); error++;
      }
    surftype--; dwg_dynapi_header_set_value(dwg, "SURFTYPE", &surftype);

  }
  {
    BITCODE_BS surftab1;
    if (dwg_dynapi_header_value(dwg, "SURFTAB1", &surftab1, NULL) &&
        surftab1 == dwg->header_vars.SURFTAB1)
      pass ("HEADER.SURFTAB1 [BS] %hu", surftab1);
    else
      {
        fail ("HEADER.SURFTAB1 [BS] %hu != %hu", dwg->header_vars.SURFTAB1, surftab1); error++;
      }
    surftab1++;
    if (dwg_dynapi_header_set_value(dwg, "SURFTAB1", &surftab1) &&
        surftab1 == dwg->header_vars.SURFTAB1)
      pass ("HEADER.SURFTAB1 [BS] set+1 %hu", surftab1);
    else
      {
        fail ("HEADER.SURFTAB1 [BS] set+1 %hu != %hu", dwg->header_vars.SURFTAB1, surftab1); error++;
      }
    surftab1--; dwg_dynapi_header_set_value(dwg, "SURFTAB1", &surftab1);

  }
  {
    BITCODE_BS surftab2;
    if (dwg_dynapi_header_value(dwg, "SURFTAB2", &surftab2, NULL) &&
        surftab2 == dwg->header_vars.SURFTAB2)
      pass ("HEADER.SURFTAB2 [BS] %hu", surftab2);
    else
      {
        fail ("HEADER.SURFTAB2 [BS] %hu != %hu", dwg->header_vars.SURFTAB2, surftab2); error++;
      }
    surftab2++;
    if (dwg_dynapi_header_set_value(dwg, "SURFTAB2", &surftab2) &&
        surftab2 == dwg->header_vars.SURFTAB2)
      pass ("HEADER.SURFTAB2 [BS] set+1 %hu", surftab2);
    else
      {
        fail ("HEADER.SURFTAB2 [BS] set+1 %hu != %hu", dwg->header_vars.SURFTAB2, surftab2); error++;
      }
    surftab2--; dwg_dynapi_header_set_value(dwg, "SURFTAB2", &surftab2);

  }
  {
    BITCODE_BS splinetype;
    if (dwg_dynapi_header_value(dwg, "SPLINETYPE", &splinetype, NULL) &&
        splinetype == dwg->header_vars.SPLINETYPE)
      pass ("HEADER.SPLINETYPE [BS] %hu", splinetype);
    else
      {
        fail ("HEADER.SPLINETYPE [BS] %hu != %hu", dwg->header_vars.SPLINETYPE, splinetype); error++;
      }
    splinetype++;
    if (dwg_dynapi_header_set_value(dwg, "SPLINETYPE", &splinetype) &&
        splinetype == dwg->header_vars.SPLINETYPE)
      pass ("HEADER.SPLINETYPE [BS] set+1 %hu", splinetype);
    else
      {
        fail ("HEADER.SPLINETYPE [BS] set+1 %hu != %hu", dwg->header_vars.SPLINETYPE, splinetype); error++;
      }
    splinetype--; dwg_dynapi_header_set_value(dwg, "SPLINETYPE", &splinetype);

  }
  {
    BITCODE_BS shadedge;
    if (dwg_dynapi_header_value(dwg, "SHADEDGE", &shadedge, NULL) &&
        shadedge == dwg->header_vars.SHADEDGE)
      pass ("HEADER.SHADEDGE [BS] %hu", shadedge);
    else
      {
        fail ("HEADER.SHADEDGE [BS] %hu != %hu", dwg->header_vars.SHADEDGE, shadedge); error++;
      }
    shadedge++;
    if (dwg_dynapi_header_set_value(dwg, "SHADEDGE", &shadedge) &&
        shadedge == dwg->header_vars.SHADEDGE)
      pass ("HEADER.SHADEDGE [BS] set+1 %hu", shadedge);
    else
      {
        fail ("HEADER.SHADEDGE [BS] set+1 %hu != %hu", dwg->header_vars.SHADEDGE, shadedge); error++;
      }
    shadedge--; dwg_dynapi_header_set_value(dwg, "SHADEDGE", &shadedge);

  }
  {
    BITCODE_BS shadedif;
    if (dwg_dynapi_header_value(dwg, "SHADEDIF", &shadedif, NULL) &&
        shadedif == dwg->header_vars.SHADEDIF)
      pass ("HEADER.SHADEDIF [BS] %hu", shadedif);
    else
      {
        fail ("HEADER.SHADEDIF [BS] %hu != %hu", dwg->header_vars.SHADEDIF, shadedif); error++;
      }
    shadedif++;
    if (dwg_dynapi_header_set_value(dwg, "SHADEDIF", &shadedif) &&
        shadedif == dwg->header_vars.SHADEDIF)
      pass ("HEADER.SHADEDIF [BS] set+1 %hu", shadedif);
    else
      {
        fail ("HEADER.SHADEDIF [BS] set+1 %hu != %hu", dwg->header_vars.SHADEDIF, shadedif); error++;
      }
    shadedif--; dwg_dynapi_header_set_value(dwg, "SHADEDIF", &shadedif);

  }
  {
    BITCODE_BS unitmode;
    if (dwg_dynapi_header_value(dwg, "UNITMODE", &unitmode, NULL) &&
        unitmode == dwg->header_vars.UNITMODE)
      pass ("HEADER.UNITMODE [BS] %hu", unitmode);
    else
      {
        fail ("HEADER.UNITMODE [BS] %hu != %hu", dwg->header_vars.UNITMODE, unitmode); error++;
      }
    unitmode++;
    if (dwg_dynapi_header_set_value(dwg, "UNITMODE", &unitmode) &&
        unitmode == dwg->header_vars.UNITMODE)
      pass ("HEADER.UNITMODE [BS] set+1 %hu", unitmode);
    else
      {
        fail ("HEADER.UNITMODE [BS] set+1 %hu != %hu", dwg->header_vars.UNITMODE, unitmode); error++;
      }
    unitmode--; dwg_dynapi_header_set_value(dwg, "UNITMODE", &unitmode);

  }
  {
    BITCODE_BS maxactvp;
    if (dwg_dynapi_header_value(dwg, "MAXACTVP", &maxactvp, NULL) &&
        maxactvp == dwg->header_vars.MAXACTVP)
      pass ("HEADER.MAXACTVP [BS] %hu", maxactvp);
    else
      {
        fail ("HEADER.MAXACTVP [BS] %hu != %hu", dwg->header_vars.MAXACTVP, maxactvp); error++;
      }
    maxactvp++;
    if (dwg_dynapi_header_set_value(dwg, "MAXACTVP", &maxactvp) &&
        maxactvp == dwg->header_vars.MAXACTVP)
      pass ("HEADER.MAXACTVP [BS] set+1 %hu", maxactvp);
    else
      {
        fail ("HEADER.MAXACTVP [BS] set+1 %hu != %hu", dwg->header_vars.MAXACTVP, maxactvp); error++;
      }
    maxactvp--; dwg_dynapi_header_set_value(dwg, "MAXACTVP", &maxactvp);

  }
  {
    BITCODE_BS isolines;
    if (dwg_dynapi_header_value(dwg, "ISOLINES", &isolines, NULL) &&
        isolines == dwg->header_vars.ISOLINES)
      pass ("HEADER.ISOLINES [BS] %hu", isolines);
    else
      {
        fail ("HEADER.ISOLINES [BS] %hu != %hu", dwg->header_vars.ISOLINES, isolines); error++;
      }
    isolines++;
    if (dwg_dynapi_header_set_value(dwg, "ISOLINES", &isolines) &&
        isolines == dwg->header_vars.ISOLINES)
      pass ("HEADER.ISOLINES [BS] set+1 %hu", isolines);
    else
      {
        fail ("HEADER.ISOLINES [BS] set+1 %hu != %hu", dwg->header_vars.ISOLINES, isolines); error++;
      }
    isolines--; dwg_dynapi_header_set_value(dwg, "ISOLINES", &isolines);

  }
  {
    BITCODE_BS cmljust;
    if (dwg_dynapi_header_value(dwg, "CMLJUST", &cmljust, NULL) &&
        cmljust == dwg->header_vars.CMLJUST)
      pass ("HEADER.CMLJUST [BS] %hu", cmljust);
    else
      {
        fail ("HEADER.CMLJUST [BS] %hu != %hu", dwg->header_vars.CMLJUST, cmljust); error++;
      }
    cmljust++;
    if (dwg_dynapi_header_set_value(dwg, "CMLJUST", &cmljust) &&
        cmljust == dwg->header_vars.CMLJUST)
      pass ("HEADER.CMLJUST [BS] set+1 %hu", cmljust);
    else
      {
        fail ("HEADER.CMLJUST [BS] set+1 %hu != %hu", dwg->header_vars.CMLJUST, cmljust); error++;
      }
    cmljust--; dwg_dynapi_header_set_value(dwg, "CMLJUST", &cmljust);

  }
  {
    BITCODE_BS textqlty;
    if (dwg_dynapi_header_value(dwg, "TEXTQLTY", &textqlty, NULL) &&
        textqlty == dwg->header_vars.TEXTQLTY)
      pass ("HEADER.TEXTQLTY [BS] %hu", textqlty);
    else
      {
        fail ("HEADER.TEXTQLTY [BS] %hu != %hu", dwg->header_vars.TEXTQLTY, textqlty); error++;
      }
    textqlty++;
    if (dwg_dynapi_header_set_value(dwg, "TEXTQLTY", &textqlty) &&
        textqlty == dwg->header_vars.TEXTQLTY)
      pass ("HEADER.TEXTQLTY [BS] set+1 %hu", textqlty);
    else
      {
        fail ("HEADER.TEXTQLTY [BS] set+1 %hu != %hu", dwg->header_vars.TEXTQLTY, textqlty); error++;
      }
    textqlty--; dwg_dynapi_header_set_value(dwg, "TEXTQLTY", &textqlty);

  }
  {
    BITCODE_BL unknown_14b;
    if (dwg_dynapi_header_value(dwg, "unknown_14b", &unknown_14b, NULL) &&
        unknown_14b == dwg->header_vars.unknown_14b)
      pass ("HEADER.unknown_14b [BL] %u", unknown_14b);
    else
      {
        fail ("HEADER.unknown_14b [BL] %u != %u", dwg->header_vars.unknown_14b, unknown_14b); error++;
      }
    unknown_14b++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_14b", &unknown_14b) &&
        unknown_14b == dwg->header_vars.unknown_14b)
      pass ("HEADER.unknown_14b [BL] set+1 %u", unknown_14b);
    else
      {
        fail ("HEADER.unknown_14b [BL] set+1 %u != %u", dwg->header_vars.unknown_14b, unknown_14b); error++;
      }
    unknown_14b--; dwg_dynapi_header_set_value(dwg, "unknown_14b", &unknown_14b);

  }
  {
    BITCODE_BD ltscale;
    if (dwg_dynapi_header_value(dwg, "LTSCALE", &ltscale, NULL) &&
        ltscale == dwg->header_vars.LTSCALE)
      pass ("HEADER.LTSCALE [BD] %g", ltscale);
    else
      {
        fail ("HEADER.LTSCALE [BD] %g != %g", dwg->header_vars.LTSCALE, ltscale); error++;
      }
    ltscale++;
    if (dwg_dynapi_header_set_value(dwg, "LTSCALE", &ltscale) &&
        ltscale == dwg->header_vars.LTSCALE)
      pass ("HEADER.LTSCALE [BD] set+1 %g", ltscale);
    else
      {
        fail ("HEADER.LTSCALE [BD] set+1 %g != %g", dwg->header_vars.LTSCALE, ltscale); error++;
      }
    ltscale--; dwg_dynapi_header_set_value(dwg, "LTSCALE", &ltscale);

  }
  {
    BITCODE_BD textsize;
    if (dwg_dynapi_header_value(dwg, "TEXTSIZE", &textsize, NULL) &&
        textsize == dwg->header_vars.TEXTSIZE)
      pass ("HEADER.TEXTSIZE [BD] %g", textsize);
    else
      {
        fail ("HEADER.TEXTSIZE [BD] %g != %g", dwg->header_vars.TEXTSIZE, textsize); error++;
      }
    textsize++;
    if (dwg_dynapi_header_set_value(dwg, "TEXTSIZE", &textsize) &&
        textsize == dwg->header_vars.TEXTSIZE)
      pass ("HEADER.TEXTSIZE [BD] set+1 %g", textsize);
    else
      {
        fail ("HEADER.TEXTSIZE [BD] set+1 %g != %g", dwg->header_vars.TEXTSIZE, textsize); error++;
      }
    textsize--; dwg_dynapi_header_set_value(dwg, "TEXTSIZE", &textsize);

  }
  {
    BITCODE_BD tracewid;
    if (dwg_dynapi_header_value(dwg, "TRACEWID", &tracewid, NULL) &&
        tracewid == dwg->header_vars.TRACEWID)
      pass ("HEADER.TRACEWID [BD] %g", tracewid);
    else
      {
        fail ("HEADER.TRACEWID [BD] %g != %g", dwg->header_vars.TRACEWID, tracewid); error++;
      }
    tracewid++;
    if (dwg_dynapi_header_set_value(dwg, "TRACEWID", &tracewid) &&
        tracewid == dwg->header_vars.TRACEWID)
      pass ("HEADER.TRACEWID [BD] set+1 %g", tracewid);
    else
      {
        fail ("HEADER.TRACEWID [BD] set+1 %g != %g", dwg->header_vars.TRACEWID, tracewid); error++;
      }
    tracewid--; dwg_dynapi_header_set_value(dwg, "TRACEWID", &tracewid);

  }
  {
    BITCODE_BD sketchinc;
    if (dwg_dynapi_header_value(dwg, "SKETCHINC", &sketchinc, NULL) &&
        sketchinc == dwg->header_vars.SKETCHINC)
      pass ("HEADER.SKETCHINC [BD] %g", sketchinc);
    else
      {
        fail ("HEADER.SKETCHINC [BD] %g != %g", dwg->header_vars.SKETCHINC, sketchinc); error++;
      }
    sketchinc++;
    if (dwg_dynapi_header_set_value(dwg, "SKETCHINC", &sketchinc) &&
        sketchinc == dwg->header_vars.SKETCHINC)
      pass ("HEADER.SKETCHINC [BD] set+1 %g", sketchinc);
    else
      {
        fail ("HEADER.SKETCHINC [BD] set+1 %g != %g", dwg->header_vars.SKETCHINC, sketchinc); error++;
      }
    sketchinc--; dwg_dynapi_header_set_value(dwg, "SKETCHINC", &sketchinc);

  }
  {
    BITCODE_BD filletrad;
    if (dwg_dynapi_header_value(dwg, "FILLETRAD", &filletrad, NULL) &&
        filletrad == dwg->header_vars.FILLETRAD)
      pass ("HEADER.FILLETRAD [BD] %g", filletrad);
    else
      {
        fail ("HEADER.FILLETRAD [BD] %g != %g", dwg->header_vars.FILLETRAD, filletrad); error++;
      }
    filletrad++;
    if (dwg_dynapi_header_set_value(dwg, "FILLETRAD", &filletrad) &&
        filletrad == dwg->header_vars.FILLETRAD)
      pass ("HEADER.FILLETRAD [BD] set+1 %g", filletrad);
    else
      {
        fail ("HEADER.FILLETRAD [BD] set+1 %g != %g", dwg->header_vars.FILLETRAD, filletrad); error++;
      }
    filletrad--; dwg_dynapi_header_set_value(dwg, "FILLETRAD", &filletrad);

  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_header_value(dwg, "THICKNESS", &thickness, NULL) &&
        thickness == dwg->header_vars.THICKNESS)
      pass ("HEADER.THICKNESS [BD] %g", thickness);
    else
      {
        fail ("HEADER.THICKNESS [BD] %g != %g", dwg->header_vars.THICKNESS, thickness); error++;
      }
    thickness++;
    if (dwg_dynapi_header_set_value(dwg, "THICKNESS", &thickness) &&
        thickness == dwg->header_vars.THICKNESS)
      pass ("HEADER.THICKNESS [BD] set+1 %g", thickness);
    else
      {
        fail ("HEADER.THICKNESS [BD] set+1 %g != %g", dwg->header_vars.THICKNESS, thickness); error++;
      }
    thickness--; dwg_dynapi_header_set_value(dwg, "THICKNESS", &thickness);

  }
  {
    BITCODE_BD angbase;
    if (dwg_dynapi_header_value(dwg, "ANGBASE", &angbase, NULL) &&
        angbase == dwg->header_vars.ANGBASE)
      pass ("HEADER.ANGBASE [BD] %g", angbase);
    else
      {
        fail ("HEADER.ANGBASE [BD] %g != %g", dwg->header_vars.ANGBASE, angbase); error++;
      }
    angbase++;
    if (dwg_dynapi_header_set_value(dwg, "ANGBASE", &angbase) &&
        angbase == dwg->header_vars.ANGBASE)
      pass ("HEADER.ANGBASE [BD] set+1 %g", angbase);
    else
      {
        fail ("HEADER.ANGBASE [BD] set+1 %g != %g", dwg->header_vars.ANGBASE, angbase); error++;
      }
    angbase--; dwg_dynapi_header_set_value(dwg, "ANGBASE", &angbase);

  }
  {
    BITCODE_BD pdsize;
    if (dwg_dynapi_header_value(dwg, "PDSIZE", &pdsize, NULL) &&
        pdsize == dwg->header_vars.PDSIZE)
      pass ("HEADER.PDSIZE [BD] %g", pdsize);
    else
      {
        fail ("HEADER.PDSIZE [BD] %g != %g", dwg->header_vars.PDSIZE, pdsize); error++;
      }
    pdsize++;
    if (dwg_dynapi_header_set_value(dwg, "PDSIZE", &pdsize) &&
        pdsize == dwg->header_vars.PDSIZE)
      pass ("HEADER.PDSIZE [BD] set+1 %g", pdsize);
    else
      {
        fail ("HEADER.PDSIZE [BD] set+1 %g != %g", dwg->header_vars.PDSIZE, pdsize); error++;
      }
    pdsize--; dwg_dynapi_header_set_value(dwg, "PDSIZE", &pdsize);

  }
  {
    BITCODE_BD plinewid;
    if (dwg_dynapi_header_value(dwg, "PLINEWID", &plinewid, NULL) &&
        plinewid == dwg->header_vars.PLINEWID)
      pass ("HEADER.PLINEWID [BD] %g", plinewid);
    else
      {
        fail ("HEADER.PLINEWID [BD] %g != %g", dwg->header_vars.PLINEWID, plinewid); error++;
      }
    plinewid++;
    if (dwg_dynapi_header_set_value(dwg, "PLINEWID", &plinewid) &&
        plinewid == dwg->header_vars.PLINEWID)
      pass ("HEADER.PLINEWID [BD] set+1 %g", plinewid);
    else
      {
        fail ("HEADER.PLINEWID [BD] set+1 %g != %g", dwg->header_vars.PLINEWID, plinewid); error++;
      }
    plinewid--; dwg_dynapi_header_set_value(dwg, "PLINEWID", &plinewid);

  }
  {
    BITCODE_BD userr1;
    if (dwg_dynapi_header_value(dwg, "USERR1", &userr1, NULL) &&
        userr1 == dwg->header_vars.USERR1)
      pass ("HEADER.USERR1 [BD] %g", userr1);
    else
      {
        fail ("HEADER.USERR1 [BD] %g != %g", dwg->header_vars.USERR1, userr1); error++;
      }
    userr1++;
    if (dwg_dynapi_header_set_value(dwg, "USERR1", &userr1) &&
        userr1 == dwg->header_vars.USERR1)
      pass ("HEADER.USERR1 [BD] set+1 %g", userr1);
    else
      {
        fail ("HEADER.USERR1 [BD] set+1 %g != %g", dwg->header_vars.USERR1, userr1); error++;
      }
    userr1--; dwg_dynapi_header_set_value(dwg, "USERR1", &userr1);

  }
  {
    BITCODE_BD userr2;
    if (dwg_dynapi_header_value(dwg, "USERR2", &userr2, NULL) &&
        userr2 == dwg->header_vars.USERR2)
      pass ("HEADER.USERR2 [BD] %g", userr2);
    else
      {
        fail ("HEADER.USERR2 [BD] %g != %g", dwg->header_vars.USERR2, userr2); error++;
      }
    userr2++;
    if (dwg_dynapi_header_set_value(dwg, "USERR2", &userr2) &&
        userr2 == dwg->header_vars.USERR2)
      pass ("HEADER.USERR2 [BD] set+1 %g", userr2);
    else
      {
        fail ("HEADER.USERR2 [BD] set+1 %g != %g", dwg->header_vars.USERR2, userr2); error++;
      }
    userr2--; dwg_dynapi_header_set_value(dwg, "USERR2", &userr2);

  }
  {
    BITCODE_BD userr3;
    if (dwg_dynapi_header_value(dwg, "USERR3", &userr3, NULL) &&
        userr3 == dwg->header_vars.USERR3)
      pass ("HEADER.USERR3 [BD] %g", userr3);
    else
      {
        fail ("HEADER.USERR3 [BD] %g != %g", dwg->header_vars.USERR3, userr3); error++;
      }
    userr3++;
    if (dwg_dynapi_header_set_value(dwg, "USERR3", &userr3) &&
        userr3 == dwg->header_vars.USERR3)
      pass ("HEADER.USERR3 [BD] set+1 %g", userr3);
    else
      {
        fail ("HEADER.USERR3 [BD] set+1 %g != %g", dwg->header_vars.USERR3, userr3); error++;
      }
    userr3--; dwg_dynapi_header_set_value(dwg, "USERR3", &userr3);

  }
  {
    BITCODE_BD userr4;
    if (dwg_dynapi_header_value(dwg, "USERR4", &userr4, NULL) &&
        userr4 == dwg->header_vars.USERR4)
      pass ("HEADER.USERR4 [BD] %g", userr4);
    else
      {
        fail ("HEADER.USERR4 [BD] %g != %g", dwg->header_vars.USERR4, userr4); error++;
      }
    userr4++;
    if (dwg_dynapi_header_set_value(dwg, "USERR4", &userr4) &&
        userr4 == dwg->header_vars.USERR4)
      pass ("HEADER.USERR4 [BD] set+1 %g", userr4);
    else
      {
        fail ("HEADER.USERR4 [BD] set+1 %g != %g", dwg->header_vars.USERR4, userr4); error++;
      }
    userr4--; dwg_dynapi_header_set_value(dwg, "USERR4", &userr4);

  }
  {
    BITCODE_BD userr5;
    if (dwg_dynapi_header_value(dwg, "USERR5", &userr5, NULL) &&
        userr5 == dwg->header_vars.USERR5)
      pass ("HEADER.USERR5 [BD] %g", userr5);
    else
      {
        fail ("HEADER.USERR5 [BD] %g != %g", dwg->header_vars.USERR5, userr5); error++;
      }
    userr5++;
    if (dwg_dynapi_header_set_value(dwg, "USERR5", &userr5) &&
        userr5 == dwg->header_vars.USERR5)
      pass ("HEADER.USERR5 [BD] set+1 %g", userr5);
    else
      {
        fail ("HEADER.USERR5 [BD] set+1 %g != %g", dwg->header_vars.USERR5, userr5); error++;
      }
    userr5--; dwg_dynapi_header_set_value(dwg, "USERR5", &userr5);

  }
  {
    BITCODE_BD chamfera;
    if (dwg_dynapi_header_value(dwg, "CHAMFERA", &chamfera, NULL) &&
        chamfera == dwg->header_vars.CHAMFERA)
      pass ("HEADER.CHAMFERA [BD] %g", chamfera);
    else
      {
        fail ("HEADER.CHAMFERA [BD] %g != %g", dwg->header_vars.CHAMFERA, chamfera); error++;
      }
    chamfera++;
    if (dwg_dynapi_header_set_value(dwg, "CHAMFERA", &chamfera) &&
        chamfera == dwg->header_vars.CHAMFERA)
      pass ("HEADER.CHAMFERA [BD] set+1 %g", chamfera);
    else
      {
        fail ("HEADER.CHAMFERA [BD] set+1 %g != %g", dwg->header_vars.CHAMFERA, chamfera); error++;
      }
    chamfera--; dwg_dynapi_header_set_value(dwg, "CHAMFERA", &chamfera);

  }
  {
    BITCODE_BD chamferb;
    if (dwg_dynapi_header_value(dwg, "CHAMFERB", &chamferb, NULL) &&
        chamferb == dwg->header_vars.CHAMFERB)
      pass ("HEADER.CHAMFERB [BD] %g", chamferb);
    else
      {
        fail ("HEADER.CHAMFERB [BD] %g != %g", dwg->header_vars.CHAMFERB, chamferb); error++;
      }
    chamferb++;
    if (dwg_dynapi_header_set_value(dwg, "CHAMFERB", &chamferb) &&
        chamferb == dwg->header_vars.CHAMFERB)
      pass ("HEADER.CHAMFERB [BD] set+1 %g", chamferb);
    else
      {
        fail ("HEADER.CHAMFERB [BD] set+1 %g != %g", dwg->header_vars.CHAMFERB, chamferb); error++;
      }
    chamferb--; dwg_dynapi_header_set_value(dwg, "CHAMFERB", &chamferb);

  }
  {
    BITCODE_BD chamferc;
    if (dwg_dynapi_header_value(dwg, "CHAMFERC", &chamferc, NULL) &&
        chamferc == dwg->header_vars.CHAMFERC)
      pass ("HEADER.CHAMFERC [BD] %g", chamferc);
    else
      {
        fail ("HEADER.CHAMFERC [BD] %g != %g", dwg->header_vars.CHAMFERC, chamferc); error++;
      }
    chamferc++;
    if (dwg_dynapi_header_set_value(dwg, "CHAMFERC", &chamferc) &&
        chamferc == dwg->header_vars.CHAMFERC)
      pass ("HEADER.CHAMFERC [BD] set+1 %g", chamferc);
    else
      {
        fail ("HEADER.CHAMFERC [BD] set+1 %g != %g", dwg->header_vars.CHAMFERC, chamferc); error++;
      }
    chamferc--; dwg_dynapi_header_set_value(dwg, "CHAMFERC", &chamferc);

  }
  {
    BITCODE_BD chamferd;
    if (dwg_dynapi_header_value(dwg, "CHAMFERD", &chamferd, NULL) &&
        chamferd == dwg->header_vars.CHAMFERD)
      pass ("HEADER.CHAMFERD [BD] %g", chamferd);
    else
      {
        fail ("HEADER.CHAMFERD [BD] %g != %g", dwg->header_vars.CHAMFERD, chamferd); error++;
      }
    chamferd++;
    if (dwg_dynapi_header_set_value(dwg, "CHAMFERD", &chamferd) &&
        chamferd == dwg->header_vars.CHAMFERD)
      pass ("HEADER.CHAMFERD [BD] set+1 %g", chamferd);
    else
      {
        fail ("HEADER.CHAMFERD [BD] set+1 %g != %g", dwg->header_vars.CHAMFERD, chamferd); error++;
      }
    chamferd--; dwg_dynapi_header_set_value(dwg, "CHAMFERD", &chamferd);

  }
  {
    BITCODE_BD facetres;
    if (dwg_dynapi_header_value(dwg, "FACETRES", &facetres, NULL) &&
        facetres == dwg->header_vars.FACETRES)
      pass ("HEADER.FACETRES [BD] %g", facetres);
    else
      {
        fail ("HEADER.FACETRES [BD] %g != %g", dwg->header_vars.FACETRES, facetres); error++;
      }
    facetres++;
    if (dwg_dynapi_header_set_value(dwg, "FACETRES", &facetres) &&
        facetres == dwg->header_vars.FACETRES)
      pass ("HEADER.FACETRES [BD] set+1 %g", facetres);
    else
      {
        fail ("HEADER.FACETRES [BD] set+1 %g != %g", dwg->header_vars.FACETRES, facetres); error++;
      }
    facetres--; dwg_dynapi_header_set_value(dwg, "FACETRES", &facetres);

  }
  {
    BITCODE_BD cmlscale;
    if (dwg_dynapi_header_value(dwg, "CMLSCALE", &cmlscale, NULL) &&
        cmlscale == dwg->header_vars.CMLSCALE)
      pass ("HEADER.CMLSCALE [BD] %g", cmlscale);
    else
      {
        fail ("HEADER.CMLSCALE [BD] %g != %g", dwg->header_vars.CMLSCALE, cmlscale); error++;
      }
    cmlscale++;
    if (dwg_dynapi_header_set_value(dwg, "CMLSCALE", &cmlscale) &&
        cmlscale == dwg->header_vars.CMLSCALE)
      pass ("HEADER.CMLSCALE [BD] set+1 %g", cmlscale);
    else
      {
        fail ("HEADER.CMLSCALE [BD] set+1 %g != %g", dwg->header_vars.CMLSCALE, cmlscale); error++;
      }
    cmlscale--; dwg_dynapi_header_set_value(dwg, "CMLSCALE", &cmlscale);

  }
  {
    BITCODE_BD celtscale;
    if (dwg_dynapi_header_value(dwg, "CELTSCALE", &celtscale, NULL) &&
        celtscale == dwg->header_vars.CELTSCALE)
      pass ("HEADER.CELTSCALE [BD] %g", celtscale);
    else
      {
        fail ("HEADER.CELTSCALE [BD] %g != %g", dwg->header_vars.CELTSCALE, celtscale); error++;
      }
    celtscale++;
    if (dwg_dynapi_header_set_value(dwg, "CELTSCALE", &celtscale) &&
        celtscale == dwg->header_vars.CELTSCALE)
      pass ("HEADER.CELTSCALE [BD] set+1 %g", celtscale);
    else
      {
        fail ("HEADER.CELTSCALE [BD] set+1 %g != %g", dwg->header_vars.CELTSCALE, celtscale); error++;
      }
    celtscale--; dwg_dynapi_header_set_value(dwg, "CELTSCALE", &celtscale);

  }
  {
    BITCODE_TV menu;
    if (dwg_dynapi_header_value(dwg, "MENU", &menu, NULL)
        && !memcmp(&menu, &dwg->header_vars.MENU, sizeof(dwg->header_vars.MENU))
       )
      pass ("HEADER.MENU [TV]");
    else
      {
        fail ("HEADER.MENU [TV]"); error++;
      }
  }
  {
    BITCODE_TIMEBLL tdcreate;
    if (dwg_dynapi_header_value(dwg, "TDCREATE", &tdcreate, NULL)
        && !memcmp(&tdcreate, &dwg->header_vars.TDCREATE, sizeof(dwg->header_vars.TDCREATE))
       )
      pass ("HEADER.TDCREATE [TIMEBLL]");
    else
      {
        fail ("HEADER.TDCREATE [TIMEBLL]"); error++;
      }
  }
  {
    BITCODE_TIMEBLL tdupdate;
    if (dwg_dynapi_header_value(dwg, "TDUPDATE", &tdupdate, NULL)
        && !memcmp(&tdupdate, &dwg->header_vars.TDUPDATE, sizeof(dwg->header_vars.TDUPDATE))
       )
      pass ("HEADER.TDUPDATE [TIMEBLL]");
    else
      {
        fail ("HEADER.TDUPDATE [TIMEBLL]"); error++;
      }
  }
  {
    BITCODE_BL unknown_15;
    if (dwg_dynapi_header_value(dwg, "unknown_15", &unknown_15, NULL) &&
        unknown_15 == dwg->header_vars.unknown_15)
      pass ("HEADER.unknown_15 [BL] %u", unknown_15);
    else
      {
        fail ("HEADER.unknown_15 [BL] %u != %u", dwg->header_vars.unknown_15, unknown_15); error++;
      }
    unknown_15++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_15", &unknown_15) &&
        unknown_15 == dwg->header_vars.unknown_15)
      pass ("HEADER.unknown_15 [BL] set+1 %u", unknown_15);
    else
      {
        fail ("HEADER.unknown_15 [BL] set+1 %u != %u", dwg->header_vars.unknown_15, unknown_15); error++;
      }
    unknown_15--; dwg_dynapi_header_set_value(dwg, "unknown_15", &unknown_15);

  }
  {
    BITCODE_BL unknown_16;
    if (dwg_dynapi_header_value(dwg, "unknown_16", &unknown_16, NULL) &&
        unknown_16 == dwg->header_vars.unknown_16)
      pass ("HEADER.unknown_16 [BL] %u", unknown_16);
    else
      {
        fail ("HEADER.unknown_16 [BL] %u != %u", dwg->header_vars.unknown_16, unknown_16); error++;
      }
    unknown_16++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_16", &unknown_16) &&
        unknown_16 == dwg->header_vars.unknown_16)
      pass ("HEADER.unknown_16 [BL] set+1 %u", unknown_16);
    else
      {
        fail ("HEADER.unknown_16 [BL] set+1 %u != %u", dwg->header_vars.unknown_16, unknown_16); error++;
      }
    unknown_16--; dwg_dynapi_header_set_value(dwg, "unknown_16", &unknown_16);

  }
  {
    BITCODE_BL unknown_17;
    if (dwg_dynapi_header_value(dwg, "unknown_17", &unknown_17, NULL) &&
        unknown_17 == dwg->header_vars.unknown_17)
      pass ("HEADER.unknown_17 [BL] %u", unknown_17);
    else
      {
        fail ("HEADER.unknown_17 [BL] %u != %u", dwg->header_vars.unknown_17, unknown_17); error++;
      }
    unknown_17++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_17", &unknown_17) &&
        unknown_17 == dwg->header_vars.unknown_17)
      pass ("HEADER.unknown_17 [BL] set+1 %u", unknown_17);
    else
      {
        fail ("HEADER.unknown_17 [BL] set+1 %u != %u", dwg->header_vars.unknown_17, unknown_17); error++;
      }
    unknown_17--; dwg_dynapi_header_set_value(dwg, "unknown_17", &unknown_17);

  }
  {
    BITCODE_TIMEBLL tdindwg;
    if (dwg_dynapi_header_value(dwg, "TDINDWG", &tdindwg, NULL)
        && !memcmp(&tdindwg, &dwg->header_vars.TDINDWG, sizeof(dwg->header_vars.TDINDWG))
       )
      pass ("HEADER.TDINDWG [TIMEBLL]");
    else
      {
        fail ("HEADER.TDINDWG [TIMEBLL]"); error++;
      }
  }
  {
    BITCODE_TIMEBLL tdusrtimer;
    if (dwg_dynapi_header_value(dwg, "TDUSRTIMER", &tdusrtimer, NULL)
        && !memcmp(&tdusrtimer, &dwg->header_vars.TDUSRTIMER, sizeof(dwg->header_vars.TDUSRTIMER))
       )
      pass ("HEADER.TDUSRTIMER [TIMEBLL]");
    else
      {
        fail ("HEADER.TDUSRTIMER [TIMEBLL]"); error++;
      }
  }
  {
    BITCODE_CMC cecolor;
    if (dwg_dynapi_header_value(dwg, "CECOLOR", &cecolor, NULL)
        && !memcmp(&cecolor, &dwg->header_vars.CECOLOR, sizeof(dwg->header_vars.CECOLOR))
       )
      pass ("HEADER.CECOLOR [CMC]");
    else
      {
        fail ("HEADER.CECOLOR [CMC]"); error++;
      }
  }
  {
    BITCODE_RS cecolor_idx;
    if (dwg_dynapi_header_value(dwg, "CECOLOR_idx", &cecolor_idx, NULL) &&
        cecolor_idx == dwg->header_vars.CECOLOR_idx)
      pass ("HEADER.CECOLOR_idx [RS] %hu", cecolor_idx);
    else
      {
        fail ("HEADER.CECOLOR_idx [RS] %hu != %hu", dwg->header_vars.CECOLOR_idx, cecolor_idx); error++;
      }
    cecolor_idx++;
    if (dwg_dynapi_header_set_value(dwg, "CECOLOR_idx", &cecolor_idx) &&
        cecolor_idx == dwg->header_vars.CECOLOR_idx)
      pass ("HEADER.CECOLOR_idx [RS] set+1 %hu", cecolor_idx);
    else
      {
        fail ("HEADER.CECOLOR_idx [RS] set+1 %hu != %hu", dwg->header_vars.CECOLOR_idx, cecolor_idx); error++;
      }
    cecolor_idx--; dwg_dynapi_header_set_value(dwg, "CECOLOR_idx", &cecolor_idx);

  }
  {
    BITCODE_BS handling;
    if (dwg_dynapi_header_value(dwg, "HANDLING", &handling, NULL) &&
        handling == dwg->header_vars.HANDLING)
      pass ("HEADER.HANDLING [BS] %hu", handling);
    else
      {
        fail ("HEADER.HANDLING [BS] %hu != %hu", dwg->header_vars.HANDLING, handling); error++;
      }
    handling++;
    if (dwg_dynapi_header_set_value(dwg, "HANDLING", &handling) &&
        handling == dwg->header_vars.HANDLING)
      pass ("HEADER.HANDLING [BS] set+1 %hu", handling);
    else
      {
        fail ("HEADER.HANDLING [BS] set+1 %hu != %hu", dwg->header_vars.HANDLING, handling); error++;
      }
    handling--; dwg_dynapi_header_set_value(dwg, "HANDLING", &handling);

  }
  {
    BITCODE_RS handseed_r11;
    if (dwg_dynapi_header_value(dwg, "HANDSEED_R11", &handseed_r11, NULL) &&
        handseed_r11 == dwg->header_vars.HANDSEED_R11)
      pass ("HEADER.HANDSEED_R11 [RS] %hu", handseed_r11);
    else
      {
        fail ("HEADER.HANDSEED_R11 [RS] %hu != %hu", dwg->header_vars.HANDSEED_R11, handseed_r11); error++;
      }
    handseed_r11++;
    if (dwg_dynapi_header_set_value(dwg, "HANDSEED_R11", &handseed_r11) &&
        handseed_r11 == dwg->header_vars.HANDSEED_R11)
      pass ("HEADER.HANDSEED_R11 [RS] set+1 %hu", handseed_r11);
    else
      {
        fail ("HEADER.HANDSEED_R11 [RS] set+1 %hu != %hu", dwg->header_vars.HANDSEED_R11, handseed_r11); error++;
      }
    handseed_r11--; dwg_dynapi_header_set_value(dwg, "HANDSEED_R11", &handseed_r11);

  }
  {
    BITCODE_H handseed;
    if (dwg_dynapi_header_value(dwg, "HANDSEED", &handseed, NULL)
        && !memcmp(&handseed, &dwg->header_vars.HANDSEED, sizeof(dwg->header_vars.HANDSEED))
       )
      pass ("HEADER.HANDSEED [H]");
    else
      {
        fail ("HEADER.HANDSEED [H]"); error++;
      }
  }
  {
    BITCODE_H clayer;
    if (dwg_dynapi_header_value(dwg, "CLAYER", &clayer, NULL)
        && !memcmp(&clayer, &dwg->header_vars.CLAYER, sizeof(dwg->header_vars.CLAYER))
       )
      pass ("HEADER.CLAYER [H]");
    else
      {
        fail ("HEADER.CLAYER [H]"); error++;
      }
  }
  {
    BITCODE_H textstyle;
    if (dwg_dynapi_header_value(dwg, "TEXTSTYLE", &textstyle, NULL)
        && !memcmp(&textstyle, &dwg->header_vars.TEXTSTYLE, sizeof(dwg->header_vars.TEXTSTYLE))
       )
      pass ("HEADER.TEXTSTYLE [H]");
    else
      {
        fail ("HEADER.TEXTSTYLE [H]"); error++;
      }
  }
  {
    BITCODE_H celtype;
    if (dwg_dynapi_header_value(dwg, "CELTYPE", &celtype, NULL)
        && !memcmp(&celtype, &dwg->header_vars.CELTYPE, sizeof(dwg->header_vars.CELTYPE))
       )
      pass ("HEADER.CELTYPE [H]");
    else
      {
        fail ("HEADER.CELTYPE [H]"); error++;
      }
  }
  {
    BITCODE_H cmaterial;
    if (dwg_dynapi_header_value(dwg, "CMATERIAL", &cmaterial, NULL)
        && !memcmp(&cmaterial, &dwg->header_vars.CMATERIAL, sizeof(dwg->header_vars.CMATERIAL))
       )
      pass ("HEADER.CMATERIAL [H]");
    else
      {
        fail ("HEADER.CMATERIAL [H]"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_header_value(dwg, "DIMSTYLE", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dwg->header_vars.DIMSTYLE, sizeof(dwg->header_vars.DIMSTYLE))
       )
      pass ("HEADER.DIMSTYLE [H]");
    else
      {
        fail ("HEADER.DIMSTYLE [H]"); error++;
      }
  }
  {
    BITCODE_H cmlstyle;
    if (dwg_dynapi_header_value(dwg, "CMLSTYLE", &cmlstyle, NULL)
        && !memcmp(&cmlstyle, &dwg->header_vars.CMLSTYLE, sizeof(dwg->header_vars.CMLSTYLE))
       )
      pass ("HEADER.CMLSTYLE [H]");
    else
      {
        fail ("HEADER.CMLSTYLE [H]"); error++;
      }
  }
  {
    BITCODE_BD psvpscale;
    if (dwg_dynapi_header_value(dwg, "PSVPSCALE", &psvpscale, NULL) &&
        psvpscale == dwg->header_vars.PSVPSCALE)
      pass ("HEADER.PSVPSCALE [BD] %g", psvpscale);
    else
      {
        fail ("HEADER.PSVPSCALE [BD] %g != %g", dwg->header_vars.PSVPSCALE, psvpscale); error++;
      }
    psvpscale++;
    if (dwg_dynapi_header_set_value(dwg, "PSVPSCALE", &psvpscale) &&
        psvpscale == dwg->header_vars.PSVPSCALE)
      pass ("HEADER.PSVPSCALE [BD] set+1 %g", psvpscale);
    else
      {
        fail ("HEADER.PSVPSCALE [BD] set+1 %g != %g", dwg->header_vars.PSVPSCALE, psvpscale); error++;
      }
    psvpscale--; dwg_dynapi_header_set_value(dwg, "PSVPSCALE", &psvpscale);

  }
  {
    BITCODE_3BD pinsbase;
    if (dwg_dynapi_header_value(dwg, "PINSBASE", &pinsbase, NULL)
        && !memcmp(&pinsbase, &dwg->header_vars.PINSBASE, sizeof(dwg->header_vars.PINSBASE))
       )
      pass ("HEADER.PINSBASE [3BD]");
    else
      {
        fail ("HEADER.PINSBASE [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pextmin;
    if (dwg_dynapi_header_value(dwg, "PEXTMIN", &pextmin, NULL)
        && !memcmp(&pextmin, &dwg->header_vars.PEXTMIN, sizeof(dwg->header_vars.PEXTMIN))
       )
      pass ("HEADER.PEXTMIN [3BD]");
    else
      {
        fail ("HEADER.PEXTMIN [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pextmax;
    if (dwg_dynapi_header_value(dwg, "PEXTMAX", &pextmax, NULL)
        && !memcmp(&pextmax, &dwg->header_vars.PEXTMAX, sizeof(dwg->header_vars.PEXTMAX))
       )
      pass ("HEADER.PEXTMAX [3BD]");
    else
      {
        fail ("HEADER.PEXTMAX [3BD]"); error++;
      }
  }
  {
    BITCODE_2RD plimmin;
    if (dwg_dynapi_header_value(dwg, "PLIMMIN", &plimmin, NULL)
        && !memcmp(&plimmin, &dwg->header_vars.PLIMMIN, sizeof(dwg->header_vars.PLIMMIN))
       )
      pass ("HEADER.PLIMMIN [2RD]");
    else
      {
        fail ("HEADER.PLIMMIN [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD plimmax;
    if (dwg_dynapi_header_value(dwg, "PLIMMAX", &plimmax, NULL)
        && !memcmp(&plimmax, &dwg->header_vars.PLIMMAX, sizeof(dwg->header_vars.PLIMMAX))
       )
      pass ("HEADER.PLIMMAX [2RD]");
    else
      {
        fail ("HEADER.PLIMMAX [2RD]"); error++;
      }
  }
  {
    BITCODE_BD pelevation;
    if (dwg_dynapi_header_value(dwg, "PELEVATION", &pelevation, NULL) &&
        pelevation == dwg->header_vars.PELEVATION)
      pass ("HEADER.PELEVATION [BD] %g", pelevation);
    else
      {
        fail ("HEADER.PELEVATION [BD] %g != %g", dwg->header_vars.PELEVATION, pelevation); error++;
      }
    pelevation++;
    if (dwg_dynapi_header_set_value(dwg, "PELEVATION", &pelevation) &&
        pelevation == dwg->header_vars.PELEVATION)
      pass ("HEADER.PELEVATION [BD] set+1 %g", pelevation);
    else
      {
        fail ("HEADER.PELEVATION [BD] set+1 %g != %g", dwg->header_vars.PELEVATION, pelevation); error++;
      }
    pelevation--; dwg_dynapi_header_set_value(dwg, "PELEVATION", &pelevation);

  }
  {
    BITCODE_3BD pucsorg;
    if (dwg_dynapi_header_value(dwg, "PUCSORG", &pucsorg, NULL)
        && !memcmp(&pucsorg, &dwg->header_vars.PUCSORG, sizeof(dwg->header_vars.PUCSORG))
       )
      pass ("HEADER.PUCSORG [3BD]");
    else
      {
        fail ("HEADER.PUCSORG [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pucsxdir;
    if (dwg_dynapi_header_value(dwg, "PUCSXDIR", &pucsxdir, NULL)
        && !memcmp(&pucsxdir, &dwg->header_vars.PUCSXDIR, sizeof(dwg->header_vars.PUCSXDIR))
       )
      pass ("HEADER.PUCSXDIR [3BD]");
    else
      {
        fail ("HEADER.PUCSXDIR [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pucsydir;
    if (dwg_dynapi_header_value(dwg, "PUCSYDIR", &pucsydir, NULL)
        && !memcmp(&pucsydir, &dwg->header_vars.PUCSYDIR, sizeof(dwg->header_vars.PUCSYDIR))
       )
      pass ("HEADER.PUCSYDIR [3BD]");
    else
      {
        fail ("HEADER.PUCSYDIR [3BD]"); error++;
      }
  }
  {
    BITCODE_H pucsname;
    if (dwg_dynapi_header_value(dwg, "PUCSNAME", &pucsname, NULL)
        && !memcmp(&pucsname, &dwg->header_vars.PUCSNAME, sizeof(dwg->header_vars.PUCSNAME))
       )
      pass ("HEADER.PUCSNAME [H]");
    else
      {
        fail ("HEADER.PUCSNAME [H]"); error++;
      }
  }
  {
    BITCODE_H pucsbase;
    if (dwg_dynapi_header_value(dwg, "PUCSBASE", &pucsbase, NULL)
        && !memcmp(&pucsbase, &dwg->header_vars.PUCSBASE, sizeof(dwg->header_vars.PUCSBASE))
       )
      pass ("HEADER.PUCSBASE [H]");
    else
      {
        fail ("HEADER.PUCSBASE [H]"); error++;
      }
  }
  {
    BITCODE_H pucsorthoref;
    if (dwg_dynapi_header_value(dwg, "PUCSORTHOREF", &pucsorthoref, NULL)
        && !memcmp(&pucsorthoref, &dwg->header_vars.PUCSORTHOREF, sizeof(dwg->header_vars.PUCSORTHOREF))
       )
      pass ("HEADER.PUCSORTHOREF [H]");
    else
      {
        fail ("HEADER.PUCSORTHOREF [H]"); error++;
      }
  }
  {
    BITCODE_BS pucsorthoview;
    if (dwg_dynapi_header_value(dwg, "PUCSORTHOVIEW", &pucsorthoview, NULL) &&
        pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
      pass ("HEADER.PUCSORTHOVIEW [BS] %hu", pucsorthoview);
    else
      {
        fail ("HEADER.PUCSORTHOVIEW [BS] %hu != %hu", dwg->header_vars.PUCSORTHOVIEW, pucsorthoview); error++;
      }
    pucsorthoview++;
    if (dwg_dynapi_header_set_value(dwg, "PUCSORTHOVIEW", &pucsorthoview) &&
        pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
      pass ("HEADER.PUCSORTHOVIEW [BS] set+1 %hu", pucsorthoview);
    else
      {
        fail ("HEADER.PUCSORTHOVIEW [BS] set+1 %hu != %hu", dwg->header_vars.PUCSORTHOVIEW, pucsorthoview); error++;
      }
    pucsorthoview--; dwg_dynapi_header_set_value(dwg, "PUCSORTHOVIEW", &pucsorthoview);

  }
  {
    BITCODE_3BD pucsorgtop;
    if (dwg_dynapi_header_value(dwg, "PUCSORGTOP", &pucsorgtop, NULL)
        && !memcmp(&pucsorgtop, &dwg->header_vars.PUCSORGTOP, sizeof(dwg->header_vars.PUCSORGTOP))
       )
      pass ("HEADER.PUCSORGTOP [3BD]");
    else
      {
        fail ("HEADER.PUCSORGTOP [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pucsorgbottom;
    if (dwg_dynapi_header_value(dwg, "PUCSORGBOTTOM", &pucsorgbottom, NULL)
        && !memcmp(&pucsorgbottom, &dwg->header_vars.PUCSORGBOTTOM, sizeof(dwg->header_vars.PUCSORGBOTTOM))
       )
      pass ("HEADER.PUCSORGBOTTOM [3BD]");
    else
      {
        fail ("HEADER.PUCSORGBOTTOM [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pucsorgleft;
    if (dwg_dynapi_header_value(dwg, "PUCSORGLEFT", &pucsorgleft, NULL)
        && !memcmp(&pucsorgleft, &dwg->header_vars.PUCSORGLEFT, sizeof(dwg->header_vars.PUCSORGLEFT))
       )
      pass ("HEADER.PUCSORGLEFT [3BD]");
    else
      {
        fail ("HEADER.PUCSORGLEFT [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pucsorgright;
    if (dwg_dynapi_header_value(dwg, "PUCSORGRIGHT", &pucsorgright, NULL)
        && !memcmp(&pucsorgright, &dwg->header_vars.PUCSORGRIGHT, sizeof(dwg->header_vars.PUCSORGRIGHT))
       )
      pass ("HEADER.PUCSORGRIGHT [3BD]");
    else
      {
        fail ("HEADER.PUCSORGRIGHT [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pucsorgfront;
    if (dwg_dynapi_header_value(dwg, "PUCSORGFRONT", &pucsorgfront, NULL)
        && !memcmp(&pucsorgfront, &dwg->header_vars.PUCSORGFRONT, sizeof(dwg->header_vars.PUCSORGFRONT))
       )
      pass ("HEADER.PUCSORGFRONT [3BD]");
    else
      {
        fail ("HEADER.PUCSORGFRONT [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD pucsorgback;
    if (dwg_dynapi_header_value(dwg, "PUCSORGBACK", &pucsorgback, NULL)
        && !memcmp(&pucsorgback, &dwg->header_vars.PUCSORGBACK, sizeof(dwg->header_vars.PUCSORGBACK))
       )
      pass ("HEADER.PUCSORGBACK [3BD]");
    else
      {
        fail ("HEADER.PUCSORGBACK [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD insbase;
    if (dwg_dynapi_header_value(dwg, "INSBASE", &insbase, NULL)
        && !memcmp(&insbase, &dwg->header_vars.INSBASE, sizeof(dwg->header_vars.INSBASE))
       )
      pass ("HEADER.INSBASE [3BD]");
    else
      {
        fail ("HEADER.INSBASE [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD extmin;
    if (dwg_dynapi_header_value(dwg, "EXTMIN", &extmin, NULL)
        && !memcmp(&extmin, &dwg->header_vars.EXTMIN, sizeof(dwg->header_vars.EXTMIN))
       )
      pass ("HEADER.EXTMIN [3BD]");
    else
      {
        fail ("HEADER.EXTMIN [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD extmax;
    if (dwg_dynapi_header_value(dwg, "EXTMAX", &extmax, NULL)
        && !memcmp(&extmax, &dwg->header_vars.EXTMAX, sizeof(dwg->header_vars.EXTMAX))
       )
      pass ("HEADER.EXTMAX [3BD]");
    else
      {
        fail ("HEADER.EXTMAX [3BD]"); error++;
      }
  }
  {
    BITCODE_2RD limmin;
    if (dwg_dynapi_header_value(dwg, "LIMMIN", &limmin, NULL)
        && !memcmp(&limmin, &dwg->header_vars.LIMMIN, sizeof(dwg->header_vars.LIMMIN))
       )
      pass ("HEADER.LIMMIN [2RD]");
    else
      {
        fail ("HEADER.LIMMIN [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD limmax;
    if (dwg_dynapi_header_value(dwg, "LIMMAX", &limmax, NULL)
        && !memcmp(&limmax, &dwg->header_vars.LIMMAX, sizeof(dwg->header_vars.LIMMAX))
       )
      pass ("HEADER.LIMMAX [2RD]");
    else
      {
        fail ("HEADER.LIMMAX [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD viewctr;
    if (dwg_dynapi_header_value(dwg, "VIEWCTR", &viewctr, NULL)
        && !memcmp(&viewctr, &dwg->header_vars.VIEWCTR, sizeof(dwg->header_vars.VIEWCTR))
       )
      pass ("HEADER.VIEWCTR [2RD]");
    else
      {
        fail ("HEADER.VIEWCTR [2RD]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_header_value(dwg, "ELEVATION", &elevation, NULL) &&
        elevation == dwg->header_vars.ELEVATION)
      pass ("HEADER.ELEVATION [BD] %g", elevation);
    else
      {
        fail ("HEADER.ELEVATION [BD] %g != %g", dwg->header_vars.ELEVATION, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_header_set_value(dwg, "ELEVATION", &elevation) &&
        elevation == dwg->header_vars.ELEVATION)
      pass ("HEADER.ELEVATION [BD] set+1 %g", elevation);
    else
      {
        fail ("HEADER.ELEVATION [BD] set+1 %g != %g", dwg->header_vars.ELEVATION, elevation); error++;
      }
    elevation--; dwg_dynapi_header_set_value(dwg, "ELEVATION", &elevation);

  }
  {
    BITCODE_RD viewsize;
    if (dwg_dynapi_header_value(dwg, "VIEWSIZE", &viewsize, NULL) &&
        viewsize == dwg->header_vars.VIEWSIZE)
      pass ("HEADER.VIEWSIZE [RD] %g", viewsize);
    else
      {
        fail ("HEADER.VIEWSIZE [RD] %g != %g", dwg->header_vars.VIEWSIZE, viewsize); error++;
      }
    viewsize++;
    if (dwg_dynapi_header_set_value(dwg, "VIEWSIZE", &viewsize) &&
        viewsize == dwg->header_vars.VIEWSIZE)
      pass ("HEADER.VIEWSIZE [RD] set+1 %g", viewsize);
    else
      {
        fail ("HEADER.VIEWSIZE [RD] set+1 %g != %g", dwg->header_vars.VIEWSIZE, viewsize); error++;
      }
    viewsize--; dwg_dynapi_header_set_value(dwg, "VIEWSIZE", &viewsize);

  }
  {
    BITCODE_RS snapmode;
    if (dwg_dynapi_header_value(dwg, "SNAPMODE", &snapmode, NULL) &&
        snapmode == dwg->header_vars.SNAPMODE)
      pass ("HEADER.SNAPMODE [RS] %hu", snapmode);
    else
      {
        fail ("HEADER.SNAPMODE [RS] %hu != %hu", dwg->header_vars.SNAPMODE, snapmode); error++;
      }
    snapmode++;
    if (dwg_dynapi_header_set_value(dwg, "SNAPMODE", &snapmode) &&
        snapmode == dwg->header_vars.SNAPMODE)
      pass ("HEADER.SNAPMODE [RS] set+1 %hu", snapmode);
    else
      {
        fail ("HEADER.SNAPMODE [RS] set+1 %hu != %hu", dwg->header_vars.SNAPMODE, snapmode); error++;
      }
    snapmode--; dwg_dynapi_header_set_value(dwg, "SNAPMODE", &snapmode);

  }
  {
    BITCODE_2RD snapunit;
    if (dwg_dynapi_header_value(dwg, "SNAPUNIT", &snapunit, NULL)
        && !memcmp(&snapunit, &dwg->header_vars.SNAPUNIT, sizeof(dwg->header_vars.SNAPUNIT))
       )
      pass ("HEADER.SNAPUNIT [2RD]");
    else
      {
        fail ("HEADER.SNAPUNIT [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD snapbase;
    if (dwg_dynapi_header_value(dwg, "SNAPBASE", &snapbase, NULL)
        && !memcmp(&snapbase, &dwg->header_vars.SNAPBASE, sizeof(dwg->header_vars.SNAPBASE))
       )
      pass ("HEADER.SNAPBASE [2RD]");
    else
      {
        fail ("HEADER.SNAPBASE [2RD]"); error++;
      }
  }
  {
    BITCODE_RD snapang;
    if (dwg_dynapi_header_value(dwg, "SNAPANG", &snapang, NULL) &&
        snapang == dwg->header_vars.SNAPANG)
      pass ("HEADER.SNAPANG [RD] %g", snapang);
    else
      {
        fail ("HEADER.SNAPANG [RD] %g != %g", dwg->header_vars.SNAPANG, snapang); error++;
      }
    snapang++;
    if (dwg_dynapi_header_set_value(dwg, "SNAPANG", &snapang) &&
        snapang == dwg->header_vars.SNAPANG)
      pass ("HEADER.SNAPANG [RD] set+1 %g", snapang);
    else
      {
        fail ("HEADER.SNAPANG [RD] set+1 %g != %g", dwg->header_vars.SNAPANG, snapang); error++;
      }
    snapang--; dwg_dynapi_header_set_value(dwg, "SNAPANG", &snapang);

  }
  {
    BITCODE_RS snapstyl;
    if (dwg_dynapi_header_value(dwg, "SNAPSTYL", &snapstyl, NULL) &&
        snapstyl == dwg->header_vars.SNAPSTYL)
      pass ("HEADER.SNAPSTYL [RS] %hu", snapstyl);
    else
      {
        fail ("HEADER.SNAPSTYL [RS] %hu != %hu", dwg->header_vars.SNAPSTYL, snapstyl); error++;
      }
    snapstyl++;
    if (dwg_dynapi_header_set_value(dwg, "SNAPSTYL", &snapstyl) &&
        snapstyl == dwg->header_vars.SNAPSTYL)
      pass ("HEADER.SNAPSTYL [RS] set+1 %hu", snapstyl);
    else
      {
        fail ("HEADER.SNAPSTYL [RS] set+1 %hu != %hu", dwg->header_vars.SNAPSTYL, snapstyl); error++;
      }
    snapstyl--; dwg_dynapi_header_set_value(dwg, "SNAPSTYL", &snapstyl);

  }
  {
    BITCODE_RS snapisopair;
    if (dwg_dynapi_header_value(dwg, "SNAPISOPAIR", &snapisopair, NULL) &&
        snapisopair == dwg->header_vars.SNAPISOPAIR)
      pass ("HEADER.SNAPISOPAIR [RS] %hu", snapisopair);
    else
      {
        fail ("HEADER.SNAPISOPAIR [RS] %hu != %hu", dwg->header_vars.SNAPISOPAIR, snapisopair); error++;
      }
    snapisopair++;
    if (dwg_dynapi_header_set_value(dwg, "SNAPISOPAIR", &snapisopair) &&
        snapisopair == dwg->header_vars.SNAPISOPAIR)
      pass ("HEADER.SNAPISOPAIR [RS] set+1 %hu", snapisopair);
    else
      {
        fail ("HEADER.SNAPISOPAIR [RS] set+1 %hu != %hu", dwg->header_vars.SNAPISOPAIR, snapisopair); error++;
      }
    snapisopair--; dwg_dynapi_header_set_value(dwg, "SNAPISOPAIR", &snapisopair);

  }
  {
    BITCODE_RS gridmode;
    if (dwg_dynapi_header_value(dwg, "GRIDMODE", &gridmode, NULL) &&
        gridmode == dwg->header_vars.GRIDMODE)
      pass ("HEADER.GRIDMODE [RS] %hu", gridmode);
    else
      {
        fail ("HEADER.GRIDMODE [RS] %hu != %hu", dwg->header_vars.GRIDMODE, gridmode); error++;
      }
    gridmode++;
    if (dwg_dynapi_header_set_value(dwg, "GRIDMODE", &gridmode) &&
        gridmode == dwg->header_vars.GRIDMODE)
      pass ("HEADER.GRIDMODE [RS] set+1 %hu", gridmode);
    else
      {
        fail ("HEADER.GRIDMODE [RS] set+1 %hu != %hu", dwg->header_vars.GRIDMODE, gridmode); error++;
      }
    gridmode--; dwg_dynapi_header_set_value(dwg, "GRIDMODE", &gridmode);

  }
  {
    BITCODE_2RD gridunit;
    if (dwg_dynapi_header_value(dwg, "GRIDUNIT", &gridunit, NULL)
        && !memcmp(&gridunit, &dwg->header_vars.GRIDUNIT, sizeof(dwg->header_vars.GRIDUNIT))
       )
      pass ("HEADER.GRIDUNIT [2RD]");
    else
      {
        fail ("HEADER.GRIDUNIT [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD ucsorg;
    if (dwg_dynapi_header_value(dwg, "UCSORG", &ucsorg, NULL)
        && !memcmp(&ucsorg, &dwg->header_vars.UCSORG, sizeof(dwg->header_vars.UCSORG))
       )
      pass ("HEADER.UCSORG [3BD]");
    else
      {
        fail ("HEADER.UCSORG [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucsxdir;
    if (dwg_dynapi_header_value(dwg, "UCSXDIR", &ucsxdir, NULL)
        && !memcmp(&ucsxdir, &dwg->header_vars.UCSXDIR, sizeof(dwg->header_vars.UCSXDIR))
       )
      pass ("HEADER.UCSXDIR [3BD]");
    else
      {
        fail ("HEADER.UCSXDIR [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucsydir;
    if (dwg_dynapi_header_value(dwg, "UCSYDIR", &ucsydir, NULL)
        && !memcmp(&ucsydir, &dwg->header_vars.UCSYDIR, sizeof(dwg->header_vars.UCSYDIR))
       )
      pass ("HEADER.UCSYDIR [3BD]");
    else
      {
        fail ("HEADER.UCSYDIR [3BD]"); error++;
      }
  }
  {
    BITCODE_H ucsname;
    if (dwg_dynapi_header_value(dwg, "UCSNAME", &ucsname, NULL)
        && !memcmp(&ucsname, &dwg->header_vars.UCSNAME, sizeof(dwg->header_vars.UCSNAME))
       )
      pass ("HEADER.UCSNAME [H]");
    else
      {
        fail ("HEADER.UCSNAME [H]"); error++;
      }
  }
  {
    BITCODE_H ucsbase;
    if (dwg_dynapi_header_value(dwg, "UCSBASE", &ucsbase, NULL)
        && !memcmp(&ucsbase, &dwg->header_vars.UCSBASE, sizeof(dwg->header_vars.UCSBASE))
       )
      pass ("HEADER.UCSBASE [H]");
    else
      {
        fail ("HEADER.UCSBASE [H]"); error++;
      }
  }
  {
    BITCODE_BS ucsorthoview;
    if (dwg_dynapi_header_value(dwg, "UCSORTHOVIEW", &ucsorthoview, NULL) &&
        ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
      pass ("HEADER.UCSORTHOVIEW [BS] %hu", ucsorthoview);
    else
      {
        fail ("HEADER.UCSORTHOVIEW [BS] %hu != %hu", dwg->header_vars.UCSORTHOVIEW, ucsorthoview); error++;
      }
    ucsorthoview++;
    if (dwg_dynapi_header_set_value(dwg, "UCSORTHOVIEW", &ucsorthoview) &&
        ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
      pass ("HEADER.UCSORTHOVIEW [BS] set+1 %hu", ucsorthoview);
    else
      {
        fail ("HEADER.UCSORTHOVIEW [BS] set+1 %hu != %hu", dwg->header_vars.UCSORTHOVIEW, ucsorthoview); error++;
      }
    ucsorthoview--; dwg_dynapi_header_set_value(dwg, "UCSORTHOVIEW", &ucsorthoview);

  }
  {
    BITCODE_H ucsorthoref;
    if (dwg_dynapi_header_value(dwg, "UCSORTHOREF", &ucsorthoref, NULL)
        && !memcmp(&ucsorthoref, &dwg->header_vars.UCSORTHOREF, sizeof(dwg->header_vars.UCSORTHOREF))
       )
      pass ("HEADER.UCSORTHOREF [H]");
    else
      {
        fail ("HEADER.UCSORTHOREF [H]"); error++;
      }
  }
  {
    BITCODE_3BD ucsorgtop;
    if (dwg_dynapi_header_value(dwg, "UCSORGTOP", &ucsorgtop, NULL)
        && !memcmp(&ucsorgtop, &dwg->header_vars.UCSORGTOP, sizeof(dwg->header_vars.UCSORGTOP))
       )
      pass ("HEADER.UCSORGTOP [3BD]");
    else
      {
        fail ("HEADER.UCSORGTOP [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucsorgbottom;
    if (dwg_dynapi_header_value(dwg, "UCSORGBOTTOM", &ucsorgbottom, NULL)
        && !memcmp(&ucsorgbottom, &dwg->header_vars.UCSORGBOTTOM, sizeof(dwg->header_vars.UCSORGBOTTOM))
       )
      pass ("HEADER.UCSORGBOTTOM [3BD]");
    else
      {
        fail ("HEADER.UCSORGBOTTOM [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucsorgleft;
    if (dwg_dynapi_header_value(dwg, "UCSORGLEFT", &ucsorgleft, NULL)
        && !memcmp(&ucsorgleft, &dwg->header_vars.UCSORGLEFT, sizeof(dwg->header_vars.UCSORGLEFT))
       )
      pass ("HEADER.UCSORGLEFT [3BD]");
    else
      {
        fail ("HEADER.UCSORGLEFT [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucsorgright;
    if (dwg_dynapi_header_value(dwg, "UCSORGRIGHT", &ucsorgright, NULL)
        && !memcmp(&ucsorgright, &dwg->header_vars.UCSORGRIGHT, sizeof(dwg->header_vars.UCSORGRIGHT))
       )
      pass ("HEADER.UCSORGRIGHT [3BD]");
    else
      {
        fail ("HEADER.UCSORGRIGHT [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucsorgfront;
    if (dwg_dynapi_header_value(dwg, "UCSORGFRONT", &ucsorgfront, NULL)
        && !memcmp(&ucsorgfront, &dwg->header_vars.UCSORGFRONT, sizeof(dwg->header_vars.UCSORGFRONT))
       )
      pass ("HEADER.UCSORGFRONT [3BD]");
    else
      {
        fail ("HEADER.UCSORGFRONT [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucsorgback;
    if (dwg_dynapi_header_value(dwg, "UCSORGBACK", &ucsorgback, NULL)
        && !memcmp(&ucsorgback, &dwg->header_vars.UCSORGBACK, sizeof(dwg->header_vars.UCSORGBACK))
       )
      pass ("HEADER.UCSORGBACK [3BD]");
    else
      {
        fail ("HEADER.UCSORGBACK [3BD]"); error++;
      }
  }
  {
    BITCODE_TV dimpost;
    if (dwg_dynapi_header_value(dwg, "DIMPOST", &dimpost, NULL)
        && !memcmp(&dimpost, &dwg->header_vars.DIMPOST, sizeof(dwg->header_vars.DIMPOST))
       )
      pass ("HEADER.DIMPOST [TV]");
    else
      {
        fail ("HEADER.DIMPOST [TV]"); error++;
      }
  }
  {
    BITCODE_TV dimapost;
    if (dwg_dynapi_header_value(dwg, "DIMAPOST", &dimapost, NULL)
        && !memcmp(&dimapost, &dwg->header_vars.DIMAPOST, sizeof(dwg->header_vars.DIMAPOST))
       )
      pass ("HEADER.DIMAPOST [TV]");
    else
      {
        fail ("HEADER.DIMAPOST [TV]"); error++;
      }
  }
  {
    BITCODE_B dimtol;
    if (dwg_dynapi_header_value(dwg, "DIMTOL", &dimtol, NULL) &&
        dimtol == dwg->header_vars.DIMTOL)
      pass ("HEADER.DIMTOL [B] " FORMAT_B "", dimtol);
    else
      {
        fail ("HEADER.DIMTOL [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOL, dimtol); error++;
      }
    dimtol++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTOL", &dimtol) &&
        dimtol == dwg->header_vars.DIMTOL)
      pass ("HEADER.DIMTOL [B] set+1 " FORMAT_B "", dimtol);
    else
      {
        fail ("HEADER.DIMTOL [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOL, dimtol); error++;
      }
    dimtol--; dwg_dynapi_header_set_value(dwg, "DIMTOL", &dimtol);

  }
  {
    BITCODE_B dimlim;
    if (dwg_dynapi_header_value(dwg, "DIMLIM", &dimlim, NULL) &&
        dimlim == dwg->header_vars.DIMLIM)
      pass ("HEADER.DIMLIM [B] " FORMAT_B "", dimlim);
    else
      {
        fail ("HEADER.DIMLIM [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMLIM, dimlim); error++;
      }
    dimlim++;
    if (dwg_dynapi_header_set_value(dwg, "DIMLIM", &dimlim) &&
        dimlim == dwg->header_vars.DIMLIM)
      pass ("HEADER.DIMLIM [B] set+1 " FORMAT_B "", dimlim);
    else
      {
        fail ("HEADER.DIMLIM [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMLIM, dimlim); error++;
      }
    dimlim--; dwg_dynapi_header_set_value(dwg, "DIMLIM", &dimlim);

  }
  {
    BITCODE_B dimtih;
    if (dwg_dynapi_header_value(dwg, "DIMTIH", &dimtih, NULL) &&
        dimtih == dwg->header_vars.DIMTIH)
      pass ("HEADER.DIMTIH [B] " FORMAT_B "", dimtih);
    else
      {
        fail ("HEADER.DIMTIH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIH, dimtih); error++;
      }
    dimtih++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTIH", &dimtih) &&
        dimtih == dwg->header_vars.DIMTIH)
      pass ("HEADER.DIMTIH [B] set+1 " FORMAT_B "", dimtih);
    else
      {
        fail ("HEADER.DIMTIH [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIH, dimtih); error++;
      }
    dimtih--; dwg_dynapi_header_set_value(dwg, "DIMTIH", &dimtih);

  }
  {
    BITCODE_B dimtoh;
    if (dwg_dynapi_header_value(dwg, "DIMTOH", &dimtoh, NULL) &&
        dimtoh == dwg->header_vars.DIMTOH)
      pass ("HEADER.DIMTOH [B] " FORMAT_B "", dimtoh);
    else
      {
        fail ("HEADER.DIMTOH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOH, dimtoh); error++;
      }
    dimtoh++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTOH", &dimtoh) &&
        dimtoh == dwg->header_vars.DIMTOH)
      pass ("HEADER.DIMTOH [B] set+1 " FORMAT_B "", dimtoh);
    else
      {
        fail ("HEADER.DIMTOH [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOH, dimtoh); error++;
      }
    dimtoh--; dwg_dynapi_header_set_value(dwg, "DIMTOH", &dimtoh);

  }
  {
    BITCODE_B dimse1;
    if (dwg_dynapi_header_value(dwg, "DIMSE1", &dimse1, NULL) &&
        dimse1 == dwg->header_vars.DIMSE1)
      pass ("HEADER.DIMSE1 [B] " FORMAT_B "", dimse1);
    else
      {
        fail ("HEADER.DIMSE1 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE1, dimse1); error++;
      }
    dimse1++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSE1", &dimse1) &&
        dimse1 == dwg->header_vars.DIMSE1)
      pass ("HEADER.DIMSE1 [B] set+1 " FORMAT_B "", dimse1);
    else
      {
        fail ("HEADER.DIMSE1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE1, dimse1); error++;
      }
    dimse1--; dwg_dynapi_header_set_value(dwg, "DIMSE1", &dimse1);

  }
  {
    BITCODE_B dimse2;
    if (dwg_dynapi_header_value(dwg, "DIMSE2", &dimse2, NULL) &&
        dimse2 == dwg->header_vars.DIMSE2)
      pass ("HEADER.DIMSE2 [B] " FORMAT_B "", dimse2);
    else
      {
        fail ("HEADER.DIMSE2 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE2, dimse2); error++;
      }
    dimse2++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSE2", &dimse2) &&
        dimse2 == dwg->header_vars.DIMSE2)
      pass ("HEADER.DIMSE2 [B] set+1 " FORMAT_B "", dimse2);
    else
      {
        fail ("HEADER.DIMSE2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE2, dimse2); error++;
      }
    dimse2--; dwg_dynapi_header_set_value(dwg, "DIMSE2", &dimse2);

  }
  {
    BITCODE_B dimalt;
    if (dwg_dynapi_header_value(dwg, "DIMALT", &dimalt, NULL) &&
        dimalt == dwg->header_vars.DIMALT)
      pass ("HEADER.DIMALT [B] " FORMAT_B "", dimalt);
    else
      {
        fail ("HEADER.DIMALT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMALT, dimalt); error++;
      }
    dimalt++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALT", &dimalt) &&
        dimalt == dwg->header_vars.DIMALT)
      pass ("HEADER.DIMALT [B] set+1 " FORMAT_B "", dimalt);
    else
      {
        fail ("HEADER.DIMALT [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMALT, dimalt); error++;
      }
    dimalt--; dwg_dynapi_header_set_value(dwg, "DIMALT", &dimalt);

  }
  {
    BITCODE_B dimtofl;
    if (dwg_dynapi_header_value(dwg, "DIMTOFL", &dimtofl, NULL) &&
        dimtofl == dwg->header_vars.DIMTOFL)
      pass ("HEADER.DIMTOFL [B] " FORMAT_B "", dimtofl);
    else
      {
        fail ("HEADER.DIMTOFL [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOFL, dimtofl); error++;
      }
    dimtofl++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTOFL", &dimtofl) &&
        dimtofl == dwg->header_vars.DIMTOFL)
      pass ("HEADER.DIMTOFL [B] set+1 " FORMAT_B "", dimtofl);
    else
      {
        fail ("HEADER.DIMTOFL [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOFL, dimtofl); error++;
      }
    dimtofl--; dwg_dynapi_header_set_value(dwg, "DIMTOFL", &dimtofl);

  }
  {
    BITCODE_B dimsah;
    if (dwg_dynapi_header_value(dwg, "DIMSAH", &dimsah, NULL) &&
        dimsah == dwg->header_vars.DIMSAH)
      pass ("HEADER.DIMSAH [B] " FORMAT_B "", dimsah);
    else
      {
        fail ("HEADER.DIMSAH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAH, dimsah); error++;
      }
    dimsah++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSAH", &dimsah) &&
        dimsah == dwg->header_vars.DIMSAH)
      pass ("HEADER.DIMSAH [B] set+1 " FORMAT_B "", dimsah);
    else
      {
        fail ("HEADER.DIMSAH [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAH, dimsah); error++;
      }
    dimsah--; dwg_dynapi_header_set_value(dwg, "DIMSAH", &dimsah);

  }
  {
    BITCODE_B dimtix;
    if (dwg_dynapi_header_value(dwg, "DIMTIX", &dimtix, NULL) &&
        dimtix == dwg->header_vars.DIMTIX)
      pass ("HEADER.DIMTIX [B] " FORMAT_B "", dimtix);
    else
      {
        fail ("HEADER.DIMTIX [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIX, dimtix); error++;
      }
    dimtix++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTIX", &dimtix) &&
        dimtix == dwg->header_vars.DIMTIX)
      pass ("HEADER.DIMTIX [B] set+1 " FORMAT_B "", dimtix);
    else
      {
        fail ("HEADER.DIMTIX [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIX, dimtix); error++;
      }
    dimtix--; dwg_dynapi_header_set_value(dwg, "DIMTIX", &dimtix);

  }
  {
    BITCODE_B dimsoxd;
    if (dwg_dynapi_header_value(dwg, "DIMSOXD", &dimsoxd, NULL) &&
        dimsoxd == dwg->header_vars.DIMSOXD)
      pass ("HEADER.DIMSOXD [B] " FORMAT_B "", dimsoxd);
    else
      {
        fail ("HEADER.DIMSOXD [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSOXD, dimsoxd); error++;
      }
    dimsoxd++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSOXD", &dimsoxd) &&
        dimsoxd == dwg->header_vars.DIMSOXD)
      pass ("HEADER.DIMSOXD [B] set+1 " FORMAT_B "", dimsoxd);
    else
      {
        fail ("HEADER.DIMSOXD [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSOXD, dimsoxd); error++;
      }
    dimsoxd--; dwg_dynapi_header_set_value(dwg, "DIMSOXD", &dimsoxd);

  }
  {
    BITCODE_BS dimaltd;
    if (dwg_dynapi_header_value(dwg, "DIMALTD", &dimaltd, NULL) &&
        dimaltd == dwg->header_vars.DIMALTD)
      pass ("HEADER.DIMALTD [BS] %hu", dimaltd);
    else
      {
        fail ("HEADER.DIMALTD [BS] %hu != %hu", dwg->header_vars.DIMALTD, dimaltd); error++;
      }
    dimaltd++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALTD", &dimaltd) &&
        dimaltd == dwg->header_vars.DIMALTD)
      pass ("HEADER.DIMALTD [BS] set+1 %hu", dimaltd);
    else
      {
        fail ("HEADER.DIMALTD [BS] set+1 %hu != %hu", dwg->header_vars.DIMALTD, dimaltd); error++;
      }
    dimaltd--; dwg_dynapi_header_set_value(dwg, "DIMALTD", &dimaltd);

  }
  {
    BITCODE_BS dimzin;
    if (dwg_dynapi_header_value(dwg, "DIMZIN", &dimzin, NULL) &&
        dimzin == dwg->header_vars.DIMZIN)
      pass ("HEADER.DIMZIN [BS] %hu", dimzin);
    else
      {
        fail ("HEADER.DIMZIN [BS] %hu != %hu", dwg->header_vars.DIMZIN, dimzin); error++;
      }
    dimzin++;
    if (dwg_dynapi_header_set_value(dwg, "DIMZIN", &dimzin) &&
        dimzin == dwg->header_vars.DIMZIN)
      pass ("HEADER.DIMZIN [BS] set+1 %hu", dimzin);
    else
      {
        fail ("HEADER.DIMZIN [BS] set+1 %hu != %hu", dwg->header_vars.DIMZIN, dimzin); error++;
      }
    dimzin--; dwg_dynapi_header_set_value(dwg, "DIMZIN", &dimzin);

  }
  {
    BITCODE_B dimsd1;
    if (dwg_dynapi_header_value(dwg, "DIMSD1", &dimsd1, NULL) &&
        dimsd1 == dwg->header_vars.DIMSD1)
      pass ("HEADER.DIMSD1 [B] " FORMAT_B "", dimsd1);
    else
      {
        fail ("HEADER.DIMSD1 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD1, dimsd1); error++;
      }
    dimsd1++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSD1", &dimsd1) &&
        dimsd1 == dwg->header_vars.DIMSD1)
      pass ("HEADER.DIMSD1 [B] set+1 " FORMAT_B "", dimsd1);
    else
      {
        fail ("HEADER.DIMSD1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD1, dimsd1); error++;
      }
    dimsd1--; dwg_dynapi_header_set_value(dwg, "DIMSD1", &dimsd1);

  }
  {
    BITCODE_B dimsd2;
    if (dwg_dynapi_header_value(dwg, "DIMSD2", &dimsd2, NULL) &&
        dimsd2 == dwg->header_vars.DIMSD2)
      pass ("HEADER.DIMSD2 [B] " FORMAT_B "", dimsd2);
    else
      {
        fail ("HEADER.DIMSD2 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD2, dimsd2); error++;
      }
    dimsd2++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSD2", &dimsd2) &&
        dimsd2 == dwg->header_vars.DIMSD2)
      pass ("HEADER.DIMSD2 [B] set+1 " FORMAT_B "", dimsd2);
    else
      {
        fail ("HEADER.DIMSD2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD2, dimsd2); error++;
      }
    dimsd2--; dwg_dynapi_header_set_value(dwg, "DIMSD2", &dimsd2);

  }
  {
    BITCODE_BS dimtolj;
    if (dwg_dynapi_header_value(dwg, "DIMTOLJ", &dimtolj, NULL) &&
        dimtolj == dwg->header_vars.DIMTOLJ)
      pass ("HEADER.DIMTOLJ [BS] %hu", dimtolj);
    else
      {
        fail ("HEADER.DIMTOLJ [BS] %hu != %hu", dwg->header_vars.DIMTOLJ, dimtolj); error++;
      }
    dimtolj++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTOLJ", &dimtolj) &&
        dimtolj == dwg->header_vars.DIMTOLJ)
      pass ("HEADER.DIMTOLJ [BS] set+1 %hu", dimtolj);
    else
      {
        fail ("HEADER.DIMTOLJ [BS] set+1 %hu != %hu", dwg->header_vars.DIMTOLJ, dimtolj); error++;
      }
    dimtolj--; dwg_dynapi_header_set_value(dwg, "DIMTOLJ", &dimtolj);

  }
  {
    BITCODE_BS dimjust;
    if (dwg_dynapi_header_value(dwg, "DIMJUST", &dimjust, NULL) &&
        dimjust == dwg->header_vars.DIMJUST)
      pass ("HEADER.DIMJUST [BS] %hu", dimjust);
    else
      {
        fail ("HEADER.DIMJUST [BS] %hu != %hu", dwg->header_vars.DIMJUST, dimjust); error++;
      }
    dimjust++;
    if (dwg_dynapi_header_set_value(dwg, "DIMJUST", &dimjust) &&
        dimjust == dwg->header_vars.DIMJUST)
      pass ("HEADER.DIMJUST [BS] set+1 %hu", dimjust);
    else
      {
        fail ("HEADER.DIMJUST [BS] set+1 %hu != %hu", dwg->header_vars.DIMJUST, dimjust); error++;
      }
    dimjust--; dwg_dynapi_header_set_value(dwg, "DIMJUST", &dimjust);

  }
  {
    BITCODE_BS dimfit;
    if (dwg_dynapi_header_value(dwg, "DIMFIT", &dimfit, NULL) &&
        dimfit == dwg->header_vars.DIMFIT)
      pass ("HEADER.DIMFIT [BS] %hu", dimfit);
    else
      {
        fail ("HEADER.DIMFIT [BS] %hu != %hu", dwg->header_vars.DIMFIT, dimfit); error++;
      }
    dimfit++;
    if (dwg_dynapi_header_set_value(dwg, "DIMFIT", &dimfit) &&
        dimfit == dwg->header_vars.DIMFIT)
      pass ("HEADER.DIMFIT [BS] set+1 %hu", dimfit);
    else
      {
        fail ("HEADER.DIMFIT [BS] set+1 %hu != %hu", dwg->header_vars.DIMFIT, dimfit); error++;
      }
    dimfit--; dwg_dynapi_header_set_value(dwg, "DIMFIT", &dimfit);

  }
  {
    BITCODE_B dimupt;
    if (dwg_dynapi_header_value(dwg, "DIMUPT", &dimupt, NULL) &&
        dimupt == dwg->header_vars.DIMUPT)
      pass ("HEADER.DIMUPT [B] " FORMAT_B "", dimupt);
    else
      {
        fail ("HEADER.DIMUPT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMUPT, dimupt); error++;
      }
    dimupt++;
    if (dwg_dynapi_header_set_value(dwg, "DIMUPT", &dimupt) &&
        dimupt == dwg->header_vars.DIMUPT)
      pass ("HEADER.DIMUPT [B] set+1 " FORMAT_B "", dimupt);
    else
      {
        fail ("HEADER.DIMUPT [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMUPT, dimupt); error++;
      }
    dimupt--; dwg_dynapi_header_set_value(dwg, "DIMUPT", &dimupt);

  }
  {
    BITCODE_BS dimtzin;
    if (dwg_dynapi_header_value(dwg, "DIMTZIN", &dimtzin, NULL) &&
        dimtzin == dwg->header_vars.DIMTZIN)
      pass ("HEADER.DIMTZIN [BS] %hu", dimtzin);
    else
      {
        fail ("HEADER.DIMTZIN [BS] %hu != %hu", dwg->header_vars.DIMTZIN, dimtzin); error++;
      }
    dimtzin++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTZIN", &dimtzin) &&
        dimtzin == dwg->header_vars.DIMTZIN)
      pass ("HEADER.DIMTZIN [BS] set+1 %hu", dimtzin);
    else
      {
        fail ("HEADER.DIMTZIN [BS] set+1 %hu != %hu", dwg->header_vars.DIMTZIN, dimtzin); error++;
      }
    dimtzin--; dwg_dynapi_header_set_value(dwg, "DIMTZIN", &dimtzin);

  }
  {
    BITCODE_BS dimmaltz;
    if (dwg_dynapi_header_value(dwg, "DIMMALTZ", &dimmaltz, NULL) &&
        dimmaltz == dwg->header_vars.DIMMALTZ)
      pass ("HEADER.DIMMALTZ [BS] %hu", dimmaltz);
    else
      {
        fail ("HEADER.DIMMALTZ [BS] %hu != %hu", dwg->header_vars.DIMMALTZ, dimmaltz); error++;
      }
    dimmaltz++;
    if (dwg_dynapi_header_set_value(dwg, "DIMMALTZ", &dimmaltz) &&
        dimmaltz == dwg->header_vars.DIMMALTZ)
      pass ("HEADER.DIMMALTZ [BS] set+1 %hu", dimmaltz);
    else
      {
        fail ("HEADER.DIMMALTZ [BS] set+1 %hu != %hu", dwg->header_vars.DIMMALTZ, dimmaltz); error++;
      }
    dimmaltz--; dwg_dynapi_header_set_value(dwg, "DIMMALTZ", &dimmaltz);

  }
  {
    BITCODE_BS dimmalttz;
    if (dwg_dynapi_header_value(dwg, "DIMMALTTZ", &dimmalttz, NULL) &&
        dimmalttz == dwg->header_vars.DIMMALTTZ)
      pass ("HEADER.DIMMALTTZ [BS] %hu", dimmalttz);
    else
      {
        fail ("HEADER.DIMMALTTZ [BS] %hu != %hu", dwg->header_vars.DIMMALTTZ, dimmalttz); error++;
      }
    dimmalttz++;
    if (dwg_dynapi_header_set_value(dwg, "DIMMALTTZ", &dimmalttz) &&
        dimmalttz == dwg->header_vars.DIMMALTTZ)
      pass ("HEADER.DIMMALTTZ [BS] set+1 %hu", dimmalttz);
    else
      {
        fail ("HEADER.DIMMALTTZ [BS] set+1 %hu != %hu", dwg->header_vars.DIMMALTTZ, dimmalttz); error++;
      }
    dimmalttz--; dwg_dynapi_header_set_value(dwg, "DIMMALTTZ", &dimmalttz);

  }
  {
    BITCODE_BS dimtad;
    if (dwg_dynapi_header_value(dwg, "DIMTAD", &dimtad, NULL) &&
        dimtad == dwg->header_vars.DIMTAD)
      pass ("HEADER.DIMTAD [BS] %hu", dimtad);
    else
      {
        fail ("HEADER.DIMTAD [BS] %hu != %hu", dwg->header_vars.DIMTAD, dimtad); error++;
      }
    dimtad++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTAD", &dimtad) &&
        dimtad == dwg->header_vars.DIMTAD)
      pass ("HEADER.DIMTAD [BS] set+1 %hu", dimtad);
    else
      {
        fail ("HEADER.DIMTAD [BS] set+1 %hu != %hu", dwg->header_vars.DIMTAD, dimtad); error++;
      }
    dimtad--; dwg_dynapi_header_set_value(dwg, "DIMTAD", &dimtad);

  }
  {
    BITCODE_BS dimunit;
    if (dwg_dynapi_header_value(dwg, "DIMUNIT", &dimunit, NULL) &&
        dimunit == dwg->header_vars.DIMUNIT)
      pass ("HEADER.DIMUNIT [BS] %hu", dimunit);
    else
      {
        fail ("HEADER.DIMUNIT [BS] %hu != %hu", dwg->header_vars.DIMUNIT, dimunit); error++;
      }
    dimunit++;
    if (dwg_dynapi_header_set_value(dwg, "DIMUNIT", &dimunit) &&
        dimunit == dwg->header_vars.DIMUNIT)
      pass ("HEADER.DIMUNIT [BS] set+1 %hu", dimunit);
    else
      {
        fail ("HEADER.DIMUNIT [BS] set+1 %hu != %hu", dwg->header_vars.DIMUNIT, dimunit); error++;
      }
    dimunit--; dwg_dynapi_header_set_value(dwg, "DIMUNIT", &dimunit);

  }
  {
    BITCODE_BS dimaunit;
    if (dwg_dynapi_header_value(dwg, "DIMAUNIT", &dimaunit, NULL) &&
        dimaunit == dwg->header_vars.DIMAUNIT)
      pass ("HEADER.DIMAUNIT [BS] %hu", dimaunit);
    else
      {
        fail ("HEADER.DIMAUNIT [BS] %hu != %hu", dwg->header_vars.DIMAUNIT, dimaunit); error++;
      }
    dimaunit++;
    if (dwg_dynapi_header_set_value(dwg, "DIMAUNIT", &dimaunit) &&
        dimaunit == dwg->header_vars.DIMAUNIT)
      pass ("HEADER.DIMAUNIT [BS] set+1 %hu", dimaunit);
    else
      {
        fail ("HEADER.DIMAUNIT [BS] set+1 %hu != %hu", dwg->header_vars.DIMAUNIT, dimaunit); error++;
      }
    dimaunit--; dwg_dynapi_header_set_value(dwg, "DIMAUNIT", &dimaunit);

  }
  {
    BITCODE_BS dimdec;
    if (dwg_dynapi_header_value(dwg, "DIMDEC", &dimdec, NULL) &&
        dimdec == dwg->header_vars.DIMDEC)
      pass ("HEADER.DIMDEC [BS] %hu", dimdec);
    else
      {
        fail ("HEADER.DIMDEC [BS] %hu != %hu", dwg->header_vars.DIMDEC, dimdec); error++;
      }
    dimdec++;
    if (dwg_dynapi_header_set_value(dwg, "DIMDEC", &dimdec) &&
        dimdec == dwg->header_vars.DIMDEC)
      pass ("HEADER.DIMDEC [BS] set+1 %hu", dimdec);
    else
      {
        fail ("HEADER.DIMDEC [BS] set+1 %hu != %hu", dwg->header_vars.DIMDEC, dimdec); error++;
      }
    dimdec--; dwg_dynapi_header_set_value(dwg, "DIMDEC", &dimdec);

  }
  {
    BITCODE_BS dimtdec;
    if (dwg_dynapi_header_value(dwg, "DIMTDEC", &dimtdec, NULL) &&
        dimtdec == dwg->header_vars.DIMTDEC)
      pass ("HEADER.DIMTDEC [BS] %hu", dimtdec);
    else
      {
        fail ("HEADER.DIMTDEC [BS] %hu != %hu", dwg->header_vars.DIMTDEC, dimtdec); error++;
      }
    dimtdec++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTDEC", &dimtdec) &&
        dimtdec == dwg->header_vars.DIMTDEC)
      pass ("HEADER.DIMTDEC [BS] set+1 %hu", dimtdec);
    else
      {
        fail ("HEADER.DIMTDEC [BS] set+1 %hu != %hu", dwg->header_vars.DIMTDEC, dimtdec); error++;
      }
    dimtdec--; dwg_dynapi_header_set_value(dwg, "DIMTDEC", &dimtdec);

  }
  {
    BITCODE_BS dimaltu;
    if (dwg_dynapi_header_value(dwg, "DIMALTU", &dimaltu, NULL) &&
        dimaltu == dwg->header_vars.DIMALTU)
      pass ("HEADER.DIMALTU [BS] %hu", dimaltu);
    else
      {
        fail ("HEADER.DIMALTU [BS] %hu != %hu", dwg->header_vars.DIMALTU, dimaltu); error++;
      }
    dimaltu++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALTU", &dimaltu) &&
        dimaltu == dwg->header_vars.DIMALTU)
      pass ("HEADER.DIMALTU [BS] set+1 %hu", dimaltu);
    else
      {
        fail ("HEADER.DIMALTU [BS] set+1 %hu != %hu", dwg->header_vars.DIMALTU, dimaltu); error++;
      }
    dimaltu--; dwg_dynapi_header_set_value(dwg, "DIMALTU", &dimaltu);

  }
  {
    BITCODE_BS dimalttd;
    if (dwg_dynapi_header_value(dwg, "DIMALTTD", &dimalttd, NULL) &&
        dimalttd == dwg->header_vars.DIMALTTD)
      pass ("HEADER.DIMALTTD [BS] %hu", dimalttd);
    else
      {
        fail ("HEADER.DIMALTTD [BS] %hu != %hu", dwg->header_vars.DIMALTTD, dimalttd); error++;
      }
    dimalttd++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALTTD", &dimalttd) &&
        dimalttd == dwg->header_vars.DIMALTTD)
      pass ("HEADER.DIMALTTD [BS] set+1 %hu", dimalttd);
    else
      {
        fail ("HEADER.DIMALTTD [BS] set+1 %hu != %hu", dwg->header_vars.DIMALTTD, dimalttd); error++;
      }
    dimalttd--; dwg_dynapi_header_set_value(dwg, "DIMALTTD", &dimalttd);

  }
  {
    BITCODE_H dimtxsty;
    if (dwg_dynapi_header_value(dwg, "DIMTXSTY", &dimtxsty, NULL)
        && !memcmp(&dimtxsty, &dwg->header_vars.DIMTXSTY, sizeof(dwg->header_vars.DIMTXSTY))
       )
      pass ("HEADER.DIMTXSTY [H]");
    else
      {
        fail ("HEADER.DIMTXSTY [H]"); error++;
      }
  }
  {
    BITCODE_BD dimscale;
    if (dwg_dynapi_header_value(dwg, "DIMSCALE", &dimscale, NULL) &&
        dimscale == dwg->header_vars.DIMSCALE)
      pass ("HEADER.DIMSCALE [BD] %g", dimscale);
    else
      {
        fail ("HEADER.DIMSCALE [BD] %g != %g", dwg->header_vars.DIMSCALE, dimscale); error++;
      }
    dimscale++;
    if (dwg_dynapi_header_set_value(dwg, "DIMSCALE", &dimscale) &&
        dimscale == dwg->header_vars.DIMSCALE)
      pass ("HEADER.DIMSCALE [BD] set+1 %g", dimscale);
    else
      {
        fail ("HEADER.DIMSCALE [BD] set+1 %g != %g", dwg->header_vars.DIMSCALE, dimscale); error++;
      }
    dimscale--; dwg_dynapi_header_set_value(dwg, "DIMSCALE", &dimscale);

  }
  {
    BITCODE_BD dimasz;
    if (dwg_dynapi_header_value(dwg, "DIMASZ", &dimasz, NULL) &&
        dimasz == dwg->header_vars.DIMASZ)
      pass ("HEADER.DIMASZ [BD] %g", dimasz);
    else
      {
        fail ("HEADER.DIMASZ [BD] %g != %g", dwg->header_vars.DIMASZ, dimasz); error++;
      }
    dimasz++;
    if (dwg_dynapi_header_set_value(dwg, "DIMASZ", &dimasz) &&
        dimasz == dwg->header_vars.DIMASZ)
      pass ("HEADER.DIMASZ [BD] set+1 %g", dimasz);
    else
      {
        fail ("HEADER.DIMASZ [BD] set+1 %g != %g", dwg->header_vars.DIMASZ, dimasz); error++;
      }
    dimasz--; dwg_dynapi_header_set_value(dwg, "DIMASZ", &dimasz);

  }
  {
    BITCODE_BD dimexo;
    if (dwg_dynapi_header_value(dwg, "DIMEXO", &dimexo, NULL) &&
        dimexo == dwg->header_vars.DIMEXO)
      pass ("HEADER.DIMEXO [BD] %g", dimexo);
    else
      {
        fail ("HEADER.DIMEXO [BD] %g != %g", dwg->header_vars.DIMEXO, dimexo); error++;
      }
    dimexo++;
    if (dwg_dynapi_header_set_value(dwg, "DIMEXO", &dimexo) &&
        dimexo == dwg->header_vars.DIMEXO)
      pass ("HEADER.DIMEXO [BD] set+1 %g", dimexo);
    else
      {
        fail ("HEADER.DIMEXO [BD] set+1 %g != %g", dwg->header_vars.DIMEXO, dimexo); error++;
      }
    dimexo--; dwg_dynapi_header_set_value(dwg, "DIMEXO", &dimexo);

  }
  {
    BITCODE_BD dimdli;
    if (dwg_dynapi_header_value(dwg, "DIMDLI", &dimdli, NULL) &&
        dimdli == dwg->header_vars.DIMDLI)
      pass ("HEADER.DIMDLI [BD] %g", dimdli);
    else
      {
        fail ("HEADER.DIMDLI [BD] %g != %g", dwg->header_vars.DIMDLI, dimdli); error++;
      }
    dimdli++;
    if (dwg_dynapi_header_set_value(dwg, "DIMDLI", &dimdli) &&
        dimdli == dwg->header_vars.DIMDLI)
      pass ("HEADER.DIMDLI [BD] set+1 %g", dimdli);
    else
      {
        fail ("HEADER.DIMDLI [BD] set+1 %g != %g", dwg->header_vars.DIMDLI, dimdli); error++;
      }
    dimdli--; dwg_dynapi_header_set_value(dwg, "DIMDLI", &dimdli);

  }
  {
    BITCODE_BD dimexe;
    if (dwg_dynapi_header_value(dwg, "DIMEXE", &dimexe, NULL) &&
        dimexe == dwg->header_vars.DIMEXE)
      pass ("HEADER.DIMEXE [BD] %g", dimexe);
    else
      {
        fail ("HEADER.DIMEXE [BD] %g != %g", dwg->header_vars.DIMEXE, dimexe); error++;
      }
    dimexe++;
    if (dwg_dynapi_header_set_value(dwg, "DIMEXE", &dimexe) &&
        dimexe == dwg->header_vars.DIMEXE)
      pass ("HEADER.DIMEXE [BD] set+1 %g", dimexe);
    else
      {
        fail ("HEADER.DIMEXE [BD] set+1 %g != %g", dwg->header_vars.DIMEXE, dimexe); error++;
      }
    dimexe--; dwg_dynapi_header_set_value(dwg, "DIMEXE", &dimexe);

  }
  {
    BITCODE_BD dimrnd;
    if (dwg_dynapi_header_value(dwg, "DIMRND", &dimrnd, NULL) &&
        dimrnd == dwg->header_vars.DIMRND)
      pass ("HEADER.DIMRND [BD] %g", dimrnd);
    else
      {
        fail ("HEADER.DIMRND [BD] %g != %g", dwg->header_vars.DIMRND, dimrnd); error++;
      }
    dimrnd++;
    if (dwg_dynapi_header_set_value(dwg, "DIMRND", &dimrnd) &&
        dimrnd == dwg->header_vars.DIMRND)
      pass ("HEADER.DIMRND [BD] set+1 %g", dimrnd);
    else
      {
        fail ("HEADER.DIMRND [BD] set+1 %g != %g", dwg->header_vars.DIMRND, dimrnd); error++;
      }
    dimrnd--; dwg_dynapi_header_set_value(dwg, "DIMRND", &dimrnd);

  }
  {
    BITCODE_BD dimdle;
    if (dwg_dynapi_header_value(dwg, "DIMDLE", &dimdle, NULL) &&
        dimdle == dwg->header_vars.DIMDLE)
      pass ("HEADER.DIMDLE [BD] %g", dimdle);
    else
      {
        fail ("HEADER.DIMDLE [BD] %g != %g", dwg->header_vars.DIMDLE, dimdle); error++;
      }
    dimdle++;
    if (dwg_dynapi_header_set_value(dwg, "DIMDLE", &dimdle) &&
        dimdle == dwg->header_vars.DIMDLE)
      pass ("HEADER.DIMDLE [BD] set+1 %g", dimdle);
    else
      {
        fail ("HEADER.DIMDLE [BD] set+1 %g != %g", dwg->header_vars.DIMDLE, dimdle); error++;
      }
    dimdle--; dwg_dynapi_header_set_value(dwg, "DIMDLE", &dimdle);

  }
  {
    BITCODE_BD dimtp;
    if (dwg_dynapi_header_value(dwg, "DIMTP", &dimtp, NULL) &&
        dimtp == dwg->header_vars.DIMTP)
      pass ("HEADER.DIMTP [BD] %g", dimtp);
    else
      {
        fail ("HEADER.DIMTP [BD] %g != %g", dwg->header_vars.DIMTP, dimtp); error++;
      }
    dimtp++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTP", &dimtp) &&
        dimtp == dwg->header_vars.DIMTP)
      pass ("HEADER.DIMTP [BD] set+1 %g", dimtp);
    else
      {
        fail ("HEADER.DIMTP [BD] set+1 %g != %g", dwg->header_vars.DIMTP, dimtp); error++;
      }
    dimtp--; dwg_dynapi_header_set_value(dwg, "DIMTP", &dimtp);

  }
  {
    BITCODE_BD dimtm;
    if (dwg_dynapi_header_value(dwg, "DIMTM", &dimtm, NULL) &&
        dimtm == dwg->header_vars.DIMTM)
      pass ("HEADER.DIMTM [BD] %g", dimtm);
    else
      {
        fail ("HEADER.DIMTM [BD] %g != %g", dwg->header_vars.DIMTM, dimtm); error++;
      }
    dimtm++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTM", &dimtm) &&
        dimtm == dwg->header_vars.DIMTM)
      pass ("HEADER.DIMTM [BD] set+1 %g", dimtm);
    else
      {
        fail ("HEADER.DIMTM [BD] set+1 %g != %g", dwg->header_vars.DIMTM, dimtm); error++;
      }
    dimtm--; dwg_dynapi_header_set_value(dwg, "DIMTM", &dimtm);

  }
  {
    BITCODE_BD dimfxl;
    if (dwg_dynapi_header_value(dwg, "DIMFXL", &dimfxl, NULL) &&
        dimfxl == dwg->header_vars.DIMFXL)
      pass ("HEADER.DIMFXL [BD] %g", dimfxl);
    else
      {
        fail ("HEADER.DIMFXL [BD] %g != %g", dwg->header_vars.DIMFXL, dimfxl); error++;
      }
    dimfxl++;
    if (dwg_dynapi_header_set_value(dwg, "DIMFXL", &dimfxl) &&
        dimfxl == dwg->header_vars.DIMFXL)
      pass ("HEADER.DIMFXL [BD] set+1 %g", dimfxl);
    else
      {
        fail ("HEADER.DIMFXL [BD] set+1 %g != %g", dwg->header_vars.DIMFXL, dimfxl); error++;
      }
    dimfxl--; dwg_dynapi_header_set_value(dwg, "DIMFXL", &dimfxl);

  }
  {
    BITCODE_BD dimjogang;
    if (dwg_dynapi_header_value(dwg, "DIMJOGANG", &dimjogang, NULL) &&
        dimjogang == dwg->header_vars.DIMJOGANG)
      pass ("HEADER.DIMJOGANG [BD] %g", dimjogang);
    else
      {
        fail ("HEADER.DIMJOGANG [BD] %g != %g", dwg->header_vars.DIMJOGANG, dimjogang); error++;
      }
    dimjogang++;
    if (dwg_dynapi_header_set_value(dwg, "DIMJOGANG", &dimjogang) &&
        dimjogang == dwg->header_vars.DIMJOGANG)
      pass ("HEADER.DIMJOGANG [BD] set+1 %g", dimjogang);
    else
      {
        fail ("HEADER.DIMJOGANG [BD] set+1 %g != %g", dwg->header_vars.DIMJOGANG, dimjogang); error++;
      }
    dimjogang--; dwg_dynapi_header_set_value(dwg, "DIMJOGANG", &dimjogang);

  }
  {
    BITCODE_BS dimtfill;
    if (dwg_dynapi_header_value(dwg, "DIMTFILL", &dimtfill, NULL) &&
        dimtfill == dwg->header_vars.DIMTFILL)
      pass ("HEADER.DIMTFILL [BS] %hu", dimtfill);
    else
      {
        fail ("HEADER.DIMTFILL [BS] %hu != %hu", dwg->header_vars.DIMTFILL, dimtfill); error++;
      }
    dimtfill++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTFILL", &dimtfill) &&
        dimtfill == dwg->header_vars.DIMTFILL)
      pass ("HEADER.DIMTFILL [BS] set+1 %hu", dimtfill);
    else
      {
        fail ("HEADER.DIMTFILL [BS] set+1 %hu != %hu", dwg->header_vars.DIMTFILL, dimtfill); error++;
      }
    dimtfill--; dwg_dynapi_header_set_value(dwg, "DIMTFILL", &dimtfill);

  }
  {
    BITCODE_CMC dimtfillclr;
    if (dwg_dynapi_header_value(dwg, "DIMTFILLCLR", &dimtfillclr, NULL)
        && !memcmp(&dimtfillclr, &dwg->header_vars.DIMTFILLCLR, sizeof(dwg->header_vars.DIMTFILLCLR))
       )
      pass ("HEADER.DIMTFILLCLR [CMC]");
    else
      {
        fail ("HEADER.DIMTFILLCLR [CMC]"); error++;
      }
  }
  {
    BITCODE_BS dimazin;
    if (dwg_dynapi_header_value(dwg, "DIMAZIN", &dimazin, NULL) &&
        dimazin == dwg->header_vars.DIMAZIN)
      pass ("HEADER.DIMAZIN [BS] %hu", dimazin);
    else
      {
        fail ("HEADER.DIMAZIN [BS] %hu != %hu", dwg->header_vars.DIMAZIN, dimazin); error++;
      }
    dimazin++;
    if (dwg_dynapi_header_set_value(dwg, "DIMAZIN", &dimazin) &&
        dimazin == dwg->header_vars.DIMAZIN)
      pass ("HEADER.DIMAZIN [BS] set+1 %hu", dimazin);
    else
      {
        fail ("HEADER.DIMAZIN [BS] set+1 %hu != %hu", dwg->header_vars.DIMAZIN, dimazin); error++;
      }
    dimazin--; dwg_dynapi_header_set_value(dwg, "DIMAZIN", &dimazin);

  }
  {
    BITCODE_BS dimarcsym;
    if (dwg_dynapi_header_value(dwg, "DIMARCSYM", &dimarcsym, NULL) &&
        dimarcsym == dwg->header_vars.DIMARCSYM)
      pass ("HEADER.DIMARCSYM [BS] %hu", dimarcsym);
    else
      {
        fail ("HEADER.DIMARCSYM [BS] %hu != %hu", dwg->header_vars.DIMARCSYM, dimarcsym); error++;
      }
    dimarcsym++;
    if (dwg_dynapi_header_set_value(dwg, "DIMARCSYM", &dimarcsym) &&
        dimarcsym == dwg->header_vars.DIMARCSYM)
      pass ("HEADER.DIMARCSYM [BS] set+1 %hu", dimarcsym);
    else
      {
        fail ("HEADER.DIMARCSYM [BS] set+1 %hu != %hu", dwg->header_vars.DIMARCSYM, dimarcsym); error++;
      }
    dimarcsym--; dwg_dynapi_header_set_value(dwg, "DIMARCSYM", &dimarcsym);

  }
  {
    BITCODE_BD dimtxt;
    if (dwg_dynapi_header_value(dwg, "DIMTXT", &dimtxt, NULL) &&
        dimtxt == dwg->header_vars.DIMTXT)
      pass ("HEADER.DIMTXT [BD] %g", dimtxt);
    else
      {
        fail ("HEADER.DIMTXT [BD] %g != %g", dwg->header_vars.DIMTXT, dimtxt); error++;
      }
    dimtxt++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTXT", &dimtxt) &&
        dimtxt == dwg->header_vars.DIMTXT)
      pass ("HEADER.DIMTXT [BD] set+1 %g", dimtxt);
    else
      {
        fail ("HEADER.DIMTXT [BD] set+1 %g != %g", dwg->header_vars.DIMTXT, dimtxt); error++;
      }
    dimtxt--; dwg_dynapi_header_set_value(dwg, "DIMTXT", &dimtxt);

  }
  {
    BITCODE_BD dimcen;
    if (dwg_dynapi_header_value(dwg, "DIMCEN", &dimcen, NULL) &&
        dimcen == dwg->header_vars.DIMCEN)
      pass ("HEADER.DIMCEN [BD] %g", dimcen);
    else
      {
        fail ("HEADER.DIMCEN [BD] %g != %g", dwg->header_vars.DIMCEN, dimcen); error++;
      }
    dimcen++;
    if (dwg_dynapi_header_set_value(dwg, "DIMCEN", &dimcen) &&
        dimcen == dwg->header_vars.DIMCEN)
      pass ("HEADER.DIMCEN [BD] set+1 %g", dimcen);
    else
      {
        fail ("HEADER.DIMCEN [BD] set+1 %g != %g", dwg->header_vars.DIMCEN, dimcen); error++;
      }
    dimcen--; dwg_dynapi_header_set_value(dwg, "DIMCEN", &dimcen);

  }
  {
    BITCODE_BD dimtsz;
    if (dwg_dynapi_header_value(dwg, "DIMTSZ", &dimtsz, NULL) &&
        dimtsz == dwg->header_vars.DIMTSZ)
      pass ("HEADER.DIMTSZ [BD] %g", dimtsz);
    else
      {
        fail ("HEADER.DIMTSZ [BD] %g != %g", dwg->header_vars.DIMTSZ, dimtsz); error++;
      }
    dimtsz++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTSZ", &dimtsz) &&
        dimtsz == dwg->header_vars.DIMTSZ)
      pass ("HEADER.DIMTSZ [BD] set+1 %g", dimtsz);
    else
      {
        fail ("HEADER.DIMTSZ [BD] set+1 %g != %g", dwg->header_vars.DIMTSZ, dimtsz); error++;
      }
    dimtsz--; dwg_dynapi_header_set_value(dwg, "DIMTSZ", &dimtsz);

  }
  {
    BITCODE_BD dimaltf;
    if (dwg_dynapi_header_value(dwg, "DIMALTF", &dimaltf, NULL) &&
        dimaltf == dwg->header_vars.DIMALTF)
      pass ("HEADER.DIMALTF [BD] %g", dimaltf);
    else
      {
        fail ("HEADER.DIMALTF [BD] %g != %g", dwg->header_vars.DIMALTF, dimaltf); error++;
      }
    dimaltf++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALTF", &dimaltf) &&
        dimaltf == dwg->header_vars.DIMALTF)
      pass ("HEADER.DIMALTF [BD] set+1 %g", dimaltf);
    else
      {
        fail ("HEADER.DIMALTF [BD] set+1 %g != %g", dwg->header_vars.DIMALTF, dimaltf); error++;
      }
    dimaltf--; dwg_dynapi_header_set_value(dwg, "DIMALTF", &dimaltf);

  }
  {
    BITCODE_BD dimlfac;
    if (dwg_dynapi_header_value(dwg, "DIMLFAC", &dimlfac, NULL) &&
        dimlfac == dwg->header_vars.DIMLFAC)
      pass ("HEADER.DIMLFAC [BD] %g", dimlfac);
    else
      {
        fail ("HEADER.DIMLFAC [BD] %g != %g", dwg->header_vars.DIMLFAC, dimlfac); error++;
      }
    dimlfac++;
    if (dwg_dynapi_header_set_value(dwg, "DIMLFAC", &dimlfac) &&
        dimlfac == dwg->header_vars.DIMLFAC)
      pass ("HEADER.DIMLFAC [BD] set+1 %g", dimlfac);
    else
      {
        fail ("HEADER.DIMLFAC [BD] set+1 %g != %g", dwg->header_vars.DIMLFAC, dimlfac); error++;
      }
    dimlfac--; dwg_dynapi_header_set_value(dwg, "DIMLFAC", &dimlfac);

  }
  {
    BITCODE_BD dimtvp;
    if (dwg_dynapi_header_value(dwg, "DIMTVP", &dimtvp, NULL) &&
        dimtvp == dwg->header_vars.DIMTVP)
      pass ("HEADER.DIMTVP [BD] %g", dimtvp);
    else
      {
        fail ("HEADER.DIMTVP [BD] %g != %g", dwg->header_vars.DIMTVP, dimtvp); error++;
      }
    dimtvp++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTVP", &dimtvp) &&
        dimtvp == dwg->header_vars.DIMTVP)
      pass ("HEADER.DIMTVP [BD] set+1 %g", dimtvp);
    else
      {
        fail ("HEADER.DIMTVP [BD] set+1 %g != %g", dwg->header_vars.DIMTVP, dimtvp); error++;
      }
    dimtvp--; dwg_dynapi_header_set_value(dwg, "DIMTVP", &dimtvp);

  }
  {
    BITCODE_BD dimtfac;
    if (dwg_dynapi_header_value(dwg, "DIMTFAC", &dimtfac, NULL) &&
        dimtfac == dwg->header_vars.DIMTFAC)
      pass ("HEADER.DIMTFAC [BD] %g", dimtfac);
    else
      {
        fail ("HEADER.DIMTFAC [BD] %g != %g", dwg->header_vars.DIMTFAC, dimtfac); error++;
      }
    dimtfac++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTFAC", &dimtfac) &&
        dimtfac == dwg->header_vars.DIMTFAC)
      pass ("HEADER.DIMTFAC [BD] set+1 %g", dimtfac);
    else
      {
        fail ("HEADER.DIMTFAC [BD] set+1 %g != %g", dwg->header_vars.DIMTFAC, dimtfac); error++;
      }
    dimtfac--; dwg_dynapi_header_set_value(dwg, "DIMTFAC", &dimtfac);

  }
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_header_value(dwg, "DIMGAP", &dimgap, NULL) &&
        dimgap == dwg->header_vars.DIMGAP)
      pass ("HEADER.DIMGAP [BD] %g", dimgap);
    else
      {
        fail ("HEADER.DIMGAP [BD] %g != %g", dwg->header_vars.DIMGAP, dimgap); error++;
      }
    dimgap++;
    if (dwg_dynapi_header_set_value(dwg, "DIMGAP", &dimgap) &&
        dimgap == dwg->header_vars.DIMGAP)
      pass ("HEADER.DIMGAP [BD] set+1 %g", dimgap);
    else
      {
        fail ("HEADER.DIMGAP [BD] set+1 %g != %g", dwg->header_vars.DIMGAP, dimgap); error++;
      }
    dimgap--; dwg_dynapi_header_set_value(dwg, "DIMGAP", &dimgap);

  }
  {
    BITCODE_T dimpost_t;
    if (dwg_dynapi_header_value(dwg, "DIMPOST_T", &dimpost_t, NULL)
        && !memcmp(&dimpost_t, &dwg->header_vars.DIMPOST_T, sizeof(dwg->header_vars.DIMPOST_T))
       )
      pass ("HEADER.DIMPOST_T [T]");
    else
      {
        fail ("HEADER.DIMPOST_T [T]"); error++;
      }
  }
  {
    BITCODE_T dimapost_t;
    if (dwg_dynapi_header_value(dwg, "DIMAPOST_T", &dimapost_t, NULL)
        && !memcmp(&dimapost_t, &dwg->header_vars.DIMAPOST_T, sizeof(dwg->header_vars.DIMAPOST_T))
       )
      pass ("HEADER.DIMAPOST_T [T]");
    else
      {
        fail ("HEADER.DIMAPOST_T [T]"); error++;
      }
  }
  {
    BITCODE_T dimblk_t;
    if (dwg_dynapi_header_value(dwg, "DIMBLK_T", &dimblk_t, NULL)
        && !memcmp(&dimblk_t, &dwg->header_vars.DIMBLK_T, sizeof(dwg->header_vars.DIMBLK_T))
       )
      pass ("HEADER.DIMBLK_T [T]");
    else
      {
        fail ("HEADER.DIMBLK_T [T]"); error++;
      }
  }
  {
    BITCODE_T dimblk1_t;
    if (dwg_dynapi_header_value(dwg, "DIMBLK1_T", &dimblk1_t, NULL)
        && !memcmp(&dimblk1_t, &dwg->header_vars.DIMBLK1_T, sizeof(dwg->header_vars.DIMBLK1_T))
       )
      pass ("HEADER.DIMBLK1_T [T]");
    else
      {
        fail ("HEADER.DIMBLK1_T [T]"); error++;
      }
  }
  {
    BITCODE_T dimblk2_t;
    if (dwg_dynapi_header_value(dwg, "DIMBLK2_T", &dimblk2_t, NULL)
        && !memcmp(&dimblk2_t, &dwg->header_vars.DIMBLK2_T, sizeof(dwg->header_vars.DIMBLK2_T))
       )
      pass ("HEADER.DIMBLK2_T [T]");
    else
      {
        fail ("HEADER.DIMBLK2_T [T]"); error++;
      }
  }
  {
    BITCODE_BD dimaltrnd;
    if (dwg_dynapi_header_value(dwg, "DIMALTRND", &dimaltrnd, NULL) &&
        dimaltrnd == dwg->header_vars.DIMALTRND)
      pass ("HEADER.DIMALTRND [BD] %g", dimaltrnd);
    else
      {
        fail ("HEADER.DIMALTRND [BD] %g != %g", dwg->header_vars.DIMALTRND, dimaltrnd); error++;
      }
    dimaltrnd++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALTRND", &dimaltrnd) &&
        dimaltrnd == dwg->header_vars.DIMALTRND)
      pass ("HEADER.DIMALTRND [BD] set+1 %g", dimaltrnd);
    else
      {
        fail ("HEADER.DIMALTRND [BD] set+1 %g != %g", dwg->header_vars.DIMALTRND, dimaltrnd); error++;
      }
    dimaltrnd--; dwg_dynapi_header_set_value(dwg, "DIMALTRND", &dimaltrnd);

  }
  {
    BITCODE_RS dimclrd_c;
    if (dwg_dynapi_header_value(dwg, "DIMCLRD_C", &dimclrd_c, NULL) &&
        dimclrd_c == dwg->header_vars.DIMCLRD_C)
      pass ("HEADER.DIMCLRD_C [RS] %hu", dimclrd_c);
    else
      {
        fail ("HEADER.DIMCLRD_C [RS] %hu != %hu", dwg->header_vars.DIMCLRD_C, dimclrd_c); error++;
      }
    dimclrd_c++;
    if (dwg_dynapi_header_set_value(dwg, "DIMCLRD_C", &dimclrd_c) &&
        dimclrd_c == dwg->header_vars.DIMCLRD_C)
      pass ("HEADER.DIMCLRD_C [RS] set+1 %hu", dimclrd_c);
    else
      {
        fail ("HEADER.DIMCLRD_C [RS] set+1 %hu != %hu", dwg->header_vars.DIMCLRD_C, dimclrd_c); error++;
      }
    dimclrd_c--; dwg_dynapi_header_set_value(dwg, "DIMCLRD_C", &dimclrd_c);

  }
  {
    BITCODE_RS dimclre_c;
    if (dwg_dynapi_header_value(dwg, "DIMCLRE_C", &dimclre_c, NULL) &&
        dimclre_c == dwg->header_vars.DIMCLRE_C)
      pass ("HEADER.DIMCLRE_C [RS] %hu", dimclre_c);
    else
      {
        fail ("HEADER.DIMCLRE_C [RS] %hu != %hu", dwg->header_vars.DIMCLRE_C, dimclre_c); error++;
      }
    dimclre_c++;
    if (dwg_dynapi_header_set_value(dwg, "DIMCLRE_C", &dimclre_c) &&
        dimclre_c == dwg->header_vars.DIMCLRE_C)
      pass ("HEADER.DIMCLRE_C [RS] set+1 %hu", dimclre_c);
    else
      {
        fail ("HEADER.DIMCLRE_C [RS] set+1 %hu != %hu", dwg->header_vars.DIMCLRE_C, dimclre_c); error++;
      }
    dimclre_c--; dwg_dynapi_header_set_value(dwg, "DIMCLRE_C", &dimclre_c);

  }
  {
    BITCODE_RS dimclrt_c;
    if (dwg_dynapi_header_value(dwg, "DIMCLRT_C", &dimclrt_c, NULL) &&
        dimclrt_c == dwg->header_vars.DIMCLRT_C)
      pass ("HEADER.DIMCLRT_C [RS] %hu", dimclrt_c);
    else
      {
        fail ("HEADER.DIMCLRT_C [RS] %hu != %hu", dwg->header_vars.DIMCLRT_C, dimclrt_c); error++;
      }
    dimclrt_c++;
    if (dwg_dynapi_header_set_value(dwg, "DIMCLRT_C", &dimclrt_c) &&
        dimclrt_c == dwg->header_vars.DIMCLRT_C)
      pass ("HEADER.DIMCLRT_C [RS] set+1 %hu", dimclrt_c);
    else
      {
        fail ("HEADER.DIMCLRT_C [RS] set+1 %hu != %hu", dwg->header_vars.DIMCLRT_C, dimclrt_c); error++;
      }
    dimclrt_c--; dwg_dynapi_header_set_value(dwg, "DIMCLRT_C", &dimclrt_c);

  }
  {
    BITCODE_CMC dimclrd;
    if (dwg_dynapi_header_value(dwg, "DIMCLRD", &dimclrd, NULL)
        && !memcmp(&dimclrd, &dwg->header_vars.DIMCLRD, sizeof(dwg->header_vars.DIMCLRD))
       )
      pass ("HEADER.DIMCLRD [CMC]");
    else
      {
        fail ("HEADER.DIMCLRD [CMC]"); error++;
      }
  }
  {
    BITCODE_CMC dimclre;
    if (dwg_dynapi_header_value(dwg, "DIMCLRE", &dimclre, NULL)
        && !memcmp(&dimclre, &dwg->header_vars.DIMCLRE, sizeof(dwg->header_vars.DIMCLRE))
       )
      pass ("HEADER.DIMCLRE [CMC]");
    else
      {
        fail ("HEADER.DIMCLRE [CMC]"); error++;
      }
  }
  {
    BITCODE_CMC dimclrt;
    if (dwg_dynapi_header_value(dwg, "DIMCLRT", &dimclrt, NULL)
        && !memcmp(&dimclrt, &dwg->header_vars.DIMCLRT, sizeof(dwg->header_vars.DIMCLRT))
       )
      pass ("HEADER.DIMCLRT [CMC]");
    else
      {
        fail ("HEADER.DIMCLRT [CMC]"); error++;
      }
  }
  {
    BITCODE_BS dimadec;
    if (dwg_dynapi_header_value(dwg, "DIMADEC", &dimadec, NULL) &&
        dimadec == dwg->header_vars.DIMADEC)
      pass ("HEADER.DIMADEC [BS] %hu", dimadec);
    else
      {
        fail ("HEADER.DIMADEC [BS] %hu != %hu", dwg->header_vars.DIMADEC, dimadec); error++;
      }
    dimadec++;
    if (dwg_dynapi_header_set_value(dwg, "DIMADEC", &dimadec) &&
        dimadec == dwg->header_vars.DIMADEC)
      pass ("HEADER.DIMADEC [BS] set+1 %hu", dimadec);
    else
      {
        fail ("HEADER.DIMADEC [BS] set+1 %hu != %hu", dwg->header_vars.DIMADEC, dimadec); error++;
      }
    dimadec--; dwg_dynapi_header_set_value(dwg, "DIMADEC", &dimadec);

  }
  {
    BITCODE_BS dimfrac;
    if (dwg_dynapi_header_value(dwg, "DIMFRAC", &dimfrac, NULL) &&
        dimfrac == dwg->header_vars.DIMFRAC)
      pass ("HEADER.DIMFRAC [BS] %hu", dimfrac);
    else
      {
        fail ("HEADER.DIMFRAC [BS] %hu != %hu", dwg->header_vars.DIMFRAC, dimfrac); error++;
      }
    dimfrac++;
    if (dwg_dynapi_header_set_value(dwg, "DIMFRAC", &dimfrac) &&
        dimfrac == dwg->header_vars.DIMFRAC)
      pass ("HEADER.DIMFRAC [BS] set+1 %hu", dimfrac);
    else
      {
        fail ("HEADER.DIMFRAC [BS] set+1 %hu != %hu", dwg->header_vars.DIMFRAC, dimfrac); error++;
      }
    dimfrac--; dwg_dynapi_header_set_value(dwg, "DIMFRAC", &dimfrac);

  }
  {
    BITCODE_BS dimlunit;
    if (dwg_dynapi_header_value(dwg, "DIMLUNIT", &dimlunit, NULL) &&
        dimlunit == dwg->header_vars.DIMLUNIT)
      pass ("HEADER.DIMLUNIT [BS] %hu", dimlunit);
    else
      {
        fail ("HEADER.DIMLUNIT [BS] %hu != %hu", dwg->header_vars.DIMLUNIT, dimlunit); error++;
      }
    dimlunit++;
    if (dwg_dynapi_header_set_value(dwg, "DIMLUNIT", &dimlunit) &&
        dimlunit == dwg->header_vars.DIMLUNIT)
      pass ("HEADER.DIMLUNIT [BS] set+1 %hu", dimlunit);
    else
      {
        fail ("HEADER.DIMLUNIT [BS] set+1 %hu != %hu", dwg->header_vars.DIMLUNIT, dimlunit); error++;
      }
    dimlunit--; dwg_dynapi_header_set_value(dwg, "DIMLUNIT", &dimlunit);

  }
  {
    BITCODE_BS dimdsep;
    if (dwg_dynapi_header_value(dwg, "DIMDSEP", &dimdsep, NULL) &&
        dimdsep == dwg->header_vars.DIMDSEP)
      pass ("HEADER.DIMDSEP [BS] %hu", dimdsep);
    else
      {
        fail ("HEADER.DIMDSEP [BS] %hu != %hu", dwg->header_vars.DIMDSEP, dimdsep); error++;
      }
    dimdsep++;
    if (dwg_dynapi_header_set_value(dwg, "DIMDSEP", &dimdsep) &&
        dimdsep == dwg->header_vars.DIMDSEP)
      pass ("HEADER.DIMDSEP [BS] set+1 %hu", dimdsep);
    else
      {
        fail ("HEADER.DIMDSEP [BS] set+1 %hu != %hu", dwg->header_vars.DIMDSEP, dimdsep); error++;
      }
    dimdsep--; dwg_dynapi_header_set_value(dwg, "DIMDSEP", &dimdsep);

  }
  {
    BITCODE_BS dimtmove;
    if (dwg_dynapi_header_value(dwg, "DIMTMOVE", &dimtmove, NULL) &&
        dimtmove == dwg->header_vars.DIMTMOVE)
      pass ("HEADER.DIMTMOVE [BS] %hu", dimtmove);
    else
      {
        fail ("HEADER.DIMTMOVE [BS] %hu != %hu", dwg->header_vars.DIMTMOVE, dimtmove); error++;
      }
    dimtmove++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTMOVE", &dimtmove) &&
        dimtmove == dwg->header_vars.DIMTMOVE)
      pass ("HEADER.DIMTMOVE [BS] set+1 %hu", dimtmove);
    else
      {
        fail ("HEADER.DIMTMOVE [BS] set+1 %hu != %hu", dwg->header_vars.DIMTMOVE, dimtmove); error++;
      }
    dimtmove--; dwg_dynapi_header_set_value(dwg, "DIMTMOVE", &dimtmove);

  }
  {
    BITCODE_BS dimaltz;
    if (dwg_dynapi_header_value(dwg, "DIMALTZ", &dimaltz, NULL) &&
        dimaltz == dwg->header_vars.DIMALTZ)
      pass ("HEADER.DIMALTZ [BS] %hu", dimaltz);
    else
      {
        fail ("HEADER.DIMALTZ [BS] %hu != %hu", dwg->header_vars.DIMALTZ, dimaltz); error++;
      }
    dimaltz++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALTZ", &dimaltz) &&
        dimaltz == dwg->header_vars.DIMALTZ)
      pass ("HEADER.DIMALTZ [BS] set+1 %hu", dimaltz);
    else
      {
        fail ("HEADER.DIMALTZ [BS] set+1 %hu != %hu", dwg->header_vars.DIMALTZ, dimaltz); error++;
      }
    dimaltz--; dwg_dynapi_header_set_value(dwg, "DIMALTZ", &dimaltz);

  }
  {
    BITCODE_BS dimalttz;
    if (dwg_dynapi_header_value(dwg, "DIMALTTZ", &dimalttz, NULL) &&
        dimalttz == dwg->header_vars.DIMALTTZ)
      pass ("HEADER.DIMALTTZ [BS] %hu", dimalttz);
    else
      {
        fail ("HEADER.DIMALTTZ [BS] %hu != %hu", dwg->header_vars.DIMALTTZ, dimalttz); error++;
      }
    dimalttz++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALTTZ", &dimalttz) &&
        dimalttz == dwg->header_vars.DIMALTTZ)
      pass ("HEADER.DIMALTTZ [BS] set+1 %hu", dimalttz);
    else
      {
        fail ("HEADER.DIMALTTZ [BS] set+1 %hu != %hu", dwg->header_vars.DIMALTTZ, dimalttz); error++;
      }
    dimalttz--; dwg_dynapi_header_set_value(dwg, "DIMALTTZ", &dimalttz);

  }
  {
    BITCODE_BS dimatfit;
    if (dwg_dynapi_header_value(dwg, "DIMATFIT", &dimatfit, NULL) &&
        dimatfit == dwg->header_vars.DIMATFIT)
      pass ("HEADER.DIMATFIT [BS] %hu", dimatfit);
    else
      {
        fail ("HEADER.DIMATFIT [BS] %hu != %hu", dwg->header_vars.DIMATFIT, dimatfit); error++;
      }
    dimatfit++;
    if (dwg_dynapi_header_set_value(dwg, "DIMATFIT", &dimatfit) &&
        dimatfit == dwg->header_vars.DIMATFIT)
      pass ("HEADER.DIMATFIT [BS] set+1 %hu", dimatfit);
    else
      {
        fail ("HEADER.DIMATFIT [BS] set+1 %hu != %hu", dwg->header_vars.DIMATFIT, dimatfit); error++;
      }
    dimatfit--; dwg_dynapi_header_set_value(dwg, "DIMATFIT", &dimatfit);

  }
  {
    BITCODE_B dimfxlon;
    if (dwg_dynapi_header_value(dwg, "DIMFXLON", &dimfxlon, NULL) &&
        dimfxlon == dwg->header_vars.DIMFXLON)
      pass ("HEADER.DIMFXLON [B] " FORMAT_B "", dimfxlon);
    else
      {
        fail ("HEADER.DIMFXLON [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMFXLON, dimfxlon); error++;
      }
    dimfxlon++;
    if (dwg_dynapi_header_set_value(dwg, "DIMFXLON", &dimfxlon) &&
        dimfxlon == dwg->header_vars.DIMFXLON)
      pass ("HEADER.DIMFXLON [B] set+1 " FORMAT_B "", dimfxlon);
    else
      {
        fail ("HEADER.DIMFXLON [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMFXLON, dimfxlon); error++;
      }
    dimfxlon--; dwg_dynapi_header_set_value(dwg, "DIMFXLON", &dimfxlon);

  }
  {
    BITCODE_B dimtxtdirection;
    if (dwg_dynapi_header_value(dwg, "DIMTXTDIRECTION", &dimtxtdirection, NULL) &&
        dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
      pass ("HEADER.DIMTXTDIRECTION [B] " FORMAT_B "", dimtxtdirection);
    else
      {
        fail ("HEADER.DIMTXTDIRECTION [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection); error++;
      }
    dimtxtdirection++;
    if (dwg_dynapi_header_set_value(dwg, "DIMTXTDIRECTION", &dimtxtdirection) &&
        dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
      pass ("HEADER.DIMTXTDIRECTION [B] set+1 " FORMAT_B "", dimtxtdirection);
    else
      {
        fail ("HEADER.DIMTXTDIRECTION [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection); error++;
      }
    dimtxtdirection--; dwg_dynapi_header_set_value(dwg, "DIMTXTDIRECTION", &dimtxtdirection);

  }
  {
    BITCODE_BD dimaltmzf;
    if (dwg_dynapi_header_value(dwg, "DIMALTMZF", &dimaltmzf, NULL) &&
        dimaltmzf == dwg->header_vars.DIMALTMZF)
      pass ("HEADER.DIMALTMZF [BD] %g", dimaltmzf);
    else
      {
        fail ("HEADER.DIMALTMZF [BD] %g != %g", dwg->header_vars.DIMALTMZF, dimaltmzf); error++;
      }
    dimaltmzf++;
    if (dwg_dynapi_header_set_value(dwg, "DIMALTMZF", &dimaltmzf) &&
        dimaltmzf == dwg->header_vars.DIMALTMZF)
      pass ("HEADER.DIMALTMZF [BD] set+1 %g", dimaltmzf);
    else
      {
        fail ("HEADER.DIMALTMZF [BD] set+1 %g != %g", dwg->header_vars.DIMALTMZF, dimaltmzf); error++;
      }
    dimaltmzf--; dwg_dynapi_header_set_value(dwg, "DIMALTMZF", &dimaltmzf);

  }
  {
    BITCODE_T dimaltmzs;
    if (dwg_dynapi_header_value(dwg, "DIMALTMZS", &dimaltmzs, NULL)
        && !memcmp(&dimaltmzs, &dwg->header_vars.DIMALTMZS, sizeof(dwg->header_vars.DIMALTMZS))
       )
      pass ("HEADER.DIMALTMZS [T]");
    else
      {
        fail ("HEADER.DIMALTMZS [T]"); error++;
      }
  }
  {
    BITCODE_BD dimmzf;
    if (dwg_dynapi_header_value(dwg, "DIMMZF", &dimmzf, NULL) &&
        dimmzf == dwg->header_vars.DIMMZF)
      pass ("HEADER.DIMMZF [BD] %g", dimmzf);
    else
      {
        fail ("HEADER.DIMMZF [BD] %g != %g", dwg->header_vars.DIMMZF, dimmzf); error++;
      }
    dimmzf++;
    if (dwg_dynapi_header_set_value(dwg, "DIMMZF", &dimmzf) &&
        dimmzf == dwg->header_vars.DIMMZF)
      pass ("HEADER.DIMMZF [BD] set+1 %g", dimmzf);
    else
      {
        fail ("HEADER.DIMMZF [BD] set+1 %g != %g", dwg->header_vars.DIMMZF, dimmzf); error++;
      }
    dimmzf--; dwg_dynapi_header_set_value(dwg, "DIMMZF", &dimmzf);

  }
  {
    BITCODE_T dimmzs;
    if (dwg_dynapi_header_value(dwg, "DIMMZS", &dimmzs, NULL)
        && !memcmp(&dimmzs, &dwg->header_vars.DIMMZS, sizeof(dwg->header_vars.DIMMZS))
       )
      pass ("HEADER.DIMMZS [T]");
    else
      {
        fail ("HEADER.DIMMZS [T]"); error++;
      }
  }
  {
    BITCODE_H dimldrblk;
    if (dwg_dynapi_header_value(dwg, "DIMLDRBLK", &dimldrblk, NULL)
        && !memcmp(&dimldrblk, &dwg->header_vars.DIMLDRBLK, sizeof(dwg->header_vars.DIMLDRBLK))
       )
      pass ("HEADER.DIMLDRBLK [H]");
    else
      {
        fail ("HEADER.DIMLDRBLK [H]"); error++;
      }
  }
  {
    BITCODE_H dimblk;
    if (dwg_dynapi_header_value(dwg, "DIMBLK", &dimblk, NULL)
        && !memcmp(&dimblk, &dwg->header_vars.DIMBLK, sizeof(dwg->header_vars.DIMBLK))
       )
      pass ("HEADER.DIMBLK [H]");
    else
      {
        fail ("HEADER.DIMBLK [H]"); error++;
      }
  }
  {
    BITCODE_H dimblk1;
    if (dwg_dynapi_header_value(dwg, "DIMBLK1", &dimblk1, NULL)
        && !memcmp(&dimblk1, &dwg->header_vars.DIMBLK1, sizeof(dwg->header_vars.DIMBLK1))
       )
      pass ("HEADER.DIMBLK1 [H]");
    else
      {
        fail ("HEADER.DIMBLK1 [H]"); error++;
      }
  }
  {
    BITCODE_H dimblk2;
    if (dwg_dynapi_header_value(dwg, "DIMBLK2", &dimblk2, NULL)
        && !memcmp(&dimblk2, &dwg->header_vars.DIMBLK2, sizeof(dwg->header_vars.DIMBLK2))
       )
      pass ("HEADER.DIMBLK2 [H]");
    else
      {
        fail ("HEADER.DIMBLK2 [H]"); error++;
      }
  }
  {
    BITCODE_H dimltype;
    if (dwg_dynapi_header_value(dwg, "DIMLTYPE", &dimltype, NULL)
        && !memcmp(&dimltype, &dwg->header_vars.DIMLTYPE, sizeof(dwg->header_vars.DIMLTYPE))
       )
      pass ("HEADER.DIMLTYPE [H]");
    else
      {
        fail ("HEADER.DIMLTYPE [H]"); error++;
      }
  }
  {
    BITCODE_H dimltex1;
    if (dwg_dynapi_header_value(dwg, "DIMLTEX1", &dimltex1, NULL)
        && !memcmp(&dimltex1, &dwg->header_vars.DIMLTEX1, sizeof(dwg->header_vars.DIMLTEX1))
       )
      pass ("HEADER.DIMLTEX1 [H]");
    else
      {
        fail ("HEADER.DIMLTEX1 [H]"); error++;
      }
  }
  {
    BITCODE_H dimltex2;
    if (dwg_dynapi_header_value(dwg, "DIMLTEX2", &dimltex2, NULL)
        && !memcmp(&dimltex2, &dwg->header_vars.DIMLTEX2, sizeof(dwg->header_vars.DIMLTEX2))
       )
      pass ("HEADER.DIMLTEX2 [H]");
    else
      {
        fail ("HEADER.DIMLTEX2 [H]"); error++;
      }
  }
  {
    BITCODE_BS dimlwd;
    if (dwg_dynapi_header_value(dwg, "DIMLWD", &dimlwd, NULL) &&
        dimlwd == dwg->header_vars.DIMLWD)
      pass ("HEADER.DIMLWD [BS] %hu", dimlwd);
    else
      {
        fail ("HEADER.DIMLWD [BS] %hu != %hu", dwg->header_vars.DIMLWD, dimlwd); error++;
      }
    dimlwd++;
    if (dwg_dynapi_header_set_value(dwg, "DIMLWD", &dimlwd) &&
        dimlwd == dwg->header_vars.DIMLWD)
      pass ("HEADER.DIMLWD [BS] set+1 %hu", dimlwd);
    else
      {
        fail ("HEADER.DIMLWD [BS] set+1 %hu != %hu", dwg->header_vars.DIMLWD, dimlwd); error++;
      }
    dimlwd--; dwg_dynapi_header_set_value(dwg, "DIMLWD", &dimlwd);

  }
  {
    BITCODE_BS dimlwe;
    if (dwg_dynapi_header_value(dwg, "DIMLWE", &dimlwe, NULL) &&
        dimlwe == dwg->header_vars.DIMLWE)
      pass ("HEADER.DIMLWE [BS] %hu", dimlwe);
    else
      {
        fail ("HEADER.DIMLWE [BS] %hu != %hu", dwg->header_vars.DIMLWE, dimlwe); error++;
      }
    dimlwe++;
    if (dwg_dynapi_header_set_value(dwg, "DIMLWE", &dimlwe) &&
        dimlwe == dwg->header_vars.DIMLWE)
      pass ("HEADER.DIMLWE [BS] set+1 %hu", dimlwe);
    else
      {
        fail ("HEADER.DIMLWE [BS] set+1 %hu != %hu", dwg->header_vars.DIMLWE, dimlwe); error++;
      }
    dimlwe--; dwg_dynapi_header_set_value(dwg, "DIMLWE", &dimlwe);

  }
  {
    BITCODE_H block_control_object;
    if (dwg_dynapi_header_value(dwg, "BLOCK_CONTROL_OBJECT", &block_control_object, NULL)
        && !memcmp(&block_control_object, &dwg->header_vars.BLOCK_CONTROL_OBJECT, sizeof(dwg->header_vars.BLOCK_CONTROL_OBJECT))
       )
      pass ("HEADER.BLOCK_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.BLOCK_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H layer_control_object;
    if (dwg_dynapi_header_value(dwg, "LAYER_CONTROL_OBJECT", &layer_control_object, NULL)
        && !memcmp(&layer_control_object, &dwg->header_vars.LAYER_CONTROL_OBJECT, sizeof(dwg->header_vars.LAYER_CONTROL_OBJECT))
       )
      pass ("HEADER.LAYER_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.LAYER_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H style_control_object;
    if (dwg_dynapi_header_value(dwg, "STYLE_CONTROL_OBJECT", &style_control_object, NULL)
        && !memcmp(&style_control_object, &dwg->header_vars.STYLE_CONTROL_OBJECT, sizeof(dwg->header_vars.STYLE_CONTROL_OBJECT))
       )
      pass ("HEADER.STYLE_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.STYLE_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H linetype_control_object;
    if (dwg_dynapi_header_value(dwg, "LINETYPE_CONTROL_OBJECT", &linetype_control_object, NULL)
        && !memcmp(&linetype_control_object, &dwg->header_vars.LINETYPE_CONTROL_OBJECT, sizeof(dwg->header_vars.LINETYPE_CONTROL_OBJECT))
       )
      pass ("HEADER.LINETYPE_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.LINETYPE_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H view_control_object;
    if (dwg_dynapi_header_value(dwg, "VIEW_CONTROL_OBJECT", &view_control_object, NULL)
        && !memcmp(&view_control_object, &dwg->header_vars.VIEW_CONTROL_OBJECT, sizeof(dwg->header_vars.VIEW_CONTROL_OBJECT))
       )
      pass ("HEADER.VIEW_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.VIEW_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H ucs_control_object;
    if (dwg_dynapi_header_value(dwg, "UCS_CONTROL_OBJECT", &ucs_control_object, NULL)
        && !memcmp(&ucs_control_object, &dwg->header_vars.UCS_CONTROL_OBJECT, sizeof(dwg->header_vars.UCS_CONTROL_OBJECT))
       )
      pass ("HEADER.UCS_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.UCS_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H vport_control_object;
    if (dwg_dynapi_header_value(dwg, "VPORT_CONTROL_OBJECT", &vport_control_object, NULL)
        && !memcmp(&vport_control_object, &dwg->header_vars.VPORT_CONTROL_OBJECT, sizeof(dwg->header_vars.VPORT_CONTROL_OBJECT))
       )
      pass ("HEADER.VPORT_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.VPORT_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H appid_control_object;
    if (dwg_dynapi_header_value(dwg, "APPID_CONTROL_OBJECT", &appid_control_object, NULL)
        && !memcmp(&appid_control_object, &dwg->header_vars.APPID_CONTROL_OBJECT, sizeof(dwg->header_vars.APPID_CONTROL_OBJECT))
       )
      pass ("HEADER.APPID_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.APPID_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H dimstyle_control_object;
    if (dwg_dynapi_header_value(dwg, "DIMSTYLE_CONTROL_OBJECT", &dimstyle_control_object, NULL)
        && !memcmp(&dimstyle_control_object, &dwg->header_vars.DIMSTYLE_CONTROL_OBJECT, sizeof(dwg->header_vars.DIMSTYLE_CONTROL_OBJECT))
       )
      pass ("HEADER.DIMSTYLE_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.DIMSTYLE_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H vport_entity_control_object;
    if (dwg_dynapi_header_value(dwg, "VPORT_ENTITY_CONTROL_OBJECT", &vport_entity_control_object, NULL)
        && !memcmp(&vport_entity_control_object, &dwg->header_vars.VPORT_ENTITY_CONTROL_OBJECT, sizeof(dwg->header_vars.VPORT_ENTITY_CONTROL_OBJECT))
       )
      pass ("HEADER.VPORT_ENTITY_CONTROL_OBJECT [H]");
    else
      {
        fail ("HEADER.VPORT_ENTITY_CONTROL_OBJECT [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_acad_group;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_ACAD_GROUP", &dictionary_acad_group, NULL)
        && !memcmp(&dictionary_acad_group, &dwg->header_vars.DICTIONARY_ACAD_GROUP, sizeof(dwg->header_vars.DICTIONARY_ACAD_GROUP))
       )
      pass ("HEADER.DICTIONARY_ACAD_GROUP [H]");
    else
      {
        fail ("HEADER.DICTIONARY_ACAD_GROUP [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_acad_mlinestyle;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_ACAD_MLINESTYLE", &dictionary_acad_mlinestyle, NULL)
        && !memcmp(&dictionary_acad_mlinestyle, &dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE, sizeof(dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE))
       )
      pass ("HEADER.DICTIONARY_ACAD_MLINESTYLE [H]");
    else
      {
        fail ("HEADER.DICTIONARY_ACAD_MLINESTYLE [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_named_objects;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_NAMED_OBJECTS", &dictionary_named_objects, NULL)
        && !memcmp(&dictionary_named_objects, &dwg->header_vars.DICTIONARY_NAMED_OBJECTS, sizeof(dwg->header_vars.DICTIONARY_NAMED_OBJECTS))
       )
      pass ("HEADER.DICTIONARY_NAMED_OBJECTS [H]");
    else
      {
        fail ("HEADER.DICTIONARY_NAMED_OBJECTS [H]"); error++;
      }
  }
  {
    BITCODE_BS tstackalign;
    if (dwg_dynapi_header_value(dwg, "TSTACKALIGN", &tstackalign, NULL) &&
        tstackalign == dwg->header_vars.TSTACKALIGN)
      pass ("HEADER.TSTACKALIGN [BS] %hu", tstackalign);
    else
      {
        fail ("HEADER.TSTACKALIGN [BS] %hu != %hu", dwg->header_vars.TSTACKALIGN, tstackalign); error++;
      }
    tstackalign++;
    if (dwg_dynapi_header_set_value(dwg, "TSTACKALIGN", &tstackalign) &&
        tstackalign == dwg->header_vars.TSTACKALIGN)
      pass ("HEADER.TSTACKALIGN [BS] set+1 %hu", tstackalign);
    else
      {
        fail ("HEADER.TSTACKALIGN [BS] set+1 %hu != %hu", dwg->header_vars.TSTACKALIGN, tstackalign); error++;
      }
    tstackalign--; dwg_dynapi_header_set_value(dwg, "TSTACKALIGN", &tstackalign);

  }
  {
    BITCODE_BS tstacksize;
    if (dwg_dynapi_header_value(dwg, "TSTACKSIZE", &tstacksize, NULL) &&
        tstacksize == dwg->header_vars.TSTACKSIZE)
      pass ("HEADER.TSTACKSIZE [BS] %hu", tstacksize);
    else
      {
        fail ("HEADER.TSTACKSIZE [BS] %hu != %hu", dwg->header_vars.TSTACKSIZE, tstacksize); error++;
      }
    tstacksize++;
    if (dwg_dynapi_header_set_value(dwg, "TSTACKSIZE", &tstacksize) &&
        tstacksize == dwg->header_vars.TSTACKSIZE)
      pass ("HEADER.TSTACKSIZE [BS] set+1 %hu", tstacksize);
    else
      {
        fail ("HEADER.TSTACKSIZE [BS] set+1 %hu != %hu", dwg->header_vars.TSTACKSIZE, tstacksize); error++;
      }
    tstacksize--; dwg_dynapi_header_set_value(dwg, "TSTACKSIZE", &tstacksize);

  }
  {
    BITCODE_TV hyperlinkbase;
    if (dwg_dynapi_header_value(dwg, "HYPERLINKBASE", &hyperlinkbase, NULL)
        && !memcmp(&hyperlinkbase, &dwg->header_vars.HYPERLINKBASE, sizeof(dwg->header_vars.HYPERLINKBASE))
       )
      pass ("HEADER.HYPERLINKBASE [TV]");
    else
      {
        fail ("HEADER.HYPERLINKBASE [TV]"); error++;
      }
  }
  {
    BITCODE_TV stylesheet;
    if (dwg_dynapi_header_value(dwg, "STYLESHEET", &stylesheet, NULL)
        && !memcmp(&stylesheet, &dwg->header_vars.STYLESHEET, sizeof(dwg->header_vars.STYLESHEET))
       )
      pass ("HEADER.STYLESHEET [TV]");
    else
      {
        fail ("HEADER.STYLESHEET [TV]"); error++;
      }
  }
  {
    BITCODE_H dictionary_layouts;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_LAYOUTS", &dictionary_layouts, NULL)
        && !memcmp(&dictionary_layouts, &dwg->header_vars.DICTIONARY_LAYOUTS, sizeof(dwg->header_vars.DICTIONARY_LAYOUTS))
       )
      pass ("HEADER.DICTIONARY_LAYOUTS [H]");
    else
      {
        fail ("HEADER.DICTIONARY_LAYOUTS [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_plotsettings;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_PLOTSETTINGS", &dictionary_plotsettings, NULL)
        && !memcmp(&dictionary_plotsettings, &dwg->header_vars.DICTIONARY_PLOTSETTINGS, sizeof(dwg->header_vars.DICTIONARY_PLOTSETTINGS))
       )
      pass ("HEADER.DICTIONARY_PLOTSETTINGS [H]");
    else
      {
        fail ("HEADER.DICTIONARY_PLOTSETTINGS [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_plotstyles;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_PLOTSTYLES", &dictionary_plotstyles, NULL)
        && !memcmp(&dictionary_plotstyles, &dwg->header_vars.DICTIONARY_PLOTSTYLES, sizeof(dwg->header_vars.DICTIONARY_PLOTSTYLES))
       )
      pass ("HEADER.DICTIONARY_PLOTSTYLES [H]");
    else
      {
        fail ("HEADER.DICTIONARY_PLOTSTYLES [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_materials;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_MATERIALS", &dictionary_materials, NULL)
        && !memcmp(&dictionary_materials, &dwg->header_vars.DICTIONARY_MATERIALS, sizeof(dwg->header_vars.DICTIONARY_MATERIALS))
       )
      pass ("HEADER.DICTIONARY_MATERIALS [H]");
    else
      {
        fail ("HEADER.DICTIONARY_MATERIALS [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_colors;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_COLORS", &dictionary_colors, NULL)
        && !memcmp(&dictionary_colors, &dwg->header_vars.DICTIONARY_COLORS, sizeof(dwg->header_vars.DICTIONARY_COLORS))
       )
      pass ("HEADER.DICTIONARY_COLORS [H]");
    else
      {
        fail ("HEADER.DICTIONARY_COLORS [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_visualstyle;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_VISUALSTYLE", &dictionary_visualstyle, NULL)
        && !memcmp(&dictionary_visualstyle, &dwg->header_vars.DICTIONARY_VISUALSTYLE, sizeof(dwg->header_vars.DICTIONARY_VISUALSTYLE))
       )
      pass ("HEADER.DICTIONARY_VISUALSTYLE [H]");
    else
      {
        fail ("HEADER.DICTIONARY_VISUALSTYLE [H]"); error++;
      }
  }
  {
    BITCODE_H dictionary_lightlist;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_LIGHTLIST", &dictionary_lightlist, NULL)
        && !memcmp(&dictionary_lightlist, &dwg->header_vars.DICTIONARY_LIGHTLIST, sizeof(dwg->header_vars.DICTIONARY_LIGHTLIST))
       )
      pass ("HEADER.DICTIONARY_LIGHTLIST [H]");
    else
      {
        fail ("HEADER.DICTIONARY_LIGHTLIST [H]"); error++;
      }
  }
  {
    BITCODE_H unknown_20;
    if (dwg_dynapi_header_value(dwg, "unknown_20", &unknown_20, NULL)
        && !memcmp(&unknown_20, &dwg->header_vars.unknown_20, sizeof(dwg->header_vars.unknown_20))
       )
      pass ("HEADER.unknown_20 [H]");
    else
      {
        fail ("HEADER.unknown_20 [H]"); error++;
      }
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_header_value(dwg, "FLAGS", &flags, NULL) &&
        flags == dwg->header_vars.FLAGS)
      pass ("HEADER.FLAGS [BL] %u", flags);
    else
      {
        fail ("HEADER.FLAGS [BL] %u != %u", dwg->header_vars.FLAGS, flags); error++;
      }
    flags++;
    if (dwg_dynapi_header_set_value(dwg, "FLAGS", &flags) &&
        flags == dwg->header_vars.FLAGS)
      pass ("HEADER.FLAGS [BL] set+1 %u", flags);
    else
      {
        fail ("HEADER.FLAGS [BL] set+1 %u != %u", dwg->header_vars.FLAGS, flags); error++;
      }
    flags--; dwg_dynapi_header_set_value(dwg, "FLAGS", &flags);

  }
  {
    BITCODE_RC celweight;
    if (dwg_dynapi_header_value(dwg, "CELWEIGHT", &celweight, NULL) &&
        celweight == dwg->header_vars.CELWEIGHT)
      pass ("HEADER.CELWEIGHT [RC] %u", celweight);
    else
      {
        fail ("HEADER.CELWEIGHT [RC] %u != %u", dwg->header_vars.CELWEIGHT, celweight); error++;
      }
    celweight++;
    if (dwg_dynapi_header_set_value(dwg, "CELWEIGHT", &celweight) &&
        celweight == dwg->header_vars.CELWEIGHT)
      pass ("HEADER.CELWEIGHT [RC] set+1 %u", celweight);
    else
      {
        fail ("HEADER.CELWEIGHT [RC] set+1 %u != %u", dwg->header_vars.CELWEIGHT, celweight); error++;
      }
    celweight--; dwg_dynapi_header_set_value(dwg, "CELWEIGHT", &celweight);

  }
  {
    BITCODE_B endcaps;
    if (dwg_dynapi_header_value(dwg, "ENDCAPS", &endcaps, NULL) &&
        endcaps == dwg->header_vars.ENDCAPS)
      pass ("HEADER.ENDCAPS [B] " FORMAT_B "", endcaps);
    else
      {
        fail ("HEADER.ENDCAPS [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ENDCAPS, endcaps); error++;
      }
    endcaps++;
    if (dwg_dynapi_header_set_value(dwg, "ENDCAPS", &endcaps) &&
        endcaps == dwg->header_vars.ENDCAPS)
      pass ("HEADER.ENDCAPS [B] set+1 " FORMAT_B "", endcaps);
    else
      {
        fail ("HEADER.ENDCAPS [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ENDCAPS, endcaps); error++;
      }
    endcaps--; dwg_dynapi_header_set_value(dwg, "ENDCAPS", &endcaps);

  }
  {
    BITCODE_B joinstyle;
    if (dwg_dynapi_header_value(dwg, "JOINSTYLE", &joinstyle, NULL) &&
        joinstyle == dwg->header_vars.JOINSTYLE)
      pass ("HEADER.JOINSTYLE [B] " FORMAT_B "", joinstyle);
    else
      {
        fail ("HEADER.JOINSTYLE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.JOINSTYLE, joinstyle); error++;
      }
    joinstyle++;
    if (dwg_dynapi_header_set_value(dwg, "JOINSTYLE", &joinstyle) &&
        joinstyle == dwg->header_vars.JOINSTYLE)
      pass ("HEADER.JOINSTYLE [B] set+1 " FORMAT_B "", joinstyle);
    else
      {
        fail ("HEADER.JOINSTYLE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.JOINSTYLE, joinstyle); error++;
      }
    joinstyle--; dwg_dynapi_header_set_value(dwg, "JOINSTYLE", &joinstyle);

  }
  {
    BITCODE_B lwdisplay;
    if (dwg_dynapi_header_value(dwg, "LWDISPLAY", &lwdisplay, NULL) &&
        lwdisplay == dwg->header_vars.LWDISPLAY)
      pass ("HEADER.LWDISPLAY [B] " FORMAT_B "", lwdisplay);
    else
      {
        fail ("HEADER.LWDISPLAY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LWDISPLAY, lwdisplay); error++;
      }
    lwdisplay++;
    if (dwg_dynapi_header_set_value(dwg, "LWDISPLAY", &lwdisplay) &&
        lwdisplay == dwg->header_vars.LWDISPLAY)
      pass ("HEADER.LWDISPLAY [B] set+1 " FORMAT_B "", lwdisplay);
    else
      {
        fail ("HEADER.LWDISPLAY [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LWDISPLAY, lwdisplay); error++;
      }
    lwdisplay--; dwg_dynapi_header_set_value(dwg, "LWDISPLAY", &lwdisplay);

  }
  {
    BITCODE_B xedit;
    if (dwg_dynapi_header_value(dwg, "XEDIT", &xedit, NULL) &&
        xedit == dwg->header_vars.XEDIT)
      pass ("HEADER.XEDIT [B] " FORMAT_B "", xedit);
    else
      {
        fail ("HEADER.XEDIT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.XEDIT, xedit); error++;
      }
    xedit++;
    if (dwg_dynapi_header_set_value(dwg, "XEDIT", &xedit) &&
        xedit == dwg->header_vars.XEDIT)
      pass ("HEADER.XEDIT [B] set+1 " FORMAT_B "", xedit);
    else
      {
        fail ("HEADER.XEDIT [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.XEDIT, xedit); error++;
      }
    xedit--; dwg_dynapi_header_set_value(dwg, "XEDIT", &xedit);

  }
  {
    BITCODE_B extnames;
    if (dwg_dynapi_header_value(dwg, "EXTNAMES", &extnames, NULL) &&
        extnames == dwg->header_vars.EXTNAMES)
      pass ("HEADER.EXTNAMES [B] " FORMAT_B "", extnames);
    else
      {
        fail ("HEADER.EXTNAMES [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.EXTNAMES, extnames); error++;
      }
    extnames++;
    if (dwg_dynapi_header_set_value(dwg, "EXTNAMES", &extnames) &&
        extnames == dwg->header_vars.EXTNAMES)
      pass ("HEADER.EXTNAMES [B] set+1 " FORMAT_B "", extnames);
    else
      {
        fail ("HEADER.EXTNAMES [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.EXTNAMES, extnames); error++;
      }
    extnames--; dwg_dynapi_header_set_value(dwg, "EXTNAMES", &extnames);

  }
  {
    BITCODE_B pstylemode;
    if (dwg_dynapi_header_value(dwg, "PSTYLEMODE", &pstylemode, NULL) &&
        pstylemode == dwg->header_vars.PSTYLEMODE)
      pass ("HEADER.PSTYLEMODE [B] " FORMAT_B "", pstylemode);
    else
      {
        fail ("HEADER.PSTYLEMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSTYLEMODE, pstylemode); error++;
      }
    pstylemode++;
    if (dwg_dynapi_header_set_value(dwg, "PSTYLEMODE", &pstylemode) &&
        pstylemode == dwg->header_vars.PSTYLEMODE)
      pass ("HEADER.PSTYLEMODE [B] set+1 " FORMAT_B "", pstylemode);
    else
      {
        fail ("HEADER.PSTYLEMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSTYLEMODE, pstylemode); error++;
      }
    pstylemode--; dwg_dynapi_header_set_value(dwg, "PSTYLEMODE", &pstylemode);

  }
  {
    BITCODE_B olestartup;
    if (dwg_dynapi_header_value(dwg, "OLESTARTUP", &olestartup, NULL) &&
        olestartup == dwg->header_vars.OLESTARTUP)
      pass ("HEADER.OLESTARTUP [B] " FORMAT_B "", olestartup);
    else
      {
        fail ("HEADER.OLESTARTUP [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.OLESTARTUP, olestartup); error++;
      }
    olestartup++;
    if (dwg_dynapi_header_set_value(dwg, "OLESTARTUP", &olestartup) &&
        olestartup == dwg->header_vars.OLESTARTUP)
      pass ("HEADER.OLESTARTUP [B] set+1 " FORMAT_B "", olestartup);
    else
      {
        fail ("HEADER.OLESTARTUP [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.OLESTARTUP, olestartup); error++;
      }
    olestartup--; dwg_dynapi_header_set_value(dwg, "OLESTARTUP", &olestartup);

  }
  {
    BITCODE_BS insunits;
    if (dwg_dynapi_header_value(dwg, "INSUNITS", &insunits, NULL) &&
        insunits == dwg->header_vars.INSUNITS)
      pass ("HEADER.INSUNITS [BS] %hu", insunits);
    else
      {
        fail ("HEADER.INSUNITS [BS] %hu != %hu", dwg->header_vars.INSUNITS, insunits); error++;
      }
    insunits++;
    if (dwg_dynapi_header_set_value(dwg, "INSUNITS", &insunits) &&
        insunits == dwg->header_vars.INSUNITS)
      pass ("HEADER.INSUNITS [BS] set+1 %hu", insunits);
    else
      {
        fail ("HEADER.INSUNITS [BS] set+1 %hu != %hu", dwg->header_vars.INSUNITS, insunits); error++;
      }
    insunits--; dwg_dynapi_header_set_value(dwg, "INSUNITS", &insunits);

  }
  {
    BITCODE_BS cepsntype;
    if (dwg_dynapi_header_value(dwg, "CEPSNTYPE", &cepsntype, NULL) &&
        cepsntype == dwg->header_vars.CEPSNTYPE)
      pass ("HEADER.CEPSNTYPE [BS] %hu", cepsntype);
    else
      {
        fail ("HEADER.CEPSNTYPE [BS] %hu != %hu", dwg->header_vars.CEPSNTYPE, cepsntype); error++;
      }
    cepsntype++;
    if (dwg_dynapi_header_set_value(dwg, "CEPSNTYPE", &cepsntype) &&
        cepsntype == dwg->header_vars.CEPSNTYPE)
      pass ("HEADER.CEPSNTYPE [BS] set+1 %hu", cepsntype);
    else
      {
        fail ("HEADER.CEPSNTYPE [BS] set+1 %hu != %hu", dwg->header_vars.CEPSNTYPE, cepsntype); error++;
      }
    cepsntype--; dwg_dynapi_header_set_value(dwg, "CEPSNTYPE", &cepsntype);

  }
  {
    BITCODE_H cpsnid;
    if (dwg_dynapi_header_value(dwg, "CPSNID", &cpsnid, NULL)
        && !memcmp(&cpsnid, &dwg->header_vars.CPSNID, sizeof(dwg->header_vars.CPSNID))
       )
      pass ("HEADER.CPSNID [H]");
    else
      {
        fail ("HEADER.CPSNID [H]"); error++;
      }
  }
  {
    BITCODE_TV fingerprintguid;
    if (dwg_dynapi_header_value(dwg, "FINGERPRINTGUID", &fingerprintguid, NULL)
        && !memcmp(&fingerprintguid, &dwg->header_vars.FINGERPRINTGUID, sizeof(dwg->header_vars.FINGERPRINTGUID))
       )
      pass ("HEADER.FINGERPRINTGUID [TV]");
    else
      {
        fail ("HEADER.FINGERPRINTGUID [TV]"); error++;
      }
  }
  {
    BITCODE_TV versionguid;
    if (dwg_dynapi_header_value(dwg, "VERSIONGUID", &versionguid, NULL)
        && !memcmp(&versionguid, &dwg->header_vars.VERSIONGUID, sizeof(dwg->header_vars.VERSIONGUID))
       )
      pass ("HEADER.VERSIONGUID [TV]");
    else
      {
        fail ("HEADER.VERSIONGUID [TV]"); error++;
      }
  }
  {
    BITCODE_RC sortents;
    if (dwg_dynapi_header_value(dwg, "SORTENTS", &sortents, NULL) &&
        sortents == dwg->header_vars.SORTENTS)
      pass ("HEADER.SORTENTS [RC] %u", sortents);
    else
      {
        fail ("HEADER.SORTENTS [RC] %u != %u", dwg->header_vars.SORTENTS, sortents); error++;
      }
    sortents++;
    if (dwg_dynapi_header_set_value(dwg, "SORTENTS", &sortents) &&
        sortents == dwg->header_vars.SORTENTS)
      pass ("HEADER.SORTENTS [RC] set+1 %u", sortents);
    else
      {
        fail ("HEADER.SORTENTS [RC] set+1 %u != %u", dwg->header_vars.SORTENTS, sortents); error++;
      }
    sortents--; dwg_dynapi_header_set_value(dwg, "SORTENTS", &sortents);

  }
  {
    BITCODE_RC indexctl;
    if (dwg_dynapi_header_value(dwg, "INDEXCTL", &indexctl, NULL) &&
        indexctl == dwg->header_vars.INDEXCTL)
      pass ("HEADER.INDEXCTL [RC] %u", indexctl);
    else
      {
        fail ("HEADER.INDEXCTL [RC] %u != %u", dwg->header_vars.INDEXCTL, indexctl); error++;
      }
    indexctl++;
    if (dwg_dynapi_header_set_value(dwg, "INDEXCTL", &indexctl) &&
        indexctl == dwg->header_vars.INDEXCTL)
      pass ("HEADER.INDEXCTL [RC] set+1 %u", indexctl);
    else
      {
        fail ("HEADER.INDEXCTL [RC] set+1 %u != %u", dwg->header_vars.INDEXCTL, indexctl); error++;
      }
    indexctl--; dwg_dynapi_header_set_value(dwg, "INDEXCTL", &indexctl);

  }
  {
    BITCODE_RC hidetext;
    if (dwg_dynapi_header_value(dwg, "HIDETEXT", &hidetext, NULL) &&
        hidetext == dwg->header_vars.HIDETEXT)
      pass ("HEADER.HIDETEXT [RC] %u", hidetext);
    else
      {
        fail ("HEADER.HIDETEXT [RC] %u != %u", dwg->header_vars.HIDETEXT, hidetext); error++;
      }
    hidetext++;
    if (dwg_dynapi_header_set_value(dwg, "HIDETEXT", &hidetext) &&
        hidetext == dwg->header_vars.HIDETEXT)
      pass ("HEADER.HIDETEXT [RC] set+1 %u", hidetext);
    else
      {
        fail ("HEADER.HIDETEXT [RC] set+1 %u != %u", dwg->header_vars.HIDETEXT, hidetext); error++;
      }
    hidetext--; dwg_dynapi_header_set_value(dwg, "HIDETEXT", &hidetext);

  }
  {
    BITCODE_RC xclipframe;
    if (dwg_dynapi_header_value(dwg, "XCLIPFRAME", &xclipframe, NULL) &&
        xclipframe == dwg->header_vars.XCLIPFRAME)
      pass ("HEADER.XCLIPFRAME [RC] %u", xclipframe);
    else
      {
        fail ("HEADER.XCLIPFRAME [RC] %u != %u", dwg->header_vars.XCLIPFRAME, xclipframe); error++;
      }
    xclipframe++;
    if (dwg_dynapi_header_set_value(dwg, "XCLIPFRAME", &xclipframe) &&
        xclipframe == dwg->header_vars.XCLIPFRAME)
      pass ("HEADER.XCLIPFRAME [RC] set+1 %u", xclipframe);
    else
      {
        fail ("HEADER.XCLIPFRAME [RC] set+1 %u != %u", dwg->header_vars.XCLIPFRAME, xclipframe); error++;
      }
    xclipframe--; dwg_dynapi_header_set_value(dwg, "XCLIPFRAME", &xclipframe);

  }
  {
    BITCODE_RC dimassoc;
    if (dwg_dynapi_header_value(dwg, "DIMASSOC", &dimassoc, NULL) &&
        dimassoc == dwg->header_vars.DIMASSOC)
      pass ("HEADER.DIMASSOC [RC] %u", dimassoc);
    else
      {
        fail ("HEADER.DIMASSOC [RC] %u != %u", dwg->header_vars.DIMASSOC, dimassoc); error++;
      }
    dimassoc++;
    if (dwg_dynapi_header_set_value(dwg, "DIMASSOC", &dimassoc) &&
        dimassoc == dwg->header_vars.DIMASSOC)
      pass ("HEADER.DIMASSOC [RC] set+1 %u", dimassoc);
    else
      {
        fail ("HEADER.DIMASSOC [RC] set+1 %u != %u", dwg->header_vars.DIMASSOC, dimassoc); error++;
      }
    dimassoc--; dwg_dynapi_header_set_value(dwg, "DIMASSOC", &dimassoc);

  }
  {
    BITCODE_RC halogap;
    if (dwg_dynapi_header_value(dwg, "HALOGAP", &halogap, NULL) &&
        halogap == dwg->header_vars.HALOGAP)
      pass ("HEADER.HALOGAP [RC] %u", halogap);
    else
      {
        fail ("HEADER.HALOGAP [RC] %u != %u", dwg->header_vars.HALOGAP, halogap); error++;
      }
    halogap++;
    if (dwg_dynapi_header_set_value(dwg, "HALOGAP", &halogap) &&
        halogap == dwg->header_vars.HALOGAP)
      pass ("HEADER.HALOGAP [RC] set+1 %u", halogap);
    else
      {
        fail ("HEADER.HALOGAP [RC] set+1 %u != %u", dwg->header_vars.HALOGAP, halogap); error++;
      }
    halogap--; dwg_dynapi_header_set_value(dwg, "HALOGAP", &halogap);

  }
  {
    BITCODE_BS obscolor;
    if (dwg_dynapi_header_value(dwg, "OBSCOLOR", &obscolor, NULL) &&
        obscolor == dwg->header_vars.OBSCOLOR)
      pass ("HEADER.OBSCOLOR [BS] %hu", obscolor);
    else
      {
        fail ("HEADER.OBSCOLOR [BS] %hu != %hu", dwg->header_vars.OBSCOLOR, obscolor); error++;
      }
    obscolor++;
    if (dwg_dynapi_header_set_value(dwg, "OBSCOLOR", &obscolor) &&
        obscolor == dwg->header_vars.OBSCOLOR)
      pass ("HEADER.OBSCOLOR [BS] set+1 %hu", obscolor);
    else
      {
        fail ("HEADER.OBSCOLOR [BS] set+1 %hu != %hu", dwg->header_vars.OBSCOLOR, obscolor); error++;
      }
    obscolor--; dwg_dynapi_header_set_value(dwg, "OBSCOLOR", &obscolor);

  }
  {
    BITCODE_BS intersectioncolor;
    if (dwg_dynapi_header_value(dwg, "INTERSECTIONCOLOR", &intersectioncolor, NULL) &&
        intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
      pass ("HEADER.INTERSECTIONCOLOR [BS] %hu", intersectioncolor);
    else
      {
        fail ("HEADER.INTERSECTIONCOLOR [BS] %hu != %hu", dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor); error++;
      }
    intersectioncolor++;
    if (dwg_dynapi_header_set_value(dwg, "INTERSECTIONCOLOR", &intersectioncolor) &&
        intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
      pass ("HEADER.INTERSECTIONCOLOR [BS] set+1 %hu", intersectioncolor);
    else
      {
        fail ("HEADER.INTERSECTIONCOLOR [BS] set+1 %hu != %hu", dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor); error++;
      }
    intersectioncolor--; dwg_dynapi_header_set_value(dwg, "INTERSECTIONCOLOR", &intersectioncolor);

  }
  {
    BITCODE_RC obsltype;
    if (dwg_dynapi_header_value(dwg, "OBSLTYPE", &obsltype, NULL) &&
        obsltype == dwg->header_vars.OBSLTYPE)
      pass ("HEADER.OBSLTYPE [RC] %u", obsltype);
    else
      {
        fail ("HEADER.OBSLTYPE [RC] %u != %u", dwg->header_vars.OBSLTYPE, obsltype); error++;
      }
    obsltype++;
    if (dwg_dynapi_header_set_value(dwg, "OBSLTYPE", &obsltype) &&
        obsltype == dwg->header_vars.OBSLTYPE)
      pass ("HEADER.OBSLTYPE [RC] set+1 %u", obsltype);
    else
      {
        fail ("HEADER.OBSLTYPE [RC] set+1 %u != %u", dwg->header_vars.OBSLTYPE, obsltype); error++;
      }
    obsltype--; dwg_dynapi_header_set_value(dwg, "OBSLTYPE", &obsltype);

  }
  {
    BITCODE_RC intersectiondisplay;
    if (dwg_dynapi_header_value(dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, NULL) &&
        intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
      pass ("HEADER.INTERSECTIONDISPLAY [RC] %u", intersectiondisplay);
    else
      {
        fail ("HEADER.INTERSECTIONDISPLAY [RC] %u != %u", dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay); error++;
      }
    intersectiondisplay++;
    if (dwg_dynapi_header_set_value(dwg, "INTERSECTIONDISPLAY", &intersectiondisplay) &&
        intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
      pass ("HEADER.INTERSECTIONDISPLAY [RC] set+1 %u", intersectiondisplay);
    else
      {
        fail ("HEADER.INTERSECTIONDISPLAY [RC] set+1 %u != %u", dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay); error++;
      }
    intersectiondisplay--; dwg_dynapi_header_set_value(dwg, "INTERSECTIONDISPLAY", &intersectiondisplay);

  }
  {
    BITCODE_TV projectname;
    if (dwg_dynapi_header_value(dwg, "PROJECTNAME", &projectname, NULL)
        && !memcmp(&projectname, &dwg->header_vars.PROJECTNAME, sizeof(dwg->header_vars.PROJECTNAME))
       )
      pass ("HEADER.PROJECTNAME [TV]");
    else
      {
        fail ("HEADER.PROJECTNAME [TV]"); error++;
      }
  }
  {
    BITCODE_H block_record_pspace;
    if (dwg_dynapi_header_value(dwg, "BLOCK_RECORD_PSPACE", &block_record_pspace, NULL)
        && !memcmp(&block_record_pspace, &dwg->header_vars.BLOCK_RECORD_PSPACE, sizeof(dwg->header_vars.BLOCK_RECORD_PSPACE))
       )
      pass ("HEADER.BLOCK_RECORD_PSPACE [H]");
    else
      {
        fail ("HEADER.BLOCK_RECORD_PSPACE [H]"); error++;
      }
  }
  {
    BITCODE_H block_record_mspace;
    if (dwg_dynapi_header_value(dwg, "BLOCK_RECORD_MSPACE", &block_record_mspace, NULL)
        && !memcmp(&block_record_mspace, &dwg->header_vars.BLOCK_RECORD_MSPACE, sizeof(dwg->header_vars.BLOCK_RECORD_MSPACE))
       )
      pass ("HEADER.BLOCK_RECORD_MSPACE [H]");
    else
      {
        fail ("HEADER.BLOCK_RECORD_MSPACE [H]"); error++;
      }
  }
  {
    BITCODE_H ltype_bylayer;
    if (dwg_dynapi_header_value(dwg, "LTYPE_BYLAYER", &ltype_bylayer, NULL)
        && !memcmp(&ltype_bylayer, &dwg->header_vars.LTYPE_BYLAYER, sizeof(dwg->header_vars.LTYPE_BYLAYER))
       )
      pass ("HEADER.LTYPE_BYLAYER [H]");
    else
      {
        fail ("HEADER.LTYPE_BYLAYER [H]"); error++;
      }
  }
  {
    BITCODE_H ltype_byblock;
    if (dwg_dynapi_header_value(dwg, "LTYPE_BYBLOCK", &ltype_byblock, NULL)
        && !memcmp(&ltype_byblock, &dwg->header_vars.LTYPE_BYBLOCK, sizeof(dwg->header_vars.LTYPE_BYBLOCK))
       )
      pass ("HEADER.LTYPE_BYBLOCK [H]");
    else
      {
        fail ("HEADER.LTYPE_BYBLOCK [H]"); error++;
      }
  }
  {
    BITCODE_H ltype_continuous;
    if (dwg_dynapi_header_value(dwg, "LTYPE_CONTINUOUS", &ltype_continuous, NULL)
        && !memcmp(&ltype_continuous, &dwg->header_vars.LTYPE_CONTINUOUS, sizeof(dwg->header_vars.LTYPE_CONTINUOUS))
       )
      pass ("HEADER.LTYPE_CONTINUOUS [H]");
    else
      {
        fail ("HEADER.LTYPE_CONTINUOUS [H]"); error++;
      }
  }
  {
    BITCODE_B cameradisplay;
    if (dwg_dynapi_header_value(dwg, "CAMERADISPLAY", &cameradisplay, NULL) &&
        cameradisplay == dwg->header_vars.CAMERADISPLAY)
      pass ("HEADER.CAMERADISPLAY [B] " FORMAT_B "", cameradisplay);
    else
      {
        fail ("HEADER.CAMERADISPLAY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.CAMERADISPLAY, cameradisplay); error++;
      }
    cameradisplay++;
    if (dwg_dynapi_header_set_value(dwg, "CAMERADISPLAY", &cameradisplay) &&
        cameradisplay == dwg->header_vars.CAMERADISPLAY)
      pass ("HEADER.CAMERADISPLAY [B] set+1 " FORMAT_B "", cameradisplay);
    else
      {
        fail ("HEADER.CAMERADISPLAY [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.CAMERADISPLAY, cameradisplay); error++;
      }
    cameradisplay--; dwg_dynapi_header_set_value(dwg, "CAMERADISPLAY", &cameradisplay);

  }
  {
    BITCODE_BL unknown_21;
    if (dwg_dynapi_header_value(dwg, "unknown_21", &unknown_21, NULL) &&
        unknown_21 == dwg->header_vars.unknown_21)
      pass ("HEADER.unknown_21 [BL] %u", unknown_21);
    else
      {
        fail ("HEADER.unknown_21 [BL] %u != %u", dwg->header_vars.unknown_21, unknown_21); error++;
      }
    unknown_21++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_21", &unknown_21) &&
        unknown_21 == dwg->header_vars.unknown_21)
      pass ("HEADER.unknown_21 [BL] set+1 %u", unknown_21);
    else
      {
        fail ("HEADER.unknown_21 [BL] set+1 %u != %u", dwg->header_vars.unknown_21, unknown_21); error++;
      }
    unknown_21--; dwg_dynapi_header_set_value(dwg, "unknown_21", &unknown_21);

  }
  {
    BITCODE_BL unknown_22;
    if (dwg_dynapi_header_value(dwg, "unknown_22", &unknown_22, NULL) &&
        unknown_22 == dwg->header_vars.unknown_22)
      pass ("HEADER.unknown_22 [BL] %u", unknown_22);
    else
      {
        fail ("HEADER.unknown_22 [BL] %u != %u", dwg->header_vars.unknown_22, unknown_22); error++;
      }
    unknown_22++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_22", &unknown_22) &&
        unknown_22 == dwg->header_vars.unknown_22)
      pass ("HEADER.unknown_22 [BL] set+1 %u", unknown_22);
    else
      {
        fail ("HEADER.unknown_22 [BL] set+1 %u != %u", dwg->header_vars.unknown_22, unknown_22); error++;
      }
    unknown_22--; dwg_dynapi_header_set_value(dwg, "unknown_22", &unknown_22);

  }
  {
    BITCODE_BD unknown_23;
    if (dwg_dynapi_header_value(dwg, "unknown_23", &unknown_23, NULL) &&
        unknown_23 == dwg->header_vars.unknown_23)
      pass ("HEADER.unknown_23 [BD] %g", unknown_23);
    else
      {
        fail ("HEADER.unknown_23 [BD] %g != %g", dwg->header_vars.unknown_23, unknown_23); error++;
      }
    unknown_23++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_23", &unknown_23) &&
        unknown_23 == dwg->header_vars.unknown_23)
      pass ("HEADER.unknown_23 [BD] set+1 %g", unknown_23);
    else
      {
        fail ("HEADER.unknown_23 [BD] set+1 %g != %g", dwg->header_vars.unknown_23, unknown_23); error++;
      }
    unknown_23--; dwg_dynapi_header_set_value(dwg, "unknown_23", &unknown_23);

  }
  {
    BITCODE_BD stepspersec;
    if (dwg_dynapi_header_value(dwg, "STEPSPERSEC", &stepspersec, NULL) &&
        stepspersec == dwg->header_vars.STEPSPERSEC)
      pass ("HEADER.STEPSPERSEC [BD] %g", stepspersec);
    else
      {
        fail ("HEADER.STEPSPERSEC [BD] %g != %g", dwg->header_vars.STEPSPERSEC, stepspersec); error++;
      }
    stepspersec++;
    if (dwg_dynapi_header_set_value(dwg, "STEPSPERSEC", &stepspersec) &&
        stepspersec == dwg->header_vars.STEPSPERSEC)
      pass ("HEADER.STEPSPERSEC [BD] set+1 %g", stepspersec);
    else
      {
        fail ("HEADER.STEPSPERSEC [BD] set+1 %g != %g", dwg->header_vars.STEPSPERSEC, stepspersec); error++;
      }
    stepspersec--; dwg_dynapi_header_set_value(dwg, "STEPSPERSEC", &stepspersec);

  }
  {
    BITCODE_BD stepsize;
    if (dwg_dynapi_header_value(dwg, "STEPSIZE", &stepsize, NULL) &&
        stepsize == dwg->header_vars.STEPSIZE)
      pass ("HEADER.STEPSIZE [BD] %g", stepsize);
    else
      {
        fail ("HEADER.STEPSIZE [BD] %g != %g", dwg->header_vars.STEPSIZE, stepsize); error++;
      }
    stepsize++;
    if (dwg_dynapi_header_set_value(dwg, "STEPSIZE", &stepsize) &&
        stepsize == dwg->header_vars.STEPSIZE)
      pass ("HEADER.STEPSIZE [BD] set+1 %g", stepsize);
    else
      {
        fail ("HEADER.STEPSIZE [BD] set+1 %g != %g", dwg->header_vars.STEPSIZE, stepsize); error++;
      }
    stepsize--; dwg_dynapi_header_set_value(dwg, "STEPSIZE", &stepsize);

  }
  {
    BITCODE_BD _3ddwfprec;
    if (dwg_dynapi_header_value(dwg, "_3DDWFPREC", &_3ddwfprec, NULL) &&
        _3ddwfprec == dwg->header_vars._3DDWFPREC)
      pass ("HEADER._3DDWFPREC [BD] %g", _3ddwfprec);
    else
      {
        fail ("HEADER._3DDWFPREC [BD] %g != %g", dwg->header_vars._3DDWFPREC, _3ddwfprec); error++;
      }
    _3ddwfprec++;
    if (dwg_dynapi_header_set_value(dwg, "_3DDWFPREC", &_3ddwfprec) &&
        _3ddwfprec == dwg->header_vars._3DDWFPREC)
      pass ("HEADER._3DDWFPREC [BD] set+1 %g", _3ddwfprec);
    else
      {
        fail ("HEADER._3DDWFPREC [BD] set+1 %g != %g", dwg->header_vars._3DDWFPREC, _3ddwfprec); error++;
      }
    _3ddwfprec--; dwg_dynapi_header_set_value(dwg, "_3DDWFPREC", &_3ddwfprec);

  }
  {
    BITCODE_BD lenslength;
    if (dwg_dynapi_header_value(dwg, "LENSLENGTH", &lenslength, NULL) &&
        lenslength == dwg->header_vars.LENSLENGTH)
      pass ("HEADER.LENSLENGTH [BD] %g", lenslength);
    else
      {
        fail ("HEADER.LENSLENGTH [BD] %g != %g", dwg->header_vars.LENSLENGTH, lenslength); error++;
      }
    lenslength++;
    if (dwg_dynapi_header_set_value(dwg, "LENSLENGTH", &lenslength) &&
        lenslength == dwg->header_vars.LENSLENGTH)
      pass ("HEADER.LENSLENGTH [BD] set+1 %g", lenslength);
    else
      {
        fail ("HEADER.LENSLENGTH [BD] set+1 %g != %g", dwg->header_vars.LENSLENGTH, lenslength); error++;
      }
    lenslength--; dwg_dynapi_header_set_value(dwg, "LENSLENGTH", &lenslength);

  }
  {
    BITCODE_BD cameraheight;
    if (dwg_dynapi_header_value(dwg, "CAMERAHEIGHT", &cameraheight, NULL) &&
        cameraheight == dwg->header_vars.CAMERAHEIGHT)
      pass ("HEADER.CAMERAHEIGHT [BD] %g", cameraheight);
    else
      {
        fail ("HEADER.CAMERAHEIGHT [BD] %g != %g", dwg->header_vars.CAMERAHEIGHT, cameraheight); error++;
      }
    cameraheight++;
    if (dwg_dynapi_header_set_value(dwg, "CAMERAHEIGHT", &cameraheight) &&
        cameraheight == dwg->header_vars.CAMERAHEIGHT)
      pass ("HEADER.CAMERAHEIGHT [BD] set+1 %g", cameraheight);
    else
      {
        fail ("HEADER.CAMERAHEIGHT [BD] set+1 %g != %g", dwg->header_vars.CAMERAHEIGHT, cameraheight); error++;
      }
    cameraheight--; dwg_dynapi_header_set_value(dwg, "CAMERAHEIGHT", &cameraheight);

  }
  {
    BITCODE_RC solidhist;
    if (dwg_dynapi_header_value(dwg, "SOLIDHIST", &solidhist, NULL) &&
        solidhist == dwg->header_vars.SOLIDHIST)
      pass ("HEADER.SOLIDHIST [RC] %u", solidhist);
    else
      {
        fail ("HEADER.SOLIDHIST [RC] %u != %u", dwg->header_vars.SOLIDHIST, solidhist); error++;
      }
    solidhist++;
    if (dwg_dynapi_header_set_value(dwg, "SOLIDHIST", &solidhist) &&
        solidhist == dwg->header_vars.SOLIDHIST)
      pass ("HEADER.SOLIDHIST [RC] set+1 %u", solidhist);
    else
      {
        fail ("HEADER.SOLIDHIST [RC] set+1 %u != %u", dwg->header_vars.SOLIDHIST, solidhist); error++;
      }
    solidhist--; dwg_dynapi_header_set_value(dwg, "SOLIDHIST", &solidhist);

  }
  {
    BITCODE_RC showhist;
    if (dwg_dynapi_header_value(dwg, "SHOWHIST", &showhist, NULL) &&
        showhist == dwg->header_vars.SHOWHIST)
      pass ("HEADER.SHOWHIST [RC] %u", showhist);
    else
      {
        fail ("HEADER.SHOWHIST [RC] %u != %u", dwg->header_vars.SHOWHIST, showhist); error++;
      }
    showhist++;
    if (dwg_dynapi_header_set_value(dwg, "SHOWHIST", &showhist) &&
        showhist == dwg->header_vars.SHOWHIST)
      pass ("HEADER.SHOWHIST [RC] set+1 %u", showhist);
    else
      {
        fail ("HEADER.SHOWHIST [RC] set+1 %u != %u", dwg->header_vars.SHOWHIST, showhist); error++;
      }
    showhist--; dwg_dynapi_header_set_value(dwg, "SHOWHIST", &showhist);

  }
  {
    BITCODE_BD psolwidth;
    if (dwg_dynapi_header_value(dwg, "PSOLWIDTH", &psolwidth, NULL) &&
        psolwidth == dwg->header_vars.PSOLWIDTH)
      pass ("HEADER.PSOLWIDTH [BD] %g", psolwidth);
    else
      {
        fail ("HEADER.PSOLWIDTH [BD] %g != %g", dwg->header_vars.PSOLWIDTH, psolwidth); error++;
      }
    psolwidth++;
    if (dwg_dynapi_header_set_value(dwg, "PSOLWIDTH", &psolwidth) &&
        psolwidth == dwg->header_vars.PSOLWIDTH)
      pass ("HEADER.PSOLWIDTH [BD] set+1 %g", psolwidth);
    else
      {
        fail ("HEADER.PSOLWIDTH [BD] set+1 %g != %g", dwg->header_vars.PSOLWIDTH, psolwidth); error++;
      }
    psolwidth--; dwg_dynapi_header_set_value(dwg, "PSOLWIDTH", &psolwidth);

  }
  {
    BITCODE_BD psolheight;
    if (dwg_dynapi_header_value(dwg, "PSOLHEIGHT", &psolheight, NULL) &&
        psolheight == dwg->header_vars.PSOLHEIGHT)
      pass ("HEADER.PSOLHEIGHT [BD] %g", psolheight);
    else
      {
        fail ("HEADER.PSOLHEIGHT [BD] %g != %g", dwg->header_vars.PSOLHEIGHT, psolheight); error++;
      }
    psolheight++;
    if (dwg_dynapi_header_set_value(dwg, "PSOLHEIGHT", &psolheight) &&
        psolheight == dwg->header_vars.PSOLHEIGHT)
      pass ("HEADER.PSOLHEIGHT [BD] set+1 %g", psolheight);
    else
      {
        fail ("HEADER.PSOLHEIGHT [BD] set+1 %g != %g", dwg->header_vars.PSOLHEIGHT, psolheight); error++;
      }
    psolheight--; dwg_dynapi_header_set_value(dwg, "PSOLHEIGHT", &psolheight);

  }
  {
    BITCODE_BD loftang1;
    if (dwg_dynapi_header_value(dwg, "LOFTANG1", &loftang1, NULL) &&
        loftang1 == dwg->header_vars.LOFTANG1)
      pass ("HEADER.LOFTANG1 [BD] %g", loftang1);
    else
      {
        fail ("HEADER.LOFTANG1 [BD] %g != %g", dwg->header_vars.LOFTANG1, loftang1); error++;
      }
    loftang1++;
    if (dwg_dynapi_header_set_value(dwg, "LOFTANG1", &loftang1) &&
        loftang1 == dwg->header_vars.LOFTANG1)
      pass ("HEADER.LOFTANG1 [BD] set+1 %g", loftang1);
    else
      {
        fail ("HEADER.LOFTANG1 [BD] set+1 %g != %g", dwg->header_vars.LOFTANG1, loftang1); error++;
      }
    loftang1--; dwg_dynapi_header_set_value(dwg, "LOFTANG1", &loftang1);

  }
  {
    BITCODE_BD loftang2;
    if (dwg_dynapi_header_value(dwg, "LOFTANG2", &loftang2, NULL) &&
        loftang2 == dwg->header_vars.LOFTANG2)
      pass ("HEADER.LOFTANG2 [BD] %g", loftang2);
    else
      {
        fail ("HEADER.LOFTANG2 [BD] %g != %g", dwg->header_vars.LOFTANG2, loftang2); error++;
      }
    loftang2++;
    if (dwg_dynapi_header_set_value(dwg, "LOFTANG2", &loftang2) &&
        loftang2 == dwg->header_vars.LOFTANG2)
      pass ("HEADER.LOFTANG2 [BD] set+1 %g", loftang2);
    else
      {
        fail ("HEADER.LOFTANG2 [BD] set+1 %g != %g", dwg->header_vars.LOFTANG2, loftang2); error++;
      }
    loftang2--; dwg_dynapi_header_set_value(dwg, "LOFTANG2", &loftang2);

  }
  {
    BITCODE_BD loftmag1;
    if (dwg_dynapi_header_value(dwg, "LOFTMAG1", &loftmag1, NULL) &&
        loftmag1 == dwg->header_vars.LOFTMAG1)
      pass ("HEADER.LOFTMAG1 [BD] %g", loftmag1);
    else
      {
        fail ("HEADER.LOFTMAG1 [BD] %g != %g", dwg->header_vars.LOFTMAG1, loftmag1); error++;
      }
    loftmag1++;
    if (dwg_dynapi_header_set_value(dwg, "LOFTMAG1", &loftmag1) &&
        loftmag1 == dwg->header_vars.LOFTMAG1)
      pass ("HEADER.LOFTMAG1 [BD] set+1 %g", loftmag1);
    else
      {
        fail ("HEADER.LOFTMAG1 [BD] set+1 %g != %g", dwg->header_vars.LOFTMAG1, loftmag1); error++;
      }
    loftmag1--; dwg_dynapi_header_set_value(dwg, "LOFTMAG1", &loftmag1);

  }
  {
    BITCODE_BD loftmag2;
    if (dwg_dynapi_header_value(dwg, "LOFTMAG2", &loftmag2, NULL) &&
        loftmag2 == dwg->header_vars.LOFTMAG2)
      pass ("HEADER.LOFTMAG2 [BD] %g", loftmag2);
    else
      {
        fail ("HEADER.LOFTMAG2 [BD] %g != %g", dwg->header_vars.LOFTMAG2, loftmag2); error++;
      }
    loftmag2++;
    if (dwg_dynapi_header_set_value(dwg, "LOFTMAG2", &loftmag2) &&
        loftmag2 == dwg->header_vars.LOFTMAG2)
      pass ("HEADER.LOFTMAG2 [BD] set+1 %g", loftmag2);
    else
      {
        fail ("HEADER.LOFTMAG2 [BD] set+1 %g != %g", dwg->header_vars.LOFTMAG2, loftmag2); error++;
      }
    loftmag2--; dwg_dynapi_header_set_value(dwg, "LOFTMAG2", &loftmag2);

  }
  {
    BITCODE_BS loftparam;
    if (dwg_dynapi_header_value(dwg, "LOFTPARAM", &loftparam, NULL) &&
        loftparam == dwg->header_vars.LOFTPARAM)
      pass ("HEADER.LOFTPARAM [BS] %hu", loftparam);
    else
      {
        fail ("HEADER.LOFTPARAM [BS] %hu != %hu", dwg->header_vars.LOFTPARAM, loftparam); error++;
      }
    loftparam++;
    if (dwg_dynapi_header_set_value(dwg, "LOFTPARAM", &loftparam) &&
        loftparam == dwg->header_vars.LOFTPARAM)
      pass ("HEADER.LOFTPARAM [BS] set+1 %hu", loftparam);
    else
      {
        fail ("HEADER.LOFTPARAM [BS] set+1 %hu != %hu", dwg->header_vars.LOFTPARAM, loftparam); error++;
      }
    loftparam--; dwg_dynapi_header_set_value(dwg, "LOFTPARAM", &loftparam);

  }
  {
    BITCODE_RC loftnormals;
    if (dwg_dynapi_header_value(dwg, "LOFTNORMALS", &loftnormals, NULL) &&
        loftnormals == dwg->header_vars.LOFTNORMALS)
      pass ("HEADER.LOFTNORMALS [RC] %u", loftnormals);
    else
      {
        fail ("HEADER.LOFTNORMALS [RC] %u != %u", dwg->header_vars.LOFTNORMALS, loftnormals); error++;
      }
    loftnormals++;
    if (dwg_dynapi_header_set_value(dwg, "LOFTNORMALS", &loftnormals) &&
        loftnormals == dwg->header_vars.LOFTNORMALS)
      pass ("HEADER.LOFTNORMALS [RC] set+1 %u", loftnormals);
    else
      {
        fail ("HEADER.LOFTNORMALS [RC] set+1 %u != %u", dwg->header_vars.LOFTNORMALS, loftnormals); error++;
      }
    loftnormals--; dwg_dynapi_header_set_value(dwg, "LOFTNORMALS", &loftnormals);

  }
  {
    BITCODE_BD latitude;
    if (dwg_dynapi_header_value(dwg, "LATITUDE", &latitude, NULL) &&
        latitude == dwg->header_vars.LATITUDE)
      pass ("HEADER.LATITUDE [BD] %g", latitude);
    else
      {
        fail ("HEADER.LATITUDE [BD] %g != %g", dwg->header_vars.LATITUDE, latitude); error++;
      }
    latitude++;
    if (dwg_dynapi_header_set_value(dwg, "LATITUDE", &latitude) &&
        latitude == dwg->header_vars.LATITUDE)
      pass ("HEADER.LATITUDE [BD] set+1 %g", latitude);
    else
      {
        fail ("HEADER.LATITUDE [BD] set+1 %g != %g", dwg->header_vars.LATITUDE, latitude); error++;
      }
    latitude--; dwg_dynapi_header_set_value(dwg, "LATITUDE", &latitude);

  }
  {
    BITCODE_BD longitude;
    if (dwg_dynapi_header_value(dwg, "LONGITUDE", &longitude, NULL) &&
        longitude == dwg->header_vars.LONGITUDE)
      pass ("HEADER.LONGITUDE [BD] %g", longitude);
    else
      {
        fail ("HEADER.LONGITUDE [BD] %g != %g", dwg->header_vars.LONGITUDE, longitude); error++;
      }
    longitude++;
    if (dwg_dynapi_header_set_value(dwg, "LONGITUDE", &longitude) &&
        longitude == dwg->header_vars.LONGITUDE)
      pass ("HEADER.LONGITUDE [BD] set+1 %g", longitude);
    else
      {
        fail ("HEADER.LONGITUDE [BD] set+1 %g != %g", dwg->header_vars.LONGITUDE, longitude); error++;
      }
    longitude--; dwg_dynapi_header_set_value(dwg, "LONGITUDE", &longitude);

  }
  {
    BITCODE_BD northdirection;
    if (dwg_dynapi_header_value(dwg, "NORTHDIRECTION", &northdirection, NULL) &&
        northdirection == dwg->header_vars.NORTHDIRECTION)
      pass ("HEADER.NORTHDIRECTION [BD] %g", northdirection);
    else
      {
        fail ("HEADER.NORTHDIRECTION [BD] %g != %g", dwg->header_vars.NORTHDIRECTION, northdirection); error++;
      }
    northdirection++;
    if (dwg_dynapi_header_set_value(dwg, "NORTHDIRECTION", &northdirection) &&
        northdirection == dwg->header_vars.NORTHDIRECTION)
      pass ("HEADER.NORTHDIRECTION [BD] set+1 %g", northdirection);
    else
      {
        fail ("HEADER.NORTHDIRECTION [BD] set+1 %g != %g", dwg->header_vars.NORTHDIRECTION, northdirection); error++;
      }
    northdirection--; dwg_dynapi_header_set_value(dwg, "NORTHDIRECTION", &northdirection);

  }
  {
    BITCODE_BL timezone;
    if (dwg_dynapi_header_value(dwg, "TIMEZONE", &timezone, NULL) &&
        timezone == dwg->header_vars.TIMEZONE)
      pass ("HEADER.TIMEZONE [BL] %u", timezone);
    else
      {
        fail ("HEADER.TIMEZONE [BL] %u != %u", dwg->header_vars.TIMEZONE, timezone); error++;
      }
    timezone++;
    if (dwg_dynapi_header_set_value(dwg, "TIMEZONE", &timezone) &&
        timezone == dwg->header_vars.TIMEZONE)
      pass ("HEADER.TIMEZONE [BL] set+1 %u", timezone);
    else
      {
        fail ("HEADER.TIMEZONE [BL] set+1 %u != %u", dwg->header_vars.TIMEZONE, timezone); error++;
      }
    timezone--; dwg_dynapi_header_set_value(dwg, "TIMEZONE", &timezone);

  }
  {
    BITCODE_RC lightglyphdisplay;
    if (dwg_dynapi_header_value(dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, NULL) &&
        lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
      pass ("HEADER.LIGHTGLYPHDISPLAY [RC] %u", lightglyphdisplay);
    else
      {
        fail ("HEADER.LIGHTGLYPHDISPLAY [RC] %u != %u", dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay); error++;
      }
    lightglyphdisplay++;
    if (dwg_dynapi_header_set_value(dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay) &&
        lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
      pass ("HEADER.LIGHTGLYPHDISPLAY [RC] set+1 %u", lightglyphdisplay);
    else
      {
        fail ("HEADER.LIGHTGLYPHDISPLAY [RC] set+1 %u != %u", dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay); error++;
      }
    lightglyphdisplay--; dwg_dynapi_header_set_value(dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay);

  }
  {
    BITCODE_RC tilemodelightsynch;
    if (dwg_dynapi_header_value(dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, NULL) &&
        tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
      pass ("HEADER.TILEMODELIGHTSYNCH [RC] %u", tilemodelightsynch);
    else
      {
        fail ("HEADER.TILEMODELIGHTSYNCH [RC] %u != %u", dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch); error++;
      }
    tilemodelightsynch++;
    if (dwg_dynapi_header_set_value(dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch) &&
        tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
      pass ("HEADER.TILEMODELIGHTSYNCH [RC] set+1 %u", tilemodelightsynch);
    else
      {
        fail ("HEADER.TILEMODELIGHTSYNCH [RC] set+1 %u != %u", dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch); error++;
      }
    tilemodelightsynch--; dwg_dynapi_header_set_value(dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch);

  }
  {
    BITCODE_RC dwfframe;
    if (dwg_dynapi_header_value(dwg, "DWFFRAME", &dwfframe, NULL) &&
        dwfframe == dwg->header_vars.DWFFRAME)
      pass ("HEADER.DWFFRAME [RC] %u", dwfframe);
    else
      {
        fail ("HEADER.DWFFRAME [RC] %u != %u", dwg->header_vars.DWFFRAME, dwfframe); error++;
      }
    dwfframe++;
    if (dwg_dynapi_header_set_value(dwg, "DWFFRAME", &dwfframe) &&
        dwfframe == dwg->header_vars.DWFFRAME)
      pass ("HEADER.DWFFRAME [RC] set+1 %u", dwfframe);
    else
      {
        fail ("HEADER.DWFFRAME [RC] set+1 %u != %u", dwg->header_vars.DWFFRAME, dwfframe); error++;
      }
    dwfframe--; dwg_dynapi_header_set_value(dwg, "DWFFRAME", &dwfframe);

  }
  {
    BITCODE_RC dgnframe;
    if (dwg_dynapi_header_value(dwg, "DGNFRAME", &dgnframe, NULL) &&
        dgnframe == dwg->header_vars.DGNFRAME)
      pass ("HEADER.DGNFRAME [RC] %u", dgnframe);
    else
      {
        fail ("HEADER.DGNFRAME [RC] %u != %u", dwg->header_vars.DGNFRAME, dgnframe); error++;
      }
    dgnframe++;
    if (dwg_dynapi_header_set_value(dwg, "DGNFRAME", &dgnframe) &&
        dgnframe == dwg->header_vars.DGNFRAME)
      pass ("HEADER.DGNFRAME [RC] set+1 %u", dgnframe);
    else
      {
        fail ("HEADER.DGNFRAME [RC] set+1 %u != %u", dwg->header_vars.DGNFRAME, dgnframe); error++;
      }
    dgnframe--; dwg_dynapi_header_set_value(dwg, "DGNFRAME", &dgnframe);

  }
  {
    BITCODE_B realworldscale;
    if (dwg_dynapi_header_value(dwg, "REALWORLDSCALE", &realworldscale, NULL) &&
        realworldscale == dwg->header_vars.REALWORLDSCALE)
      pass ("HEADER.REALWORLDSCALE [B] " FORMAT_B "", realworldscale);
    else
      {
        fail ("HEADER.REALWORLDSCALE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REALWORLDSCALE, realworldscale); error++;
      }
    realworldscale++;
    if (dwg_dynapi_header_set_value(dwg, "REALWORLDSCALE", &realworldscale) &&
        realworldscale == dwg->header_vars.REALWORLDSCALE)
      pass ("HEADER.REALWORLDSCALE [B] set+1 " FORMAT_B "", realworldscale);
    else
      {
        fail ("HEADER.REALWORLDSCALE [B] set+1 " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REALWORLDSCALE, realworldscale); error++;
      }
    realworldscale--; dwg_dynapi_header_set_value(dwg, "REALWORLDSCALE", &realworldscale);

  }
  {
    BITCODE_CMC interferecolor;
    if (dwg_dynapi_header_value(dwg, "INTERFERECOLOR", &interferecolor, NULL)
        && !memcmp(&interferecolor, &dwg->header_vars.INTERFERECOLOR, sizeof(dwg->header_vars.INTERFERECOLOR))
       )
      pass ("HEADER.INTERFERECOLOR [CMC]");
    else
      {
        fail ("HEADER.INTERFERECOLOR [CMC]"); error++;
      }
  }
  {
    BITCODE_H interfereobjvs;
    if (dwg_dynapi_header_value(dwg, "INTERFEREOBJVS", &interfereobjvs, NULL)
        && !memcmp(&interfereobjvs, &dwg->header_vars.INTERFEREOBJVS, sizeof(dwg->header_vars.INTERFEREOBJVS))
       )
      pass ("HEADER.INTERFEREOBJVS [H]");
    else
      {
        fail ("HEADER.INTERFEREOBJVS [H]"); error++;
      }
  }
  {
    BITCODE_H interferevpvs;
    if (dwg_dynapi_header_value(dwg, "INTERFEREVPVS", &interferevpvs, NULL)
        && !memcmp(&interferevpvs, &dwg->header_vars.INTERFEREVPVS, sizeof(dwg->header_vars.INTERFEREVPVS))
       )
      pass ("HEADER.INTERFEREVPVS [H]");
    else
      {
        fail ("HEADER.INTERFEREVPVS [H]"); error++;
      }
  }
  {
    BITCODE_H dragvs;
    if (dwg_dynapi_header_value(dwg, "DRAGVS", &dragvs, NULL)
        && !memcmp(&dragvs, &dwg->header_vars.DRAGVS, sizeof(dwg->header_vars.DRAGVS))
       )
      pass ("HEADER.DRAGVS [H]");
    else
      {
        fail ("HEADER.DRAGVS [H]"); error++;
      }
  }
  {
    BITCODE_RC cshadow;
    if (dwg_dynapi_header_value(dwg, "CSHADOW", &cshadow, NULL) &&
        cshadow == dwg->header_vars.CSHADOW)
      pass ("HEADER.CSHADOW [RC] %u", cshadow);
    else
      {
        fail ("HEADER.CSHADOW [RC] %u != %u", dwg->header_vars.CSHADOW, cshadow); error++;
      }
    cshadow++;
    if (dwg_dynapi_header_set_value(dwg, "CSHADOW", &cshadow) &&
        cshadow == dwg->header_vars.CSHADOW)
      pass ("HEADER.CSHADOW [RC] set+1 %u", cshadow);
    else
      {
        fail ("HEADER.CSHADOW [RC] set+1 %u != %u", dwg->header_vars.CSHADOW, cshadow); error++;
      }
    cshadow--; dwg_dynapi_header_set_value(dwg, "CSHADOW", &cshadow);

  }
  {
    BITCODE_BD shadowplanelocation;
    if (dwg_dynapi_header_value(dwg, "SHADOWPLANELOCATION", &shadowplanelocation, NULL) &&
        shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
      pass ("HEADER.SHADOWPLANELOCATION [BD] %g", shadowplanelocation);
    else
      {
        fail ("HEADER.SHADOWPLANELOCATION [BD] %g != %g", dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation); error++;
      }
    shadowplanelocation++;
    if (dwg_dynapi_header_set_value(dwg, "SHADOWPLANELOCATION", &shadowplanelocation) &&
        shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
      pass ("HEADER.SHADOWPLANELOCATION [BD] set+1 %g", shadowplanelocation);
    else
      {
        fail ("HEADER.SHADOWPLANELOCATION [BD] set+1 %g != %g", dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation); error++;
      }
    shadowplanelocation--; dwg_dynapi_header_set_value(dwg, "SHADOWPLANELOCATION", &shadowplanelocation);

  }
  {
    BITCODE_BS unknown_54;
    if (dwg_dynapi_header_value(dwg, "unknown_54", &unknown_54, NULL) &&
        unknown_54 == dwg->header_vars.unknown_54)
      pass ("HEADER.unknown_54 [BS] %hu", unknown_54);
    else
      {
        fail ("HEADER.unknown_54 [BS] %hu != %hu", dwg->header_vars.unknown_54, unknown_54); error++;
      }
    unknown_54++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_54", &unknown_54) &&
        unknown_54 == dwg->header_vars.unknown_54)
      pass ("HEADER.unknown_54 [BS] set+1 %hu", unknown_54);
    else
      {
        fail ("HEADER.unknown_54 [BS] set+1 %hu != %hu", dwg->header_vars.unknown_54, unknown_54); error++;
      }
    unknown_54--; dwg_dynapi_header_set_value(dwg, "unknown_54", &unknown_54);

  }
  {
    BITCODE_BS unknown_55;
    if (dwg_dynapi_header_value(dwg, "unknown_55", &unknown_55, NULL) &&
        unknown_55 == dwg->header_vars.unknown_55)
      pass ("HEADER.unknown_55 [BS] %hu", unknown_55);
    else
      {
        fail ("HEADER.unknown_55 [BS] %hu != %hu", dwg->header_vars.unknown_55, unknown_55); error++;
      }
    unknown_55++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_55", &unknown_55) &&
        unknown_55 == dwg->header_vars.unknown_55)
      pass ("HEADER.unknown_55 [BS] set+1 %hu", unknown_55);
    else
      {
        fail ("HEADER.unknown_55 [BS] set+1 %hu != %hu", dwg->header_vars.unknown_55, unknown_55); error++;
      }
    unknown_55--; dwg_dynapi_header_set_value(dwg, "unknown_55", &unknown_55);

  }
  {
    BITCODE_BS unknown_56;
    if (dwg_dynapi_header_value(dwg, "unknown_56", &unknown_56, NULL) &&
        unknown_56 == dwg->header_vars.unknown_56)
      pass ("HEADER.unknown_56 [BS] %hu", unknown_56);
    else
      {
        fail ("HEADER.unknown_56 [BS] %hu != %hu", dwg->header_vars.unknown_56, unknown_56); error++;
      }
    unknown_56++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_56", &unknown_56) &&
        unknown_56 == dwg->header_vars.unknown_56)
      pass ("HEADER.unknown_56 [BS] set+1 %hu", unknown_56);
    else
      {
        fail ("HEADER.unknown_56 [BS] set+1 %hu != %hu", dwg->header_vars.unknown_56, unknown_56); error++;
      }
    unknown_56--; dwg_dynapi_header_set_value(dwg, "unknown_56", &unknown_56);

  }
  {
    BITCODE_BS unknown_57;
    if (dwg_dynapi_header_value(dwg, "unknown_57", &unknown_57, NULL) &&
        unknown_57 == dwg->header_vars.unknown_57)
      pass ("HEADER.unknown_57 [BS] %hu", unknown_57);
    else
      {
        fail ("HEADER.unknown_57 [BS] %hu != %hu", dwg->header_vars.unknown_57, unknown_57); error++;
      }
    unknown_57++;
    if (dwg_dynapi_header_set_value(dwg, "unknown_57", &unknown_57) &&
        unknown_57 == dwg->header_vars.unknown_57)
      pass ("HEADER.unknown_57 [BS] set+1 %hu", unknown_57);
    else
      {
        fail ("HEADER.unknown_57 [BS] set+1 %hu != %hu", dwg->header_vars.unknown_57, unknown_57); error++;
      }
    unknown_57--; dwg_dynapi_header_set_value(dwg, "unknown_57", &unknown_57);

  }
  {
    BITCODE_RS crc;
    if (dwg_dynapi_header_value(dwg, "crc", &crc, NULL) &&
        crc == dwg->header_vars.crc)
      pass ("HEADER.crc [RS] %hu", crc);
    else
      {
        fail ("HEADER.crc [RS] %hu != %hu", dwg->header_vars.crc, crc); error++;
      }
    crc++;
    if (dwg_dynapi_header_set_value(dwg, "crc", &crc) &&
        crc == dwg->header_vars.crc)
      pass ("HEADER.crc [RS] set+1 %hu", crc);
    else
      {
        fail ("HEADER.crc [RS] set+1 %hu != %hu", dwg->header_vars.crc, crc); error++;
      }
    crc--; dwg_dynapi_header_set_value(dwg, "crc", &crc);

  }
#line 49 "dynapi_test.c.in"
  return error;
}

#line 6119 "dynapi_test.c"
/* @@for test_OBJECT@@ */
static int test__3DFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity__3DFACE *_3dface = obj->tio.entity->tio._3DFACE;
  {
    BITCODE_3BD corner1;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "corner1", &corner1, NULL)
        && !memcmp(&corner1, &_3dface->corner1, sizeof(_3dface->corner1)))
      pass ("3DFACE.corner1 [3BD]");
    else
      {
        fail ("3DFACE.corner1 [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD corner2;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "corner2", &corner2, NULL)
        && !memcmp(&corner2, &_3dface->corner2, sizeof(_3dface->corner2)))
      pass ("3DFACE.corner2 [3BD]");
    else
      {
        fail ("3DFACE.corner2 [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD corner3;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "corner3", &corner3, NULL)
        && !memcmp(&corner3, &_3dface->corner3, sizeof(_3dface->corner3)))
      pass ("3DFACE.corner3 [3BD]");
    else
      {
        fail ("3DFACE.corner3 [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD corner4;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "corner4", &corner4, NULL)
        && !memcmp(&corner4, &_3dface->corner4, sizeof(_3dface->corner4)))
      pass ("3DFACE.corner4 [3BD]");
    else
      {
        fail ("3DFACE.corner4 [3BD]"); error++;
      }
  }
  {
    BITCODE_B has_no_flags;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "has_no_flags", &has_no_flags, NULL) &&
        has_no_flags == _3dface->has_no_flags)
      pass ("3DFACE.has_no_flags [B] " FORMAT_B "", has_no_flags);
    else
      {
        fail ("3DFACE.has_no_flags [B] " FORMAT_B " != " FORMAT_B "", _3dface->has_no_flags, has_no_flags); error++;
      }
    has_no_flags++;
    if (dwg_dynapi_entity_set_value(_3dface, "3DFACE", "has_no_flags", &has_no_flags) &&
        has_no_flags == _3dface->has_no_flags)
      pass ("3DFACE.has_no_flags [B] set+1 " FORMAT_B "", has_no_flags);
    else
      {
        fail ("3DFACE.has_no_flags [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dface->has_no_flags, has_no_flags); error++;
      }
    _3dface->has_no_flags--;

  }
  {
    BITCODE_BS invis_flags;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "invis_flags", &invis_flags, NULL) &&
        invis_flags == _3dface->invis_flags)
      pass ("3DFACE.invis_flags [BS] %hu", invis_flags);
    else
      {
        fail ("3DFACE.invis_flags [BS] %hu != %hu", _3dface->invis_flags, invis_flags); error++;
      }
    invis_flags++;
    if (dwg_dynapi_entity_set_value(_3dface, "3DFACE", "invis_flags", &invis_flags) &&
        invis_flags == _3dface->invis_flags)
      pass ("3DFACE.invis_flags [BS] set+1 %hu", invis_flags);
    else
      {
        fail ("3DFACE.invis_flags [BS] set+1 %hu != %hu", _3dface->invis_flags, invis_flags); error++;
      }
    _3dface->invis_flags--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &_3dface->parent, sizeof(_3dface->parent)))
      pass ("3DFACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("3DFACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_B z_is_zero;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "z_is_zero", &z_is_zero, NULL) &&
        z_is_zero == _3dface->z_is_zero)
      pass ("3DFACE.z_is_zero [B] " FORMAT_B "", z_is_zero);
    else
      {
        fail ("3DFACE.z_is_zero [B] " FORMAT_B " != " FORMAT_B "", _3dface->z_is_zero, z_is_zero); error++;
      }
    z_is_zero++;
    if (dwg_dynapi_entity_set_value(_3dface, "3DFACE", "z_is_zero", &z_is_zero) &&
        z_is_zero == _3dface->z_is_zero)
      pass ("3DFACE.z_is_zero [B] set+1 " FORMAT_B "", z_is_zero);
    else
      {
        fail ("3DFACE.z_is_zero [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dface->z_is_zero, z_is_zero); error++;
      }
    _3dface->z_is_zero--;

  }
  return error;
}
static int test__3DSOLID (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity__3DSOLID *_3dsolid = obj->tio.entity->tio._3DSOLID;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&_3dsolid->acis_data))
      pass ("3DSOLID.acis_data [RC*]");
    else
      {
        fail ("3DSOLID.acis_data [RC*]"); error++;
      }
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "acis_empty", &acis_empty, NULL) &&
        acis_empty == _3dsolid->acis_empty)
      pass ("3DSOLID.acis_empty [B] " FORMAT_B "", acis_empty);
    else
      {
        fail ("3DSOLID.acis_empty [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty); error++;
      }
    acis_empty++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "acis_empty", &acis_empty) &&
        acis_empty == _3dsolid->acis_empty)
      pass ("3DSOLID.acis_empty [B] set+1 " FORMAT_B "", acis_empty);
    else
      {
        fail ("3DSOLID.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty); error++;
      }
    _3dsolid->acis_empty--;

  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == _3dsolid->acis_empty2)
      pass ("3DSOLID.acis_empty2 [B] " FORMAT_B "", acis_empty2);
    else
      {
        fail ("3DSOLID.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2); error++;
      }
    acis_empty2++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2) &&
        acis_empty2 == _3dsolid->acis_empty2)
      pass ("3DSOLID.acis_empty2 [B] set+1 " FORMAT_B "", acis_empty2);
    else
      {
        fail ("3DSOLID.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2); error++;
      }
    _3dsolid->acis_empty2--;

  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == _3dsolid->acis_empty_bit)
      pass ("3DSOLID.acis_empty_bit [B] " FORMAT_B "", acis_empty_bit);
    else
      {
        fail ("3DSOLID.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit); error++;
      }
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit) &&
        acis_empty_bit == _3dsolid->acis_empty_bit)
      pass ("3DSOLID.acis_empty_bit [B] set+1 " FORMAT_B "", acis_empty_bit);
    else
      {
        fail ("3DSOLID.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit); error++;
      }
    _3dsolid->acis_empty_bit--;

  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &_3dsolid->block_size, sizeof(_3dsolid->block_size)))
      pass ("3DSOLID.block_size [BL*]");
    else
      {
        fail ("3DSOLID.block_size [BL*]"); error++;
      }
  }
  {
    BITCODE_RC** encr_sat_data;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "encr_sat_data", &encr_sat_data, NULL)
)
      pass ("3DSOLID.encr_sat_data [RC**]");
    else
      {
        fail ("3DSOLID.encr_sat_data [RC**]"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &_3dsolid->extra_acis_data, sizeof(_3dsolid->extra_acis_data)))
      pass ("3DSOLID.extra_acis_data [struct _dwg_entity_3DSOLID*]");
    else
      {
        fail ("3DSOLID.extra_acis_data [struct _dwg_entity_3DSOLID*]"); error++;
      }
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &_3dsolid->history_id, sizeof(_3dsolid->history_id)))
      pass ("3DSOLID.history_id [H]");
    else
      {
        fail ("3DSOLID.history_id [H]"); error++;
      }
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "isoline_present", &isoline_present, NULL) &&
        isoline_present == _3dsolid->isoline_present)
      pass ("3DSOLID.isoline_present [B] " FORMAT_B "", isoline_present);
    else
      {
        fail ("3DSOLID.isoline_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present); error++;
      }
    isoline_present++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "isoline_present", &isoline_present) &&
        isoline_present == _3dsolid->isoline_present)
      pass ("3DSOLID.isoline_present [B] set+1 " FORMAT_B "", isoline_present);
    else
      {
        fail ("3DSOLID.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present); error++;
      }
    _3dsolid->isoline_present--;

  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "num_blocks", &num_blocks, NULL) &&
        num_blocks == _3dsolid->num_blocks)
      pass ("3DSOLID.num_blocks [BL] %u", num_blocks);
    else
      {
        fail ("3DSOLID.num_blocks [BL] %u != %u", _3dsolid->num_blocks, num_blocks); error++;
      }
    num_blocks++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "num_blocks", &num_blocks) &&
        num_blocks == _3dsolid->num_blocks)
      pass ("3DSOLID.num_blocks [BL] set+1 %u", num_blocks);
    else
      {
        fail ("3DSOLID.num_blocks [BL] set+1 %u != %u", _3dsolid->num_blocks, num_blocks); error++;
      }
    _3dsolid->num_blocks--;

  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "num_isolines", &num_isolines, NULL) &&
        num_isolines == _3dsolid->num_isolines)
      pass ("3DSOLID.num_isolines [BL] %u", num_isolines);
    else
      {
        fail ("3DSOLID.num_isolines [BL] %u != %u", _3dsolid->num_isolines, num_isolines); error++;
      }
    num_isolines++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "num_isolines", &num_isolines) &&
        num_isolines == _3dsolid->num_isolines)
      pass ("3DSOLID.num_isolines [BL] set+1 %u", num_isolines);
    else
      {
        fail ("3DSOLID.num_isolines [BL] set+1 %u != %u", _3dsolid->num_isolines, num_isolines); error++;
      }
    _3dsolid->num_isolines--;

  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == _3dsolid->num_silhouettes)
      pass ("3DSOLID.num_silhouettes [BL] %u", num_silhouettes);
    else
      {
        fail ("3DSOLID.num_silhouettes [BL] %u != %u", _3dsolid->num_silhouettes, num_silhouettes); error++;
      }
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes) &&
        num_silhouettes == _3dsolid->num_silhouettes)
      pass ("3DSOLID.num_silhouettes [BL] set+1 %u", num_silhouettes);
    else
      {
        fail ("3DSOLID.num_silhouettes [BL] set+1 %u != %u", _3dsolid->num_silhouettes, num_silhouettes); error++;
      }
    _3dsolid->num_silhouettes--;

  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "num_wires", &num_wires, NULL) &&
        num_wires == _3dsolid->num_wires)
      pass ("3DSOLID.num_wires [BL] %u", num_wires);
    else
      {
        fail ("3DSOLID.num_wires [BL] %u != %u", _3dsolid->num_wires, num_wires); error++;
      }
    num_wires++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "num_wires", &num_wires) &&
        num_wires == _3dsolid->num_wires)
      pass ("3DSOLID.num_wires [BL] set+1 %u", num_wires);
    else
      {
        fail ("3DSOLID.num_wires [BL] set+1 %u != %u", _3dsolid->num_wires, num_wires); error++;
      }
    _3dsolid->num_wires--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "parent", &parent, NULL)
        && !memcmp(&parent, &_3dsolid->parent, sizeof(_3dsolid->parent)))
      pass ("3DSOLID.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("3DSOLID.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "point", &point, NULL)
        && !memcmp(&point, &_3dsolid->point, sizeof(_3dsolid->point)))
      pass ("3DSOLID.point [3BD]");
    else
      {
        fail ("3DSOLID.point [3BD]"); error++;
      }
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "point_present", &point_present, NULL) &&
        point_present == _3dsolid->point_present)
      pass ("3DSOLID.point_present [B] " FORMAT_B "", point_present);
    else
      {
        fail ("3DSOLID.point_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present); error++;
      }
    point_present++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "point_present", &point_present) &&
        point_present == _3dsolid->point_present)
      pass ("3DSOLID.point_present [B] set+1 " FORMAT_B "", point_present);
    else
      {
        fail ("3DSOLID.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present); error++;
      }
    _3dsolid->point_present--;

  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &_3dsolid->silhouettes, sizeof(_3dsolid->silhouettes)))
      pass ("3DSOLID.silhouettes [Dwg_3DSOLID_silhouette*]");
    else
      {
        fail ("3DSOLID.silhouettes [Dwg_3DSOLID_silhouette*]"); error++;
      }
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "unknown", &unknown, NULL) &&
        unknown == _3dsolid->unknown)
      pass ("3DSOLID.unknown [B] " FORMAT_B "", unknown);
    else
      {
        fail ("3DSOLID.unknown [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "unknown", &unknown) &&
        unknown == _3dsolid->unknown)
      pass ("3DSOLID.unknown [B] set+1 " FORMAT_B "", unknown);
    else
      {
        fail ("3DSOLID.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown); error++;
      }
    _3dsolid->unknown--;

  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == _3dsolid->unknown_2007)
      pass ("3DSOLID.unknown_2007 [BL] %u", unknown_2007);
    else
      {
        fail ("3DSOLID.unknown_2007 [BL] %u != %u", _3dsolid->unknown_2007, unknown_2007); error++;
      }
    unknown_2007++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "unknown_2007", &unknown_2007) &&
        unknown_2007 == _3dsolid->unknown_2007)
      pass ("3DSOLID.unknown_2007 [BL] set+1 %u", unknown_2007);
    else
      {
        fail ("3DSOLID.unknown_2007 [BL] set+1 %u != %u", _3dsolid->unknown_2007, unknown_2007); error++;
      }
    _3dsolid->unknown_2007--;

  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "version", &version, NULL) &&
        version == _3dsolid->version)
      pass ("3DSOLID.version [BS] %hu", version);
    else
      {
        fail ("3DSOLID.version [BS] %hu != %hu", _3dsolid->version, version); error++;
      }
    version++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "version", &version) &&
        version == _3dsolid->version)
      pass ("3DSOLID.version [BS] set+1 %hu", version);
    else
      {
        fail ("3DSOLID.version [BS] set+1 %hu != %hu", _3dsolid->version, version); error++;
      }
    _3dsolid->version--;

  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == _3dsolid->wireframe_data_present)
      pass ("3DSOLID.wireframe_data_present [B] " FORMAT_B "", wireframe_data_present);
    else
      {
        fail ("3DSOLID.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present); error++;
      }
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value(_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present) &&
        wireframe_data_present == _3dsolid->wireframe_data_present)
      pass ("3DSOLID.wireframe_data_present [B] set+1 " FORMAT_B "", wireframe_data_present);
    else
      {
        fail ("3DSOLID.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present); error++;
      }
    _3dsolid->wireframe_data_present--;

  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "wires", &wires, NULL)
        && !memcmp(&wires, &_3dsolid->wires, sizeof(_3dsolid->wires)))
      pass ("3DSOLID.wires [Dwg_3DSOLID_wire*]");
    else
      {
        fail ("3DSOLID.wires [Dwg_3DSOLID_wire*]"); error++;
      }
  }
  return error;
}
static int test_ARC (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ARC *arc = obj->tio.entity->tio.ARC;
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value(arc, "ARC", "center", &center, NULL)
        && !memcmp(&center, &arc->center, sizeof(arc->center)))
      pass ("ARC.center [3BD]");
    else
      {
        fail ("ARC.center [3BD]"); error++;
      }
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value(arc, "ARC", "end_angle", &end_angle, NULL) &&
        end_angle == arc->end_angle)
      pass ("ARC.end_angle [BD] %g", end_angle);
    else
      {
        fail ("ARC.end_angle [BD] %g != %g", arc->end_angle, end_angle); error++;
      }
    end_angle++;
    if (dwg_dynapi_entity_set_value(arc, "ARC", "end_angle", &end_angle) &&
        end_angle == arc->end_angle)
      pass ("ARC.end_angle [BD] set+1 %g", end_angle);
    else
      {
        fail ("ARC.end_angle [BD] set+1 %g != %g", arc->end_angle, end_angle); error++;
      }
    arc->end_angle--;

  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(arc, "ARC", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &arc->extrusion, sizeof(arc->extrusion)))
      pass ("ARC.extrusion [BE]");
    else
      {
        fail ("ARC.extrusion [BE]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(arc, "ARC", "parent", &parent, NULL)
        && !memcmp(&parent, &arc->parent, sizeof(arc->parent)))
      pass ("ARC.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("ARC.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value(arc, "ARC", "radius", &radius, NULL) &&
        radius == arc->radius)
      pass ("ARC.radius [BD] %g", radius);
    else
      {
        fail ("ARC.radius [BD] %g != %g", arc->radius, radius); error++;
      }
    radius++;
    if (dwg_dynapi_entity_set_value(arc, "ARC", "radius", &radius) &&
        radius == arc->radius)
      pass ("ARC.radius [BD] set+1 %g", radius);
    else
      {
        fail ("ARC.radius [BD] set+1 %g != %g", arc->radius, radius); error++;
      }
    arc->radius--;

  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value(arc, "ARC", "start_angle", &start_angle, NULL) &&
        start_angle == arc->start_angle)
      pass ("ARC.start_angle [BD] %g", start_angle);
    else
      {
        fail ("ARC.start_angle [BD] %g != %g", arc->start_angle, start_angle); error++;
      }
    start_angle++;
    if (dwg_dynapi_entity_set_value(arc, "ARC", "start_angle", &start_angle) &&
        start_angle == arc->start_angle)
      pass ("ARC.start_angle [BD] set+1 %g", start_angle);
    else
      {
        fail ("ARC.start_angle [BD] set+1 %g != %g", arc->start_angle, start_angle); error++;
      }
    arc->start_angle--;

  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(arc, "ARC", "thickness", &thickness, NULL) &&
        thickness == arc->thickness)
      pass ("ARC.thickness [BT] " FORMAT_BT "", thickness);
    else
      {
        fail ("ARC.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", arc->thickness, thickness); error++;
      }
    if (dwg_dynapi_entity_set_value(arc, "ARC", "thickness", &thickness) &&
        thickness == arc->thickness)
      pass ("ARC.thickness [BT] set+1 " FORMAT_BT "", thickness);
    else
      {
        fail ("ARC.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", arc->thickness, thickness); error++;
      }
    arc->thickness--;

  }
  return error;
}
static int test_ATTDEF (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ATTDEF *attdef = obj->tio.entity->tio.ATTDEF;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "alignment_pt", &alignment_pt, NULL)
        && !memcmp(&alignment_pt, &attdef->alignment_pt, sizeof(attdef->alignment_pt)))
      pass ("ATTDEF.alignment_pt [2DPOINT]");
    else
      {
        fail ("ATTDEF.alignment_pt [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "class_version", &class_version, NULL) &&
        class_version == attdef->class_version)
      pass ("ATTDEF.class_version [RC] %u", class_version);
    else
      {
        fail ("ATTDEF.class_version [RC] %u != %u", attdef->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "class_version", &class_version) &&
        class_version == attdef->class_version)
      pass ("ATTDEF.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("ATTDEF.class_version [RC] set+1 %u != %u", attdef->class_version, class_version); error++;
      }
    attdef->class_version--;

  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "dataflags", &dataflags, NULL) &&
        dataflags == attdef->dataflags)
      pass ("ATTDEF.dataflags [RC] %u", dataflags);
    else
      {
        fail ("ATTDEF.dataflags [RC] %u != %u", attdef->dataflags, dataflags); error++;
      }
    dataflags++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "dataflags", &dataflags) &&
        dataflags == attdef->dataflags)
      pass ("ATTDEF.dataflags [RC] set+1 %u", dataflags);
    else
      {
        fail ("ATTDEF.dataflags [RC] set+1 %u != %u", attdef->dataflags, dataflags); error++;
      }
    attdef->dataflags--;

  }
  {
    BITCODE_TV default_value;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "default_value", &default_value, NULL)
        && !strcmp((char*)&default_value, (char*)&attdef->default_value))
      pass ("ATTDEF.default_value [TV]");
    else
      {
        fail ("ATTDEF.default_value [TV]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "elevation", &elevation, NULL) &&
        elevation == attdef->elevation)
      pass ("ATTDEF.elevation [BD] %g", elevation);
    else
      {
        fail ("ATTDEF.elevation [BD] %g != %g", attdef->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "elevation", &elevation) &&
        elevation == attdef->elevation)
      pass ("ATTDEF.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("ATTDEF.elevation [BD] set+1 %g != %g", attdef->elevation, elevation); error++;
      }
    attdef->elevation--;

  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &attdef->extrusion, sizeof(attdef->extrusion)))
      pass ("ATTDEF.extrusion [3DPOINT]");
    else
      {
        fail ("ATTDEF.extrusion [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_BS field_length;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "field_length", &field_length, NULL) &&
        field_length == attdef->field_length)
      pass ("ATTDEF.field_length [BS] %hu", field_length);
    else
      {
        fail ("ATTDEF.field_length [BS] %hu != %hu", attdef->field_length, field_length); error++;
      }
    field_length++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "field_length", &field_length) &&
        field_length == attdef->field_length)
      pass ("ATTDEF.field_length [BS] set+1 %hu", field_length);
    else
      {
        fail ("ATTDEF.field_length [BS] set+1 %hu != %hu", attdef->field_length, field_length); error++;
      }
    attdef->field_length--;

  }
  {
    BITCODE_RC flags;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "flags", &flags, NULL) &&
        flags == attdef->flags)
      pass ("ATTDEF.flags [RC] %u", flags);
    else
      {
        fail ("ATTDEF.flags [RC] %u != %u", attdef->flags, flags); error++;
      }
    flags++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "flags", &flags) &&
        flags == attdef->flags)
      pass ("ATTDEF.flags [RC] set+1 %u", flags);
    else
      {
        fail ("ATTDEF.flags [RC] set+1 %u != %u", attdef->flags, flags); error++;
      }
    attdef->flags--;

  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "generation", &generation, NULL) &&
        generation == attdef->generation)
      pass ("ATTDEF.generation [BS] %hu", generation);
    else
      {
        fail ("ATTDEF.generation [BS] %hu != %hu", attdef->generation, generation); error++;
      }
    generation++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "generation", &generation) &&
        generation == attdef->generation)
      pass ("ATTDEF.generation [BS] set+1 %hu", generation);
    else
      {
        fail ("ATTDEF.generation [BS] set+1 %hu != %hu", attdef->generation, generation); error++;
      }
    attdef->generation--;

  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "height", &height, NULL) &&
        height == attdef->height)
      pass ("ATTDEF.height [RD] %g", height);
    else
      {
        fail ("ATTDEF.height [RD] %g != %g", attdef->height, height); error++;
      }
    height++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "height", &height) &&
        height == attdef->height)
      pass ("ATTDEF.height [RD] set+1 %g", height);
    else
      {
        fail ("ATTDEF.height [RD] set+1 %g != %g", attdef->height, height); error++;
      }
    attdef->height--;

  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "horiz_alignment", &horiz_alignment, NULL) &&
        horiz_alignment == attdef->horiz_alignment)
      pass ("ATTDEF.horiz_alignment [BS] %hu", horiz_alignment);
    else
      {
        fail ("ATTDEF.horiz_alignment [BS] %hu != %hu", attdef->horiz_alignment, horiz_alignment); error++;
      }
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "horiz_alignment", &horiz_alignment) &&
        horiz_alignment == attdef->horiz_alignment)
      pass ("ATTDEF.horiz_alignment [BS] set+1 %hu", horiz_alignment);
    else
      {
        fail ("ATTDEF.horiz_alignment [BS] set+1 %hu != %hu", attdef->horiz_alignment, horiz_alignment); error++;
      }
    attdef->horiz_alignment--;

  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &attdef->insertion_pt, sizeof(attdef->insertion_pt)))
      pass ("ATTDEF.insertion_pt [2DPOINT]");
    else
      {
        fail ("ATTDEF.insertion_pt [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_B lock_position_flag;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "lock_position_flag", &lock_position_flag, NULL) &&
        lock_position_flag == attdef->lock_position_flag)
      pass ("ATTDEF.lock_position_flag [B] " FORMAT_B "", lock_position_flag);
    else
      {
        fail ("ATTDEF.lock_position_flag [B] " FORMAT_B " != " FORMAT_B "", attdef->lock_position_flag, lock_position_flag); error++;
      }
    lock_position_flag++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "lock_position_flag", &lock_position_flag) &&
        lock_position_flag == attdef->lock_position_flag)
      pass ("ATTDEF.lock_position_flag [B] set+1 " FORMAT_B "", lock_position_flag);
    else
      {
        fail ("ATTDEF.lock_position_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", attdef->lock_position_flag, lock_position_flag); error++;
      }
    attdef->lock_position_flag--;

  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "oblique_ang", &oblique_ang, NULL) &&
        oblique_ang == attdef->oblique_ang)
      pass ("ATTDEF.oblique_ang [RD] %g", oblique_ang);
    else
      {
        fail ("ATTDEF.oblique_ang [RD] %g != %g", attdef->oblique_ang, oblique_ang); error++;
      }
    oblique_ang++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "oblique_ang", &oblique_ang) &&
        oblique_ang == attdef->oblique_ang)
      pass ("ATTDEF.oblique_ang [RD] set+1 %g", oblique_ang);
    else
      {
        fail ("ATTDEF.oblique_ang [RD] set+1 %g != %g", attdef->oblique_ang, oblique_ang); error++;
      }
    attdef->oblique_ang--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "parent", &parent, NULL)
        && !memcmp(&parent, &attdef->parent, sizeof(attdef->parent)))
      pass ("ATTDEF.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("ATTDEF.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_TV prompt;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "prompt", &prompt, NULL)
        && !strcmp((char*)&prompt, (char*)&attdef->prompt))
      pass ("ATTDEF.prompt [TV]");
    else
      {
        fail ("ATTDEF.prompt [TV]"); error++;
      }
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "rotation", &rotation, NULL) &&
        rotation == attdef->rotation)
      pass ("ATTDEF.rotation [RD] %g", rotation);
    else
      {
        fail ("ATTDEF.rotation [RD] %g != %g", attdef->rotation, rotation); error++;
      }
    rotation++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "rotation", &rotation) &&
        rotation == attdef->rotation)
      pass ("ATTDEF.rotation [RD] set+1 %g", rotation);
    else
      {
        fail ("ATTDEF.rotation [RD] set+1 %g != %g", attdef->rotation, rotation); error++;
      }
    attdef->rotation--;

  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "style", &style, NULL)
        && !memcmp(&style, &attdef->style, sizeof(attdef->style)))
      pass ("ATTDEF.style [H]");
    else
      {
        fail ("ATTDEF.style [H]"); error++;
      }
  }
  {
    BITCODE_TV tag;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "tag", &tag, NULL)
        && !strcmp((char*)&tag, (char*)&attdef->tag))
      pass ("ATTDEF.tag [TV]");
    else
      {
        fail ("ATTDEF.tag [TV]"); error++;
      }
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "thickness", &thickness, NULL) &&
        thickness == attdef->thickness)
      pass ("ATTDEF.thickness [RD] %g", thickness);
    else
      {
        fail ("ATTDEF.thickness [RD] %g != %g", attdef->thickness, thickness); error++;
      }
    thickness++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "thickness", &thickness) &&
        thickness == attdef->thickness)
      pass ("ATTDEF.thickness [RD] set+1 %g", thickness);
    else
      {
        fail ("ATTDEF.thickness [RD] set+1 %g != %g", attdef->thickness, thickness); error++;
      }
    attdef->thickness--;

  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "vert_alignment", &vert_alignment, NULL) &&
        vert_alignment == attdef->vert_alignment)
      pass ("ATTDEF.vert_alignment [BS] %hu", vert_alignment);
    else
      {
        fail ("ATTDEF.vert_alignment [BS] %hu != %hu", attdef->vert_alignment, vert_alignment); error++;
      }
    vert_alignment++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "vert_alignment", &vert_alignment) &&
        vert_alignment == attdef->vert_alignment)
      pass ("ATTDEF.vert_alignment [BS] set+1 %hu", vert_alignment);
    else
      {
        fail ("ATTDEF.vert_alignment [BS] set+1 %hu != %hu", attdef->vert_alignment, vert_alignment); error++;
      }
    attdef->vert_alignment--;

  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "width_factor", &width_factor, NULL) &&
        width_factor == attdef->width_factor)
      pass ("ATTDEF.width_factor [RD] %g", width_factor);
    else
      {
        fail ("ATTDEF.width_factor [RD] %g != %g", attdef->width_factor, width_factor); error++;
      }
    width_factor++;
    if (dwg_dynapi_entity_set_value(attdef, "ATTDEF", "width_factor", &width_factor) &&
        width_factor == attdef->width_factor)
      pass ("ATTDEF.width_factor [RD] set+1 %g", width_factor);
    else
      {
        fail ("ATTDEF.width_factor [RD] set+1 %g != %g", attdef->width_factor, width_factor); error++;
      }
    attdef->width_factor--;

  }
  return error;
}
static int test_ATTRIB (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ATTRIB *attrib = obj->tio.entity->tio.ATTRIB;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "alignment_pt", &alignment_pt, NULL)
        && !memcmp(&alignment_pt, &attrib->alignment_pt, sizeof(attrib->alignment_pt)))
      pass ("ATTRIB.alignment_pt [2DPOINT]");
    else
      {
        fail ("ATTRIB.alignment_pt [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_H annotative_app;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "annotative_app", &annotative_app, NULL)
        && !memcmp(&annotative_app, &attrib->annotative_app, sizeof(attrib->annotative_app)))
      pass ("ATTRIB.annotative_app [H]");
    else
      {
        fail ("ATTRIB.annotative_app [H]"); error++;
      }
  }
  {
    BITCODE_RC annotative_data_bytes;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "annotative_data_bytes", &annotative_data_bytes, NULL) &&
        annotative_data_bytes == attrib->annotative_data_bytes)
      pass ("ATTRIB.annotative_data_bytes [RC] %u", annotative_data_bytes);
    else
      {
        fail ("ATTRIB.annotative_data_bytes [RC] %u != %u", attrib->annotative_data_bytes, annotative_data_bytes); error++;
      }
    annotative_data_bytes++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "annotative_data_bytes", &annotative_data_bytes) &&
        annotative_data_bytes == attrib->annotative_data_bytes)
      pass ("ATTRIB.annotative_data_bytes [RC] set+1 %u", annotative_data_bytes);
    else
      {
        fail ("ATTRIB.annotative_data_bytes [RC] set+1 %u != %u", attrib->annotative_data_bytes, annotative_data_bytes); error++;
      }
    attrib->annotative_data_bytes--;

  }
  {
    BITCODE_BS annotative_data_size;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "annotative_data_size", &annotative_data_size, NULL) &&
        annotative_data_size == attrib->annotative_data_size)
      pass ("ATTRIB.annotative_data_size [BS] %hu", annotative_data_size);
    else
      {
        fail ("ATTRIB.annotative_data_size [BS] %hu != %hu", attrib->annotative_data_size, annotative_data_size); error++;
      }
    annotative_data_size++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "annotative_data_size", &annotative_data_size) &&
        annotative_data_size == attrib->annotative_data_size)
      pass ("ATTRIB.annotative_data_size [BS] set+1 %hu", annotative_data_size);
    else
      {
        fail ("ATTRIB.annotative_data_size [BS] set+1 %hu != %hu", attrib->annotative_data_size, annotative_data_size); error++;
      }
    attrib->annotative_data_size--;

  }
  {
    BITCODE_BS annotative_short;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "annotative_short", &annotative_short, NULL) &&
        annotative_short == attrib->annotative_short)
      pass ("ATTRIB.annotative_short [BS] %hu", annotative_short);
    else
      {
        fail ("ATTRIB.annotative_short [BS] %hu != %hu", attrib->annotative_short, annotative_short); error++;
      }
    annotative_short++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "annotative_short", &annotative_short) &&
        annotative_short == attrib->annotative_short)
      pass ("ATTRIB.annotative_short [BS] set+1 %hu", annotative_short);
    else
      {
        fail ("ATTRIB.annotative_short [BS] set+1 %hu != %hu", attrib->annotative_short, annotative_short); error++;
      }
    attrib->annotative_short--;

  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "class_version", &class_version, NULL) &&
        class_version == attrib->class_version)
      pass ("ATTRIB.class_version [RC] %u", class_version);
    else
      {
        fail ("ATTRIB.class_version [RC] %u != %u", attrib->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "class_version", &class_version) &&
        class_version == attrib->class_version)
      pass ("ATTRIB.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("ATTRIB.class_version [RC] set+1 %u != %u", attrib->class_version, class_version); error++;
      }
    attrib->class_version--;

  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "dataflags", &dataflags, NULL) &&
        dataflags == attrib->dataflags)
      pass ("ATTRIB.dataflags [RC] %u", dataflags);
    else
      {
        fail ("ATTRIB.dataflags [RC] %u != %u", attrib->dataflags, dataflags); error++;
      }
    dataflags++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "dataflags", &dataflags) &&
        dataflags == attrib->dataflags)
      pass ("ATTRIB.dataflags [RC] set+1 %u", dataflags);
    else
      {
        fail ("ATTRIB.dataflags [RC] set+1 %u != %u", attrib->dataflags, dataflags); error++;
      }
    attrib->dataflags--;

  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "elevation", &elevation, NULL) &&
        elevation == attrib->elevation)
      pass ("ATTRIB.elevation [BD] %g", elevation);
    else
      {
        fail ("ATTRIB.elevation [BD] %g != %g", attrib->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "elevation", &elevation) &&
        elevation == attrib->elevation)
      pass ("ATTRIB.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("ATTRIB.elevation [BD] set+1 %g != %g", attrib->elevation, elevation); error++;
      }
    attrib->elevation--;

  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &attrib->extrusion, sizeof(attrib->extrusion)))
      pass ("ATTRIB.extrusion [3DPOINT]");
    else
      {
        fail ("ATTRIB.extrusion [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_BS field_length;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "field_length", &field_length, NULL) &&
        field_length == attrib->field_length)
      pass ("ATTRIB.field_length [BS] %hu", field_length);
    else
      {
        fail ("ATTRIB.field_length [BS] %hu != %hu", attrib->field_length, field_length); error++;
      }
    field_length++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "field_length", &field_length) &&
        field_length == attrib->field_length)
      pass ("ATTRIB.field_length [BS] set+1 %hu", field_length);
    else
      {
        fail ("ATTRIB.field_length [BS] set+1 %hu != %hu", attrib->field_length, field_length); error++;
      }
    attrib->field_length--;

  }
  {
    BITCODE_RC flags;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "flags", &flags, NULL) &&
        flags == attrib->flags)
      pass ("ATTRIB.flags [RC] %u", flags);
    else
      {
        fail ("ATTRIB.flags [RC] %u != %u", attrib->flags, flags); error++;
      }
    flags++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "flags", &flags) &&
        flags == attrib->flags)
      pass ("ATTRIB.flags [RC] set+1 %u", flags);
    else
      {
        fail ("ATTRIB.flags [RC] set+1 %u != %u", attrib->flags, flags); error++;
      }
    attrib->flags--;

  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "generation", &generation, NULL) &&
        generation == attrib->generation)
      pass ("ATTRIB.generation [BS] %hu", generation);
    else
      {
        fail ("ATTRIB.generation [BS] %hu != %hu", attrib->generation, generation); error++;
      }
    generation++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "generation", &generation) &&
        generation == attrib->generation)
      pass ("ATTRIB.generation [BS] set+1 %hu", generation);
    else
      {
        fail ("ATTRIB.generation [BS] set+1 %hu != %hu", attrib->generation, generation); error++;
      }
    attrib->generation--;

  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "height", &height, NULL) &&
        height == attrib->height)
      pass ("ATTRIB.height [RD] %g", height);
    else
      {
        fail ("ATTRIB.height [RD] %g != %g", attrib->height, height); error++;
      }
    height++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "height", &height) &&
        height == attrib->height)
      pass ("ATTRIB.height [RD] set+1 %g", height);
    else
      {
        fail ("ATTRIB.height [RD] set+1 %g != %g", attrib->height, height); error++;
      }
    attrib->height--;

  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "horiz_alignment", &horiz_alignment, NULL) &&
        horiz_alignment == attrib->horiz_alignment)
      pass ("ATTRIB.horiz_alignment [BS] %hu", horiz_alignment);
    else
      {
        fail ("ATTRIB.horiz_alignment [BS] %hu != %hu", attrib->horiz_alignment, horiz_alignment); error++;
      }
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "horiz_alignment", &horiz_alignment) &&
        horiz_alignment == attrib->horiz_alignment)
      pass ("ATTRIB.horiz_alignment [BS] set+1 %hu", horiz_alignment);
    else
      {
        fail ("ATTRIB.horiz_alignment [BS] set+1 %hu != %hu", attrib->horiz_alignment, horiz_alignment); error++;
      }
    attrib->horiz_alignment--;

  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &attrib->insertion_pt, sizeof(attrib->insertion_pt)))
      pass ("ATTRIB.insertion_pt [2DPOINT]");
    else
      {
        fail ("ATTRIB.insertion_pt [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_B lock_position_flag;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "lock_position_flag", &lock_position_flag, NULL) &&
        lock_position_flag == attrib->lock_position_flag)
      pass ("ATTRIB.lock_position_flag [B] " FORMAT_B "", lock_position_flag);
    else
      {
        fail ("ATTRIB.lock_position_flag [B] " FORMAT_B " != " FORMAT_B "", attrib->lock_position_flag, lock_position_flag); error++;
      }
    lock_position_flag++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "lock_position_flag", &lock_position_flag) &&
        lock_position_flag == attrib->lock_position_flag)
      pass ("ATTRIB.lock_position_flag [B] set+1 " FORMAT_B "", lock_position_flag);
    else
      {
        fail ("ATTRIB.lock_position_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", attrib->lock_position_flag, lock_position_flag); error++;
      }
    attrib->lock_position_flag--;

  }
  {
    BITCODE_H mtext_handles;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "mtext_handles", &mtext_handles, NULL)
        && !memcmp(&mtext_handles, &attrib->mtext_handles, sizeof(attrib->mtext_handles)))
      pass ("ATTRIB.mtext_handles [H]");
    else
      {
        fail ("ATTRIB.mtext_handles [H]"); error++;
      }
  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "oblique_ang", &oblique_ang, NULL) &&
        oblique_ang == attrib->oblique_ang)
      pass ("ATTRIB.oblique_ang [RD] %g", oblique_ang);
    else
      {
        fail ("ATTRIB.oblique_ang [RD] %g != %g", attrib->oblique_ang, oblique_ang); error++;
      }
    oblique_ang++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "oblique_ang", &oblique_ang) &&
        oblique_ang == attrib->oblique_ang)
      pass ("ATTRIB.oblique_ang [RD] set+1 %g", oblique_ang);
    else
      {
        fail ("ATTRIB.oblique_ang [RD] set+1 %g != %g", attrib->oblique_ang, oblique_ang); error++;
      }
    attrib->oblique_ang--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "parent", &parent, NULL)
        && !memcmp(&parent, &attrib->parent, sizeof(attrib->parent)))
      pass ("ATTRIB.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("ATTRIB.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "rotation", &rotation, NULL) &&
        rotation == attrib->rotation)
      pass ("ATTRIB.rotation [RD] %g", rotation);
    else
      {
        fail ("ATTRIB.rotation [RD] %g != %g", attrib->rotation, rotation); error++;
      }
    rotation++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "rotation", &rotation) &&
        rotation == attrib->rotation)
      pass ("ATTRIB.rotation [RD] set+1 %g", rotation);
    else
      {
        fail ("ATTRIB.rotation [RD] set+1 %g != %g", attrib->rotation, rotation); error++;
      }
    attrib->rotation--;

  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "style", &style, NULL)
        && !memcmp(&style, &attrib->style, sizeof(attrib->style)))
      pass ("ATTRIB.style [H]");
    else
      {
        fail ("ATTRIB.style [H]"); error++;
      }
  }
  {
    BITCODE_TV tag;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "tag", &tag, NULL)
        && !strcmp((char*)&tag, (char*)&attrib->tag))
      pass ("ATTRIB.tag [TV]");
    else
      {
        fail ("ATTRIB.tag [TV]"); error++;
      }
  }
  {
    BITCODE_TV text_value;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "text_value", &text_value, NULL)
        && !strcmp((char*)&text_value, (char*)&attrib->text_value))
      pass ("ATTRIB.text_value [TV]");
    else
      {
        fail ("ATTRIB.text_value [TV]"); error++;
      }
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "thickness", &thickness, NULL) &&
        thickness == attrib->thickness)
      pass ("ATTRIB.thickness [RD] %g", thickness);
    else
      {
        fail ("ATTRIB.thickness [RD] %g != %g", attrib->thickness, thickness); error++;
      }
    thickness++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "thickness", &thickness) &&
        thickness == attrib->thickness)
      pass ("ATTRIB.thickness [RD] set+1 %g", thickness);
    else
      {
        fail ("ATTRIB.thickness [RD] set+1 %g != %g", attrib->thickness, thickness); error++;
      }
    attrib->thickness--;

  }
  {
    BITCODE_RC type;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "type", &type, NULL) &&
        type == attrib->type)
      pass ("ATTRIB.type [RC] %u", type);
    else
      {
        fail ("ATTRIB.type [RC] %u != %u", attrib->type, type); error++;
      }
    type++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "type", &type) &&
        type == attrib->type)
      pass ("ATTRIB.type [RC] set+1 %u", type);
    else
      {
        fail ("ATTRIB.type [RC] set+1 %u != %u", attrib->type, type); error++;
      }
    attrib->type--;

  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "vert_alignment", &vert_alignment, NULL) &&
        vert_alignment == attrib->vert_alignment)
      pass ("ATTRIB.vert_alignment [BS] %hu", vert_alignment);
    else
      {
        fail ("ATTRIB.vert_alignment [BS] %hu != %hu", attrib->vert_alignment, vert_alignment); error++;
      }
    vert_alignment++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "vert_alignment", &vert_alignment) &&
        vert_alignment == attrib->vert_alignment)
      pass ("ATTRIB.vert_alignment [BS] set+1 %hu", vert_alignment);
    else
      {
        fail ("ATTRIB.vert_alignment [BS] set+1 %hu != %hu", attrib->vert_alignment, vert_alignment); error++;
      }
    attrib->vert_alignment--;

  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "width_factor", &width_factor, NULL) &&
        width_factor == attrib->width_factor)
      pass ("ATTRIB.width_factor [RD] %g", width_factor);
    else
      {
        fail ("ATTRIB.width_factor [RD] %g != %g", attrib->width_factor, width_factor); error++;
      }
    width_factor++;
    if (dwg_dynapi_entity_set_value(attrib, "ATTRIB", "width_factor", &width_factor) &&
        width_factor == attrib->width_factor)
      pass ("ATTRIB.width_factor [RD] set+1 %g", width_factor);
    else
      {
        fail ("ATTRIB.width_factor [RD] set+1 %g != %g", attrib->width_factor, width_factor); error++;
      }
    attrib->width_factor--;

  }
  return error;
}
static int test_BLOCK (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_BLOCK *block = obj->tio.entity->tio.BLOCK;
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(block, "BLOCK", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&block->name))
      pass ("BLOCK.name [TV]");
    else
      {
        fail ("BLOCK.name [TV]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(block, "BLOCK", "parent", &parent, NULL)
        && !memcmp(&parent, &block->parent, sizeof(block->parent)))
      pass ("BLOCK.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("BLOCK.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  return error;
}
static int test_CAMERA (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_CAMERA *camera = obj->tio.entity->tio.CAMERA;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(camera, "CAMERA", "parent", &parent, NULL)
        && !memcmp(&parent, &camera->parent, sizeof(camera->parent)))
      pass ("CAMERA.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("CAMERA.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_H view;
    if (dwg_dynapi_entity_value(camera, "CAMERA", "view", &view, NULL)
        && !memcmp(&view, &camera->view, sizeof(camera->view)))
      pass ("CAMERA.view [H]");
    else
      {
        fail ("CAMERA.view [H]"); error++;
      }
  }
  return error;
}
static int test_CIRCLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_CIRCLE *circle = obj->tio.entity->tio.CIRCLE;
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "center", &center, NULL)
        && !memcmp(&center, &circle->center, sizeof(circle->center)))
      pass ("CIRCLE.center [3BD]");
    else
      {
        fail ("CIRCLE.center [3BD]"); error++;
      }
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &circle->extrusion, sizeof(circle->extrusion)))
      pass ("CIRCLE.extrusion [BE]");
    else
      {
        fail ("CIRCLE.extrusion [BE]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "parent", &parent, NULL)
        && !memcmp(&parent, &circle->parent, sizeof(circle->parent)))
      pass ("CIRCLE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("CIRCLE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "radius", &radius, NULL) &&
        radius == circle->radius)
      pass ("CIRCLE.radius [BD] %g", radius);
    else
      {
        fail ("CIRCLE.radius [BD] %g != %g", circle->radius, radius); error++;
      }
    radius++;
    if (dwg_dynapi_entity_set_value(circle, "CIRCLE", "radius", &radius) &&
        radius == circle->radius)
      pass ("CIRCLE.radius [BD] set+1 %g", radius);
    else
      {
        fail ("CIRCLE.radius [BD] set+1 %g != %g", circle->radius, radius); error++;
      }
    circle->radius--;

  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "thickness", &thickness, NULL) &&
        thickness == circle->thickness)
      pass ("CIRCLE.thickness [BT] " FORMAT_BT "", thickness);
    else
      {
        fail ("CIRCLE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", circle->thickness, thickness); error++;
      }
    if (dwg_dynapi_entity_set_value(circle, "CIRCLE", "thickness", &thickness) &&
        thickness == circle->thickness)
      pass ("CIRCLE.thickness [BT] set+1 " FORMAT_BT "", thickness);
    else
      {
        fail ("CIRCLE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", circle->thickness, thickness); error++;
      }
    circle->thickness--;

  }
  return error;
}
static int test_DIMENSION_ALIGNED (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_ALIGNED *dimension_aligned = obj->tio.entity->tio.DIMENSION_ALIGNED;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "_13_pt", &_13_pt, NULL)
        && !memcmp(&_13_pt, &dimension_aligned->_13_pt, sizeof(dimension_aligned->_13_pt)))
      pass ("DIMENSION_ALIGNED._13_pt [3BD]");
    else
      {
        fail ("DIMENSION_ALIGNED._13_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "_14_pt", &_14_pt, NULL)
        && !memcmp(&_14_pt, &dimension_aligned->_14_pt, sizeof(dimension_aligned->_14_pt)))
      pass ("DIMENSION_ALIGNED._14_pt [3BD]");
    else
      {
        fail ("DIMENSION_ALIGNED._14_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_aligned->act_measurement)
      pass ("DIMENSION_ALIGNED.act_measurement [BD] %g", act_measurement);
    else
      {
        fail ("DIMENSION_ALIGNED.act_measurement [BD] %g != %g", dimension_aligned->act_measurement, act_measurement); error++;
      }
    act_measurement++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "act_measurement", &act_measurement) &&
        act_measurement == dimension_aligned->act_measurement)
      pass ("DIMENSION_ALIGNED.act_measurement [BD] set+1 %g", act_measurement);
    else
      {
        fail ("DIMENSION_ALIGNED.act_measurement [BD] set+1 %g != %g", dimension_aligned->act_measurement, act_measurement); error++;
      }
    dimension_aligned->act_measurement--;

  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "attachment", &attachment, NULL) &&
        attachment == dimension_aligned->attachment)
      pass ("DIMENSION_ALIGNED.attachment [BS] %hu", attachment);
    else
      {
        fail ("DIMENSION_ALIGNED.attachment [BS] %hu != %hu", dimension_aligned->attachment, attachment); error++;
      }
    attachment++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "attachment", &attachment) &&
        attachment == dimension_aligned->attachment)
      pass ("DIMENSION_ALIGNED.attachment [BS] set+1 %hu", attachment);
    else
      {
        fail ("DIMENSION_ALIGNED.attachment [BS] set+1 %hu != %hu", dimension_aligned->attachment, attachment); error++;
      }
    dimension_aligned->attachment--;

  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "block", &block, NULL)
        && !memcmp(&block, &dimension_aligned->block, sizeof(dimension_aligned->block)))
      pass ("DIMENSION_ALIGNED.block [H]");
    else
      {
        fail ("DIMENSION_ALIGNED.block [H]"); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_aligned->blockname))
      pass ("DIMENSION_ALIGNED.blockname [TV]");
    else
      {
        fail ("DIMENSION_ALIGNED.blockname [TV]"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "class_version", &class_version, NULL) &&
        class_version == dimension_aligned->class_version)
      pass ("DIMENSION_ALIGNED.class_version [RC] %u", class_version);
    else
      {
        fail ("DIMENSION_ALIGNED.class_version [RC] %u != %u", dimension_aligned->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "class_version", &class_version) &&
        class_version == dimension_aligned->class_version)
      pass ("DIMENSION_ALIGNED.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("DIMENSION_ALIGNED.class_version [RC] set+1 %u != %u", dimension_aligned->class_version, class_version); error++;
      }
    dimension_aligned->class_version--;

  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_aligned->clone_ins_pt, sizeof(dimension_aligned->clone_ins_pt)))
      pass ("DIMENSION_ALIGNED.clone_ins_pt [2RD]");
    else
      {
        fail ("DIMENSION_ALIGNED.clone_ins_pt [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_aligned->def_pt, sizeof(dimension_aligned->def_pt)))
      pass ("DIMENSION_ALIGNED.def_pt [3BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.def_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dimension_aligned->dimstyle, sizeof(dimension_aligned->dimstyle)))
      pass ("DIMENSION_ALIGNED.dimstyle [H]");
    else
      {
        fail ("DIMENSION_ALIGNED.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "elevation", &elevation, NULL) &&
        elevation == dimension_aligned->elevation)
      pass ("DIMENSION_ALIGNED.elevation [BD] %g", elevation);
    else
      {
        fail ("DIMENSION_ALIGNED.elevation [BD] %g != %g", dimension_aligned->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "elevation", &elevation) &&
        elevation == dimension_aligned->elevation)
      pass ("DIMENSION_ALIGNED.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("DIMENSION_ALIGNED.elevation [BD] set+1 %g != %g", dimension_aligned->elevation, elevation); error++;
      }
    dimension_aligned->elevation--;

  }
  {
    BITCODE_BD ext_line_rotation;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "ext_line_rotation", &ext_line_rotation, NULL) &&
        ext_line_rotation == dimension_aligned->ext_line_rotation)
      pass ("DIMENSION_ALIGNED.ext_line_rotation [BD] %g", ext_line_rotation);
    else
      {
        fail ("DIMENSION_ALIGNED.ext_line_rotation [BD] %g != %g", dimension_aligned->ext_line_rotation, ext_line_rotation); error++;
      }
    ext_line_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "ext_line_rotation", &ext_line_rotation) &&
        ext_line_rotation == dimension_aligned->ext_line_rotation)
      pass ("DIMENSION_ALIGNED.ext_line_rotation [BD] set+1 %g", ext_line_rotation);
    else
      {
        fail ("DIMENSION_ALIGNED.ext_line_rotation [BD] set+1 %g != %g", dimension_aligned->ext_line_rotation, ext_line_rotation); error++;
      }
    dimension_aligned->ext_line_rotation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_aligned->extrusion, sizeof(dimension_aligned->extrusion)))
      pass ("DIMENSION_ALIGNED.extrusion [3BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "flag", &flag, NULL) &&
        flag == dimension_aligned->flag)
      pass ("DIMENSION_ALIGNED.flag [RC] %u", flag);
    else
      {
        fail ("DIMENSION_ALIGNED.flag [RC] %u != %u", dimension_aligned->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "flag", &flag) &&
        flag == dimension_aligned->flag)
      pass ("DIMENSION_ALIGNED.flag [RC] set+1 %u", flag);
    else
      {
        fail ("DIMENSION_ALIGNED.flag [RC] set+1 %u != %u", dimension_aligned->flag, flag); error++;
      }
    dimension_aligned->flag--;

  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "flag1", &flag1, NULL) &&
        flag1 == dimension_aligned->flag1)
      pass ("DIMENSION_ALIGNED.flag1 [RC] %u", flag1);
    else
      {
        fail ("DIMENSION_ALIGNED.flag1 [RC] %u != %u", dimension_aligned->flag1, flag1); error++;
      }
    flag1++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "flag1", &flag1) &&
        flag1 == dimension_aligned->flag1)
      pass ("DIMENSION_ALIGNED.flag1 [RC] set+1 %u", flag1);
    else
      {
        fail ("DIMENSION_ALIGNED.flag1 [RC] set+1 %u != %u", dimension_aligned->flag1, flag1); error++;
      }
    dimension_aligned->flag1--;

  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_aligned->flip_arrow1)
      pass ("DIMENSION_ALIGNED.flip_arrow1 [RC] %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_ALIGNED.flip_arrow1 [RC] %u != %u", dimension_aligned->flip_arrow1, flip_arrow1); error++;
      }
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow1", &flip_arrow1) &&
        flip_arrow1 == dimension_aligned->flip_arrow1)
      pass ("DIMENSION_ALIGNED.flip_arrow1 [RC] set+1 %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_ALIGNED.flip_arrow1 [RC] set+1 %u != %u", dimension_aligned->flip_arrow1, flip_arrow1); error++;
      }
    dimension_aligned->flip_arrow1--;

  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_aligned->flip_arrow2)
      pass ("DIMENSION_ALIGNED.flip_arrow2 [RC] %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_ALIGNED.flip_arrow2 [RC] %u != %u", dimension_aligned->flip_arrow2, flip_arrow2); error++;
      }
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow2", &flip_arrow2) &&
        flip_arrow2 == dimension_aligned->flip_arrow2)
      pass ("DIMENSION_ALIGNED.flip_arrow2 [RC] set+1 %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_ALIGNED.flip_arrow2 [RC] set+1 %u != %u", dimension_aligned->flip_arrow2, flip_arrow2); error++;
      }
    dimension_aligned->flip_arrow2--;

  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_aligned->horiz_dir)
      pass ("DIMENSION_ALIGNED.horiz_dir [BD] %g", horiz_dir);
    else
      {
        fail ("DIMENSION_ALIGNED.horiz_dir [BD] %g != %g", dimension_aligned->horiz_dir, horiz_dir); error++;
      }
    horiz_dir++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "horiz_dir", &horiz_dir) &&
        horiz_dir == dimension_aligned->horiz_dir)
      pass ("DIMENSION_ALIGNED.horiz_dir [BD] set+1 %g", horiz_dir);
    else
      {
        fail ("DIMENSION_ALIGNED.horiz_dir [BD] set+1 %g != %g", dimension_aligned->horiz_dir, horiz_dir); error++;
      }
    dimension_aligned->horiz_dir--;

  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_aligned->ins_rotation)
      pass ("DIMENSION_ALIGNED.ins_rotation [BD] %g", ins_rotation);
    else
      {
        fail ("DIMENSION_ALIGNED.ins_rotation [BD] %g != %g", dimension_aligned->ins_rotation, ins_rotation); error++;
      }
    ins_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "ins_rotation", &ins_rotation) &&
        ins_rotation == dimension_aligned->ins_rotation)
      pass ("DIMENSION_ALIGNED.ins_rotation [BD] set+1 %g", ins_rotation);
    else
      {
        fail ("DIMENSION_ALIGNED.ins_rotation [BD] set+1 %g != %g", dimension_aligned->ins_rotation, ins_rotation); error++;
      }
    dimension_aligned->ins_rotation--;

  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_aligned->ins_scale, sizeof(dimension_aligned->ins_scale)))
      pass ("DIMENSION_ALIGNED.ins_scale [3BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.ins_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_aligned->lspace_factor)
      pass ("DIMENSION_ALIGNED.lspace_factor [BD] %g", lspace_factor);
    else
      {
        fail ("DIMENSION_ALIGNED.lspace_factor [BD] %g != %g", dimension_aligned->lspace_factor, lspace_factor); error++;
      }
    lspace_factor++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "lspace_factor", &lspace_factor) &&
        lspace_factor == dimension_aligned->lspace_factor)
      pass ("DIMENSION_ALIGNED.lspace_factor [BD] set+1 %g", lspace_factor);
    else
      {
        fail ("DIMENSION_ALIGNED.lspace_factor [BD] set+1 %g != %g", dimension_aligned->lspace_factor, lspace_factor); error++;
      }
    dimension_aligned->lspace_factor--;

  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_aligned->lspace_style)
      pass ("DIMENSION_ALIGNED.lspace_style [BS] %hu", lspace_style);
    else
      {
        fail ("DIMENSION_ALIGNED.lspace_style [BS] %hu != %hu", dimension_aligned->lspace_style, lspace_style); error++;
      }
    lspace_style++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "lspace_style", &lspace_style) &&
        lspace_style == dimension_aligned->lspace_style)
      pass ("DIMENSION_ALIGNED.lspace_style [BS] set+1 %hu", lspace_style);
    else
      {
        fail ("DIMENSION_ALIGNED.lspace_style [BS] set+1 %hu != %hu", dimension_aligned->lspace_style, lspace_style); error++;
      }
    dimension_aligned->lspace_style--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_aligned->parent, sizeof(dimension_aligned->parent)))
      pass ("DIMENSION_ALIGNED.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("DIMENSION_ALIGNED.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_aligned->text_midpt, sizeof(dimension_aligned->text_midpt)))
      pass ("DIMENSION_ALIGNED.text_midpt [2RD]");
    else
      {
        fail ("DIMENSION_ALIGNED.text_midpt [2RD]"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_aligned->text_rotation)
      pass ("DIMENSION_ALIGNED.text_rotation [BD] %g", text_rotation);
    else
      {
        fail ("DIMENSION_ALIGNED.text_rotation [BD] %g != %g", dimension_aligned->text_rotation, text_rotation); error++;
      }
    text_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "text_rotation", &text_rotation) &&
        text_rotation == dimension_aligned->text_rotation)
      pass ("DIMENSION_ALIGNED.text_rotation [BD] set+1 %g", text_rotation);
    else
      {
        fail ("DIMENSION_ALIGNED.text_rotation [BD] set+1 %g != %g", dimension_aligned->text_rotation, text_rotation); error++;
      }
    dimension_aligned->text_rotation--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "unknown", &unknown, NULL) &&
        unknown == dimension_aligned->unknown)
      pass ("DIMENSION_ALIGNED.unknown [RC] %u", unknown);
    else
      {
        fail ("DIMENSION_ALIGNED.unknown [RC] %u != %u", dimension_aligned->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(dimension_aligned, "DIMENSION_ALIGNED", "unknown", &unknown) &&
        unknown == dimension_aligned->unknown)
      pass ("DIMENSION_ALIGNED.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("DIMENSION_ALIGNED.unknown [RC] set+1 %u != %u", dimension_aligned->unknown, unknown); error++;
      }
    dimension_aligned->unknown--;

  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_aligned->user_text))
      pass ("DIMENSION_ALIGNED.user_text [TV]");
    else
      {
        fail ("DIMENSION_ALIGNED.user_text [TV]"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_ANG2LN (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_ANG2LN *dimension_ang2ln = obj->tio.entity->tio.DIMENSION_ANG2LN;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "_13_pt", &_13_pt, NULL)
        && !memcmp(&_13_pt, &dimension_ang2ln->_13_pt, sizeof(dimension_ang2ln->_13_pt)))
      pass ("DIMENSION_ANG2LN._13_pt [3BD]");
    else
      {
        fail ("DIMENSION_ANG2LN._13_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "_14_pt", &_14_pt, NULL)
        && !memcmp(&_14_pt, &dimension_ang2ln->_14_pt, sizeof(dimension_ang2ln->_14_pt)))
      pass ("DIMENSION_ANG2LN._14_pt [3BD]");
    else
      {
        fail ("DIMENSION_ANG2LN._14_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_2RD _16_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "_16_pt", &_16_pt, NULL)
        && !memcmp(&_16_pt, &dimension_ang2ln->_16_pt, sizeof(dimension_ang2ln->_16_pt)))
      pass ("DIMENSION_ANG2LN._16_pt [2RD]");
    else
      {
        fail ("DIMENSION_ANG2LN._16_pt [2RD]"); error++;
      }
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_ang2ln->act_measurement)
      pass ("DIMENSION_ANG2LN.act_measurement [BD] %g", act_measurement);
    else
      {
        fail ("DIMENSION_ANG2LN.act_measurement [BD] %g != %g", dimension_ang2ln->act_measurement, act_measurement); error++;
      }
    act_measurement++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "act_measurement", &act_measurement) &&
        act_measurement == dimension_ang2ln->act_measurement)
      pass ("DIMENSION_ANG2LN.act_measurement [BD] set+1 %g", act_measurement);
    else
      {
        fail ("DIMENSION_ANG2LN.act_measurement [BD] set+1 %g != %g", dimension_ang2ln->act_measurement, act_measurement); error++;
      }
    dimension_ang2ln->act_measurement--;

  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "attachment", &attachment, NULL) &&
        attachment == dimension_ang2ln->attachment)
      pass ("DIMENSION_ANG2LN.attachment [BS] %hu", attachment);
    else
      {
        fail ("DIMENSION_ANG2LN.attachment [BS] %hu != %hu", dimension_ang2ln->attachment, attachment); error++;
      }
    attachment++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "attachment", &attachment) &&
        attachment == dimension_ang2ln->attachment)
      pass ("DIMENSION_ANG2LN.attachment [BS] set+1 %hu", attachment);
    else
      {
        fail ("DIMENSION_ANG2LN.attachment [BS] set+1 %hu != %hu", dimension_ang2ln->attachment, attachment); error++;
      }
    dimension_ang2ln->attachment--;

  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "block", &block, NULL)
        && !memcmp(&block, &dimension_ang2ln->block, sizeof(dimension_ang2ln->block)))
      pass ("DIMENSION_ANG2LN.block [H]");
    else
      {
        fail ("DIMENSION_ANG2LN.block [H]"); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_ang2ln->blockname))
      pass ("DIMENSION_ANG2LN.blockname [TV]");
    else
      {
        fail ("DIMENSION_ANG2LN.blockname [TV]"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "class_version", &class_version, NULL) &&
        class_version == dimension_ang2ln->class_version)
      pass ("DIMENSION_ANG2LN.class_version [RC] %u", class_version);
    else
      {
        fail ("DIMENSION_ANG2LN.class_version [RC] %u != %u", dimension_ang2ln->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "class_version", &class_version) &&
        class_version == dimension_ang2ln->class_version)
      pass ("DIMENSION_ANG2LN.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("DIMENSION_ANG2LN.class_version [RC] set+1 %u != %u", dimension_ang2ln->class_version, class_version); error++;
      }
    dimension_ang2ln->class_version--;

  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_ang2ln->clone_ins_pt, sizeof(dimension_ang2ln->clone_ins_pt)))
      pass ("DIMENSION_ANG2LN.clone_ins_pt [2RD]");
    else
      {
        fail ("DIMENSION_ANG2LN.clone_ins_pt [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_ang2ln->def_pt, sizeof(dimension_ang2ln->def_pt)))
      pass ("DIMENSION_ANG2LN.def_pt [3BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.def_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dimension_ang2ln->dimstyle, sizeof(dimension_ang2ln->dimstyle)))
      pass ("DIMENSION_ANG2LN.dimstyle [H]");
    else
      {
        fail ("DIMENSION_ANG2LN.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "elevation", &elevation, NULL) &&
        elevation == dimension_ang2ln->elevation)
      pass ("DIMENSION_ANG2LN.elevation [BD] %g", elevation);
    else
      {
        fail ("DIMENSION_ANG2LN.elevation [BD] %g != %g", dimension_ang2ln->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "elevation", &elevation) &&
        elevation == dimension_ang2ln->elevation)
      pass ("DIMENSION_ANG2LN.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("DIMENSION_ANG2LN.elevation [BD] set+1 %g != %g", dimension_ang2ln->elevation, elevation); error++;
      }
    dimension_ang2ln->elevation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_ang2ln->extrusion, sizeof(dimension_ang2ln->extrusion)))
      pass ("DIMENSION_ANG2LN.extrusion [3BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp(&first_arc_pt, &dimension_ang2ln->first_arc_pt, sizeof(dimension_ang2ln->first_arc_pt)))
      pass ("DIMENSION_ANG2LN.first_arc_pt [3BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.first_arc_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flag", &flag, NULL) &&
        flag == dimension_ang2ln->flag)
      pass ("DIMENSION_ANG2LN.flag [RC] %u", flag);
    else
      {
        fail ("DIMENSION_ANG2LN.flag [RC] %u != %u", dimension_ang2ln->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flag", &flag) &&
        flag == dimension_ang2ln->flag)
      pass ("DIMENSION_ANG2LN.flag [RC] set+1 %u", flag);
    else
      {
        fail ("DIMENSION_ANG2LN.flag [RC] set+1 %u != %u", dimension_ang2ln->flag, flag); error++;
      }
    dimension_ang2ln->flag--;

  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flag1", &flag1, NULL) &&
        flag1 == dimension_ang2ln->flag1)
      pass ("DIMENSION_ANG2LN.flag1 [RC] %u", flag1);
    else
      {
        fail ("DIMENSION_ANG2LN.flag1 [RC] %u != %u", dimension_ang2ln->flag1, flag1); error++;
      }
    flag1++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flag1", &flag1) &&
        flag1 == dimension_ang2ln->flag1)
      pass ("DIMENSION_ANG2LN.flag1 [RC] set+1 %u", flag1);
    else
      {
        fail ("DIMENSION_ANG2LN.flag1 [RC] set+1 %u != %u", dimension_ang2ln->flag1, flag1); error++;
      }
    dimension_ang2ln->flag1--;

  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_ang2ln->flip_arrow1)
      pass ("DIMENSION_ANG2LN.flip_arrow1 [RC] %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_ANG2LN.flip_arrow1 [RC] %u != %u", dimension_ang2ln->flip_arrow1, flip_arrow1); error++;
      }
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow1", &flip_arrow1) &&
        flip_arrow1 == dimension_ang2ln->flip_arrow1)
      pass ("DIMENSION_ANG2LN.flip_arrow1 [RC] set+1 %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_ANG2LN.flip_arrow1 [RC] set+1 %u != %u", dimension_ang2ln->flip_arrow1, flip_arrow1); error++;
      }
    dimension_ang2ln->flip_arrow1--;

  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_ang2ln->flip_arrow2)
      pass ("DIMENSION_ANG2LN.flip_arrow2 [RC] %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_ANG2LN.flip_arrow2 [RC] %u != %u", dimension_ang2ln->flip_arrow2, flip_arrow2); error++;
      }
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow2", &flip_arrow2) &&
        flip_arrow2 == dimension_ang2ln->flip_arrow2)
      pass ("DIMENSION_ANG2LN.flip_arrow2 [RC] set+1 %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_ANG2LN.flip_arrow2 [RC] set+1 %u != %u", dimension_ang2ln->flip_arrow2, flip_arrow2); error++;
      }
    dimension_ang2ln->flip_arrow2--;

  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_ang2ln->horiz_dir)
      pass ("DIMENSION_ANG2LN.horiz_dir [BD] %g", horiz_dir);
    else
      {
        fail ("DIMENSION_ANG2LN.horiz_dir [BD] %g != %g", dimension_ang2ln->horiz_dir, horiz_dir); error++;
      }
    horiz_dir++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "horiz_dir", &horiz_dir) &&
        horiz_dir == dimension_ang2ln->horiz_dir)
      pass ("DIMENSION_ANG2LN.horiz_dir [BD] set+1 %g", horiz_dir);
    else
      {
        fail ("DIMENSION_ANG2LN.horiz_dir [BD] set+1 %g != %g", dimension_ang2ln->horiz_dir, horiz_dir); error++;
      }
    dimension_ang2ln->horiz_dir--;

  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_ang2ln->ins_rotation)
      pass ("DIMENSION_ANG2LN.ins_rotation [BD] %g", ins_rotation);
    else
      {
        fail ("DIMENSION_ANG2LN.ins_rotation [BD] %g != %g", dimension_ang2ln->ins_rotation, ins_rotation); error++;
      }
    ins_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "ins_rotation", &ins_rotation) &&
        ins_rotation == dimension_ang2ln->ins_rotation)
      pass ("DIMENSION_ANG2LN.ins_rotation [BD] set+1 %g", ins_rotation);
    else
      {
        fail ("DIMENSION_ANG2LN.ins_rotation [BD] set+1 %g != %g", dimension_ang2ln->ins_rotation, ins_rotation); error++;
      }
    dimension_ang2ln->ins_rotation--;

  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_ang2ln->ins_scale, sizeof(dimension_ang2ln->ins_scale)))
      pass ("DIMENSION_ANG2LN.ins_scale [3BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.ins_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_ang2ln->lspace_factor)
      pass ("DIMENSION_ANG2LN.lspace_factor [BD] %g", lspace_factor);
    else
      {
        fail ("DIMENSION_ANG2LN.lspace_factor [BD] %g != %g", dimension_ang2ln->lspace_factor, lspace_factor); error++;
      }
    lspace_factor++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_factor", &lspace_factor) &&
        lspace_factor == dimension_ang2ln->lspace_factor)
      pass ("DIMENSION_ANG2LN.lspace_factor [BD] set+1 %g", lspace_factor);
    else
      {
        fail ("DIMENSION_ANG2LN.lspace_factor [BD] set+1 %g != %g", dimension_ang2ln->lspace_factor, lspace_factor); error++;
      }
    dimension_ang2ln->lspace_factor--;

  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_ang2ln->lspace_style)
      pass ("DIMENSION_ANG2LN.lspace_style [BS] %hu", lspace_style);
    else
      {
        fail ("DIMENSION_ANG2LN.lspace_style [BS] %hu != %hu", dimension_ang2ln->lspace_style, lspace_style); error++;
      }
    lspace_style++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_style", &lspace_style) &&
        lspace_style == dimension_ang2ln->lspace_style)
      pass ("DIMENSION_ANG2LN.lspace_style [BS] set+1 %hu", lspace_style);
    else
      {
        fail ("DIMENSION_ANG2LN.lspace_style [BS] set+1 %hu != %hu", dimension_ang2ln->lspace_style, lspace_style); error++;
      }
    dimension_ang2ln->lspace_style--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_ang2ln->parent, sizeof(dimension_ang2ln->parent)))
      pass ("DIMENSION_ANG2LN.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("DIMENSION_ANG2LN.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_ang2ln->text_midpt, sizeof(dimension_ang2ln->text_midpt)))
      pass ("DIMENSION_ANG2LN.text_midpt [2RD]");
    else
      {
        fail ("DIMENSION_ANG2LN.text_midpt [2RD]"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_ang2ln->text_rotation)
      pass ("DIMENSION_ANG2LN.text_rotation [BD] %g", text_rotation);
    else
      {
        fail ("DIMENSION_ANG2LN.text_rotation [BD] %g != %g", dimension_ang2ln->text_rotation, text_rotation); error++;
      }
    text_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "text_rotation", &text_rotation) &&
        text_rotation == dimension_ang2ln->text_rotation)
      pass ("DIMENSION_ANG2LN.text_rotation [BD] set+1 %g", text_rotation);
    else
      {
        fail ("DIMENSION_ANG2LN.text_rotation [BD] set+1 %g != %g", dimension_ang2ln->text_rotation, text_rotation); error++;
      }
    dimension_ang2ln->text_rotation--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "unknown", &unknown, NULL) &&
        unknown == dimension_ang2ln->unknown)
      pass ("DIMENSION_ANG2LN.unknown [RC] %u", unknown);
    else
      {
        fail ("DIMENSION_ANG2LN.unknown [RC] %u != %u", dimension_ang2ln->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(dimension_ang2ln, "DIMENSION_ANG2LN", "unknown", &unknown) &&
        unknown == dimension_ang2ln->unknown)
      pass ("DIMENSION_ANG2LN.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("DIMENSION_ANG2LN.unknown [RC] set+1 %u != %u", dimension_ang2ln->unknown, unknown); error++;
      }
    dimension_ang2ln->unknown--;

  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_ang2ln->user_text))
      pass ("DIMENSION_ANG2LN.user_text [TV]");
    else
      {
        fail ("DIMENSION_ANG2LN.user_text [TV]"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_ANG3PT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_ANG3PT *dimension_ang3pt = obj->tio.entity->tio.DIMENSION_ANG3PT;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "_13_pt", &_13_pt, NULL)
        && !memcmp(&_13_pt, &dimension_ang3pt->_13_pt, sizeof(dimension_ang3pt->_13_pt)))
      pass ("DIMENSION_ANG3PT._13_pt [3BD]");
    else
      {
        fail ("DIMENSION_ANG3PT._13_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "_14_pt", &_14_pt, NULL)
        && !memcmp(&_14_pt, &dimension_ang3pt->_14_pt, sizeof(dimension_ang3pt->_14_pt)))
      pass ("DIMENSION_ANG3PT._14_pt [3BD]");
    else
      {
        fail ("DIMENSION_ANG3PT._14_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_ang3pt->act_measurement)
      pass ("DIMENSION_ANG3PT.act_measurement [BD] %g", act_measurement);
    else
      {
        fail ("DIMENSION_ANG3PT.act_measurement [BD] %g != %g", dimension_ang3pt->act_measurement, act_measurement); error++;
      }
    act_measurement++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "act_measurement", &act_measurement) &&
        act_measurement == dimension_ang3pt->act_measurement)
      pass ("DIMENSION_ANG3PT.act_measurement [BD] set+1 %g", act_measurement);
    else
      {
        fail ("DIMENSION_ANG3PT.act_measurement [BD] set+1 %g != %g", dimension_ang3pt->act_measurement, act_measurement); error++;
      }
    dimension_ang3pt->act_measurement--;

  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "attachment", &attachment, NULL) &&
        attachment == dimension_ang3pt->attachment)
      pass ("DIMENSION_ANG3PT.attachment [BS] %hu", attachment);
    else
      {
        fail ("DIMENSION_ANG3PT.attachment [BS] %hu != %hu", dimension_ang3pt->attachment, attachment); error++;
      }
    attachment++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "attachment", &attachment) &&
        attachment == dimension_ang3pt->attachment)
      pass ("DIMENSION_ANG3PT.attachment [BS] set+1 %hu", attachment);
    else
      {
        fail ("DIMENSION_ANG3PT.attachment [BS] set+1 %hu != %hu", dimension_ang3pt->attachment, attachment); error++;
      }
    dimension_ang3pt->attachment--;

  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "block", &block, NULL)
        && !memcmp(&block, &dimension_ang3pt->block, sizeof(dimension_ang3pt->block)))
      pass ("DIMENSION_ANG3PT.block [H]");
    else
      {
        fail ("DIMENSION_ANG3PT.block [H]"); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_ang3pt->blockname))
      pass ("DIMENSION_ANG3PT.blockname [TV]");
    else
      {
        fail ("DIMENSION_ANG3PT.blockname [TV]"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "class_version", &class_version, NULL) &&
        class_version == dimension_ang3pt->class_version)
      pass ("DIMENSION_ANG3PT.class_version [RC] %u", class_version);
    else
      {
        fail ("DIMENSION_ANG3PT.class_version [RC] %u != %u", dimension_ang3pt->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "class_version", &class_version) &&
        class_version == dimension_ang3pt->class_version)
      pass ("DIMENSION_ANG3PT.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("DIMENSION_ANG3PT.class_version [RC] set+1 %u != %u", dimension_ang3pt->class_version, class_version); error++;
      }
    dimension_ang3pt->class_version--;

  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_ang3pt->clone_ins_pt, sizeof(dimension_ang3pt->clone_ins_pt)))
      pass ("DIMENSION_ANG3PT.clone_ins_pt [2RD]");
    else
      {
        fail ("DIMENSION_ANG3PT.clone_ins_pt [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_ang3pt->def_pt, sizeof(dimension_ang3pt->def_pt)))
      pass ("DIMENSION_ANG3PT.def_pt [3BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.def_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dimension_ang3pt->dimstyle, sizeof(dimension_ang3pt->dimstyle)))
      pass ("DIMENSION_ANG3PT.dimstyle [H]");
    else
      {
        fail ("DIMENSION_ANG3PT.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "elevation", &elevation, NULL) &&
        elevation == dimension_ang3pt->elevation)
      pass ("DIMENSION_ANG3PT.elevation [BD] %g", elevation);
    else
      {
        fail ("DIMENSION_ANG3PT.elevation [BD] %g != %g", dimension_ang3pt->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "elevation", &elevation) &&
        elevation == dimension_ang3pt->elevation)
      pass ("DIMENSION_ANG3PT.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("DIMENSION_ANG3PT.elevation [BD] set+1 %g != %g", dimension_ang3pt->elevation, elevation); error++;
      }
    dimension_ang3pt->elevation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_ang3pt->extrusion, sizeof(dimension_ang3pt->extrusion)))
      pass ("DIMENSION_ANG3PT.extrusion [3BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp(&first_arc_pt, &dimension_ang3pt->first_arc_pt, sizeof(dimension_ang3pt->first_arc_pt)))
      pass ("DIMENSION_ANG3PT.first_arc_pt [3BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.first_arc_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flag", &flag, NULL) &&
        flag == dimension_ang3pt->flag)
      pass ("DIMENSION_ANG3PT.flag [RC] %u", flag);
    else
      {
        fail ("DIMENSION_ANG3PT.flag [RC] %u != %u", dimension_ang3pt->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flag", &flag) &&
        flag == dimension_ang3pt->flag)
      pass ("DIMENSION_ANG3PT.flag [RC] set+1 %u", flag);
    else
      {
        fail ("DIMENSION_ANG3PT.flag [RC] set+1 %u != %u", dimension_ang3pt->flag, flag); error++;
      }
    dimension_ang3pt->flag--;

  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flag1", &flag1, NULL) &&
        flag1 == dimension_ang3pt->flag1)
      pass ("DIMENSION_ANG3PT.flag1 [RC] %u", flag1);
    else
      {
        fail ("DIMENSION_ANG3PT.flag1 [RC] %u != %u", dimension_ang3pt->flag1, flag1); error++;
      }
    flag1++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flag1", &flag1) &&
        flag1 == dimension_ang3pt->flag1)
      pass ("DIMENSION_ANG3PT.flag1 [RC] set+1 %u", flag1);
    else
      {
        fail ("DIMENSION_ANG3PT.flag1 [RC] set+1 %u != %u", dimension_ang3pt->flag1, flag1); error++;
      }
    dimension_ang3pt->flag1--;

  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_ang3pt->flip_arrow1)
      pass ("DIMENSION_ANG3PT.flip_arrow1 [RC] %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_ANG3PT.flip_arrow1 [RC] %u != %u", dimension_ang3pt->flip_arrow1, flip_arrow1); error++;
      }
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow1", &flip_arrow1) &&
        flip_arrow1 == dimension_ang3pt->flip_arrow1)
      pass ("DIMENSION_ANG3PT.flip_arrow1 [RC] set+1 %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_ANG3PT.flip_arrow1 [RC] set+1 %u != %u", dimension_ang3pt->flip_arrow1, flip_arrow1); error++;
      }
    dimension_ang3pt->flip_arrow1--;

  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_ang3pt->flip_arrow2)
      pass ("DIMENSION_ANG3PT.flip_arrow2 [RC] %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_ANG3PT.flip_arrow2 [RC] %u != %u", dimension_ang3pt->flip_arrow2, flip_arrow2); error++;
      }
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow2", &flip_arrow2) &&
        flip_arrow2 == dimension_ang3pt->flip_arrow2)
      pass ("DIMENSION_ANG3PT.flip_arrow2 [RC] set+1 %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_ANG3PT.flip_arrow2 [RC] set+1 %u != %u", dimension_ang3pt->flip_arrow2, flip_arrow2); error++;
      }
    dimension_ang3pt->flip_arrow2--;

  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_ang3pt->horiz_dir)
      pass ("DIMENSION_ANG3PT.horiz_dir [BD] %g", horiz_dir);
    else
      {
        fail ("DIMENSION_ANG3PT.horiz_dir [BD] %g != %g", dimension_ang3pt->horiz_dir, horiz_dir); error++;
      }
    horiz_dir++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "horiz_dir", &horiz_dir) &&
        horiz_dir == dimension_ang3pt->horiz_dir)
      pass ("DIMENSION_ANG3PT.horiz_dir [BD] set+1 %g", horiz_dir);
    else
      {
        fail ("DIMENSION_ANG3PT.horiz_dir [BD] set+1 %g != %g", dimension_ang3pt->horiz_dir, horiz_dir); error++;
      }
    dimension_ang3pt->horiz_dir--;

  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_ang3pt->ins_rotation)
      pass ("DIMENSION_ANG3PT.ins_rotation [BD] %g", ins_rotation);
    else
      {
        fail ("DIMENSION_ANG3PT.ins_rotation [BD] %g != %g", dimension_ang3pt->ins_rotation, ins_rotation); error++;
      }
    ins_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "ins_rotation", &ins_rotation) &&
        ins_rotation == dimension_ang3pt->ins_rotation)
      pass ("DIMENSION_ANG3PT.ins_rotation [BD] set+1 %g", ins_rotation);
    else
      {
        fail ("DIMENSION_ANG3PT.ins_rotation [BD] set+1 %g != %g", dimension_ang3pt->ins_rotation, ins_rotation); error++;
      }
    dimension_ang3pt->ins_rotation--;

  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_ang3pt->ins_scale, sizeof(dimension_ang3pt->ins_scale)))
      pass ("DIMENSION_ANG3PT.ins_scale [3BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.ins_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_ang3pt->lspace_factor)
      pass ("DIMENSION_ANG3PT.lspace_factor [BD] %g", lspace_factor);
    else
      {
        fail ("DIMENSION_ANG3PT.lspace_factor [BD] %g != %g", dimension_ang3pt->lspace_factor, lspace_factor); error++;
      }
    lspace_factor++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_factor", &lspace_factor) &&
        lspace_factor == dimension_ang3pt->lspace_factor)
      pass ("DIMENSION_ANG3PT.lspace_factor [BD] set+1 %g", lspace_factor);
    else
      {
        fail ("DIMENSION_ANG3PT.lspace_factor [BD] set+1 %g != %g", dimension_ang3pt->lspace_factor, lspace_factor); error++;
      }
    dimension_ang3pt->lspace_factor--;

  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_ang3pt->lspace_style)
      pass ("DIMENSION_ANG3PT.lspace_style [BS] %hu", lspace_style);
    else
      {
        fail ("DIMENSION_ANG3PT.lspace_style [BS] %hu != %hu", dimension_ang3pt->lspace_style, lspace_style); error++;
      }
    lspace_style++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_style", &lspace_style) &&
        lspace_style == dimension_ang3pt->lspace_style)
      pass ("DIMENSION_ANG3PT.lspace_style [BS] set+1 %hu", lspace_style);
    else
      {
        fail ("DIMENSION_ANG3PT.lspace_style [BS] set+1 %hu != %hu", dimension_ang3pt->lspace_style, lspace_style); error++;
      }
    dimension_ang3pt->lspace_style--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_ang3pt->parent, sizeof(dimension_ang3pt->parent)))
      pass ("DIMENSION_ANG3PT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("DIMENSION_ANG3PT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_ang3pt->text_midpt, sizeof(dimension_ang3pt->text_midpt)))
      pass ("DIMENSION_ANG3PT.text_midpt [2RD]");
    else
      {
        fail ("DIMENSION_ANG3PT.text_midpt [2RD]"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_ang3pt->text_rotation)
      pass ("DIMENSION_ANG3PT.text_rotation [BD] %g", text_rotation);
    else
      {
        fail ("DIMENSION_ANG3PT.text_rotation [BD] %g != %g", dimension_ang3pt->text_rotation, text_rotation); error++;
      }
    text_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "text_rotation", &text_rotation) &&
        text_rotation == dimension_ang3pt->text_rotation)
      pass ("DIMENSION_ANG3PT.text_rotation [BD] set+1 %g", text_rotation);
    else
      {
        fail ("DIMENSION_ANG3PT.text_rotation [BD] set+1 %g != %g", dimension_ang3pt->text_rotation, text_rotation); error++;
      }
    dimension_ang3pt->text_rotation--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "unknown", &unknown, NULL) &&
        unknown == dimension_ang3pt->unknown)
      pass ("DIMENSION_ANG3PT.unknown [RC] %u", unknown);
    else
      {
        fail ("DIMENSION_ANG3PT.unknown [RC] %u != %u", dimension_ang3pt->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(dimension_ang3pt, "DIMENSION_ANG3PT", "unknown", &unknown) &&
        unknown == dimension_ang3pt->unknown)
      pass ("DIMENSION_ANG3PT.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("DIMENSION_ANG3PT.unknown [RC] set+1 %u != %u", dimension_ang3pt->unknown, unknown); error++;
      }
    dimension_ang3pt->unknown--;

  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_ang3pt->user_text))
      pass ("DIMENSION_ANG3PT.user_text [TV]");
    else
      {
        fail ("DIMENSION_ANG3PT.user_text [TV]"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_DIAMETER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_DIAMETER *dimension_diameter = obj->tio.entity->tio.DIMENSION_DIAMETER;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_diameter->act_measurement)
      pass ("DIMENSION_DIAMETER.act_measurement [BD] %g", act_measurement);
    else
      {
        fail ("DIMENSION_DIAMETER.act_measurement [BD] %g != %g", dimension_diameter->act_measurement, act_measurement); error++;
      }
    act_measurement++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "act_measurement", &act_measurement) &&
        act_measurement == dimension_diameter->act_measurement)
      pass ("DIMENSION_DIAMETER.act_measurement [BD] set+1 %g", act_measurement);
    else
      {
        fail ("DIMENSION_DIAMETER.act_measurement [BD] set+1 %g != %g", dimension_diameter->act_measurement, act_measurement); error++;
      }
    dimension_diameter->act_measurement--;

  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "attachment", &attachment, NULL) &&
        attachment == dimension_diameter->attachment)
      pass ("DIMENSION_DIAMETER.attachment [BS] %hu", attachment);
    else
      {
        fail ("DIMENSION_DIAMETER.attachment [BS] %hu != %hu", dimension_diameter->attachment, attachment); error++;
      }
    attachment++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "attachment", &attachment) &&
        attachment == dimension_diameter->attachment)
      pass ("DIMENSION_DIAMETER.attachment [BS] set+1 %hu", attachment);
    else
      {
        fail ("DIMENSION_DIAMETER.attachment [BS] set+1 %hu != %hu", dimension_diameter->attachment, attachment); error++;
      }
    dimension_diameter->attachment--;

  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "block", &block, NULL)
        && !memcmp(&block, &dimension_diameter->block, sizeof(dimension_diameter->block)))
      pass ("DIMENSION_DIAMETER.block [H]");
    else
      {
        fail ("DIMENSION_DIAMETER.block [H]"); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_diameter->blockname))
      pass ("DIMENSION_DIAMETER.blockname [TV]");
    else
      {
        fail ("DIMENSION_DIAMETER.blockname [TV]"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "class_version", &class_version, NULL) &&
        class_version == dimension_diameter->class_version)
      pass ("DIMENSION_DIAMETER.class_version [RC] %u", class_version);
    else
      {
        fail ("DIMENSION_DIAMETER.class_version [RC] %u != %u", dimension_diameter->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "class_version", &class_version) &&
        class_version == dimension_diameter->class_version)
      pass ("DIMENSION_DIAMETER.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("DIMENSION_DIAMETER.class_version [RC] set+1 %u != %u", dimension_diameter->class_version, class_version); error++;
      }
    dimension_diameter->class_version--;

  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_diameter->clone_ins_pt, sizeof(dimension_diameter->clone_ins_pt)))
      pass ("DIMENSION_DIAMETER.clone_ins_pt [2RD]");
    else
      {
        fail ("DIMENSION_DIAMETER.clone_ins_pt [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_diameter->def_pt, sizeof(dimension_diameter->def_pt)))
      pass ("DIMENSION_DIAMETER.def_pt [3BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.def_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dimension_diameter->dimstyle, sizeof(dimension_diameter->dimstyle)))
      pass ("DIMENSION_DIAMETER.dimstyle [H]");
    else
      {
        fail ("DIMENSION_DIAMETER.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "elevation", &elevation, NULL) &&
        elevation == dimension_diameter->elevation)
      pass ("DIMENSION_DIAMETER.elevation [BD] %g", elevation);
    else
      {
        fail ("DIMENSION_DIAMETER.elevation [BD] %g != %g", dimension_diameter->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "elevation", &elevation) &&
        elevation == dimension_diameter->elevation)
      pass ("DIMENSION_DIAMETER.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("DIMENSION_DIAMETER.elevation [BD] set+1 %g != %g", dimension_diameter->elevation, elevation); error++;
      }
    dimension_diameter->elevation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_diameter->extrusion, sizeof(dimension_diameter->extrusion)))
      pass ("DIMENSION_DIAMETER.extrusion [3BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp(&first_arc_pt, &dimension_diameter->first_arc_pt, sizeof(dimension_diameter->first_arc_pt)))
      pass ("DIMENSION_DIAMETER.first_arc_pt [3BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.first_arc_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "flag", &flag, NULL) &&
        flag == dimension_diameter->flag)
      pass ("DIMENSION_DIAMETER.flag [RC] %u", flag);
    else
      {
        fail ("DIMENSION_DIAMETER.flag [RC] %u != %u", dimension_diameter->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "flag", &flag) &&
        flag == dimension_diameter->flag)
      pass ("DIMENSION_DIAMETER.flag [RC] set+1 %u", flag);
    else
      {
        fail ("DIMENSION_DIAMETER.flag [RC] set+1 %u != %u", dimension_diameter->flag, flag); error++;
      }
    dimension_diameter->flag--;

  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "flag1", &flag1, NULL) &&
        flag1 == dimension_diameter->flag1)
      pass ("DIMENSION_DIAMETER.flag1 [RC] %u", flag1);
    else
      {
        fail ("DIMENSION_DIAMETER.flag1 [RC] %u != %u", dimension_diameter->flag1, flag1); error++;
      }
    flag1++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "flag1", &flag1) &&
        flag1 == dimension_diameter->flag1)
      pass ("DIMENSION_DIAMETER.flag1 [RC] set+1 %u", flag1);
    else
      {
        fail ("DIMENSION_DIAMETER.flag1 [RC] set+1 %u != %u", dimension_diameter->flag1, flag1); error++;
      }
    dimension_diameter->flag1--;

  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_diameter->flip_arrow1)
      pass ("DIMENSION_DIAMETER.flip_arrow1 [RC] %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_DIAMETER.flip_arrow1 [RC] %u != %u", dimension_diameter->flip_arrow1, flip_arrow1); error++;
      }
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow1", &flip_arrow1) &&
        flip_arrow1 == dimension_diameter->flip_arrow1)
      pass ("DIMENSION_DIAMETER.flip_arrow1 [RC] set+1 %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_DIAMETER.flip_arrow1 [RC] set+1 %u != %u", dimension_diameter->flip_arrow1, flip_arrow1); error++;
      }
    dimension_diameter->flip_arrow1--;

  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_diameter->flip_arrow2)
      pass ("DIMENSION_DIAMETER.flip_arrow2 [RC] %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_DIAMETER.flip_arrow2 [RC] %u != %u", dimension_diameter->flip_arrow2, flip_arrow2); error++;
      }
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow2", &flip_arrow2) &&
        flip_arrow2 == dimension_diameter->flip_arrow2)
      pass ("DIMENSION_DIAMETER.flip_arrow2 [RC] set+1 %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_DIAMETER.flip_arrow2 [RC] set+1 %u != %u", dimension_diameter->flip_arrow2, flip_arrow2); error++;
      }
    dimension_diameter->flip_arrow2--;

  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_diameter->horiz_dir)
      pass ("DIMENSION_DIAMETER.horiz_dir [BD] %g", horiz_dir);
    else
      {
        fail ("DIMENSION_DIAMETER.horiz_dir [BD] %g != %g", dimension_diameter->horiz_dir, horiz_dir); error++;
      }
    horiz_dir++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "horiz_dir", &horiz_dir) &&
        horiz_dir == dimension_diameter->horiz_dir)
      pass ("DIMENSION_DIAMETER.horiz_dir [BD] set+1 %g", horiz_dir);
    else
      {
        fail ("DIMENSION_DIAMETER.horiz_dir [BD] set+1 %g != %g", dimension_diameter->horiz_dir, horiz_dir); error++;
      }
    dimension_diameter->horiz_dir--;

  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_diameter->ins_rotation)
      pass ("DIMENSION_DIAMETER.ins_rotation [BD] %g", ins_rotation);
    else
      {
        fail ("DIMENSION_DIAMETER.ins_rotation [BD] %g != %g", dimension_diameter->ins_rotation, ins_rotation); error++;
      }
    ins_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "ins_rotation", &ins_rotation) &&
        ins_rotation == dimension_diameter->ins_rotation)
      pass ("DIMENSION_DIAMETER.ins_rotation [BD] set+1 %g", ins_rotation);
    else
      {
        fail ("DIMENSION_DIAMETER.ins_rotation [BD] set+1 %g != %g", dimension_diameter->ins_rotation, ins_rotation); error++;
      }
    dimension_diameter->ins_rotation--;

  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_diameter->ins_scale, sizeof(dimension_diameter->ins_scale)))
      pass ("DIMENSION_DIAMETER.ins_scale [3BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.ins_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "leader_len", &leader_len, NULL) &&
        leader_len == dimension_diameter->leader_len)
      pass ("DIMENSION_DIAMETER.leader_len [BD] %g", leader_len);
    else
      {
        fail ("DIMENSION_DIAMETER.leader_len [BD] %g != %g", dimension_diameter->leader_len, leader_len); error++;
      }
    leader_len++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "leader_len", &leader_len) &&
        leader_len == dimension_diameter->leader_len)
      pass ("DIMENSION_DIAMETER.leader_len [BD] set+1 %g", leader_len);
    else
      {
        fail ("DIMENSION_DIAMETER.leader_len [BD] set+1 %g != %g", dimension_diameter->leader_len, leader_len); error++;
      }
    dimension_diameter->leader_len--;

  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_diameter->lspace_factor)
      pass ("DIMENSION_DIAMETER.lspace_factor [BD] %g", lspace_factor);
    else
      {
        fail ("DIMENSION_DIAMETER.lspace_factor [BD] %g != %g", dimension_diameter->lspace_factor, lspace_factor); error++;
      }
    lspace_factor++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "lspace_factor", &lspace_factor) &&
        lspace_factor == dimension_diameter->lspace_factor)
      pass ("DIMENSION_DIAMETER.lspace_factor [BD] set+1 %g", lspace_factor);
    else
      {
        fail ("DIMENSION_DIAMETER.lspace_factor [BD] set+1 %g != %g", dimension_diameter->lspace_factor, lspace_factor); error++;
      }
    dimension_diameter->lspace_factor--;

  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_diameter->lspace_style)
      pass ("DIMENSION_DIAMETER.lspace_style [BS] %hu", lspace_style);
    else
      {
        fail ("DIMENSION_DIAMETER.lspace_style [BS] %hu != %hu", dimension_diameter->lspace_style, lspace_style); error++;
      }
    lspace_style++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "lspace_style", &lspace_style) &&
        lspace_style == dimension_diameter->lspace_style)
      pass ("DIMENSION_DIAMETER.lspace_style [BS] set+1 %hu", lspace_style);
    else
      {
        fail ("DIMENSION_DIAMETER.lspace_style [BS] set+1 %hu != %hu", dimension_diameter->lspace_style, lspace_style); error++;
      }
    dimension_diameter->lspace_style--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_diameter->parent, sizeof(dimension_diameter->parent)))
      pass ("DIMENSION_DIAMETER.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("DIMENSION_DIAMETER.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_diameter->text_midpt, sizeof(dimension_diameter->text_midpt)))
      pass ("DIMENSION_DIAMETER.text_midpt [2RD]");
    else
      {
        fail ("DIMENSION_DIAMETER.text_midpt [2RD]"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_diameter->text_rotation)
      pass ("DIMENSION_DIAMETER.text_rotation [BD] %g", text_rotation);
    else
      {
        fail ("DIMENSION_DIAMETER.text_rotation [BD] %g != %g", dimension_diameter->text_rotation, text_rotation); error++;
      }
    text_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "text_rotation", &text_rotation) &&
        text_rotation == dimension_diameter->text_rotation)
      pass ("DIMENSION_DIAMETER.text_rotation [BD] set+1 %g", text_rotation);
    else
      {
        fail ("DIMENSION_DIAMETER.text_rotation [BD] set+1 %g != %g", dimension_diameter->text_rotation, text_rotation); error++;
      }
    dimension_diameter->text_rotation--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "unknown", &unknown, NULL) &&
        unknown == dimension_diameter->unknown)
      pass ("DIMENSION_DIAMETER.unknown [RC] %u", unknown);
    else
      {
        fail ("DIMENSION_DIAMETER.unknown [RC] %u != %u", dimension_diameter->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(dimension_diameter, "DIMENSION_DIAMETER", "unknown", &unknown) &&
        unknown == dimension_diameter->unknown)
      pass ("DIMENSION_DIAMETER.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("DIMENSION_DIAMETER.unknown [RC] set+1 %u != %u", dimension_diameter->unknown, unknown); error++;
      }
    dimension_diameter->unknown--;

  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_diameter->user_text))
      pass ("DIMENSION_DIAMETER.user_text [TV]");
    else
      {
        fail ("DIMENSION_DIAMETER.user_text [TV]"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_LINEAR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_LINEAR *dimension_linear = obj->tio.entity->tio.DIMENSION_LINEAR;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "_13_pt", &_13_pt, NULL)
        && !memcmp(&_13_pt, &dimension_linear->_13_pt, sizeof(dimension_linear->_13_pt)))
      pass ("DIMENSION_LINEAR._13_pt [3BD]");
    else
      {
        fail ("DIMENSION_LINEAR._13_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "_14_pt", &_14_pt, NULL)
        && !memcmp(&_14_pt, &dimension_linear->_14_pt, sizeof(dimension_linear->_14_pt)))
      pass ("DIMENSION_LINEAR._14_pt [3BD]");
    else
      {
        fail ("DIMENSION_LINEAR._14_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_linear->act_measurement)
      pass ("DIMENSION_LINEAR.act_measurement [BD] %g", act_measurement);
    else
      {
        fail ("DIMENSION_LINEAR.act_measurement [BD] %g != %g", dimension_linear->act_measurement, act_measurement); error++;
      }
    act_measurement++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "act_measurement", &act_measurement) &&
        act_measurement == dimension_linear->act_measurement)
      pass ("DIMENSION_LINEAR.act_measurement [BD] set+1 %g", act_measurement);
    else
      {
        fail ("DIMENSION_LINEAR.act_measurement [BD] set+1 %g != %g", dimension_linear->act_measurement, act_measurement); error++;
      }
    dimension_linear->act_measurement--;

  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "attachment", &attachment, NULL) &&
        attachment == dimension_linear->attachment)
      pass ("DIMENSION_LINEAR.attachment [BS] %hu", attachment);
    else
      {
        fail ("DIMENSION_LINEAR.attachment [BS] %hu != %hu", dimension_linear->attachment, attachment); error++;
      }
    attachment++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "attachment", &attachment) &&
        attachment == dimension_linear->attachment)
      pass ("DIMENSION_LINEAR.attachment [BS] set+1 %hu", attachment);
    else
      {
        fail ("DIMENSION_LINEAR.attachment [BS] set+1 %hu != %hu", dimension_linear->attachment, attachment); error++;
      }
    dimension_linear->attachment--;

  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "block", &block, NULL)
        && !memcmp(&block, &dimension_linear->block, sizeof(dimension_linear->block)))
      pass ("DIMENSION_LINEAR.block [H]");
    else
      {
        fail ("DIMENSION_LINEAR.block [H]"); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_linear->blockname))
      pass ("DIMENSION_LINEAR.blockname [TV]");
    else
      {
        fail ("DIMENSION_LINEAR.blockname [TV]"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "class_version", &class_version, NULL) &&
        class_version == dimension_linear->class_version)
      pass ("DIMENSION_LINEAR.class_version [RC] %u", class_version);
    else
      {
        fail ("DIMENSION_LINEAR.class_version [RC] %u != %u", dimension_linear->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "class_version", &class_version) &&
        class_version == dimension_linear->class_version)
      pass ("DIMENSION_LINEAR.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("DIMENSION_LINEAR.class_version [RC] set+1 %u != %u", dimension_linear->class_version, class_version); error++;
      }
    dimension_linear->class_version--;

  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_linear->clone_ins_pt, sizeof(dimension_linear->clone_ins_pt)))
      pass ("DIMENSION_LINEAR.clone_ins_pt [2RD]");
    else
      {
        fail ("DIMENSION_LINEAR.clone_ins_pt [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_linear->def_pt, sizeof(dimension_linear->def_pt)))
      pass ("DIMENSION_LINEAR.def_pt [3BD]");
    else
      {
        fail ("DIMENSION_LINEAR.def_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BD dim_rotation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "dim_rotation", &dim_rotation, NULL) &&
        dim_rotation == dimension_linear->dim_rotation)
      pass ("DIMENSION_LINEAR.dim_rotation [BD] %g", dim_rotation);
    else
      {
        fail ("DIMENSION_LINEAR.dim_rotation [BD] %g != %g", dimension_linear->dim_rotation, dim_rotation); error++;
      }
    dim_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "dim_rotation", &dim_rotation) &&
        dim_rotation == dimension_linear->dim_rotation)
      pass ("DIMENSION_LINEAR.dim_rotation [BD] set+1 %g", dim_rotation);
    else
      {
        fail ("DIMENSION_LINEAR.dim_rotation [BD] set+1 %g != %g", dimension_linear->dim_rotation, dim_rotation); error++;
      }
    dimension_linear->dim_rotation--;

  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dimension_linear->dimstyle, sizeof(dimension_linear->dimstyle)))
      pass ("DIMENSION_LINEAR.dimstyle [H]");
    else
      {
        fail ("DIMENSION_LINEAR.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "elevation", &elevation, NULL) &&
        elevation == dimension_linear->elevation)
      pass ("DIMENSION_LINEAR.elevation [BD] %g", elevation);
    else
      {
        fail ("DIMENSION_LINEAR.elevation [BD] %g != %g", dimension_linear->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "elevation", &elevation) &&
        elevation == dimension_linear->elevation)
      pass ("DIMENSION_LINEAR.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("DIMENSION_LINEAR.elevation [BD] set+1 %g != %g", dimension_linear->elevation, elevation); error++;
      }
    dimension_linear->elevation--;

  }
  {
    BITCODE_BD ext_line_rotation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "ext_line_rotation", &ext_line_rotation, NULL) &&
        ext_line_rotation == dimension_linear->ext_line_rotation)
      pass ("DIMENSION_LINEAR.ext_line_rotation [BD] %g", ext_line_rotation);
    else
      {
        fail ("DIMENSION_LINEAR.ext_line_rotation [BD] %g != %g", dimension_linear->ext_line_rotation, ext_line_rotation); error++;
      }
    ext_line_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "ext_line_rotation", &ext_line_rotation) &&
        ext_line_rotation == dimension_linear->ext_line_rotation)
      pass ("DIMENSION_LINEAR.ext_line_rotation [BD] set+1 %g", ext_line_rotation);
    else
      {
        fail ("DIMENSION_LINEAR.ext_line_rotation [BD] set+1 %g != %g", dimension_linear->ext_line_rotation, ext_line_rotation); error++;
      }
    dimension_linear->ext_line_rotation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_linear->extrusion, sizeof(dimension_linear->extrusion)))
      pass ("DIMENSION_LINEAR.extrusion [3BD]");
    else
      {
        fail ("DIMENSION_LINEAR.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "flag", &flag, NULL) &&
        flag == dimension_linear->flag)
      pass ("DIMENSION_LINEAR.flag [RC] %u", flag);
    else
      {
        fail ("DIMENSION_LINEAR.flag [RC] %u != %u", dimension_linear->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "flag", &flag) &&
        flag == dimension_linear->flag)
      pass ("DIMENSION_LINEAR.flag [RC] set+1 %u", flag);
    else
      {
        fail ("DIMENSION_LINEAR.flag [RC] set+1 %u != %u", dimension_linear->flag, flag); error++;
      }
    dimension_linear->flag--;

  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "flag1", &flag1, NULL) &&
        flag1 == dimension_linear->flag1)
      pass ("DIMENSION_LINEAR.flag1 [RC] %u", flag1);
    else
      {
        fail ("DIMENSION_LINEAR.flag1 [RC] %u != %u", dimension_linear->flag1, flag1); error++;
      }
    flag1++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "flag1", &flag1) &&
        flag1 == dimension_linear->flag1)
      pass ("DIMENSION_LINEAR.flag1 [RC] set+1 %u", flag1);
    else
      {
        fail ("DIMENSION_LINEAR.flag1 [RC] set+1 %u != %u", dimension_linear->flag1, flag1); error++;
      }
    dimension_linear->flag1--;

  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_linear->flip_arrow1)
      pass ("DIMENSION_LINEAR.flip_arrow1 [RC] %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_LINEAR.flip_arrow1 [RC] %u != %u", dimension_linear->flip_arrow1, flip_arrow1); error++;
      }
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "flip_arrow1", &flip_arrow1) &&
        flip_arrow1 == dimension_linear->flip_arrow1)
      pass ("DIMENSION_LINEAR.flip_arrow1 [RC] set+1 %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_LINEAR.flip_arrow1 [RC] set+1 %u != %u", dimension_linear->flip_arrow1, flip_arrow1); error++;
      }
    dimension_linear->flip_arrow1--;

  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_linear->flip_arrow2)
      pass ("DIMENSION_LINEAR.flip_arrow2 [RC] %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_LINEAR.flip_arrow2 [RC] %u != %u", dimension_linear->flip_arrow2, flip_arrow2); error++;
      }
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "flip_arrow2", &flip_arrow2) &&
        flip_arrow2 == dimension_linear->flip_arrow2)
      pass ("DIMENSION_LINEAR.flip_arrow2 [RC] set+1 %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_LINEAR.flip_arrow2 [RC] set+1 %u != %u", dimension_linear->flip_arrow2, flip_arrow2); error++;
      }
    dimension_linear->flip_arrow2--;

  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_linear->horiz_dir)
      pass ("DIMENSION_LINEAR.horiz_dir [BD] %g", horiz_dir);
    else
      {
        fail ("DIMENSION_LINEAR.horiz_dir [BD] %g != %g", dimension_linear->horiz_dir, horiz_dir); error++;
      }
    horiz_dir++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "horiz_dir", &horiz_dir) &&
        horiz_dir == dimension_linear->horiz_dir)
      pass ("DIMENSION_LINEAR.horiz_dir [BD] set+1 %g", horiz_dir);
    else
      {
        fail ("DIMENSION_LINEAR.horiz_dir [BD] set+1 %g != %g", dimension_linear->horiz_dir, horiz_dir); error++;
      }
    dimension_linear->horiz_dir--;

  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_linear->ins_rotation)
      pass ("DIMENSION_LINEAR.ins_rotation [BD] %g", ins_rotation);
    else
      {
        fail ("DIMENSION_LINEAR.ins_rotation [BD] %g != %g", dimension_linear->ins_rotation, ins_rotation); error++;
      }
    ins_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "ins_rotation", &ins_rotation) &&
        ins_rotation == dimension_linear->ins_rotation)
      pass ("DIMENSION_LINEAR.ins_rotation [BD] set+1 %g", ins_rotation);
    else
      {
        fail ("DIMENSION_LINEAR.ins_rotation [BD] set+1 %g != %g", dimension_linear->ins_rotation, ins_rotation); error++;
      }
    dimension_linear->ins_rotation--;

  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_linear->ins_scale, sizeof(dimension_linear->ins_scale)))
      pass ("DIMENSION_LINEAR.ins_scale [3BD]");
    else
      {
        fail ("DIMENSION_LINEAR.ins_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_linear->lspace_factor)
      pass ("DIMENSION_LINEAR.lspace_factor [BD] %g", lspace_factor);
    else
      {
        fail ("DIMENSION_LINEAR.lspace_factor [BD] %g != %g", dimension_linear->lspace_factor, lspace_factor); error++;
      }
    lspace_factor++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "lspace_factor", &lspace_factor) &&
        lspace_factor == dimension_linear->lspace_factor)
      pass ("DIMENSION_LINEAR.lspace_factor [BD] set+1 %g", lspace_factor);
    else
      {
        fail ("DIMENSION_LINEAR.lspace_factor [BD] set+1 %g != %g", dimension_linear->lspace_factor, lspace_factor); error++;
      }
    dimension_linear->lspace_factor--;

  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_linear->lspace_style)
      pass ("DIMENSION_LINEAR.lspace_style [BS] %hu", lspace_style);
    else
      {
        fail ("DIMENSION_LINEAR.lspace_style [BS] %hu != %hu", dimension_linear->lspace_style, lspace_style); error++;
      }
    lspace_style++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "lspace_style", &lspace_style) &&
        lspace_style == dimension_linear->lspace_style)
      pass ("DIMENSION_LINEAR.lspace_style [BS] set+1 %hu", lspace_style);
    else
      {
        fail ("DIMENSION_LINEAR.lspace_style [BS] set+1 %hu != %hu", dimension_linear->lspace_style, lspace_style); error++;
      }
    dimension_linear->lspace_style--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_linear->parent, sizeof(dimension_linear->parent)))
      pass ("DIMENSION_LINEAR.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("DIMENSION_LINEAR.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_linear->text_midpt, sizeof(dimension_linear->text_midpt)))
      pass ("DIMENSION_LINEAR.text_midpt [2RD]");
    else
      {
        fail ("DIMENSION_LINEAR.text_midpt [2RD]"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_linear->text_rotation)
      pass ("DIMENSION_LINEAR.text_rotation [BD] %g", text_rotation);
    else
      {
        fail ("DIMENSION_LINEAR.text_rotation [BD] %g != %g", dimension_linear->text_rotation, text_rotation); error++;
      }
    text_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "text_rotation", &text_rotation) &&
        text_rotation == dimension_linear->text_rotation)
      pass ("DIMENSION_LINEAR.text_rotation [BD] set+1 %g", text_rotation);
    else
      {
        fail ("DIMENSION_LINEAR.text_rotation [BD] set+1 %g != %g", dimension_linear->text_rotation, text_rotation); error++;
      }
    dimension_linear->text_rotation--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "unknown", &unknown, NULL) &&
        unknown == dimension_linear->unknown)
      pass ("DIMENSION_LINEAR.unknown [RC] %u", unknown);
    else
      {
        fail ("DIMENSION_LINEAR.unknown [RC] %u != %u", dimension_linear->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(dimension_linear, "DIMENSION_LINEAR", "unknown", &unknown) &&
        unknown == dimension_linear->unknown)
      pass ("DIMENSION_LINEAR.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("DIMENSION_LINEAR.unknown [RC] set+1 %u != %u", dimension_linear->unknown, unknown); error++;
      }
    dimension_linear->unknown--;

  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_linear->user_text))
      pass ("DIMENSION_LINEAR.user_text [TV]");
    else
      {
        fail ("DIMENSION_LINEAR.user_text [TV]"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_ORDINATE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_ORDINATE *dimension_ordinate = obj->tio.entity->tio.DIMENSION_ORDINATE;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_ordinate->act_measurement)
      pass ("DIMENSION_ORDINATE.act_measurement [BD] %g", act_measurement);
    else
      {
        fail ("DIMENSION_ORDINATE.act_measurement [BD] %g != %g", dimension_ordinate->act_measurement, act_measurement); error++;
      }
    act_measurement++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "act_measurement", &act_measurement) &&
        act_measurement == dimension_ordinate->act_measurement)
      pass ("DIMENSION_ORDINATE.act_measurement [BD] set+1 %g", act_measurement);
    else
      {
        fail ("DIMENSION_ORDINATE.act_measurement [BD] set+1 %g != %g", dimension_ordinate->act_measurement, act_measurement); error++;
      }
    dimension_ordinate->act_measurement--;

  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "attachment", &attachment, NULL) &&
        attachment == dimension_ordinate->attachment)
      pass ("DIMENSION_ORDINATE.attachment [BS] %hu", attachment);
    else
      {
        fail ("DIMENSION_ORDINATE.attachment [BS] %hu != %hu", dimension_ordinate->attachment, attachment); error++;
      }
    attachment++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "attachment", &attachment) &&
        attachment == dimension_ordinate->attachment)
      pass ("DIMENSION_ORDINATE.attachment [BS] set+1 %hu", attachment);
    else
      {
        fail ("DIMENSION_ORDINATE.attachment [BS] set+1 %hu != %hu", dimension_ordinate->attachment, attachment); error++;
      }
    dimension_ordinate->attachment--;

  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "block", &block, NULL)
        && !memcmp(&block, &dimension_ordinate->block, sizeof(dimension_ordinate->block)))
      pass ("DIMENSION_ORDINATE.block [H]");
    else
      {
        fail ("DIMENSION_ORDINATE.block [H]"); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_ordinate->blockname))
      pass ("DIMENSION_ORDINATE.blockname [TV]");
    else
      {
        fail ("DIMENSION_ORDINATE.blockname [TV]"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "class_version", &class_version, NULL) &&
        class_version == dimension_ordinate->class_version)
      pass ("DIMENSION_ORDINATE.class_version [RC] %u", class_version);
    else
      {
        fail ("DIMENSION_ORDINATE.class_version [RC] %u != %u", dimension_ordinate->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "class_version", &class_version) &&
        class_version == dimension_ordinate->class_version)
      pass ("DIMENSION_ORDINATE.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("DIMENSION_ORDINATE.class_version [RC] set+1 %u != %u", dimension_ordinate->class_version, class_version); error++;
      }
    dimension_ordinate->class_version--;

  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_ordinate->clone_ins_pt, sizeof(dimension_ordinate->clone_ins_pt)))
      pass ("DIMENSION_ORDINATE.clone_ins_pt [2RD]");
    else
      {
        fail ("DIMENSION_ORDINATE.clone_ins_pt [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_ordinate->def_pt, sizeof(dimension_ordinate->def_pt)))
      pass ("DIMENSION_ORDINATE.def_pt [3BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.def_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dimension_ordinate->dimstyle, sizeof(dimension_ordinate->dimstyle)))
      pass ("DIMENSION_ORDINATE.dimstyle [H]");
    else
      {
        fail ("DIMENSION_ORDINATE.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "elevation", &elevation, NULL) &&
        elevation == dimension_ordinate->elevation)
      pass ("DIMENSION_ORDINATE.elevation [BD] %g", elevation);
    else
      {
        fail ("DIMENSION_ORDINATE.elevation [BD] %g != %g", dimension_ordinate->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "elevation", &elevation) &&
        elevation == dimension_ordinate->elevation)
      pass ("DIMENSION_ORDINATE.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("DIMENSION_ORDINATE.elevation [BD] set+1 %g != %g", dimension_ordinate->elevation, elevation); error++;
      }
    dimension_ordinate->elevation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_ordinate->extrusion, sizeof(dimension_ordinate->extrusion)))
      pass ("DIMENSION_ORDINATE.extrusion [3BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD feature_location_pt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "feature_location_pt", &feature_location_pt, NULL)
        && !memcmp(&feature_location_pt, &dimension_ordinate->feature_location_pt, sizeof(dimension_ordinate->feature_location_pt)))
      pass ("DIMENSION_ORDINATE.feature_location_pt [3BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.feature_location_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag", &flag, NULL) &&
        flag == dimension_ordinate->flag)
      pass ("DIMENSION_ORDINATE.flag [RC] %u", flag);
    else
      {
        fail ("DIMENSION_ORDINATE.flag [RC] %u != %u", dimension_ordinate->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag", &flag) &&
        flag == dimension_ordinate->flag)
      pass ("DIMENSION_ORDINATE.flag [RC] set+1 %u", flag);
    else
      {
        fail ("DIMENSION_ORDINATE.flag [RC] set+1 %u != %u", dimension_ordinate->flag, flag); error++;
      }
    dimension_ordinate->flag--;

  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag1", &flag1, NULL) &&
        flag1 == dimension_ordinate->flag1)
      pass ("DIMENSION_ORDINATE.flag1 [RC] %u", flag1);
    else
      {
        fail ("DIMENSION_ORDINATE.flag1 [RC] %u != %u", dimension_ordinate->flag1, flag1); error++;
      }
    flag1++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag1", &flag1) &&
        flag1 == dimension_ordinate->flag1)
      pass ("DIMENSION_ORDINATE.flag1 [RC] set+1 %u", flag1);
    else
      {
        fail ("DIMENSION_ORDINATE.flag1 [RC] set+1 %u != %u", dimension_ordinate->flag1, flag1); error++;
      }
    dimension_ordinate->flag1--;

  }
  {
    BITCODE_RC flag2;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag2", &flag2, NULL) &&
        flag2 == dimension_ordinate->flag2)
      pass ("DIMENSION_ORDINATE.flag2 [RC] %u", flag2);
    else
      {
        fail ("DIMENSION_ORDINATE.flag2 [RC] %u != %u", dimension_ordinate->flag2, flag2); error++;
      }
    flag2++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag2", &flag2) &&
        flag2 == dimension_ordinate->flag2)
      pass ("DIMENSION_ORDINATE.flag2 [RC] set+1 %u", flag2);
    else
      {
        fail ("DIMENSION_ORDINATE.flag2 [RC] set+1 %u != %u", dimension_ordinate->flag2, flag2); error++;
      }
    dimension_ordinate->flag2--;

  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_ordinate->flip_arrow1)
      pass ("DIMENSION_ORDINATE.flip_arrow1 [RC] %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_ORDINATE.flip_arrow1 [RC] %u != %u", dimension_ordinate->flip_arrow1, flip_arrow1); error++;
      }
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow1", &flip_arrow1) &&
        flip_arrow1 == dimension_ordinate->flip_arrow1)
      pass ("DIMENSION_ORDINATE.flip_arrow1 [RC] set+1 %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_ORDINATE.flip_arrow1 [RC] set+1 %u != %u", dimension_ordinate->flip_arrow1, flip_arrow1); error++;
      }
    dimension_ordinate->flip_arrow1--;

  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_ordinate->flip_arrow2)
      pass ("DIMENSION_ORDINATE.flip_arrow2 [RC] %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_ORDINATE.flip_arrow2 [RC] %u != %u", dimension_ordinate->flip_arrow2, flip_arrow2); error++;
      }
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow2", &flip_arrow2) &&
        flip_arrow2 == dimension_ordinate->flip_arrow2)
      pass ("DIMENSION_ORDINATE.flip_arrow2 [RC] set+1 %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_ORDINATE.flip_arrow2 [RC] set+1 %u != %u", dimension_ordinate->flip_arrow2, flip_arrow2); error++;
      }
    dimension_ordinate->flip_arrow2--;

  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_ordinate->horiz_dir)
      pass ("DIMENSION_ORDINATE.horiz_dir [BD] %g", horiz_dir);
    else
      {
        fail ("DIMENSION_ORDINATE.horiz_dir [BD] %g != %g", dimension_ordinate->horiz_dir, horiz_dir); error++;
      }
    horiz_dir++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "horiz_dir", &horiz_dir) &&
        horiz_dir == dimension_ordinate->horiz_dir)
      pass ("DIMENSION_ORDINATE.horiz_dir [BD] set+1 %g", horiz_dir);
    else
      {
        fail ("DIMENSION_ORDINATE.horiz_dir [BD] set+1 %g != %g", dimension_ordinate->horiz_dir, horiz_dir); error++;
      }
    dimension_ordinate->horiz_dir--;

  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_ordinate->ins_rotation)
      pass ("DIMENSION_ORDINATE.ins_rotation [BD] %g", ins_rotation);
    else
      {
        fail ("DIMENSION_ORDINATE.ins_rotation [BD] %g != %g", dimension_ordinate->ins_rotation, ins_rotation); error++;
      }
    ins_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "ins_rotation", &ins_rotation) &&
        ins_rotation == dimension_ordinate->ins_rotation)
      pass ("DIMENSION_ORDINATE.ins_rotation [BD] set+1 %g", ins_rotation);
    else
      {
        fail ("DIMENSION_ORDINATE.ins_rotation [BD] set+1 %g != %g", dimension_ordinate->ins_rotation, ins_rotation); error++;
      }
    dimension_ordinate->ins_rotation--;

  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_ordinate->ins_scale, sizeof(dimension_ordinate->ins_scale)))
      pass ("DIMENSION_ORDINATE.ins_scale [3BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.ins_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD leader_endpt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "leader_endpt", &leader_endpt, NULL)
        && !memcmp(&leader_endpt, &dimension_ordinate->leader_endpt, sizeof(dimension_ordinate->leader_endpt)))
      pass ("DIMENSION_ORDINATE.leader_endpt [3BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.leader_endpt [3BD]"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_ordinate->lspace_factor)
      pass ("DIMENSION_ORDINATE.lspace_factor [BD] %g", lspace_factor);
    else
      {
        fail ("DIMENSION_ORDINATE.lspace_factor [BD] %g != %g", dimension_ordinate->lspace_factor, lspace_factor); error++;
      }
    lspace_factor++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "lspace_factor", &lspace_factor) &&
        lspace_factor == dimension_ordinate->lspace_factor)
      pass ("DIMENSION_ORDINATE.lspace_factor [BD] set+1 %g", lspace_factor);
    else
      {
        fail ("DIMENSION_ORDINATE.lspace_factor [BD] set+1 %g != %g", dimension_ordinate->lspace_factor, lspace_factor); error++;
      }
    dimension_ordinate->lspace_factor--;

  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_ordinate->lspace_style)
      pass ("DIMENSION_ORDINATE.lspace_style [BS] %hu", lspace_style);
    else
      {
        fail ("DIMENSION_ORDINATE.lspace_style [BS] %hu != %hu", dimension_ordinate->lspace_style, lspace_style); error++;
      }
    lspace_style++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "lspace_style", &lspace_style) &&
        lspace_style == dimension_ordinate->lspace_style)
      pass ("DIMENSION_ORDINATE.lspace_style [BS] set+1 %hu", lspace_style);
    else
      {
        fail ("DIMENSION_ORDINATE.lspace_style [BS] set+1 %hu != %hu", dimension_ordinate->lspace_style, lspace_style); error++;
      }
    dimension_ordinate->lspace_style--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_ordinate->parent, sizeof(dimension_ordinate->parent)))
      pass ("DIMENSION_ORDINATE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("DIMENSION_ORDINATE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_ordinate->text_midpt, sizeof(dimension_ordinate->text_midpt)))
      pass ("DIMENSION_ORDINATE.text_midpt [2RD]");
    else
      {
        fail ("DIMENSION_ORDINATE.text_midpt [2RD]"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_ordinate->text_rotation)
      pass ("DIMENSION_ORDINATE.text_rotation [BD] %g", text_rotation);
    else
      {
        fail ("DIMENSION_ORDINATE.text_rotation [BD] %g != %g", dimension_ordinate->text_rotation, text_rotation); error++;
      }
    text_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "text_rotation", &text_rotation) &&
        text_rotation == dimension_ordinate->text_rotation)
      pass ("DIMENSION_ORDINATE.text_rotation [BD] set+1 %g", text_rotation);
    else
      {
        fail ("DIMENSION_ORDINATE.text_rotation [BD] set+1 %g != %g", dimension_ordinate->text_rotation, text_rotation); error++;
      }
    dimension_ordinate->text_rotation--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "unknown", &unknown, NULL) &&
        unknown == dimension_ordinate->unknown)
      pass ("DIMENSION_ORDINATE.unknown [RC] %u", unknown);
    else
      {
        fail ("DIMENSION_ORDINATE.unknown [RC] %u != %u", dimension_ordinate->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(dimension_ordinate, "DIMENSION_ORDINATE", "unknown", &unknown) &&
        unknown == dimension_ordinate->unknown)
      pass ("DIMENSION_ORDINATE.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("DIMENSION_ORDINATE.unknown [RC] set+1 %u != %u", dimension_ordinate->unknown, unknown); error++;
      }
    dimension_ordinate->unknown--;

  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_ordinate->user_text))
      pass ("DIMENSION_ORDINATE.user_text [TV]");
    else
      {
        fail ("DIMENSION_ORDINATE.user_text [TV]"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_RADIUS (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_RADIUS *dimension_radius = obj->tio.entity->tio.DIMENSION_RADIUS;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_radius->act_measurement)
      pass ("DIMENSION_RADIUS.act_measurement [BD] %g", act_measurement);
    else
      {
        fail ("DIMENSION_RADIUS.act_measurement [BD] %g != %g", dimension_radius->act_measurement, act_measurement); error++;
      }
    act_measurement++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "act_measurement", &act_measurement) &&
        act_measurement == dimension_radius->act_measurement)
      pass ("DIMENSION_RADIUS.act_measurement [BD] set+1 %g", act_measurement);
    else
      {
        fail ("DIMENSION_RADIUS.act_measurement [BD] set+1 %g != %g", dimension_radius->act_measurement, act_measurement); error++;
      }
    dimension_radius->act_measurement--;

  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "attachment", &attachment, NULL) &&
        attachment == dimension_radius->attachment)
      pass ("DIMENSION_RADIUS.attachment [BS] %hu", attachment);
    else
      {
        fail ("DIMENSION_RADIUS.attachment [BS] %hu != %hu", dimension_radius->attachment, attachment); error++;
      }
    attachment++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "attachment", &attachment) &&
        attachment == dimension_radius->attachment)
      pass ("DIMENSION_RADIUS.attachment [BS] set+1 %hu", attachment);
    else
      {
        fail ("DIMENSION_RADIUS.attachment [BS] set+1 %hu != %hu", dimension_radius->attachment, attachment); error++;
      }
    dimension_radius->attachment--;

  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "block", &block, NULL)
        && !memcmp(&block, &dimension_radius->block, sizeof(dimension_radius->block)))
      pass ("DIMENSION_RADIUS.block [H]");
    else
      {
        fail ("DIMENSION_RADIUS.block [H]"); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_radius->blockname))
      pass ("DIMENSION_RADIUS.blockname [TV]");
    else
      {
        fail ("DIMENSION_RADIUS.blockname [TV]"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "class_version", &class_version, NULL) &&
        class_version == dimension_radius->class_version)
      pass ("DIMENSION_RADIUS.class_version [RC] %u", class_version);
    else
      {
        fail ("DIMENSION_RADIUS.class_version [RC] %u != %u", dimension_radius->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "class_version", &class_version) &&
        class_version == dimension_radius->class_version)
      pass ("DIMENSION_RADIUS.class_version [RC] set+1 %u", class_version);
    else
      {
        fail ("DIMENSION_RADIUS.class_version [RC] set+1 %u != %u", dimension_radius->class_version, class_version); error++;
      }
    dimension_radius->class_version--;

  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_radius->clone_ins_pt, sizeof(dimension_radius->clone_ins_pt)))
      pass ("DIMENSION_RADIUS.clone_ins_pt [2RD]");
    else
      {
        fail ("DIMENSION_RADIUS.clone_ins_pt [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_radius->def_pt, sizeof(dimension_radius->def_pt)))
      pass ("DIMENSION_RADIUS.def_pt [3BD]");
    else
      {
        fail ("DIMENSION_RADIUS.def_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dimension_radius->dimstyle, sizeof(dimension_radius->dimstyle)))
      pass ("DIMENSION_RADIUS.dimstyle [H]");
    else
      {
        fail ("DIMENSION_RADIUS.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "elevation", &elevation, NULL) &&
        elevation == dimension_radius->elevation)
      pass ("DIMENSION_RADIUS.elevation [BD] %g", elevation);
    else
      {
        fail ("DIMENSION_RADIUS.elevation [BD] %g != %g", dimension_radius->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "elevation", &elevation) &&
        elevation == dimension_radius->elevation)
      pass ("DIMENSION_RADIUS.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("DIMENSION_RADIUS.elevation [BD] set+1 %g != %g", dimension_radius->elevation, elevation); error++;
      }
    dimension_radius->elevation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_radius->extrusion, sizeof(dimension_radius->extrusion)))
      pass ("DIMENSION_RADIUS.extrusion [3BD]");
    else
      {
        fail ("DIMENSION_RADIUS.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp(&first_arc_pt, &dimension_radius->first_arc_pt, sizeof(dimension_radius->first_arc_pt)))
      pass ("DIMENSION_RADIUS.first_arc_pt [3BD]");
    else
      {
        fail ("DIMENSION_RADIUS.first_arc_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "flag", &flag, NULL) &&
        flag == dimension_radius->flag)
      pass ("DIMENSION_RADIUS.flag [RC] %u", flag);
    else
      {
        fail ("DIMENSION_RADIUS.flag [RC] %u != %u", dimension_radius->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "flag", &flag) &&
        flag == dimension_radius->flag)
      pass ("DIMENSION_RADIUS.flag [RC] set+1 %u", flag);
    else
      {
        fail ("DIMENSION_RADIUS.flag [RC] set+1 %u != %u", dimension_radius->flag, flag); error++;
      }
    dimension_radius->flag--;

  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "flag1", &flag1, NULL) &&
        flag1 == dimension_radius->flag1)
      pass ("DIMENSION_RADIUS.flag1 [RC] %u", flag1);
    else
      {
        fail ("DIMENSION_RADIUS.flag1 [RC] %u != %u", dimension_radius->flag1, flag1); error++;
      }
    flag1++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "flag1", &flag1) &&
        flag1 == dimension_radius->flag1)
      pass ("DIMENSION_RADIUS.flag1 [RC] set+1 %u", flag1);
    else
      {
        fail ("DIMENSION_RADIUS.flag1 [RC] set+1 %u != %u", dimension_radius->flag1, flag1); error++;
      }
    dimension_radius->flag1--;

  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_radius->flip_arrow1)
      pass ("DIMENSION_RADIUS.flip_arrow1 [RC] %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_RADIUS.flip_arrow1 [RC] %u != %u", dimension_radius->flip_arrow1, flip_arrow1); error++;
      }
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "flip_arrow1", &flip_arrow1) &&
        flip_arrow1 == dimension_radius->flip_arrow1)
      pass ("DIMENSION_RADIUS.flip_arrow1 [RC] set+1 %u", flip_arrow1);
    else
      {
        fail ("DIMENSION_RADIUS.flip_arrow1 [RC] set+1 %u != %u", dimension_radius->flip_arrow1, flip_arrow1); error++;
      }
    dimension_radius->flip_arrow1--;

  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_radius->flip_arrow2)
      pass ("DIMENSION_RADIUS.flip_arrow2 [RC] %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_RADIUS.flip_arrow2 [RC] %u != %u", dimension_radius->flip_arrow2, flip_arrow2); error++;
      }
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "flip_arrow2", &flip_arrow2) &&
        flip_arrow2 == dimension_radius->flip_arrow2)
      pass ("DIMENSION_RADIUS.flip_arrow2 [RC] set+1 %u", flip_arrow2);
    else
      {
        fail ("DIMENSION_RADIUS.flip_arrow2 [RC] set+1 %u != %u", dimension_radius->flip_arrow2, flip_arrow2); error++;
      }
    dimension_radius->flip_arrow2--;

  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_radius->horiz_dir)
      pass ("DIMENSION_RADIUS.horiz_dir [BD] %g", horiz_dir);
    else
      {
        fail ("DIMENSION_RADIUS.horiz_dir [BD] %g != %g", dimension_radius->horiz_dir, horiz_dir); error++;
      }
    horiz_dir++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "horiz_dir", &horiz_dir) &&
        horiz_dir == dimension_radius->horiz_dir)
      pass ("DIMENSION_RADIUS.horiz_dir [BD] set+1 %g", horiz_dir);
    else
      {
        fail ("DIMENSION_RADIUS.horiz_dir [BD] set+1 %g != %g", dimension_radius->horiz_dir, horiz_dir); error++;
      }
    dimension_radius->horiz_dir--;

  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_radius->ins_rotation)
      pass ("DIMENSION_RADIUS.ins_rotation [BD] %g", ins_rotation);
    else
      {
        fail ("DIMENSION_RADIUS.ins_rotation [BD] %g != %g", dimension_radius->ins_rotation, ins_rotation); error++;
      }
    ins_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "ins_rotation", &ins_rotation) &&
        ins_rotation == dimension_radius->ins_rotation)
      pass ("DIMENSION_RADIUS.ins_rotation [BD] set+1 %g", ins_rotation);
    else
      {
        fail ("DIMENSION_RADIUS.ins_rotation [BD] set+1 %g != %g", dimension_radius->ins_rotation, ins_rotation); error++;
      }
    dimension_radius->ins_rotation--;

  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_radius->ins_scale, sizeof(dimension_radius->ins_scale)))
      pass ("DIMENSION_RADIUS.ins_scale [3BD]");
    else
      {
        fail ("DIMENSION_RADIUS.ins_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "leader_len", &leader_len, NULL) &&
        leader_len == dimension_radius->leader_len)
      pass ("DIMENSION_RADIUS.leader_len [BD] %g", leader_len);
    else
      {
        fail ("DIMENSION_RADIUS.leader_len [BD] %g != %g", dimension_radius->leader_len, leader_len); error++;
      }
    leader_len++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "leader_len", &leader_len) &&
        leader_len == dimension_radius->leader_len)
      pass ("DIMENSION_RADIUS.leader_len [BD] set+1 %g", leader_len);
    else
      {
        fail ("DIMENSION_RADIUS.leader_len [BD] set+1 %g != %g", dimension_radius->leader_len, leader_len); error++;
      }
    dimension_radius->leader_len--;

  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_radius->lspace_factor)
      pass ("DIMENSION_RADIUS.lspace_factor [BD] %g", lspace_factor);
    else
      {
        fail ("DIMENSION_RADIUS.lspace_factor [BD] %g != %g", dimension_radius->lspace_factor, lspace_factor); error++;
      }
    lspace_factor++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "lspace_factor", &lspace_factor) &&
        lspace_factor == dimension_radius->lspace_factor)
      pass ("DIMENSION_RADIUS.lspace_factor [BD] set+1 %g", lspace_factor);
    else
      {
        fail ("DIMENSION_RADIUS.lspace_factor [BD] set+1 %g != %g", dimension_radius->lspace_factor, lspace_factor); error++;
      }
    dimension_radius->lspace_factor--;

  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_radius->lspace_style)
      pass ("DIMENSION_RADIUS.lspace_style [BS] %hu", lspace_style);
    else
      {
        fail ("DIMENSION_RADIUS.lspace_style [BS] %hu != %hu", dimension_radius->lspace_style, lspace_style); error++;
      }
    lspace_style++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "lspace_style", &lspace_style) &&
        lspace_style == dimension_radius->lspace_style)
      pass ("DIMENSION_RADIUS.lspace_style [BS] set+1 %hu", lspace_style);
    else
      {
        fail ("DIMENSION_RADIUS.lspace_style [BS] set+1 %hu != %hu", dimension_radius->lspace_style, lspace_style); error++;
      }
    dimension_radius->lspace_style--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_radius->parent, sizeof(dimension_radius->parent)))
      pass ("DIMENSION_RADIUS.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("DIMENSION_RADIUS.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_radius->text_midpt, sizeof(dimension_radius->text_midpt)))
      pass ("DIMENSION_RADIUS.text_midpt [2RD]");
    else
      {
        fail ("DIMENSION_RADIUS.text_midpt [2RD]"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_radius->text_rotation)
      pass ("DIMENSION_RADIUS.text_rotation [BD] %g", text_rotation);
    else
      {
        fail ("DIMENSION_RADIUS.text_rotation [BD] %g != %g", dimension_radius->text_rotation, text_rotation); error++;
      }
    text_rotation++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "text_rotation", &text_rotation) &&
        text_rotation == dimension_radius->text_rotation)
      pass ("DIMENSION_RADIUS.text_rotation [BD] set+1 %g", text_rotation);
    else
      {
        fail ("DIMENSION_RADIUS.text_rotation [BD] set+1 %g != %g", dimension_radius->text_rotation, text_rotation); error++;
      }
    dimension_radius->text_rotation--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "unknown", &unknown, NULL) &&
        unknown == dimension_radius->unknown)
      pass ("DIMENSION_RADIUS.unknown [RC] %u", unknown);
    else
      {
        fail ("DIMENSION_RADIUS.unknown [RC] %u != %u", dimension_radius->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(dimension_radius, "DIMENSION_RADIUS", "unknown", &unknown) &&
        unknown == dimension_radius->unknown)
      pass ("DIMENSION_RADIUS.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("DIMENSION_RADIUS.unknown [RC] set+1 %u != %u", dimension_radius->unknown, unknown); error++;
      }
    dimension_radius->unknown--;

  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_radius->user_text))
      pass ("DIMENSION_RADIUS.user_text [TV]");
    else
      {
        fail ("DIMENSION_RADIUS.user_text [TV]"); error++;
      }
  }
  return error;
}
static int test_ELLIPSE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ELLIPSE *ellipse = obj->tio.entity->tio.ELLIPSE;
  {
    BITCODE_BD axis_ratio;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "axis_ratio", &axis_ratio, NULL) &&
        axis_ratio == ellipse->axis_ratio)
      pass ("ELLIPSE.axis_ratio [BD] %g", axis_ratio);
    else
      {
        fail ("ELLIPSE.axis_ratio [BD] %g != %g", ellipse->axis_ratio, axis_ratio); error++;
      }
    axis_ratio++;
    if (dwg_dynapi_entity_set_value(ellipse, "ELLIPSE", "axis_ratio", &axis_ratio) &&
        axis_ratio == ellipse->axis_ratio)
      pass ("ELLIPSE.axis_ratio [BD] set+1 %g", axis_ratio);
    else
      {
        fail ("ELLIPSE.axis_ratio [BD] set+1 %g != %g", ellipse->axis_ratio, axis_ratio); error++;
      }
    ellipse->axis_ratio--;

  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "center", &center, NULL)
        && !memcmp(&center, &ellipse->center, sizeof(ellipse->center)))
      pass ("ELLIPSE.center [3BD]");
    else
      {
        fail ("ELLIPSE.center [3BD]"); error++;
      }
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "end_angle", &end_angle, NULL) &&
        end_angle == ellipse->end_angle)
      pass ("ELLIPSE.end_angle [BD] %g", end_angle);
    else
      {
        fail ("ELLIPSE.end_angle [BD] %g != %g", ellipse->end_angle, end_angle); error++;
      }
    end_angle++;
    if (dwg_dynapi_entity_set_value(ellipse, "ELLIPSE", "end_angle", &end_angle) &&
        end_angle == ellipse->end_angle)
      pass ("ELLIPSE.end_angle [BD] set+1 %g", end_angle);
    else
      {
        fail ("ELLIPSE.end_angle [BD] set+1 %g != %g", ellipse->end_angle, end_angle); error++;
      }
    ellipse->end_angle--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &ellipse->extrusion, sizeof(ellipse->extrusion)))
      pass ("ELLIPSE.extrusion [3BD]");
    else
      {
        fail ("ELLIPSE.extrusion [3BD]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "parent", &parent, NULL)
        && !memcmp(&parent, &ellipse->parent, sizeof(ellipse->parent)))
      pass ("ELLIPSE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("ELLIPSE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD sm_axis;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "sm_axis", &sm_axis, NULL)
        && !memcmp(&sm_axis, &ellipse->sm_axis, sizeof(ellipse->sm_axis)))
      pass ("ELLIPSE.sm_axis [3BD]");
    else
      {
        fail ("ELLIPSE.sm_axis [3BD]"); error++;
      }
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "start_angle", &start_angle, NULL) &&
        start_angle == ellipse->start_angle)
      pass ("ELLIPSE.start_angle [BD] %g", start_angle);
    else
      {
        fail ("ELLIPSE.start_angle [BD] %g != %g", ellipse->start_angle, start_angle); error++;
      }
    start_angle++;
    if (dwg_dynapi_entity_set_value(ellipse, "ELLIPSE", "start_angle", &start_angle) &&
        start_angle == ellipse->start_angle)
      pass ("ELLIPSE.start_angle [BD] set+1 %g", start_angle);
    else
      {
        fail ("ELLIPSE.start_angle [BD] set+1 %g != %g", ellipse->start_angle, start_angle); error++;
      }
    ellipse->start_angle--;

  }
  return error;
}
static int test_ENDBLK (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ENDBLK *endblk = obj->tio.entity->tio.ENDBLK;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(endblk, "ENDBLK", "parent", &parent, NULL)
        && !memcmp(&parent, &endblk->parent, sizeof(endblk->parent)))
      pass ("ENDBLK.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("ENDBLK.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  return error;
}
static int test_EXTRUDEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_EXTRUDEDSURFACE *extrudedsurface = obj->tio.entity->tio.EXTRUDEDSURFACE;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&extrudedsurface->acis_data))
      pass ("EXTRUDEDSURFACE.acis_data [RC*]");
    else
      {
        fail ("EXTRUDEDSURFACE.acis_data [RC*]"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == extrudedsurface->acis_empty)
      pass ("EXTRUDEDSURFACE.acis_empty [RC] %u", acis_empty);
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty [RC] %u != %u", extrudedsurface->acis_empty, acis_empty); error++;
      }
    acis_empty++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty) &&
        acis_empty == extrudedsurface->acis_empty)
      pass ("EXTRUDEDSURFACE.acis_empty [RC] set+1 %u", acis_empty);
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty [RC] set+1 %u != %u", extrudedsurface->acis_empty, acis_empty); error++;
      }
    extrudedsurface->acis_empty--;

  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == extrudedsurface->acis_empty2)
      pass ("EXTRUDEDSURFACE.acis_empty2 [RC] %u", acis_empty2);
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty2 [RC] %u != %u", extrudedsurface->acis_empty2, acis_empty2); error++;
      }
    acis_empty2++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2) &&
        acis_empty2 == extrudedsurface->acis_empty2)
      pass ("EXTRUDEDSURFACE.acis_empty2 [RC] set+1 %u", acis_empty2);
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty2 [RC] set+1 %u != %u", extrudedsurface->acis_empty2, acis_empty2); error++;
      }
    extrudedsurface->acis_empty2--;

  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == extrudedsurface->acis_empty_bit)
      pass ("EXTRUDEDSURFACE.acis_empty_bit [RC] %u", acis_empty_bit);
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty_bit [RC] %u != %u", extrudedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit) &&
        acis_empty_bit == extrudedsurface->acis_empty_bit)
      pass ("EXTRUDEDSURFACE.acis_empty_bit [RC] set+1 %u", acis_empty_bit);
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty_bit [RC] set+1 %u != %u", extrudedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
    extrudedsurface->acis_empty_bit--;

  }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle, NULL) &&
        align_angle == extrudedsurface->align_angle)
      pass ("EXTRUDEDSURFACE.align_angle [BD] %g", align_angle);
    else
      {
        fail ("EXTRUDEDSURFACE.align_angle [BD] %g != %g", extrudedsurface->align_angle, align_angle); error++;
      }
    align_angle++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle) &&
        align_angle == extrudedsurface->align_angle)
      pass ("EXTRUDEDSURFACE.align_angle [BD] set+1 %g", align_angle);
    else
      {
        fail ("EXTRUDEDSURFACE.align_angle [BD] set+1 %g != %g", extrudedsurface->align_angle, align_angle); error++;
      }
    extrudedsurface->align_angle--;

  }
  {
    BITCODE_B align_start;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start, NULL) &&
        align_start == extrudedsurface->align_start)
      pass ("EXTRUDEDSURFACE.align_start [B] " FORMAT_B "", align_start);
    else
      {
        fail ("EXTRUDEDSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start); error++;
      }
    align_start++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start) &&
        align_start == extrudedsurface->align_start)
      pass ("EXTRUDEDSURFACE.align_start [B] set+1 " FORMAT_B "", align_start);
    else
      {
        fail ("EXTRUDEDSURFACE.align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start); error++;
      }
    extrudedsurface->align_start--;

  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank, NULL) &&
        bank == extrudedsurface->bank)
      pass ("EXTRUDEDSURFACE.bank [B] " FORMAT_B "", bank);
    else
      {
        fail ("EXTRUDEDSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank); error++;
      }
    bank++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank) &&
        bank == extrudedsurface->bank)
      pass ("EXTRUDEDSURFACE.bank [B] set+1 " FORMAT_B "", bank);
    else
      {
        fail ("EXTRUDEDSURFACE.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank); error++;
      }
    extrudedsurface->bank--;

  }
  {
    BITCODE_B base_point_set;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set, NULL) &&
        base_point_set == extrudedsurface->base_point_set)
      pass ("EXTRUDEDSURFACE.base_point_set [B] " FORMAT_B "", base_point_set);
    else
      {
        fail ("EXTRUDEDSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set); error++;
      }
    base_point_set++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set) &&
        base_point_set == extrudedsurface->base_point_set)
      pass ("EXTRUDEDSURFACE.base_point_set [B] set+1 " FORMAT_B "", base_point_set);
    else
      {
        fail ("EXTRUDEDSURFACE.base_point_set [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set); error++;
      }
    extrudedsurface->base_point_set--;

  }
  {
    BITCODE_TF bindata;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "bindata", &bindata, NULL)
        && !memcmp(&bindata, &extrudedsurface->bindata, sizeof(extrudedsurface->bindata)))
      pass ("EXTRUDEDSURFACE.bindata [TF]");
    else
      {
        fail ("EXTRUDEDSURFACE.bindata [TF]"); error++;
      }
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &extrudedsurface->block_size, sizeof(extrudedsurface->block_size)))
      pass ("EXTRUDEDSURFACE.block_size [BL*]");
    else
      {
        fail ("EXTRUDEDSURFACE.block_size [BL*]"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version, NULL) &&
        class_version == extrudedsurface->class_version)
      pass ("EXTRUDEDSURFACE.class_version [BL] %u", class_version);
    else
      {
        fail ("EXTRUDEDSURFACE.class_version [BL] %u != %u", extrudedsurface->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version) &&
        class_version == extrudedsurface->class_version)
      pass ("EXTRUDEDSURFACE.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("EXTRUDEDSURFACE.class_version [BL] set+1 %u != %u", extrudedsurface->class_version, class_version); error++;
      }
    extrudedsurface->class_version--;

  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle, NULL) &&
        draft_angle == extrudedsurface->draft_angle)
      pass ("EXTRUDEDSURFACE.draft_angle [BD] %g", draft_angle);
    else
      {
        fail ("EXTRUDEDSURFACE.draft_angle [BD] %g != %g", extrudedsurface->draft_angle, draft_angle); error++;
      }
    draft_angle++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle) &&
        draft_angle == extrudedsurface->draft_angle)
      pass ("EXTRUDEDSURFACE.draft_angle [BD] set+1 %g", draft_angle);
    else
      {
        fail ("EXTRUDEDSURFACE.draft_angle [BD] set+1 %g != %g", extrudedsurface->draft_angle, draft_angle); error++;
      }
    extrudedsurface->draft_angle--;

  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance, NULL) &&
        draft_end_distance == extrudedsurface->draft_end_distance)
      pass ("EXTRUDEDSURFACE.draft_end_distance [BD] %g", draft_end_distance);
    else
      {
        fail ("EXTRUDEDSURFACE.draft_end_distance [BD] %g != %g", extrudedsurface->draft_end_distance, draft_end_distance); error++;
      }
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance) &&
        draft_end_distance == extrudedsurface->draft_end_distance)
      pass ("EXTRUDEDSURFACE.draft_end_distance [BD] set+1 %g", draft_end_distance);
    else
      {
        fail ("EXTRUDEDSURFACE.draft_end_distance [BD] set+1 %g != %g", extrudedsurface->draft_end_distance, draft_end_distance); error++;
      }
    extrudedsurface->draft_end_distance--;

  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance, NULL) &&
        draft_start_distance == extrudedsurface->draft_start_distance)
      pass ("EXTRUDEDSURFACE.draft_start_distance [BD] %g", draft_start_distance);
    else
      {
        fail ("EXTRUDEDSURFACE.draft_start_distance [BD] %g != %g", extrudedsurface->draft_start_distance, draft_start_distance); error++;
      }
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance) &&
        draft_start_distance == extrudedsurface->draft_start_distance)
      pass ("EXTRUDEDSURFACE.draft_start_distance [BD] set+1 %g", draft_start_distance);
    else
      {
        fail ("EXTRUDEDSURFACE.draft_start_distance [BD] set+1 %g != %g", extrudedsurface->draft_start_distance, draft_start_distance); error++;
      }
    extrudedsurface->draft_start_distance--;

  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&extrudedsurface->encr_sat_data))
      pass ("EXTRUDEDSURFACE.encr_sat_data [TV]");
    else
      {
        fail ("EXTRUDEDSURFACE.encr_sat_data [TV]"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &extrudedsurface->extra_acis_data, sizeof(extrudedsurface->extra_acis_data)))
      pass ("EXTRUDEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
    else
      {
        fail ("EXTRUDEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]"); error++;
      }
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "height", &height, NULL) &&
        height == extrudedsurface->height)
      pass ("EXTRUDEDSURFACE.height [BD] %g", height);
    else
      {
        fail ("EXTRUDEDSURFACE.height [BD] %g != %g", extrudedsurface->height, height); error++;
      }
    height++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "height", &height) &&
        height == extrudedsurface->height)
      pass ("EXTRUDEDSURFACE.height [BD] set+1 %g", height);
    else
      {
        fail ("EXTRUDEDSURFACE.height [BD] set+1 %g != %g", extrudedsurface->height, height); error++;
      }
    extrudedsurface->height--;

  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &extrudedsurface->history_id, sizeof(extrudedsurface->history_id)))
      pass ("EXTRUDEDSURFACE.history_id [H]");
    else
      {
        fail ("EXTRUDEDSURFACE.history_id [H]"); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == extrudedsurface->isoline_present)
      pass ("EXTRUDEDSURFACE.isoline_present [RC] %u", isoline_present);
    else
      {
        fail ("EXTRUDEDSURFACE.isoline_present [RC] %u != %u", extrudedsurface->isoline_present, isoline_present); error++;
      }
    isoline_present++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present) &&
        isoline_present == extrudedsurface->isoline_present)
      pass ("EXTRUDEDSURFACE.isoline_present [RC] set+1 %u", isoline_present);
    else
      {
        fail ("EXTRUDEDSURFACE.isoline_present [RC] set+1 %u != %u", extrudedsurface->isoline_present, isoline_present); error++;
      }
    extrudedsurface->isoline_present--;

  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == extrudedsurface->modeler_format_version)
      pass ("EXTRUDEDSURFACE.modeler_format_version [BS] %hu", modeler_format_version);
    else
      {
        fail ("EXTRUDEDSURFACE.modeler_format_version [BS] %hu != %hu", extrudedsurface->modeler_format_version, modeler_format_version); error++;
      }
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version) &&
        modeler_format_version == extrudedsurface->modeler_format_version)
      pass ("EXTRUDEDSURFACE.modeler_format_version [BS] set+1 %hu", modeler_format_version);
    else
      {
        fail ("EXTRUDEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", extrudedsurface->modeler_format_version, modeler_format_version); error++;
      }
    extrudedsurface->modeler_format_version--;

  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == extrudedsurface->num_blocks)
      pass ("EXTRUDEDSURFACE.num_blocks [BL] %u", num_blocks);
    else
      {
        fail ("EXTRUDEDSURFACE.num_blocks [BL] %u != %u", extrudedsurface->num_blocks, num_blocks); error++;
      }
    num_blocks++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks) &&
        num_blocks == extrudedsurface->num_blocks)
      pass ("EXTRUDEDSURFACE.num_blocks [BL] set+1 %u", num_blocks);
    else
      {
        fail ("EXTRUDEDSURFACE.num_blocks [BL] set+1 %u != %u", extrudedsurface->num_blocks, num_blocks); error++;
      }
    extrudedsurface->num_blocks--;

  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == extrudedsurface->num_isolines)
      pass ("EXTRUDEDSURFACE.num_isolines [BL] %u", num_isolines);
    else
      {
        fail ("EXTRUDEDSURFACE.num_isolines [BL] %u != %u", extrudedsurface->num_isolines, num_isolines); error++;
      }
    num_isolines++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "num_isolines", &num_isolines) &&
        num_isolines == extrudedsurface->num_isolines)
      pass ("EXTRUDEDSURFACE.num_isolines [BL] set+1 %u", num_isolines);
    else
      {
        fail ("EXTRUDEDSURFACE.num_isolines [BL] set+1 %u != %u", extrudedsurface->num_isolines, num_isolines); error++;
      }
    extrudedsurface->num_isolines--;

  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == extrudedsurface->num_silhouettes)
      pass ("EXTRUDEDSURFACE.num_silhouettes [BL] %u", num_silhouettes);
    else
      {
        fail ("EXTRUDEDSURFACE.num_silhouettes [BL] %u != %u", extrudedsurface->num_silhouettes, num_silhouettes); error++;
      }
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes) &&
        num_silhouettes == extrudedsurface->num_silhouettes)
      pass ("EXTRUDEDSURFACE.num_silhouettes [BL] set+1 %u", num_silhouettes);
    else
      {
        fail ("EXTRUDEDSURFACE.num_silhouettes [BL] set+1 %u != %u", extrudedsurface->num_silhouettes, num_silhouettes); error++;
      }
    extrudedsurface->num_silhouettes--;

  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == extrudedsurface->num_wires)
      pass ("EXTRUDEDSURFACE.num_wires [BL] %u", num_wires);
    else
      {
        fail ("EXTRUDEDSURFACE.num_wires [BL] %u != %u", extrudedsurface->num_wires, num_wires); error++;
      }
    num_wires++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires) &&
        num_wires == extrudedsurface->num_wires)
      pass ("EXTRUDEDSURFACE.num_wires [BL] set+1 %u", num_wires);
    else
      {
        fail ("EXTRUDEDSURFACE.num_wires [BL] set+1 %u != %u", extrudedsurface->num_wires, num_wires); error++;
      }
    extrudedsurface->num_wires--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &extrudedsurface->parent, sizeof(extrudedsurface->parent)))
      pass ("EXTRUDEDSURFACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("EXTRUDEDSURFACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_H path_entity;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "path_entity", &path_entity, NULL)
        && !memcmp(&path_entity, &extrudedsurface->path_entity, sizeof(extrudedsurface->path_entity)))
      pass ("EXTRUDEDSURFACE.path_entity [H]");
    else
      {
        fail ("EXTRUDEDSURFACE.path_entity [H]"); error++;
      }
  }
  {
    BITCODE_B path_entity_transform_computed;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL) &&
        path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
      pass ("EXTRUDEDSURFACE.path_entity_transform_computed [B] " FORMAT_B "", path_entity_transform_computed);
    else
      {
        fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed); error++;
      }
    path_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed) &&
        path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
      pass ("EXTRUDEDSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B "", path_entity_transform_computed);
    else
      {
        fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed); error++;
      }
    extrudedsurface->path_entity_transform_computed--;

  }
  {
    BITCODE_BD* path_entity_transmatrix;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
        && !memcmp(&path_entity_transmatrix, &extrudedsurface->path_entity_transmatrix, sizeof(extrudedsurface->path_entity_transmatrix)))
      pass ("EXTRUDEDSURFACE.path_entity_transmatrix [BD*]");
    else
      {
        fail ("EXTRUDEDSURFACE.path_entity_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "point", &point, NULL)
        && !memcmp(&point, &extrudedsurface->point, sizeof(extrudedsurface->point)))
      pass ("EXTRUDEDSURFACE.point [3BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.point [3BD]"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present, NULL) &&
        point_present == extrudedsurface->point_present)
      pass ("EXTRUDEDSURFACE.point_present [RC] %u", point_present);
    else
      {
        fail ("EXTRUDEDSURFACE.point_present [RC] %u != %u", extrudedsurface->point_present, point_present); error++;
      }
    point_present++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present) &&
        point_present == extrudedsurface->point_present)
      pass ("EXTRUDEDSURFACE.point_present [RC] set+1 %u", point_present);
    else
      {
        fail ("EXTRUDEDSURFACE.point_present [RC] set+1 %u != %u", extrudedsurface->point_present, point_present); error++;
      }
    extrudedsurface->point_present--;

  }
  {
    BITCODE_3BD reference_vector_for_controlling_twist;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
        && !memcmp(&reference_vector_for_controlling_twist, &extrudedsurface->reference_vector_for_controlling_twist, sizeof(extrudedsurface->reference_vector_for_controlling_twist)))
      pass ("EXTRUDEDSURFACE.reference_vector_for_controlling_twist [3BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.reference_vector_for_controlling_twist [3BD]"); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor, NULL) &&
        scale_factor == extrudedsurface->scale_factor)
      pass ("EXTRUDEDSURFACE.scale_factor [BD] %g", scale_factor);
    else
      {
        fail ("EXTRUDEDSURFACE.scale_factor [BD] %g != %g", extrudedsurface->scale_factor, scale_factor); error++;
      }
    scale_factor++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor) &&
        scale_factor == extrudedsurface->scale_factor)
      pass ("EXTRUDEDSURFACE.scale_factor [BD] set+1 %g", scale_factor);
    else
      {
        fail ("EXTRUDEDSURFACE.scale_factor [BD] set+1 %g != %g", extrudedsurface->scale_factor, scale_factor); error++;
      }
    extrudedsurface->scale_factor--;

  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &extrudedsurface->silhouettes, sizeof(extrudedsurface->silhouettes)))
      pass ("EXTRUDEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*]");
    else
      {
        fail ("EXTRUDEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*]"); error++;
      }
  }
  {
    BITCODE_BL size_bindata;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "size_bindata", &size_bindata, NULL) &&
        size_bindata == extrudedsurface->size_bindata)
      pass ("EXTRUDEDSURFACE.size_bindata [BL] %u", size_bindata);
    else
      {
        fail ("EXTRUDEDSURFACE.size_bindata [BL] %u != %u", extrudedsurface->size_bindata, size_bindata); error++;
      }
    size_bindata++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "size_bindata", &size_bindata) &&
        size_bindata == extrudedsurface->size_bindata)
      pass ("EXTRUDEDSURFACE.size_bindata [BL] set+1 %u", size_bindata);
    else
      {
        fail ("EXTRUDEDSURFACE.size_bindata [BL] set+1 %u != %u", extrudedsurface->size_bindata, size_bindata); error++;
      }
    extrudedsurface->size_bindata--;

  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "solid", &solid, NULL) &&
        solid == extrudedsurface->solid)
      pass ("EXTRUDEDSURFACE.solid [B] " FORMAT_B "", solid);
    else
      {
        fail ("EXTRUDEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->solid, solid); error++;
      }
    solid++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "solid", &solid) &&
        solid == extrudedsurface->solid)
      pass ("EXTRUDEDSURFACE.solid [B] set+1 " FORMAT_B "", solid);
    else
      {
        fail ("EXTRUDEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->solid, solid); error++;
      }
    extrudedsurface->solid--;

  }
  {
    BITCODE_BS sweep_alignment_flags;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, NULL) &&
        sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
      pass ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] %hu", sweep_alignment_flags);
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] %hu != %hu", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags); error++;
      }
    sweep_alignment_flags++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags) &&
        sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
      pass ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] set+1 %hu", sweep_alignment_flags);
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] set+1 %hu != %hu", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags); error++;
      }
    extrudedsurface->sweep_alignment_flags--;

  }
  {
    BITCODE_H sweep_entity;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity", &sweep_entity, NULL)
        && !memcmp(&sweep_entity, &extrudedsurface->sweep_entity, sizeof(extrudedsurface->sweep_entity)))
      pass ("EXTRUDEDSURFACE.sweep_entity [H]");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_entity [H]"); error++;
      }
  }
  {
    BITCODE_B sweep_entity_transform_computed;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL) &&
        sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
      pass ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] " FORMAT_B "", sweep_entity_transform_computed);
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed); error++;
      }
    sweep_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed) &&
        sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
      pass ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B "", sweep_entity_transform_computed);
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed); error++;
      }
    extrudedsurface->sweep_entity_transform_computed--;

  }
  {
    BITCODE_BD* sweep_entity_transmatrix;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
        && !memcmp(&sweep_entity_transmatrix, &extrudedsurface->sweep_entity_transmatrix, sizeof(extrudedsurface->sweep_entity_transmatrix)))
      pass ("EXTRUDEDSURFACE.sweep_entity_transmatrix [BD*]");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_entity_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BD* sweep_transmatrix;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_transmatrix", &sweep_transmatrix, NULL)
        && !memcmp(&sweep_transmatrix, &extrudedsurface->sweep_transmatrix, sizeof(extrudedsurface->sweep_transmatrix)))
      pass ("EXTRUDEDSURFACE.sweep_transmatrix [BD*]");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_3BD sweep_vector;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_vector", &sweep_vector, NULL)
        && !memcmp(&sweep_vector, &extrudedsurface->sweep_vector, sizeof(extrudedsurface->sweep_vector)))
      pass ("EXTRUDEDSURFACE.sweep_vector [3BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_vector [3BD]"); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle, NULL) &&
        twist_angle == extrudedsurface->twist_angle)
      pass ("EXTRUDEDSURFACE.twist_angle [BD] %g", twist_angle);
    else
      {
        fail ("EXTRUDEDSURFACE.twist_angle [BD] %g != %g", extrudedsurface->twist_angle, twist_angle); error++;
      }
    twist_angle++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle) &&
        twist_angle == extrudedsurface->twist_angle)
      pass ("EXTRUDEDSURFACE.twist_angle [BD] set+1 %g", twist_angle);
    else
      {
        fail ("EXTRUDEDSURFACE.twist_angle [BD] set+1 %g != %g", extrudedsurface->twist_angle, twist_angle); error++;
      }
    extrudedsurface->twist_angle--;

  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == extrudedsurface->u_isolines)
      pass ("EXTRUDEDSURFACE.u_isolines [BS] %hu", u_isolines);
    else
      {
        fail ("EXTRUDEDSURFACE.u_isolines [BS] %hu != %hu", extrudedsurface->u_isolines, u_isolines); error++;
      }
    u_isolines++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines) &&
        u_isolines == extrudedsurface->u_isolines)
      pass ("EXTRUDEDSURFACE.u_isolines [BS] set+1 %hu", u_isolines);
    else
      {
        fail ("EXTRUDEDSURFACE.u_isolines [BS] set+1 %hu != %hu", extrudedsurface->u_isolines, u_isolines); error++;
      }
    extrudedsurface->u_isolines--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown, NULL) &&
        unknown == extrudedsurface->unknown)
      pass ("EXTRUDEDSURFACE.unknown [RC] %u", unknown);
    else
      {
        fail ("EXTRUDEDSURFACE.unknown [RC] %u != %u", extrudedsurface->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown) &&
        unknown == extrudedsurface->unknown)
      pass ("EXTRUDEDSURFACE.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("EXTRUDEDSURFACE.unknown [RC] set+1 %u != %u", extrudedsurface->unknown, unknown); error++;
      }
    extrudedsurface->unknown--;

  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == extrudedsurface->unknown_2007)
      pass ("EXTRUDEDSURFACE.unknown_2007 [BL] %u", unknown_2007);
    else
      {
        fail ("EXTRUDEDSURFACE.unknown_2007 [BL] %u != %u", extrudedsurface->unknown_2007, unknown_2007); error++;
      }
    unknown_2007++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "unknown_2007", &unknown_2007) &&
        unknown_2007 == extrudedsurface->unknown_2007)
      pass ("EXTRUDEDSURFACE.unknown_2007 [BL] set+1 %u", unknown_2007);
    else
      {
        fail ("EXTRUDEDSURFACE.unknown_2007 [BL] set+1 %u != %u", extrudedsurface->unknown_2007, unknown_2007); error++;
      }
    extrudedsurface->unknown_2007--;

  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == extrudedsurface->v_isolines)
      pass ("EXTRUDEDSURFACE.v_isolines [BS] %hu", v_isolines);
    else
      {
        fail ("EXTRUDEDSURFACE.v_isolines [BS] %hu != %hu", extrudedsurface->v_isolines, v_isolines); error++;
      }
    v_isolines++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines) &&
        v_isolines == extrudedsurface->v_isolines)
      pass ("EXTRUDEDSURFACE.v_isolines [BS] set+1 %hu", v_isolines);
    else
      {
        fail ("EXTRUDEDSURFACE.v_isolines [BS] set+1 %hu != %hu", extrudedsurface->v_isolines, v_isolines); error++;
      }
    extrudedsurface->v_isolines--;

  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "version", &version, NULL) &&
        version == extrudedsurface->version)
      pass ("EXTRUDEDSURFACE.version [BS] %hu", version);
    else
      {
        fail ("EXTRUDEDSURFACE.version [BS] %hu != %hu", extrudedsurface->version, version); error++;
      }
    version++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "version", &version) &&
        version == extrudedsurface->version)
      pass ("EXTRUDEDSURFACE.version [BS] set+1 %hu", version);
    else
      {
        fail ("EXTRUDEDSURFACE.version [BS] set+1 %hu != %hu", extrudedsurface->version, version); error++;
      }
    extrudedsurface->version--;

  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == extrudedsurface->wireframe_data_present)
      pass ("EXTRUDEDSURFACE.wireframe_data_present [RC] %u", wireframe_data_present);
    else
      {
        fail ("EXTRUDEDSURFACE.wireframe_data_present [RC] %u != %u", extrudedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value(extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present) &&
        wireframe_data_present == extrudedsurface->wireframe_data_present)
      pass ("EXTRUDEDSURFACE.wireframe_data_present [RC] set+1 %u", wireframe_data_present);
    else
      {
        fail ("EXTRUDEDSURFACE.wireframe_data_present [RC] set+1 %u != %u", extrudedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
    extrudedsurface->wireframe_data_present--;

  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &extrudedsurface->wires, sizeof(extrudedsurface->wires)))
      pass ("EXTRUDEDSURFACE.wires [Dwg_3DSOLID_wire*]");
    else
      {
        fail ("EXTRUDEDSURFACE.wires [Dwg_3DSOLID_wire*]"); error++;
      }
  }
  return error;
}
static int test_GEOPOSITIONMARKER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_GEOPOSITIONMARKER *geopositionmarker = obj->tio.entity->tio.GEOPOSITIONMARKER;
  {
    BITCODE_B enable_frame_text;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "enable_frame_text", &enable_frame_text, NULL) &&
        enable_frame_text == geopositionmarker->enable_frame_text)
      pass ("GEOPOSITIONMARKER.enable_frame_text [B] " FORMAT_B "", enable_frame_text);
    else
      {
        fail ("GEOPOSITIONMARKER.enable_frame_text [B] " FORMAT_B " != " FORMAT_B "", geopositionmarker->enable_frame_text, enable_frame_text); error++;
      }
    enable_frame_text++;
    if (dwg_dynapi_entity_set_value(geopositionmarker, "GEOPOSITIONMARKER", "enable_frame_text", &enable_frame_text) &&
        enable_frame_text == geopositionmarker->enable_frame_text)
      pass ("GEOPOSITIONMARKER.enable_frame_text [B] set+1 " FORMAT_B "", enable_frame_text);
    else
      {
        fail ("GEOPOSITIONMARKER.enable_frame_text [B] set+1 " FORMAT_B " != " FORMAT_B "", geopositionmarker->enable_frame_text, enable_frame_text); error++;
      }
    geopositionmarker->enable_frame_text--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &geopositionmarker->extrusion, sizeof(geopositionmarker->extrusion)))
      pass ("GEOPOSITIONMARKER.extrusion [3BD]");
    else
      {
        fail ("GEOPOSITIONMARKER.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_BD landing_gap;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "landing_gap", &landing_gap, NULL) &&
        landing_gap == geopositionmarker->landing_gap)
      pass ("GEOPOSITIONMARKER.landing_gap [BD] %g", landing_gap);
    else
      {
        fail ("GEOPOSITIONMARKER.landing_gap [BD] %g != %g", geopositionmarker->landing_gap, landing_gap); error++;
      }
    landing_gap++;
    if (dwg_dynapi_entity_set_value(geopositionmarker, "GEOPOSITIONMARKER", "landing_gap", &landing_gap) &&
        landing_gap == geopositionmarker->landing_gap)
      pass ("GEOPOSITIONMARKER.landing_gap [BD] set+1 %g", landing_gap);
    else
      {
        fail ("GEOPOSITIONMARKER.landing_gap [BD] set+1 %g != %g", geopositionmarker->landing_gap, landing_gap); error++;
      }
    geopositionmarker->landing_gap--;

  }
  {
    BITCODE_H mtext_handle;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "mtext_handle", &mtext_handle, NULL)
        && !memcmp(&mtext_handle, &geopositionmarker->mtext_handle, sizeof(geopositionmarker->mtext_handle)))
      pass ("GEOPOSITIONMARKER.mtext_handle [H]");
    else
      {
        fail ("GEOPOSITIONMARKER.mtext_handle [H]"); error++;
      }
  }
  {
    BITCODE_B mtext_visible;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "mtext_visible", &mtext_visible, NULL) &&
        mtext_visible == geopositionmarker->mtext_visible)
      pass ("GEOPOSITIONMARKER.mtext_visible [B] " FORMAT_B "", mtext_visible);
    else
      {
        fail ("GEOPOSITIONMARKER.mtext_visible [B] " FORMAT_B " != " FORMAT_B "", geopositionmarker->mtext_visible, mtext_visible); error++;
      }
    mtext_visible++;
    if (dwg_dynapi_entity_set_value(geopositionmarker, "GEOPOSITIONMARKER", "mtext_visible", &mtext_visible) &&
        mtext_visible == geopositionmarker->mtext_visible)
      pass ("GEOPOSITIONMARKER.mtext_visible [B] set+1 " FORMAT_B "", mtext_visible);
    else
      {
        fail ("GEOPOSITIONMARKER.mtext_visible [B] set+1 " FORMAT_B " != " FORMAT_B "", geopositionmarker->mtext_visible, mtext_visible); error++;
      }
    geopositionmarker->mtext_visible--;

  }
  {
    BITCODE_T notes;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "notes", &notes, NULL)
        && !memcmp(&notes, &geopositionmarker->notes, sizeof(geopositionmarker->notes)))
      pass ("GEOPOSITIONMARKER.notes [T]");
    else
      {
        fail ("GEOPOSITIONMARKER.notes [T]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "parent", &parent, NULL)
        && !memcmp(&parent, &geopositionmarker->parent, sizeof(geopositionmarker->parent)))
      pass ("GEOPOSITIONMARKER.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("GEOPOSITIONMARKER.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD position;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "position", &position, NULL)
        && !memcmp(&position, &geopositionmarker->position, sizeof(geopositionmarker->position)))
      pass ("GEOPOSITIONMARKER.position [3BD]");
    else
      {
        fail ("GEOPOSITIONMARKER.position [3BD]"); error++;
      }
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "radius", &radius, NULL) &&
        radius == geopositionmarker->radius)
      pass ("GEOPOSITIONMARKER.radius [BD] %g", radius);
    else
      {
        fail ("GEOPOSITIONMARKER.radius [BD] %g != %g", geopositionmarker->radius, radius); error++;
      }
    radius++;
    if (dwg_dynapi_entity_set_value(geopositionmarker, "GEOPOSITIONMARKER", "radius", &radius) &&
        radius == geopositionmarker->radius)
      pass ("GEOPOSITIONMARKER.radius [BD] set+1 %g", radius);
    else
      {
        fail ("GEOPOSITIONMARKER.radius [BD] set+1 %g != %g", geopositionmarker->radius, radius); error++;
      }
    geopositionmarker->radius--;

  }
  {
    BITCODE_T text;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "text", &text, NULL)
        && !memcmp(&text, &geopositionmarker->text, sizeof(geopositionmarker->text)))
      pass ("GEOPOSITIONMARKER.text [T]");
    else
      {
        fail ("GEOPOSITIONMARKER.text [T]"); error++;
      }
  }
  {
    BITCODE_BS text_alignment;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "text_alignment", &text_alignment, NULL) &&
        text_alignment == geopositionmarker->text_alignment)
      pass ("GEOPOSITIONMARKER.text_alignment [BS] %hu", text_alignment);
    else
      {
        fail ("GEOPOSITIONMARKER.text_alignment [BS] %hu != %hu", geopositionmarker->text_alignment, text_alignment); error++;
      }
    text_alignment++;
    if (dwg_dynapi_entity_set_value(geopositionmarker, "GEOPOSITIONMARKER", "text_alignment", &text_alignment) &&
        text_alignment == geopositionmarker->text_alignment)
      pass ("GEOPOSITIONMARKER.text_alignment [BS] set+1 %hu", text_alignment);
    else
      {
        fail ("GEOPOSITIONMARKER.text_alignment [BS] set+1 %hu != %hu", geopositionmarker->text_alignment, text_alignment); error++;
      }
    geopositionmarker->text_alignment--;

  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "text_style", &text_style, NULL)
        && !memcmp(&text_style, &geopositionmarker->text_style, sizeof(geopositionmarker->text_style)))
      pass ("GEOPOSITIONMARKER.text_style [H]");
    else
      {
        fail ("GEOPOSITIONMARKER.text_style [H]"); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "type", &type, NULL) &&
        type == geopositionmarker->type)
      pass ("GEOPOSITIONMARKER.type [BS] %hu", type);
    else
      {
        fail ("GEOPOSITIONMARKER.type [BS] %hu != %hu", geopositionmarker->type, type); error++;
      }
    type++;
    if (dwg_dynapi_entity_set_value(geopositionmarker, "GEOPOSITIONMARKER", "type", &type) &&
        type == geopositionmarker->type)
      pass ("GEOPOSITIONMARKER.type [BS] set+1 %hu", type);
    else
      {
        fail ("GEOPOSITIONMARKER.type [BS] set+1 %hu != %hu", geopositionmarker->type, type); error++;
      }
    geopositionmarker->type--;

  }
  return error;
}
static int test_HATCH (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_HATCH *hatch = obj->tio.entity->tio.HATCH;
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "angle", &angle, NULL) &&
        angle == hatch->angle)
      pass ("HATCH.angle [BD] %g", angle);
    else
      {
        fail ("HATCH.angle [BD] %g != %g", hatch->angle, angle); error++;
      }
    angle++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "angle", &angle) &&
        angle == hatch->angle)
      pass ("HATCH.angle [BD] set+1 %g", angle);
    else
      {
        fail ("HATCH.angle [BD] set+1 %g != %g", hatch->angle, angle); error++;
      }
    hatch->angle--;

  }
  {
    BITCODE_B associative;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "associative", &associative, NULL) &&
        associative == hatch->associative)
      pass ("HATCH.associative [B] " FORMAT_B "", associative);
    else
      {
        fail ("HATCH.associative [B] " FORMAT_B " != " FORMAT_B "", hatch->associative, associative); error++;
      }
    associative++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "associative", &associative) &&
        associative == hatch->associative)
      pass ("HATCH.associative [B] set+1 " FORMAT_B "", associative);
    else
      {
        fail ("HATCH.associative [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->associative, associative); error++;
      }
    hatch->associative--;

  }
  {
    BITCODE_H* boundary_handles;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "boundary_handles", &boundary_handles, NULL)
        && !memcmp(&boundary_handles, &hatch->boundary_handles, sizeof(hatch->boundary_handles)))
      pass ("HATCH.boundary_handles [H*]");
    else
      {
        fail ("HATCH.boundary_handles [H*]"); error++;
      }
  }
  {
    Dwg_HATCH_Color* colors;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "colors", &colors, NULL)
        && !memcmp(&colors, &hatch->colors, sizeof(hatch->colors)))
      pass ("HATCH.colors [Dwg_HATCH_Color*]");
    else
      {
        fail ("HATCH.colors [Dwg_HATCH_Color*]"); error++;
      }
  }
  {
    Dwg_HATCH_DefLine* deflines;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "deflines", &deflines, NULL)
        && !memcmp(&deflines, &hatch->deflines, sizeof(hatch->deflines)))
      pass ("HATCH.deflines [Dwg_HATCH_DefLine*]");
    else
      {
        fail ("HATCH.deflines [Dwg_HATCH_DefLine*]"); error++;
      }
  }
  {
    BITCODE_B double_flag;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "double_flag", &double_flag, NULL) &&
        double_flag == hatch->double_flag)
      pass ("HATCH.double_flag [B] " FORMAT_B "", double_flag);
    else
      {
        fail ("HATCH.double_flag [B] " FORMAT_B " != " FORMAT_B "", hatch->double_flag, double_flag); error++;
      }
    double_flag++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "double_flag", &double_flag) &&
        double_flag == hatch->double_flag)
      pass ("HATCH.double_flag [B] set+1 " FORMAT_B "", double_flag);
    else
      {
        fail ("HATCH.double_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->double_flag, double_flag); error++;
      }
    hatch->double_flag--;

  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "elevation", &elevation, NULL) &&
        elevation == hatch->elevation)
      pass ("HATCH.elevation [BD] %g", elevation);
    else
      {
        fail ("HATCH.elevation [BD] %g != %g", hatch->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "elevation", &elevation) &&
        elevation == hatch->elevation)
      pass ("HATCH.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("HATCH.elevation [BD] set+1 %g != %g", hatch->elevation, elevation); error++;
      }
    hatch->elevation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &hatch->extrusion, sizeof(hatch->extrusion)))
      pass ("HATCH.extrusion [3BD]");
    else
      {
        fail ("HATCH.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_BD gradient_angle;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "gradient_angle", &gradient_angle, NULL) &&
        gradient_angle == hatch->gradient_angle)
      pass ("HATCH.gradient_angle [BD] %g", gradient_angle);
    else
      {
        fail ("HATCH.gradient_angle [BD] %g != %g", hatch->gradient_angle, gradient_angle); error++;
      }
    gradient_angle++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "gradient_angle", &gradient_angle) &&
        gradient_angle == hatch->gradient_angle)
      pass ("HATCH.gradient_angle [BD] set+1 %g", gradient_angle);
    else
      {
        fail ("HATCH.gradient_angle [BD] set+1 %g != %g", hatch->gradient_angle, gradient_angle); error++;
      }
    hatch->gradient_angle--;

  }
  {
    BITCODE_TV gradient_name;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "gradient_name", &gradient_name, NULL)
        && !strcmp((char*)&gradient_name, (char*)&hatch->gradient_name))
      pass ("HATCH.gradient_name [TV]");
    else
      {
        fail ("HATCH.gradient_name [TV]"); error++;
      }
  }
  {
    BITCODE_BD gradient_shift;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "gradient_shift", &gradient_shift, NULL) &&
        gradient_shift == hatch->gradient_shift)
      pass ("HATCH.gradient_shift [BD] %g", gradient_shift);
    else
      {
        fail ("HATCH.gradient_shift [BD] %g != %g", hatch->gradient_shift, gradient_shift); error++;
      }
    gradient_shift++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "gradient_shift", &gradient_shift) &&
        gradient_shift == hatch->gradient_shift)
      pass ("HATCH.gradient_shift [BD] set+1 %g", gradient_shift);
    else
      {
        fail ("HATCH.gradient_shift [BD] set+1 %g != %g", hatch->gradient_shift, gradient_shift); error++;
      }
    hatch->gradient_shift--;

  }
  {
    BITCODE_BD gradient_tint;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "gradient_tint", &gradient_tint, NULL) &&
        gradient_tint == hatch->gradient_tint)
      pass ("HATCH.gradient_tint [BD] %g", gradient_tint);
    else
      {
        fail ("HATCH.gradient_tint [BD] %g != %g", hatch->gradient_tint, gradient_tint); error++;
      }
    gradient_tint++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "gradient_tint", &gradient_tint) &&
        gradient_tint == hatch->gradient_tint)
      pass ("HATCH.gradient_tint [BD] set+1 %g", gradient_tint);
    else
      {
        fail ("HATCH.gradient_tint [BD] set+1 %g != %g", hatch->gradient_tint, gradient_tint); error++;
      }
    hatch->gradient_tint--;

  }
  {
    BITCODE_B has_derived;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "has_derived", &has_derived, NULL) &&
        has_derived == hatch->has_derived)
      pass ("HATCH.has_derived [B] " FORMAT_B "", has_derived);
    else
      {
        fail ("HATCH.has_derived [B] " FORMAT_B " != " FORMAT_B "", hatch->has_derived, has_derived); error++;
      }
    has_derived++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "has_derived", &has_derived) &&
        has_derived == hatch->has_derived)
      pass ("HATCH.has_derived [B] set+1 " FORMAT_B "", has_derived);
    else
      {
        fail ("HATCH.has_derived [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->has_derived, has_derived); error++;
      }
    hatch->has_derived--;

  }
  {
    BITCODE_BL is_gradient_fill;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "is_gradient_fill", &is_gradient_fill, NULL) &&
        is_gradient_fill == hatch->is_gradient_fill)
      pass ("HATCH.is_gradient_fill [BL] %u", is_gradient_fill);
    else
      {
        fail ("HATCH.is_gradient_fill [BL] %u != %u", hatch->is_gradient_fill, is_gradient_fill); error++;
      }
    is_gradient_fill++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "is_gradient_fill", &is_gradient_fill) &&
        is_gradient_fill == hatch->is_gradient_fill)
      pass ("HATCH.is_gradient_fill [BL] set+1 %u", is_gradient_fill);
    else
      {
        fail ("HATCH.is_gradient_fill [BL] set+1 %u != %u", hatch->is_gradient_fill, is_gradient_fill); error++;
      }
    hatch->is_gradient_fill--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&hatch->name))
      pass ("HATCH.name [TV]");
    else
      {
        fail ("HATCH.name [TV]"); error++;
      }
  }
  {
    BITCODE_BL num_boundary_handles;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_boundary_handles", &num_boundary_handles, NULL) &&
        num_boundary_handles == hatch->num_boundary_handles)
      pass ("HATCH.num_boundary_handles [BL] %u", num_boundary_handles);
    else
      {
        fail ("HATCH.num_boundary_handles [BL] %u != %u", hatch->num_boundary_handles, num_boundary_handles); error++;
      }
    num_boundary_handles++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "num_boundary_handles", &num_boundary_handles) &&
        num_boundary_handles == hatch->num_boundary_handles)
      pass ("HATCH.num_boundary_handles [BL] set+1 %u", num_boundary_handles);
    else
      {
        fail ("HATCH.num_boundary_handles [BL] set+1 %u != %u", hatch->num_boundary_handles, num_boundary_handles); error++;
      }
    hatch->num_boundary_handles--;

  }
  {
    BITCODE_BL num_colors;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_colors", &num_colors, NULL) &&
        num_colors == hatch->num_colors)
      pass ("HATCH.num_colors [BL] %u", num_colors);
    else
      {
        fail ("HATCH.num_colors [BL] %u != %u", hatch->num_colors, num_colors); error++;
      }
    num_colors++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "num_colors", &num_colors) &&
        num_colors == hatch->num_colors)
      pass ("HATCH.num_colors [BL] set+1 %u", num_colors);
    else
      {
        fail ("HATCH.num_colors [BL] set+1 %u != %u", hatch->num_colors, num_colors); error++;
      }
    hatch->num_colors--;

  }
  {
    BITCODE_BS num_deflines;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_deflines", &num_deflines, NULL) &&
        num_deflines == hatch->num_deflines)
      pass ("HATCH.num_deflines [BS] %hu", num_deflines);
    else
      {
        fail ("HATCH.num_deflines [BS] %hu != %hu", hatch->num_deflines, num_deflines); error++;
      }
    num_deflines++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "num_deflines", &num_deflines) &&
        num_deflines == hatch->num_deflines)
      pass ("HATCH.num_deflines [BS] set+1 %hu", num_deflines);
    else
      {
        fail ("HATCH.num_deflines [BS] set+1 %hu != %hu", hatch->num_deflines, num_deflines); error++;
      }
    hatch->num_deflines--;

  }
  {
    BITCODE_BL num_paths;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_paths", &num_paths, NULL) &&
        num_paths == hatch->num_paths)
      pass ("HATCH.num_paths [BL] %u", num_paths);
    else
      {
        fail ("HATCH.num_paths [BL] %u != %u", hatch->num_paths, num_paths); error++;
      }
    num_paths++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "num_paths", &num_paths) &&
        num_paths == hatch->num_paths)
      pass ("HATCH.num_paths [BL] set+1 %u", num_paths);
    else
      {
        fail ("HATCH.num_paths [BL] set+1 %u != %u", hatch->num_paths, num_paths); error++;
      }
    hatch->num_paths--;

  }
  {
    BITCODE_BL num_seeds;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_seeds", &num_seeds, NULL) &&
        num_seeds == hatch->num_seeds)
      pass ("HATCH.num_seeds [BL] %u", num_seeds);
    else
      {
        fail ("HATCH.num_seeds [BL] %u != %u", hatch->num_seeds, num_seeds); error++;
      }
    num_seeds++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "num_seeds", &num_seeds) &&
        num_seeds == hatch->num_seeds)
      pass ("HATCH.num_seeds [BL] set+1 %u", num_seeds);
    else
      {
        fail ("HATCH.num_seeds [BL] set+1 %u != %u", hatch->num_seeds, num_seeds); error++;
      }
    hatch->num_seeds--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "parent", &parent, NULL)
        && !memcmp(&parent, &hatch->parent, sizeof(hatch->parent)))
      pass ("HATCH.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("HATCH.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    Dwg_HATCH_Path* paths;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "paths", &paths, NULL)
        && !memcmp(&paths, &hatch->paths, sizeof(hatch->paths)))
      pass ("HATCH.paths [Dwg_HATCH_Path*]");
    else
      {
        fail ("HATCH.paths [Dwg_HATCH_Path*]"); error++;
      }
  }
  {
    BITCODE_BS pattern_type;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "pattern_type", &pattern_type, NULL) &&
        pattern_type == hatch->pattern_type)
      pass ("HATCH.pattern_type [BS] %hu", pattern_type);
    else
      {
        fail ("HATCH.pattern_type [BS] %hu != %hu", hatch->pattern_type, pattern_type); error++;
      }
    pattern_type++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "pattern_type", &pattern_type) &&
        pattern_type == hatch->pattern_type)
      pass ("HATCH.pattern_type [BS] set+1 %hu", pattern_type);
    else
      {
        fail ("HATCH.pattern_type [BS] set+1 %hu != %hu", hatch->pattern_type, pattern_type); error++;
      }
    hatch->pattern_type--;

  }
  {
    BITCODE_BD pixel_size;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "pixel_size", &pixel_size, NULL) &&
        pixel_size == hatch->pixel_size)
      pass ("HATCH.pixel_size [BD] %g", pixel_size);
    else
      {
        fail ("HATCH.pixel_size [BD] %g != %g", hatch->pixel_size, pixel_size); error++;
      }
    pixel_size++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "pixel_size", &pixel_size) &&
        pixel_size == hatch->pixel_size)
      pass ("HATCH.pixel_size [BD] set+1 %g", pixel_size);
    else
      {
        fail ("HATCH.pixel_size [BD] set+1 %g != %g", hatch->pixel_size, pixel_size); error++;
      }
    hatch->pixel_size--;

  }
  {
    BITCODE_BL reserved;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "reserved", &reserved, NULL) &&
        reserved == hatch->reserved)
      pass ("HATCH.reserved [BL] %u", reserved);
    else
      {
        fail ("HATCH.reserved [BL] %u != %u", hatch->reserved, reserved); error++;
      }
    reserved++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "reserved", &reserved) &&
        reserved == hatch->reserved)
      pass ("HATCH.reserved [BL] set+1 %u", reserved);
    else
      {
        fail ("HATCH.reserved [BL] set+1 %u != %u", hatch->reserved, reserved); error++;
      }
    hatch->reserved--;

  }
  {
    BITCODE_BD scale_spacing;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "scale_spacing", &scale_spacing, NULL) &&
        scale_spacing == hatch->scale_spacing)
      pass ("HATCH.scale_spacing [BD] %g", scale_spacing);
    else
      {
        fail ("HATCH.scale_spacing [BD] %g != %g", hatch->scale_spacing, scale_spacing); error++;
      }
    scale_spacing++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "scale_spacing", &scale_spacing) &&
        scale_spacing == hatch->scale_spacing)
      pass ("HATCH.scale_spacing [BD] set+1 %g", scale_spacing);
    else
      {
        fail ("HATCH.scale_spacing [BD] set+1 %g != %g", hatch->scale_spacing, scale_spacing); error++;
      }
    hatch->scale_spacing--;

  }
  {
    BITCODE_2RD seeds;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "seeds", &seeds, NULL)
        && !memcmp(&seeds, &hatch->seeds, sizeof(hatch->seeds)))
      pass ("HATCH.seeds [2RD]");
    else
      {
        fail ("HATCH.seeds [2RD]"); error++;
      }
  }
  {
    BITCODE_BL single_color_gradient;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "single_color_gradient", &single_color_gradient, NULL) &&
        single_color_gradient == hatch->single_color_gradient)
      pass ("HATCH.single_color_gradient [BL] %u", single_color_gradient);
    else
      {
        fail ("HATCH.single_color_gradient [BL] %u != %u", hatch->single_color_gradient, single_color_gradient); error++;
      }
    single_color_gradient++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "single_color_gradient", &single_color_gradient) &&
        single_color_gradient == hatch->single_color_gradient)
      pass ("HATCH.single_color_gradient [BL] set+1 %u", single_color_gradient);
    else
      {
        fail ("HATCH.single_color_gradient [BL] set+1 %u != %u", hatch->single_color_gradient, single_color_gradient); error++;
      }
    hatch->single_color_gradient--;

  }
  {
    BITCODE_B solid_fill;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "solid_fill", &solid_fill, NULL) &&
        solid_fill == hatch->solid_fill)
      pass ("HATCH.solid_fill [B] " FORMAT_B "", solid_fill);
    else
      {
        fail ("HATCH.solid_fill [B] " FORMAT_B " != " FORMAT_B "", hatch->solid_fill, solid_fill); error++;
      }
    solid_fill++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "solid_fill", &solid_fill) &&
        solid_fill == hatch->solid_fill)
      pass ("HATCH.solid_fill [B] set+1 " FORMAT_B "", solid_fill);
    else
      {
        fail ("HATCH.solid_fill [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->solid_fill, solid_fill); error++;
      }
    hatch->solid_fill--;

  }
  {
    BITCODE_BS style;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "style", &style, NULL) &&
        style == hatch->style)
      pass ("HATCH.style [BS] %hu", style);
    else
      {
        fail ("HATCH.style [BS] %hu != %hu", hatch->style, style); error++;
      }
    style++;
    if (dwg_dynapi_entity_set_value(hatch, "HATCH", "style", &style) &&
        style == hatch->style)
      pass ("HATCH.style [BS] set+1 %hu", style);
    else
      {
        fail ("HATCH.style [BS] set+1 %hu != %hu", hatch->style, style); error++;
      }
    hatch->style--;

  }
  return error;
}
static int test_HELIX (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_HELIX *helix = obj->tio.entity->tio.HELIX;
  {
    BITCODE_3BD axis_base_pt;
    if (dwg_dynapi_entity_value(helix, "HELIX", "axis_base_pt", &axis_base_pt, NULL)
        && !memcmp(&axis_base_pt, &helix->axis_base_pt, sizeof(helix->axis_base_pt)))
      pass ("HELIX.axis_base_pt [3BD]");
    else
      {
        fail ("HELIX.axis_base_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD axis_vector;
    if (dwg_dynapi_entity_value(helix, "HELIX", "axis_vector", &axis_vector, NULL)
        && !memcmp(&axis_vector, &helix->axis_vector, sizeof(helix->axis_vector)))
      pass ("HELIX.axis_vector [3BD]");
    else
      {
        fail ("HELIX.axis_vector [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD beg_tan_vec;
    if (dwg_dynapi_entity_value(helix, "HELIX", "beg_tan_vec", &beg_tan_vec, NULL)
        && !memcmp(&beg_tan_vec, &helix->beg_tan_vec, sizeof(helix->beg_tan_vec)))
      pass ("HELIX.beg_tan_vec [3BD]");
    else
      {
        fail ("HELIX.beg_tan_vec [3BD]"); error++;
      }
  }
  {
    BITCODE_B closed_b;
    if (dwg_dynapi_entity_value(helix, "HELIX", "closed_b", &closed_b, NULL) &&
        closed_b == helix->closed_b)
      pass ("HELIX.closed_b [B] " FORMAT_B "", closed_b);
    else
      {
        fail ("HELIX.closed_b [B] " FORMAT_B " != " FORMAT_B "", helix->closed_b, closed_b); error++;
      }
    closed_b++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "closed_b", &closed_b) &&
        closed_b == helix->closed_b)
      pass ("HELIX.closed_b [B] set+1 " FORMAT_B "", closed_b);
    else
      {
        fail ("HELIX.closed_b [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->closed_b, closed_b); error++;
      }
    helix->closed_b--;

  }
  {
    BITCODE_BS constraint_type;
    if (dwg_dynapi_entity_value(helix, "HELIX", "constraint_type", &constraint_type, NULL) &&
        constraint_type == helix->constraint_type)
      pass ("HELIX.constraint_type [BS] %hu", constraint_type);
    else
      {
        fail ("HELIX.constraint_type [BS] %hu != %hu", helix->constraint_type, constraint_type); error++;
      }
    constraint_type++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "constraint_type", &constraint_type) &&
        constraint_type == helix->constraint_type)
      pass ("HELIX.constraint_type [BS] set+1 %hu", constraint_type);
    else
      {
        fail ("HELIX.constraint_type [BS] set+1 %hu != %hu", helix->constraint_type, constraint_type); error++;
      }
    helix->constraint_type--;

  }
  {
    Dwg_SPLINE_control_point* ctrl_pts;
    if (dwg_dynapi_entity_value(helix, "HELIX", "ctrl_pts", &ctrl_pts, NULL)
        && !memcmp(&ctrl_pts, &helix->ctrl_pts, sizeof(helix->ctrl_pts)))
      pass ("HELIX.ctrl_pts [Dwg_SPLINE_control_point*]");
    else
      {
        fail ("HELIX.ctrl_pts [Dwg_SPLINE_control_point*]"); error++;
      }
  }
  {
    BITCODE_BD ctrl_tol;
    if (dwg_dynapi_entity_value(helix, "HELIX", "ctrl_tol", &ctrl_tol, NULL) &&
        ctrl_tol == helix->ctrl_tol)
      pass ("HELIX.ctrl_tol [BD] %g", ctrl_tol);
    else
      {
        fail ("HELIX.ctrl_tol [BD] %g != %g", helix->ctrl_tol, ctrl_tol); error++;
      }
    ctrl_tol++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "ctrl_tol", &ctrl_tol) &&
        ctrl_tol == helix->ctrl_tol)
      pass ("HELIX.ctrl_tol [BD] set+1 %g", ctrl_tol);
    else
      {
        fail ("HELIX.ctrl_tol [BD] set+1 %g != %g", helix->ctrl_tol, ctrl_tol); error++;
      }
    helix->ctrl_tol--;

  }
  {
    BITCODE_BS degree;
    if (dwg_dynapi_entity_value(helix, "HELIX", "degree", &degree, NULL) &&
        degree == helix->degree)
      pass ("HELIX.degree [BS] %hu", degree);
    else
      {
        fail ("HELIX.degree [BS] %hu != %hu", helix->degree, degree); error++;
      }
    degree++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "degree", &degree) &&
        degree == helix->degree)
      pass ("HELIX.degree [BS] set+1 %hu", degree);
    else
      {
        fail ("HELIX.degree [BS] set+1 %hu != %hu", helix->degree, degree); error++;
      }
    helix->degree--;

  }
  {
    BITCODE_3BD end_tan_vec;
    if (dwg_dynapi_entity_value(helix, "HELIX", "end_tan_vec", &end_tan_vec, NULL)
        && !memcmp(&end_tan_vec, &helix->end_tan_vec, sizeof(helix->end_tan_vec)))
      pass ("HELIX.end_tan_vec [3BD]");
    else
      {
        fail ("HELIX.end_tan_vec [3BD]"); error++;
      }
  }
  {
    Dwg_SPLINE_point* fit_pts;
    if (dwg_dynapi_entity_value(helix, "HELIX", "fit_pts", &fit_pts, NULL)
        && !memcmp(&fit_pts, &helix->fit_pts, sizeof(helix->fit_pts)))
      pass ("HELIX.fit_pts [Dwg_SPLINE_point*]");
    else
      {
        fail ("HELIX.fit_pts [Dwg_SPLINE_point*]"); error++;
      }
  }
  {
    BITCODE_BD fit_tol;
    if (dwg_dynapi_entity_value(helix, "HELIX", "fit_tol", &fit_tol, NULL) &&
        fit_tol == helix->fit_tol)
      pass ("HELIX.fit_tol [BD] %g", fit_tol);
    else
      {
        fail ("HELIX.fit_tol [BD] %g != %g", helix->fit_tol, fit_tol); error++;
      }
    fit_tol++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "fit_tol", &fit_tol) &&
        fit_tol == helix->fit_tol)
      pass ("HELIX.fit_tol [BD] set+1 %g", fit_tol);
    else
      {
        fail ("HELIX.fit_tol [BD] set+1 %g != %g", helix->fit_tol, fit_tol); error++;
      }
    helix->fit_tol--;

  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(helix, "HELIX", "flag", &flag, NULL) &&
        flag == helix->flag)
      pass ("HELIX.flag [BS] %hu", flag);
    else
      {
        fail ("HELIX.flag [BS] %hu != %hu", helix->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "flag", &flag) &&
        flag == helix->flag)
      pass ("HELIX.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("HELIX.flag [BS] set+1 %hu != %hu", helix->flag, flag); error++;
      }
    helix->flag--;

  }
  {
    BITCODE_B handedness;
    if (dwg_dynapi_entity_value(helix, "HELIX", "handedness", &handedness, NULL) &&
        handedness == helix->handedness)
      pass ("HELIX.handedness [B] " FORMAT_B "", handedness);
    else
      {
        fail ("HELIX.handedness [B] " FORMAT_B " != " FORMAT_B "", helix->handedness, handedness); error++;
      }
    handedness++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "handedness", &handedness) &&
        handedness == helix->handedness)
      pass ("HELIX.handedness [B] set+1 " FORMAT_B "", handedness);
    else
      {
        fail ("HELIX.handedness [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->handedness, handedness); error++;
      }
    helix->handedness--;

  }
  {
    BITCODE_BD knot_tol;
    if (dwg_dynapi_entity_value(helix, "HELIX", "knot_tol", &knot_tol, NULL) &&
        knot_tol == helix->knot_tol)
      pass ("HELIX.knot_tol [BD] %g", knot_tol);
    else
      {
        fail ("HELIX.knot_tol [BD] %g != %g", helix->knot_tol, knot_tol); error++;
      }
    knot_tol++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "knot_tol", &knot_tol) &&
        knot_tol == helix->knot_tol)
      pass ("HELIX.knot_tol [BD] set+1 %g", knot_tol);
    else
      {
        fail ("HELIX.knot_tol [BD] set+1 %g != %g", helix->knot_tol, knot_tol); error++;
      }
    helix->knot_tol--;

  }
  {
    BITCODE_BL knotparam;
    if (dwg_dynapi_entity_value(helix, "HELIX", "knotparam", &knotparam, NULL) &&
        knotparam == helix->knotparam)
      pass ("HELIX.knotparam [BL] %u", knotparam);
    else
      {
        fail ("HELIX.knotparam [BL] %u != %u", helix->knotparam, knotparam); error++;
      }
    knotparam++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "knotparam", &knotparam) &&
        knotparam == helix->knotparam)
      pass ("HELIX.knotparam [BL] set+1 %u", knotparam);
    else
      {
        fail ("HELIX.knotparam [BL] set+1 %u != %u", helix->knotparam, knotparam); error++;
      }
    helix->knotparam--;

  }
  {
    BITCODE_BD* knots;
    if (dwg_dynapi_entity_value(helix, "HELIX", "knots", &knots, NULL)
        && !memcmp(&knots, &helix->knots, sizeof(helix->knots)))
      pass ("HELIX.knots [BD*]");
    else
      {
        fail ("HELIX.knots [BD*]"); error++;
      }
  }
  {
    BITCODE_BS maint_version;
    if (dwg_dynapi_entity_value(helix, "HELIX", "maint_version", &maint_version, NULL) &&
        maint_version == helix->maint_version)
      pass ("HELIX.maint_version [BS] %hu", maint_version);
    else
      {
        fail ("HELIX.maint_version [BS] %hu != %hu", helix->maint_version, maint_version); error++;
      }
    maint_version++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "maint_version", &maint_version) &&
        maint_version == helix->maint_version)
      pass ("HELIX.maint_version [BS] set+1 %hu", maint_version);
    else
      {
        fail ("HELIX.maint_version [BS] set+1 %hu != %hu", helix->maint_version, maint_version); error++;
      }
    helix->maint_version--;

  }
  {
    BITCODE_BS major_version;
    if (dwg_dynapi_entity_value(helix, "HELIX", "major_version", &major_version, NULL) &&
        major_version == helix->major_version)
      pass ("HELIX.major_version [BS] %hu", major_version);
    else
      {
        fail ("HELIX.major_version [BS] %hu != %hu", helix->major_version, major_version); error++;
      }
    major_version++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "major_version", &major_version) &&
        major_version == helix->major_version)
      pass ("HELIX.major_version [BS] set+1 %hu", major_version);
    else
      {
        fail ("HELIX.major_version [BS] set+1 %hu != %hu", helix->major_version, major_version); error++;
      }
    helix->major_version--;

  }
  {
    BITCODE_BL num_ctrl_pts;
    if (dwg_dynapi_entity_value(helix, "HELIX", "num_ctrl_pts", &num_ctrl_pts, NULL) &&
        num_ctrl_pts == helix->num_ctrl_pts)
      pass ("HELIX.num_ctrl_pts [BL] %u", num_ctrl_pts);
    else
      {
        fail ("HELIX.num_ctrl_pts [BL] %u != %u", helix->num_ctrl_pts, num_ctrl_pts); error++;
      }
    num_ctrl_pts++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "num_ctrl_pts", &num_ctrl_pts) &&
        num_ctrl_pts == helix->num_ctrl_pts)
      pass ("HELIX.num_ctrl_pts [BL] set+1 %u", num_ctrl_pts);
    else
      {
        fail ("HELIX.num_ctrl_pts [BL] set+1 %u != %u", helix->num_ctrl_pts, num_ctrl_pts); error++;
      }
    helix->num_ctrl_pts--;

  }
  {
    BITCODE_BS num_fit_pts;
    if (dwg_dynapi_entity_value(helix, "HELIX", "num_fit_pts", &num_fit_pts, NULL) &&
        num_fit_pts == helix->num_fit_pts)
      pass ("HELIX.num_fit_pts [BS] %hu", num_fit_pts);
    else
      {
        fail ("HELIX.num_fit_pts [BS] %hu != %hu", helix->num_fit_pts, num_fit_pts); error++;
      }
    num_fit_pts++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "num_fit_pts", &num_fit_pts) &&
        num_fit_pts == helix->num_fit_pts)
      pass ("HELIX.num_fit_pts [BS] set+1 %hu", num_fit_pts);
    else
      {
        fail ("HELIX.num_fit_pts [BS] set+1 %hu != %hu", helix->num_fit_pts, num_fit_pts); error++;
      }
    helix->num_fit_pts--;

  }
  {
    BITCODE_BL num_knots;
    if (dwg_dynapi_entity_value(helix, "HELIX", "num_knots", &num_knots, NULL) &&
        num_knots == helix->num_knots)
      pass ("HELIX.num_knots [BL] %u", num_knots);
    else
      {
        fail ("HELIX.num_knots [BL] %u != %u", helix->num_knots, num_knots); error++;
      }
    num_knots++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "num_knots", &num_knots) &&
        num_knots == helix->num_knots)
      pass ("HELIX.num_knots [BL] set+1 %u", num_knots);
    else
      {
        fail ("HELIX.num_knots [BL] set+1 %u != %u", helix->num_knots, num_knots); error++;
      }
    helix->num_knots--;

  }
  {
    BITCODE_BD num_turns;
    if (dwg_dynapi_entity_value(helix, "HELIX", "num_turns", &num_turns, NULL) &&
        num_turns == helix->num_turns)
      pass ("HELIX.num_turns [BD] %g", num_turns);
    else
      {
        fail ("HELIX.num_turns [BD] %g != %g", helix->num_turns, num_turns); error++;
      }
    num_turns++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "num_turns", &num_turns) &&
        num_turns == helix->num_turns)
      pass ("HELIX.num_turns [BD] set+1 %g", num_turns);
    else
      {
        fail ("HELIX.num_turns [BD] set+1 %g != %g", helix->num_turns, num_turns); error++;
      }
    helix->num_turns--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(helix, "HELIX", "parent", &parent, NULL)
        && !memcmp(&parent, &helix->parent, sizeof(helix->parent)))
      pass ("HELIX.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("HELIX.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_B periodic;
    if (dwg_dynapi_entity_value(helix, "HELIX", "periodic", &periodic, NULL) &&
        periodic == helix->periodic)
      pass ("HELIX.periodic [B] " FORMAT_B "", periodic);
    else
      {
        fail ("HELIX.periodic [B] " FORMAT_B " != " FORMAT_B "", helix->periodic, periodic); error++;
      }
    periodic++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "periodic", &periodic) &&
        periodic == helix->periodic)
      pass ("HELIX.periodic [B] set+1 " FORMAT_B "", periodic);
    else
      {
        fail ("HELIX.periodic [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->periodic, periodic); error++;
      }
    helix->periodic--;

  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value(helix, "HELIX", "radius", &radius, NULL) &&
        radius == helix->radius)
      pass ("HELIX.radius [BD] %g", radius);
    else
      {
        fail ("HELIX.radius [BD] %g != %g", helix->radius, radius); error++;
      }
    radius++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "radius", &radius) &&
        radius == helix->radius)
      pass ("HELIX.radius [BD] set+1 %g", radius);
    else
      {
        fail ("HELIX.radius [BD] set+1 %g != %g", helix->radius, radius); error++;
      }
    helix->radius--;

  }
  {
    BITCODE_B rational;
    if (dwg_dynapi_entity_value(helix, "HELIX", "rational", &rational, NULL) &&
        rational == helix->rational)
      pass ("HELIX.rational [B] " FORMAT_B "", rational);
    else
      {
        fail ("HELIX.rational [B] " FORMAT_B " != " FORMAT_B "", helix->rational, rational); error++;
      }
    rational++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "rational", &rational) &&
        rational == helix->rational)
      pass ("HELIX.rational [B] set+1 " FORMAT_B "", rational);
    else
      {
        fail ("HELIX.rational [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->rational, rational); error++;
      }
    helix->rational--;

  }
  {
    BITCODE_BS scenario;
    if (dwg_dynapi_entity_value(helix, "HELIX", "scenario", &scenario, NULL) &&
        scenario == helix->scenario)
      pass ("HELIX.scenario [BS] %hu", scenario);
    else
      {
        fail ("HELIX.scenario [BS] %hu != %hu", helix->scenario, scenario); error++;
      }
    scenario++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "scenario", &scenario) &&
        scenario == helix->scenario)
      pass ("HELIX.scenario [BS] set+1 %hu", scenario);
    else
      {
        fail ("HELIX.scenario [BS] set+1 %hu != %hu", helix->scenario, scenario); error++;
      }
    helix->scenario--;

  }
  {
    BITCODE_BL splineflags1;
    if (dwg_dynapi_entity_value(helix, "HELIX", "splineflags1", &splineflags1, NULL) &&
        splineflags1 == helix->splineflags1)
      pass ("HELIX.splineflags1 [BL] %u", splineflags1);
    else
      {
        fail ("HELIX.splineflags1 [BL] %u != %u", helix->splineflags1, splineflags1); error++;
      }
    splineflags1++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "splineflags1", &splineflags1) &&
        splineflags1 == helix->splineflags1)
      pass ("HELIX.splineflags1 [BL] set+1 %u", splineflags1);
    else
      {
        fail ("HELIX.splineflags1 [BL] set+1 %u != %u", helix->splineflags1, splineflags1); error++;
      }
    helix->splineflags1--;

  }
  {
    BITCODE_3BD start_pt;
    if (dwg_dynapi_entity_value(helix, "HELIX", "start_pt", &start_pt, NULL)
        && !memcmp(&start_pt, &helix->start_pt, sizeof(helix->start_pt)))
      pass ("HELIX.start_pt [3BD]");
    else
      {
        fail ("HELIX.start_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BD turn_height;
    if (dwg_dynapi_entity_value(helix, "HELIX", "turn_height", &turn_height, NULL) &&
        turn_height == helix->turn_height)
      pass ("HELIX.turn_height [BD] %g", turn_height);
    else
      {
        fail ("HELIX.turn_height [BD] %g != %g", helix->turn_height, turn_height); error++;
      }
    turn_height++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "turn_height", &turn_height) &&
        turn_height == helix->turn_height)
      pass ("HELIX.turn_height [BD] set+1 %g", turn_height);
    else
      {
        fail ("HELIX.turn_height [BD] set+1 %g != %g", helix->turn_height, turn_height); error++;
      }
    helix->turn_height--;

  }
  {
    BITCODE_B weighted;
    if (dwg_dynapi_entity_value(helix, "HELIX", "weighted", &weighted, NULL) &&
        weighted == helix->weighted)
      pass ("HELIX.weighted [B] " FORMAT_B "", weighted);
    else
      {
        fail ("HELIX.weighted [B] " FORMAT_B " != " FORMAT_B "", helix->weighted, weighted); error++;
      }
    weighted++;
    if (dwg_dynapi_entity_set_value(helix, "HELIX", "weighted", &weighted) &&
        weighted == helix->weighted)
      pass ("HELIX.weighted [B] set+1 " FORMAT_B "", weighted);
    else
      {
        fail ("HELIX.weighted [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->weighted, weighted); error++;
      }
    helix->weighted--;

  }
  return error;
}
static int test_IMAGE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_IMAGE *image = obj->tio.entity->tio.IMAGE;
  {
    BITCODE_2RD boundary_pt0;
    if (dwg_dynapi_entity_value(image, "IMAGE", "boundary_pt0", &boundary_pt0, NULL)
        && !memcmp(&boundary_pt0, &image->boundary_pt0, sizeof(image->boundary_pt0)))
      pass ("IMAGE.boundary_pt0 [2RD]");
    else
      {
        fail ("IMAGE.boundary_pt0 [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD boundary_pt1;
    if (dwg_dynapi_entity_value(image, "IMAGE", "boundary_pt1", &boundary_pt1, NULL)
        && !memcmp(&boundary_pt1, &image->boundary_pt1, sizeof(image->boundary_pt1)))
      pass ("IMAGE.boundary_pt1 [2RD]");
    else
      {
        fail ("IMAGE.boundary_pt1 [2RD]"); error++;
      }
  }
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value(image, "IMAGE", "brightness", &brightness, NULL) &&
        brightness == image->brightness)
      pass ("IMAGE.brightness [RC] %u", brightness);
    else
      {
        fail ("IMAGE.brightness [RC] %u != %u", image->brightness, brightness); error++;
      }
    brightness++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "brightness", &brightness) &&
        brightness == image->brightness)
      pass ("IMAGE.brightness [RC] set+1 %u", brightness);
    else
      {
        fail ("IMAGE.brightness [RC] set+1 %u != %u", image->brightness, brightness); error++;
      }
    image->brightness--;

  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(image, "IMAGE", "class_version", &class_version, NULL) &&
        class_version == image->class_version)
      pass ("IMAGE.class_version [BL] %u", class_version);
    else
      {
        fail ("IMAGE.class_version [BL] %u != %u", image->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "class_version", &class_version) &&
        class_version == image->class_version)
      pass ("IMAGE.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("IMAGE.class_version [BL] set+1 %u != %u", image->class_version, class_version); error++;
      }
    image->class_version--;

  }
  {
    BITCODE_BS clip_boundary_type;
    if (dwg_dynapi_entity_value(image, "IMAGE", "clip_boundary_type", &clip_boundary_type, NULL) &&
        clip_boundary_type == image->clip_boundary_type)
      pass ("IMAGE.clip_boundary_type [BS] %hu", clip_boundary_type);
    else
      {
        fail ("IMAGE.clip_boundary_type [BS] %hu != %hu", image->clip_boundary_type, clip_boundary_type); error++;
      }
    clip_boundary_type++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "clip_boundary_type", &clip_boundary_type) &&
        clip_boundary_type == image->clip_boundary_type)
      pass ("IMAGE.clip_boundary_type [BS] set+1 %hu", clip_boundary_type);
    else
      {
        fail ("IMAGE.clip_boundary_type [BS] set+1 %hu != %hu", image->clip_boundary_type, clip_boundary_type); error++;
      }
    image->clip_boundary_type--;

  }
  {
    BITCODE_B clip_mode;
    if (dwg_dynapi_entity_value(image, "IMAGE", "clip_mode", &clip_mode, NULL) &&
        clip_mode == image->clip_mode)
      pass ("IMAGE.clip_mode [B] " FORMAT_B "", clip_mode);
    else
      {
        fail ("IMAGE.clip_mode [B] " FORMAT_B " != " FORMAT_B "", image->clip_mode, clip_mode); error++;
      }
    clip_mode++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "clip_mode", &clip_mode) &&
        clip_mode == image->clip_mode)
      pass ("IMAGE.clip_mode [B] set+1 " FORMAT_B "", clip_mode);
    else
      {
        fail ("IMAGE.clip_mode [B] set+1 " FORMAT_B " != " FORMAT_B "", image->clip_mode, clip_mode); error++;
      }
    image->clip_mode--;

  }
  {
    BITCODE_2RD* clip_verts;
    if (dwg_dynapi_entity_value(image, "IMAGE", "clip_verts", &clip_verts, NULL)
        && !memcmp(&clip_verts, &image->clip_verts, sizeof(image->clip_verts)))
      pass ("IMAGE.clip_verts [2RD*]");
    else
      {
        fail ("IMAGE.clip_verts [2RD*]"); error++;
      }
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value(image, "IMAGE", "clipping", &clipping, NULL) &&
        clipping == image->clipping)
      pass ("IMAGE.clipping [B] " FORMAT_B "", clipping);
    else
      {
        fail ("IMAGE.clipping [B] " FORMAT_B " != " FORMAT_B "", image->clipping, clipping); error++;
      }
    clipping++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "clipping", &clipping) &&
        clipping == image->clipping)
      pass ("IMAGE.clipping [B] set+1 " FORMAT_B "", clipping);
    else
      {
        fail ("IMAGE.clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", image->clipping, clipping); error++;
      }
    image->clipping--;

  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value(image, "IMAGE", "contrast", &contrast, NULL) &&
        contrast == image->contrast)
      pass ("IMAGE.contrast [RC] %u", contrast);
    else
      {
        fail ("IMAGE.contrast [RC] %u != %u", image->contrast, contrast); error++;
      }
    contrast++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "contrast", &contrast) &&
        contrast == image->contrast)
      pass ("IMAGE.contrast [RC] set+1 %u", contrast);
    else
      {
        fail ("IMAGE.contrast [RC] set+1 %u != %u", image->contrast, contrast); error++;
      }
    image->contrast--;

  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value(image, "IMAGE", "display_props", &display_props, NULL) &&
        display_props == image->display_props)
      pass ("IMAGE.display_props [BS] %hu", display_props);
    else
      {
        fail ("IMAGE.display_props [BS] %hu != %hu", image->display_props, display_props); error++;
      }
    display_props++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "display_props", &display_props) &&
        display_props == image->display_props)
      pass ("IMAGE.display_props [BS] set+1 %hu", display_props);
    else
      {
        fail ("IMAGE.display_props [BS] set+1 %hu != %hu", image->display_props, display_props); error++;
      }
    image->display_props--;

  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value(image, "IMAGE", "fade", &fade, NULL) &&
        fade == image->fade)
      pass ("IMAGE.fade [RC] %u", fade);
    else
      {
        fail ("IMAGE.fade [RC] %u != %u", image->fade, fade); error++;
      }
    fade++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "fade", &fade) &&
        fade == image->fade)
      pass ("IMAGE.fade [RC] set+1 %u", fade);
    else
      {
        fail ("IMAGE.fade [RC] set+1 %u != %u", image->fade, fade); error++;
      }
    image->fade--;

  }
  {
    BITCODE_H imagedef;
    if (dwg_dynapi_entity_value(image, "IMAGE", "imagedef", &imagedef, NULL)
        && !memcmp(&imagedef, &image->imagedef, sizeof(image->imagedef)))
      pass ("IMAGE.imagedef [H]");
    else
      {
        fail ("IMAGE.imagedef [H]"); error++;
      }
  }
  {
    BITCODE_H imagedefreactor;
    if (dwg_dynapi_entity_value(image, "IMAGE", "imagedefreactor", &imagedefreactor, NULL)
        && !memcmp(&imagedefreactor, &image->imagedefreactor, sizeof(image->imagedefreactor)))
      pass ("IMAGE.imagedefreactor [H]");
    else
      {
        fail ("IMAGE.imagedefreactor [H]"); error++;
      }
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value(image, "IMAGE", "num_clip_verts", &num_clip_verts, NULL) &&
        num_clip_verts == image->num_clip_verts)
      pass ("IMAGE.num_clip_verts [BL] %u", num_clip_verts);
    else
      {
        fail ("IMAGE.num_clip_verts [BL] %u != %u", image->num_clip_verts, num_clip_verts); error++;
      }
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value(image, "IMAGE", "num_clip_verts", &num_clip_verts) &&
        num_clip_verts == image->num_clip_verts)
      pass ("IMAGE.num_clip_verts [BL] set+1 %u", num_clip_verts);
    else
      {
        fail ("IMAGE.num_clip_verts [BL] set+1 %u != %u", image->num_clip_verts, num_clip_verts); error++;
      }
    image->num_clip_verts--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(image, "IMAGE", "parent", &parent, NULL)
        && !memcmp(&parent, &image->parent, sizeof(image->parent)))
      pass ("IMAGE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("IMAGE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value(image, "IMAGE", "pt0", &pt0, NULL)
        && !memcmp(&pt0, &image->pt0, sizeof(image->pt0)))
      pass ("IMAGE.pt0 [3BD]");
    else
      {
        fail ("IMAGE.pt0 [3BD]"); error++;
      }
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value(image, "IMAGE", "size", &size, NULL)
        && !memcmp(&size, &image->size, sizeof(image->size)))
      pass ("IMAGE.size [2RD]");
    else
      {
        fail ("IMAGE.size [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD uvec;
    if (dwg_dynapi_entity_value(image, "IMAGE", "uvec", &uvec, NULL)
        && !memcmp(&uvec, &image->uvec, sizeof(image->uvec)))
      pass ("IMAGE.uvec [3BD]");
    else
      {
        fail ("IMAGE.uvec [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD vvec;
    if (dwg_dynapi_entity_value(image, "IMAGE", "vvec", &vvec, NULL)
        && !memcmp(&vvec, &image->vvec, sizeof(image->vvec)))
      pass ("IMAGE.vvec [3BD]");
    else
      {
        fail ("IMAGE.vvec [3BD]"); error++;
      }
  }
  return error;
}
static int test_INSERT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_INSERT *insert = obj->tio.entity->tio.INSERT;
  {
    BITCODE_H* attrib_handles;
    if (dwg_dynapi_entity_value(insert, "INSERT", "attrib_handles", &attrib_handles, NULL)
        && !memcmp(&attrib_handles, &insert->attrib_handles, sizeof(insert->attrib_handles)))
      pass ("INSERT.attrib_handles [H*]");
    else
      {
        fail ("INSERT.attrib_handles [H*]"); error++;
      }
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value(insert, "INSERT", "block_header", &block_header, NULL)
        && !memcmp(&block_header, &insert->block_header, sizeof(insert->block_header)))
      pass ("INSERT.block_header [H]");
    else
      {
        fail ("INSERT.block_header [H]"); error++;
      }
  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(insert, "INSERT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &insert->extrusion, sizeof(insert->extrusion)))
      pass ("INSERT.extrusion [3DPOINT]");
    else
      {
        fail ("INSERT.extrusion [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value(insert, "INSERT", "first_attrib", &first_attrib, NULL)
        && !memcmp(&first_attrib, &insert->first_attrib, sizeof(insert->first_attrib)))
      pass ("INSERT.first_attrib [H]");
    else
      {
        fail ("INSERT.first_attrib [H]"); error++;
      }
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value(insert, "INSERT", "has_attribs", &has_attribs, NULL) &&
        has_attribs == insert->has_attribs)
      pass ("INSERT.has_attribs [B] " FORMAT_B "", has_attribs);
    else
      {
        fail ("INSERT.has_attribs [B] " FORMAT_B " != " FORMAT_B "", insert->has_attribs, has_attribs); error++;
      }
    has_attribs++;
    if (dwg_dynapi_entity_set_value(insert, "INSERT", "has_attribs", &has_attribs) &&
        has_attribs == insert->has_attribs)
      pass ("INSERT.has_attribs [B] set+1 " FORMAT_B "", has_attribs);
    else
      {
        fail ("INSERT.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", insert->has_attribs, has_attribs); error++;
      }
    insert->has_attribs--;

  }
  {
    BITCODE_3DPOINT ins_pt;
    if (dwg_dynapi_entity_value(insert, "INSERT", "ins_pt", &ins_pt, NULL)
        && !memcmp(&ins_pt, &insert->ins_pt, sizeof(insert->ins_pt)))
      pass ("INSERT.ins_pt [3DPOINT]");
    else
      {
        fail ("INSERT.ins_pt [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value(insert, "INSERT", "last_attrib", &last_attrib, NULL)
        && !memcmp(&last_attrib, &insert->last_attrib, sizeof(insert->last_attrib)))
      pass ("INSERT.last_attrib [H]");
    else
      {
        fail ("INSERT.last_attrib [H]"); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(insert, "INSERT", "num_owned", &num_owned, NULL) &&
        num_owned == insert->num_owned)
      pass ("INSERT.num_owned [BL] %u", num_owned);
    else
      {
        fail ("INSERT.num_owned [BL] %u != %u", insert->num_owned, num_owned); error++;
      }
    num_owned++;
    if (dwg_dynapi_entity_set_value(insert, "INSERT", "num_owned", &num_owned) &&
        num_owned == insert->num_owned)
      pass ("INSERT.num_owned [BL] set+1 %u", num_owned);
    else
      {
        fail ("INSERT.num_owned [BL] set+1 %u != %u", insert->num_owned, num_owned); error++;
      }
    insert->num_owned--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(insert, "INSERT", "parent", &parent, NULL)
        && !memcmp(&parent, &insert->parent, sizeof(insert->parent)))
      pass ("INSERT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("INSERT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value(insert, "INSERT", "rotation", &rotation, NULL) &&
        rotation == insert->rotation)
      pass ("INSERT.rotation [BD] %g", rotation);
    else
      {
        fail ("INSERT.rotation [BD] %g != %g", insert->rotation, rotation); error++;
      }
    rotation++;
    if (dwg_dynapi_entity_set_value(insert, "INSERT", "rotation", &rotation) &&
        rotation == insert->rotation)
      pass ("INSERT.rotation [BD] set+1 %g", rotation);
    else
      {
        fail ("INSERT.rotation [BD] set+1 %g != %g", insert->rotation, rotation); error++;
      }
    insert->rotation--;

  }
  {
    BITCODE_3DPOINT scale;
    if (dwg_dynapi_entity_value(insert, "INSERT", "scale", &scale, NULL)
        && !memcmp(&scale, &insert->scale, sizeof(insert->scale)))
      pass ("INSERT.scale [3DPOINT]");
    else
      {
        fail ("INSERT.scale [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_BB scale_flag;
    if (dwg_dynapi_entity_value(insert, "INSERT", "scale_flag", &scale_flag, NULL) &&
        scale_flag == insert->scale_flag)
      pass ("INSERT.scale_flag [BB] " FORMAT_BB "", scale_flag);
    else
      {
        fail ("INSERT.scale_flag [BB] " FORMAT_BB " != " FORMAT_BB "", insert->scale_flag, scale_flag); error++;
      }
    scale_flag++;
    if (dwg_dynapi_entity_set_value(insert, "INSERT", "scale_flag", &scale_flag) &&
        scale_flag == insert->scale_flag)
      pass ("INSERT.scale_flag [BB] set+1 " FORMAT_BB "", scale_flag);
    else
      {
        fail ("INSERT.scale_flag [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", insert->scale_flag, scale_flag); error++;
      }
    insert->scale_flag--;

  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value(insert, "INSERT", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &insert->seqend, sizeof(insert->seqend)))
      pass ("INSERT.seqend [H]");
    else
      {
        fail ("INSERT.seqend [H]"); error++;
      }
  }
  return error;
}
static int test_LEADER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LEADER *leader = obj->tio.entity->tio.LEADER;
  {
    BITCODE_BS annot_type;
    if (dwg_dynapi_entity_value(leader, "LEADER", "annot_type", &annot_type, NULL) &&
        annot_type == leader->annot_type)
      pass ("LEADER.annot_type [BS] %hu", annot_type);
    else
      {
        fail ("LEADER.annot_type [BS] %hu != %hu", leader->annot_type, annot_type); error++;
      }
    annot_type++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "annot_type", &annot_type) &&
        annot_type == leader->annot_type)
      pass ("LEADER.annot_type [BS] set+1 %hu", annot_type);
    else
      {
        fail ("LEADER.annot_type [BS] set+1 %hu != %hu", leader->annot_type, annot_type); error++;
      }
    leader->annot_type--;

  }
  {
    BITCODE_B arrowhead_on;
    if (dwg_dynapi_entity_value(leader, "LEADER", "arrowhead_on", &arrowhead_on, NULL) &&
        arrowhead_on == leader->arrowhead_on)
      pass ("LEADER.arrowhead_on [B] " FORMAT_B "", arrowhead_on);
    else
      {
        fail ("LEADER.arrowhead_on [B] " FORMAT_B " != " FORMAT_B "", leader->arrowhead_on, arrowhead_on); error++;
      }
    arrowhead_on++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "arrowhead_on", &arrowhead_on) &&
        arrowhead_on == leader->arrowhead_on)
      pass ("LEADER.arrowhead_on [B] set+1 " FORMAT_B "", arrowhead_on);
    else
      {
        fail ("LEADER.arrowhead_on [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->arrowhead_on, arrowhead_on); error++;
      }
    leader->arrowhead_on--;

  }
  {
    BITCODE_BS arrowhead_type;
    if (dwg_dynapi_entity_value(leader, "LEADER", "arrowhead_type", &arrowhead_type, NULL) &&
        arrowhead_type == leader->arrowhead_type)
      pass ("LEADER.arrowhead_type [BS] %hu", arrowhead_type);
    else
      {
        fail ("LEADER.arrowhead_type [BS] %hu != %hu", leader->arrowhead_type, arrowhead_type); error++;
      }
    arrowhead_type++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "arrowhead_type", &arrowhead_type) &&
        arrowhead_type == leader->arrowhead_type)
      pass ("LEADER.arrowhead_type [BS] set+1 %hu", arrowhead_type);
    else
      {
        fail ("LEADER.arrowhead_type [BS] set+1 %hu != %hu", leader->arrowhead_type, arrowhead_type); error++;
      }
    leader->arrowhead_type--;

  }
  {
    BITCODE_H associated_annotation;
    if (dwg_dynapi_entity_value(leader, "LEADER", "associated_annotation", &associated_annotation, NULL)
        && !memcmp(&associated_annotation, &leader->associated_annotation, sizeof(leader->associated_annotation)))
      pass ("LEADER.associated_annotation [H]");
    else
      {
        fail ("LEADER.associated_annotation [H]"); error++;
      }
  }
  {
    BITCODE_BD box_height;
    if (dwg_dynapi_entity_value(leader, "LEADER", "box_height", &box_height, NULL) &&
        box_height == leader->box_height)
      pass ("LEADER.box_height [BD] %g", box_height);
    else
      {
        fail ("LEADER.box_height [BD] %g != %g", leader->box_height, box_height); error++;
      }
    box_height++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "box_height", &box_height) &&
        box_height == leader->box_height)
      pass ("LEADER.box_height [BD] set+1 %g", box_height);
    else
      {
        fail ("LEADER.box_height [BD] set+1 %g != %g", leader->box_height, box_height); error++;
      }
    leader->box_height--;

  }
  {
    BITCODE_BD box_width;
    if (dwg_dynapi_entity_value(leader, "LEADER", "box_width", &box_width, NULL) &&
        box_width == leader->box_width)
      pass ("LEADER.box_width [BD] %g", box_width);
    else
      {
        fail ("LEADER.box_width [BD] %g != %g", leader->box_width, box_width); error++;
      }
    box_width++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "box_width", &box_width) &&
        box_width == leader->box_width)
      pass ("LEADER.box_width [BD] set+1 %g", box_width);
    else
      {
        fail ("LEADER.box_width [BD] set+1 %g != %g", leader->box_width, box_width); error++;
      }
    leader->box_width--;

  }
  {
    BITCODE_BS byblock_color;
    if (dwg_dynapi_entity_value(leader, "LEADER", "byblock_color", &byblock_color, NULL) &&
        byblock_color == leader->byblock_color)
      pass ("LEADER.byblock_color [BS] %hu", byblock_color);
    else
      {
        fail ("LEADER.byblock_color [BS] %hu != %hu", leader->byblock_color, byblock_color); error++;
      }
    byblock_color++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "byblock_color", &byblock_color) &&
        byblock_color == leader->byblock_color)
      pass ("LEADER.byblock_color [BS] set+1 %hu", byblock_color);
    else
      {
        fail ("LEADER.byblock_color [BS] set+1 %hu != %hu", leader->byblock_color, byblock_color); error++;
      }
    leader->byblock_color--;

  }
  {
    BITCODE_BD dimasz;
    if (dwg_dynapi_entity_value(leader, "LEADER", "dimasz", &dimasz, NULL) &&
        dimasz == leader->dimasz)
      pass ("LEADER.dimasz [BD] %g", dimasz);
    else
      {
        fail ("LEADER.dimasz [BD] %g != %g", leader->dimasz, dimasz); error++;
      }
    dimasz++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "dimasz", &dimasz) &&
        dimasz == leader->dimasz)
      pass ("LEADER.dimasz [BD] set+1 %g", dimasz);
    else
      {
        fail ("LEADER.dimasz [BD] set+1 %g != %g", leader->dimasz, dimasz); error++;
      }
    leader->dimasz--;

  }
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_entity_value(leader, "LEADER", "dimgap", &dimgap, NULL) &&
        dimgap == leader->dimgap)
      pass ("LEADER.dimgap [BD] %g", dimgap);
    else
      {
        fail ("LEADER.dimgap [BD] %g != %g", leader->dimgap, dimgap); error++;
      }
    dimgap++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "dimgap", &dimgap) &&
        dimgap == leader->dimgap)
      pass ("LEADER.dimgap [BD] set+1 %g", dimgap);
    else
      {
        fail ("LEADER.dimgap [BD] set+1 %g != %g", leader->dimgap, dimgap); error++;
      }
    leader->dimgap--;

  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(leader, "LEADER", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &leader->dimstyle, sizeof(leader->dimstyle)))
      pass ("LEADER.dimstyle [H]");
    else
      {
        fail ("LEADER.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_3DPOINT endptproj;
    if (dwg_dynapi_entity_value(leader, "LEADER", "endptproj", &endptproj, NULL)
        && !memcmp(&endptproj, &leader->endptproj, sizeof(leader->endptproj)))
      pass ("LEADER.endptproj [3DPOINT]");
    else
      {
        fail ("LEADER.endptproj [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(leader, "LEADER", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &leader->extrusion, sizeof(leader->extrusion)))
      pass ("LEADER.extrusion [3DPOINT]");
    else
      {
        fail ("LEADER.extrusion [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_B hookline_dir;
    if (dwg_dynapi_entity_value(leader, "LEADER", "hookline_dir", &hookline_dir, NULL) &&
        hookline_dir == leader->hookline_dir)
      pass ("LEADER.hookline_dir [B] " FORMAT_B "", hookline_dir);
    else
      {
        fail ("LEADER.hookline_dir [B] " FORMAT_B " != " FORMAT_B "", leader->hookline_dir, hookline_dir); error++;
      }
    hookline_dir++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "hookline_dir", &hookline_dir) &&
        hookline_dir == leader->hookline_dir)
      pass ("LEADER.hookline_dir [B] set+1 " FORMAT_B "", hookline_dir);
    else
      {
        fail ("LEADER.hookline_dir [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->hookline_dir, hookline_dir); error++;
      }
    leader->hookline_dir--;

  }
  {
    BITCODE_B hookline_on;
    if (dwg_dynapi_entity_value(leader, "LEADER", "hookline_on", &hookline_on, NULL) &&
        hookline_on == leader->hookline_on)
      pass ("LEADER.hookline_on [B] " FORMAT_B "", hookline_on);
    else
      {
        fail ("LEADER.hookline_on [B] " FORMAT_B " != " FORMAT_B "", leader->hookline_on, hookline_on); error++;
      }
    hookline_on++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "hookline_on", &hookline_on) &&
        hookline_on == leader->hookline_on)
      pass ("LEADER.hookline_on [B] set+1 " FORMAT_B "", hookline_on);
    else
      {
        fail ("LEADER.hookline_on [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->hookline_on, hookline_on); error++;
      }
    leader->hookline_on--;

  }
  {
    BITCODE_BL numpts;
    if (dwg_dynapi_entity_value(leader, "LEADER", "numpts", &numpts, NULL) &&
        numpts == leader->numpts)
      pass ("LEADER.numpts [BL] %u", numpts);
    else
      {
        fail ("LEADER.numpts [BL] %u != %u", leader->numpts, numpts); error++;
      }
    numpts++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "numpts", &numpts) &&
        numpts == leader->numpts)
      pass ("LEADER.numpts [BL] set+1 %u", numpts);
    else
      {
        fail ("LEADER.numpts [BL] set+1 %u != %u", leader->numpts, numpts); error++;
      }
    leader->numpts--;

  }
  {
    BITCODE_3DPOINT offset_to_block_ins_pt;
    if (dwg_dynapi_entity_value(leader, "LEADER", "offset_to_block_ins_pt", &offset_to_block_ins_pt, NULL)
        && !memcmp(&offset_to_block_ins_pt, &leader->offset_to_block_ins_pt, sizeof(leader->offset_to_block_ins_pt)))
      pass ("LEADER.offset_to_block_ins_pt [3DPOINT]");
    else
      {
        fail ("LEADER.offset_to_block_ins_pt [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_3DPOINT origin;
    if (dwg_dynapi_entity_value(leader, "LEADER", "origin", &origin, NULL)
        && !memcmp(&origin, &leader->origin, sizeof(leader->origin)))
      pass ("LEADER.origin [3DPOINT]");
    else
      {
        fail ("LEADER.origin [3DPOINT]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(leader, "LEADER", "parent", &parent, NULL)
        && !memcmp(&parent, &leader->parent, sizeof(leader->parent)))
      pass ("LEADER.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("LEADER.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BS path_type;
    if (dwg_dynapi_entity_value(leader, "LEADER", "path_type", &path_type, NULL) &&
        path_type == leader->path_type)
      pass ("LEADER.path_type [BS] %hu", path_type);
    else
      {
        fail ("LEADER.path_type [BS] %hu != %hu", leader->path_type, path_type); error++;
      }
    path_type++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "path_type", &path_type) &&
        path_type == leader->path_type)
      pass ("LEADER.path_type [BS] set+1 %hu", path_type);
    else
      {
        fail ("LEADER.path_type [BS] set+1 %hu != %hu", leader->path_type, path_type); error++;
      }
    leader->path_type--;

  }
  {
    BITCODE_3DPOINT* points;
    if (dwg_dynapi_entity_value(leader, "LEADER", "points", &points, NULL)
        && !memcmp(&points, &leader->points, sizeof(leader->points)))
      pass ("LEADER.points [3DPOINT*]");
    else
      {
        fail ("LEADER.points [3DPOINT*]"); error++;
      }
  }
  {
    BITCODE_B unknown_bit_1;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_bit_1", &unknown_bit_1, NULL) &&
        unknown_bit_1 == leader->unknown_bit_1)
      pass ("LEADER.unknown_bit_1 [B] " FORMAT_B "", unknown_bit_1);
    else
      {
        fail ("LEADER.unknown_bit_1 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_1, unknown_bit_1); error++;
      }
    unknown_bit_1++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "unknown_bit_1", &unknown_bit_1) &&
        unknown_bit_1 == leader->unknown_bit_1)
      pass ("LEADER.unknown_bit_1 [B] set+1 " FORMAT_B "", unknown_bit_1);
    else
      {
        fail ("LEADER.unknown_bit_1 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_1, unknown_bit_1); error++;
      }
    leader->unknown_bit_1--;

  }
  {
    BITCODE_B unknown_bit_2;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_bit_2", &unknown_bit_2, NULL) &&
        unknown_bit_2 == leader->unknown_bit_2)
      pass ("LEADER.unknown_bit_2 [B] " FORMAT_B "", unknown_bit_2);
    else
      {
        fail ("LEADER.unknown_bit_2 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_2, unknown_bit_2); error++;
      }
    unknown_bit_2++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "unknown_bit_2", &unknown_bit_2) &&
        unknown_bit_2 == leader->unknown_bit_2)
      pass ("LEADER.unknown_bit_2 [B] set+1 " FORMAT_B "", unknown_bit_2);
    else
      {
        fail ("LEADER.unknown_bit_2 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_2, unknown_bit_2); error++;
      }
    leader->unknown_bit_2--;

  }
  {
    BITCODE_B unknown_bit_3;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_bit_3", &unknown_bit_3, NULL) &&
        unknown_bit_3 == leader->unknown_bit_3)
      pass ("LEADER.unknown_bit_3 [B] " FORMAT_B "", unknown_bit_3);
    else
      {
        fail ("LEADER.unknown_bit_3 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_3, unknown_bit_3); error++;
      }
    unknown_bit_3++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "unknown_bit_3", &unknown_bit_3) &&
        unknown_bit_3 == leader->unknown_bit_3)
      pass ("LEADER.unknown_bit_3 [B] set+1 " FORMAT_B "", unknown_bit_3);
    else
      {
        fail ("LEADER.unknown_bit_3 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_3, unknown_bit_3); error++;
      }
    leader->unknown_bit_3--;

  }
  {
    BITCODE_B unknown_bit_5;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_bit_5", &unknown_bit_5, NULL) &&
        unknown_bit_5 == leader->unknown_bit_5)
      pass ("LEADER.unknown_bit_5 [B] " FORMAT_B "", unknown_bit_5);
    else
      {
        fail ("LEADER.unknown_bit_5 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_5, unknown_bit_5); error++;
      }
    unknown_bit_5++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "unknown_bit_5", &unknown_bit_5) &&
        unknown_bit_5 == leader->unknown_bit_5)
      pass ("LEADER.unknown_bit_5 [B] set+1 " FORMAT_B "", unknown_bit_5);
    else
      {
        fail ("LEADER.unknown_bit_5 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_5, unknown_bit_5); error++;
      }
    leader->unknown_bit_5--;

  }
  {
    BITCODE_BS unknown_short_1;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_short_1", &unknown_short_1, NULL) &&
        unknown_short_1 == leader->unknown_short_1)
      pass ("LEADER.unknown_short_1 [BS] %hu", unknown_short_1);
    else
      {
        fail ("LEADER.unknown_short_1 [BS] %hu != %hu", leader->unknown_short_1, unknown_short_1); error++;
      }
    unknown_short_1++;
    if (dwg_dynapi_entity_set_value(leader, "LEADER", "unknown_short_1", &unknown_short_1) &&
        unknown_short_1 == leader->unknown_short_1)
      pass ("LEADER.unknown_short_1 [BS] set+1 %hu", unknown_short_1);
    else
      {
        fail ("LEADER.unknown_short_1 [BS] set+1 %hu != %hu", leader->unknown_short_1, unknown_short_1); error++;
      }
    leader->unknown_short_1--;

  }
  {
    BITCODE_3DPOINT x_direction;
    if (dwg_dynapi_entity_value(leader, "LEADER", "x_direction", &x_direction, NULL)
        && !memcmp(&x_direction, &leader->x_direction, sizeof(leader->x_direction)))
      pass ("LEADER.x_direction [3DPOINT]");
    else
      {
        fail ("LEADER.x_direction [3DPOINT]"); error++;
      }
  }
  return error;
}
static int test_LIGHT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LIGHT *light = obj->tio.entity->tio.LIGHT;
  {
    BITCODE_BD attenuation_end_limit;
    if (dwg_dynapi_entity_value(light, "LIGHT", "attenuation_end_limit", &attenuation_end_limit, NULL) &&
        attenuation_end_limit == light->attenuation_end_limit)
      pass ("LIGHT.attenuation_end_limit [BD] %g", attenuation_end_limit);
    else
      {
        fail ("LIGHT.attenuation_end_limit [BD] %g != %g", light->attenuation_end_limit, attenuation_end_limit); error++;
      }
    attenuation_end_limit++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "attenuation_end_limit", &attenuation_end_limit) &&
        attenuation_end_limit == light->attenuation_end_limit)
      pass ("LIGHT.attenuation_end_limit [BD] set+1 %g", attenuation_end_limit);
    else
      {
        fail ("LIGHT.attenuation_end_limit [BD] set+1 %g != %g", light->attenuation_end_limit, attenuation_end_limit); error++;
      }
    light->attenuation_end_limit--;

  }
  {
    BITCODE_BD attenuation_start_limit;
    if (dwg_dynapi_entity_value(light, "LIGHT", "attenuation_start_limit", &attenuation_start_limit, NULL) &&
        attenuation_start_limit == light->attenuation_start_limit)
      pass ("LIGHT.attenuation_start_limit [BD] %g", attenuation_start_limit);
    else
      {
        fail ("LIGHT.attenuation_start_limit [BD] %g != %g", light->attenuation_start_limit, attenuation_start_limit); error++;
      }
    attenuation_start_limit++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "attenuation_start_limit", &attenuation_start_limit) &&
        attenuation_start_limit == light->attenuation_start_limit)
      pass ("LIGHT.attenuation_start_limit [BD] set+1 %g", attenuation_start_limit);
    else
      {
        fail ("LIGHT.attenuation_start_limit [BD] set+1 %g != %g", light->attenuation_start_limit, attenuation_start_limit); error++;
      }
    light->attenuation_start_limit--;

  }
  {
    BITCODE_BS attenuation_type;
    if (dwg_dynapi_entity_value(light, "LIGHT", "attenuation_type", &attenuation_type, NULL) &&
        attenuation_type == light->attenuation_type)
      pass ("LIGHT.attenuation_type [BS] %hu", attenuation_type);
    else
      {
        fail ("LIGHT.attenuation_type [BS] %hu != %hu", light->attenuation_type, attenuation_type); error++;
      }
    attenuation_type++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "attenuation_type", &attenuation_type) &&
        attenuation_type == light->attenuation_type)
      pass ("LIGHT.attenuation_type [BS] set+1 %hu", attenuation_type);
    else
      {
        fail ("LIGHT.attenuation_type [BS] set+1 %hu != %hu", light->attenuation_type, attenuation_type); error++;
      }
    light->attenuation_type--;

  }
  {
    BITCODE_B cast_shadows;
    if (dwg_dynapi_entity_value(light, "LIGHT", "cast_shadows", &cast_shadows, NULL) &&
        cast_shadows == light->cast_shadows)
      pass ("LIGHT.cast_shadows [B] " FORMAT_B "", cast_shadows);
    else
      {
        fail ("LIGHT.cast_shadows [B] " FORMAT_B " != " FORMAT_B "", light->cast_shadows, cast_shadows); error++;
      }
    cast_shadows++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "cast_shadows", &cast_shadows) &&
        cast_shadows == light->cast_shadows)
      pass ("LIGHT.cast_shadows [B] set+1 " FORMAT_B "", cast_shadows);
    else
      {
        fail ("LIGHT.cast_shadows [B] set+1 " FORMAT_B " != " FORMAT_B "", light->cast_shadows, cast_shadows); error++;
      }
    light->cast_shadows--;

  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(light, "LIGHT", "class_version", &class_version, NULL) &&
        class_version == light->class_version)
      pass ("LIGHT.class_version [BL] %u", class_version);
    else
      {
        fail ("LIGHT.class_version [BL] %u != %u", light->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "class_version", &class_version) &&
        class_version == light->class_version)
      pass ("LIGHT.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("LIGHT.class_version [BL] set+1 %u != %u", light->class_version, class_version); error++;
      }
    light->class_version--;

  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(light, "LIGHT", "color", &color, NULL)
        && !memcmp(&color, &light->color, sizeof(light->color)))
      pass ("LIGHT.color [CMC]");
    else
      {
        fail ("LIGHT.color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD falloff_angle;
    if (dwg_dynapi_entity_value(light, "LIGHT", "falloff_angle", &falloff_angle, NULL) &&
        falloff_angle == light->falloff_angle)
      pass ("LIGHT.falloff_angle [BD] %g", falloff_angle);
    else
      {
        fail ("LIGHT.falloff_angle [BD] %g != %g", light->falloff_angle, falloff_angle); error++;
      }
    falloff_angle++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "falloff_angle", &falloff_angle) &&
        falloff_angle == light->falloff_angle)
      pass ("LIGHT.falloff_angle [BD] set+1 %g", falloff_angle);
    else
      {
        fail ("LIGHT.falloff_angle [BD] set+1 %g != %g", light->falloff_angle, falloff_angle); error++;
      }
    light->falloff_angle--;

  }
  {
    BITCODE_BD hotspot_angle;
    if (dwg_dynapi_entity_value(light, "LIGHT", "hotspot_angle", &hotspot_angle, NULL) &&
        hotspot_angle == light->hotspot_angle)
      pass ("LIGHT.hotspot_angle [BD] %g", hotspot_angle);
    else
      {
        fail ("LIGHT.hotspot_angle [BD] %g != %g", light->hotspot_angle, hotspot_angle); error++;
      }
    hotspot_angle++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "hotspot_angle", &hotspot_angle) &&
        hotspot_angle == light->hotspot_angle)
      pass ("LIGHT.hotspot_angle [BD] set+1 %g", hotspot_angle);
    else
      {
        fail ("LIGHT.hotspot_angle [BD] set+1 %g != %g", light->hotspot_angle, hotspot_angle); error++;
      }
    light->hotspot_angle--;

  }
  {
    BITCODE_BD intensity;
    if (dwg_dynapi_entity_value(light, "LIGHT", "intensity", &intensity, NULL) &&
        intensity == light->intensity)
      pass ("LIGHT.intensity [BD] %g", intensity);
    else
      {
        fail ("LIGHT.intensity [BD] %g != %g", light->intensity, intensity); error++;
      }
    intensity++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "intensity", &intensity) &&
        intensity == light->intensity)
      pass ("LIGHT.intensity [BD] set+1 %g", intensity);
    else
      {
        fail ("LIGHT.intensity [BD] set+1 %g != %g", light->intensity, intensity); error++;
      }
    light->intensity--;

  }
  {
    BITCODE_H lights_layer;
    if (dwg_dynapi_entity_value(light, "LIGHT", "lights_layer", &lights_layer, NULL)
        && !memcmp(&lights_layer, &light->lights_layer, sizeof(light->lights_layer)))
      pass ("LIGHT.lights_layer [H]");
    else
      {
        fail ("LIGHT.lights_layer [H]"); error++;
      }
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value(light, "LIGHT", "name", &name, NULL)
        && !memcmp(&name, &light->name, sizeof(light->name)))
      pass ("LIGHT.name [T]");
    else
      {
        fail ("LIGHT.name [T]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(light, "LIGHT", "parent", &parent, NULL)
        && !memcmp(&parent, &light->parent, sizeof(light->parent)))
      pass ("LIGHT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("LIGHT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_B plot_glyph;
    if (dwg_dynapi_entity_value(light, "LIGHT", "plot_glyph", &plot_glyph, NULL) &&
        plot_glyph == light->plot_glyph)
      pass ("LIGHT.plot_glyph [B] " FORMAT_B "", plot_glyph);
    else
      {
        fail ("LIGHT.plot_glyph [B] " FORMAT_B " != " FORMAT_B "", light->plot_glyph, plot_glyph); error++;
      }
    plot_glyph++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "plot_glyph", &plot_glyph) &&
        plot_glyph == light->plot_glyph)
      pass ("LIGHT.plot_glyph [B] set+1 " FORMAT_B "", plot_glyph);
    else
      {
        fail ("LIGHT.plot_glyph [B] set+1 " FORMAT_B " != " FORMAT_B "", light->plot_glyph, plot_glyph); error++;
      }
    light->plot_glyph--;

  }
  {
    BITCODE_3BD position;
    if (dwg_dynapi_entity_value(light, "LIGHT", "position", &position, NULL)
        && !memcmp(&position, &light->position, sizeof(light->position)))
      pass ("LIGHT.position [3BD]");
    else
      {
        fail ("LIGHT.position [3BD]"); error++;
      }
  }
  {
    BITCODE_BS shadow_map_size;
    if (dwg_dynapi_entity_value(light, "LIGHT", "shadow_map_size", &shadow_map_size, NULL) &&
        shadow_map_size == light->shadow_map_size)
      pass ("LIGHT.shadow_map_size [BS] %hu", shadow_map_size);
    else
      {
        fail ("LIGHT.shadow_map_size [BS] %hu != %hu", light->shadow_map_size, shadow_map_size); error++;
      }
    shadow_map_size++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "shadow_map_size", &shadow_map_size) &&
        shadow_map_size == light->shadow_map_size)
      pass ("LIGHT.shadow_map_size [BS] set+1 %hu", shadow_map_size);
    else
      {
        fail ("LIGHT.shadow_map_size [BS] set+1 %hu != %hu", light->shadow_map_size, shadow_map_size); error++;
      }
    light->shadow_map_size--;

  }
  {
    BITCODE_RC shadow_map_softness;
    if (dwg_dynapi_entity_value(light, "LIGHT", "shadow_map_softness", &shadow_map_softness, NULL) &&
        shadow_map_softness == light->shadow_map_softness)
      pass ("LIGHT.shadow_map_softness [RC] %u", shadow_map_softness);
    else
      {
        fail ("LIGHT.shadow_map_softness [RC] %u != %u", light->shadow_map_softness, shadow_map_softness); error++;
      }
    shadow_map_softness++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "shadow_map_softness", &shadow_map_softness) &&
        shadow_map_softness == light->shadow_map_softness)
      pass ("LIGHT.shadow_map_softness [RC] set+1 %u", shadow_map_softness);
    else
      {
        fail ("LIGHT.shadow_map_softness [RC] set+1 %u != %u", light->shadow_map_softness, shadow_map_softness); error++;
      }
    light->shadow_map_softness--;

  }
  {
    BITCODE_BS shadow_type;
    if (dwg_dynapi_entity_value(light, "LIGHT", "shadow_type", &shadow_type, NULL) &&
        shadow_type == light->shadow_type)
      pass ("LIGHT.shadow_type [BS] %hu", shadow_type);
    else
      {
        fail ("LIGHT.shadow_type [BS] %hu != %hu", light->shadow_type, shadow_type); error++;
      }
    shadow_type++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "shadow_type", &shadow_type) &&
        shadow_type == light->shadow_type)
      pass ("LIGHT.shadow_type [BS] set+1 %hu", shadow_type);
    else
      {
        fail ("LIGHT.shadow_type [BS] set+1 %hu != %hu", light->shadow_type, shadow_type); error++;
      }
    light->shadow_type--;

  }
  {
    BITCODE_B status;
    if (dwg_dynapi_entity_value(light, "LIGHT", "status", &status, NULL) &&
        status == light->status)
      pass ("LIGHT.status [B] " FORMAT_B "", status);
    else
      {
        fail ("LIGHT.status [B] " FORMAT_B " != " FORMAT_B "", light->status, status); error++;
      }
    status++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "status", &status) &&
        status == light->status)
      pass ("LIGHT.status [B] set+1 " FORMAT_B "", status);
    else
      {
        fail ("LIGHT.status [B] set+1 " FORMAT_B " != " FORMAT_B "", light->status, status); error++;
      }
    light->status--;

  }
  {
    BITCODE_3BD target;
    if (dwg_dynapi_entity_value(light, "LIGHT", "target", &target, NULL)
        && !memcmp(&target, &light->target, sizeof(light->target)))
      pass ("LIGHT.target [3BD]");
    else
      {
        fail ("LIGHT.target [3BD]"); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(light, "LIGHT", "type", &type, NULL) &&
        type == light->type)
      pass ("LIGHT.type [BS] %hu", type);
    else
      {
        fail ("LIGHT.type [BS] %hu != %hu", light->type, type); error++;
      }
    type++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "type", &type) &&
        type == light->type)
      pass ("LIGHT.type [BS] set+1 %hu", type);
    else
      {
        fail ("LIGHT.type [BS] set+1 %hu != %hu", light->type, type); error++;
      }
    light->type--;

  }
  {
    BITCODE_B use_attenuation_limits;
    if (dwg_dynapi_entity_value(light, "LIGHT", "use_attenuation_limits", &use_attenuation_limits, NULL) &&
        use_attenuation_limits == light->use_attenuation_limits)
      pass ("LIGHT.use_attenuation_limits [B] " FORMAT_B "", use_attenuation_limits);
    else
      {
        fail ("LIGHT.use_attenuation_limits [B] " FORMAT_B " != " FORMAT_B "", light->use_attenuation_limits, use_attenuation_limits); error++;
      }
    use_attenuation_limits++;
    if (dwg_dynapi_entity_set_value(light, "LIGHT", "use_attenuation_limits", &use_attenuation_limits) &&
        use_attenuation_limits == light->use_attenuation_limits)
      pass ("LIGHT.use_attenuation_limits [B] set+1 " FORMAT_B "", use_attenuation_limits);
    else
      {
        fail ("LIGHT.use_attenuation_limits [B] set+1 " FORMAT_B " != " FORMAT_B "", light->use_attenuation_limits, use_attenuation_limits); error++;
      }
    light->use_attenuation_limits--;

  }
  return error;
}
static int test_LINE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LINE *line = obj->tio.entity->tio.LINE;
  {
    BITCODE_RC Zs_are_zero;
    if (dwg_dynapi_entity_value(line, "LINE", "Zs_are_zero", &Zs_are_zero, NULL) &&
        Zs_are_zero == line->Zs_are_zero)
      pass ("LINE.Zs_are_zero [RC] %u", Zs_are_zero);
    else
      {
        fail ("LINE.Zs_are_zero [RC] %u != %u", line->Zs_are_zero, Zs_are_zero); error++;
      }
    Zs_are_zero++;
    if (dwg_dynapi_entity_set_value(line, "LINE", "Zs_are_zero", &Zs_are_zero) &&
        Zs_are_zero == line->Zs_are_zero)
      pass ("LINE.Zs_are_zero [RC] set+1 %u", Zs_are_zero);
    else
      {
        fail ("LINE.Zs_are_zero [RC] set+1 %u != %u", line->Zs_are_zero, Zs_are_zero); error++;
      }
    line->Zs_are_zero--;

  }
  {
    BITCODE_3BD end;
    if (dwg_dynapi_entity_value(line, "LINE", "end", &end, NULL)
        && !memcmp(&end, &line->end, sizeof(line->end)))
      pass ("LINE.end [3BD]");
    else
      {
        fail ("LINE.end [3BD]"); error++;
      }
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(line, "LINE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &line->extrusion, sizeof(line->extrusion)))
      pass ("LINE.extrusion [BE]");
    else
      {
        fail ("LINE.extrusion [BE]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(line, "LINE", "parent", &parent, NULL)
        && !memcmp(&parent, &line->parent, sizeof(line->parent)))
      pass ("LINE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("LINE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD start;
    if (dwg_dynapi_entity_value(line, "LINE", "start", &start, NULL)
        && !memcmp(&start, &line->start, sizeof(line->start)))
      pass ("LINE.start [3BD]");
    else
      {
        fail ("LINE.start [3BD]"); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(line, "LINE", "thickness", &thickness, NULL) &&
        thickness == line->thickness)
      pass ("LINE.thickness [BT] " FORMAT_BT "", thickness);
    else
      {
        fail ("LINE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", line->thickness, thickness); error++;
      }
    if (dwg_dynapi_entity_set_value(line, "LINE", "thickness", &thickness) &&
        thickness == line->thickness)
      pass ("LINE.thickness [BT] set+1 " FORMAT_BT "", thickness);
    else
      {
        fail ("LINE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", line->thickness, thickness); error++;
      }
    line->thickness--;

  }
  return error;
}
static int test_LOFTEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LOFTEDSURFACE *loftedsurface = obj->tio.entity->tio.LOFTEDSURFACE;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&loftedsurface->acis_data))
      pass ("LOFTEDSURFACE.acis_data [RC*]");
    else
      {
        fail ("LOFTEDSURFACE.acis_data [RC*]"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == loftedsurface->acis_empty)
      pass ("LOFTEDSURFACE.acis_empty [RC] %u", acis_empty);
    else
      {
        fail ("LOFTEDSURFACE.acis_empty [RC] %u != %u", loftedsurface->acis_empty, acis_empty); error++;
      }
    acis_empty++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty) &&
        acis_empty == loftedsurface->acis_empty)
      pass ("LOFTEDSURFACE.acis_empty [RC] set+1 %u", acis_empty);
    else
      {
        fail ("LOFTEDSURFACE.acis_empty [RC] set+1 %u != %u", loftedsurface->acis_empty, acis_empty); error++;
      }
    loftedsurface->acis_empty--;

  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == loftedsurface->acis_empty2)
      pass ("LOFTEDSURFACE.acis_empty2 [RC] %u", acis_empty2);
    else
      {
        fail ("LOFTEDSURFACE.acis_empty2 [RC] %u != %u", loftedsurface->acis_empty2, acis_empty2); error++;
      }
    acis_empty2++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2) &&
        acis_empty2 == loftedsurface->acis_empty2)
      pass ("LOFTEDSURFACE.acis_empty2 [RC] set+1 %u", acis_empty2);
    else
      {
        fail ("LOFTEDSURFACE.acis_empty2 [RC] set+1 %u != %u", loftedsurface->acis_empty2, acis_empty2); error++;
      }
    loftedsurface->acis_empty2--;

  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == loftedsurface->acis_empty_bit)
      pass ("LOFTEDSURFACE.acis_empty_bit [RC] %u", acis_empty_bit);
    else
      {
        fail ("LOFTEDSURFACE.acis_empty_bit [RC] %u != %u", loftedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit) &&
        acis_empty_bit == loftedsurface->acis_empty_bit)
      pass ("LOFTEDSURFACE.acis_empty_bit [RC] set+1 %u", acis_empty_bit);
    else
      {
        fail ("LOFTEDSURFACE.acis_empty_bit [RC] set+1 %u != %u", loftedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
    loftedsurface->acis_empty_bit--;

  }
  {
    BITCODE_B align_direction;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction, NULL) &&
        align_direction == loftedsurface->align_direction)
      pass ("LOFTEDSURFACE.align_direction [B] " FORMAT_B "", align_direction);
    else
      {
        fail ("LOFTEDSURFACE.align_direction [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction); error++;
      }
    align_direction++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction) &&
        align_direction == loftedsurface->align_direction)
      pass ("LOFTEDSURFACE.align_direction [B] set+1 " FORMAT_B "", align_direction);
    else
      {
        fail ("LOFTEDSURFACE.align_direction [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction); error++;
      }
    loftedsurface->align_direction--;

  }
  {
    BITCODE_B arc_length_parameterization;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization, NULL) &&
        arc_length_parameterization == loftedsurface->arc_length_parameterization)
      pass ("LOFTEDSURFACE.arc_length_parameterization [B] " FORMAT_B "", arc_length_parameterization);
    else
      {
        fail ("LOFTEDSURFACE.arc_length_parameterization [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization); error++;
      }
    arc_length_parameterization++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization) &&
        arc_length_parameterization == loftedsurface->arc_length_parameterization)
      pass ("LOFTEDSURFACE.arc_length_parameterization [B] set+1 " FORMAT_B "", arc_length_parameterization);
    else
      {
        fail ("LOFTEDSURFACE.arc_length_parameterization [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization); error++;
      }
    loftedsurface->arc_length_parameterization--;

  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &loftedsurface->block_size, sizeof(loftedsurface->block_size)))
      pass ("LOFTEDSURFACE.block_size [BL*]");
    else
      {
        fail ("LOFTEDSURFACE.block_size [BL*]"); error++;
      }
  }
  {
    BITCODE_B closed_surfaces;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces, NULL) &&
        closed_surfaces == loftedsurface->closed_surfaces)
      pass ("LOFTEDSURFACE.closed_surfaces [B] " FORMAT_B "", closed_surfaces);
    else
      {
        fail ("LOFTEDSURFACE.closed_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces); error++;
      }
    closed_surfaces++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces) &&
        closed_surfaces == loftedsurface->closed_surfaces)
      pass ("LOFTEDSURFACE.closed_surfaces [B] set+1 " FORMAT_B "", closed_surfaces);
    else
      {
        fail ("LOFTEDSURFACE.closed_surfaces [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces); error++;
      }
    loftedsurface->closed_surfaces--;

  }
  {
    BITCODE_H cross_sections;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "cross_sections", &cross_sections, NULL)
        && !memcmp(&cross_sections, &loftedsurface->cross_sections, sizeof(loftedsurface->cross_sections)))
      pass ("LOFTEDSURFACE.cross_sections [H]");
    else
      {
        fail ("LOFTEDSURFACE.cross_sections [H]"); error++;
      }
  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&loftedsurface->encr_sat_data))
      pass ("LOFTEDSURFACE.encr_sat_data [TV]");
    else
      {
        fail ("LOFTEDSURFACE.encr_sat_data [TV]"); error++;
      }
  }
  {
    BITCODE_BD end_draft_angle;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle, NULL) &&
        end_draft_angle == loftedsurface->end_draft_angle)
      pass ("LOFTEDSURFACE.end_draft_angle [BD] %g", end_draft_angle);
    else
      {
        fail ("LOFTEDSURFACE.end_draft_angle [BD] %g != %g", loftedsurface->end_draft_angle, end_draft_angle); error++;
      }
    end_draft_angle++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle) &&
        end_draft_angle == loftedsurface->end_draft_angle)
      pass ("LOFTEDSURFACE.end_draft_angle [BD] set+1 %g", end_draft_angle);
    else
      {
        fail ("LOFTEDSURFACE.end_draft_angle [BD] set+1 %g != %g", loftedsurface->end_draft_angle, end_draft_angle); error++;
      }
    loftedsurface->end_draft_angle--;

  }
  {
    BITCODE_BD end_draft_magnitude;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude, NULL) &&
        end_draft_magnitude == loftedsurface->end_draft_magnitude)
      pass ("LOFTEDSURFACE.end_draft_magnitude [BD] %g", end_draft_magnitude);
    else
      {
        fail ("LOFTEDSURFACE.end_draft_magnitude [BD] %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude); error++;
      }
    end_draft_magnitude++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude) &&
        end_draft_magnitude == loftedsurface->end_draft_magnitude)
      pass ("LOFTEDSURFACE.end_draft_magnitude [BD] set+1 %g", end_draft_magnitude);
    else
      {
        fail ("LOFTEDSURFACE.end_draft_magnitude [BD] set+1 %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude); error++;
      }
    loftedsurface->end_draft_magnitude--;

  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &loftedsurface->extra_acis_data, sizeof(loftedsurface->extra_acis_data)))
      pass ("LOFTEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
    else
      {
        fail ("LOFTEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]"); error++;
      }
  }
  {
    BITCODE_H guide_curves;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "guide_curves", &guide_curves, NULL)
        && !memcmp(&guide_curves, &loftedsurface->guide_curves, sizeof(loftedsurface->guide_curves)))
      pass ("LOFTEDSURFACE.guide_curves [H]");
    else
      {
        fail ("LOFTEDSURFACE.guide_curves [H]"); error++;
      }
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &loftedsurface->history_id, sizeof(loftedsurface->history_id)))
      pass ("LOFTEDSURFACE.history_id [H]");
    else
      {
        fail ("LOFTEDSURFACE.history_id [H]"); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == loftedsurface->isoline_present)
      pass ("LOFTEDSURFACE.isoline_present [RC] %u", isoline_present);
    else
      {
        fail ("LOFTEDSURFACE.isoline_present [RC] %u != %u", loftedsurface->isoline_present, isoline_present); error++;
      }
    isoline_present++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present) &&
        isoline_present == loftedsurface->isoline_present)
      pass ("LOFTEDSURFACE.isoline_present [RC] set+1 %u", isoline_present);
    else
      {
        fail ("LOFTEDSURFACE.isoline_present [RC] set+1 %u != %u", loftedsurface->isoline_present, isoline_present); error++;
      }
    loftedsurface->isoline_present--;

  }
  {
    BITCODE_BD* loft_entity_transmatrix;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "loft_entity_transmatrix", &loft_entity_transmatrix, NULL)
        && !memcmp(&loft_entity_transmatrix, &loftedsurface->loft_entity_transmatrix, sizeof(loftedsurface->loft_entity_transmatrix)))
      pass ("LOFTEDSURFACE.loft_entity_transmatrix [BD*]");
    else
      {
        fail ("LOFTEDSURFACE.loft_entity_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == loftedsurface->modeler_format_version)
      pass ("LOFTEDSURFACE.modeler_format_version [BS] %hu", modeler_format_version);
    else
      {
        fail ("LOFTEDSURFACE.modeler_format_version [BS] %hu != %hu", loftedsurface->modeler_format_version, modeler_format_version); error++;
      }
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version) &&
        modeler_format_version == loftedsurface->modeler_format_version)
      pass ("LOFTEDSURFACE.modeler_format_version [BS] set+1 %hu", modeler_format_version);
    else
      {
        fail ("LOFTEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", loftedsurface->modeler_format_version, modeler_format_version); error++;
      }
    loftedsurface->modeler_format_version--;

  }
  {
    BITCODE_B no_twist;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist, NULL) &&
        no_twist == loftedsurface->no_twist)
      pass ("LOFTEDSURFACE.no_twist [B] " FORMAT_B "", no_twist);
    else
      {
        fail ("LOFTEDSURFACE.no_twist [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist); error++;
      }
    no_twist++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist) &&
        no_twist == loftedsurface->no_twist)
      pass ("LOFTEDSURFACE.no_twist [B] set+1 " FORMAT_B "", no_twist);
    else
      {
        fail ("LOFTEDSURFACE.no_twist [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist); error++;
      }
    loftedsurface->no_twist--;

  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == loftedsurface->num_blocks)
      pass ("LOFTEDSURFACE.num_blocks [BL] %u", num_blocks);
    else
      {
        fail ("LOFTEDSURFACE.num_blocks [BL] %u != %u", loftedsurface->num_blocks, num_blocks); error++;
      }
    num_blocks++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks) &&
        num_blocks == loftedsurface->num_blocks)
      pass ("LOFTEDSURFACE.num_blocks [BL] set+1 %u", num_blocks);
    else
      {
        fail ("LOFTEDSURFACE.num_blocks [BL] set+1 %u != %u", loftedsurface->num_blocks, num_blocks); error++;
      }
    loftedsurface->num_blocks--;

  }
  {
    BITCODE_BS num_cross_sections;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections, NULL) &&
        num_cross_sections == loftedsurface->num_cross_sections)
      pass ("LOFTEDSURFACE.num_cross_sections [BS] %hu", num_cross_sections);
    else
      {
        fail ("LOFTEDSURFACE.num_cross_sections [BS] %hu != %hu", loftedsurface->num_cross_sections, num_cross_sections); error++;
      }
    num_cross_sections++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections) &&
        num_cross_sections == loftedsurface->num_cross_sections)
      pass ("LOFTEDSURFACE.num_cross_sections [BS] set+1 %hu", num_cross_sections);
    else
      {
        fail ("LOFTEDSURFACE.num_cross_sections [BS] set+1 %hu != %hu", loftedsurface->num_cross_sections, num_cross_sections); error++;
      }
    loftedsurface->num_cross_sections--;

  }
  {
    BITCODE_BS num_guide_curves;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves, NULL) &&
        num_guide_curves == loftedsurface->num_guide_curves)
      pass ("LOFTEDSURFACE.num_guide_curves [BS] %hu", num_guide_curves);
    else
      {
        fail ("LOFTEDSURFACE.num_guide_curves [BS] %hu != %hu", loftedsurface->num_guide_curves, num_guide_curves); error++;
      }
    num_guide_curves++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves) &&
        num_guide_curves == loftedsurface->num_guide_curves)
      pass ("LOFTEDSURFACE.num_guide_curves [BS] set+1 %hu", num_guide_curves);
    else
      {
        fail ("LOFTEDSURFACE.num_guide_curves [BS] set+1 %hu != %hu", loftedsurface->num_guide_curves, num_guide_curves); error++;
      }
    loftedsurface->num_guide_curves--;

  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == loftedsurface->num_isolines)
      pass ("LOFTEDSURFACE.num_isolines [BL] %u", num_isolines);
    else
      {
        fail ("LOFTEDSURFACE.num_isolines [BL] %u != %u", loftedsurface->num_isolines, num_isolines); error++;
      }
    num_isolines++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "num_isolines", &num_isolines) &&
        num_isolines == loftedsurface->num_isolines)
      pass ("LOFTEDSURFACE.num_isolines [BL] set+1 %u", num_isolines);
    else
      {
        fail ("LOFTEDSURFACE.num_isolines [BL] set+1 %u != %u", loftedsurface->num_isolines, num_isolines); error++;
      }
    loftedsurface->num_isolines--;

  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == loftedsurface->num_silhouettes)
      pass ("LOFTEDSURFACE.num_silhouettes [BL] %u", num_silhouettes);
    else
      {
        fail ("LOFTEDSURFACE.num_silhouettes [BL] %u != %u", loftedsurface->num_silhouettes, num_silhouettes); error++;
      }
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes) &&
        num_silhouettes == loftedsurface->num_silhouettes)
      pass ("LOFTEDSURFACE.num_silhouettes [BL] set+1 %u", num_silhouettes);
    else
      {
        fail ("LOFTEDSURFACE.num_silhouettes [BL] set+1 %u != %u", loftedsurface->num_silhouettes, num_silhouettes); error++;
      }
    loftedsurface->num_silhouettes--;

  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == loftedsurface->num_wires)
      pass ("LOFTEDSURFACE.num_wires [BL] %u", num_wires);
    else
      {
        fail ("LOFTEDSURFACE.num_wires [BL] %u != %u", loftedsurface->num_wires, num_wires); error++;
      }
    num_wires++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires) &&
        num_wires == loftedsurface->num_wires)
      pass ("LOFTEDSURFACE.num_wires [BL] set+1 %u", num_wires);
    else
      {
        fail ("LOFTEDSURFACE.num_wires [BL] set+1 %u != %u", loftedsurface->num_wires, num_wires); error++;
      }
    loftedsurface->num_wires--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &loftedsurface->parent, sizeof(loftedsurface->parent)))
      pass ("LOFTEDSURFACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("LOFTEDSURFACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_H path_curve;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "path_curve", &path_curve, NULL)
        && !memcmp(&path_curve, &loftedsurface->path_curve, sizeof(loftedsurface->path_curve)))
      pass ("LOFTEDSURFACE.path_curve [H]");
    else
      {
        fail ("LOFTEDSURFACE.path_curve [H]"); error++;
      }
  }
  {
    BITCODE_BL plane_normal_lofting_type;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type, NULL) &&
        plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
      pass ("LOFTEDSURFACE.plane_normal_lofting_type [BL] %u", plane_normal_lofting_type);
    else
      {
        fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type); error++;
      }
    plane_normal_lofting_type++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type) &&
        plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
      pass ("LOFTEDSURFACE.plane_normal_lofting_type [BL] set+1 %u", plane_normal_lofting_type);
    else
      {
        fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] set+1 %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type); error++;
      }
    loftedsurface->plane_normal_lofting_type--;

  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "point", &point, NULL)
        && !memcmp(&point, &loftedsurface->point, sizeof(loftedsurface->point)))
      pass ("LOFTEDSURFACE.point [3BD]");
    else
      {
        fail ("LOFTEDSURFACE.point [3BD]"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "point_present", &point_present, NULL) &&
        point_present == loftedsurface->point_present)
      pass ("LOFTEDSURFACE.point_present [RC] %u", point_present);
    else
      {
        fail ("LOFTEDSURFACE.point_present [RC] %u != %u", loftedsurface->point_present, point_present); error++;
      }
    point_present++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "point_present", &point_present) &&
        point_present == loftedsurface->point_present)
      pass ("LOFTEDSURFACE.point_present [RC] set+1 %u", point_present);
    else
      {
        fail ("LOFTEDSURFACE.point_present [RC] set+1 %u != %u", loftedsurface->point_present, point_present); error++;
      }
    loftedsurface->point_present--;

  }
  {
    BITCODE_B ruled_surface;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface, NULL) &&
        ruled_surface == loftedsurface->ruled_surface)
      pass ("LOFTEDSURFACE.ruled_surface [B] " FORMAT_B "", ruled_surface);
    else
      {
        fail ("LOFTEDSURFACE.ruled_surface [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface); error++;
      }
    ruled_surface++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface) &&
        ruled_surface == loftedsurface->ruled_surface)
      pass ("LOFTEDSURFACE.ruled_surface [B] set+1 " FORMAT_B "", ruled_surface);
    else
      {
        fail ("LOFTEDSURFACE.ruled_surface [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface); error++;
      }
    loftedsurface->ruled_surface--;

  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &loftedsurface->silhouettes, sizeof(loftedsurface->silhouettes)))
      pass ("LOFTEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*]");
    else
      {
        fail ("LOFTEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*]"); error++;
      }
  }
  {
    BITCODE_B simple_surfaces;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces, NULL) &&
        simple_surfaces == loftedsurface->simple_surfaces)
      pass ("LOFTEDSURFACE.simple_surfaces [B] " FORMAT_B "", simple_surfaces);
    else
      {
        fail ("LOFTEDSURFACE.simple_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces); error++;
      }
    simple_surfaces++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces) &&
        simple_surfaces == loftedsurface->simple_surfaces)
      pass ("LOFTEDSURFACE.simple_surfaces [B] set+1 " FORMAT_B "", simple_surfaces);
    else
      {
        fail ("LOFTEDSURFACE.simple_surfaces [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces); error++;
      }
    loftedsurface->simple_surfaces--;

  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "solid", &solid, NULL) &&
        solid == loftedsurface->solid)
      pass ("LOFTEDSURFACE.solid [B] " FORMAT_B "", solid);
    else
      {
        fail ("LOFTEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid); error++;
      }
    solid++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "solid", &solid) &&
        solid == loftedsurface->solid)
      pass ("LOFTEDSURFACE.solid [B] set+1 " FORMAT_B "", solid);
    else
      {
        fail ("LOFTEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid); error++;
      }
    loftedsurface->solid--;

  }
  {
    BITCODE_BD start_draft_angle;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle, NULL) &&
        start_draft_angle == loftedsurface->start_draft_angle)
      pass ("LOFTEDSURFACE.start_draft_angle [BD] %g", start_draft_angle);
    else
      {
        fail ("LOFTEDSURFACE.start_draft_angle [BD] %g != %g", loftedsurface->start_draft_angle, start_draft_angle); error++;
      }
    start_draft_angle++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle) &&
        start_draft_angle == loftedsurface->start_draft_angle)
      pass ("LOFTEDSURFACE.start_draft_angle [BD] set+1 %g", start_draft_angle);
    else
      {
        fail ("LOFTEDSURFACE.start_draft_angle [BD] set+1 %g != %g", loftedsurface->start_draft_angle, start_draft_angle); error++;
      }
    loftedsurface->start_draft_angle--;

  }
  {
    BITCODE_BD start_draft_magnitude;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude, NULL) &&
        start_draft_magnitude == loftedsurface->start_draft_magnitude)
      pass ("LOFTEDSURFACE.start_draft_magnitude [BD] %g", start_draft_magnitude);
    else
      {
        fail ("LOFTEDSURFACE.start_draft_magnitude [BD] %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude); error++;
      }
    start_draft_magnitude++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude) &&
        start_draft_magnitude == loftedsurface->start_draft_magnitude)
      pass ("LOFTEDSURFACE.start_draft_magnitude [BD] set+1 %g", start_draft_magnitude);
    else
      {
        fail ("LOFTEDSURFACE.start_draft_magnitude [BD] set+1 %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude); error++;
      }
    loftedsurface->start_draft_magnitude--;

  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == loftedsurface->u_isolines)
      pass ("LOFTEDSURFACE.u_isolines [BS] %hu", u_isolines);
    else
      {
        fail ("LOFTEDSURFACE.u_isolines [BS] %hu != %hu", loftedsurface->u_isolines, u_isolines); error++;
      }
    u_isolines++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines) &&
        u_isolines == loftedsurface->u_isolines)
      pass ("LOFTEDSURFACE.u_isolines [BS] set+1 %hu", u_isolines);
    else
      {
        fail ("LOFTEDSURFACE.u_isolines [BS] set+1 %hu != %hu", loftedsurface->u_isolines, u_isolines); error++;
      }
    loftedsurface->u_isolines--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "unknown", &unknown, NULL) &&
        unknown == loftedsurface->unknown)
      pass ("LOFTEDSURFACE.unknown [RC] %u", unknown);
    else
      {
        fail ("LOFTEDSURFACE.unknown [RC] %u != %u", loftedsurface->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "unknown", &unknown) &&
        unknown == loftedsurface->unknown)
      pass ("LOFTEDSURFACE.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("LOFTEDSURFACE.unknown [RC] set+1 %u != %u", loftedsurface->unknown, unknown); error++;
      }
    loftedsurface->unknown--;

  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == loftedsurface->unknown_2007)
      pass ("LOFTEDSURFACE.unknown_2007 [BL] %u", unknown_2007);
    else
      {
        fail ("LOFTEDSURFACE.unknown_2007 [BL] %u != %u", loftedsurface->unknown_2007, unknown_2007); error++;
      }
    unknown_2007++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "unknown_2007", &unknown_2007) &&
        unknown_2007 == loftedsurface->unknown_2007)
      pass ("LOFTEDSURFACE.unknown_2007 [BL] set+1 %u", unknown_2007);
    else
      {
        fail ("LOFTEDSURFACE.unknown_2007 [BL] set+1 %u != %u", loftedsurface->unknown_2007, unknown_2007); error++;
      }
    loftedsurface->unknown_2007--;

  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == loftedsurface->v_isolines)
      pass ("LOFTEDSURFACE.v_isolines [BS] %hu", v_isolines);
    else
      {
        fail ("LOFTEDSURFACE.v_isolines [BS] %hu != %hu", loftedsurface->v_isolines, v_isolines); error++;
      }
    v_isolines++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines) &&
        v_isolines == loftedsurface->v_isolines)
      pass ("LOFTEDSURFACE.v_isolines [BS] set+1 %hu", v_isolines);
    else
      {
        fail ("LOFTEDSURFACE.v_isolines [BS] set+1 %hu != %hu", loftedsurface->v_isolines, v_isolines); error++;
      }
    loftedsurface->v_isolines--;

  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "version", &version, NULL) &&
        version == loftedsurface->version)
      pass ("LOFTEDSURFACE.version [BS] %hu", version);
    else
      {
        fail ("LOFTEDSURFACE.version [BS] %hu != %hu", loftedsurface->version, version); error++;
      }
    version++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "version", &version) &&
        version == loftedsurface->version)
      pass ("LOFTEDSURFACE.version [BS] set+1 %hu", version);
    else
      {
        fail ("LOFTEDSURFACE.version [BS] set+1 %hu != %hu", loftedsurface->version, version); error++;
      }
    loftedsurface->version--;

  }
  {
    BITCODE_B virtual_guide;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide, NULL) &&
        virtual_guide == loftedsurface->virtual_guide)
      pass ("LOFTEDSURFACE.virtual_guide [B] " FORMAT_B "", virtual_guide);
    else
      {
        fail ("LOFTEDSURFACE.virtual_guide [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide); error++;
      }
    virtual_guide++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide) &&
        virtual_guide == loftedsurface->virtual_guide)
      pass ("LOFTEDSURFACE.virtual_guide [B] set+1 " FORMAT_B "", virtual_guide);
    else
      {
        fail ("LOFTEDSURFACE.virtual_guide [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide); error++;
      }
    loftedsurface->virtual_guide--;

  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == loftedsurface->wireframe_data_present)
      pass ("LOFTEDSURFACE.wireframe_data_present [RC] %u", wireframe_data_present);
    else
      {
        fail ("LOFTEDSURFACE.wireframe_data_present [RC] %u != %u", loftedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value(loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present) &&
        wireframe_data_present == loftedsurface->wireframe_data_present)
      pass ("LOFTEDSURFACE.wireframe_data_present [RC] set+1 %u", wireframe_data_present);
    else
      {
        fail ("LOFTEDSURFACE.wireframe_data_present [RC] set+1 %u != %u", loftedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
    loftedsurface->wireframe_data_present--;

  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &loftedsurface->wires, sizeof(loftedsurface->wires)))
      pass ("LOFTEDSURFACE.wires [Dwg_3DSOLID_wire*]");
    else
      {
        fail ("LOFTEDSURFACE.wires [Dwg_3DSOLID_wire*]"); error++;
      }
  }
  return error;
}
static int test_LWPOLYLINE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LWPOLYLINE *lwpolyline = obj->tio.entity->tio.LWPOLYLINE;
  {
    BITCODE_BD* bulges;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "bulges", &bulges, NULL)
        && !memcmp(&bulges, &lwpolyline->bulges, sizeof(lwpolyline->bulges)))
      pass ("LWPOLYLINE.bulges [BD*]");
    else
      {
        fail ("LWPOLYLINE.bulges [BD*]"); error++;
      }
  }
  {
    BITCODE_BD const_width;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "const_width", &const_width, NULL) &&
        const_width == lwpolyline->const_width)
      pass ("LWPOLYLINE.const_width [BD] %g", const_width);
    else
      {
        fail ("LWPOLYLINE.const_width [BD] %g != %g", lwpolyline->const_width, const_width); error++;
      }
    const_width++;
    if (dwg_dynapi_entity_set_value(lwpolyline, "LWPOLYLINE", "const_width", &const_width) &&
        const_width == lwpolyline->const_width)
      pass ("LWPOLYLINE.const_width [BD] set+1 %g", const_width);
    else
      {
        fail ("LWPOLYLINE.const_width [BD] set+1 %g != %g", lwpolyline->const_width, const_width); error++;
      }
    lwpolyline->const_width--;

  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "elevation", &elevation, NULL) &&
        elevation == lwpolyline->elevation)
      pass ("LWPOLYLINE.elevation [BD] %g", elevation);
    else
      {
        fail ("LWPOLYLINE.elevation [BD] %g != %g", lwpolyline->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(lwpolyline, "LWPOLYLINE", "elevation", &elevation) &&
        elevation == lwpolyline->elevation)
      pass ("LWPOLYLINE.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("LWPOLYLINE.elevation [BD] set+1 %g != %g", lwpolyline->elevation, elevation); error++;
      }
    lwpolyline->elevation--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &lwpolyline->extrusion, sizeof(lwpolyline->extrusion)))
      pass ("LWPOLYLINE.extrusion [3BD]");
    else
      {
        fail ("LWPOLYLINE.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "flag", &flag, NULL) &&
        flag == lwpolyline->flag)
      pass ("LWPOLYLINE.flag [BS] %hu", flag);
    else
      {
        fail ("LWPOLYLINE.flag [BS] %hu != %hu", lwpolyline->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(lwpolyline, "LWPOLYLINE", "flag", &flag) &&
        flag == lwpolyline->flag)
      pass ("LWPOLYLINE.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("LWPOLYLINE.flag [BS] set+1 %hu != %hu", lwpolyline->flag, flag); error++;
      }
    lwpolyline->flag--;

  }
  {
    BITCODE_BL num_bulges;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "num_bulges", &num_bulges, NULL) &&
        num_bulges == lwpolyline->num_bulges)
      pass ("LWPOLYLINE.num_bulges [BL] %u", num_bulges);
    else
      {
        fail ("LWPOLYLINE.num_bulges [BL] %u != %u", lwpolyline->num_bulges, num_bulges); error++;
      }
    num_bulges++;
    if (dwg_dynapi_entity_set_value(lwpolyline, "LWPOLYLINE", "num_bulges", &num_bulges) &&
        num_bulges == lwpolyline->num_bulges)
      pass ("LWPOLYLINE.num_bulges [BL] set+1 %u", num_bulges);
    else
      {
        fail ("LWPOLYLINE.num_bulges [BL] set+1 %u != %u", lwpolyline->num_bulges, num_bulges); error++;
      }
    lwpolyline->num_bulges--;

  }
  {
    BITCODE_BL num_points;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "num_points", &num_points, NULL) &&
        num_points == lwpolyline->num_points)
      pass ("LWPOLYLINE.num_points [BL] %u", num_points);
    else
      {
        fail ("LWPOLYLINE.num_points [BL] %u != %u", lwpolyline->num_points, num_points); error++;
      }
    num_points++;
    if (dwg_dynapi_entity_set_value(lwpolyline, "LWPOLYLINE", "num_points", &num_points) &&
        num_points == lwpolyline->num_points)
      pass ("LWPOLYLINE.num_points [BL] set+1 %u", num_points);
    else
      {
        fail ("LWPOLYLINE.num_points [BL] set+1 %u != %u", lwpolyline->num_points, num_points); error++;
      }
    lwpolyline->num_points--;

  }
  {
    BITCODE_BL num_vertexids;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "num_vertexids", &num_vertexids, NULL) &&
        num_vertexids == lwpolyline->num_vertexids)
      pass ("LWPOLYLINE.num_vertexids [BL] %u", num_vertexids);
    else
      {
        fail ("LWPOLYLINE.num_vertexids [BL] %u != %u", lwpolyline->num_vertexids, num_vertexids); error++;
      }
    num_vertexids++;
    if (dwg_dynapi_entity_set_value(lwpolyline, "LWPOLYLINE", "num_vertexids", &num_vertexids) &&
        num_vertexids == lwpolyline->num_vertexids)
      pass ("LWPOLYLINE.num_vertexids [BL] set+1 %u", num_vertexids);
    else
      {
        fail ("LWPOLYLINE.num_vertexids [BL] set+1 %u != %u", lwpolyline->num_vertexids, num_vertexids); error++;
      }
    lwpolyline->num_vertexids--;

  }
  {
    BITCODE_BL num_widths;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "num_widths", &num_widths, NULL) &&
        num_widths == lwpolyline->num_widths)
      pass ("LWPOLYLINE.num_widths [BL] %u", num_widths);
    else
      {
        fail ("LWPOLYLINE.num_widths [BL] %u != %u", lwpolyline->num_widths, num_widths); error++;
      }
    num_widths++;
    if (dwg_dynapi_entity_set_value(lwpolyline, "LWPOLYLINE", "num_widths", &num_widths) &&
        num_widths == lwpolyline->num_widths)
      pass ("LWPOLYLINE.num_widths [BL] set+1 %u", num_widths);
    else
      {
        fail ("LWPOLYLINE.num_widths [BL] set+1 %u != %u", lwpolyline->num_widths, num_widths); error++;
      }
    lwpolyline->num_widths--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "parent", &parent, NULL)
        && !memcmp(&parent, &lwpolyline->parent, sizeof(lwpolyline->parent)))
      pass ("LWPOLYLINE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("LWPOLYLINE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_2RD* points;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "points", &points, NULL)
        && !memcmp(&points, &lwpolyline->points, sizeof(lwpolyline->points)))
      pass ("LWPOLYLINE.points [2RD*]");
    else
      {
        fail ("LWPOLYLINE.points [2RD*]"); error++;
      }
  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "thickness", &thickness, NULL) &&
        thickness == lwpolyline->thickness)
      pass ("LWPOLYLINE.thickness [BD] %g", thickness);
    else
      {
        fail ("LWPOLYLINE.thickness [BD] %g != %g", lwpolyline->thickness, thickness); error++;
      }
    thickness++;
    if (dwg_dynapi_entity_set_value(lwpolyline, "LWPOLYLINE", "thickness", &thickness) &&
        thickness == lwpolyline->thickness)
      pass ("LWPOLYLINE.thickness [BD] set+1 %g", thickness);
    else
      {
        fail ("LWPOLYLINE.thickness [BD] set+1 %g != %g", lwpolyline->thickness, thickness); error++;
      }
    lwpolyline->thickness--;

  }
  {
    BITCODE_BL* vertexids;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "vertexids", &vertexids, NULL)
        && !memcmp(&vertexids, &lwpolyline->vertexids, sizeof(lwpolyline->vertexids)))
      pass ("LWPOLYLINE.vertexids [BL*]");
    else
      {
        fail ("LWPOLYLINE.vertexids [BL*]"); error++;
      }
  }
  {
    Dwg_LWPOLYLINE_width* widths;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "widths", &widths, NULL)
        && !memcmp(&widths, &lwpolyline->widths, sizeof(lwpolyline->widths)))
      pass ("LWPOLYLINE.widths [Dwg_LWPOLYLINE_width*]");
    else
      {
        fail ("LWPOLYLINE.widths [Dwg_LWPOLYLINE_width*]"); error++;
      }
  }
  return error;
}
static int test_MINSERT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_MINSERT *minsert = obj->tio.entity->tio.MINSERT;
  {
    BITCODE_H* attrib_handles;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "attrib_handles", &attrib_handles, NULL)
        && !memcmp(&attrib_handles, &minsert->attrib_handles, sizeof(minsert->attrib_handles)))
      pass ("MINSERT.attrib_handles [H*]");
    else
      {
        fail ("MINSERT.attrib_handles [H*]"); error++;
      }
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "block_header", &block_header, NULL)
        && !memcmp(&block_header, &minsert->block_header, sizeof(minsert->block_header)))
      pass ("MINSERT.block_header [H]");
    else
      {
        fail ("MINSERT.block_header [H]"); error++;
      }
  }
  {
    BITCODE_BD col_spacing;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "col_spacing", &col_spacing, NULL) &&
        col_spacing == minsert->col_spacing)
      pass ("MINSERT.col_spacing [BD] %g", col_spacing);
    else
      {
        fail ("MINSERT.col_spacing [BD] %g != %g", minsert->col_spacing, col_spacing); error++;
      }
    col_spacing++;
    if (dwg_dynapi_entity_set_value(minsert, "MINSERT", "col_spacing", &col_spacing) &&
        col_spacing == minsert->col_spacing)
      pass ("MINSERT.col_spacing [BD] set+1 %g", col_spacing);
    else
      {
        fail ("MINSERT.col_spacing [BD] set+1 %g != %g", minsert->col_spacing, col_spacing); error++;
      }
    minsert->col_spacing--;

  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &minsert->extrusion, sizeof(minsert->extrusion)))
      pass ("MINSERT.extrusion [3DPOINT]");
    else
      {
        fail ("MINSERT.extrusion [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "first_attrib", &first_attrib, NULL)
        && !memcmp(&first_attrib, &minsert->first_attrib, sizeof(minsert->first_attrib)))
      pass ("MINSERT.first_attrib [H]");
    else
      {
        fail ("MINSERT.first_attrib [H]"); error++;
      }
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "has_attribs", &has_attribs, NULL) &&
        has_attribs == minsert->has_attribs)
      pass ("MINSERT.has_attribs [B] " FORMAT_B "", has_attribs);
    else
      {
        fail ("MINSERT.has_attribs [B] " FORMAT_B " != " FORMAT_B "", minsert->has_attribs, has_attribs); error++;
      }
    has_attribs++;
    if (dwg_dynapi_entity_set_value(minsert, "MINSERT", "has_attribs", &has_attribs) &&
        has_attribs == minsert->has_attribs)
      pass ("MINSERT.has_attribs [B] set+1 " FORMAT_B "", has_attribs);
    else
      {
        fail ("MINSERT.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", minsert->has_attribs, has_attribs); error++;
      }
    minsert->has_attribs--;

  }
  {
    BITCODE_3DPOINT ins_pt;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "ins_pt", &ins_pt, NULL)
        && !memcmp(&ins_pt, &minsert->ins_pt, sizeof(minsert->ins_pt)))
      pass ("MINSERT.ins_pt [3DPOINT]");
    else
      {
        fail ("MINSERT.ins_pt [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "last_attrib", &last_attrib, NULL)
        && !memcmp(&last_attrib, &minsert->last_attrib, sizeof(minsert->last_attrib)))
      pass ("MINSERT.last_attrib [H]");
    else
      {
        fail ("MINSERT.last_attrib [H]"); error++;
      }
  }
  {
    BITCODE_BS num_cols;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "num_cols", &num_cols, NULL) &&
        num_cols == minsert->num_cols)
      pass ("MINSERT.num_cols [BS] %hu", num_cols);
    else
      {
        fail ("MINSERT.num_cols [BS] %hu != %hu", minsert->num_cols, num_cols); error++;
      }
    num_cols++;
    if (dwg_dynapi_entity_set_value(minsert, "MINSERT", "num_cols", &num_cols) &&
        num_cols == minsert->num_cols)
      pass ("MINSERT.num_cols [BS] set+1 %hu", num_cols);
    else
      {
        fail ("MINSERT.num_cols [BS] set+1 %hu != %hu", minsert->num_cols, num_cols); error++;
      }
    minsert->num_cols--;

  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "num_owned", &num_owned, NULL) &&
        num_owned == minsert->num_owned)
      pass ("MINSERT.num_owned [BL] %u", num_owned);
    else
      {
        fail ("MINSERT.num_owned [BL] %u != %u", minsert->num_owned, num_owned); error++;
      }
    num_owned++;
    if (dwg_dynapi_entity_set_value(minsert, "MINSERT", "num_owned", &num_owned) &&
        num_owned == minsert->num_owned)
      pass ("MINSERT.num_owned [BL] set+1 %u", num_owned);
    else
      {
        fail ("MINSERT.num_owned [BL] set+1 %u != %u", minsert->num_owned, num_owned); error++;
      }
    minsert->num_owned--;

  }
  {
    BITCODE_BS num_rows;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "num_rows", &num_rows, NULL) &&
        num_rows == minsert->num_rows)
      pass ("MINSERT.num_rows [BS] %hu", num_rows);
    else
      {
        fail ("MINSERT.num_rows [BS] %hu != %hu", minsert->num_rows, num_rows); error++;
      }
    num_rows++;
    if (dwg_dynapi_entity_set_value(minsert, "MINSERT", "num_rows", &num_rows) &&
        num_rows == minsert->num_rows)
      pass ("MINSERT.num_rows [BS] set+1 %hu", num_rows);
    else
      {
        fail ("MINSERT.num_rows [BS] set+1 %hu != %hu", minsert->num_rows, num_rows); error++;
      }
    minsert->num_rows--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "parent", &parent, NULL)
        && !memcmp(&parent, &minsert->parent, sizeof(minsert->parent)))
      pass ("MINSERT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("MINSERT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "rotation", &rotation, NULL) &&
        rotation == minsert->rotation)
      pass ("MINSERT.rotation [BD] %g", rotation);
    else
      {
        fail ("MINSERT.rotation [BD] %g != %g", minsert->rotation, rotation); error++;
      }
    rotation++;
    if (dwg_dynapi_entity_set_value(minsert, "MINSERT", "rotation", &rotation) &&
        rotation == minsert->rotation)
      pass ("MINSERT.rotation [BD] set+1 %g", rotation);
    else
      {
        fail ("MINSERT.rotation [BD] set+1 %g != %g", minsert->rotation, rotation); error++;
      }
    minsert->rotation--;

  }
  {
    BITCODE_BD row_spacing;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "row_spacing", &row_spacing, NULL) &&
        row_spacing == minsert->row_spacing)
      pass ("MINSERT.row_spacing [BD] %g", row_spacing);
    else
      {
        fail ("MINSERT.row_spacing [BD] %g != %g", minsert->row_spacing, row_spacing); error++;
      }
    row_spacing++;
    if (dwg_dynapi_entity_set_value(minsert, "MINSERT", "row_spacing", &row_spacing) &&
        row_spacing == minsert->row_spacing)
      pass ("MINSERT.row_spacing [BD] set+1 %g", row_spacing);
    else
      {
        fail ("MINSERT.row_spacing [BD] set+1 %g != %g", minsert->row_spacing, row_spacing); error++;
      }
    minsert->row_spacing--;

  }
  {
    BITCODE_3DPOINT scale;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "scale", &scale, NULL)
        && !memcmp(&scale, &minsert->scale, sizeof(minsert->scale)))
      pass ("MINSERT.scale [3DPOINT]");
    else
      {
        fail ("MINSERT.scale [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_BB scale_flag;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "scale_flag", &scale_flag, NULL) &&
        scale_flag == minsert->scale_flag)
      pass ("MINSERT.scale_flag [BB] " FORMAT_BB "", scale_flag);
    else
      {
        fail ("MINSERT.scale_flag [BB] " FORMAT_BB " != " FORMAT_BB "", minsert->scale_flag, scale_flag); error++;
      }
    scale_flag++;
    if (dwg_dynapi_entity_set_value(minsert, "MINSERT", "scale_flag", &scale_flag) &&
        scale_flag == minsert->scale_flag)
      pass ("MINSERT.scale_flag [BB] set+1 " FORMAT_BB "", scale_flag);
    else
      {
        fail ("MINSERT.scale_flag [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", minsert->scale_flag, scale_flag); error++;
      }
    minsert->scale_flag--;

  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &minsert->seqend, sizeof(minsert->seqend)))
      pass ("MINSERT.seqend [H]");
    else
      {
        fail ("MINSERT.seqend [H]"); error++;
      }
  }
  return error;
}
static int test_MLINE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_MLINE *mline = obj->tio.entity->tio.MLINE;
  {
    BITCODE_3BD base_point;
    if (dwg_dynapi_entity_value(mline, "MLINE", "base_point", &base_point, NULL)
        && !memcmp(&base_point, &mline->base_point, sizeof(mline->base_point)))
      pass ("MLINE.base_point [3BD]");
    else
      {
        fail ("MLINE.base_point [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(mline, "MLINE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &mline->extrusion, sizeof(mline->extrusion)))
      pass ("MLINE.extrusion [3BD]");
    else
      {
        fail ("MLINE.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value(mline, "MLINE", "flags", &flags, NULL) &&
        flags == mline->flags)
      pass ("MLINE.flags [BS] %hu", flags);
    else
      {
        fail ("MLINE.flags [BS] %hu != %hu", mline->flags, flags); error++;
      }
    flags++;
    if (dwg_dynapi_entity_set_value(mline, "MLINE", "flags", &flags) &&
        flags == mline->flags)
      pass ("MLINE.flags [BS] set+1 %hu", flags);
    else
      {
        fail ("MLINE.flags [BS] set+1 %hu != %hu", mline->flags, flags); error++;
      }
    mline->flags--;

  }
  {
    BITCODE_RC justification;
    if (dwg_dynapi_entity_value(mline, "MLINE", "justification", &justification, NULL) &&
        justification == mline->justification)
      pass ("MLINE.justification [RC] %u", justification);
    else
      {
        fail ("MLINE.justification [RC] %u != %u", mline->justification, justification); error++;
      }
    justification++;
    if (dwg_dynapi_entity_set_value(mline, "MLINE", "justification", &justification) &&
        justification == mline->justification)
      pass ("MLINE.justification [RC] set+1 %u", justification);
    else
      {
        fail ("MLINE.justification [RC] set+1 %u != %u", mline->justification, justification); error++;
      }
    mline->justification--;

  }
  {
    BITCODE_H mlinestyle;
    if (dwg_dynapi_entity_value(mline, "MLINE", "mlinestyle", &mlinestyle, NULL)
        && !memcmp(&mlinestyle, &mline->mlinestyle, sizeof(mline->mlinestyle)))
      pass ("MLINE.mlinestyle [H]");
    else
      {
        fail ("MLINE.mlinestyle [H]"); error++;
      }
  }
  {
    BITCODE_RC num_lines;
    if (dwg_dynapi_entity_value(mline, "MLINE", "num_lines", &num_lines, NULL) &&
        num_lines == mline->num_lines)
      pass ("MLINE.num_lines [RC] %u", num_lines);
    else
      {
        fail ("MLINE.num_lines [RC] %u != %u", mline->num_lines, num_lines); error++;
      }
    num_lines++;
    if (dwg_dynapi_entity_set_value(mline, "MLINE", "num_lines", &num_lines) &&
        num_lines == mline->num_lines)
      pass ("MLINE.num_lines [RC] set+1 %u", num_lines);
    else
      {
        fail ("MLINE.num_lines [RC] set+1 %u != %u", mline->num_lines, num_lines); error++;
      }
    mline->num_lines--;

  }
  {
    BITCODE_BS num_verts;
    if (dwg_dynapi_entity_value(mline, "MLINE", "num_verts", &num_verts, NULL) &&
        num_verts == mline->num_verts)
      pass ("MLINE.num_verts [BS] %hu", num_verts);
    else
      {
        fail ("MLINE.num_verts [BS] %hu != %hu", mline->num_verts, num_verts); error++;
      }
    num_verts++;
    if (dwg_dynapi_entity_set_value(mline, "MLINE", "num_verts", &num_verts) &&
        num_verts == mline->num_verts)
      pass ("MLINE.num_verts [BS] set+1 %hu", num_verts);
    else
      {
        fail ("MLINE.num_verts [BS] set+1 %hu != %hu", mline->num_verts, num_verts); error++;
      }
    mline->num_verts--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(mline, "MLINE", "parent", &parent, NULL)
        && !memcmp(&parent, &mline->parent, sizeof(mline->parent)))
      pass ("MLINE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("MLINE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value(mline, "MLINE", "scale", &scale, NULL) &&
        scale == mline->scale)
      pass ("MLINE.scale [BD] %g", scale);
    else
      {
        fail ("MLINE.scale [BD] %g != %g", mline->scale, scale); error++;
      }
    scale++;
    if (dwg_dynapi_entity_set_value(mline, "MLINE", "scale", &scale) &&
        scale == mline->scale)
      pass ("MLINE.scale [BD] set+1 %g", scale);
    else
      {
        fail ("MLINE.scale [BD] set+1 %g != %g", mline->scale, scale); error++;
      }
    mline->scale--;

  }
  {
    Dwg_MLINE_vertex* verts;
    if (dwg_dynapi_entity_value(mline, "MLINE", "verts", &verts, NULL)
        && !memcmp(&verts, &mline->verts, sizeof(mline->verts)))
      pass ("MLINE.verts [Dwg_MLINE_vertex*]");
    else
      {
        fail ("MLINE.verts [Dwg_MLINE_vertex*]"); error++;
      }
  }
  return error;
}
static int test_MTEXT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_MTEXT *mtext = obj->tio.entity->tio.MTEXT;
  {
    BITCODE_B annotative;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "annotative", &annotative, NULL) &&
        annotative == mtext->annotative)
      pass ("MTEXT.annotative [B] " FORMAT_B "", annotative);
    else
      {
        fail ("MTEXT.annotative [B] " FORMAT_B " != " FORMAT_B "", mtext->annotative, annotative); error++;
      }
    annotative++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "annotative", &annotative) &&
        annotative == mtext->annotative)
      pass ("MTEXT.annotative [B] set+1 " FORMAT_B "", annotative);
    else
      {
        fail ("MTEXT.annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->annotative, annotative); error++;
      }
    mtext->annotative--;

  }
  {
    BITCODE_H appid;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "appid", &appid, NULL)
        && !memcmp(&appid, &mtext->appid, sizeof(mtext->appid)))
      pass ("MTEXT.appid [H]");
    else
      {
        fail ("MTEXT.appid [H]"); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "attachment", &attachment, NULL) &&
        attachment == mtext->attachment)
      pass ("MTEXT.attachment [BS] %hu", attachment);
    else
      {
        fail ("MTEXT.attachment [BS] %hu != %hu", mtext->attachment, attachment); error++;
      }
    attachment++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "attachment", &attachment) &&
        attachment == mtext->attachment)
      pass ("MTEXT.attachment [BS] set+1 %hu", attachment);
    else
      {
        fail ("MTEXT.attachment [BS] set+1 %hu != %hu", mtext->attachment, attachment); error++;
      }
    mtext->attachment--;

  }
  {
    BITCODE_B auto_height;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "auto_height", &auto_height, NULL) &&
        auto_height == mtext->auto_height)
      pass ("MTEXT.auto_height [B] " FORMAT_B "", auto_height);
    else
      {
        fail ("MTEXT.auto_height [B] " FORMAT_B " != " FORMAT_B "", mtext->auto_height, auto_height); error++;
      }
    auto_height++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "auto_height", &auto_height) &&
        auto_height == mtext->auto_height)
      pass ("MTEXT.auto_height [B] set+1 " FORMAT_B "", auto_height);
    else
      {
        fail ("MTEXT.auto_height [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->auto_height, auto_height); error++;
      }
    mtext->auto_height--;

  }
  {
    BITCODE_CMC bg_fill_color;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "bg_fill_color", &bg_fill_color, NULL)
        && !memcmp(&bg_fill_color, &mtext->bg_fill_color, sizeof(mtext->bg_fill_color)))
      pass ("MTEXT.bg_fill_color [CMC]");
    else
      {
        fail ("MTEXT.bg_fill_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BL bg_fill_flag;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "bg_fill_flag", &bg_fill_flag, NULL) &&
        bg_fill_flag == mtext->bg_fill_flag)
      pass ("MTEXT.bg_fill_flag [BL] %u", bg_fill_flag);
    else
      {
        fail ("MTEXT.bg_fill_flag [BL] %u != %u", mtext->bg_fill_flag, bg_fill_flag); error++;
      }
    bg_fill_flag++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "bg_fill_flag", &bg_fill_flag) &&
        bg_fill_flag == mtext->bg_fill_flag)
      pass ("MTEXT.bg_fill_flag [BL] set+1 %u", bg_fill_flag);
    else
      {
        fail ("MTEXT.bg_fill_flag [BL] set+1 %u != %u", mtext->bg_fill_flag, bg_fill_flag); error++;
      }
    mtext->bg_fill_flag--;

  }
  {
    BITCODE_BL bg_fill_scale;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "bg_fill_scale", &bg_fill_scale, NULL) &&
        bg_fill_scale == mtext->bg_fill_scale)
      pass ("MTEXT.bg_fill_scale [BL] %u", bg_fill_scale);
    else
      {
        fail ("MTEXT.bg_fill_scale [BL] %u != %u", mtext->bg_fill_scale, bg_fill_scale); error++;
      }
    bg_fill_scale++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "bg_fill_scale", &bg_fill_scale) &&
        bg_fill_scale == mtext->bg_fill_scale)
      pass ("MTEXT.bg_fill_scale [BL] set+1 %u", bg_fill_scale);
    else
      {
        fail ("MTEXT.bg_fill_scale [BL] set+1 %u != %u", mtext->bg_fill_scale, bg_fill_scale); error++;
      }
    mtext->bg_fill_scale--;

  }
  {
    BITCODE_BL bg_fill_trans;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "bg_fill_trans", &bg_fill_trans, NULL) &&
        bg_fill_trans == mtext->bg_fill_trans)
      pass ("MTEXT.bg_fill_trans [BL] %u", bg_fill_trans);
    else
      {
        fail ("MTEXT.bg_fill_trans [BL] %u != %u", mtext->bg_fill_trans, bg_fill_trans); error++;
      }
    bg_fill_trans++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "bg_fill_trans", &bg_fill_trans) &&
        bg_fill_trans == mtext->bg_fill_trans)
      pass ("MTEXT.bg_fill_trans [BL] set+1 %u", bg_fill_trans);
    else
      {
        fail ("MTEXT.bg_fill_trans [BL] set+1 %u != %u", mtext->bg_fill_trans, bg_fill_trans); error++;
      }
    mtext->bg_fill_trans--;

  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "class_version", &class_version, NULL) &&
        class_version == mtext->class_version)
      pass ("MTEXT.class_version [BS] %hu", class_version);
    else
      {
        fail ("MTEXT.class_version [BS] %hu != %hu", mtext->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "class_version", &class_version) &&
        class_version == mtext->class_version)
      pass ("MTEXT.class_version [BS] set+1 %hu", class_version);
    else
      {
        fail ("MTEXT.class_version [BS] set+1 %hu != %hu", mtext->class_version, class_version); error++;
      }
    mtext->class_version--;

  }
  {
    BITCODE_BD* column_heights;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "column_heights", &column_heights, NULL)
        && !memcmp(&column_heights, &mtext->column_heights, sizeof(mtext->column_heights)))
      pass ("MTEXT.column_heights [BD*]");
    else
      {
        fail ("MTEXT.column_heights [BD*]"); error++;
      }
  }
  {
    BITCODE_BL column_type;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "column_type", &column_type, NULL) &&
        column_type == mtext->column_type)
      pass ("MTEXT.column_type [BL] %u", column_type);
    else
      {
        fail ("MTEXT.column_type [BL] %u != %u", mtext->column_type, column_type); error++;
      }
    column_type++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "column_type", &column_type) &&
        column_type == mtext->column_type)
      pass ("MTEXT.column_type [BL] set+1 %u", column_type);
    else
      {
        fail ("MTEXT.column_type [BL] set+1 %u != %u", mtext->column_type, column_type); error++;
      }
    mtext->column_type--;

  }
  {
    BITCODE_BD column_width;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "column_width", &column_width, NULL) &&
        column_width == mtext->column_width)
      pass ("MTEXT.column_width [BD] %g", column_width);
    else
      {
        fail ("MTEXT.column_width [BD] %g != %g", mtext->column_width, column_width); error++;
      }
    column_width++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "column_width", &column_width) &&
        column_width == mtext->column_width)
      pass ("MTEXT.column_width [BD] set+1 %g", column_width);
    else
      {
        fail ("MTEXT.column_width [BD] set+1 %g != %g", mtext->column_width, column_width); error++;
      }
    mtext->column_width--;

  }
  {
    BITCODE_B default_flag;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "default_flag", &default_flag, NULL) &&
        default_flag == mtext->default_flag)
      pass ("MTEXT.default_flag [B] " FORMAT_B "", default_flag);
    else
      {
        fail ("MTEXT.default_flag [B] " FORMAT_B " != " FORMAT_B "", mtext->default_flag, default_flag); error++;
      }
    default_flag++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "default_flag", &default_flag) &&
        default_flag == mtext->default_flag)
      pass ("MTEXT.default_flag [B] set+1 " FORMAT_B "", default_flag);
    else
      {
        fail ("MTEXT.default_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->default_flag, default_flag); error++;
      }
    mtext->default_flag--;

  }
  {
    BITCODE_BS drawing_dir;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "drawing_dir", &drawing_dir, NULL) &&
        drawing_dir == mtext->drawing_dir)
      pass ("MTEXT.drawing_dir [BS] %hu", drawing_dir);
    else
      {
        fail ("MTEXT.drawing_dir [BS] %hu != %hu", mtext->drawing_dir, drawing_dir); error++;
      }
    drawing_dir++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "drawing_dir", &drawing_dir) &&
        drawing_dir == mtext->drawing_dir)
      pass ("MTEXT.drawing_dir [BS] set+1 %hu", drawing_dir);
    else
      {
        fail ("MTEXT.drawing_dir [BS] set+1 %hu != %hu", mtext->drawing_dir, drawing_dir); error++;
      }
    mtext->drawing_dir--;

  }
  {
    BITCODE_BD extents_height;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "extents_height", &extents_height, NULL) &&
        extents_height == mtext->extents_height)
      pass ("MTEXT.extents_height [BD] %g", extents_height);
    else
      {
        fail ("MTEXT.extents_height [BD] %g != %g", mtext->extents_height, extents_height); error++;
      }
    extents_height++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "extents_height", &extents_height) &&
        extents_height == mtext->extents_height)
      pass ("MTEXT.extents_height [BD] set+1 %g", extents_height);
    else
      {
        fail ("MTEXT.extents_height [BD] set+1 %g != %g", mtext->extents_height, extents_height); error++;
      }
    mtext->extents_height--;

  }
  {
    BITCODE_BD extents_width;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "extents_width", &extents_width, NULL) &&
        extents_width == mtext->extents_width)
      pass ("MTEXT.extents_width [BD] %g", extents_width);
    else
      {
        fail ("MTEXT.extents_width [BD] %g != %g", mtext->extents_width, extents_width); error++;
      }
    extents_width++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "extents_width", &extents_width) &&
        extents_width == mtext->extents_width)
      pass ("MTEXT.extents_width [BD] set+1 %g", extents_width);
    else
      {
        fail ("MTEXT.extents_width [BD] set+1 %g != %g", mtext->extents_width, extents_width); error++;
      }
    mtext->extents_width--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &mtext->extrusion, sizeof(mtext->extrusion)))
      pass ("MTEXT.extrusion [3BD]");
    else
      {
        fail ("MTEXT.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_B flow_reversed;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "flow_reversed", &flow_reversed, NULL) &&
        flow_reversed == mtext->flow_reversed)
      pass ("MTEXT.flow_reversed [B] " FORMAT_B "", flow_reversed);
    else
      {
        fail ("MTEXT.flow_reversed [B] " FORMAT_B " != " FORMAT_B "", mtext->flow_reversed, flow_reversed); error++;
      }
    flow_reversed++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "flow_reversed", &flow_reversed) &&
        flow_reversed == mtext->flow_reversed)
      pass ("MTEXT.flow_reversed [B] set+1 " FORMAT_B "", flow_reversed);
    else
      {
        fail ("MTEXT.flow_reversed [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->flow_reversed, flow_reversed); error++;
      }
    mtext->flow_reversed--;

  }
  {
    BITCODE_BD gutter;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "gutter", &gutter, NULL) &&
        gutter == mtext->gutter)
      pass ("MTEXT.gutter [BD] %g", gutter);
    else
      {
        fail ("MTEXT.gutter [BD] %g != %g", mtext->gutter, gutter); error++;
      }
    gutter++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "gutter", &gutter) &&
        gutter == mtext->gutter)
      pass ("MTEXT.gutter [BD] set+1 %g", gutter);
    else
      {
        fail ("MTEXT.gutter [BD] set+1 %g != %g", mtext->gutter, gutter); error++;
      }
    mtext->gutter--;

  }
  {
    BITCODE_3BD insertion_pt;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &mtext->insertion_pt, sizeof(mtext->insertion_pt)))
      pass ("MTEXT.insertion_pt [3BD]");
    else
      {
        fail ("MTEXT.insertion_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BD linespace_factor;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "linespace_factor", &linespace_factor, NULL) &&
        linespace_factor == mtext->linespace_factor)
      pass ("MTEXT.linespace_factor [BD] %g", linespace_factor);
    else
      {
        fail ("MTEXT.linespace_factor [BD] %g != %g", mtext->linespace_factor, linespace_factor); error++;
      }
    linespace_factor++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "linespace_factor", &linespace_factor) &&
        linespace_factor == mtext->linespace_factor)
      pass ("MTEXT.linespace_factor [BD] set+1 %g", linespace_factor);
    else
      {
        fail ("MTEXT.linespace_factor [BD] set+1 %g != %g", mtext->linespace_factor, linespace_factor); error++;
      }
    mtext->linespace_factor--;

  }
  {
    BITCODE_BS linespace_style;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "linespace_style", &linespace_style, NULL) &&
        linespace_style == mtext->linespace_style)
      pass ("MTEXT.linespace_style [BS] %hu", linespace_style);
    else
      {
        fail ("MTEXT.linespace_style [BS] %hu != %hu", mtext->linespace_style, linespace_style); error++;
      }
    linespace_style++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "linespace_style", &linespace_style) &&
        linespace_style == mtext->linespace_style)
      pass ("MTEXT.linespace_style [BS] set+1 %hu", linespace_style);
    else
      {
        fail ("MTEXT.linespace_style [BS] set+1 %hu != %hu", mtext->linespace_style, linespace_style); error++;
      }
    mtext->linespace_style--;

  }
  {
    BITCODE_BL num_column_heights;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "num_column_heights", &num_column_heights, NULL) &&
        num_column_heights == mtext->num_column_heights)
      pass ("MTEXT.num_column_heights [BL] %u", num_column_heights);
    else
      {
        fail ("MTEXT.num_column_heights [BL] %u != %u", mtext->num_column_heights, num_column_heights); error++;
      }
    num_column_heights++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "num_column_heights", &num_column_heights) &&
        num_column_heights == mtext->num_column_heights)
      pass ("MTEXT.num_column_heights [BL] set+1 %u", num_column_heights);
    else
      {
        fail ("MTEXT.num_column_heights [BL] set+1 %u != %u", mtext->num_column_heights, num_column_heights); error++;
      }
    mtext->num_column_heights--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "parent", &parent, NULL)
        && !memcmp(&parent, &mtext->parent, sizeof(mtext->parent)))
      pass ("MTEXT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("MTEXT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD rect_height;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "rect_height", &rect_height, NULL) &&
        rect_height == mtext->rect_height)
      pass ("MTEXT.rect_height [BD] %g", rect_height);
    else
      {
        fail ("MTEXT.rect_height [BD] %g != %g", mtext->rect_height, rect_height); error++;
      }
    rect_height++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "rect_height", &rect_height) &&
        rect_height == mtext->rect_height)
      pass ("MTEXT.rect_height [BD] set+1 %g", rect_height);
    else
      {
        fail ("MTEXT.rect_height [BD] set+1 %g != %g", mtext->rect_height, rect_height); error++;
      }
    mtext->rect_height--;

  }
  {
    BITCODE_BD rect_width;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "rect_width", &rect_width, NULL) &&
        rect_width == mtext->rect_width)
      pass ("MTEXT.rect_width [BD] %g", rect_width);
    else
      {
        fail ("MTEXT.rect_width [BD] %g != %g", mtext->rect_width, rect_width); error++;
      }
    rect_width++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "rect_width", &rect_width) &&
        rect_width == mtext->rect_width)
      pass ("MTEXT.rect_width [BD] set+1 %g", rect_width);
    else
      {
        fail ("MTEXT.rect_width [BD] set+1 %g != %g", mtext->rect_width, rect_width); error++;
      }
    mtext->rect_width--;

  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "style", &style, NULL)
        && !memcmp(&style, &mtext->style, sizeof(mtext->style)))
      pass ("MTEXT.style [H]");
    else
      {
        fail ("MTEXT.style [H]"); error++;
      }
  }
  {
    BITCODE_TV text;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "text", &text, NULL)
        && !strcmp((char*)&text, (char*)&mtext->text))
      pass ("MTEXT.text [TV]");
    else
      {
        fail ("MTEXT.text [TV]"); error++;
      }
  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "text_height", &text_height, NULL) &&
        text_height == mtext->text_height)
      pass ("MTEXT.text_height [BD] %g", text_height);
    else
      {
        fail ("MTEXT.text_height [BD] %g != %g", mtext->text_height, text_height); error++;
      }
    text_height++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "text_height", &text_height) &&
        text_height == mtext->text_height)
      pass ("MTEXT.text_height [BD] set+1 %g", text_height);
    else
      {
        fail ("MTEXT.text_height [BD] set+1 %g != %g", mtext->text_height, text_height); error++;
      }
    mtext->text_height--;

  }
  {
    BITCODE_B unknown_bit;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "unknown_bit", &unknown_bit, NULL) &&
        unknown_bit == mtext->unknown_bit)
      pass ("MTEXT.unknown_bit [B] " FORMAT_B "", unknown_bit);
    else
      {
        fail ("MTEXT.unknown_bit [B] " FORMAT_B " != " FORMAT_B "", mtext->unknown_bit, unknown_bit); error++;
      }
    unknown_bit++;
    if (dwg_dynapi_entity_set_value(mtext, "MTEXT", "unknown_bit", &unknown_bit) &&
        unknown_bit == mtext->unknown_bit)
      pass ("MTEXT.unknown_bit [B] set+1 " FORMAT_B "", unknown_bit);
    else
      {
        fail ("MTEXT.unknown_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->unknown_bit, unknown_bit); error++;
      }
    mtext->unknown_bit--;

  }
  {
    BITCODE_3BD x_axis_dir;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "x_axis_dir", &x_axis_dir, NULL)
        && !memcmp(&x_axis_dir, &mtext->x_axis_dir, sizeof(mtext->x_axis_dir)))
      pass ("MTEXT.x_axis_dir [3BD]");
    else
      {
        fail ("MTEXT.x_axis_dir [3BD]"); error++;
      }
  }
  return error;
}
static int test_MULTILEADER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_MULTILEADER *multileader = obj->tio.entity->tio.MULTILEADER;
  {
    BITCODE_H arrow_handle;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "arrow_handle", &arrow_handle, NULL)
        && !memcmp(&arrow_handle, &multileader->arrow_handle, sizeof(multileader->arrow_handle)))
      pass ("MULTILEADER.arrow_handle [H]");
    else
      {
        fail ("MULTILEADER.arrow_handle [H]"); error++;
      }
  }
  {
    BITCODE_BD arrow_size;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "arrow_size", &arrow_size, NULL) &&
        arrow_size == multileader->arrow_size)
      pass ("MULTILEADER.arrow_size [BD] %g", arrow_size);
    else
      {
        fail ("MULTILEADER.arrow_size [BD] %g != %g", multileader->arrow_size, arrow_size); error++;
      }
    arrow_size++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "arrow_size", &arrow_size) &&
        arrow_size == multileader->arrow_size)
      pass ("MULTILEADER.arrow_size [BD] set+1 %g", arrow_size);
    else
      {
        fail ("MULTILEADER.arrow_size [BD] set+1 %g != %g", multileader->arrow_size, arrow_size); error++;
      }
    multileader->arrow_size--;

  }
  {
    Dwg_LEADER_ArrowHead* arrowheads;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "arrowheads", &arrowheads, NULL)
        && !memcmp(&arrowheads, &multileader->arrowheads, sizeof(multileader->arrowheads)))
      pass ("MULTILEADER.arrowheads [Dwg_LEADER_ArrowHead*]");
    else
      {
        fail ("MULTILEADER.arrowheads [Dwg_LEADER_ArrowHead*]"); error++;
      }
  }
  {
    BITCODE_BS attach_bottom;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "attach_bottom", &attach_bottom, NULL) &&
        attach_bottom == multileader->attach_bottom)
      pass ("MULTILEADER.attach_bottom [BS] %hu", attach_bottom);
    else
      {
        fail ("MULTILEADER.attach_bottom [BS] %hu != %hu", multileader->attach_bottom, attach_bottom); error++;
      }
    attach_bottom++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "attach_bottom", &attach_bottom) &&
        attach_bottom == multileader->attach_bottom)
      pass ("MULTILEADER.attach_bottom [BS] set+1 %hu", attach_bottom);
    else
      {
        fail ("MULTILEADER.attach_bottom [BS] set+1 %hu != %hu", multileader->attach_bottom, attach_bottom); error++;
      }
    multileader->attach_bottom--;

  }
  {
    BITCODE_BS attach_dir;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "attach_dir", &attach_dir, NULL) &&
        attach_dir == multileader->attach_dir)
      pass ("MULTILEADER.attach_dir [BS] %hu", attach_dir);
    else
      {
        fail ("MULTILEADER.attach_dir [BS] %hu != %hu", multileader->attach_dir, attach_dir); error++;
      }
    attach_dir++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "attach_dir", &attach_dir) &&
        attach_dir == multileader->attach_dir)
      pass ("MULTILEADER.attach_dir [BS] set+1 %hu", attach_dir);
    else
      {
        fail ("MULTILEADER.attach_dir [BS] set+1 %hu != %hu", multileader->attach_dir, attach_dir); error++;
      }
    multileader->attach_dir--;

  }
  {
    BITCODE_BS attach_top;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "attach_top", &attach_top, NULL) &&
        attach_top == multileader->attach_top)
      pass ("MULTILEADER.attach_top [BS] %hu", attach_top);
    else
      {
        fail ("MULTILEADER.attach_top [BS] %hu != %hu", multileader->attach_top, attach_top); error++;
      }
    attach_top++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "attach_top", &attach_top) &&
        attach_top == multileader->attach_top)
      pass ("MULTILEADER.attach_top [BS] set+1 %hu", attach_top);
    else
      {
        fail ("MULTILEADER.attach_top [BS] set+1 %hu != %hu", multileader->attach_top, attach_top); error++;
      }
    multileader->attach_top--;

  }
  {
    BITCODE_BS attach_type;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "attach_type", &attach_type, NULL) &&
        attach_type == multileader->attach_type)
      pass ("MULTILEADER.attach_type [BS] %hu", attach_type);
    else
      {
        fail ("MULTILEADER.attach_type [BS] %hu != %hu", multileader->attach_type, attach_type); error++;
      }
    attach_type++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "attach_type", &attach_type) &&
        attach_type == multileader->attach_type)
      pass ("MULTILEADER.attach_type [BS] set+1 %hu", attach_type);
    else
      {
        fail ("MULTILEADER.attach_type [BS] set+1 %hu != %hu", multileader->attach_type, attach_type); error++;
      }
    multileader->attach_type--;

  }
  {
    BITCODE_CMC block_color;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "block_color", &block_color, NULL)
        && !memcmp(&block_color, &multileader->block_color, sizeof(multileader->block_color)))
      pass ("MULTILEADER.block_color [CMC]");
    else
      {
        fail ("MULTILEADER.block_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD block_rotation;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "block_rotation", &block_rotation, NULL) &&
        block_rotation == multileader->block_rotation)
      pass ("MULTILEADER.block_rotation [BD] %g", block_rotation);
    else
      {
        fail ("MULTILEADER.block_rotation [BD] %g != %g", multileader->block_rotation, block_rotation); error++;
      }
    block_rotation++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "block_rotation", &block_rotation) &&
        block_rotation == multileader->block_rotation)
      pass ("MULTILEADER.block_rotation [BD] set+1 %g", block_rotation);
    else
      {
        fail ("MULTILEADER.block_rotation [BD] set+1 %g != %g", multileader->block_rotation, block_rotation); error++;
      }
    multileader->block_rotation--;

  }
  {
    BITCODE_3BD block_scale;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "block_scale", &block_scale, NULL)
        && !memcmp(&block_scale, &multileader->block_scale, sizeof(multileader->block_scale)))
      pass ("MULTILEADER.block_scale [3BD]");
    else
      {
        fail ("MULTILEADER.block_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_H block_style;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "block_style", &block_style, NULL)
        && !memcmp(&block_style, &multileader->block_style, sizeof(multileader->block_style)))
      pass ("MULTILEADER.block_style [H]");
    else
      {
        fail ("MULTILEADER.block_style [H]"); error++;
      }
  }
  {
    Dwg_LEADER_BlockLabel* blocklabels;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "blocklabels", &blocklabels, NULL)
        && !memcmp(&blocklabels, &multileader->blocklabels, sizeof(multileader->blocklabels)))
      pass ("MULTILEADER.blocklabels [Dwg_LEADER_BlockLabel*]");
    else
      {
        fail ("MULTILEADER.blocklabels [Dwg_LEADER_BlockLabel*]"); error++;
      }
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "class_version", &class_version, NULL) &&
        class_version == multileader->class_version)
      pass ("MULTILEADER.class_version [BS] %hu", class_version);
    else
      {
        fail ("MULTILEADER.class_version [BS] %hu != %hu", multileader->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "class_version", &class_version) &&
        class_version == multileader->class_version)
      pass ("MULTILEADER.class_version [BS] set+1 %hu", class_version);
    else
      {
        fail ("MULTILEADER.class_version [BS] set+1 %hu != %hu", multileader->class_version, class_version); error++;
      }
    multileader->class_version--;

  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "color", &color, NULL)
        && !memcmp(&color, &multileader->color, sizeof(multileader->color)))
      pass ("MULTILEADER.color [CMC]");
    else
      {
        fail ("MULTILEADER.color [CMC]"); error++;
      }
  }
  {
    Dwg_MLEADER_AnnotContext ctx;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "ctx", &ctx, NULL)
        && !memcmp(&ctx, &multileader->ctx, sizeof(multileader->ctx)))
      pass ("MULTILEADER.ctx [Dwg_MLEADER_AnnotContext]");
    else
      {
        fail ("MULTILEADER.ctx [Dwg_MLEADER_AnnotContext]"); error++;
      }
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "flags", &flags, NULL) &&
        flags == multileader->flags)
      pass ("MULTILEADER.flags [BL] %u", flags);
    else
      {
        fail ("MULTILEADER.flags [BL] %u != %u", multileader->flags, flags); error++;
      }
    flags++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "flags", &flags) &&
        flags == multileader->flags)
      pass ("MULTILEADER.flags [BL] set+1 %u", flags);
    else
      {
        fail ("MULTILEADER.flags [BL] set+1 %u != %u", multileader->flags, flags); error++;
      }
    multileader->flags--;

  }
  {
    BITCODE_B has_dogleg;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "has_dogleg", &has_dogleg, NULL) &&
        has_dogleg == multileader->has_dogleg)
      pass ("MULTILEADER.has_dogleg [B] " FORMAT_B "", has_dogleg);
    else
      {
        fail ("MULTILEADER.has_dogleg [B] " FORMAT_B " != " FORMAT_B "", multileader->has_dogleg, has_dogleg); error++;
      }
    has_dogleg++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "has_dogleg", &has_dogleg) &&
        has_dogleg == multileader->has_dogleg)
      pass ("MULTILEADER.has_dogleg [B] set+1 " FORMAT_B "", has_dogleg);
    else
      {
        fail ("MULTILEADER.has_dogleg [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_dogleg, has_dogleg); error++;
      }
    multileader->has_dogleg--;

  }
  {
    BITCODE_B has_landing;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "has_landing", &has_landing, NULL) &&
        has_landing == multileader->has_landing)
      pass ("MULTILEADER.has_landing [B] " FORMAT_B "", has_landing);
    else
      {
        fail ("MULTILEADER.has_landing [B] " FORMAT_B " != " FORMAT_B "", multileader->has_landing, has_landing); error++;
      }
    has_landing++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "has_landing", &has_landing) &&
        has_landing == multileader->has_landing)
      pass ("MULTILEADER.has_landing [B] set+1 " FORMAT_B "", has_landing);
    else
      {
        fail ("MULTILEADER.has_landing [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_landing, has_landing); error++;
      }
    multileader->has_landing--;

  }
  {
    BITCODE_B has_text_frame;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "has_text_frame", &has_text_frame, NULL) &&
        has_text_frame == multileader->has_text_frame)
      pass ("MULTILEADER.has_text_frame [B] " FORMAT_B "", has_text_frame);
    else
      {
        fail ("MULTILEADER.has_text_frame [B] " FORMAT_B " != " FORMAT_B "", multileader->has_text_frame, has_text_frame); error++;
      }
    has_text_frame++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "has_text_frame", &has_text_frame) &&
        has_text_frame == multileader->has_text_frame)
      pass ("MULTILEADER.has_text_frame [B] set+1 " FORMAT_B "", has_text_frame);
    else
      {
        fail ("MULTILEADER.has_text_frame [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_text_frame, has_text_frame); error++;
      }
    multileader->has_text_frame--;

  }
  {
    BITCODE_BS ipe_alignment;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "ipe_alignment", &ipe_alignment, NULL) &&
        ipe_alignment == multileader->ipe_alignment)
      pass ("MULTILEADER.ipe_alignment [BS] %hu", ipe_alignment);
    else
      {
        fail ("MULTILEADER.ipe_alignment [BS] %hu != %hu", multileader->ipe_alignment, ipe_alignment); error++;
      }
    ipe_alignment++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "ipe_alignment", &ipe_alignment) &&
        ipe_alignment == multileader->ipe_alignment)
      pass ("MULTILEADER.ipe_alignment [BS] set+1 %hu", ipe_alignment);
    else
      {
        fail ("MULTILEADER.ipe_alignment [BS] set+1 %hu != %hu", multileader->ipe_alignment, ipe_alignment); error++;
      }
    multileader->ipe_alignment--;

  }
  {
    BITCODE_B is_annotative;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "is_annotative", &is_annotative, NULL) &&
        is_annotative == multileader->is_annotative)
      pass ("MULTILEADER.is_annotative [B] " FORMAT_B "", is_annotative);
    else
      {
        fail ("MULTILEADER.is_annotative [B] " FORMAT_B " != " FORMAT_B "", multileader->is_annotative, is_annotative); error++;
      }
    is_annotative++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "is_annotative", &is_annotative) &&
        is_annotative == multileader->is_annotative)
      pass ("MULTILEADER.is_annotative [B] set+1 " FORMAT_B "", is_annotative);
    else
      {
        fail ("MULTILEADER.is_annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->is_annotative, is_annotative); error++;
      }
    multileader->is_annotative--;

  }
  {
    BITCODE_BS justification;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "justification", &justification, NULL) &&
        justification == multileader->justification)
      pass ("MULTILEADER.justification [BS] %hu", justification);
    else
      {
        fail ("MULTILEADER.justification [BS] %hu != %hu", multileader->justification, justification); error++;
      }
    justification++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "justification", &justification) &&
        justification == multileader->justification)
      pass ("MULTILEADER.justification [BS] set+1 %hu", justification);
    else
      {
        fail ("MULTILEADER.justification [BS] set+1 %hu != %hu", multileader->justification, justification); error++;
      }
    multileader->justification--;

  }
  {
    BITCODE_BD landing_dist;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "landing_dist", &landing_dist, NULL) &&
        landing_dist == multileader->landing_dist)
      pass ("MULTILEADER.landing_dist [BD] %g", landing_dist);
    else
      {
        fail ("MULTILEADER.landing_dist [BD] %g != %g", multileader->landing_dist, landing_dist); error++;
      }
    landing_dist++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "landing_dist", &landing_dist) &&
        landing_dist == multileader->landing_dist)
      pass ("MULTILEADER.landing_dist [BD] set+1 %g", landing_dist);
    else
      {
        fail ("MULTILEADER.landing_dist [BD] set+1 %g != %g", multileader->landing_dist, landing_dist); error++;
      }
    multileader->landing_dist--;

  }
  {
    BITCODE_BL linewt;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "linewt", &linewt, NULL) &&
        linewt == multileader->linewt)
      pass ("MULTILEADER.linewt [BL] %u", linewt);
    else
      {
        fail ("MULTILEADER.linewt [BL] %u != %u", multileader->linewt, linewt); error++;
      }
    linewt++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "linewt", &linewt) &&
        linewt == multileader->linewt)
      pass ("MULTILEADER.linewt [BL] set+1 %u", linewt);
    else
      {
        fail ("MULTILEADER.linewt [BL] set+1 %u != %u", multileader->linewt, linewt); error++;
      }
    multileader->linewt--;

  }
  {
    BITCODE_H ltype;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "ltype", &ltype, NULL)
        && !memcmp(&ltype, &multileader->ltype, sizeof(multileader->ltype)))
      pass ("MULTILEADER.ltype [H]");
    else
      {
        fail ("MULTILEADER.ltype [H]"); error++;
      }
  }
  {
    BITCODE_H mleaderstyle;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "mleaderstyle", &mleaderstyle, NULL)
        && !memcmp(&mleaderstyle, &multileader->mleaderstyle, sizeof(multileader->mleaderstyle)))
      pass ("MULTILEADER.mleaderstyle [H]");
    else
      {
        fail ("MULTILEADER.mleaderstyle [H]"); error++;
      }
  }
  {
    BITCODE_B neg_textdir;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "neg_textdir", &neg_textdir, NULL) &&
        neg_textdir == multileader->neg_textdir)
      pass ("MULTILEADER.neg_textdir [B] " FORMAT_B "", neg_textdir);
    else
      {
        fail ("MULTILEADER.neg_textdir [B] " FORMAT_B " != " FORMAT_B "", multileader->neg_textdir, neg_textdir); error++;
      }
    neg_textdir++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "neg_textdir", &neg_textdir) &&
        neg_textdir == multileader->neg_textdir)
      pass ("MULTILEADER.neg_textdir [B] set+1 " FORMAT_B "", neg_textdir);
    else
      {
        fail ("MULTILEADER.neg_textdir [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->neg_textdir, neg_textdir); error++;
      }
    multileader->neg_textdir--;

  }
  {
    BITCODE_BL num_arrowheads;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "num_arrowheads", &num_arrowheads, NULL) &&
        num_arrowheads == multileader->num_arrowheads)
      pass ("MULTILEADER.num_arrowheads [BL] %u", num_arrowheads);
    else
      {
        fail ("MULTILEADER.num_arrowheads [BL] %u != %u", multileader->num_arrowheads, num_arrowheads); error++;
      }
    num_arrowheads++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "num_arrowheads", &num_arrowheads) &&
        num_arrowheads == multileader->num_arrowheads)
      pass ("MULTILEADER.num_arrowheads [BL] set+1 %u", num_arrowheads);
    else
      {
        fail ("MULTILEADER.num_arrowheads [BL] set+1 %u != %u", multileader->num_arrowheads, num_arrowheads); error++;
      }
    multileader->num_arrowheads--;

  }
  {
    BITCODE_BL num_blocklabels;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "num_blocklabels", &num_blocklabels, NULL) &&
        num_blocklabels == multileader->num_blocklabels)
      pass ("MULTILEADER.num_blocklabels [BL] %u", num_blocklabels);
    else
      {
        fail ("MULTILEADER.num_blocklabels [BL] %u != %u", multileader->num_blocklabels, num_blocklabels); error++;
      }
    num_blocklabels++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "num_blocklabels", &num_blocklabels) &&
        num_blocklabels == multileader->num_blocklabels)
      pass ("MULTILEADER.num_blocklabels [BL] set+1 %u", num_blocklabels);
    else
      {
        fail ("MULTILEADER.num_blocklabels [BL] set+1 %u != %u", multileader->num_blocklabels, num_blocklabels); error++;
      }
    multileader->num_blocklabels--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "parent", &parent, NULL)
        && !memcmp(&parent, &multileader->parent, sizeof(multileader->parent)))
      pass ("MULTILEADER.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("MULTILEADER.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "scale_factor", &scale_factor, NULL) &&
        scale_factor == multileader->scale_factor)
      pass ("MULTILEADER.scale_factor [BD] %g", scale_factor);
    else
      {
        fail ("MULTILEADER.scale_factor [BD] %g != %g", multileader->scale_factor, scale_factor); error++;
      }
    scale_factor++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "scale_factor", &scale_factor) &&
        scale_factor == multileader->scale_factor)
      pass ("MULTILEADER.scale_factor [BD] set+1 %g", scale_factor);
    else
      {
        fail ("MULTILEADER.scale_factor [BD] set+1 %g != %g", multileader->scale_factor, scale_factor); error++;
      }
    multileader->scale_factor--;

  }
  {
    BITCODE_BS style_attachment;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "style_attachment", &style_attachment, NULL) &&
        style_attachment == multileader->style_attachment)
      pass ("MULTILEADER.style_attachment [BS] %hu", style_attachment);
    else
      {
        fail ("MULTILEADER.style_attachment [BS] %hu != %hu", multileader->style_attachment, style_attachment); error++;
      }
    style_attachment++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "style_attachment", &style_attachment) &&
        style_attachment == multileader->style_attachment)
      pass ("MULTILEADER.style_attachment [BS] set+1 %hu", style_attachment);
    else
      {
        fail ("MULTILEADER.style_attachment [BS] set+1 %hu != %hu", multileader->style_attachment, style_attachment); error++;
      }
    multileader->style_attachment--;

  }
  {
    BITCODE_BS style_content;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "style_content", &style_content, NULL) &&
        style_content == multileader->style_content)
      pass ("MULTILEADER.style_content [BS] %hu", style_content);
    else
      {
        fail ("MULTILEADER.style_content [BS] %hu != %hu", multileader->style_content, style_content); error++;
      }
    style_content++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "style_content", &style_content) &&
        style_content == multileader->style_content)
      pass ("MULTILEADER.style_content [BS] set+1 %hu", style_content);
    else
      {
        fail ("MULTILEADER.style_content [BS] set+1 %hu != %hu", multileader->style_content, style_content); error++;
      }
    multileader->style_content--;

  }
  {
    BITCODE_BS text_angletype;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_angletype", &text_angletype, NULL) &&
        text_angletype == multileader->text_angletype)
      pass ("MULTILEADER.text_angletype [BS] %hu", text_angletype);
    else
      {
        fail ("MULTILEADER.text_angletype [BS] %hu != %hu", multileader->text_angletype, text_angletype); error++;
      }
    text_angletype++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "text_angletype", &text_angletype) &&
        text_angletype == multileader->text_angletype)
      pass ("MULTILEADER.text_angletype [BS] set+1 %hu", text_angletype);
    else
      {
        fail ("MULTILEADER.text_angletype [BS] set+1 %hu != %hu", multileader->text_angletype, text_angletype); error++;
      }
    multileader->text_angletype--;

  }
  {
    BITCODE_CMC text_color;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_color", &text_color, NULL)
        && !memcmp(&text_color, &multileader->text_color, sizeof(multileader->text_color)))
      pass ("MULTILEADER.text_color [CMC]");
    else
      {
        fail ("MULTILEADER.text_color [CMC]"); error++;
      }
  }
  {
    BITCODE_B text_extended;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_extended", &text_extended, NULL) &&
        text_extended == multileader->text_extended)
      pass ("MULTILEADER.text_extended [B] " FORMAT_B "", text_extended);
    else
      {
        fail ("MULTILEADER.text_extended [B] " FORMAT_B " != " FORMAT_B "", multileader->text_extended, text_extended); error++;
      }
    text_extended++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "text_extended", &text_extended) &&
        text_extended == multileader->text_extended)
      pass ("MULTILEADER.text_extended [B] set+1 " FORMAT_B "", text_extended);
    else
      {
        fail ("MULTILEADER.text_extended [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->text_extended, text_extended); error++;
      }
    multileader->text_extended--;

  }
  {
    BITCODE_BS text_left;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_left", &text_left, NULL) &&
        text_left == multileader->text_left)
      pass ("MULTILEADER.text_left [BS] %hu", text_left);
    else
      {
        fail ("MULTILEADER.text_left [BS] %hu != %hu", multileader->text_left, text_left); error++;
      }
    text_left++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "text_left", &text_left) &&
        text_left == multileader->text_left)
      pass ("MULTILEADER.text_left [BS] set+1 %hu", text_left);
    else
      {
        fail ("MULTILEADER.text_left [BS] set+1 %hu != %hu", multileader->text_left, text_left); error++;
      }
    multileader->text_left--;

  }
  {
    BITCODE_BS text_right;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_right", &text_right, NULL) &&
        text_right == multileader->text_right)
      pass ("MULTILEADER.text_right [BS] %hu", text_right);
    else
      {
        fail ("MULTILEADER.text_right [BS] %hu != %hu", multileader->text_right, text_right); error++;
      }
    text_right++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "text_right", &text_right) &&
        text_right == multileader->text_right)
      pass ("MULTILEADER.text_right [BS] set+1 %hu", text_right);
    else
      {
        fail ("MULTILEADER.text_right [BS] set+1 %hu != %hu", multileader->text_right, text_right); error++;
      }
    multileader->text_right--;

  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_style", &text_style, NULL)
        && !memcmp(&text_style, &multileader->text_style, sizeof(multileader->text_style)))
      pass ("MULTILEADER.text_style [H]");
    else
      {
        fail ("MULTILEADER.text_style [H]"); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "type", &type, NULL) &&
        type == multileader->type)
      pass ("MULTILEADER.type [BS] %hu", type);
    else
      {
        fail ("MULTILEADER.type [BS] %hu != %hu", multileader->type, type); error++;
      }
    type++;
    if (dwg_dynapi_entity_set_value(multileader, "MULTILEADER", "type", &type) &&
        type == multileader->type)
      pass ("MULTILEADER.type [BS] set+1 %hu", type);
    else
      {
        fail ("MULTILEADER.type [BS] set+1 %hu != %hu", multileader->type, type); error++;
      }
    multileader->type--;

  }
  return error;
}
static int test_OLE2FRAME (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_OLE2FRAME *ole2frame = obj->tio.entity->tio.OLE2FRAME;
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "data", &data, NULL)
        && !strcmp((char*)&data, (char*)&ole2frame->data))
      pass ("OLE2FRAME.data [TV]");
    else
      {
        fail ("OLE2FRAME.data [TV]"); error++;
      }
  }
  {
    BITCODE_BL data_length;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "data_length", &data_length, NULL) &&
        data_length == ole2frame->data_length)
      pass ("OLE2FRAME.data_length [BL] %u", data_length);
    else
      {
        fail ("OLE2FRAME.data_length [BL] %u != %u", ole2frame->data_length, data_length); error++;
      }
    data_length++;
    if (dwg_dynapi_entity_set_value(ole2frame, "OLE2FRAME", "data_length", &data_length) &&
        data_length == ole2frame->data_length)
      pass ("OLE2FRAME.data_length [BL] set+1 %u", data_length);
    else
      {
        fail ("OLE2FRAME.data_length [BL] set+1 %u != %u", ole2frame->data_length, data_length); error++;
      }
    ole2frame->data_length--;

  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "flag", &flag, NULL) &&
        flag == ole2frame->flag)
      pass ("OLE2FRAME.flag [BS] %hu", flag);
    else
      {
        fail ("OLE2FRAME.flag [BS] %hu != %hu", ole2frame->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(ole2frame, "OLE2FRAME", "flag", &flag) &&
        flag == ole2frame->flag)
      pass ("OLE2FRAME.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("OLE2FRAME.flag [BS] set+1 %hu != %hu", ole2frame->flag, flag); error++;
      }
    ole2frame->flag--;

  }
  {
    BITCODE_BS mode;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "mode", &mode, NULL) &&
        mode == ole2frame->mode)
      pass ("OLE2FRAME.mode [BS] %hu", mode);
    else
      {
        fail ("OLE2FRAME.mode [BS] %hu != %hu", ole2frame->mode, mode); error++;
      }
    mode++;
    if (dwg_dynapi_entity_set_value(ole2frame, "OLE2FRAME", "mode", &mode) &&
        mode == ole2frame->mode)
      pass ("OLE2FRAME.mode [BS] set+1 %hu", mode);
    else
      {
        fail ("OLE2FRAME.mode [BS] set+1 %hu != %hu", ole2frame->mode, mode); error++;
      }
    ole2frame->mode--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "parent", &parent, NULL)
        && !memcmp(&parent, &ole2frame->parent, sizeof(ole2frame->parent)))
      pass ("OLE2FRAME.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("OLE2FRAME.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "unknown", &unknown, NULL) &&
        unknown == ole2frame->unknown)
      pass ("OLE2FRAME.unknown [RC] %u", unknown);
    else
      {
        fail ("OLE2FRAME.unknown [RC] %u != %u", ole2frame->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(ole2frame, "OLE2FRAME", "unknown", &unknown) &&
        unknown == ole2frame->unknown)
      pass ("OLE2FRAME.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("OLE2FRAME.unknown [RC] set+1 %u != %u", ole2frame->unknown, unknown); error++;
      }
    ole2frame->unknown--;

  }
  return error;
}
static int test_OLEFRAME (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_OLEFRAME *oleframe = obj->tio.entity->tio.OLEFRAME;
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "data", &data, NULL)
        && !strcmp((char*)&data, (char*)&oleframe->data))
      pass ("OLEFRAME.data [TV]");
    else
      {
        fail ("OLEFRAME.data [TV]"); error++;
      }
  }
  {
    BITCODE_BL data_length;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "data_length", &data_length, NULL) &&
        data_length == oleframe->data_length)
      pass ("OLEFRAME.data_length [BL] %u", data_length);
    else
      {
        fail ("OLEFRAME.data_length [BL] %u != %u", oleframe->data_length, data_length); error++;
      }
    data_length++;
    if (dwg_dynapi_entity_set_value(oleframe, "OLEFRAME", "data_length", &data_length) &&
        data_length == oleframe->data_length)
      pass ("OLEFRAME.data_length [BL] set+1 %u", data_length);
    else
      {
        fail ("OLEFRAME.data_length [BL] set+1 %u != %u", oleframe->data_length, data_length); error++;
      }
    oleframe->data_length--;

  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "flag", &flag, NULL) &&
        flag == oleframe->flag)
      pass ("OLEFRAME.flag [BS] %hu", flag);
    else
      {
        fail ("OLEFRAME.flag [BS] %hu != %hu", oleframe->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(oleframe, "OLEFRAME", "flag", &flag) &&
        flag == oleframe->flag)
      pass ("OLEFRAME.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("OLEFRAME.flag [BS] set+1 %hu != %hu", oleframe->flag, flag); error++;
      }
    oleframe->flag--;

  }
  {
    BITCODE_BS mode;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "mode", &mode, NULL) &&
        mode == oleframe->mode)
      pass ("OLEFRAME.mode [BS] %hu", mode);
    else
      {
        fail ("OLEFRAME.mode [BS] %hu != %hu", oleframe->mode, mode); error++;
      }
    mode++;
    if (dwg_dynapi_entity_set_value(oleframe, "OLEFRAME", "mode", &mode) &&
        mode == oleframe->mode)
      pass ("OLEFRAME.mode [BS] set+1 %hu", mode);
    else
      {
        fail ("OLEFRAME.mode [BS] set+1 %hu != %hu", oleframe->mode, mode); error++;
      }
    oleframe->mode--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "parent", &parent, NULL)
        && !memcmp(&parent, &oleframe->parent, sizeof(oleframe->parent)))
      pass ("OLEFRAME.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("OLEFRAME.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  return error;
}
static int test_PLANESURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_PLANESURFACE *planesurface = obj->tio.entity->tio.PLANESURFACE;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&planesurface->acis_data))
      pass ("PLANESURFACE.acis_data [RC*]");
    else
      {
        fail ("PLANESURFACE.acis_data [RC*]"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == planesurface->acis_empty)
      pass ("PLANESURFACE.acis_empty [RC] %u", acis_empty);
    else
      {
        fail ("PLANESURFACE.acis_empty [RC] %u != %u", planesurface->acis_empty, acis_empty); error++;
      }
    acis_empty++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "acis_empty", &acis_empty) &&
        acis_empty == planesurface->acis_empty)
      pass ("PLANESURFACE.acis_empty [RC] set+1 %u", acis_empty);
    else
      {
        fail ("PLANESURFACE.acis_empty [RC] set+1 %u != %u", planesurface->acis_empty, acis_empty); error++;
      }
    planesurface->acis_empty--;

  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == planesurface->acis_empty2)
      pass ("PLANESURFACE.acis_empty2 [RC] %u", acis_empty2);
    else
      {
        fail ("PLANESURFACE.acis_empty2 [RC] %u != %u", planesurface->acis_empty2, acis_empty2); error++;
      }
    acis_empty2++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2) &&
        acis_empty2 == planesurface->acis_empty2)
      pass ("PLANESURFACE.acis_empty2 [RC] set+1 %u", acis_empty2);
    else
      {
        fail ("PLANESURFACE.acis_empty2 [RC] set+1 %u != %u", planesurface->acis_empty2, acis_empty2); error++;
      }
    planesurface->acis_empty2--;

  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == planesurface->acis_empty_bit)
      pass ("PLANESURFACE.acis_empty_bit [RC] %u", acis_empty_bit);
    else
      {
        fail ("PLANESURFACE.acis_empty_bit [RC] %u != %u", planesurface->acis_empty_bit, acis_empty_bit); error++;
      }
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit) &&
        acis_empty_bit == planesurface->acis_empty_bit)
      pass ("PLANESURFACE.acis_empty_bit [RC] set+1 %u", acis_empty_bit);
    else
      {
        fail ("PLANESURFACE.acis_empty_bit [RC] set+1 %u != %u", planesurface->acis_empty_bit, acis_empty_bit); error++;
      }
    planesurface->acis_empty_bit--;

  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &planesurface->block_size, sizeof(planesurface->block_size)))
      pass ("PLANESURFACE.block_size [BL*]");
    else
      {
        fail ("PLANESURFACE.block_size [BL*]"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "class_version", &class_version, NULL) &&
        class_version == planesurface->class_version)
      pass ("PLANESURFACE.class_version [BL] %u", class_version);
    else
      {
        fail ("PLANESURFACE.class_version [BL] %u != %u", planesurface->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "class_version", &class_version) &&
        class_version == planesurface->class_version)
      pass ("PLANESURFACE.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("PLANESURFACE.class_version [BL] set+1 %u != %u", planesurface->class_version, class_version); error++;
      }
    planesurface->class_version--;

  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&planesurface->encr_sat_data))
      pass ("PLANESURFACE.encr_sat_data [TV]");
    else
      {
        fail ("PLANESURFACE.encr_sat_data [TV]"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &planesurface->extra_acis_data, sizeof(planesurface->extra_acis_data)))
      pass ("PLANESURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
    else
      {
        fail ("PLANESURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]"); error++;
      }
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &planesurface->history_id, sizeof(planesurface->history_id)))
      pass ("PLANESURFACE.history_id [H]");
    else
      {
        fail ("PLANESURFACE.history_id [H]"); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == planesurface->isoline_present)
      pass ("PLANESURFACE.isoline_present [RC] %u", isoline_present);
    else
      {
        fail ("PLANESURFACE.isoline_present [RC] %u != %u", planesurface->isoline_present, isoline_present); error++;
      }
    isoline_present++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "isoline_present", &isoline_present) &&
        isoline_present == planesurface->isoline_present)
      pass ("PLANESURFACE.isoline_present [RC] set+1 %u", isoline_present);
    else
      {
        fail ("PLANESURFACE.isoline_present [RC] set+1 %u != %u", planesurface->isoline_present, isoline_present); error++;
      }
    planesurface->isoline_present--;

  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == planesurface->modeler_format_version)
      pass ("PLANESURFACE.modeler_format_version [BS] %hu", modeler_format_version);
    else
      {
        fail ("PLANESURFACE.modeler_format_version [BS] %hu != %hu", planesurface->modeler_format_version, modeler_format_version); error++;
      }
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version) &&
        modeler_format_version == planesurface->modeler_format_version)
      pass ("PLANESURFACE.modeler_format_version [BS] set+1 %hu", modeler_format_version);
    else
      {
        fail ("PLANESURFACE.modeler_format_version [BS] set+1 %hu != %hu", planesurface->modeler_format_version, modeler_format_version); error++;
      }
    planesurface->modeler_format_version--;

  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == planesurface->num_blocks)
      pass ("PLANESURFACE.num_blocks [BL] %u", num_blocks);
    else
      {
        fail ("PLANESURFACE.num_blocks [BL] %u != %u", planesurface->num_blocks, num_blocks); error++;
      }
    num_blocks++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "num_blocks", &num_blocks) &&
        num_blocks == planesurface->num_blocks)
      pass ("PLANESURFACE.num_blocks [BL] set+1 %u", num_blocks);
    else
      {
        fail ("PLANESURFACE.num_blocks [BL] set+1 %u != %u", planesurface->num_blocks, num_blocks); error++;
      }
    planesurface->num_blocks--;

  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == planesurface->num_isolines)
      pass ("PLANESURFACE.num_isolines [BL] %u", num_isolines);
    else
      {
        fail ("PLANESURFACE.num_isolines [BL] %u != %u", planesurface->num_isolines, num_isolines); error++;
      }
    num_isolines++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "num_isolines", &num_isolines) &&
        num_isolines == planesurface->num_isolines)
      pass ("PLANESURFACE.num_isolines [BL] set+1 %u", num_isolines);
    else
      {
        fail ("PLANESURFACE.num_isolines [BL] set+1 %u != %u", planesurface->num_isolines, num_isolines); error++;
      }
    planesurface->num_isolines--;

  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == planesurface->num_silhouettes)
      pass ("PLANESURFACE.num_silhouettes [BL] %u", num_silhouettes);
    else
      {
        fail ("PLANESURFACE.num_silhouettes [BL] %u != %u", planesurface->num_silhouettes, num_silhouettes); error++;
      }
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes) &&
        num_silhouettes == planesurface->num_silhouettes)
      pass ("PLANESURFACE.num_silhouettes [BL] set+1 %u", num_silhouettes);
    else
      {
        fail ("PLANESURFACE.num_silhouettes [BL] set+1 %u != %u", planesurface->num_silhouettes, num_silhouettes); error++;
      }
    planesurface->num_silhouettes--;

  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == planesurface->num_wires)
      pass ("PLANESURFACE.num_wires [BL] %u", num_wires);
    else
      {
        fail ("PLANESURFACE.num_wires [BL] %u != %u", planesurface->num_wires, num_wires); error++;
      }
    num_wires++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "num_wires", &num_wires) &&
        num_wires == planesurface->num_wires)
      pass ("PLANESURFACE.num_wires [BL] set+1 %u", num_wires);
    else
      {
        fail ("PLANESURFACE.num_wires [BL] set+1 %u != %u", planesurface->num_wires, num_wires); error++;
      }
    planesurface->num_wires--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &planesurface->parent, sizeof(planesurface->parent)))
      pass ("PLANESURFACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("PLANESURFACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "point", &point, NULL)
        && !memcmp(&point, &planesurface->point, sizeof(planesurface->point)))
      pass ("PLANESURFACE.point [3BD]");
    else
      {
        fail ("PLANESURFACE.point [3BD]"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "point_present", &point_present, NULL) &&
        point_present == planesurface->point_present)
      pass ("PLANESURFACE.point_present [RC] %u", point_present);
    else
      {
        fail ("PLANESURFACE.point_present [RC] %u != %u", planesurface->point_present, point_present); error++;
      }
    point_present++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "point_present", &point_present) &&
        point_present == planesurface->point_present)
      pass ("PLANESURFACE.point_present [RC] set+1 %u", point_present);
    else
      {
        fail ("PLANESURFACE.point_present [RC] set+1 %u != %u", planesurface->point_present, point_present); error++;
      }
    planesurface->point_present--;

  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &planesurface->silhouettes, sizeof(planesurface->silhouettes)))
      pass ("PLANESURFACE.silhouettes [Dwg_3DSOLID_silhouette*]");
    else
      {
        fail ("PLANESURFACE.silhouettes [Dwg_3DSOLID_silhouette*]"); error++;
      }
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == planesurface->u_isolines)
      pass ("PLANESURFACE.u_isolines [BS] %hu", u_isolines);
    else
      {
        fail ("PLANESURFACE.u_isolines [BS] %hu != %hu", planesurface->u_isolines, u_isolines); error++;
      }
    u_isolines++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "u_isolines", &u_isolines) &&
        u_isolines == planesurface->u_isolines)
      pass ("PLANESURFACE.u_isolines [BS] set+1 %hu", u_isolines);
    else
      {
        fail ("PLANESURFACE.u_isolines [BS] set+1 %hu != %hu", planesurface->u_isolines, u_isolines); error++;
      }
    planesurface->u_isolines--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "unknown", &unknown, NULL) &&
        unknown == planesurface->unknown)
      pass ("PLANESURFACE.unknown [RC] %u", unknown);
    else
      {
        fail ("PLANESURFACE.unknown [RC] %u != %u", planesurface->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "unknown", &unknown) &&
        unknown == planesurface->unknown)
      pass ("PLANESURFACE.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("PLANESURFACE.unknown [RC] set+1 %u != %u", planesurface->unknown, unknown); error++;
      }
    planesurface->unknown--;

  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == planesurface->unknown_2007)
      pass ("PLANESURFACE.unknown_2007 [BL] %u", unknown_2007);
    else
      {
        fail ("PLANESURFACE.unknown_2007 [BL] %u != %u", planesurface->unknown_2007, unknown_2007); error++;
      }
    unknown_2007++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "unknown_2007", &unknown_2007) &&
        unknown_2007 == planesurface->unknown_2007)
      pass ("PLANESURFACE.unknown_2007 [BL] set+1 %u", unknown_2007);
    else
      {
        fail ("PLANESURFACE.unknown_2007 [BL] set+1 %u != %u", planesurface->unknown_2007, unknown_2007); error++;
      }
    planesurface->unknown_2007--;

  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == planesurface->v_isolines)
      pass ("PLANESURFACE.v_isolines [BS] %hu", v_isolines);
    else
      {
        fail ("PLANESURFACE.v_isolines [BS] %hu != %hu", planesurface->v_isolines, v_isolines); error++;
      }
    v_isolines++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "v_isolines", &v_isolines) &&
        v_isolines == planesurface->v_isolines)
      pass ("PLANESURFACE.v_isolines [BS] set+1 %hu", v_isolines);
    else
      {
        fail ("PLANESURFACE.v_isolines [BS] set+1 %hu != %hu", planesurface->v_isolines, v_isolines); error++;
      }
    planesurface->v_isolines--;

  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "version", &version, NULL) &&
        version == planesurface->version)
      pass ("PLANESURFACE.version [BS] %hu", version);
    else
      {
        fail ("PLANESURFACE.version [BS] %hu != %hu", planesurface->version, version); error++;
      }
    version++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "version", &version) &&
        version == planesurface->version)
      pass ("PLANESURFACE.version [BS] set+1 %hu", version);
    else
      {
        fail ("PLANESURFACE.version [BS] set+1 %hu != %hu", planesurface->version, version); error++;
      }
    planesurface->version--;

  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == planesurface->wireframe_data_present)
      pass ("PLANESURFACE.wireframe_data_present [RC] %u", wireframe_data_present);
    else
      {
        fail ("PLANESURFACE.wireframe_data_present [RC] %u != %u", planesurface->wireframe_data_present, wireframe_data_present); error++;
      }
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value(planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present) &&
        wireframe_data_present == planesurface->wireframe_data_present)
      pass ("PLANESURFACE.wireframe_data_present [RC] set+1 %u", wireframe_data_present);
    else
      {
        fail ("PLANESURFACE.wireframe_data_present [RC] set+1 %u != %u", planesurface->wireframe_data_present, wireframe_data_present); error++;
      }
    planesurface->wireframe_data_present--;

  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &planesurface->wires, sizeof(planesurface->wires)))
      pass ("PLANESURFACE.wires [Dwg_3DSOLID_wire*]");
    else
      {
        fail ("PLANESURFACE.wires [Dwg_3DSOLID_wire*]"); error++;
      }
  }
  return error;
}
static int test_POINT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POINT *point = obj->tio.entity->tio.POINT;
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(point, "POINT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &point->extrusion, sizeof(point->extrusion)))
      pass ("POINT.extrusion [BE]");
    else
      {
        fail ("POINT.extrusion [BE]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(point, "POINT", "parent", &parent, NULL)
        && !memcmp(&parent, &point->parent, sizeof(point->parent)))
      pass ("POINT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("POINT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(point, "POINT", "thickness", &thickness, NULL) &&
        thickness == point->thickness)
      pass ("POINT.thickness [BT] " FORMAT_BT "", thickness);
    else
      {
        fail ("POINT.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", point->thickness, thickness); error++;
      }
    if (dwg_dynapi_entity_set_value(point, "POINT", "thickness", &thickness) &&
        thickness == point->thickness)
      pass ("POINT.thickness [BT] set+1 " FORMAT_BT "", thickness);
    else
      {
        fail ("POINT.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", point->thickness, thickness); error++;
      }
    point->thickness--;

  }
  {
    BITCODE_BD x;
    if (dwg_dynapi_entity_value(point, "POINT", "x", &x, NULL) &&
        x == point->x)
      pass ("POINT.x [BD] %g", x);
    else
      {
        fail ("POINT.x [BD] %g != %g", point->x, x); error++;
      }
    x++;
    if (dwg_dynapi_entity_set_value(point, "POINT", "x", &x) &&
        x == point->x)
      pass ("POINT.x [BD] set+1 %g", x);
    else
      {
        fail ("POINT.x [BD] set+1 %g != %g", point->x, x); error++;
      }
    point->x--;

  }
  {
    BITCODE_BD x_ang;
    if (dwg_dynapi_entity_value(point, "POINT", "x_ang", &x_ang, NULL) &&
        x_ang == point->x_ang)
      pass ("POINT.x_ang [BD] %g", x_ang);
    else
      {
        fail ("POINT.x_ang [BD] %g != %g", point->x_ang, x_ang); error++;
      }
    x_ang++;
    if (dwg_dynapi_entity_set_value(point, "POINT", "x_ang", &x_ang) &&
        x_ang == point->x_ang)
      pass ("POINT.x_ang [BD] set+1 %g", x_ang);
    else
      {
        fail ("POINT.x_ang [BD] set+1 %g != %g", point->x_ang, x_ang); error++;
      }
    point->x_ang--;

  }
  {
    BITCODE_BD y;
    if (dwg_dynapi_entity_value(point, "POINT", "y", &y, NULL) &&
        y == point->y)
      pass ("POINT.y [BD] %g", y);
    else
      {
        fail ("POINT.y [BD] %g != %g", point->y, y); error++;
      }
    y++;
    if (dwg_dynapi_entity_set_value(point, "POINT", "y", &y) &&
        y == point->y)
      pass ("POINT.y [BD] set+1 %g", y);
    else
      {
        fail ("POINT.y [BD] set+1 %g != %g", point->y, y); error++;
      }
    point->y--;

  }
  {
    BITCODE_BD z;
    if (dwg_dynapi_entity_value(point, "POINT", "z", &z, NULL) &&
        z == point->z)
      pass ("POINT.z [BD] %g", z);
    else
      {
        fail ("POINT.z [BD] %g != %g", point->z, z); error++;
      }
    z++;
    if (dwg_dynapi_entity_set_value(point, "POINT", "z", &z) &&
        z == point->z)
      pass ("POINT.z [BD] set+1 %g", z);
    else
      {
        fail ("POINT.z [BD] set+1 %g != %g", point->z, z); error++;
      }
    point->z--;

  }
  return error;
}
static int test_POLYLINE_2D (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POLYLINE_2D *polyline_2d = obj->tio.entity->tio.POLYLINE_2D;
  {
    BITCODE_BS curve_type;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "curve_type", &curve_type, NULL) &&
        curve_type == polyline_2d->curve_type)
      pass ("POLYLINE_2D.curve_type [BS] %hu", curve_type);
    else
      {
        fail ("POLYLINE_2D.curve_type [BS] %hu != %hu", polyline_2d->curve_type, curve_type); error++;
      }
    curve_type++;
    if (dwg_dynapi_entity_set_value(polyline_2d, "POLYLINE_2D", "curve_type", &curve_type) &&
        curve_type == polyline_2d->curve_type)
      pass ("POLYLINE_2D.curve_type [BS] set+1 %hu", curve_type);
    else
      {
        fail ("POLYLINE_2D.curve_type [BS] set+1 %hu != %hu", polyline_2d->curve_type, curve_type); error++;
      }
    polyline_2d->curve_type--;

  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "elevation", &elevation, NULL) &&
        elevation == polyline_2d->elevation)
      pass ("POLYLINE_2D.elevation [BD] %g", elevation);
    else
      {
        fail ("POLYLINE_2D.elevation [BD] %g != %g", polyline_2d->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(polyline_2d, "POLYLINE_2D", "elevation", &elevation) &&
        elevation == polyline_2d->elevation)
      pass ("POLYLINE_2D.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("POLYLINE_2D.elevation [BD] set+1 %g != %g", polyline_2d->elevation, elevation); error++;
      }
    polyline_2d->elevation--;

  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "end_width", &end_width, NULL) &&
        end_width == polyline_2d->end_width)
      pass ("POLYLINE_2D.end_width [BD] %g", end_width);
    else
      {
        fail ("POLYLINE_2D.end_width [BD] %g != %g", polyline_2d->end_width, end_width); error++;
      }
    end_width++;
    if (dwg_dynapi_entity_set_value(polyline_2d, "POLYLINE_2D", "end_width", &end_width) &&
        end_width == polyline_2d->end_width)
      pass ("POLYLINE_2D.end_width [BD] set+1 %g", end_width);
    else
      {
        fail ("POLYLINE_2D.end_width [BD] set+1 %g != %g", polyline_2d->end_width, end_width); error++;
      }
    polyline_2d->end_width--;

  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &polyline_2d->extrusion, sizeof(polyline_2d->extrusion)))
      pass ("POLYLINE_2D.extrusion [BE]");
    else
      {
        fail ("POLYLINE_2D.extrusion [BE]"); error++;
      }
  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "first_vertex", &first_vertex, NULL)
        && !memcmp(&first_vertex, &polyline_2d->first_vertex, sizeof(polyline_2d->first_vertex)))
      pass ("POLYLINE_2D.first_vertex [H]");
    else
      {
        fail ("POLYLINE_2D.first_vertex [H]"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "flag", &flag, NULL) &&
        flag == polyline_2d->flag)
      pass ("POLYLINE_2D.flag [BS] %hu", flag);
    else
      {
        fail ("POLYLINE_2D.flag [BS] %hu != %hu", polyline_2d->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(polyline_2d, "POLYLINE_2D", "flag", &flag) &&
        flag == polyline_2d->flag)
      pass ("POLYLINE_2D.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("POLYLINE_2D.flag [BS] set+1 %hu != %hu", polyline_2d->flag, flag); error++;
      }
    polyline_2d->flag--;

  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "last_vertex", &last_vertex, NULL)
        && !memcmp(&last_vertex, &polyline_2d->last_vertex, sizeof(polyline_2d->last_vertex)))
      pass ("POLYLINE_2D.last_vertex [H]");
    else
      {
        fail ("POLYLINE_2D.last_vertex [H]"); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "num_owned", &num_owned, NULL) &&
        num_owned == polyline_2d->num_owned)
      pass ("POLYLINE_2D.num_owned [BL] %u", num_owned);
    else
      {
        fail ("POLYLINE_2D.num_owned [BL] %u != %u", polyline_2d->num_owned, num_owned); error++;
      }
    num_owned++;
    if (dwg_dynapi_entity_set_value(polyline_2d, "POLYLINE_2D", "num_owned", &num_owned) &&
        num_owned == polyline_2d->num_owned)
      pass ("POLYLINE_2D.num_owned [BL] set+1 %u", num_owned);
    else
      {
        fail ("POLYLINE_2D.num_owned [BL] set+1 %u != %u", polyline_2d->num_owned, num_owned); error++;
      }
    polyline_2d->num_owned--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "parent", &parent, NULL)
        && !memcmp(&parent, &polyline_2d->parent, sizeof(polyline_2d->parent)))
      pass ("POLYLINE_2D.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("POLYLINE_2D.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &polyline_2d->seqend, sizeof(polyline_2d->seqend)))
      pass ("POLYLINE_2D.seqend [H]");
    else
      {
        fail ("POLYLINE_2D.seqend [H]"); error++;
      }
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "start_width", &start_width, NULL) &&
        start_width == polyline_2d->start_width)
      pass ("POLYLINE_2D.start_width [BD] %g", start_width);
    else
      {
        fail ("POLYLINE_2D.start_width [BD] %g != %g", polyline_2d->start_width, start_width); error++;
      }
    start_width++;
    if (dwg_dynapi_entity_set_value(polyline_2d, "POLYLINE_2D", "start_width", &start_width) &&
        start_width == polyline_2d->start_width)
      pass ("POLYLINE_2D.start_width [BD] set+1 %g", start_width);
    else
      {
        fail ("POLYLINE_2D.start_width [BD] set+1 %g != %g", polyline_2d->start_width, start_width); error++;
      }
    polyline_2d->start_width--;

  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "thickness", &thickness, NULL) &&
        thickness == polyline_2d->thickness)
      pass ("POLYLINE_2D.thickness [BT] " FORMAT_BT "", thickness);
    else
      {
        fail ("POLYLINE_2D.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", polyline_2d->thickness, thickness); error++;
      }
    if (dwg_dynapi_entity_set_value(polyline_2d, "POLYLINE_2D", "thickness", &thickness) &&
        thickness == polyline_2d->thickness)
      pass ("POLYLINE_2D.thickness [BT] set+1 " FORMAT_BT "", thickness);
    else
      {
        fail ("POLYLINE_2D.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", polyline_2d->thickness, thickness); error++;
      }
    polyline_2d->thickness--;

  }
  {
    BITCODE_H vertex;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "vertex", &vertex, NULL)
        && !memcmp(&vertex, &polyline_2d->vertex, sizeof(polyline_2d->vertex)))
      pass ("POLYLINE_2D.vertex [H]");
    else
      {
        fail ("POLYLINE_2D.vertex [H]"); error++;
      }
  }
  return error;
}
static int test_POLYLINE_3D (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POLYLINE_3D *polyline_3d = obj->tio.entity->tio.POLYLINE_3D;
  {
    BITCODE_RC curve_type;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "curve_type", &curve_type, NULL) &&
        curve_type == polyline_3d->curve_type)
      pass ("POLYLINE_3D.curve_type [RC] %u", curve_type);
    else
      {
        fail ("POLYLINE_3D.curve_type [RC] %u != %u", polyline_3d->curve_type, curve_type); error++;
      }
    curve_type++;
    if (dwg_dynapi_entity_set_value(polyline_3d, "POLYLINE_3D", "curve_type", &curve_type) &&
        curve_type == polyline_3d->curve_type)
      pass ("POLYLINE_3D.curve_type [RC] set+1 %u", curve_type);
    else
      {
        fail ("POLYLINE_3D.curve_type [RC] set+1 %u != %u", polyline_3d->curve_type, curve_type); error++;
      }
    polyline_3d->curve_type--;

  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "first_vertex", &first_vertex, NULL)
        && !memcmp(&first_vertex, &polyline_3d->first_vertex, sizeof(polyline_3d->first_vertex)))
      pass ("POLYLINE_3D.first_vertex [H]");
    else
      {
        fail ("POLYLINE_3D.first_vertex [H]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "flag", &flag, NULL) &&
        flag == polyline_3d->flag)
      pass ("POLYLINE_3D.flag [RC] %u", flag);
    else
      {
        fail ("POLYLINE_3D.flag [RC] %u != %u", polyline_3d->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(polyline_3d, "POLYLINE_3D", "flag", &flag) &&
        flag == polyline_3d->flag)
      pass ("POLYLINE_3D.flag [RC] set+1 %u", flag);
    else
      {
        fail ("POLYLINE_3D.flag [RC] set+1 %u != %u", polyline_3d->flag, flag); error++;
      }
    polyline_3d->flag--;

  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "last_vertex", &last_vertex, NULL)
        && !memcmp(&last_vertex, &polyline_3d->last_vertex, sizeof(polyline_3d->last_vertex)))
      pass ("POLYLINE_3D.last_vertex [H]");
    else
      {
        fail ("POLYLINE_3D.last_vertex [H]"); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "num_owned", &num_owned, NULL) &&
        num_owned == polyline_3d->num_owned)
      pass ("POLYLINE_3D.num_owned [BL] %u", num_owned);
    else
      {
        fail ("POLYLINE_3D.num_owned [BL] %u != %u", polyline_3d->num_owned, num_owned); error++;
      }
    num_owned++;
    if (dwg_dynapi_entity_set_value(polyline_3d, "POLYLINE_3D", "num_owned", &num_owned) &&
        num_owned == polyline_3d->num_owned)
      pass ("POLYLINE_3D.num_owned [BL] set+1 %u", num_owned);
    else
      {
        fail ("POLYLINE_3D.num_owned [BL] set+1 %u != %u", polyline_3d->num_owned, num_owned); error++;
      }
    polyline_3d->num_owned--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "parent", &parent, NULL)
        && !memcmp(&parent, &polyline_3d->parent, sizeof(polyline_3d->parent)))
      pass ("POLYLINE_3D.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("POLYLINE_3D.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &polyline_3d->seqend, sizeof(polyline_3d->seqend)))
      pass ("POLYLINE_3D.seqend [H]");
    else
      {
        fail ("POLYLINE_3D.seqend [H]"); error++;
      }
  }
  {
    BITCODE_H vertex;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "vertex", &vertex, NULL)
        && !memcmp(&vertex, &polyline_3d->vertex, sizeof(polyline_3d->vertex)))
      pass ("POLYLINE_3D.vertex [H]");
    else
      {
        fail ("POLYLINE_3D.vertex [H]"); error++;
      }
  }
  return error;
}
static int test_POLYLINE_MESH (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POLYLINE_MESH *polyline_mesh = obj->tio.entity->tio.POLYLINE_MESH;
  {
    BITCODE_BS curve_type;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "curve_type", &curve_type, NULL) &&
        curve_type == polyline_mesh->curve_type)
      pass ("POLYLINE_MESH.curve_type [BS] %hu", curve_type);
    else
      {
        fail ("POLYLINE_MESH.curve_type [BS] %hu != %hu", polyline_mesh->curve_type, curve_type); error++;
      }
    curve_type++;
    if (dwg_dynapi_entity_set_value(polyline_mesh, "POLYLINE_MESH", "curve_type", &curve_type) &&
        curve_type == polyline_mesh->curve_type)
      pass ("POLYLINE_MESH.curve_type [BS] set+1 %hu", curve_type);
    else
      {
        fail ("POLYLINE_MESH.curve_type [BS] set+1 %hu != %hu", polyline_mesh->curve_type, curve_type); error++;
      }
    polyline_mesh->curve_type--;

  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "first_vertex", &first_vertex, NULL)
        && !memcmp(&first_vertex, &polyline_mesh->first_vertex, sizeof(polyline_mesh->first_vertex)))
      pass ("POLYLINE_MESH.first_vertex [H]");
    else
      {
        fail ("POLYLINE_MESH.first_vertex [H]"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "flag", &flag, NULL) &&
        flag == polyline_mesh->flag)
      pass ("POLYLINE_MESH.flag [BS] %hu", flag);
    else
      {
        fail ("POLYLINE_MESH.flag [BS] %hu != %hu", polyline_mesh->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(polyline_mesh, "POLYLINE_MESH", "flag", &flag) &&
        flag == polyline_mesh->flag)
      pass ("POLYLINE_MESH.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("POLYLINE_MESH.flag [BS] set+1 %hu != %hu", polyline_mesh->flag, flag); error++;
      }
    polyline_mesh->flag--;

  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "last_vertex", &last_vertex, NULL)
        && !memcmp(&last_vertex, &polyline_mesh->last_vertex, sizeof(polyline_mesh->last_vertex)))
      pass ("POLYLINE_MESH.last_vertex [H]");
    else
      {
        fail ("POLYLINE_MESH.last_vertex [H]"); error++;
      }
  }
  {
    BITCODE_BS m_density;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "m_density", &m_density, NULL) &&
        m_density == polyline_mesh->m_density)
      pass ("POLYLINE_MESH.m_density [BS] %hu", m_density);
    else
      {
        fail ("POLYLINE_MESH.m_density [BS] %hu != %hu", polyline_mesh->m_density, m_density); error++;
      }
    m_density++;
    if (dwg_dynapi_entity_set_value(polyline_mesh, "POLYLINE_MESH", "m_density", &m_density) &&
        m_density == polyline_mesh->m_density)
      pass ("POLYLINE_MESH.m_density [BS] set+1 %hu", m_density);
    else
      {
        fail ("POLYLINE_MESH.m_density [BS] set+1 %hu != %hu", polyline_mesh->m_density, m_density); error++;
      }
    polyline_mesh->m_density--;

  }
  {
    BITCODE_BS n_density;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "n_density", &n_density, NULL) &&
        n_density == polyline_mesh->n_density)
      pass ("POLYLINE_MESH.n_density [BS] %hu", n_density);
    else
      {
        fail ("POLYLINE_MESH.n_density [BS] %hu != %hu", polyline_mesh->n_density, n_density); error++;
      }
    n_density++;
    if (dwg_dynapi_entity_set_value(polyline_mesh, "POLYLINE_MESH", "n_density", &n_density) &&
        n_density == polyline_mesh->n_density)
      pass ("POLYLINE_MESH.n_density [BS] set+1 %hu", n_density);
    else
      {
        fail ("POLYLINE_MESH.n_density [BS] set+1 %hu != %hu", polyline_mesh->n_density, n_density); error++;
      }
    polyline_mesh->n_density--;

  }
  {
    BITCODE_BS num_m_verts;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "num_m_verts", &num_m_verts, NULL) &&
        num_m_verts == polyline_mesh->num_m_verts)
      pass ("POLYLINE_MESH.num_m_verts [BS] %hu", num_m_verts);
    else
      {
        fail ("POLYLINE_MESH.num_m_verts [BS] %hu != %hu", polyline_mesh->num_m_verts, num_m_verts); error++;
      }
    num_m_verts++;
    if (dwg_dynapi_entity_set_value(polyline_mesh, "POLYLINE_MESH", "num_m_verts", &num_m_verts) &&
        num_m_verts == polyline_mesh->num_m_verts)
      pass ("POLYLINE_MESH.num_m_verts [BS] set+1 %hu", num_m_verts);
    else
      {
        fail ("POLYLINE_MESH.num_m_verts [BS] set+1 %hu != %hu", polyline_mesh->num_m_verts, num_m_verts); error++;
      }
    polyline_mesh->num_m_verts--;

  }
  {
    BITCODE_BS num_n_verts;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "num_n_verts", &num_n_verts, NULL) &&
        num_n_verts == polyline_mesh->num_n_verts)
      pass ("POLYLINE_MESH.num_n_verts [BS] %hu", num_n_verts);
    else
      {
        fail ("POLYLINE_MESH.num_n_verts [BS] %hu != %hu", polyline_mesh->num_n_verts, num_n_verts); error++;
      }
    num_n_verts++;
    if (dwg_dynapi_entity_set_value(polyline_mesh, "POLYLINE_MESH", "num_n_verts", &num_n_verts) &&
        num_n_verts == polyline_mesh->num_n_verts)
      pass ("POLYLINE_MESH.num_n_verts [BS] set+1 %hu", num_n_verts);
    else
      {
        fail ("POLYLINE_MESH.num_n_verts [BS] set+1 %hu != %hu", polyline_mesh->num_n_verts, num_n_verts); error++;
      }
    polyline_mesh->num_n_verts--;

  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "num_owned", &num_owned, NULL) &&
        num_owned == polyline_mesh->num_owned)
      pass ("POLYLINE_MESH.num_owned [BL] %u", num_owned);
    else
      {
        fail ("POLYLINE_MESH.num_owned [BL] %u != %u", polyline_mesh->num_owned, num_owned); error++;
      }
    num_owned++;
    if (dwg_dynapi_entity_set_value(polyline_mesh, "POLYLINE_MESH", "num_owned", &num_owned) &&
        num_owned == polyline_mesh->num_owned)
      pass ("POLYLINE_MESH.num_owned [BL] set+1 %u", num_owned);
    else
      {
        fail ("POLYLINE_MESH.num_owned [BL] set+1 %u != %u", polyline_mesh->num_owned, num_owned); error++;
      }
    polyline_mesh->num_owned--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "parent", &parent, NULL)
        && !memcmp(&parent, &polyline_mesh->parent, sizeof(polyline_mesh->parent)))
      pass ("POLYLINE_MESH.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("POLYLINE_MESH.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &polyline_mesh->seqend, sizeof(polyline_mesh->seqend)))
      pass ("POLYLINE_MESH.seqend [H]");
    else
      {
        fail ("POLYLINE_MESH.seqend [H]"); error++;
      }
  }
  {
    BITCODE_H vertex;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "vertex", &vertex, NULL)
        && !memcmp(&vertex, &polyline_mesh->vertex, sizeof(polyline_mesh->vertex)))
      pass ("POLYLINE_MESH.vertex [H]");
    else
      {
        fail ("POLYLINE_MESH.vertex [H]"); error++;
      }
  }
  return error;
}
static int test_POLYLINE_PFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POLYLINE_PFACE *polyline_pface = obj->tio.entity->tio.POLYLINE_PFACE;
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "first_vertex", &first_vertex, NULL)
        && !memcmp(&first_vertex, &polyline_pface->first_vertex, sizeof(polyline_pface->first_vertex)))
      pass ("POLYLINE_PFACE.first_vertex [H]");
    else
      {
        fail ("POLYLINE_PFACE.first_vertex [H]"); error++;
      }
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "last_vertex", &last_vertex, NULL)
        && !memcmp(&last_vertex, &polyline_pface->last_vertex, sizeof(polyline_pface->last_vertex)))
      pass ("POLYLINE_PFACE.last_vertex [H]");
    else
      {
        fail ("POLYLINE_PFACE.last_vertex [H]"); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "num_owned", &num_owned, NULL) &&
        num_owned == polyline_pface->num_owned)
      pass ("POLYLINE_PFACE.num_owned [BL] %u", num_owned);
    else
      {
        fail ("POLYLINE_PFACE.num_owned [BL] %u != %u", polyline_pface->num_owned, num_owned); error++;
      }
    num_owned++;
    if (dwg_dynapi_entity_set_value(polyline_pface, "POLYLINE_PFACE", "num_owned", &num_owned) &&
        num_owned == polyline_pface->num_owned)
      pass ("POLYLINE_PFACE.num_owned [BL] set+1 %u", num_owned);
    else
      {
        fail ("POLYLINE_PFACE.num_owned [BL] set+1 %u != %u", polyline_pface->num_owned, num_owned); error++;
      }
    polyline_pface->num_owned--;

  }
  {
    BITCODE_BS numfaces;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "numfaces", &numfaces, NULL) &&
        numfaces == polyline_pface->numfaces)
      pass ("POLYLINE_PFACE.numfaces [BS] %hu", numfaces);
    else
      {
        fail ("POLYLINE_PFACE.numfaces [BS] %hu != %hu", polyline_pface->numfaces, numfaces); error++;
      }
    numfaces++;
    if (dwg_dynapi_entity_set_value(polyline_pface, "POLYLINE_PFACE", "numfaces", &numfaces) &&
        numfaces == polyline_pface->numfaces)
      pass ("POLYLINE_PFACE.numfaces [BS] set+1 %hu", numfaces);
    else
      {
        fail ("POLYLINE_PFACE.numfaces [BS] set+1 %hu != %hu", polyline_pface->numfaces, numfaces); error++;
      }
    polyline_pface->numfaces--;

  }
  {
    BITCODE_BS numverts;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "numverts", &numverts, NULL) &&
        numverts == polyline_pface->numverts)
      pass ("POLYLINE_PFACE.numverts [BS] %hu", numverts);
    else
      {
        fail ("POLYLINE_PFACE.numverts [BS] %hu != %hu", polyline_pface->numverts, numverts); error++;
      }
    numverts++;
    if (dwg_dynapi_entity_set_value(polyline_pface, "POLYLINE_PFACE", "numverts", &numverts) &&
        numverts == polyline_pface->numverts)
      pass ("POLYLINE_PFACE.numverts [BS] set+1 %hu", numverts);
    else
      {
        fail ("POLYLINE_PFACE.numverts [BS] set+1 %hu != %hu", polyline_pface->numverts, numverts); error++;
      }
    polyline_pface->numverts--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &polyline_pface->parent, sizeof(polyline_pface->parent)))
      pass ("POLYLINE_PFACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("POLYLINE_PFACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &polyline_pface->seqend, sizeof(polyline_pface->seqend)))
      pass ("POLYLINE_PFACE.seqend [H]");
    else
      {
        fail ("POLYLINE_PFACE.seqend [H]"); error++;
      }
  }
  {
    BITCODE_H vertex;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "vertex", &vertex, NULL)
        && !memcmp(&vertex, &polyline_pface->vertex, sizeof(polyline_pface->vertex)))
      pass ("POLYLINE_PFACE.vertex [H]");
    else
      {
        fail ("POLYLINE_PFACE.vertex [H]"); error++;
      }
  }
  return error;
}
static int test_PROXY_ENTITY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_PROXY_ENTITY *proxy_entity = obj->tio.entity->tio.PROXY_ENTITY;
  {
    BITCODE_BL class_id;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "class_id", &class_id, NULL) &&
        class_id == proxy_entity->class_id)
      pass ("PROXY_ENTITY.class_id [BL] %u", class_id);
    else
      {
        fail ("PROXY_ENTITY.class_id [BL] %u != %u", proxy_entity->class_id, class_id); error++;
      }
    class_id++;
    if (dwg_dynapi_entity_set_value(proxy_entity, "PROXY_ENTITY", "class_id", &class_id) &&
        class_id == proxy_entity->class_id)
      pass ("PROXY_ENTITY.class_id [BL] set+1 %u", class_id);
    else
      {
        fail ("PROXY_ENTITY.class_id [BL] set+1 %u != %u", proxy_entity->class_id, class_id); error++;
      }
    proxy_entity->class_id--;

  }
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "data", &data, NULL)
        && !strcmp((char*)&data, (char*)&proxy_entity->data))
      pass ("PROXY_ENTITY.data [TV]");
    else
      {
        fail ("PROXY_ENTITY.data [TV]"); error++;
      }
  }
  {
    BITCODE_B from_dxf;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "from_dxf", &from_dxf, NULL) &&
        from_dxf == proxy_entity->from_dxf)
      pass ("PROXY_ENTITY.from_dxf [B] " FORMAT_B "", from_dxf);
    else
      {
        fail ("PROXY_ENTITY.from_dxf [B] " FORMAT_B " != " FORMAT_B "", proxy_entity->from_dxf, from_dxf); error++;
      }
    from_dxf++;
    if (dwg_dynapi_entity_set_value(proxy_entity, "PROXY_ENTITY", "from_dxf", &from_dxf) &&
        from_dxf == proxy_entity->from_dxf)
      pass ("PROXY_ENTITY.from_dxf [B] set+1 " FORMAT_B "", from_dxf);
    else
      {
        fail ("PROXY_ENTITY.from_dxf [B] set+1 " FORMAT_B " != " FORMAT_B "", proxy_entity->from_dxf, from_dxf); error++;
      }
    proxy_entity->from_dxf--;

  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "maint_version", &maint_version, NULL) &&
        maint_version == proxy_entity->maint_version)
      pass ("PROXY_ENTITY.maint_version [BL] %u", maint_version);
    else
      {
        fail ("PROXY_ENTITY.maint_version [BL] %u != %u", proxy_entity->maint_version, maint_version); error++;
      }
    maint_version++;
    if (dwg_dynapi_entity_set_value(proxy_entity, "PROXY_ENTITY", "maint_version", &maint_version) &&
        maint_version == proxy_entity->maint_version)
      pass ("PROXY_ENTITY.maint_version [BL] set+1 %u", maint_version);
    else
      {
        fail ("PROXY_ENTITY.maint_version [BL] set+1 %u != %u", proxy_entity->maint_version, maint_version); error++;
      }
    proxy_entity->maint_version--;

  }
  {
    BITCODE_H* objid_object_handles;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "objid_object_handles", &objid_object_handles, NULL)
        && !memcmp(&objid_object_handles, &proxy_entity->objid_object_handles, sizeof(proxy_entity->objid_object_handles)))
      pass ("PROXY_ENTITY.objid_object_handles [H*]");
    else
      {
        fail ("PROXY_ENTITY.objid_object_handles [H*]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &proxy_entity->ownerhandle, sizeof(proxy_entity->ownerhandle)))
      pass ("PROXY_ENTITY.ownerhandle [H]");
    else
      {
        fail ("PROXY_ENTITY.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "parent", &parent, NULL)
        && !memcmp(&parent, &proxy_entity->parent, sizeof(proxy_entity->parent)))
      pass ("PROXY_ENTITY.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("PROXY_ENTITY.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_MS size;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "size", &size, NULL) &&
        size == proxy_entity->size)
      pass ("PROXY_ENTITY.size [MS] " FORMAT_MS "", size);
    else
      {
        fail ("PROXY_ENTITY.size [MS] " FORMAT_MS " != " FORMAT_MS "", proxy_entity->size, size); error++;
      }
    if (dwg_dynapi_entity_set_value(proxy_entity, "PROXY_ENTITY", "size", &size) &&
        size == proxy_entity->size)
      pass ("PROXY_ENTITY.size [MS] set+1 " FORMAT_MS "", size);
    else
      {
        fail ("PROXY_ENTITY.size [MS] set+1 " FORMAT_MS " != " FORMAT_MS "", proxy_entity->size, size); error++;
      }
    proxy_entity->size--;

  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "version", &version, NULL) &&
        version == proxy_entity->version)
      pass ("PROXY_ENTITY.version [BL] %u", version);
    else
      {
        fail ("PROXY_ENTITY.version [BL] %u != %u", proxy_entity->version, version); error++;
      }
    version++;
    if (dwg_dynapi_entity_set_value(proxy_entity, "PROXY_ENTITY", "version", &version) &&
        version == proxy_entity->version)
      pass ("PROXY_ENTITY.version [BL] set+1 %u", version);
    else
      {
        fail ("PROXY_ENTITY.version [BL] set+1 %u != %u", proxy_entity->version, version); error++;
      }
    proxy_entity->version--;

  }
  return error;
}
static int test_RAY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_RAY *ray = obj->tio.entity->tio.RAY;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(ray, "RAY", "parent", &parent, NULL)
        && !memcmp(&parent, &ray->parent, sizeof(ray->parent)))
      pass ("RAY.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("RAY.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(ray, "RAY", "point", &point, NULL)
        && !memcmp(&point, &ray->point, sizeof(ray->point)))
      pass ("RAY.point [3BD]");
    else
      {
        fail ("RAY.point [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD vector;
    if (dwg_dynapi_entity_value(ray, "RAY", "vector", &vector, NULL)
        && !memcmp(&vector, &ray->vector, sizeof(ray->vector)))
      pass ("RAY.vector [3BD]");
    else
      {
        fail ("RAY.vector [3BD]"); error++;
      }
  }
  return error;
}
static int test_REVOLVEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_REVOLVEDSURFACE *revolvedsurface = obj->tio.entity->tio.REVOLVEDSURFACE;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&revolvedsurface->acis_data))
      pass ("REVOLVEDSURFACE.acis_data [RC*]");
    else
      {
        fail ("REVOLVEDSURFACE.acis_data [RC*]"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == revolvedsurface->acis_empty)
      pass ("REVOLVEDSURFACE.acis_empty [RC] %u", acis_empty);
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty [RC] %u != %u", revolvedsurface->acis_empty, acis_empty); error++;
      }
    acis_empty++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty) &&
        acis_empty == revolvedsurface->acis_empty)
      pass ("REVOLVEDSURFACE.acis_empty [RC] set+1 %u", acis_empty);
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty [RC] set+1 %u != %u", revolvedsurface->acis_empty, acis_empty); error++;
      }
    revolvedsurface->acis_empty--;

  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == revolvedsurface->acis_empty2)
      pass ("REVOLVEDSURFACE.acis_empty2 [RC] %u", acis_empty2);
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty2 [RC] %u != %u", revolvedsurface->acis_empty2, acis_empty2); error++;
      }
    acis_empty2++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2) &&
        acis_empty2 == revolvedsurface->acis_empty2)
      pass ("REVOLVEDSURFACE.acis_empty2 [RC] set+1 %u", acis_empty2);
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty2 [RC] set+1 %u != %u", revolvedsurface->acis_empty2, acis_empty2); error++;
      }
    revolvedsurface->acis_empty2--;

  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == revolvedsurface->acis_empty_bit)
      pass ("REVOLVEDSURFACE.acis_empty_bit [RC] %u", acis_empty_bit);
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty_bit [RC] %u != %u", revolvedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit) &&
        acis_empty_bit == revolvedsurface->acis_empty_bit)
      pass ("REVOLVEDSURFACE.acis_empty_bit [RC] set+1 %u", acis_empty_bit);
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty_bit [RC] set+1 %u != %u", revolvedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
    revolvedsurface->acis_empty_bit--;

  }
  {
    BITCODE_3BD axis_point;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "axis_point", &axis_point, NULL)
        && !memcmp(&axis_point, &revolvedsurface->axis_point, sizeof(revolvedsurface->axis_point)))
      pass ("REVOLVEDSURFACE.axis_point [3BD]");
    else
      {
        fail ("REVOLVEDSURFACE.axis_point [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD axis_vector;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "axis_vector", &axis_vector, NULL)
        && !memcmp(&axis_vector, &revolvedsurface->axis_vector, sizeof(revolvedsurface->axis_vector)))
      pass ("REVOLVEDSURFACE.axis_vector [3BD]");
    else
      {
        fail ("REVOLVEDSURFACE.axis_vector [3BD]"); error++;
      }
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &revolvedsurface->block_size, sizeof(revolvedsurface->block_size)))
      pass ("REVOLVEDSURFACE.block_size [BL*]");
    else
      {
        fail ("REVOLVEDSURFACE.block_size [BL*]"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version, NULL) &&
        class_version == revolvedsurface->class_version)
      pass ("REVOLVEDSURFACE.class_version [BL] %u", class_version);
    else
      {
        fail ("REVOLVEDSURFACE.class_version [BL] %u != %u", revolvedsurface->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version) &&
        class_version == revolvedsurface->class_version)
      pass ("REVOLVEDSURFACE.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("REVOLVEDSURFACE.class_version [BL] set+1 %u != %u", revolvedsurface->class_version, class_version); error++;
      }
    revolvedsurface->class_version--;

  }
  {
    BITCODE_B close_to_axis;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis, NULL) &&
        close_to_axis == revolvedsurface->close_to_axis)
      pass ("REVOLVEDSURFACE.close_to_axis [B] " FORMAT_B "", close_to_axis);
    else
      {
        fail ("REVOLVEDSURFACE.close_to_axis [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis); error++;
      }
    close_to_axis++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis) &&
        close_to_axis == revolvedsurface->close_to_axis)
      pass ("REVOLVEDSURFACE.close_to_axis [B] set+1 " FORMAT_B "", close_to_axis);
    else
      {
        fail ("REVOLVEDSURFACE.close_to_axis [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis); error++;
      }
    revolvedsurface->close_to_axis--;

  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle, NULL) &&
        draft_angle == revolvedsurface->draft_angle)
      pass ("REVOLVEDSURFACE.draft_angle [BD] %g", draft_angle);
    else
      {
        fail ("REVOLVEDSURFACE.draft_angle [BD] %g != %g", revolvedsurface->draft_angle, draft_angle); error++;
      }
    draft_angle++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle) &&
        draft_angle == revolvedsurface->draft_angle)
      pass ("REVOLVEDSURFACE.draft_angle [BD] set+1 %g", draft_angle);
    else
      {
        fail ("REVOLVEDSURFACE.draft_angle [BD] set+1 %g != %g", revolvedsurface->draft_angle, draft_angle); error++;
      }
    revolvedsurface->draft_angle--;

  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance, NULL) &&
        draft_end_distance == revolvedsurface->draft_end_distance)
      pass ("REVOLVEDSURFACE.draft_end_distance [BD] %g", draft_end_distance);
    else
      {
        fail ("REVOLVEDSURFACE.draft_end_distance [BD] %g != %g", revolvedsurface->draft_end_distance, draft_end_distance); error++;
      }
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance) &&
        draft_end_distance == revolvedsurface->draft_end_distance)
      pass ("REVOLVEDSURFACE.draft_end_distance [BD] set+1 %g", draft_end_distance);
    else
      {
        fail ("REVOLVEDSURFACE.draft_end_distance [BD] set+1 %g != %g", revolvedsurface->draft_end_distance, draft_end_distance); error++;
      }
    revolvedsurface->draft_end_distance--;

  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance, NULL) &&
        draft_start_distance == revolvedsurface->draft_start_distance)
      pass ("REVOLVEDSURFACE.draft_start_distance [BD] %g", draft_start_distance);
    else
      {
        fail ("REVOLVEDSURFACE.draft_start_distance [BD] %g != %g", revolvedsurface->draft_start_distance, draft_start_distance); error++;
      }
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance) &&
        draft_start_distance == revolvedsurface->draft_start_distance)
      pass ("REVOLVEDSURFACE.draft_start_distance [BD] set+1 %g", draft_start_distance);
    else
      {
        fail ("REVOLVEDSURFACE.draft_start_distance [BD] set+1 %g != %g", revolvedsurface->draft_start_distance, draft_start_distance); error++;
      }
    revolvedsurface->draft_start_distance--;

  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&revolvedsurface->encr_sat_data))
      pass ("REVOLVEDSURFACE.encr_sat_data [TV]");
    else
      {
        fail ("REVOLVEDSURFACE.encr_sat_data [TV]"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &revolvedsurface->extra_acis_data, sizeof(revolvedsurface->extra_acis_data)))
      pass ("REVOLVEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
    else
      {
        fail ("REVOLVEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]"); error++;
      }
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &revolvedsurface->history_id, sizeof(revolvedsurface->history_id)))
      pass ("REVOLVEDSURFACE.history_id [H]");
    else
      {
        fail ("REVOLVEDSURFACE.history_id [H]"); error++;
      }
  }
  {
    BITCODE_BL id;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "id", &id, NULL) &&
        id == revolvedsurface->id)
      pass ("REVOLVEDSURFACE.id [BL] %u", id);
    else
      {
        fail ("REVOLVEDSURFACE.id [BL] %u != %u", revolvedsurface->id, id); error++;
      }
    id++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "id", &id) &&
        id == revolvedsurface->id)
      pass ("REVOLVEDSURFACE.id [BL] set+1 %u", id);
    else
      {
        fail ("REVOLVEDSURFACE.id [BL] set+1 %u != %u", revolvedsurface->id, id); error++;
      }
    revolvedsurface->id--;

  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == revolvedsurface->isoline_present)
      pass ("REVOLVEDSURFACE.isoline_present [RC] %u", isoline_present);
    else
      {
        fail ("REVOLVEDSURFACE.isoline_present [RC] %u != %u", revolvedsurface->isoline_present, isoline_present); error++;
      }
    isoline_present++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present) &&
        isoline_present == revolvedsurface->isoline_present)
      pass ("REVOLVEDSURFACE.isoline_present [RC] set+1 %u", isoline_present);
    else
      {
        fail ("REVOLVEDSURFACE.isoline_present [RC] set+1 %u != %u", revolvedsurface->isoline_present, isoline_present); error++;
      }
    revolvedsurface->isoline_present--;

  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == revolvedsurface->modeler_format_version)
      pass ("REVOLVEDSURFACE.modeler_format_version [BS] %hu", modeler_format_version);
    else
      {
        fail ("REVOLVEDSURFACE.modeler_format_version [BS] %hu != %hu", revolvedsurface->modeler_format_version, modeler_format_version); error++;
      }
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version) &&
        modeler_format_version == revolvedsurface->modeler_format_version)
      pass ("REVOLVEDSURFACE.modeler_format_version [BS] set+1 %hu", modeler_format_version);
    else
      {
        fail ("REVOLVEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", revolvedsurface->modeler_format_version, modeler_format_version); error++;
      }
    revolvedsurface->modeler_format_version--;

  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == revolvedsurface->num_blocks)
      pass ("REVOLVEDSURFACE.num_blocks [BL] %u", num_blocks);
    else
      {
        fail ("REVOLVEDSURFACE.num_blocks [BL] %u != %u", revolvedsurface->num_blocks, num_blocks); error++;
      }
    num_blocks++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks) &&
        num_blocks == revolvedsurface->num_blocks)
      pass ("REVOLVEDSURFACE.num_blocks [BL] set+1 %u", num_blocks);
    else
      {
        fail ("REVOLVEDSURFACE.num_blocks [BL] set+1 %u != %u", revolvedsurface->num_blocks, num_blocks); error++;
      }
    revolvedsurface->num_blocks--;

  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == revolvedsurface->num_isolines)
      pass ("REVOLVEDSURFACE.num_isolines [BL] %u", num_isolines);
    else
      {
        fail ("REVOLVEDSURFACE.num_isolines [BL] %u != %u", revolvedsurface->num_isolines, num_isolines); error++;
      }
    num_isolines++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "num_isolines", &num_isolines) &&
        num_isolines == revolvedsurface->num_isolines)
      pass ("REVOLVEDSURFACE.num_isolines [BL] set+1 %u", num_isolines);
    else
      {
        fail ("REVOLVEDSURFACE.num_isolines [BL] set+1 %u != %u", revolvedsurface->num_isolines, num_isolines); error++;
      }
    revolvedsurface->num_isolines--;

  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == revolvedsurface->num_silhouettes)
      pass ("REVOLVEDSURFACE.num_silhouettes [BL] %u", num_silhouettes);
    else
      {
        fail ("REVOLVEDSURFACE.num_silhouettes [BL] %u != %u", revolvedsurface->num_silhouettes, num_silhouettes); error++;
      }
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes) &&
        num_silhouettes == revolvedsurface->num_silhouettes)
      pass ("REVOLVEDSURFACE.num_silhouettes [BL] set+1 %u", num_silhouettes);
    else
      {
        fail ("REVOLVEDSURFACE.num_silhouettes [BL] set+1 %u != %u", revolvedsurface->num_silhouettes, num_silhouettes); error++;
      }
    revolvedsurface->num_silhouettes--;

  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == revolvedsurface->num_wires)
      pass ("REVOLVEDSURFACE.num_wires [BL] %u", num_wires);
    else
      {
        fail ("REVOLVEDSURFACE.num_wires [BL] %u != %u", revolvedsurface->num_wires, num_wires); error++;
      }
    num_wires++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires) &&
        num_wires == revolvedsurface->num_wires)
      pass ("REVOLVEDSURFACE.num_wires [BL] set+1 %u", num_wires);
    else
      {
        fail ("REVOLVEDSURFACE.num_wires [BL] set+1 %u != %u", revolvedsurface->num_wires, num_wires); error++;
      }
    revolvedsurface->num_wires--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &revolvedsurface->parent, sizeof(revolvedsurface->parent)))
      pass ("REVOLVEDSURFACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("REVOLVEDSURFACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "point", &point, NULL)
        && !memcmp(&point, &revolvedsurface->point, sizeof(revolvedsurface->point)))
      pass ("REVOLVEDSURFACE.point [3BD]");
    else
      {
        fail ("REVOLVEDSURFACE.point [3BD]"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present, NULL) &&
        point_present == revolvedsurface->point_present)
      pass ("REVOLVEDSURFACE.point_present [RC] %u", point_present);
    else
      {
        fail ("REVOLVEDSURFACE.point_present [RC] %u != %u", revolvedsurface->point_present, point_present); error++;
      }
    point_present++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present) &&
        point_present == revolvedsurface->point_present)
      pass ("REVOLVEDSURFACE.point_present [RC] set+1 %u", point_present);
    else
      {
        fail ("REVOLVEDSURFACE.point_present [RC] set+1 %u != %u", revolvedsurface->point_present, point_present); error++;
      }
    revolvedsurface->point_present--;

  }
  {
    BITCODE_BD revolve_angle;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle, NULL) &&
        revolve_angle == revolvedsurface->revolve_angle)
      pass ("REVOLVEDSURFACE.revolve_angle [BD] %g", revolve_angle);
    else
      {
        fail ("REVOLVEDSURFACE.revolve_angle [BD] %g != %g", revolvedsurface->revolve_angle, revolve_angle); error++;
      }
    revolve_angle++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle) &&
        revolve_angle == revolvedsurface->revolve_angle)
      pass ("REVOLVEDSURFACE.revolve_angle [BD] set+1 %g", revolve_angle);
    else
      {
        fail ("REVOLVEDSURFACE.revolve_angle [BD] set+1 %g != %g", revolvedsurface->revolve_angle, revolve_angle); error++;
      }
    revolvedsurface->revolve_angle--;

  }
  {
    BITCODE_BD* revolved_entity_transmatrix;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "revolved_entity_transmatrix", &revolved_entity_transmatrix, NULL)
        && !memcmp(&revolved_entity_transmatrix, &revolvedsurface->revolved_entity_transmatrix, sizeof(revolvedsurface->revolved_entity_transmatrix)))
      pass ("REVOLVEDSURFACE.revolved_entity_transmatrix [BD*]");
    else
      {
        fail ("REVOLVEDSURFACE.revolved_entity_transmatrix [BD*]"); error++;
      }
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &revolvedsurface->silhouettes, sizeof(revolvedsurface->silhouettes)))
      pass ("REVOLVEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*]");
    else
      {
        fail ("REVOLVEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*]"); error++;
      }
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "solid", &solid, NULL) &&
        solid == revolvedsurface->solid)
      pass ("REVOLVEDSURFACE.solid [B] " FORMAT_B "", solid);
    else
      {
        fail ("REVOLVEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid); error++;
      }
    solid++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "solid", &solid) &&
        solid == revolvedsurface->solid)
      pass ("REVOLVEDSURFACE.solid [B] set+1 " FORMAT_B "", solid);
    else
      {
        fail ("REVOLVEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid); error++;
      }
    revolvedsurface->solid--;

  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle, NULL) &&
        start_angle == revolvedsurface->start_angle)
      pass ("REVOLVEDSURFACE.start_angle [BD] %g", start_angle);
    else
      {
        fail ("REVOLVEDSURFACE.start_angle [BD] %g != %g", revolvedsurface->start_angle, start_angle); error++;
      }
    start_angle++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle) &&
        start_angle == revolvedsurface->start_angle)
      pass ("REVOLVEDSURFACE.start_angle [BD] set+1 %g", start_angle);
    else
      {
        fail ("REVOLVEDSURFACE.start_angle [BD] set+1 %g != %g", revolvedsurface->start_angle, start_angle); error++;
      }
    revolvedsurface->start_angle--;

  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle, NULL) &&
        twist_angle == revolvedsurface->twist_angle)
      pass ("REVOLVEDSURFACE.twist_angle [BD] %g", twist_angle);
    else
      {
        fail ("REVOLVEDSURFACE.twist_angle [BD] %g != %g", revolvedsurface->twist_angle, twist_angle); error++;
      }
    twist_angle++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle) &&
        twist_angle == revolvedsurface->twist_angle)
      pass ("REVOLVEDSURFACE.twist_angle [BD] set+1 %g", twist_angle);
    else
      {
        fail ("REVOLVEDSURFACE.twist_angle [BD] set+1 %g != %g", revolvedsurface->twist_angle, twist_angle); error++;
      }
    revolvedsurface->twist_angle--;

  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == revolvedsurface->u_isolines)
      pass ("REVOLVEDSURFACE.u_isolines [BS] %hu", u_isolines);
    else
      {
        fail ("REVOLVEDSURFACE.u_isolines [BS] %hu != %hu", revolvedsurface->u_isolines, u_isolines); error++;
      }
    u_isolines++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines) &&
        u_isolines == revolvedsurface->u_isolines)
      pass ("REVOLVEDSURFACE.u_isolines [BS] set+1 %hu", u_isolines);
    else
      {
        fail ("REVOLVEDSURFACE.u_isolines [BS] set+1 %hu != %hu", revolvedsurface->u_isolines, u_isolines); error++;
      }
    revolvedsurface->u_isolines--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown, NULL) &&
        unknown == revolvedsurface->unknown)
      pass ("REVOLVEDSURFACE.unknown [RC] %u", unknown);
    else
      {
        fail ("REVOLVEDSURFACE.unknown [RC] %u != %u", revolvedsurface->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown) &&
        unknown == revolvedsurface->unknown)
      pass ("REVOLVEDSURFACE.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("REVOLVEDSURFACE.unknown [RC] set+1 %u != %u", revolvedsurface->unknown, unknown); error++;
      }
    revolvedsurface->unknown--;

  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == revolvedsurface->unknown_2007)
      pass ("REVOLVEDSURFACE.unknown_2007 [BL] %u", unknown_2007);
    else
      {
        fail ("REVOLVEDSURFACE.unknown_2007 [BL] %u != %u", revolvedsurface->unknown_2007, unknown_2007); error++;
      }
    unknown_2007++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "unknown_2007", &unknown_2007) &&
        unknown_2007 == revolvedsurface->unknown_2007)
      pass ("REVOLVEDSURFACE.unknown_2007 [BL] set+1 %u", unknown_2007);
    else
      {
        fail ("REVOLVEDSURFACE.unknown_2007 [BL] set+1 %u != %u", revolvedsurface->unknown_2007, unknown_2007); error++;
      }
    revolvedsurface->unknown_2007--;

  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == revolvedsurface->v_isolines)
      pass ("REVOLVEDSURFACE.v_isolines [BS] %hu", v_isolines);
    else
      {
        fail ("REVOLVEDSURFACE.v_isolines [BS] %hu != %hu", revolvedsurface->v_isolines, v_isolines); error++;
      }
    v_isolines++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines) &&
        v_isolines == revolvedsurface->v_isolines)
      pass ("REVOLVEDSURFACE.v_isolines [BS] set+1 %hu", v_isolines);
    else
      {
        fail ("REVOLVEDSURFACE.v_isolines [BS] set+1 %hu != %hu", revolvedsurface->v_isolines, v_isolines); error++;
      }
    revolvedsurface->v_isolines--;

  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "version", &version, NULL) &&
        version == revolvedsurface->version)
      pass ("REVOLVEDSURFACE.version [BS] %hu", version);
    else
      {
        fail ("REVOLVEDSURFACE.version [BS] %hu != %hu", revolvedsurface->version, version); error++;
      }
    version++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "version", &version) &&
        version == revolvedsurface->version)
      pass ("REVOLVEDSURFACE.version [BS] set+1 %hu", version);
    else
      {
        fail ("REVOLVEDSURFACE.version [BS] set+1 %hu != %hu", revolvedsurface->version, version); error++;
      }
    revolvedsurface->version--;

  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == revolvedsurface->wireframe_data_present)
      pass ("REVOLVEDSURFACE.wireframe_data_present [RC] %u", wireframe_data_present);
    else
      {
        fail ("REVOLVEDSURFACE.wireframe_data_present [RC] %u != %u", revolvedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value(revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present) &&
        wireframe_data_present == revolvedsurface->wireframe_data_present)
      pass ("REVOLVEDSURFACE.wireframe_data_present [RC] set+1 %u", wireframe_data_present);
    else
      {
        fail ("REVOLVEDSURFACE.wireframe_data_present [RC] set+1 %u != %u", revolvedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
    revolvedsurface->wireframe_data_present--;

  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &revolvedsurface->wires, sizeof(revolvedsurface->wires)))
      pass ("REVOLVEDSURFACE.wires [Dwg_3DSOLID_wire*]");
    else
      {
        fail ("REVOLVEDSURFACE.wires [Dwg_3DSOLID_wire*]"); error++;
      }
  }
  return error;
}
static int test_SEQEND (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SEQEND *seqend = obj->tio.entity->tio.SEQEND;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(seqend, "SEQEND", "parent", &parent, NULL)
        && !memcmp(&parent, &seqend->parent, sizeof(seqend->parent)))
      pass ("SEQEND.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("SEQEND.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  return error;
}
static int test_SHAPE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SHAPE *shape = obj->tio.entity->tio.SHAPE;
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &shape->extrusion, sizeof(shape->extrusion)))
      pass ("SHAPE.extrusion [3BD]");
    else
      {
        fail ("SHAPE.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "ins_pt", &ins_pt, NULL)
        && !memcmp(&ins_pt, &shape->ins_pt, sizeof(shape->ins_pt)))
      pass ("SHAPE.ins_pt [3BD]");
    else
      {
        fail ("SHAPE.ins_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BD oblique;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "oblique", &oblique, NULL) &&
        oblique == shape->oblique)
      pass ("SHAPE.oblique [BD] %g", oblique);
    else
      {
        fail ("SHAPE.oblique [BD] %g != %g", shape->oblique, oblique); error++;
      }
    oblique++;
    if (dwg_dynapi_entity_set_value(shape, "SHAPE", "oblique", &oblique) &&
        oblique == shape->oblique)
      pass ("SHAPE.oblique [BD] set+1 %g", oblique);
    else
      {
        fail ("SHAPE.oblique [BD] set+1 %g != %g", shape->oblique, oblique); error++;
      }
    shape->oblique--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "parent", &parent, NULL)
        && !memcmp(&parent, &shape->parent, sizeof(shape->parent)))
      pass ("SHAPE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("SHAPE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "rotation", &rotation, NULL) &&
        rotation == shape->rotation)
      pass ("SHAPE.rotation [BD] %g", rotation);
    else
      {
        fail ("SHAPE.rotation [BD] %g != %g", shape->rotation, rotation); error++;
      }
    rotation++;
    if (dwg_dynapi_entity_set_value(shape, "SHAPE", "rotation", &rotation) &&
        rotation == shape->rotation)
      pass ("SHAPE.rotation [BD] set+1 %g", rotation);
    else
      {
        fail ("SHAPE.rotation [BD] set+1 %g != %g", shape->rotation, rotation); error++;
      }
    shape->rotation--;

  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "scale", &scale, NULL) &&
        scale == shape->scale)
      pass ("SHAPE.scale [BD] %g", scale);
    else
      {
        fail ("SHAPE.scale [BD] %g != %g", shape->scale, scale); error++;
      }
    scale++;
    if (dwg_dynapi_entity_set_value(shape, "SHAPE", "scale", &scale) &&
        scale == shape->scale)
      pass ("SHAPE.scale [BD] set+1 %g", scale);
    else
      {
        fail ("SHAPE.scale [BD] set+1 %g != %g", shape->scale, scale); error++;
      }
    shape->scale--;

  }
  {
    BITCODE_BS shape_no;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "shape_no", &shape_no, NULL) &&
        shape_no == shape->shape_no)
      pass ("SHAPE.shape_no [BS] %hu", shape_no);
    else
      {
        fail ("SHAPE.shape_no [BS] %hu != %hu", shape->shape_no, shape_no); error++;
      }
    shape_no++;
    if (dwg_dynapi_entity_set_value(shape, "SHAPE", "shape_no", &shape_no) &&
        shape_no == shape->shape_no)
      pass ("SHAPE.shape_no [BS] set+1 %hu", shape_no);
    else
      {
        fail ("SHAPE.shape_no [BS] set+1 %hu != %hu", shape->shape_no, shape_no); error++;
      }
    shape->shape_no--;

  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "style", &style, NULL)
        && !memcmp(&style, &shape->style, sizeof(shape->style)))
      pass ("SHAPE.style [H]");
    else
      {
        fail ("SHAPE.style [H]"); error++;
      }
  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "thickness", &thickness, NULL) &&
        thickness == shape->thickness)
      pass ("SHAPE.thickness [BD] %g", thickness);
    else
      {
        fail ("SHAPE.thickness [BD] %g != %g", shape->thickness, thickness); error++;
      }
    thickness++;
    if (dwg_dynapi_entity_set_value(shape, "SHAPE", "thickness", &thickness) &&
        thickness == shape->thickness)
      pass ("SHAPE.thickness [BD] set+1 %g", thickness);
    else
      {
        fail ("SHAPE.thickness [BD] set+1 %g != %g", shape->thickness, thickness); error++;
      }
    shape->thickness--;

  }
  {
    BITCODE_BD width_factor;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "width_factor", &width_factor, NULL) &&
        width_factor == shape->width_factor)
      pass ("SHAPE.width_factor [BD] %g", width_factor);
    else
      {
        fail ("SHAPE.width_factor [BD] %g != %g", shape->width_factor, width_factor); error++;
      }
    width_factor++;
    if (dwg_dynapi_entity_set_value(shape, "SHAPE", "width_factor", &width_factor) &&
        width_factor == shape->width_factor)
      pass ("SHAPE.width_factor [BD] set+1 %g", width_factor);
    else
      {
        fail ("SHAPE.width_factor [BD] set+1 %g != %g", shape->width_factor, width_factor); error++;
      }
    shape->width_factor--;

  }
  return error;
}
static int test_SOLID (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SOLID *solid = obj->tio.entity->tio.SOLID;
  {
    BITCODE_2RD corner1;
    if (dwg_dynapi_entity_value(solid, "SOLID", "corner1", &corner1, NULL)
        && !memcmp(&corner1, &solid->corner1, sizeof(solid->corner1)))
      pass ("SOLID.corner1 [2RD]");
    else
      {
        fail ("SOLID.corner1 [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD corner2;
    if (dwg_dynapi_entity_value(solid, "SOLID", "corner2", &corner2, NULL)
        && !memcmp(&corner2, &solid->corner2, sizeof(solid->corner2)))
      pass ("SOLID.corner2 [2RD]");
    else
      {
        fail ("SOLID.corner2 [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD corner3;
    if (dwg_dynapi_entity_value(solid, "SOLID", "corner3", &corner3, NULL)
        && !memcmp(&corner3, &solid->corner3, sizeof(solid->corner3)))
      pass ("SOLID.corner3 [2RD]");
    else
      {
        fail ("SOLID.corner3 [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD corner4;
    if (dwg_dynapi_entity_value(solid, "SOLID", "corner4", &corner4, NULL)
        && !memcmp(&corner4, &solid->corner4, sizeof(solid->corner4)))
      pass ("SOLID.corner4 [2RD]");
    else
      {
        fail ("SOLID.corner4 [2RD]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(solid, "SOLID", "elevation", &elevation, NULL) &&
        elevation == solid->elevation)
      pass ("SOLID.elevation [BD] %g", elevation);
    else
      {
        fail ("SOLID.elevation [BD] %g != %g", solid->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(solid, "SOLID", "elevation", &elevation) &&
        elevation == solid->elevation)
      pass ("SOLID.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("SOLID.elevation [BD] set+1 %g != %g", solid->elevation, elevation); error++;
      }
    solid->elevation--;

  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(solid, "SOLID", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &solid->extrusion, sizeof(solid->extrusion)))
      pass ("SOLID.extrusion [BE]");
    else
      {
        fail ("SOLID.extrusion [BE]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(solid, "SOLID", "parent", &parent, NULL)
        && !memcmp(&parent, &solid->parent, sizeof(solid->parent)))
      pass ("SOLID.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("SOLID.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(solid, "SOLID", "thickness", &thickness, NULL) &&
        thickness == solid->thickness)
      pass ("SOLID.thickness [BT] " FORMAT_BT "", thickness);
    else
      {
        fail ("SOLID.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", solid->thickness, thickness); error++;
      }
    if (dwg_dynapi_entity_set_value(solid, "SOLID", "thickness", &thickness) &&
        thickness == solid->thickness)
      pass ("SOLID.thickness [BT] set+1 " FORMAT_BT "", thickness);
    else
      {
        fail ("SOLID.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", solid->thickness, thickness); error++;
      }
    solid->thickness--;

  }
  return error;
}
static int test_SPLINE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SPLINE *spline = obj->tio.entity->tio.SPLINE;
  {
    BITCODE_3BD beg_tan_vec;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "beg_tan_vec", &beg_tan_vec, NULL)
        && !memcmp(&beg_tan_vec, &spline->beg_tan_vec, sizeof(spline->beg_tan_vec)))
      pass ("SPLINE.beg_tan_vec [3BD]");
    else
      {
        fail ("SPLINE.beg_tan_vec [3BD]"); error++;
      }
  }
  {
    BITCODE_B closed_b;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "closed_b", &closed_b, NULL) &&
        closed_b == spline->closed_b)
      pass ("SPLINE.closed_b [B] " FORMAT_B "", closed_b);
    else
      {
        fail ("SPLINE.closed_b [B] " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b); error++;
      }
    closed_b++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "closed_b", &closed_b) &&
        closed_b == spline->closed_b)
      pass ("SPLINE.closed_b [B] set+1 " FORMAT_B "", closed_b);
    else
      {
        fail ("SPLINE.closed_b [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b); error++;
      }
    spline->closed_b--;

  }
  {
    Dwg_SPLINE_control_point* ctrl_pts;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "ctrl_pts", &ctrl_pts, NULL)
        && !memcmp(&ctrl_pts, &spline->ctrl_pts, sizeof(spline->ctrl_pts)))
      pass ("SPLINE.ctrl_pts [Dwg_SPLINE_control_point*]");
    else
      {
        fail ("SPLINE.ctrl_pts [Dwg_SPLINE_control_point*]"); error++;
      }
  }
  {
    BITCODE_BD ctrl_tol;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "ctrl_tol", &ctrl_tol, NULL) &&
        ctrl_tol == spline->ctrl_tol)
      pass ("SPLINE.ctrl_tol [BD] %g", ctrl_tol);
    else
      {
        fail ("SPLINE.ctrl_tol [BD] %g != %g", spline->ctrl_tol, ctrl_tol); error++;
      }
    ctrl_tol++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "ctrl_tol", &ctrl_tol) &&
        ctrl_tol == spline->ctrl_tol)
      pass ("SPLINE.ctrl_tol [BD] set+1 %g", ctrl_tol);
    else
      {
        fail ("SPLINE.ctrl_tol [BD] set+1 %g != %g", spline->ctrl_tol, ctrl_tol); error++;
      }
    spline->ctrl_tol--;

  }
  {
    BITCODE_BS degree;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "degree", &degree, NULL) &&
        degree == spline->degree)
      pass ("SPLINE.degree [BS] %hu", degree);
    else
      {
        fail ("SPLINE.degree [BS] %hu != %hu", spline->degree, degree); error++;
      }
    degree++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "degree", &degree) &&
        degree == spline->degree)
      pass ("SPLINE.degree [BS] set+1 %hu", degree);
    else
      {
        fail ("SPLINE.degree [BS] set+1 %hu != %hu", spline->degree, degree); error++;
      }
    spline->degree--;

  }
  {
    BITCODE_3BD end_tan_vec;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "end_tan_vec", &end_tan_vec, NULL)
        && !memcmp(&end_tan_vec, &spline->end_tan_vec, sizeof(spline->end_tan_vec)))
      pass ("SPLINE.end_tan_vec [3BD]");
    else
      {
        fail ("SPLINE.end_tan_vec [3BD]"); error++;
      }
  }
  {
    Dwg_SPLINE_point* fit_pts;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "fit_pts", &fit_pts, NULL)
        && !memcmp(&fit_pts, &spline->fit_pts, sizeof(spline->fit_pts)))
      pass ("SPLINE.fit_pts [Dwg_SPLINE_point*]");
    else
      {
        fail ("SPLINE.fit_pts [Dwg_SPLINE_point*]"); error++;
      }
  }
  {
    BITCODE_BD fit_tol;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "fit_tol", &fit_tol, NULL) &&
        fit_tol == spline->fit_tol)
      pass ("SPLINE.fit_tol [BD] %g", fit_tol);
    else
      {
        fail ("SPLINE.fit_tol [BD] %g != %g", spline->fit_tol, fit_tol); error++;
      }
    fit_tol++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "fit_tol", &fit_tol) &&
        fit_tol == spline->fit_tol)
      pass ("SPLINE.fit_tol [BD] set+1 %g", fit_tol);
    else
      {
        fail ("SPLINE.fit_tol [BD] set+1 %g != %g", spline->fit_tol, fit_tol); error++;
      }
    spline->fit_tol--;

  }
  {
    BITCODE_RS flag;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "flag", &flag, NULL) &&
        flag == spline->flag)
      pass ("SPLINE.flag [RS] %hu", flag);
    else
      {
        fail ("SPLINE.flag [RS] %hu != %hu", spline->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "flag", &flag) &&
        flag == spline->flag)
      pass ("SPLINE.flag [RS] set+1 %hu", flag);
    else
      {
        fail ("SPLINE.flag [RS] set+1 %hu != %hu", spline->flag, flag); error++;
      }
    spline->flag--;

  }
  {
    BITCODE_BD knot_tol;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "knot_tol", &knot_tol, NULL) &&
        knot_tol == spline->knot_tol)
      pass ("SPLINE.knot_tol [BD] %g", knot_tol);
    else
      {
        fail ("SPLINE.knot_tol [BD] %g != %g", spline->knot_tol, knot_tol); error++;
      }
    knot_tol++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "knot_tol", &knot_tol) &&
        knot_tol == spline->knot_tol)
      pass ("SPLINE.knot_tol [BD] set+1 %g", knot_tol);
    else
      {
        fail ("SPLINE.knot_tol [BD] set+1 %g != %g", spline->knot_tol, knot_tol); error++;
      }
    spline->knot_tol--;

  }
  {
    BITCODE_BL knotparam;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "knotparam", &knotparam, NULL) &&
        knotparam == spline->knotparam)
      pass ("SPLINE.knotparam [BL] %u", knotparam);
    else
      {
        fail ("SPLINE.knotparam [BL] %u != %u", spline->knotparam, knotparam); error++;
      }
    knotparam++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "knotparam", &knotparam) &&
        knotparam == spline->knotparam)
      pass ("SPLINE.knotparam [BL] set+1 %u", knotparam);
    else
      {
        fail ("SPLINE.knotparam [BL] set+1 %u != %u", spline->knotparam, knotparam); error++;
      }
    spline->knotparam--;

  }
  {
    BITCODE_BD* knots;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "knots", &knots, NULL)
        && !memcmp(&knots, &spline->knots, sizeof(spline->knots)))
      pass ("SPLINE.knots [BD*]");
    else
      {
        fail ("SPLINE.knots [BD*]"); error++;
      }
  }
  {
    BITCODE_BL num_ctrl_pts;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts, NULL) &&
        num_ctrl_pts == spline->num_ctrl_pts)
      pass ("SPLINE.num_ctrl_pts [BL] %u", num_ctrl_pts);
    else
      {
        fail ("SPLINE.num_ctrl_pts [BL] %u != %u", spline->num_ctrl_pts, num_ctrl_pts); error++;
      }
    num_ctrl_pts++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts) &&
        num_ctrl_pts == spline->num_ctrl_pts)
      pass ("SPLINE.num_ctrl_pts [BL] set+1 %u", num_ctrl_pts);
    else
      {
        fail ("SPLINE.num_ctrl_pts [BL] set+1 %u != %u", spline->num_ctrl_pts, num_ctrl_pts); error++;
      }
    spline->num_ctrl_pts--;

  }
  {
    BITCODE_BS num_fit_pts;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "num_fit_pts", &num_fit_pts, NULL) &&
        num_fit_pts == spline->num_fit_pts)
      pass ("SPLINE.num_fit_pts [BS] %hu", num_fit_pts);
    else
      {
        fail ("SPLINE.num_fit_pts [BS] %hu != %hu", spline->num_fit_pts, num_fit_pts); error++;
      }
    num_fit_pts++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "num_fit_pts", &num_fit_pts) &&
        num_fit_pts == spline->num_fit_pts)
      pass ("SPLINE.num_fit_pts [BS] set+1 %hu", num_fit_pts);
    else
      {
        fail ("SPLINE.num_fit_pts [BS] set+1 %hu != %hu", spline->num_fit_pts, num_fit_pts); error++;
      }
    spline->num_fit_pts--;

  }
  {
    BITCODE_BL num_knots;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "num_knots", &num_knots, NULL) &&
        num_knots == spline->num_knots)
      pass ("SPLINE.num_knots [BL] %u", num_knots);
    else
      {
        fail ("SPLINE.num_knots [BL] %u != %u", spline->num_knots, num_knots); error++;
      }
    num_knots++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "num_knots", &num_knots) &&
        num_knots == spline->num_knots)
      pass ("SPLINE.num_knots [BL] set+1 %u", num_knots);
    else
      {
        fail ("SPLINE.num_knots [BL] set+1 %u != %u", spline->num_knots, num_knots); error++;
      }
    spline->num_knots--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "parent", &parent, NULL)
        && !memcmp(&parent, &spline->parent, sizeof(spline->parent)))
      pass ("SPLINE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("SPLINE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_B periodic;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "periodic", &periodic, NULL) &&
        periodic == spline->periodic)
      pass ("SPLINE.periodic [B] " FORMAT_B "", periodic);
    else
      {
        fail ("SPLINE.periodic [B] " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic); error++;
      }
    periodic++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "periodic", &periodic) &&
        periodic == spline->periodic)
      pass ("SPLINE.periodic [B] set+1 " FORMAT_B "", periodic);
    else
      {
        fail ("SPLINE.periodic [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic); error++;
      }
    spline->periodic--;

  }
  {
    BITCODE_B rational;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "rational", &rational, NULL) &&
        rational == spline->rational)
      pass ("SPLINE.rational [B] " FORMAT_B "", rational);
    else
      {
        fail ("SPLINE.rational [B] " FORMAT_B " != " FORMAT_B "", spline->rational, rational); error++;
      }
    rational++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "rational", &rational) &&
        rational == spline->rational)
      pass ("SPLINE.rational [B] set+1 " FORMAT_B "", rational);
    else
      {
        fail ("SPLINE.rational [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->rational, rational); error++;
      }
    spline->rational--;

  }
  {
    BITCODE_BS scenario;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "scenario", &scenario, NULL) &&
        scenario == spline->scenario)
      pass ("SPLINE.scenario [BS] %hu", scenario);
    else
      {
        fail ("SPLINE.scenario [BS] %hu != %hu", spline->scenario, scenario); error++;
      }
    scenario++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "scenario", &scenario) &&
        scenario == spline->scenario)
      pass ("SPLINE.scenario [BS] set+1 %hu", scenario);
    else
      {
        fail ("SPLINE.scenario [BS] set+1 %hu != %hu", spline->scenario, scenario); error++;
      }
    spline->scenario--;

  }
  {
    BITCODE_BL splineflags1;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "splineflags1", &splineflags1, NULL) &&
        splineflags1 == spline->splineflags1)
      pass ("SPLINE.splineflags1 [BL] %u", splineflags1);
    else
      {
        fail ("SPLINE.splineflags1 [BL] %u != %u", spline->splineflags1, splineflags1); error++;
      }
    splineflags1++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "splineflags1", &splineflags1) &&
        splineflags1 == spline->splineflags1)
      pass ("SPLINE.splineflags1 [BL] set+1 %u", splineflags1);
    else
      {
        fail ("SPLINE.splineflags1 [BL] set+1 %u != %u", spline->splineflags1, splineflags1); error++;
      }
    spline->splineflags1--;

  }
  {
    BITCODE_B weighted;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "weighted", &weighted, NULL) &&
        weighted == spline->weighted)
      pass ("SPLINE.weighted [B] " FORMAT_B "", weighted);
    else
      {
        fail ("SPLINE.weighted [B] " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted); error++;
      }
    weighted++;
    if (dwg_dynapi_entity_set_value(spline, "SPLINE", "weighted", &weighted) &&
        weighted == spline->weighted)
      pass ("SPLINE.weighted [B] set+1 " FORMAT_B "", weighted);
    else
      {
        fail ("SPLINE.weighted [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted); error++;
      }
    spline->weighted--;

  }
  return error;
}
static int test_SWEPTSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SWEPTSURFACE *sweptsurface = obj->tio.entity->tio.SWEPTSURFACE;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&sweptsurface->acis_data))
      pass ("SWEPTSURFACE.acis_data [RC*]");
    else
      {
        fail ("SWEPTSURFACE.acis_data [RC*]"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == sweptsurface->acis_empty)
      pass ("SWEPTSURFACE.acis_empty [RC] %u", acis_empty);
    else
      {
        fail ("SWEPTSURFACE.acis_empty [RC] %u != %u", sweptsurface->acis_empty, acis_empty); error++;
      }
    acis_empty++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty) &&
        acis_empty == sweptsurface->acis_empty)
      pass ("SWEPTSURFACE.acis_empty [RC] set+1 %u", acis_empty);
    else
      {
        fail ("SWEPTSURFACE.acis_empty [RC] set+1 %u != %u", sweptsurface->acis_empty, acis_empty); error++;
      }
    sweptsurface->acis_empty--;

  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == sweptsurface->acis_empty2)
      pass ("SWEPTSURFACE.acis_empty2 [RC] %u", acis_empty2);
    else
      {
        fail ("SWEPTSURFACE.acis_empty2 [RC] %u != %u", sweptsurface->acis_empty2, acis_empty2); error++;
      }
    acis_empty2++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2) &&
        acis_empty2 == sweptsurface->acis_empty2)
      pass ("SWEPTSURFACE.acis_empty2 [RC] set+1 %u", acis_empty2);
    else
      {
        fail ("SWEPTSURFACE.acis_empty2 [RC] set+1 %u != %u", sweptsurface->acis_empty2, acis_empty2); error++;
      }
    sweptsurface->acis_empty2--;

  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == sweptsurface->acis_empty_bit)
      pass ("SWEPTSURFACE.acis_empty_bit [RC] %u", acis_empty_bit);
    else
      {
        fail ("SWEPTSURFACE.acis_empty_bit [RC] %u != %u", sweptsurface->acis_empty_bit, acis_empty_bit); error++;
      }
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit) &&
        acis_empty_bit == sweptsurface->acis_empty_bit)
      pass ("SWEPTSURFACE.acis_empty_bit [RC] set+1 %u", acis_empty_bit);
    else
      {
        fail ("SWEPTSURFACE.acis_empty_bit [RC] set+1 %u != %u", sweptsurface->acis_empty_bit, acis_empty_bit); error++;
      }
    sweptsurface->acis_empty_bit--;

  }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle, NULL) &&
        align_angle == sweptsurface->align_angle)
      pass ("SWEPTSURFACE.align_angle [BD] %g", align_angle);
    else
      {
        fail ("SWEPTSURFACE.align_angle [BD] %g != %g", sweptsurface->align_angle, align_angle); error++;
      }
    align_angle++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle) &&
        align_angle == sweptsurface->align_angle)
      pass ("SWEPTSURFACE.align_angle [BD] set+1 %g", align_angle);
    else
      {
        fail ("SWEPTSURFACE.align_angle [BD] set+1 %g != %g", sweptsurface->align_angle, align_angle); error++;
      }
    sweptsurface->align_angle--;

  }
  {
    BITCODE_B align_start;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "align_start", &align_start, NULL) &&
        align_start == sweptsurface->align_start)
      pass ("SWEPTSURFACE.align_start [B] " FORMAT_B "", align_start);
    else
      {
        fail ("SWEPTSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start); error++;
      }
    align_start++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "align_start", &align_start) &&
        align_start == sweptsurface->align_start)
      pass ("SWEPTSURFACE.align_start [B] set+1 " FORMAT_B "", align_start);
    else
      {
        fail ("SWEPTSURFACE.align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start); error++;
      }
    sweptsurface->align_start--;

  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "bank", &bank, NULL) &&
        bank == sweptsurface->bank)
      pass ("SWEPTSURFACE.bank [B] " FORMAT_B "", bank);
    else
      {
        fail ("SWEPTSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank); error++;
      }
    bank++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "bank", &bank) &&
        bank == sweptsurface->bank)
      pass ("SWEPTSURFACE.bank [B] set+1 " FORMAT_B "", bank);
    else
      {
        fail ("SWEPTSURFACE.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank); error++;
      }
    sweptsurface->bank--;

  }
  {
    BITCODE_B base_point_set;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set, NULL) &&
        base_point_set == sweptsurface->base_point_set)
      pass ("SWEPTSURFACE.base_point_set [B] " FORMAT_B "", base_point_set);
    else
      {
        fail ("SWEPTSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set); error++;
      }
    base_point_set++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set) &&
        base_point_set == sweptsurface->base_point_set)
      pass ("SWEPTSURFACE.base_point_set [B] set+1 " FORMAT_B "", base_point_set);
    else
      {
        fail ("SWEPTSURFACE.base_point_set [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set); error++;
      }
    sweptsurface->base_point_set--;

  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &sweptsurface->block_size, sizeof(sweptsurface->block_size)))
      pass ("SWEPTSURFACE.block_size [BL*]");
    else
      {
        fail ("SWEPTSURFACE.block_size [BL*]"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "class_version", &class_version, NULL) &&
        class_version == sweptsurface->class_version)
      pass ("SWEPTSURFACE.class_version [BL] %u", class_version);
    else
      {
        fail ("SWEPTSURFACE.class_version [BL] %u != %u", sweptsurface->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "class_version", &class_version) &&
        class_version == sweptsurface->class_version)
      pass ("SWEPTSURFACE.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("SWEPTSURFACE.class_version [BL] set+1 %u != %u", sweptsurface->class_version, class_version); error++;
      }
    sweptsurface->class_version--;

  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle, NULL) &&
        draft_angle == sweptsurface->draft_angle)
      pass ("SWEPTSURFACE.draft_angle [BD] %g", draft_angle);
    else
      {
        fail ("SWEPTSURFACE.draft_angle [BD] %g != %g", sweptsurface->draft_angle, draft_angle); error++;
      }
    draft_angle++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle) &&
        draft_angle == sweptsurface->draft_angle)
      pass ("SWEPTSURFACE.draft_angle [BD] set+1 %g", draft_angle);
    else
      {
        fail ("SWEPTSURFACE.draft_angle [BD] set+1 %g != %g", sweptsurface->draft_angle, draft_angle); error++;
      }
    sweptsurface->draft_angle--;

  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance, NULL) &&
        draft_end_distance == sweptsurface->draft_end_distance)
      pass ("SWEPTSURFACE.draft_end_distance [BD] %g", draft_end_distance);
    else
      {
        fail ("SWEPTSURFACE.draft_end_distance [BD] %g != %g", sweptsurface->draft_end_distance, draft_end_distance); error++;
      }
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance) &&
        draft_end_distance == sweptsurface->draft_end_distance)
      pass ("SWEPTSURFACE.draft_end_distance [BD] set+1 %g", draft_end_distance);
    else
      {
        fail ("SWEPTSURFACE.draft_end_distance [BD] set+1 %g != %g", sweptsurface->draft_end_distance, draft_end_distance); error++;
      }
    sweptsurface->draft_end_distance--;

  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance, NULL) &&
        draft_start_distance == sweptsurface->draft_start_distance)
      pass ("SWEPTSURFACE.draft_start_distance [BD] %g", draft_start_distance);
    else
      {
        fail ("SWEPTSURFACE.draft_start_distance [BD] %g != %g", sweptsurface->draft_start_distance, draft_start_distance); error++;
      }
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance) &&
        draft_start_distance == sweptsurface->draft_start_distance)
      pass ("SWEPTSURFACE.draft_start_distance [BD] set+1 %g", draft_start_distance);
    else
      {
        fail ("SWEPTSURFACE.draft_start_distance [BD] set+1 %g != %g", sweptsurface->draft_start_distance, draft_start_distance); error++;
      }
    sweptsurface->draft_start_distance--;

  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&sweptsurface->encr_sat_data))
      pass ("SWEPTSURFACE.encr_sat_data [TV]");
    else
      {
        fail ("SWEPTSURFACE.encr_sat_data [TV]"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &sweptsurface->extra_acis_data, sizeof(sweptsurface->extra_acis_data)))
      pass ("SWEPTSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
    else
      {
        fail ("SWEPTSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]"); error++;
      }
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &sweptsurface->history_id, sizeof(sweptsurface->history_id)))
      pass ("SWEPTSURFACE.history_id [H]");
    else
      {
        fail ("SWEPTSURFACE.history_id [H]"); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == sweptsurface->isoline_present)
      pass ("SWEPTSURFACE.isoline_present [RC] %u", isoline_present);
    else
      {
        fail ("SWEPTSURFACE.isoline_present [RC] %u != %u", sweptsurface->isoline_present, isoline_present); error++;
      }
    isoline_present++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present) &&
        isoline_present == sweptsurface->isoline_present)
      pass ("SWEPTSURFACE.isoline_present [RC] set+1 %u", isoline_present);
    else
      {
        fail ("SWEPTSURFACE.isoline_present [RC] set+1 %u != %u", sweptsurface->isoline_present, isoline_present); error++;
      }
    sweptsurface->isoline_present--;

  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == sweptsurface->modeler_format_version)
      pass ("SWEPTSURFACE.modeler_format_version [BS] %hu", modeler_format_version);
    else
      {
        fail ("SWEPTSURFACE.modeler_format_version [BS] %hu != %hu", sweptsurface->modeler_format_version, modeler_format_version); error++;
      }
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version) &&
        modeler_format_version == sweptsurface->modeler_format_version)
      pass ("SWEPTSURFACE.modeler_format_version [BS] set+1 %hu", modeler_format_version);
    else
      {
        fail ("SWEPTSURFACE.modeler_format_version [BS] set+1 %hu != %hu", sweptsurface->modeler_format_version, modeler_format_version); error++;
      }
    sweptsurface->modeler_format_version--;

  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == sweptsurface->num_blocks)
      pass ("SWEPTSURFACE.num_blocks [BL] %u", num_blocks);
    else
      {
        fail ("SWEPTSURFACE.num_blocks [BL] %u != %u", sweptsurface->num_blocks, num_blocks); error++;
      }
    num_blocks++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks) &&
        num_blocks == sweptsurface->num_blocks)
      pass ("SWEPTSURFACE.num_blocks [BL] set+1 %u", num_blocks);
    else
      {
        fail ("SWEPTSURFACE.num_blocks [BL] set+1 %u != %u", sweptsurface->num_blocks, num_blocks); error++;
      }
    sweptsurface->num_blocks--;

  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == sweptsurface->num_isolines)
      pass ("SWEPTSURFACE.num_isolines [BL] %u", num_isolines);
    else
      {
        fail ("SWEPTSURFACE.num_isolines [BL] %u != %u", sweptsurface->num_isolines, num_isolines); error++;
      }
    num_isolines++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "num_isolines", &num_isolines) &&
        num_isolines == sweptsurface->num_isolines)
      pass ("SWEPTSURFACE.num_isolines [BL] set+1 %u", num_isolines);
    else
      {
        fail ("SWEPTSURFACE.num_isolines [BL] set+1 %u != %u", sweptsurface->num_isolines, num_isolines); error++;
      }
    sweptsurface->num_isolines--;

  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == sweptsurface->num_silhouettes)
      pass ("SWEPTSURFACE.num_silhouettes [BL] %u", num_silhouettes);
    else
      {
        fail ("SWEPTSURFACE.num_silhouettes [BL] %u != %u", sweptsurface->num_silhouettes, num_silhouettes); error++;
      }
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes) &&
        num_silhouettes == sweptsurface->num_silhouettes)
      pass ("SWEPTSURFACE.num_silhouettes [BL] set+1 %u", num_silhouettes);
    else
      {
        fail ("SWEPTSURFACE.num_silhouettes [BL] set+1 %u != %u", sweptsurface->num_silhouettes, num_silhouettes); error++;
      }
    sweptsurface->num_silhouettes--;

  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == sweptsurface->num_wires)
      pass ("SWEPTSURFACE.num_wires [BL] %u", num_wires);
    else
      {
        fail ("SWEPTSURFACE.num_wires [BL] %u != %u", sweptsurface->num_wires, num_wires); error++;
      }
    num_wires++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires) &&
        num_wires == sweptsurface->num_wires)
      pass ("SWEPTSURFACE.num_wires [BL] set+1 %u", num_wires);
    else
      {
        fail ("SWEPTSURFACE.num_wires [BL] set+1 %u != %u", sweptsurface->num_wires, num_wires); error++;
      }
    sweptsurface->num_wires--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &sweptsurface->parent, sizeof(sweptsurface->parent)))
      pass ("SWEPTSURFACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("SWEPTSURFACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BL path_entity_id;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id, NULL) &&
        path_entity_id == sweptsurface->path_entity_id)
      pass ("SWEPTSURFACE.path_entity_id [BL] %u", path_entity_id);
    else
      {
        fail ("SWEPTSURFACE.path_entity_id [BL] %u != %u", sweptsurface->path_entity_id, path_entity_id); error++;
      }
    path_entity_id++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id) &&
        path_entity_id == sweptsurface->path_entity_id)
      pass ("SWEPTSURFACE.path_entity_id [BL] set+1 %u", path_entity_id);
    else
      {
        fail ("SWEPTSURFACE.path_entity_id [BL] set+1 %u != %u", sweptsurface->path_entity_id, path_entity_id); error++;
      }
    sweptsurface->path_entity_id--;

  }
  {
    BITCODE_B path_entity_transform_computed;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL) &&
        path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
      pass ("SWEPTSURFACE.path_entity_transform_computed [B] " FORMAT_B "", path_entity_transform_computed);
    else
      {
        fail ("SWEPTSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed); error++;
      }
    path_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed) &&
        path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
      pass ("SWEPTSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B "", path_entity_transform_computed);
    else
      {
        fail ("SWEPTSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed); error++;
      }
    sweptsurface->path_entity_transform_computed--;

  }
  {
    BITCODE_BD* path_entity_transmatrix;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
        && !memcmp(&path_entity_transmatrix, &sweptsurface->path_entity_transmatrix, sizeof(sweptsurface->path_entity_transmatrix)))
      pass ("SWEPTSURFACE.path_entity_transmatrix [BD*]");
    else
      {
        fail ("SWEPTSURFACE.path_entity_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BD* path_entity_transmatrix1;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "path_entity_transmatrix1", &path_entity_transmatrix1, NULL)
        && !memcmp(&path_entity_transmatrix1, &sweptsurface->path_entity_transmatrix1, sizeof(sweptsurface->path_entity_transmatrix1)))
      pass ("SWEPTSURFACE.path_entity_transmatrix1 [BD*]");
    else
      {
        fail ("SWEPTSURFACE.path_entity_transmatrix1 [BD*]"); error++;
      }
  }
  {
    BITCODE_TF pathdata;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "pathdata", &pathdata, NULL)
        && !memcmp(&pathdata, &sweptsurface->pathdata, sizeof(sweptsurface->pathdata)))
      pass ("SWEPTSURFACE.pathdata [TF]");
    else
      {
        fail ("SWEPTSURFACE.pathdata [TF]"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "point", &point, NULL)
        && !memcmp(&point, &sweptsurface->point, sizeof(sweptsurface->point)))
      pass ("SWEPTSURFACE.point [3BD]");
    else
      {
        fail ("SWEPTSURFACE.point [3BD]"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "point_present", &point_present, NULL) &&
        point_present == sweptsurface->point_present)
      pass ("SWEPTSURFACE.point_present [RC] %u", point_present);
    else
      {
        fail ("SWEPTSURFACE.point_present [RC] %u != %u", sweptsurface->point_present, point_present); error++;
      }
    point_present++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "point_present", &point_present) &&
        point_present == sweptsurface->point_present)
      pass ("SWEPTSURFACE.point_present [RC] set+1 %u", point_present);
    else
      {
        fail ("SWEPTSURFACE.point_present [RC] set+1 %u != %u", sweptsurface->point_present, point_present); error++;
      }
    sweptsurface->point_present--;

  }
  {
    BITCODE_3BD reference_vector_for_controlling_twist;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
        && !memcmp(&reference_vector_for_controlling_twist, &sweptsurface->reference_vector_for_controlling_twist, sizeof(sweptsurface->reference_vector_for_controlling_twist)))
      pass ("SWEPTSURFACE.reference_vector_for_controlling_twist [3BD]");
    else
      {
        fail ("SWEPTSURFACE.reference_vector_for_controlling_twist [3BD]"); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor, NULL) &&
        scale_factor == sweptsurface->scale_factor)
      pass ("SWEPTSURFACE.scale_factor [BD] %g", scale_factor);
    else
      {
        fail ("SWEPTSURFACE.scale_factor [BD] %g != %g", sweptsurface->scale_factor, scale_factor); error++;
      }
    scale_factor++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor) &&
        scale_factor == sweptsurface->scale_factor)
      pass ("SWEPTSURFACE.scale_factor [BD] set+1 %g", scale_factor);
    else
      {
        fail ("SWEPTSURFACE.scale_factor [BD] set+1 %g != %g", sweptsurface->scale_factor, scale_factor); error++;
      }
    sweptsurface->scale_factor--;

  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &sweptsurface->silhouettes, sizeof(sweptsurface->silhouettes)))
      pass ("SWEPTSURFACE.silhouettes [Dwg_3DSOLID_silhouette*]");
    else
      {
        fail ("SWEPTSURFACE.silhouettes [Dwg_3DSOLID_silhouette*]"); error++;
      }
  }
  {
    BITCODE_BL size_pathdata;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "size_pathdata", &size_pathdata, NULL) &&
        size_pathdata == sweptsurface->size_pathdata)
      pass ("SWEPTSURFACE.size_pathdata [BL] %u", size_pathdata);
    else
      {
        fail ("SWEPTSURFACE.size_pathdata [BL] %u != %u", sweptsurface->size_pathdata, size_pathdata); error++;
      }
    size_pathdata++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "size_pathdata", &size_pathdata) &&
        size_pathdata == sweptsurface->size_pathdata)
      pass ("SWEPTSURFACE.size_pathdata [BL] set+1 %u", size_pathdata);
    else
      {
        fail ("SWEPTSURFACE.size_pathdata [BL] set+1 %u != %u", sweptsurface->size_pathdata, size_pathdata); error++;
      }
    sweptsurface->size_pathdata--;

  }
  {
    BITCODE_BL size_sweepdata;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "size_sweepdata", &size_sweepdata, NULL) &&
        size_sweepdata == sweptsurface->size_sweepdata)
      pass ("SWEPTSURFACE.size_sweepdata [BL] %u", size_sweepdata);
    else
      {
        fail ("SWEPTSURFACE.size_sweepdata [BL] %u != %u", sweptsurface->size_sweepdata, size_sweepdata); error++;
      }
    size_sweepdata++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "size_sweepdata", &size_sweepdata) &&
        size_sweepdata == sweptsurface->size_sweepdata)
      pass ("SWEPTSURFACE.size_sweepdata [BL] set+1 %u", size_sweepdata);
    else
      {
        fail ("SWEPTSURFACE.size_sweepdata [BL] set+1 %u != %u", sweptsurface->size_sweepdata, size_sweepdata); error++;
      }
    sweptsurface->size_sweepdata--;

  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "solid", &solid, NULL) &&
        solid == sweptsurface->solid)
      pass ("SWEPTSURFACE.solid [B] " FORMAT_B "", solid);
    else
      {
        fail ("SWEPTSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->solid, solid); error++;
      }
    solid++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "solid", &solid) &&
        solid == sweptsurface->solid)
      pass ("SWEPTSURFACE.solid [B] set+1 " FORMAT_B "", solid);
    else
      {
        fail ("SWEPTSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->solid, solid); error++;
      }
    sweptsurface->solid--;

  }
  {
    BITCODE_RC sweep_alignment;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_alignment", &sweep_alignment, NULL) &&
        sweep_alignment == sweptsurface->sweep_alignment)
      pass ("SWEPTSURFACE.sweep_alignment [RC] %u", sweep_alignment);
    else
      {
        fail ("SWEPTSURFACE.sweep_alignment [RC] %u != %u", sweptsurface->sweep_alignment, sweep_alignment); error++;
      }
    sweep_alignment++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "sweep_alignment", &sweep_alignment) &&
        sweep_alignment == sweptsurface->sweep_alignment)
      pass ("SWEPTSURFACE.sweep_alignment [RC] set+1 %u", sweep_alignment);
    else
      {
        fail ("SWEPTSURFACE.sweep_alignment [RC] set+1 %u != %u", sweptsurface->sweep_alignment, sweep_alignment); error++;
      }
    sweptsurface->sweep_alignment--;

  }
  {
    BITCODE_BL sweep_entity_id;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id, NULL) &&
        sweep_entity_id == sweptsurface->sweep_entity_id)
      pass ("SWEPTSURFACE.sweep_entity_id [BL] %u", sweep_entity_id);
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_id [BL] %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id); error++;
      }
    sweep_entity_id++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id) &&
        sweep_entity_id == sweptsurface->sweep_entity_id)
      pass ("SWEPTSURFACE.sweep_entity_id [BL] set+1 %u", sweep_entity_id);
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_id [BL] set+1 %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id); error++;
      }
    sweptsurface->sweep_entity_id--;

  }
  {
    BITCODE_B sweep_entity_transform_computed;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL) &&
        sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
      pass ("SWEPTSURFACE.sweep_entity_transform_computed [B] " FORMAT_B "", sweep_entity_transform_computed);
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed); error++;
      }
    sweep_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed) &&
        sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
      pass ("SWEPTSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B "", sweep_entity_transform_computed);
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed); error++;
      }
    sweptsurface->sweep_entity_transform_computed--;

  }
  {
    BITCODE_BD* sweep_entity_transmatrix;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
        && !memcmp(&sweep_entity_transmatrix, &sweptsurface->sweep_entity_transmatrix, sizeof(sweptsurface->sweep_entity_transmatrix)))
      pass ("SWEPTSURFACE.sweep_entity_transmatrix [BD*]");
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BD* sweep_entity_transmatrix1;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_transmatrix1", &sweep_entity_transmatrix1, NULL)
        && !memcmp(&sweep_entity_transmatrix1, &sweptsurface->sweep_entity_transmatrix1, sizeof(sweptsurface->sweep_entity_transmatrix1)))
      pass ("SWEPTSURFACE.sweep_entity_transmatrix1 [BD*]");
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_transmatrix1 [BD*]"); error++;
      }
  }
  {
    BITCODE_TF sweepdata;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweepdata", &sweepdata, NULL)
        && !memcmp(&sweepdata, &sweptsurface->sweepdata, sizeof(sweptsurface->sweepdata)))
      pass ("SWEPTSURFACE.sweepdata [TF]");
    else
      {
        fail ("SWEPTSURFACE.sweepdata [TF]"); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle, NULL) &&
        twist_angle == sweptsurface->twist_angle)
      pass ("SWEPTSURFACE.twist_angle [BD] %g", twist_angle);
    else
      {
        fail ("SWEPTSURFACE.twist_angle [BD] %g != %g", sweptsurface->twist_angle, twist_angle); error++;
      }
    twist_angle++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle) &&
        twist_angle == sweptsurface->twist_angle)
      pass ("SWEPTSURFACE.twist_angle [BD] set+1 %g", twist_angle);
    else
      {
        fail ("SWEPTSURFACE.twist_angle [BD] set+1 %g != %g", sweptsurface->twist_angle, twist_angle); error++;
      }
    sweptsurface->twist_angle--;

  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == sweptsurface->u_isolines)
      pass ("SWEPTSURFACE.u_isolines [BS] %hu", u_isolines);
    else
      {
        fail ("SWEPTSURFACE.u_isolines [BS] %hu != %hu", sweptsurface->u_isolines, u_isolines); error++;
      }
    u_isolines++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines) &&
        u_isolines == sweptsurface->u_isolines)
      pass ("SWEPTSURFACE.u_isolines [BS] set+1 %hu", u_isolines);
    else
      {
        fail ("SWEPTSURFACE.u_isolines [BS] set+1 %hu != %hu", sweptsurface->u_isolines, u_isolines); error++;
      }
    sweptsurface->u_isolines--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "unknown", &unknown, NULL) &&
        unknown == sweptsurface->unknown)
      pass ("SWEPTSURFACE.unknown [RC] %u", unknown);
    else
      {
        fail ("SWEPTSURFACE.unknown [RC] %u != %u", sweptsurface->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "unknown", &unknown) &&
        unknown == sweptsurface->unknown)
      pass ("SWEPTSURFACE.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("SWEPTSURFACE.unknown [RC] set+1 %u != %u", sweptsurface->unknown, unknown); error++;
      }
    sweptsurface->unknown--;

  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == sweptsurface->unknown_2007)
      pass ("SWEPTSURFACE.unknown_2007 [BL] %u", unknown_2007);
    else
      {
        fail ("SWEPTSURFACE.unknown_2007 [BL] %u != %u", sweptsurface->unknown_2007, unknown_2007); error++;
      }
    unknown_2007++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "unknown_2007", &unknown_2007) &&
        unknown_2007 == sweptsurface->unknown_2007)
      pass ("SWEPTSURFACE.unknown_2007 [BL] set+1 %u", unknown_2007);
    else
      {
        fail ("SWEPTSURFACE.unknown_2007 [BL] set+1 %u != %u", sweptsurface->unknown_2007, unknown_2007); error++;
      }
    sweptsurface->unknown_2007--;

  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == sweptsurface->v_isolines)
      pass ("SWEPTSURFACE.v_isolines [BS] %hu", v_isolines);
    else
      {
        fail ("SWEPTSURFACE.v_isolines [BS] %hu != %hu", sweptsurface->v_isolines, v_isolines); error++;
      }
    v_isolines++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines) &&
        v_isolines == sweptsurface->v_isolines)
      pass ("SWEPTSURFACE.v_isolines [BS] set+1 %hu", v_isolines);
    else
      {
        fail ("SWEPTSURFACE.v_isolines [BS] set+1 %hu != %hu", sweptsurface->v_isolines, v_isolines); error++;
      }
    sweptsurface->v_isolines--;

  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "version", &version, NULL) &&
        version == sweptsurface->version)
      pass ("SWEPTSURFACE.version [BS] %hu", version);
    else
      {
        fail ("SWEPTSURFACE.version [BS] %hu != %hu", sweptsurface->version, version); error++;
      }
    version++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "version", &version) &&
        version == sweptsurface->version)
      pass ("SWEPTSURFACE.version [BS] set+1 %hu", version);
    else
      {
        fail ("SWEPTSURFACE.version [BS] set+1 %hu != %hu", sweptsurface->version, version); error++;
      }
    sweptsurface->version--;

  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == sweptsurface->wireframe_data_present)
      pass ("SWEPTSURFACE.wireframe_data_present [RC] %u", wireframe_data_present);
    else
      {
        fail ("SWEPTSURFACE.wireframe_data_present [RC] %u != %u", sweptsurface->wireframe_data_present, wireframe_data_present); error++;
      }
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value(sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present) &&
        wireframe_data_present == sweptsurface->wireframe_data_present)
      pass ("SWEPTSURFACE.wireframe_data_present [RC] set+1 %u", wireframe_data_present);
    else
      {
        fail ("SWEPTSURFACE.wireframe_data_present [RC] set+1 %u != %u", sweptsurface->wireframe_data_present, wireframe_data_present); error++;
      }
    sweptsurface->wireframe_data_present--;

  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &sweptsurface->wires, sizeof(sweptsurface->wires)))
      pass ("SWEPTSURFACE.wires [Dwg_3DSOLID_wire*]");
    else
      {
        fail ("SWEPTSURFACE.wires [Dwg_3DSOLID_wire*]"); error++;
      }
  }
  return error;
}
static int test_TABLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_TABLE *table = obj->tio.entity->tio.TABLE;
  {
    BITCODE_H* attribs;
    if (dwg_dynapi_entity_value(table, "TABLE", "attribs", &attribs, NULL)
        && !memcmp(&attribs, &table->attribs, sizeof(table->attribs)))
      pass ("TABLE.attribs [H*]");
    else
      {
        fail ("TABLE.attribs [H*]"); error++;
      }
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value(table, "TABLE", "block_header", &block_header, NULL)
        && !memcmp(&block_header, &table->block_header, sizeof(table->block_header)))
      pass ("TABLE.block_header [H]");
    else
      {
        fail ("TABLE.block_header [H]"); error++;
      }
  }
  {
    BITCODE_BL border_color_overrides_flag;
    if (dwg_dynapi_entity_value(table, "TABLE", "border_color_overrides_flag", &border_color_overrides_flag, NULL) &&
        border_color_overrides_flag == table->border_color_overrides_flag)
      pass ("TABLE.border_color_overrides_flag [BL] %u", border_color_overrides_flag);
    else
      {
        fail ("TABLE.border_color_overrides_flag [BL] %u != %u", table->border_color_overrides_flag, border_color_overrides_flag); error++;
      }
    border_color_overrides_flag++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "border_color_overrides_flag", &border_color_overrides_flag) &&
        border_color_overrides_flag == table->border_color_overrides_flag)
      pass ("TABLE.border_color_overrides_flag [BL] set+1 %u", border_color_overrides_flag);
    else
      {
        fail ("TABLE.border_color_overrides_flag [BL] set+1 %u != %u", table->border_color_overrides_flag, border_color_overrides_flag); error++;
      }
    table->border_color_overrides_flag--;

  }
  {
    BITCODE_BL border_lineweight_overrides_flag;
    if (dwg_dynapi_entity_value(table, "TABLE", "border_lineweight_overrides_flag", &border_lineweight_overrides_flag, NULL) &&
        border_lineweight_overrides_flag == table->border_lineweight_overrides_flag)
      pass ("TABLE.border_lineweight_overrides_flag [BL] %u", border_lineweight_overrides_flag);
    else
      {
        fail ("TABLE.border_lineweight_overrides_flag [BL] %u != %u", table->border_lineweight_overrides_flag, border_lineweight_overrides_flag); error++;
      }
    border_lineweight_overrides_flag++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "border_lineweight_overrides_flag", &border_lineweight_overrides_flag) &&
        border_lineweight_overrides_flag == table->border_lineweight_overrides_flag)
      pass ("TABLE.border_lineweight_overrides_flag [BL] set+1 %u", border_lineweight_overrides_flag);
    else
      {
        fail ("TABLE.border_lineweight_overrides_flag [BL] set+1 %u != %u", table->border_lineweight_overrides_flag, border_lineweight_overrides_flag); error++;
      }
    table->border_lineweight_overrides_flag--;

  }
  {
    BITCODE_BL border_visibility_overrides_flag;
    if (dwg_dynapi_entity_value(table, "TABLE", "border_visibility_overrides_flag", &border_visibility_overrides_flag, NULL) &&
        border_visibility_overrides_flag == table->border_visibility_overrides_flag)
      pass ("TABLE.border_visibility_overrides_flag [BL] %u", border_visibility_overrides_flag);
    else
      {
        fail ("TABLE.border_visibility_overrides_flag [BL] %u != %u", table->border_visibility_overrides_flag, border_visibility_overrides_flag); error++;
      }
    border_visibility_overrides_flag++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "border_visibility_overrides_flag", &border_visibility_overrides_flag) &&
        border_visibility_overrides_flag == table->border_visibility_overrides_flag)
      pass ("TABLE.border_visibility_overrides_flag [BL] set+1 %u", border_visibility_overrides_flag);
    else
      {
        fail ("TABLE.border_visibility_overrides_flag [BL] set+1 %u != %u", table->border_visibility_overrides_flag, border_visibility_overrides_flag); error++;
      }
    table->border_visibility_overrides_flag--;

  }
  {
    BITCODE_BL break_flag;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_flag", &break_flag, NULL) &&
        break_flag == table->break_flag)
      pass ("TABLE.break_flag [BL] %u", break_flag);
    else
      {
        fail ("TABLE.break_flag [BL] %u != %u", table->break_flag, break_flag); error++;
      }
    break_flag++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "break_flag", &break_flag) &&
        break_flag == table->break_flag)
      pass ("TABLE.break_flag [BL] set+1 %u", break_flag);
    else
      {
        fail ("TABLE.break_flag [BL] set+1 %u != %u", table->break_flag, break_flag); error++;
      }
    table->break_flag--;

  }
  {
    BITCODE_BL break_flow_direction;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_flow_direction", &break_flow_direction, NULL) &&
        break_flow_direction == table->break_flow_direction)
      pass ("TABLE.break_flow_direction [BL] %u", break_flow_direction);
    else
      {
        fail ("TABLE.break_flow_direction [BL] %u != %u", table->break_flow_direction, break_flow_direction); error++;
      }
    break_flow_direction++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "break_flow_direction", &break_flow_direction) &&
        break_flow_direction == table->break_flow_direction)
      pass ("TABLE.break_flow_direction [BL] set+1 %u", break_flow_direction);
    else
      {
        fail ("TABLE.break_flow_direction [BL] set+1 %u != %u", table->break_flow_direction, break_flow_direction); error++;
      }
    table->break_flow_direction--;

  }
  {
    Dwg_TABLE_BreakHeight* break_heights;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_heights", &break_heights, NULL)
        && !memcmp(&break_heights, &table->break_heights, sizeof(table->break_heights)))
      pass ("TABLE.break_heights [Dwg_TABLE_BreakHeight*]");
    else
      {
        fail ("TABLE.break_heights [Dwg_TABLE_BreakHeight*]"); error++;
      }
  }
  {
    Dwg_TABLE_BreakRow* break_rows;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_rows", &break_rows, NULL)
        && !memcmp(&break_rows, &table->break_rows, sizeof(table->break_rows)))
      pass ("TABLE.break_rows [Dwg_TABLE_BreakRow*]");
    else
      {
        fail ("TABLE.break_rows [Dwg_TABLE_BreakRow*]"); error++;
      }
  }
  {
    BITCODE_BD break_spacing;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_spacing", &break_spacing, NULL) &&
        break_spacing == table->break_spacing)
      pass ("TABLE.break_spacing [BD] %g", break_spacing);
    else
      {
        fail ("TABLE.break_spacing [BD] %g != %g", table->break_spacing, break_spacing); error++;
      }
    break_spacing++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "break_spacing", &break_spacing) &&
        break_spacing == table->break_spacing)
      pass ("TABLE.break_spacing [BD] set+1 %g", break_spacing);
    else
      {
        fail ("TABLE.break_spacing [BD] set+1 %g != %g", table->break_spacing, break_spacing); error++;
      }
    table->break_spacing--;

  }
  {
    BITCODE_BL break_unknown1;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_unknown1", &break_unknown1, NULL) &&
        break_unknown1 == table->break_unknown1)
      pass ("TABLE.break_unknown1 [BL] %u", break_unknown1);
    else
      {
        fail ("TABLE.break_unknown1 [BL] %u != %u", table->break_unknown1, break_unknown1); error++;
      }
    break_unknown1++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "break_unknown1", &break_unknown1) &&
        break_unknown1 == table->break_unknown1)
      pass ("TABLE.break_unknown1 [BL] set+1 %u", break_unknown1);
    else
      {
        fail ("TABLE.break_unknown1 [BL] set+1 %u != %u", table->break_unknown1, break_unknown1); error++;
      }
    table->break_unknown1--;

  }
  {
    BITCODE_BL break_unknown2;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_unknown2", &break_unknown2, NULL) &&
        break_unknown2 == table->break_unknown2)
      pass ("TABLE.break_unknown2 [BL] %u", break_unknown2);
    else
      {
        fail ("TABLE.break_unknown2 [BL] %u != %u", table->break_unknown2, break_unknown2); error++;
      }
    break_unknown2++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "break_unknown2", &break_unknown2) &&
        break_unknown2 == table->break_unknown2)
      pass ("TABLE.break_unknown2 [BL] set+1 %u", break_unknown2);
    else
      {
        fail ("TABLE.break_unknown2 [BL] set+1 %u != %u", table->break_unknown2, break_unknown2); error++;
      }
    table->break_unknown2--;

  }
  {
    Dwg_TABLE_Cell* cells;
    if (dwg_dynapi_entity_value(table, "TABLE", "cells", &cells, NULL)
        && !memcmp(&cells, &table->cells, sizeof(table->cells)))
      pass ("TABLE.cells [Dwg_TABLE_Cell*]");
    else
      {
        fail ("TABLE.cells [Dwg_TABLE_Cell*]"); error++;
      }
  }
  {
    BITCODE_BD* col_widths;
    if (dwg_dynapi_entity_value(table, "TABLE", "col_widths", &col_widths, NULL)
        && !memcmp(&col_widths, &table->col_widths, sizeof(table->col_widths)))
      pass ("TABLE.col_widths [BD*]");
    else
      {
        fail ("TABLE.col_widths [BD*]"); error++;
      }
  }
  {
    BITCODE_BB data_flags;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_flags", &data_flags, NULL) &&
        data_flags == table->data_flags)
      pass ("TABLE.data_flags [BB] " FORMAT_BB "", data_flags);
    else
      {
        fail ("TABLE.data_flags [BB] " FORMAT_BB " != " FORMAT_BB "", table->data_flags, data_flags); error++;
      }
    data_flags++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_flags", &data_flags) &&
        data_flags == table->data_flags)
      pass ("TABLE.data_flags [BB] set+1 " FORMAT_BB "", data_flags);
    else
      {
        fail ("TABLE.data_flags [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", table->data_flags, data_flags); error++;
      }
    table->data_flags--;

  }
  {
    BITCODE_CMC data_horiz_bottom_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_bottom_color", &data_horiz_bottom_color, NULL)
        && !memcmp(&data_horiz_bottom_color, &table->data_horiz_bottom_color, sizeof(table->data_horiz_bottom_color)))
      pass ("TABLE.data_horiz_bottom_color [CMC]");
    else
      {
        fail ("TABLE.data_horiz_bottom_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS data_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_bottom_linewt", &data_horiz_bottom_linewt, NULL) &&
        data_horiz_bottom_linewt == table->data_horiz_bottom_linewt)
      pass ("TABLE.data_horiz_bottom_linewt [BS] %hu", data_horiz_bottom_linewt);
    else
      {
        fail ("TABLE.data_horiz_bottom_linewt [BS] %hu != %hu", table->data_horiz_bottom_linewt, data_horiz_bottom_linewt); error++;
      }
    data_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_horiz_bottom_linewt", &data_horiz_bottom_linewt) &&
        data_horiz_bottom_linewt == table->data_horiz_bottom_linewt)
      pass ("TABLE.data_horiz_bottom_linewt [BS] set+1 %hu", data_horiz_bottom_linewt);
    else
      {
        fail ("TABLE.data_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->data_horiz_bottom_linewt, data_horiz_bottom_linewt); error++;
      }
    table->data_horiz_bottom_linewt--;

  }
  {
    BITCODE_BS data_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_bottom_visibility", &data_horiz_bottom_visibility, NULL) &&
        data_horiz_bottom_visibility == table->data_horiz_bottom_visibility)
      pass ("TABLE.data_horiz_bottom_visibility [BS] %hu", data_horiz_bottom_visibility);
    else
      {
        fail ("TABLE.data_horiz_bottom_visibility [BS] %hu != %hu", table->data_horiz_bottom_visibility, data_horiz_bottom_visibility); error++;
      }
    data_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_horiz_bottom_visibility", &data_horiz_bottom_visibility) &&
        data_horiz_bottom_visibility == table->data_horiz_bottom_visibility)
      pass ("TABLE.data_horiz_bottom_visibility [BS] set+1 %hu", data_horiz_bottom_visibility);
    else
      {
        fail ("TABLE.data_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->data_horiz_bottom_visibility, data_horiz_bottom_visibility); error++;
      }
    table->data_horiz_bottom_visibility--;

  }
  {
    BITCODE_CMC data_horiz_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_ins_color", &data_horiz_ins_color, NULL)
        && !memcmp(&data_horiz_ins_color, &table->data_horiz_ins_color, sizeof(table->data_horiz_ins_color)))
      pass ("TABLE.data_horiz_ins_color [CMC]");
    else
      {
        fail ("TABLE.data_horiz_ins_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS data_horiz_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_ins_linewt", &data_horiz_ins_linewt, NULL) &&
        data_horiz_ins_linewt == table->data_horiz_ins_linewt)
      pass ("TABLE.data_horiz_ins_linewt [BS] %hu", data_horiz_ins_linewt);
    else
      {
        fail ("TABLE.data_horiz_ins_linewt [BS] %hu != %hu", table->data_horiz_ins_linewt, data_horiz_ins_linewt); error++;
      }
    data_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_horiz_ins_linewt", &data_horiz_ins_linewt) &&
        data_horiz_ins_linewt == table->data_horiz_ins_linewt)
      pass ("TABLE.data_horiz_ins_linewt [BS] set+1 %hu", data_horiz_ins_linewt);
    else
      {
        fail ("TABLE.data_horiz_ins_linewt [BS] set+1 %hu != %hu", table->data_horiz_ins_linewt, data_horiz_ins_linewt); error++;
      }
    table->data_horiz_ins_linewt--;

  }
  {
    BITCODE_BS data_horiz_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_ins_visibility", &data_horiz_ins_visibility, NULL) &&
        data_horiz_ins_visibility == table->data_horiz_ins_visibility)
      pass ("TABLE.data_horiz_ins_visibility [BS] %hu", data_horiz_ins_visibility);
    else
      {
        fail ("TABLE.data_horiz_ins_visibility [BS] %hu != %hu", table->data_horiz_ins_visibility, data_horiz_ins_visibility); error++;
      }
    data_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_horiz_ins_visibility", &data_horiz_ins_visibility) &&
        data_horiz_ins_visibility == table->data_horiz_ins_visibility)
      pass ("TABLE.data_horiz_ins_visibility [BS] set+1 %hu", data_horiz_ins_visibility);
    else
      {
        fail ("TABLE.data_horiz_ins_visibility [BS] set+1 %hu != %hu", table->data_horiz_ins_visibility, data_horiz_ins_visibility); error++;
      }
    table->data_horiz_ins_visibility--;

  }
  {
    BITCODE_CMC data_horiz_top_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_top_color", &data_horiz_top_color, NULL)
        && !memcmp(&data_horiz_top_color, &table->data_horiz_top_color, sizeof(table->data_horiz_top_color)))
      pass ("TABLE.data_horiz_top_color [CMC]");
    else
      {
        fail ("TABLE.data_horiz_top_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS data_horiz_top_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_top_linewt", &data_horiz_top_linewt, NULL) &&
        data_horiz_top_linewt == table->data_horiz_top_linewt)
      pass ("TABLE.data_horiz_top_linewt [BS] %hu", data_horiz_top_linewt);
    else
      {
        fail ("TABLE.data_horiz_top_linewt [BS] %hu != %hu", table->data_horiz_top_linewt, data_horiz_top_linewt); error++;
      }
    data_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_horiz_top_linewt", &data_horiz_top_linewt) &&
        data_horiz_top_linewt == table->data_horiz_top_linewt)
      pass ("TABLE.data_horiz_top_linewt [BS] set+1 %hu", data_horiz_top_linewt);
    else
      {
        fail ("TABLE.data_horiz_top_linewt [BS] set+1 %hu != %hu", table->data_horiz_top_linewt, data_horiz_top_linewt); error++;
      }
    table->data_horiz_top_linewt--;

  }
  {
    BITCODE_BS data_horiz_top_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_top_visibility", &data_horiz_top_visibility, NULL) &&
        data_horiz_top_visibility == table->data_horiz_top_visibility)
      pass ("TABLE.data_horiz_top_visibility [BS] %hu", data_horiz_top_visibility);
    else
      {
        fail ("TABLE.data_horiz_top_visibility [BS] %hu != %hu", table->data_horiz_top_visibility, data_horiz_top_visibility); error++;
      }
    data_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_horiz_top_visibility", &data_horiz_top_visibility) &&
        data_horiz_top_visibility == table->data_horiz_top_visibility)
      pass ("TABLE.data_horiz_top_visibility [BS] set+1 %hu", data_horiz_top_visibility);
    else
      {
        fail ("TABLE.data_horiz_top_visibility [BS] set+1 %hu != %hu", table->data_horiz_top_visibility, data_horiz_top_visibility); error++;
      }
    table->data_horiz_top_visibility--;

  }
  {
    BITCODE_BS data_row_alignment;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_alignment", &data_row_alignment, NULL) &&
        data_row_alignment == table->data_row_alignment)
      pass ("TABLE.data_row_alignment [BS] %hu", data_row_alignment);
    else
      {
        fail ("TABLE.data_row_alignment [BS] %hu != %hu", table->data_row_alignment, data_row_alignment); error++;
      }
    data_row_alignment++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_row_alignment", &data_row_alignment) &&
        data_row_alignment == table->data_row_alignment)
      pass ("TABLE.data_row_alignment [BS] set+1 %hu", data_row_alignment);
    else
      {
        fail ("TABLE.data_row_alignment [BS] set+1 %hu != %hu", table->data_row_alignment, data_row_alignment); error++;
      }
    table->data_row_alignment--;

  }
  {
    BITCODE_CMC data_row_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_color", &data_row_color, NULL)
        && !memcmp(&data_row_color, &table->data_row_color, sizeof(table->data_row_color)))
      pass ("TABLE.data_row_color [CMC]");
    else
      {
        fail ("TABLE.data_row_color [CMC]"); error++;
      }
  }
  {
    BITCODE_CMC data_row_fill_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_fill_color", &data_row_fill_color, NULL)
        && !memcmp(&data_row_fill_color, &table->data_row_fill_color, sizeof(table->data_row_fill_color)))
      pass ("TABLE.data_row_fill_color [CMC]");
    else
      {
        fail ("TABLE.data_row_fill_color [CMC]"); error++;
      }
  }
  {
    BITCODE_B data_row_fill_none;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_fill_none", &data_row_fill_none, NULL) &&
        data_row_fill_none == table->data_row_fill_none)
      pass ("TABLE.data_row_fill_none [B] " FORMAT_B "", data_row_fill_none);
    else
      {
        fail ("TABLE.data_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->data_row_fill_none, data_row_fill_none); error++;
      }
    data_row_fill_none++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_row_fill_none", &data_row_fill_none) &&
        data_row_fill_none == table->data_row_fill_none)
      pass ("TABLE.data_row_fill_none [B] set+1 " FORMAT_B "", data_row_fill_none);
    else
      {
        fail ("TABLE.data_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->data_row_fill_none, data_row_fill_none); error++;
      }
    table->data_row_fill_none--;

  }
  {
    BITCODE_BD data_row_height;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_height", &data_row_height, NULL) &&
        data_row_height == table->data_row_height)
      pass ("TABLE.data_row_height [BD] %g", data_row_height);
    else
      {
        fail ("TABLE.data_row_height [BD] %g != %g", table->data_row_height, data_row_height); error++;
      }
    data_row_height++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_row_height", &data_row_height) &&
        data_row_height == table->data_row_height)
      pass ("TABLE.data_row_height [BD] set+1 %g", data_row_height);
    else
      {
        fail ("TABLE.data_row_height [BD] set+1 %g != %g", table->data_row_height, data_row_height); error++;
      }
    table->data_row_height--;

  }
  {
    BITCODE_H data_row_style_override;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_style_override", &data_row_style_override, NULL)
        && !memcmp(&data_row_style_override, &table->data_row_style_override, sizeof(table->data_row_style_override)))
      pass ("TABLE.data_row_style_override [H]");
    else
      {
        fail ("TABLE.data_row_style_override [H]"); error++;
      }
  }
  {
    BITCODE_H data_text_style;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_text_style", &data_text_style, NULL)
        && !memcmp(&data_text_style, &table->data_text_style, sizeof(table->data_text_style)))
      pass ("TABLE.data_text_style [H]");
    else
      {
        fail ("TABLE.data_text_style [H]"); error++;
      }
  }
  {
    BITCODE_CMC data_vert_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_ins_color", &data_vert_ins_color, NULL)
        && !memcmp(&data_vert_ins_color, &table->data_vert_ins_color, sizeof(table->data_vert_ins_color)))
      pass ("TABLE.data_vert_ins_color [CMC]");
    else
      {
        fail ("TABLE.data_vert_ins_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS data_vert_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_ins_linewt", &data_vert_ins_linewt, NULL) &&
        data_vert_ins_linewt == table->data_vert_ins_linewt)
      pass ("TABLE.data_vert_ins_linewt [BS] %hu", data_vert_ins_linewt);
    else
      {
        fail ("TABLE.data_vert_ins_linewt [BS] %hu != %hu", table->data_vert_ins_linewt, data_vert_ins_linewt); error++;
      }
    data_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_vert_ins_linewt", &data_vert_ins_linewt) &&
        data_vert_ins_linewt == table->data_vert_ins_linewt)
      pass ("TABLE.data_vert_ins_linewt [BS] set+1 %hu", data_vert_ins_linewt);
    else
      {
        fail ("TABLE.data_vert_ins_linewt [BS] set+1 %hu != %hu", table->data_vert_ins_linewt, data_vert_ins_linewt); error++;
      }
    table->data_vert_ins_linewt--;

  }
  {
    BITCODE_BS data_vert_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_ins_visibility", &data_vert_ins_visibility, NULL) &&
        data_vert_ins_visibility == table->data_vert_ins_visibility)
      pass ("TABLE.data_vert_ins_visibility [BS] %hu", data_vert_ins_visibility);
    else
      {
        fail ("TABLE.data_vert_ins_visibility [BS] %hu != %hu", table->data_vert_ins_visibility, data_vert_ins_visibility); error++;
      }
    data_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_vert_ins_visibility", &data_vert_ins_visibility) &&
        data_vert_ins_visibility == table->data_vert_ins_visibility)
      pass ("TABLE.data_vert_ins_visibility [BS] set+1 %hu", data_vert_ins_visibility);
    else
      {
        fail ("TABLE.data_vert_ins_visibility [BS] set+1 %hu != %hu", table->data_vert_ins_visibility, data_vert_ins_visibility); error++;
      }
    table->data_vert_ins_visibility--;

  }
  {
    BITCODE_CMC data_vert_left_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_left_color", &data_vert_left_color, NULL)
        && !memcmp(&data_vert_left_color, &table->data_vert_left_color, sizeof(table->data_vert_left_color)))
      pass ("TABLE.data_vert_left_color [CMC]");
    else
      {
        fail ("TABLE.data_vert_left_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS data_vert_left_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_left_linewt", &data_vert_left_linewt, NULL) &&
        data_vert_left_linewt == table->data_vert_left_linewt)
      pass ("TABLE.data_vert_left_linewt [BS] %hu", data_vert_left_linewt);
    else
      {
        fail ("TABLE.data_vert_left_linewt [BS] %hu != %hu", table->data_vert_left_linewt, data_vert_left_linewt); error++;
      }
    data_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_vert_left_linewt", &data_vert_left_linewt) &&
        data_vert_left_linewt == table->data_vert_left_linewt)
      pass ("TABLE.data_vert_left_linewt [BS] set+1 %hu", data_vert_left_linewt);
    else
      {
        fail ("TABLE.data_vert_left_linewt [BS] set+1 %hu != %hu", table->data_vert_left_linewt, data_vert_left_linewt); error++;
      }
    table->data_vert_left_linewt--;

  }
  {
    BITCODE_BS data_vert_left_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_left_visibility", &data_vert_left_visibility, NULL) &&
        data_vert_left_visibility == table->data_vert_left_visibility)
      pass ("TABLE.data_vert_left_visibility [BS] %hu", data_vert_left_visibility);
    else
      {
        fail ("TABLE.data_vert_left_visibility [BS] %hu != %hu", table->data_vert_left_visibility, data_vert_left_visibility); error++;
      }
    data_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_vert_left_visibility", &data_vert_left_visibility) &&
        data_vert_left_visibility == table->data_vert_left_visibility)
      pass ("TABLE.data_vert_left_visibility [BS] set+1 %hu", data_vert_left_visibility);
    else
      {
        fail ("TABLE.data_vert_left_visibility [BS] set+1 %hu != %hu", table->data_vert_left_visibility, data_vert_left_visibility); error++;
      }
    table->data_vert_left_visibility--;

  }
  {
    BITCODE_CMC data_vert_right_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_right_color", &data_vert_right_color, NULL)
        && !memcmp(&data_vert_right_color, &table->data_vert_right_color, sizeof(table->data_vert_right_color)))
      pass ("TABLE.data_vert_right_color [CMC]");
    else
      {
        fail ("TABLE.data_vert_right_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS data_vert_right_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_right_linewt", &data_vert_right_linewt, NULL) &&
        data_vert_right_linewt == table->data_vert_right_linewt)
      pass ("TABLE.data_vert_right_linewt [BS] %hu", data_vert_right_linewt);
    else
      {
        fail ("TABLE.data_vert_right_linewt [BS] %hu != %hu", table->data_vert_right_linewt, data_vert_right_linewt); error++;
      }
    data_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_vert_right_linewt", &data_vert_right_linewt) &&
        data_vert_right_linewt == table->data_vert_right_linewt)
      pass ("TABLE.data_vert_right_linewt [BS] set+1 %hu", data_vert_right_linewt);
    else
      {
        fail ("TABLE.data_vert_right_linewt [BS] set+1 %hu != %hu", table->data_vert_right_linewt, data_vert_right_linewt); error++;
      }
    table->data_vert_right_linewt--;

  }
  {
    BITCODE_BS data_vert_right_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_right_visibility", &data_vert_right_visibility, NULL) &&
        data_vert_right_visibility == table->data_vert_right_visibility)
      pass ("TABLE.data_vert_right_visibility [BS] %hu", data_vert_right_visibility);
    else
      {
        fail ("TABLE.data_vert_right_visibility [BS] %hu != %hu", table->data_vert_right_visibility, data_vert_right_visibility); error++;
      }
    data_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "data_vert_right_visibility", &data_vert_right_visibility) &&
        data_vert_right_visibility == table->data_vert_right_visibility)
      pass ("TABLE.data_vert_right_visibility [BS] set+1 %hu", data_vert_right_visibility);
    else
      {
        fail ("TABLE.data_vert_right_visibility [BS] set+1 %hu != %hu", table->data_vert_right_visibility, data_vert_right_visibility); error++;
      }
    table->data_vert_right_visibility--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(table, "TABLE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &table->extrusion, sizeof(table->extrusion)))
      pass ("TABLE.extrusion [3BD]");
    else
      {
        fail ("TABLE.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value(table, "TABLE", "first_attrib", &first_attrib, NULL)
        && !memcmp(&first_attrib, &table->first_attrib, sizeof(table->first_attrib)))
      pass ("TABLE.first_attrib [H]");
    else
      {
        fail ("TABLE.first_attrib [H]"); error++;
      }
  }
  {
    BITCODE_BS flag_for_table_value;
    if (dwg_dynapi_entity_value(table, "TABLE", "flag_for_table_value", &flag_for_table_value, NULL) &&
        flag_for_table_value == table->flag_for_table_value)
      pass ("TABLE.flag_for_table_value [BS] %hu", flag_for_table_value);
    else
      {
        fail ("TABLE.flag_for_table_value [BS] %hu != %hu", table->flag_for_table_value, flag_for_table_value); error++;
      }
    flag_for_table_value++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "flag_for_table_value", &flag_for_table_value) &&
        flag_for_table_value == table->flag_for_table_value)
      pass ("TABLE.flag_for_table_value [BS] set+1 %hu", flag_for_table_value);
    else
      {
        fail ("TABLE.flag_for_table_value [BS] set+1 %hu != %hu", table->flag_for_table_value, flag_for_table_value); error++;
      }
    table->flag_for_table_value--;

  }
  {
    BITCODE_BS flow_direction;
    if (dwg_dynapi_entity_value(table, "TABLE", "flow_direction", &flow_direction, NULL) &&
        flow_direction == table->flow_direction)
      pass ("TABLE.flow_direction [BS] %hu", flow_direction);
    else
      {
        fail ("TABLE.flow_direction [BS] %hu != %hu", table->flow_direction, flow_direction); error++;
      }
    flow_direction++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "flow_direction", &flow_direction) &&
        flow_direction == table->flow_direction)
      pass ("TABLE.flow_direction [BS] set+1 %hu", flow_direction);
    else
      {
        fail ("TABLE.flow_direction [BS] set+1 %hu != %hu", table->flow_direction, flow_direction); error++;
      }
    table->flow_direction--;

  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_attribs", &has_attribs, NULL) &&
        has_attribs == table->has_attribs)
      pass ("TABLE.has_attribs [B] " FORMAT_B "", has_attribs);
    else
      {
        fail ("TABLE.has_attribs [B] " FORMAT_B " != " FORMAT_B "", table->has_attribs, has_attribs); error++;
      }
    has_attribs++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "has_attribs", &has_attribs) &&
        has_attribs == table->has_attribs)
      pass ("TABLE.has_attribs [B] set+1 " FORMAT_B "", has_attribs);
    else
      {
        fail ("TABLE.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_attribs, has_attribs); error++;
      }
    table->has_attribs--;

  }
  {
    BITCODE_B has_border_color_overrides;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_border_color_overrides", &has_border_color_overrides, NULL) &&
        has_border_color_overrides == table->has_border_color_overrides)
      pass ("TABLE.has_border_color_overrides [B] " FORMAT_B "", has_border_color_overrides);
    else
      {
        fail ("TABLE.has_border_color_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_color_overrides, has_border_color_overrides); error++;
      }
    has_border_color_overrides++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "has_border_color_overrides", &has_border_color_overrides) &&
        has_border_color_overrides == table->has_border_color_overrides)
      pass ("TABLE.has_border_color_overrides [B] set+1 " FORMAT_B "", has_border_color_overrides);
    else
      {
        fail ("TABLE.has_border_color_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_color_overrides, has_border_color_overrides); error++;
      }
    table->has_border_color_overrides--;

  }
  {
    BITCODE_B has_border_lineweight_overrides;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_border_lineweight_overrides", &has_border_lineweight_overrides, NULL) &&
        has_border_lineweight_overrides == table->has_border_lineweight_overrides)
      pass ("TABLE.has_border_lineweight_overrides [B] " FORMAT_B "", has_border_lineweight_overrides);
    else
      {
        fail ("TABLE.has_border_lineweight_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_lineweight_overrides, has_border_lineweight_overrides); error++;
      }
    has_border_lineweight_overrides++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "has_border_lineweight_overrides", &has_border_lineweight_overrides) &&
        has_border_lineweight_overrides == table->has_border_lineweight_overrides)
      pass ("TABLE.has_border_lineweight_overrides [B] set+1 " FORMAT_B "", has_border_lineweight_overrides);
    else
      {
        fail ("TABLE.has_border_lineweight_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_lineweight_overrides, has_border_lineweight_overrides); error++;
      }
    table->has_border_lineweight_overrides--;

  }
  {
    BITCODE_B has_border_visibility_overrides;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_border_visibility_overrides", &has_border_visibility_overrides, NULL) &&
        has_border_visibility_overrides == table->has_border_visibility_overrides)
      pass ("TABLE.has_border_visibility_overrides [B] " FORMAT_B "", has_border_visibility_overrides);
    else
      {
        fail ("TABLE.has_border_visibility_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_visibility_overrides, has_border_visibility_overrides); error++;
      }
    has_border_visibility_overrides++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "has_border_visibility_overrides", &has_border_visibility_overrides) &&
        has_border_visibility_overrides == table->has_border_visibility_overrides)
      pass ("TABLE.has_border_visibility_overrides [B] set+1 " FORMAT_B "", has_border_visibility_overrides);
    else
      {
        fail ("TABLE.has_border_visibility_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_visibility_overrides, has_border_visibility_overrides); error++;
      }
    table->has_border_visibility_overrides--;

  }
  {
    BITCODE_BL has_break_data;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_break_data", &has_break_data, NULL) &&
        has_break_data == table->has_break_data)
      pass ("TABLE.has_break_data [BL] %u", has_break_data);
    else
      {
        fail ("TABLE.has_break_data [BL] %u != %u", table->has_break_data, has_break_data); error++;
      }
    has_break_data++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "has_break_data", &has_break_data) &&
        has_break_data == table->has_break_data)
      pass ("TABLE.has_break_data [BL] set+1 %u", has_break_data);
    else
      {
        fail ("TABLE.has_break_data [BL] set+1 %u != %u", table->has_break_data, has_break_data); error++;
      }
    table->has_break_data--;

  }
  {
    BITCODE_B has_table_overrides;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_table_overrides", &has_table_overrides, NULL) &&
        has_table_overrides == table->has_table_overrides)
      pass ("TABLE.has_table_overrides [B] " FORMAT_B "", has_table_overrides);
    else
      {
        fail ("TABLE.has_table_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_table_overrides, has_table_overrides); error++;
      }
    has_table_overrides++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "has_table_overrides", &has_table_overrides) &&
        has_table_overrides == table->has_table_overrides)
      pass ("TABLE.has_table_overrides [B] set+1 " FORMAT_B "", has_table_overrides);
    else
      {
        fail ("TABLE.has_table_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_table_overrides, has_table_overrides); error++;
      }
    table->has_table_overrides--;

  }
  {
    BITCODE_CMC header_horiz_bottom_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_bottom_color", &header_horiz_bottom_color, NULL)
        && !memcmp(&header_horiz_bottom_color, &table->header_horiz_bottom_color, sizeof(table->header_horiz_bottom_color)))
      pass ("TABLE.header_horiz_bottom_color [CMC]");
    else
      {
        fail ("TABLE.header_horiz_bottom_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS header_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_bottom_linewt", &header_horiz_bottom_linewt, NULL) &&
        header_horiz_bottom_linewt == table->header_horiz_bottom_linewt)
      pass ("TABLE.header_horiz_bottom_linewt [BS] %hu", header_horiz_bottom_linewt);
    else
      {
        fail ("TABLE.header_horiz_bottom_linewt [BS] %hu != %hu", table->header_horiz_bottom_linewt, header_horiz_bottom_linewt); error++;
      }
    header_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_horiz_bottom_linewt", &header_horiz_bottom_linewt) &&
        header_horiz_bottom_linewt == table->header_horiz_bottom_linewt)
      pass ("TABLE.header_horiz_bottom_linewt [BS] set+1 %hu", header_horiz_bottom_linewt);
    else
      {
        fail ("TABLE.header_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->header_horiz_bottom_linewt, header_horiz_bottom_linewt); error++;
      }
    table->header_horiz_bottom_linewt--;

  }
  {
    BITCODE_BS header_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_bottom_visibility", &header_horiz_bottom_visibility, NULL) &&
        header_horiz_bottom_visibility == table->header_horiz_bottom_visibility)
      pass ("TABLE.header_horiz_bottom_visibility [BS] %hu", header_horiz_bottom_visibility);
    else
      {
        fail ("TABLE.header_horiz_bottom_visibility [BS] %hu != %hu", table->header_horiz_bottom_visibility, header_horiz_bottom_visibility); error++;
      }
    header_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_horiz_bottom_visibility", &header_horiz_bottom_visibility) &&
        header_horiz_bottom_visibility == table->header_horiz_bottom_visibility)
      pass ("TABLE.header_horiz_bottom_visibility [BS] set+1 %hu", header_horiz_bottom_visibility);
    else
      {
        fail ("TABLE.header_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->header_horiz_bottom_visibility, header_horiz_bottom_visibility); error++;
      }
    table->header_horiz_bottom_visibility--;

  }
  {
    BITCODE_CMC header_horiz_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_ins_color", &header_horiz_ins_color, NULL)
        && !memcmp(&header_horiz_ins_color, &table->header_horiz_ins_color, sizeof(table->header_horiz_ins_color)))
      pass ("TABLE.header_horiz_ins_color [CMC]");
    else
      {
        fail ("TABLE.header_horiz_ins_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS header_horiz_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_ins_linewt", &header_horiz_ins_linewt, NULL) &&
        header_horiz_ins_linewt == table->header_horiz_ins_linewt)
      pass ("TABLE.header_horiz_ins_linewt [BS] %hu", header_horiz_ins_linewt);
    else
      {
        fail ("TABLE.header_horiz_ins_linewt [BS] %hu != %hu", table->header_horiz_ins_linewt, header_horiz_ins_linewt); error++;
      }
    header_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_horiz_ins_linewt", &header_horiz_ins_linewt) &&
        header_horiz_ins_linewt == table->header_horiz_ins_linewt)
      pass ("TABLE.header_horiz_ins_linewt [BS] set+1 %hu", header_horiz_ins_linewt);
    else
      {
        fail ("TABLE.header_horiz_ins_linewt [BS] set+1 %hu != %hu", table->header_horiz_ins_linewt, header_horiz_ins_linewt); error++;
      }
    table->header_horiz_ins_linewt--;

  }
  {
    BITCODE_BS header_horiz_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_ins_visibility", &header_horiz_ins_visibility, NULL) &&
        header_horiz_ins_visibility == table->header_horiz_ins_visibility)
      pass ("TABLE.header_horiz_ins_visibility [BS] %hu", header_horiz_ins_visibility);
    else
      {
        fail ("TABLE.header_horiz_ins_visibility [BS] %hu != %hu", table->header_horiz_ins_visibility, header_horiz_ins_visibility); error++;
      }
    header_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_horiz_ins_visibility", &header_horiz_ins_visibility) &&
        header_horiz_ins_visibility == table->header_horiz_ins_visibility)
      pass ("TABLE.header_horiz_ins_visibility [BS] set+1 %hu", header_horiz_ins_visibility);
    else
      {
        fail ("TABLE.header_horiz_ins_visibility [BS] set+1 %hu != %hu", table->header_horiz_ins_visibility, header_horiz_ins_visibility); error++;
      }
    table->header_horiz_ins_visibility--;

  }
  {
    BITCODE_CMC header_horiz_top_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_top_color", &header_horiz_top_color, NULL)
        && !memcmp(&header_horiz_top_color, &table->header_horiz_top_color, sizeof(table->header_horiz_top_color)))
      pass ("TABLE.header_horiz_top_color [CMC]");
    else
      {
        fail ("TABLE.header_horiz_top_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS header_horiz_top_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_top_linewt", &header_horiz_top_linewt, NULL) &&
        header_horiz_top_linewt == table->header_horiz_top_linewt)
      pass ("TABLE.header_horiz_top_linewt [BS] %hu", header_horiz_top_linewt);
    else
      {
        fail ("TABLE.header_horiz_top_linewt [BS] %hu != %hu", table->header_horiz_top_linewt, header_horiz_top_linewt); error++;
      }
    header_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_horiz_top_linewt", &header_horiz_top_linewt) &&
        header_horiz_top_linewt == table->header_horiz_top_linewt)
      pass ("TABLE.header_horiz_top_linewt [BS] set+1 %hu", header_horiz_top_linewt);
    else
      {
        fail ("TABLE.header_horiz_top_linewt [BS] set+1 %hu != %hu", table->header_horiz_top_linewt, header_horiz_top_linewt); error++;
      }
    table->header_horiz_top_linewt--;

  }
  {
    BITCODE_BS header_horiz_top_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_top_visibility", &header_horiz_top_visibility, NULL) &&
        header_horiz_top_visibility == table->header_horiz_top_visibility)
      pass ("TABLE.header_horiz_top_visibility [BS] %hu", header_horiz_top_visibility);
    else
      {
        fail ("TABLE.header_horiz_top_visibility [BS] %hu != %hu", table->header_horiz_top_visibility, header_horiz_top_visibility); error++;
      }
    header_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_horiz_top_visibility", &header_horiz_top_visibility) &&
        header_horiz_top_visibility == table->header_horiz_top_visibility)
      pass ("TABLE.header_horiz_top_visibility [BS] set+1 %hu", header_horiz_top_visibility);
    else
      {
        fail ("TABLE.header_horiz_top_visibility [BS] set+1 %hu != %hu", table->header_horiz_top_visibility, header_horiz_top_visibility); error++;
      }
    table->header_horiz_top_visibility--;

  }
  {
    BITCODE_BS header_row_alignment;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_alignment", &header_row_alignment, NULL) &&
        header_row_alignment == table->header_row_alignment)
      pass ("TABLE.header_row_alignment [BS] %hu", header_row_alignment);
    else
      {
        fail ("TABLE.header_row_alignment [BS] %hu != %hu", table->header_row_alignment, header_row_alignment); error++;
      }
    header_row_alignment++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_row_alignment", &header_row_alignment) &&
        header_row_alignment == table->header_row_alignment)
      pass ("TABLE.header_row_alignment [BS] set+1 %hu", header_row_alignment);
    else
      {
        fail ("TABLE.header_row_alignment [BS] set+1 %hu != %hu", table->header_row_alignment, header_row_alignment); error++;
      }
    table->header_row_alignment--;

  }
  {
    BITCODE_CMC header_row_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_color", &header_row_color, NULL)
        && !memcmp(&header_row_color, &table->header_row_color, sizeof(table->header_row_color)))
      pass ("TABLE.header_row_color [CMC]");
    else
      {
        fail ("TABLE.header_row_color [CMC]"); error++;
      }
  }
  {
    BITCODE_CMC header_row_fill_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_fill_color", &header_row_fill_color, NULL)
        && !memcmp(&header_row_fill_color, &table->header_row_fill_color, sizeof(table->header_row_fill_color)))
      pass ("TABLE.header_row_fill_color [CMC]");
    else
      {
        fail ("TABLE.header_row_fill_color [CMC]"); error++;
      }
  }
  {
    BITCODE_B header_row_fill_none;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_fill_none", &header_row_fill_none, NULL) &&
        header_row_fill_none == table->header_row_fill_none)
      pass ("TABLE.header_row_fill_none [B] " FORMAT_B "", header_row_fill_none);
    else
      {
        fail ("TABLE.header_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->header_row_fill_none, header_row_fill_none); error++;
      }
    header_row_fill_none++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_row_fill_none", &header_row_fill_none) &&
        header_row_fill_none == table->header_row_fill_none)
      pass ("TABLE.header_row_fill_none [B] set+1 " FORMAT_B "", header_row_fill_none);
    else
      {
        fail ("TABLE.header_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->header_row_fill_none, header_row_fill_none); error++;
      }
    table->header_row_fill_none--;

  }
  {
    BITCODE_BD header_row_height;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_height", &header_row_height, NULL) &&
        header_row_height == table->header_row_height)
      pass ("TABLE.header_row_height [BD] %g", header_row_height);
    else
      {
        fail ("TABLE.header_row_height [BD] %g != %g", table->header_row_height, header_row_height); error++;
      }
    header_row_height++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_row_height", &header_row_height) &&
        header_row_height == table->header_row_height)
      pass ("TABLE.header_row_height [BD] set+1 %g", header_row_height);
    else
      {
        fail ("TABLE.header_row_height [BD] set+1 %g != %g", table->header_row_height, header_row_height); error++;
      }
    table->header_row_height--;

  }
  {
    BITCODE_H header_row_style_override;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_style_override", &header_row_style_override, NULL)
        && !memcmp(&header_row_style_override, &table->header_row_style_override, sizeof(table->header_row_style_override)))
      pass ("TABLE.header_row_style_override [H]");
    else
      {
        fail ("TABLE.header_row_style_override [H]"); error++;
      }
  }
  {
    BITCODE_B header_suppressed;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_suppressed", &header_suppressed, NULL) &&
        header_suppressed == table->header_suppressed)
      pass ("TABLE.header_suppressed [B] " FORMAT_B "", header_suppressed);
    else
      {
        fail ("TABLE.header_suppressed [B] " FORMAT_B " != " FORMAT_B "", table->header_suppressed, header_suppressed); error++;
      }
    header_suppressed++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_suppressed", &header_suppressed) &&
        header_suppressed == table->header_suppressed)
      pass ("TABLE.header_suppressed [B] set+1 " FORMAT_B "", header_suppressed);
    else
      {
        fail ("TABLE.header_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", table->header_suppressed, header_suppressed); error++;
      }
    table->header_suppressed--;

  }
  {
    BITCODE_H header_text_style;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_text_style", &header_text_style, NULL)
        && !memcmp(&header_text_style, &table->header_text_style, sizeof(table->header_text_style)))
      pass ("TABLE.header_text_style [H]");
    else
      {
        fail ("TABLE.header_text_style [H]"); error++;
      }
  }
  {
    BITCODE_CMC header_vert_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_ins_color", &header_vert_ins_color, NULL)
        && !memcmp(&header_vert_ins_color, &table->header_vert_ins_color, sizeof(table->header_vert_ins_color)))
      pass ("TABLE.header_vert_ins_color [CMC]");
    else
      {
        fail ("TABLE.header_vert_ins_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS header_vert_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_ins_linewt", &header_vert_ins_linewt, NULL) &&
        header_vert_ins_linewt == table->header_vert_ins_linewt)
      pass ("TABLE.header_vert_ins_linewt [BS] %hu", header_vert_ins_linewt);
    else
      {
        fail ("TABLE.header_vert_ins_linewt [BS] %hu != %hu", table->header_vert_ins_linewt, header_vert_ins_linewt); error++;
      }
    header_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_vert_ins_linewt", &header_vert_ins_linewt) &&
        header_vert_ins_linewt == table->header_vert_ins_linewt)
      pass ("TABLE.header_vert_ins_linewt [BS] set+1 %hu", header_vert_ins_linewt);
    else
      {
        fail ("TABLE.header_vert_ins_linewt [BS] set+1 %hu != %hu", table->header_vert_ins_linewt, header_vert_ins_linewt); error++;
      }
    table->header_vert_ins_linewt--;

  }
  {
    BITCODE_BS header_vert_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_ins_visibility", &header_vert_ins_visibility, NULL) &&
        header_vert_ins_visibility == table->header_vert_ins_visibility)
      pass ("TABLE.header_vert_ins_visibility [BS] %hu", header_vert_ins_visibility);
    else
      {
        fail ("TABLE.header_vert_ins_visibility [BS] %hu != %hu", table->header_vert_ins_visibility, header_vert_ins_visibility); error++;
      }
    header_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_vert_ins_visibility", &header_vert_ins_visibility) &&
        header_vert_ins_visibility == table->header_vert_ins_visibility)
      pass ("TABLE.header_vert_ins_visibility [BS] set+1 %hu", header_vert_ins_visibility);
    else
      {
        fail ("TABLE.header_vert_ins_visibility [BS] set+1 %hu != %hu", table->header_vert_ins_visibility, header_vert_ins_visibility); error++;
      }
    table->header_vert_ins_visibility--;

  }
  {
    BITCODE_CMC header_vert_left_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_left_color", &header_vert_left_color, NULL)
        && !memcmp(&header_vert_left_color, &table->header_vert_left_color, sizeof(table->header_vert_left_color)))
      pass ("TABLE.header_vert_left_color [CMC]");
    else
      {
        fail ("TABLE.header_vert_left_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS header_vert_left_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_left_linewt", &header_vert_left_linewt, NULL) &&
        header_vert_left_linewt == table->header_vert_left_linewt)
      pass ("TABLE.header_vert_left_linewt [BS] %hu", header_vert_left_linewt);
    else
      {
        fail ("TABLE.header_vert_left_linewt [BS] %hu != %hu", table->header_vert_left_linewt, header_vert_left_linewt); error++;
      }
    header_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_vert_left_linewt", &header_vert_left_linewt) &&
        header_vert_left_linewt == table->header_vert_left_linewt)
      pass ("TABLE.header_vert_left_linewt [BS] set+1 %hu", header_vert_left_linewt);
    else
      {
        fail ("TABLE.header_vert_left_linewt [BS] set+1 %hu != %hu", table->header_vert_left_linewt, header_vert_left_linewt); error++;
      }
    table->header_vert_left_linewt--;

  }
  {
    BITCODE_BS header_vert_left_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_left_visibility", &header_vert_left_visibility, NULL) &&
        header_vert_left_visibility == table->header_vert_left_visibility)
      pass ("TABLE.header_vert_left_visibility [BS] %hu", header_vert_left_visibility);
    else
      {
        fail ("TABLE.header_vert_left_visibility [BS] %hu != %hu", table->header_vert_left_visibility, header_vert_left_visibility); error++;
      }
    header_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_vert_left_visibility", &header_vert_left_visibility) &&
        header_vert_left_visibility == table->header_vert_left_visibility)
      pass ("TABLE.header_vert_left_visibility [BS] set+1 %hu", header_vert_left_visibility);
    else
      {
        fail ("TABLE.header_vert_left_visibility [BS] set+1 %hu != %hu", table->header_vert_left_visibility, header_vert_left_visibility); error++;
      }
    table->header_vert_left_visibility--;

  }
  {
    BITCODE_CMC header_vert_right_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_right_color", &header_vert_right_color, NULL)
        && !memcmp(&header_vert_right_color, &table->header_vert_right_color, sizeof(table->header_vert_right_color)))
      pass ("TABLE.header_vert_right_color [CMC]");
    else
      {
        fail ("TABLE.header_vert_right_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS header_vert_right_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_right_linewt", &header_vert_right_linewt, NULL) &&
        header_vert_right_linewt == table->header_vert_right_linewt)
      pass ("TABLE.header_vert_right_linewt [BS] %hu", header_vert_right_linewt);
    else
      {
        fail ("TABLE.header_vert_right_linewt [BS] %hu != %hu", table->header_vert_right_linewt, header_vert_right_linewt); error++;
      }
    header_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_vert_right_linewt", &header_vert_right_linewt) &&
        header_vert_right_linewt == table->header_vert_right_linewt)
      pass ("TABLE.header_vert_right_linewt [BS] set+1 %hu", header_vert_right_linewt);
    else
      {
        fail ("TABLE.header_vert_right_linewt [BS] set+1 %hu != %hu", table->header_vert_right_linewt, header_vert_right_linewt); error++;
      }
    table->header_vert_right_linewt--;

  }
  {
    BITCODE_BS header_vert_right_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_right_visibility", &header_vert_right_visibility, NULL) &&
        header_vert_right_visibility == table->header_vert_right_visibility)
      pass ("TABLE.header_vert_right_visibility [BS] %hu", header_vert_right_visibility);
    else
      {
        fail ("TABLE.header_vert_right_visibility [BS] %hu != %hu", table->header_vert_right_visibility, header_vert_right_visibility); error++;
      }
    header_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "header_vert_right_visibility", &header_vert_right_visibility) &&
        header_vert_right_visibility == table->header_vert_right_visibility)
      pass ("TABLE.header_vert_right_visibility [BS] set+1 %hu", header_vert_right_visibility);
    else
      {
        fail ("TABLE.header_vert_right_visibility [BS] set+1 %hu != %hu", table->header_vert_right_visibility, header_vert_right_visibility); error++;
      }
    table->header_vert_right_visibility--;

  }
  {
    BITCODE_3BD hor_dir;
    if (dwg_dynapi_entity_value(table, "TABLE", "hor_dir", &hor_dir, NULL)
        && !memcmp(&hor_dir, &table->hor_dir, sizeof(table->hor_dir)))
      pass ("TABLE.hor_dir [3BD]");
    else
      {
        fail ("TABLE.hor_dir [3BD]"); error++;
      }
  }
  {
    BITCODE_BD horiz_cell_margin;
    if (dwg_dynapi_entity_value(table, "TABLE", "horiz_cell_margin", &horiz_cell_margin, NULL) &&
        horiz_cell_margin == table->horiz_cell_margin)
      pass ("TABLE.horiz_cell_margin [BD] %g", horiz_cell_margin);
    else
      {
        fail ("TABLE.horiz_cell_margin [BD] %g != %g", table->horiz_cell_margin, horiz_cell_margin); error++;
      }
    horiz_cell_margin++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "horiz_cell_margin", &horiz_cell_margin) &&
        horiz_cell_margin == table->horiz_cell_margin)
      pass ("TABLE.horiz_cell_margin [BD] set+1 %g", horiz_cell_margin);
    else
      {
        fail ("TABLE.horiz_cell_margin [BD] set+1 %g != %g", table->horiz_cell_margin, horiz_cell_margin); error++;
      }
    table->horiz_cell_margin--;

  }
  {
    BITCODE_3BD horiz_direction;
    if (dwg_dynapi_entity_value(table, "TABLE", "horiz_direction", &horiz_direction, NULL)
        && !memcmp(&horiz_direction, &table->horiz_direction, sizeof(table->horiz_direction)))
      pass ("TABLE.horiz_direction [3BD]");
    else
      {
        fail ("TABLE.horiz_direction [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD insertion_point;
    if (dwg_dynapi_entity_value(table, "TABLE", "insertion_point", &insertion_point, NULL)
        && !memcmp(&insertion_point, &table->insertion_point, sizeof(table->insertion_point)))
      pass ("TABLE.insertion_point [3BD]");
    else
      {
        fail ("TABLE.insertion_point [3BD]"); error++;
      }
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value(table, "TABLE", "last_attrib", &last_attrib, NULL)
        && !memcmp(&last_attrib, &table->last_attrib, sizeof(table->last_attrib)))
      pass ("TABLE.last_attrib [H]");
    else
      {
        fail ("TABLE.last_attrib [H]"); error++;
      }
  }
  {
    BITCODE_BL num_break_heights;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_break_heights", &num_break_heights, NULL) &&
        num_break_heights == table->num_break_heights)
      pass ("TABLE.num_break_heights [BL] %u", num_break_heights);
    else
      {
        fail ("TABLE.num_break_heights [BL] %u != %u", table->num_break_heights, num_break_heights); error++;
      }
    num_break_heights++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "num_break_heights", &num_break_heights) &&
        num_break_heights == table->num_break_heights)
      pass ("TABLE.num_break_heights [BL] set+1 %u", num_break_heights);
    else
      {
        fail ("TABLE.num_break_heights [BL] set+1 %u != %u", table->num_break_heights, num_break_heights); error++;
      }
    table->num_break_heights--;

  }
  {
    BITCODE_BL num_break_rows;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_break_rows", &num_break_rows, NULL) &&
        num_break_rows == table->num_break_rows)
      pass ("TABLE.num_break_rows [BL] %u", num_break_rows);
    else
      {
        fail ("TABLE.num_break_rows [BL] %u != %u", table->num_break_rows, num_break_rows); error++;
      }
    num_break_rows++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "num_break_rows", &num_break_rows) &&
        num_break_rows == table->num_break_rows)
      pass ("TABLE.num_break_rows [BL] set+1 %u", num_break_rows);
    else
      {
        fail ("TABLE.num_break_rows [BL] set+1 %u != %u", table->num_break_rows, num_break_rows); error++;
      }
    table->num_break_rows--;

  }
  {
    unsigned long num_cells;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_cells", &num_cells, NULL) &&
        num_cells == table->num_cells)
      pass ("TABLE.num_cells [unsigned long] %p", num_cells);
    else
      {
        fail ("TABLE.num_cells [unsigned long] %p != %p", table->num_cells, num_cells); error++;
      }
    num_cells++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "num_cells", &num_cells) &&
        num_cells == table->num_cells)
      pass ("TABLE.num_cells [unsigned long] set+1 %p", num_cells);
    else
      {
        fail ("TABLE.num_cells [unsigned long] set+1 %p != %p", table->num_cells, num_cells); error++;
      }
    table->num_cells--;

  }
  {
    BITCODE_BL num_cols;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_cols", &num_cols, NULL) &&
        num_cols == table->num_cols)
      pass ("TABLE.num_cols [BL] %u", num_cols);
    else
      {
        fail ("TABLE.num_cols [BL] %u != %u", table->num_cols, num_cols); error++;
      }
    num_cols++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "num_cols", &num_cols) &&
        num_cols == table->num_cols)
      pass ("TABLE.num_cols [BL] set+1 %u", num_cols);
    else
      {
        fail ("TABLE.num_cols [BL] set+1 %u != %u", table->num_cols, num_cols); error++;
      }
    table->num_cols--;

  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_owned", &num_owned, NULL) &&
        num_owned == table->num_owned)
      pass ("TABLE.num_owned [BL] %u", num_owned);
    else
      {
        fail ("TABLE.num_owned [BL] %u != %u", table->num_owned, num_owned); error++;
      }
    num_owned++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "num_owned", &num_owned) &&
        num_owned == table->num_owned)
      pass ("TABLE.num_owned [BL] set+1 %u", num_owned);
    else
      {
        fail ("TABLE.num_owned [BL] set+1 %u != %u", table->num_owned, num_owned); error++;
      }
    table->num_owned--;

  }
  {
    BITCODE_BL num_rows;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_rows", &num_rows, NULL) &&
        num_rows == table->num_rows)
      pass ("TABLE.num_rows [BL] %u", num_rows);
    else
      {
        fail ("TABLE.num_rows [BL] %u != %u", table->num_rows, num_rows); error++;
      }
    num_rows++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "num_rows", &num_rows) &&
        num_rows == table->num_rows)
      pass ("TABLE.num_rows [BL] set+1 %u", num_rows);
    else
      {
        fail ("TABLE.num_rows [BL] set+1 %u != %u", table->num_rows, num_rows); error++;
      }
    table->num_rows--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(table, "TABLE", "parent", &parent, NULL)
        && !memcmp(&parent, &table->parent, sizeof(table->parent)))
      pass ("TABLE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("TABLE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value(table, "TABLE", "rotation", &rotation, NULL) &&
        rotation == table->rotation)
      pass ("TABLE.rotation [BD] %g", rotation);
    else
      {
        fail ("TABLE.rotation [BD] %g != %g", table->rotation, rotation); error++;
      }
    rotation++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "rotation", &rotation) &&
        rotation == table->rotation)
      pass ("TABLE.rotation [BD] set+1 %g", rotation);
    else
      {
        fail ("TABLE.rotation [BD] set+1 %g != %g", table->rotation, rotation); error++;
      }
    table->rotation--;

  }
  {
    BITCODE_BD* row_heights;
    if (dwg_dynapi_entity_value(table, "TABLE", "row_heights", &row_heights, NULL)
        && !memcmp(&row_heights, &table->row_heights, sizeof(table->row_heights)))
      pass ("TABLE.row_heights [BD*]");
    else
      {
        fail ("TABLE.row_heights [BD*]"); error++;
      }
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value(table, "TABLE", "scale", &scale, NULL)
        && !memcmp(&scale, &table->scale, sizeof(table->scale)))
      pass ("TABLE.scale [3BD]");
    else
      {
        fail ("TABLE.scale [3BD]"); error++;
      }
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value(table, "TABLE", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &table->seqend, sizeof(table->seqend)))
      pass ("TABLE.seqend [H]");
    else
      {
        fail ("TABLE.seqend [H]"); error++;
      }
  }
  {
    BITCODE_BL table_flag_override;
    if (dwg_dynapi_entity_value(table, "TABLE", "table_flag_override", &table_flag_override, NULL) &&
        table_flag_override == table->table_flag_override)
      pass ("TABLE.table_flag_override [BL] %u", table_flag_override);
    else
      {
        fail ("TABLE.table_flag_override [BL] %u != %u", table->table_flag_override, table_flag_override); error++;
      }
    table_flag_override++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "table_flag_override", &table_flag_override) &&
        table_flag_override == table->table_flag_override)
      pass ("TABLE.table_flag_override [BL] set+1 %u", table_flag_override);
    else
      {
        fail ("TABLE.table_flag_override [BL] set+1 %u != %u", table->table_flag_override, table_flag_override); error++;
      }
    table->table_flag_override--;

  }
  {
    BITCODE_H table_style_id;
    if (dwg_dynapi_entity_value(table, "TABLE", "table_style_id", &table_style_id, NULL)
        && !memcmp(&table_style_id, &table->table_style_id, sizeof(table->table_style_id)))
      pass ("TABLE.table_style_id [H]");
    else
      {
        fail ("TABLE.table_style_id [H]"); error++;
      }
  }
  {
    BITCODE_CMC title_horiz_bottom_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_bottom_color", &title_horiz_bottom_color, NULL)
        && !memcmp(&title_horiz_bottom_color, &table->title_horiz_bottom_color, sizeof(table->title_horiz_bottom_color)))
      pass ("TABLE.title_horiz_bottom_color [CMC]");
    else
      {
        fail ("TABLE.title_horiz_bottom_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS title_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_bottom_linewt", &title_horiz_bottom_linewt, NULL) &&
        title_horiz_bottom_linewt == table->title_horiz_bottom_linewt)
      pass ("TABLE.title_horiz_bottom_linewt [BS] %hu", title_horiz_bottom_linewt);
    else
      {
        fail ("TABLE.title_horiz_bottom_linewt [BS] %hu != %hu", table->title_horiz_bottom_linewt, title_horiz_bottom_linewt); error++;
      }
    title_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_horiz_bottom_linewt", &title_horiz_bottom_linewt) &&
        title_horiz_bottom_linewt == table->title_horiz_bottom_linewt)
      pass ("TABLE.title_horiz_bottom_linewt [BS] set+1 %hu", title_horiz_bottom_linewt);
    else
      {
        fail ("TABLE.title_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->title_horiz_bottom_linewt, title_horiz_bottom_linewt); error++;
      }
    table->title_horiz_bottom_linewt--;

  }
  {
    BITCODE_BS title_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_bottom_visibility", &title_horiz_bottom_visibility, NULL) &&
        title_horiz_bottom_visibility == table->title_horiz_bottom_visibility)
      pass ("TABLE.title_horiz_bottom_visibility [BS] %hu", title_horiz_bottom_visibility);
    else
      {
        fail ("TABLE.title_horiz_bottom_visibility [BS] %hu != %hu", table->title_horiz_bottom_visibility, title_horiz_bottom_visibility); error++;
      }
    title_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_horiz_bottom_visibility", &title_horiz_bottom_visibility) &&
        title_horiz_bottom_visibility == table->title_horiz_bottom_visibility)
      pass ("TABLE.title_horiz_bottom_visibility [BS] set+1 %hu", title_horiz_bottom_visibility);
    else
      {
        fail ("TABLE.title_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->title_horiz_bottom_visibility, title_horiz_bottom_visibility); error++;
      }
    table->title_horiz_bottom_visibility--;

  }
  {
    BITCODE_CMC title_horiz_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_ins_color", &title_horiz_ins_color, NULL)
        && !memcmp(&title_horiz_ins_color, &table->title_horiz_ins_color, sizeof(table->title_horiz_ins_color)))
      pass ("TABLE.title_horiz_ins_color [CMC]");
    else
      {
        fail ("TABLE.title_horiz_ins_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS title_horiz_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_ins_linewt", &title_horiz_ins_linewt, NULL) &&
        title_horiz_ins_linewt == table->title_horiz_ins_linewt)
      pass ("TABLE.title_horiz_ins_linewt [BS] %hu", title_horiz_ins_linewt);
    else
      {
        fail ("TABLE.title_horiz_ins_linewt [BS] %hu != %hu", table->title_horiz_ins_linewt, title_horiz_ins_linewt); error++;
      }
    title_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_horiz_ins_linewt", &title_horiz_ins_linewt) &&
        title_horiz_ins_linewt == table->title_horiz_ins_linewt)
      pass ("TABLE.title_horiz_ins_linewt [BS] set+1 %hu", title_horiz_ins_linewt);
    else
      {
        fail ("TABLE.title_horiz_ins_linewt [BS] set+1 %hu != %hu", table->title_horiz_ins_linewt, title_horiz_ins_linewt); error++;
      }
    table->title_horiz_ins_linewt--;

  }
  {
    BITCODE_BS title_horiz_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_ins_visibility", &title_horiz_ins_visibility, NULL) &&
        title_horiz_ins_visibility == table->title_horiz_ins_visibility)
      pass ("TABLE.title_horiz_ins_visibility [BS] %hu", title_horiz_ins_visibility);
    else
      {
        fail ("TABLE.title_horiz_ins_visibility [BS] %hu != %hu", table->title_horiz_ins_visibility, title_horiz_ins_visibility); error++;
      }
    title_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_horiz_ins_visibility", &title_horiz_ins_visibility) &&
        title_horiz_ins_visibility == table->title_horiz_ins_visibility)
      pass ("TABLE.title_horiz_ins_visibility [BS] set+1 %hu", title_horiz_ins_visibility);
    else
      {
        fail ("TABLE.title_horiz_ins_visibility [BS] set+1 %hu != %hu", table->title_horiz_ins_visibility, title_horiz_ins_visibility); error++;
      }
    table->title_horiz_ins_visibility--;

  }
  {
    BITCODE_CMC title_horiz_top_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_top_color", &title_horiz_top_color, NULL)
        && !memcmp(&title_horiz_top_color, &table->title_horiz_top_color, sizeof(table->title_horiz_top_color)))
      pass ("TABLE.title_horiz_top_color [CMC]");
    else
      {
        fail ("TABLE.title_horiz_top_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS title_horiz_top_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_top_linewt", &title_horiz_top_linewt, NULL) &&
        title_horiz_top_linewt == table->title_horiz_top_linewt)
      pass ("TABLE.title_horiz_top_linewt [BS] %hu", title_horiz_top_linewt);
    else
      {
        fail ("TABLE.title_horiz_top_linewt [BS] %hu != %hu", table->title_horiz_top_linewt, title_horiz_top_linewt); error++;
      }
    title_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_horiz_top_linewt", &title_horiz_top_linewt) &&
        title_horiz_top_linewt == table->title_horiz_top_linewt)
      pass ("TABLE.title_horiz_top_linewt [BS] set+1 %hu", title_horiz_top_linewt);
    else
      {
        fail ("TABLE.title_horiz_top_linewt [BS] set+1 %hu != %hu", table->title_horiz_top_linewt, title_horiz_top_linewt); error++;
      }
    table->title_horiz_top_linewt--;

  }
  {
    BITCODE_BS title_horiz_top_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_top_visibility", &title_horiz_top_visibility, NULL) &&
        title_horiz_top_visibility == table->title_horiz_top_visibility)
      pass ("TABLE.title_horiz_top_visibility [BS] %hu", title_horiz_top_visibility);
    else
      {
        fail ("TABLE.title_horiz_top_visibility [BS] %hu != %hu", table->title_horiz_top_visibility, title_horiz_top_visibility); error++;
      }
    title_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_horiz_top_visibility", &title_horiz_top_visibility) &&
        title_horiz_top_visibility == table->title_horiz_top_visibility)
      pass ("TABLE.title_horiz_top_visibility [BS] set+1 %hu", title_horiz_top_visibility);
    else
      {
        fail ("TABLE.title_horiz_top_visibility [BS] set+1 %hu != %hu", table->title_horiz_top_visibility, title_horiz_top_visibility); error++;
      }
    table->title_horiz_top_visibility--;

  }
  {
    BITCODE_BS title_row_alignment;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_alignment", &title_row_alignment, NULL) &&
        title_row_alignment == table->title_row_alignment)
      pass ("TABLE.title_row_alignment [BS] %hu", title_row_alignment);
    else
      {
        fail ("TABLE.title_row_alignment [BS] %hu != %hu", table->title_row_alignment, title_row_alignment); error++;
      }
    title_row_alignment++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_row_alignment", &title_row_alignment) &&
        title_row_alignment == table->title_row_alignment)
      pass ("TABLE.title_row_alignment [BS] set+1 %hu", title_row_alignment);
    else
      {
        fail ("TABLE.title_row_alignment [BS] set+1 %hu != %hu", table->title_row_alignment, title_row_alignment); error++;
      }
    table->title_row_alignment--;

  }
  {
    BITCODE_CMC title_row_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_color", &title_row_color, NULL)
        && !memcmp(&title_row_color, &table->title_row_color, sizeof(table->title_row_color)))
      pass ("TABLE.title_row_color [CMC]");
    else
      {
        fail ("TABLE.title_row_color [CMC]"); error++;
      }
  }
  {
    BITCODE_CMC title_row_fill_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_fill_color", &title_row_fill_color, NULL)
        && !memcmp(&title_row_fill_color, &table->title_row_fill_color, sizeof(table->title_row_fill_color)))
      pass ("TABLE.title_row_fill_color [CMC]");
    else
      {
        fail ("TABLE.title_row_fill_color [CMC]"); error++;
      }
  }
  {
    BITCODE_B title_row_fill_none;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_fill_none", &title_row_fill_none, NULL) &&
        title_row_fill_none == table->title_row_fill_none)
      pass ("TABLE.title_row_fill_none [B] " FORMAT_B "", title_row_fill_none);
    else
      {
        fail ("TABLE.title_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->title_row_fill_none, title_row_fill_none); error++;
      }
    title_row_fill_none++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_row_fill_none", &title_row_fill_none) &&
        title_row_fill_none == table->title_row_fill_none)
      pass ("TABLE.title_row_fill_none [B] set+1 " FORMAT_B "", title_row_fill_none);
    else
      {
        fail ("TABLE.title_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->title_row_fill_none, title_row_fill_none); error++;
      }
    table->title_row_fill_none--;

  }
  {
    BITCODE_BD title_row_height;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_height", &title_row_height, NULL) &&
        title_row_height == table->title_row_height)
      pass ("TABLE.title_row_height [BD] %g", title_row_height);
    else
      {
        fail ("TABLE.title_row_height [BD] %g != %g", table->title_row_height, title_row_height); error++;
      }
    title_row_height++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_row_height", &title_row_height) &&
        title_row_height == table->title_row_height)
      pass ("TABLE.title_row_height [BD] set+1 %g", title_row_height);
    else
      {
        fail ("TABLE.title_row_height [BD] set+1 %g != %g", table->title_row_height, title_row_height); error++;
      }
    table->title_row_height--;

  }
  {
    BITCODE_H title_row_style_override;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_style_override", &title_row_style_override, NULL)
        && !memcmp(&title_row_style_override, &table->title_row_style_override, sizeof(table->title_row_style_override)))
      pass ("TABLE.title_row_style_override [H]");
    else
      {
        fail ("TABLE.title_row_style_override [H]"); error++;
      }
  }
  {
    BITCODE_B title_suppressed;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_suppressed", &title_suppressed, NULL) &&
        title_suppressed == table->title_suppressed)
      pass ("TABLE.title_suppressed [B] " FORMAT_B "", title_suppressed);
    else
      {
        fail ("TABLE.title_suppressed [B] " FORMAT_B " != " FORMAT_B "", table->title_suppressed, title_suppressed); error++;
      }
    title_suppressed++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_suppressed", &title_suppressed) &&
        title_suppressed == table->title_suppressed)
      pass ("TABLE.title_suppressed [B] set+1 " FORMAT_B "", title_suppressed);
    else
      {
        fail ("TABLE.title_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", table->title_suppressed, title_suppressed); error++;
      }
    table->title_suppressed--;

  }
  {
    BITCODE_H title_text_style;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_text_style", &title_text_style, NULL)
        && !memcmp(&title_text_style, &table->title_text_style, sizeof(table->title_text_style)))
      pass ("TABLE.title_text_style [H]");
    else
      {
        fail ("TABLE.title_text_style [H]"); error++;
      }
  }
  {
    BITCODE_CMC title_vert_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_ins_color", &title_vert_ins_color, NULL)
        && !memcmp(&title_vert_ins_color, &table->title_vert_ins_color, sizeof(table->title_vert_ins_color)))
      pass ("TABLE.title_vert_ins_color [CMC]");
    else
      {
        fail ("TABLE.title_vert_ins_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS title_vert_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_ins_linewt", &title_vert_ins_linewt, NULL) &&
        title_vert_ins_linewt == table->title_vert_ins_linewt)
      pass ("TABLE.title_vert_ins_linewt [BS] %hu", title_vert_ins_linewt);
    else
      {
        fail ("TABLE.title_vert_ins_linewt [BS] %hu != %hu", table->title_vert_ins_linewt, title_vert_ins_linewt); error++;
      }
    title_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_vert_ins_linewt", &title_vert_ins_linewt) &&
        title_vert_ins_linewt == table->title_vert_ins_linewt)
      pass ("TABLE.title_vert_ins_linewt [BS] set+1 %hu", title_vert_ins_linewt);
    else
      {
        fail ("TABLE.title_vert_ins_linewt [BS] set+1 %hu != %hu", table->title_vert_ins_linewt, title_vert_ins_linewt); error++;
      }
    table->title_vert_ins_linewt--;

  }
  {
    BITCODE_BS title_vert_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_ins_visibility", &title_vert_ins_visibility, NULL) &&
        title_vert_ins_visibility == table->title_vert_ins_visibility)
      pass ("TABLE.title_vert_ins_visibility [BS] %hu", title_vert_ins_visibility);
    else
      {
        fail ("TABLE.title_vert_ins_visibility [BS] %hu != %hu", table->title_vert_ins_visibility, title_vert_ins_visibility); error++;
      }
    title_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_vert_ins_visibility", &title_vert_ins_visibility) &&
        title_vert_ins_visibility == table->title_vert_ins_visibility)
      pass ("TABLE.title_vert_ins_visibility [BS] set+1 %hu", title_vert_ins_visibility);
    else
      {
        fail ("TABLE.title_vert_ins_visibility [BS] set+1 %hu != %hu", table->title_vert_ins_visibility, title_vert_ins_visibility); error++;
      }
    table->title_vert_ins_visibility--;

  }
  {
    BITCODE_CMC title_vert_left_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_left_color", &title_vert_left_color, NULL)
        && !memcmp(&title_vert_left_color, &table->title_vert_left_color, sizeof(table->title_vert_left_color)))
      pass ("TABLE.title_vert_left_color [CMC]");
    else
      {
        fail ("TABLE.title_vert_left_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS title_vert_left_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_left_linewt", &title_vert_left_linewt, NULL) &&
        title_vert_left_linewt == table->title_vert_left_linewt)
      pass ("TABLE.title_vert_left_linewt [BS] %hu", title_vert_left_linewt);
    else
      {
        fail ("TABLE.title_vert_left_linewt [BS] %hu != %hu", table->title_vert_left_linewt, title_vert_left_linewt); error++;
      }
    title_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_vert_left_linewt", &title_vert_left_linewt) &&
        title_vert_left_linewt == table->title_vert_left_linewt)
      pass ("TABLE.title_vert_left_linewt [BS] set+1 %hu", title_vert_left_linewt);
    else
      {
        fail ("TABLE.title_vert_left_linewt [BS] set+1 %hu != %hu", table->title_vert_left_linewt, title_vert_left_linewt); error++;
      }
    table->title_vert_left_linewt--;

  }
  {
    BITCODE_BS title_vert_left_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_left_visibility", &title_vert_left_visibility, NULL) &&
        title_vert_left_visibility == table->title_vert_left_visibility)
      pass ("TABLE.title_vert_left_visibility [BS] %hu", title_vert_left_visibility);
    else
      {
        fail ("TABLE.title_vert_left_visibility [BS] %hu != %hu", table->title_vert_left_visibility, title_vert_left_visibility); error++;
      }
    title_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_vert_left_visibility", &title_vert_left_visibility) &&
        title_vert_left_visibility == table->title_vert_left_visibility)
      pass ("TABLE.title_vert_left_visibility [BS] set+1 %hu", title_vert_left_visibility);
    else
      {
        fail ("TABLE.title_vert_left_visibility [BS] set+1 %hu != %hu", table->title_vert_left_visibility, title_vert_left_visibility); error++;
      }
    table->title_vert_left_visibility--;

  }
  {
    BITCODE_CMC title_vert_right_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_right_color", &title_vert_right_color, NULL)
        && !memcmp(&title_vert_right_color, &table->title_vert_right_color, sizeof(table->title_vert_right_color)))
      pass ("TABLE.title_vert_right_color [CMC]");
    else
      {
        fail ("TABLE.title_vert_right_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS title_vert_right_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_right_linewt", &title_vert_right_linewt, NULL) &&
        title_vert_right_linewt == table->title_vert_right_linewt)
      pass ("TABLE.title_vert_right_linewt [BS] %hu", title_vert_right_linewt);
    else
      {
        fail ("TABLE.title_vert_right_linewt [BS] %hu != %hu", table->title_vert_right_linewt, title_vert_right_linewt); error++;
      }
    title_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_vert_right_linewt", &title_vert_right_linewt) &&
        title_vert_right_linewt == table->title_vert_right_linewt)
      pass ("TABLE.title_vert_right_linewt [BS] set+1 %hu", title_vert_right_linewt);
    else
      {
        fail ("TABLE.title_vert_right_linewt [BS] set+1 %hu != %hu", table->title_vert_right_linewt, title_vert_right_linewt); error++;
      }
    table->title_vert_right_linewt--;

  }
  {
    BITCODE_BS title_vert_right_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_right_visibility", &title_vert_right_visibility, NULL) &&
        title_vert_right_visibility == table->title_vert_right_visibility)
      pass ("TABLE.title_vert_right_visibility [BS] %hu", title_vert_right_visibility);
    else
      {
        fail ("TABLE.title_vert_right_visibility [BS] %hu != %hu", table->title_vert_right_visibility, title_vert_right_visibility); error++;
      }
    title_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "title_vert_right_visibility", &title_vert_right_visibility) &&
        title_vert_right_visibility == table->title_vert_right_visibility)
      pass ("TABLE.title_vert_right_visibility [BS] set+1 %hu", title_vert_right_visibility);
    else
      {
        fail ("TABLE.title_vert_right_visibility [BS] set+1 %hu != %hu", table->title_vert_right_visibility, title_vert_right_visibility); error++;
      }
    table->title_vert_right_visibility--;

  }
  {
    BITCODE_B unknown_b;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_b", &unknown_b, NULL) &&
        unknown_b == table->unknown_b)
      pass ("TABLE.unknown_b [B] " FORMAT_B "", unknown_b);
    else
      {
        fail ("TABLE.unknown_b [B] " FORMAT_B " != " FORMAT_B "", table->unknown_b, unknown_b); error++;
      }
    unknown_b++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "unknown_b", &unknown_b) &&
        unknown_b == table->unknown_b)
      pass ("TABLE.unknown_b [B] set+1 " FORMAT_B "", unknown_b);
    else
      {
        fail ("TABLE.unknown_b [B] set+1 " FORMAT_B " != " FORMAT_B "", table->unknown_b, unknown_b); error++;
      }
    table->unknown_b--;

  }
  {
    BITCODE_BL unknown_bl;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_bl", &unknown_bl, NULL) &&
        unknown_bl == table->unknown_bl)
      pass ("TABLE.unknown_bl [BL] %u", unknown_bl);
    else
      {
        fail ("TABLE.unknown_bl [BL] %u != %u", table->unknown_bl, unknown_bl); error++;
      }
    unknown_bl++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "unknown_bl", &unknown_bl) &&
        unknown_bl == table->unknown_bl)
      pass ("TABLE.unknown_bl [BL] set+1 %u", unknown_bl);
    else
      {
        fail ("TABLE.unknown_bl [BL] set+1 %u != %u", table->unknown_bl, unknown_bl); error++;
      }
    table->unknown_bl--;

  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_bl1", &unknown_bl1, NULL) &&
        unknown_bl1 == table->unknown_bl1)
      pass ("TABLE.unknown_bl1 [BL] %u", unknown_bl1);
    else
      {
        fail ("TABLE.unknown_bl1 [BL] %u != %u", table->unknown_bl1, unknown_bl1); error++;
      }
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "unknown_bl1", &unknown_bl1) &&
        unknown_bl1 == table->unknown_bl1)
      pass ("TABLE.unknown_bl1 [BL] set+1 %u", unknown_bl1);
    else
      {
        fail ("TABLE.unknown_bl1 [BL] set+1 %u != %u", table->unknown_bl1, unknown_bl1); error++;
      }
    table->unknown_bl1--;

  }
  {
    BITCODE_BS unknown_bs;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_bs", &unknown_bs, NULL) &&
        unknown_bs == table->unknown_bs)
      pass ("TABLE.unknown_bs [BS] %hu", unknown_bs);
    else
      {
        fail ("TABLE.unknown_bs [BS] %hu != %hu", table->unknown_bs, unknown_bs); error++;
      }
    unknown_bs++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "unknown_bs", &unknown_bs) &&
        unknown_bs == table->unknown_bs)
      pass ("TABLE.unknown_bs [BS] set+1 %hu", unknown_bs);
    else
      {
        fail ("TABLE.unknown_bs [BS] set+1 %hu != %hu", table->unknown_bs, unknown_bs); error++;
      }
    table->unknown_bs--;

  }
  {
    BITCODE_H unknown_h;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_h", &unknown_h, NULL)
        && !memcmp(&unknown_h, &table->unknown_h, sizeof(table->unknown_h)))
      pass ("TABLE.unknown_h [H]");
    else
      {
        fail ("TABLE.unknown_h [H]"); error++;
      }
  }
  {
    BITCODE_RC unknown_rc;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_rc", &unknown_rc, NULL) &&
        unknown_rc == table->unknown_rc)
      pass ("TABLE.unknown_rc [RC] %u", unknown_rc);
    else
      {
        fail ("TABLE.unknown_rc [RC] %u != %u", table->unknown_rc, unknown_rc); error++;
      }
    unknown_rc++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "unknown_rc", &unknown_rc) &&
        unknown_rc == table->unknown_rc)
      pass ("TABLE.unknown_rc [RC] set+1 %u", unknown_rc);
    else
      {
        fail ("TABLE.unknown_rc [RC] set+1 %u != %u", table->unknown_rc, unknown_rc); error++;
      }
    table->unknown_rc--;

  }
  {
    BITCODE_BD vert_cell_margin;
    if (dwg_dynapi_entity_value(table, "TABLE", "vert_cell_margin", &vert_cell_margin, NULL) &&
        vert_cell_margin == table->vert_cell_margin)
      pass ("TABLE.vert_cell_margin [BD] %g", vert_cell_margin);
    else
      {
        fail ("TABLE.vert_cell_margin [BD] %g != %g", table->vert_cell_margin, vert_cell_margin); error++;
      }
    vert_cell_margin++;
    if (dwg_dynapi_entity_set_value(table, "TABLE", "vert_cell_margin", &vert_cell_margin) &&
        vert_cell_margin == table->vert_cell_margin)
      pass ("TABLE.vert_cell_margin [BD] set+1 %g", vert_cell_margin);
    else
      {
        fail ("TABLE.vert_cell_margin [BD] set+1 %g != %g", table->vert_cell_margin, vert_cell_margin); error++;
      }
    table->vert_cell_margin--;

  }
  return error;
}
static int test_TEXT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_TEXT *text = obj->tio.entity->tio.TEXT;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value(text, "TEXT", "alignment_pt", &alignment_pt, NULL)
        && !memcmp(&alignment_pt, &text->alignment_pt, sizeof(text->alignment_pt)))
      pass ("TEXT.alignment_pt [2DPOINT]");
    else
      {
        fail ("TEXT.alignment_pt [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value(text, "TEXT", "dataflags", &dataflags, NULL) &&
        dataflags == text->dataflags)
      pass ("TEXT.dataflags [RC] %u", dataflags);
    else
      {
        fail ("TEXT.dataflags [RC] %u != %u", text->dataflags, dataflags); error++;
      }
    dataflags++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "dataflags", &dataflags) &&
        dataflags == text->dataflags)
      pass ("TEXT.dataflags [RC] set+1 %u", dataflags);
    else
      {
        fail ("TEXT.dataflags [RC] set+1 %u != %u", text->dataflags, dataflags); error++;
      }
    text->dataflags--;

  }
  {
    BITCODE_RD elevation;
    if (dwg_dynapi_entity_value(text, "TEXT", "elevation", &elevation, NULL) &&
        elevation == text->elevation)
      pass ("TEXT.elevation [RD] %g", elevation);
    else
      {
        fail ("TEXT.elevation [RD] %g != %g", text->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "elevation", &elevation) &&
        elevation == text->elevation)
      pass ("TEXT.elevation [RD] set+1 %g", elevation);
    else
      {
        fail ("TEXT.elevation [RD] set+1 %g != %g", text->elevation, elevation); error++;
      }
    text->elevation--;

  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(text, "TEXT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &text->extrusion, sizeof(text->extrusion)))
      pass ("TEXT.extrusion [3DPOINT]");
    else
      {
        fail ("TEXT.extrusion [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value(text, "TEXT", "generation", &generation, NULL) &&
        generation == text->generation)
      pass ("TEXT.generation [BS] %hu", generation);
    else
      {
        fail ("TEXT.generation [BS] %hu != %hu", text->generation, generation); error++;
      }
    generation++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "generation", &generation) &&
        generation == text->generation)
      pass ("TEXT.generation [BS] set+1 %hu", generation);
    else
      {
        fail ("TEXT.generation [BS] set+1 %hu != %hu", text->generation, generation); error++;
      }
    text->generation--;

  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value(text, "TEXT", "height", &height, NULL) &&
        height == text->height)
      pass ("TEXT.height [RD] %g", height);
    else
      {
        fail ("TEXT.height [RD] %g != %g", text->height, height); error++;
      }
    height++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "height", &height) &&
        height == text->height)
      pass ("TEXT.height [RD] set+1 %g", height);
    else
      {
        fail ("TEXT.height [RD] set+1 %g != %g", text->height, height); error++;
      }
    text->height--;

  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value(text, "TEXT", "horiz_alignment", &horiz_alignment, NULL) &&
        horiz_alignment == text->horiz_alignment)
      pass ("TEXT.horiz_alignment [BS] %hu", horiz_alignment);
    else
      {
        fail ("TEXT.horiz_alignment [BS] %hu != %hu", text->horiz_alignment, horiz_alignment); error++;
      }
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "horiz_alignment", &horiz_alignment) &&
        horiz_alignment == text->horiz_alignment)
      pass ("TEXT.horiz_alignment [BS] set+1 %hu", horiz_alignment);
    else
      {
        fail ("TEXT.horiz_alignment [BS] set+1 %hu != %hu", text->horiz_alignment, horiz_alignment); error++;
      }
    text->horiz_alignment--;

  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value(text, "TEXT", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &text->insertion_pt, sizeof(text->insertion_pt)))
      pass ("TEXT.insertion_pt [2DPOINT]");
    else
      {
        fail ("TEXT.insertion_pt [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value(text, "TEXT", "oblique_ang", &oblique_ang, NULL) &&
        oblique_ang == text->oblique_ang)
      pass ("TEXT.oblique_ang [RD] %g", oblique_ang);
    else
      {
        fail ("TEXT.oblique_ang [RD] %g != %g", text->oblique_ang, oblique_ang); error++;
      }
    oblique_ang++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "oblique_ang", &oblique_ang) &&
        oblique_ang == text->oblique_ang)
      pass ("TEXT.oblique_ang [RD] set+1 %g", oblique_ang);
    else
      {
        fail ("TEXT.oblique_ang [RD] set+1 %g != %g", text->oblique_ang, oblique_ang); error++;
      }
    text->oblique_ang--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(text, "TEXT", "parent", &parent, NULL)
        && !memcmp(&parent, &text->parent, sizeof(text->parent)))
      pass ("TEXT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("TEXT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value(text, "TEXT", "rotation", &rotation, NULL) &&
        rotation == text->rotation)
      pass ("TEXT.rotation [RD] %g", rotation);
    else
      {
        fail ("TEXT.rotation [RD] %g != %g", text->rotation, rotation); error++;
      }
    rotation++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "rotation", &rotation) &&
        rotation == text->rotation)
      pass ("TEXT.rotation [RD] set+1 %g", rotation);
    else
      {
        fail ("TEXT.rotation [RD] set+1 %g != %g", text->rotation, rotation); error++;
      }
    text->rotation--;

  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(text, "TEXT", "style", &style, NULL)
        && !memcmp(&style, &text->style, sizeof(text->style)))
      pass ("TEXT.style [H]");
    else
      {
        fail ("TEXT.style [H]"); error++;
      }
  }
  {
    BITCODE_TV text_value;
    if (dwg_dynapi_entity_value(text, "TEXT", "text_value", &text_value, NULL)
        && !strcmp((char*)&text_value, (char*)&text->text_value))
      pass ("TEXT.text_value [TV]");
    else
      {
        fail ("TEXT.text_value [TV]"); error++;
      }
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value(text, "TEXT", "thickness", &thickness, NULL) &&
        thickness == text->thickness)
      pass ("TEXT.thickness [RD] %g", thickness);
    else
      {
        fail ("TEXT.thickness [RD] %g != %g", text->thickness, thickness); error++;
      }
    thickness++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "thickness", &thickness) &&
        thickness == text->thickness)
      pass ("TEXT.thickness [RD] set+1 %g", thickness);
    else
      {
        fail ("TEXT.thickness [RD] set+1 %g != %g", text->thickness, thickness); error++;
      }
    text->thickness--;

  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value(text, "TEXT", "vert_alignment", &vert_alignment, NULL) &&
        vert_alignment == text->vert_alignment)
      pass ("TEXT.vert_alignment [BS] %hu", vert_alignment);
    else
      {
        fail ("TEXT.vert_alignment [BS] %hu != %hu", text->vert_alignment, vert_alignment); error++;
      }
    vert_alignment++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "vert_alignment", &vert_alignment) &&
        vert_alignment == text->vert_alignment)
      pass ("TEXT.vert_alignment [BS] set+1 %hu", vert_alignment);
    else
      {
        fail ("TEXT.vert_alignment [BS] set+1 %hu != %hu", text->vert_alignment, vert_alignment); error++;
      }
    text->vert_alignment--;

  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value(text, "TEXT", "width_factor", &width_factor, NULL) &&
        width_factor == text->width_factor)
      pass ("TEXT.width_factor [RD] %g", width_factor);
    else
      {
        fail ("TEXT.width_factor [RD] %g != %g", text->width_factor, width_factor); error++;
      }
    width_factor++;
    if (dwg_dynapi_entity_set_value(text, "TEXT", "width_factor", &width_factor) &&
        width_factor == text->width_factor)
      pass ("TEXT.width_factor [RD] set+1 %g", width_factor);
    else
      {
        fail ("TEXT.width_factor [RD] set+1 %g != %g", text->width_factor, width_factor); error++;
      }
    text->width_factor--;

  }
  return error;
}
static int test_TOLERANCE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_TOLERANCE *tolerance = obj->tio.entity->tio.TOLERANCE;
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "dimgap", &dimgap, NULL) &&
        dimgap == tolerance->dimgap)
      pass ("TOLERANCE.dimgap [BD] %g", dimgap);
    else
      {
        fail ("TOLERANCE.dimgap [BD] %g != %g", tolerance->dimgap, dimgap); error++;
      }
    dimgap++;
    if (dwg_dynapi_entity_set_value(tolerance, "TOLERANCE", "dimgap", &dimgap) &&
        dimgap == tolerance->dimgap)
      pass ("TOLERANCE.dimgap [BD] set+1 %g", dimgap);
    else
      {
        fail ("TOLERANCE.dimgap [BD] set+1 %g != %g", tolerance->dimgap, dimgap); error++;
      }
    tolerance->dimgap--;

  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "dimstyle", &dimstyle, NULL)
        && !memcmp(&dimstyle, &tolerance->dimstyle, sizeof(tolerance->dimstyle)))
      pass ("TOLERANCE.dimstyle [H]");
    else
      {
        fail ("TOLERANCE.dimstyle [H]"); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &tolerance->extrusion, sizeof(tolerance->extrusion)))
      pass ("TOLERANCE.extrusion [3BD]");
    else
      {
        fail ("TOLERANCE.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "height", &height, NULL) &&
        height == tolerance->height)
      pass ("TOLERANCE.height [BD] %g", height);
    else
      {
        fail ("TOLERANCE.height [BD] %g != %g", tolerance->height, height); error++;
      }
    height++;
    if (dwg_dynapi_entity_set_value(tolerance, "TOLERANCE", "height", &height) &&
        height == tolerance->height)
      pass ("TOLERANCE.height [BD] set+1 %g", height);
    else
      {
        fail ("TOLERANCE.height [BD] set+1 %g != %g", tolerance->height, height); error++;
      }
    tolerance->height--;

  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "ins_pt", &ins_pt, NULL)
        && !memcmp(&ins_pt, &tolerance->ins_pt, sizeof(tolerance->ins_pt)))
      pass ("TOLERANCE.ins_pt [3BD]");
    else
      {
        fail ("TOLERANCE.ins_pt [3BD]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "parent", &parent, NULL)
        && !memcmp(&parent, &tolerance->parent, sizeof(tolerance->parent)))
      pass ("TOLERANCE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("TOLERANCE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_TV text_string;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "text_string", &text_string, NULL)
        && !strcmp((char*)&text_string, (char*)&tolerance->text_string))
      pass ("TOLERANCE.text_string [TV]");
    else
      {
        fail ("TOLERANCE.text_string [TV]"); error++;
      }
  }
  {
    BITCODE_BS unknown_short;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "unknown_short", &unknown_short, NULL) &&
        unknown_short == tolerance->unknown_short)
      pass ("TOLERANCE.unknown_short [BS] %hu", unknown_short);
    else
      {
        fail ("TOLERANCE.unknown_short [BS] %hu != %hu", tolerance->unknown_short, unknown_short); error++;
      }
    unknown_short++;
    if (dwg_dynapi_entity_set_value(tolerance, "TOLERANCE", "unknown_short", &unknown_short) &&
        unknown_short == tolerance->unknown_short)
      pass ("TOLERANCE.unknown_short [BS] set+1 %hu", unknown_short);
    else
      {
        fail ("TOLERANCE.unknown_short [BS] set+1 %hu != %hu", tolerance->unknown_short, unknown_short); error++;
      }
    tolerance->unknown_short--;

  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "x_direction", &x_direction, NULL)
        && !memcmp(&x_direction, &tolerance->x_direction, sizeof(tolerance->x_direction)))
      pass ("TOLERANCE.x_direction [3BD]");
    else
      {
        fail ("TOLERANCE.x_direction [3BD]"); error++;
      }
  }
  return error;
}
static int test_TRACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_TRACE *trace = obj->tio.entity->tio.TRACE;
  {
    BITCODE_2RD corner1;
    if (dwg_dynapi_entity_value(trace, "TRACE", "corner1", &corner1, NULL)
        && !memcmp(&corner1, &trace->corner1, sizeof(trace->corner1)))
      pass ("TRACE.corner1 [2RD]");
    else
      {
        fail ("TRACE.corner1 [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD corner2;
    if (dwg_dynapi_entity_value(trace, "TRACE", "corner2", &corner2, NULL)
        && !memcmp(&corner2, &trace->corner2, sizeof(trace->corner2)))
      pass ("TRACE.corner2 [2RD]");
    else
      {
        fail ("TRACE.corner2 [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD corner3;
    if (dwg_dynapi_entity_value(trace, "TRACE", "corner3", &corner3, NULL)
        && !memcmp(&corner3, &trace->corner3, sizeof(trace->corner3)))
      pass ("TRACE.corner3 [2RD]");
    else
      {
        fail ("TRACE.corner3 [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD corner4;
    if (dwg_dynapi_entity_value(trace, "TRACE", "corner4", &corner4, NULL)
        && !memcmp(&corner4, &trace->corner4, sizeof(trace->corner4)))
      pass ("TRACE.corner4 [2RD]");
    else
      {
        fail ("TRACE.corner4 [2RD]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(trace, "TRACE", "elevation", &elevation, NULL) &&
        elevation == trace->elevation)
      pass ("TRACE.elevation [BD] %g", elevation);
    else
      {
        fail ("TRACE.elevation [BD] %g != %g", trace->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(trace, "TRACE", "elevation", &elevation) &&
        elevation == trace->elevation)
      pass ("TRACE.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("TRACE.elevation [BD] set+1 %g != %g", trace->elevation, elevation); error++;
      }
    trace->elevation--;

  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(trace, "TRACE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &trace->extrusion, sizeof(trace->extrusion)))
      pass ("TRACE.extrusion [BE]");
    else
      {
        fail ("TRACE.extrusion [BE]"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(trace, "TRACE", "parent", &parent, NULL)
        && !memcmp(&parent, &trace->parent, sizeof(trace->parent)))
      pass ("TRACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("TRACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(trace, "TRACE", "thickness", &thickness, NULL) &&
        thickness == trace->thickness)
      pass ("TRACE.thickness [BT] " FORMAT_BT "", thickness);
    else
      {
        fail ("TRACE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", trace->thickness, thickness); error++;
      }
    if (dwg_dynapi_entity_set_value(trace, "TRACE", "thickness", &thickness) &&
        thickness == trace->thickness)
      pass ("TRACE.thickness [BT] set+1 " FORMAT_BT "", thickness);
    else
      {
        fail ("TRACE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", trace->thickness, thickness); error++;
      }
    trace->thickness--;

  }
  return error;
}
static int test_UNDERLAY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_UNDERLAY *underlay = obj->tio.entity->tio.UNDERLAY;
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "angle", &angle, NULL) &&
        angle == underlay->angle)
      pass ("UNDERLAY.angle [BD] %g", angle);
    else
      {
        fail ("UNDERLAY.angle [BD] %g != %g", underlay->angle, angle); error++;
      }
    angle++;
    if (dwg_dynapi_entity_set_value(underlay, "UNDERLAY", "angle", &angle) &&
        angle == underlay->angle)
      pass ("UNDERLAY.angle [BD] set+1 %g", angle);
    else
      {
        fail ("UNDERLAY.angle [BD] set+1 %g != %g", underlay->angle, angle); error++;
      }
    underlay->angle--;

  }
  {
    BITCODE_2RD clip_verts;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "clip_verts", &clip_verts, NULL)
        && !memcmp(&clip_verts, &underlay->clip_verts, sizeof(underlay->clip_verts)))
      pass ("UNDERLAY.clip_verts [2RD]");
    else
      {
        fail ("UNDERLAY.clip_verts [2RD]"); error++;
      }
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "contrast", &contrast, NULL) &&
        contrast == underlay->contrast)
      pass ("UNDERLAY.contrast [RC] %u", contrast);
    else
      {
        fail ("UNDERLAY.contrast [RC] %u != %u", underlay->contrast, contrast); error++;
      }
    contrast++;
    if (dwg_dynapi_entity_set_value(underlay, "UNDERLAY", "contrast", &contrast) &&
        contrast == underlay->contrast)
      pass ("UNDERLAY.contrast [RC] set+1 %u", contrast);
    else
      {
        fail ("UNDERLAY.contrast [RC] set+1 %u != %u", underlay->contrast, contrast); error++;
      }
    underlay->contrast--;

  }
  {
    BITCODE_H definition_id;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "definition_id", &definition_id, NULL)
        && !memcmp(&definition_id, &underlay->definition_id, sizeof(underlay->definition_id)))
      pass ("UNDERLAY.definition_id [H]");
    else
      {
        fail ("UNDERLAY.definition_id [H]"); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &underlay->extrusion, sizeof(underlay->extrusion)))
      pass ("UNDERLAY.extrusion [3BD]");
    else
      {
        fail ("UNDERLAY.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "fade", &fade, NULL) &&
        fade == underlay->fade)
      pass ("UNDERLAY.fade [RC] %u", fade);
    else
      {
        fail ("UNDERLAY.fade [RC] %u != %u", underlay->fade, fade); error++;
      }
    fade++;
    if (dwg_dynapi_entity_set_value(underlay, "UNDERLAY", "fade", &fade) &&
        fade == underlay->fade)
      pass ("UNDERLAY.fade [RC] set+1 %u", fade);
    else
      {
        fail ("UNDERLAY.fade [RC] set+1 %u != %u", underlay->fade, fade); error++;
      }
    underlay->fade--;

  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "flag", &flag, NULL) &&
        flag == underlay->flag)
      pass ("UNDERLAY.flag [RC] %u", flag);
    else
      {
        fail ("UNDERLAY.flag [RC] %u != %u", underlay->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(underlay, "UNDERLAY", "flag", &flag) &&
        flag == underlay->flag)
      pass ("UNDERLAY.flag [RC] set+1 %u", flag);
    else
      {
        fail ("UNDERLAY.flag [RC] set+1 %u != %u", underlay->flag, flag); error++;
      }
    underlay->flag--;

  }
  {
    BITCODE_3BD insertion_pt;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &underlay->insertion_pt, sizeof(underlay->insertion_pt)))
      pass ("UNDERLAY.insertion_pt [3BD]");
    else
      {
        fail ("UNDERLAY.insertion_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "num_clip_verts", &num_clip_verts, NULL) &&
        num_clip_verts == underlay->num_clip_verts)
      pass ("UNDERLAY.num_clip_verts [BL] %u", num_clip_verts);
    else
      {
        fail ("UNDERLAY.num_clip_verts [BL] %u != %u", underlay->num_clip_verts, num_clip_verts); error++;
      }
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value(underlay, "UNDERLAY", "num_clip_verts", &num_clip_verts) &&
        num_clip_verts == underlay->num_clip_verts)
      pass ("UNDERLAY.num_clip_verts [BL] set+1 %u", num_clip_verts);
    else
      {
        fail ("UNDERLAY.num_clip_verts [BL] set+1 %u != %u", underlay->num_clip_verts, num_clip_verts); error++;
      }
    underlay->num_clip_verts--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "parent", &parent, NULL)
        && !memcmp(&parent, &underlay->parent, sizeof(underlay->parent)))
      pass ("UNDERLAY.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("UNDERLAY.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "scale", &scale, NULL)
        && !memcmp(&scale, &underlay->scale, sizeof(underlay->scale)))
      pass ("UNDERLAY.scale [3BD]");
    else
      {
        fail ("UNDERLAY.scale [3BD]"); error++;
      }
  }
  {
    BITCODE_H underlay_layer;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "underlay_layer", &underlay_layer, NULL)
        && !memcmp(&underlay_layer, &underlay->underlay_layer, sizeof(underlay->underlay_layer)))
      pass ("UNDERLAY.underlay_layer [H]");
    else
      {
        fail ("UNDERLAY.underlay_layer [H]"); error++;
      }
  }
  return error;
}
static int test_UNKNOWN_ENT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_UNKNOWN_ENT *unknown_ent = obj->tio.entity->tio.UNKNOWN_ENT;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(unknown_ent, "UNKNOWN_ENT", "parent", &parent, NULL)
        && !memcmp(&parent, &unknown_ent->parent, sizeof(unknown_ent->parent)))
      pass ("UNKNOWN_ENT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("UNKNOWN_ENT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  return error;
}
static int test_VERTEX_2D (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_VERTEX_2D *vertex_2d = obj->tio.entity->tio.VERTEX_2D;
  {
    BITCODE_BD bulge;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "bulge", &bulge, NULL) &&
        bulge == vertex_2d->bulge)
      pass ("VERTEX_2D.bulge [BD] %g", bulge);
    else
      {
        fail ("VERTEX_2D.bulge [BD] %g != %g", vertex_2d->bulge, bulge); error++;
      }
    bulge++;
    if (dwg_dynapi_entity_set_value(vertex_2d, "VERTEX_2D", "bulge", &bulge) &&
        bulge == vertex_2d->bulge)
      pass ("VERTEX_2D.bulge [BD] set+1 %g", bulge);
    else
      {
        fail ("VERTEX_2D.bulge [BD] set+1 %g != %g", vertex_2d->bulge, bulge); error++;
      }
    vertex_2d->bulge--;

  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "end_width", &end_width, NULL) &&
        end_width == vertex_2d->end_width)
      pass ("VERTEX_2D.end_width [BD] %g", end_width);
    else
      {
        fail ("VERTEX_2D.end_width [BD] %g != %g", vertex_2d->end_width, end_width); error++;
      }
    end_width++;
    if (dwg_dynapi_entity_set_value(vertex_2d, "VERTEX_2D", "end_width", &end_width) &&
        end_width == vertex_2d->end_width)
      pass ("VERTEX_2D.end_width [BD] set+1 %g", end_width);
    else
      {
        fail ("VERTEX_2D.end_width [BD] set+1 %g != %g", vertex_2d->end_width, end_width); error++;
      }
    vertex_2d->end_width--;

  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "flag", &flag, NULL) &&
        flag == vertex_2d->flag)
      pass ("VERTEX_2D.flag [RC] %u", flag);
    else
      {
        fail ("VERTEX_2D.flag [RC] %u != %u", vertex_2d->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(vertex_2d, "VERTEX_2D", "flag", &flag) &&
        flag == vertex_2d->flag)
      pass ("VERTEX_2D.flag [RC] set+1 %u", flag);
    else
      {
        fail ("VERTEX_2D.flag [RC] set+1 %u != %u", vertex_2d->flag, flag); error++;
      }
    vertex_2d->flag--;

  }
  {
    BITCODE_BL id;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "id", &id, NULL) &&
        id == vertex_2d->id)
      pass ("VERTEX_2D.id [BL] %u", id);
    else
      {
        fail ("VERTEX_2D.id [BL] %u != %u", vertex_2d->id, id); error++;
      }
    id++;
    if (dwg_dynapi_entity_set_value(vertex_2d, "VERTEX_2D", "id", &id) &&
        id == vertex_2d->id)
      pass ("VERTEX_2D.id [BL] set+1 %u", id);
    else
      {
        fail ("VERTEX_2D.id [BL] set+1 %u != %u", vertex_2d->id, id); error++;
      }
    vertex_2d->id--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "parent", &parent, NULL)
        && !memcmp(&parent, &vertex_2d->parent, sizeof(vertex_2d->parent)))
      pass ("VERTEX_2D.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("VERTEX_2D.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "point", &point, NULL)
        && !memcmp(&point, &vertex_2d->point, sizeof(vertex_2d->point)))
      pass ("VERTEX_2D.point [3BD]");
    else
      {
        fail ("VERTEX_2D.point [3BD]"); error++;
      }
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "start_width", &start_width, NULL) &&
        start_width == vertex_2d->start_width)
      pass ("VERTEX_2D.start_width [BD] %g", start_width);
    else
      {
        fail ("VERTEX_2D.start_width [BD] %g != %g", vertex_2d->start_width, start_width); error++;
      }
    start_width++;
    if (dwg_dynapi_entity_set_value(vertex_2d, "VERTEX_2D", "start_width", &start_width) &&
        start_width == vertex_2d->start_width)
      pass ("VERTEX_2D.start_width [BD] set+1 %g", start_width);
    else
      {
        fail ("VERTEX_2D.start_width [BD] set+1 %g != %g", vertex_2d->start_width, start_width); error++;
      }
    vertex_2d->start_width--;

  }
  {
    BITCODE_BD tangent_dir;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "tangent_dir", &tangent_dir, NULL) &&
        tangent_dir == vertex_2d->tangent_dir)
      pass ("VERTEX_2D.tangent_dir [BD] %g", tangent_dir);
    else
      {
        fail ("VERTEX_2D.tangent_dir [BD] %g != %g", vertex_2d->tangent_dir, tangent_dir); error++;
      }
    tangent_dir++;
    if (dwg_dynapi_entity_set_value(vertex_2d, "VERTEX_2D", "tangent_dir", &tangent_dir) &&
        tangent_dir == vertex_2d->tangent_dir)
      pass ("VERTEX_2D.tangent_dir [BD] set+1 %g", tangent_dir);
    else
      {
        fail ("VERTEX_2D.tangent_dir [BD] set+1 %g != %g", vertex_2d->tangent_dir, tangent_dir); error++;
      }
    vertex_2d->tangent_dir--;

  }
  return error;
}
static int test_VERTEX_3D (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_VERTEX_3D *vertex_3d = obj->tio.entity->tio.VERTEX_3D;
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(vertex_3d, "VERTEX_3D", "flag", &flag, NULL) &&
        flag == vertex_3d->flag)
      pass ("VERTEX_3D.flag [RC] %u", flag);
    else
      {
        fail ("VERTEX_3D.flag [RC] %u != %u", vertex_3d->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(vertex_3d, "VERTEX_3D", "flag", &flag) &&
        flag == vertex_3d->flag)
      pass ("VERTEX_3D.flag [RC] set+1 %u", flag);
    else
      {
        fail ("VERTEX_3D.flag [RC] set+1 %u != %u", vertex_3d->flag, flag); error++;
      }
    vertex_3d->flag--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(vertex_3d, "VERTEX_3D", "parent", &parent, NULL)
        && !memcmp(&parent, &vertex_3d->parent, sizeof(vertex_3d->parent)))
      pass ("VERTEX_3D.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("VERTEX_3D.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(vertex_3d, "VERTEX_3D", "point", &point, NULL)
        && !memcmp(&point, &vertex_3d->point, sizeof(vertex_3d->point)))
      pass ("VERTEX_3D.point [3BD]");
    else
      {
        fail ("VERTEX_3D.point [3BD]"); error++;
      }
  }
  return error;
}
static int test_VERTEX_PFACE_FACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_VERTEX_PFACE_FACE *vertex_pface_face = obj->tio.entity->tio.VERTEX_PFACE_FACE;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(vertex_pface_face, "VERTEX_PFACE_FACE", "parent", &parent, NULL)
        && !memcmp(&parent, &vertex_pface_face->parent, sizeof(vertex_pface_face->parent)))
      pass ("VERTEX_PFACE_FACE.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("VERTEX_PFACE_FACE.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_BS vertind[4];
    if (dwg_dynapi_entity_value(vertex_pface_face, "VERTEX_PFACE_FACE", "vertind[4]", &vertind, NULL)
        && !memcmp(&vertind, &vertex_pface_face->vertind, sizeof(vertex_pface_face->vertind)))
      pass ("VERTEX_PFACE_FACE.vertind[4] [BS]");
    else
      {
        fail ("VERTEX_PFACE_FACE.vertind[4] [BS]"); error++;
      }
  }
  return error;
}
static int test_VIEWPORT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_VIEWPORT *viewport = obj->tio.entity->tio.VIEWPORT;
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ambient_color", &ambient_color, NULL)
        && !memcmp(&ambient_color, &viewport->ambient_color, sizeof(viewport->ambient_color)))
      pass ("VIEWPORT.ambient_color [CMC]");
    else
      {
        fail ("VIEWPORT.ambient_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD back_clip_z;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "back_clip_z", &back_clip_z, NULL) &&
        back_clip_z == viewport->back_clip_z)
      pass ("VIEWPORT.back_clip_z [BD] %g", back_clip_z);
    else
      {
        fail ("VIEWPORT.back_clip_z [BD] %g != %g", viewport->back_clip_z, back_clip_z); error++;
      }
    back_clip_z++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "back_clip_z", &back_clip_z) &&
        back_clip_z == viewport->back_clip_z)
      pass ("VIEWPORT.back_clip_z [BD] set+1 %g", back_clip_z);
    else
      {
        fail ("VIEWPORT.back_clip_z [BD] set+1 %g != %g", viewport->back_clip_z, back_clip_z); error++;
      }
    viewport->back_clip_z--;

  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "brightness", &brightness, NULL) &&
        brightness == viewport->brightness)
      pass ("VIEWPORT.brightness [BD] %g", brightness);
    else
      {
        fail ("VIEWPORT.brightness [BD] %g != %g", viewport->brightness, brightness); error++;
      }
    brightness++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "brightness", &brightness) &&
        brightness == viewport->brightness)
      pass ("VIEWPORT.brightness [BD] set+1 %g", brightness);
    else
      {
        fail ("VIEWPORT.brightness [BD] set+1 %g != %g", viewport->brightness, brightness); error++;
      }
    viewport->brightness--;

  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "center", &center, NULL)
        && !memcmp(&center, &viewport->center, sizeof(viewport->center)))
      pass ("VIEWPORT.center [3BD]");
    else
      {
        fail ("VIEWPORT.center [3BD]"); error++;
      }
  }
  {
    BITCODE_BS circle_zoom;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "circle_zoom", &circle_zoom, NULL) &&
        circle_zoom == viewport->circle_zoom)
      pass ("VIEWPORT.circle_zoom [BS] %hu", circle_zoom);
    else
      {
        fail ("VIEWPORT.circle_zoom [BS] %hu != %hu", viewport->circle_zoom, circle_zoom); error++;
      }
    circle_zoom++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "circle_zoom", &circle_zoom) &&
        circle_zoom == viewport->circle_zoom)
      pass ("VIEWPORT.circle_zoom [BS] set+1 %hu", circle_zoom);
    else
      {
        fail ("VIEWPORT.circle_zoom [BS] set+1 %hu != %hu", viewport->circle_zoom, circle_zoom); error++;
      }
    viewport->circle_zoom--;

  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "contrast", &contrast, NULL) &&
        contrast == viewport->contrast)
      pass ("VIEWPORT.contrast [BD] %g", contrast);
    else
      {
        fail ("VIEWPORT.contrast [BD] %g != %g", viewport->contrast, contrast); error++;
      }
    contrast++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "contrast", &contrast) &&
        contrast == viewport->contrast)
      pass ("VIEWPORT.contrast [BD] set+1 %g", contrast);
    else
      {
        fail ("VIEWPORT.contrast [BD] set+1 %g != %g", viewport->contrast, contrast); error++;
      }
    viewport->contrast--;

  }
  {
    BITCODE_RC default_lighting_type;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "default_lighting_type", &default_lighting_type, NULL) &&
        default_lighting_type == viewport->default_lighting_type)
      pass ("VIEWPORT.default_lighting_type [RC] %u", default_lighting_type);
    else
      {
        fail ("VIEWPORT.default_lighting_type [RC] %u != %u", viewport->default_lighting_type, default_lighting_type); error++;
      }
    default_lighting_type++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "default_lighting_type", &default_lighting_type) &&
        default_lighting_type == viewport->default_lighting_type)
      pass ("VIEWPORT.default_lighting_type [RC] set+1 %u", default_lighting_type);
    else
      {
        fail ("VIEWPORT.default_lighting_type [RC] set+1 %u != %u", viewport->default_lighting_type, default_lighting_type); error++;
      }
    viewport->default_lighting_type--;

  }
  {
    BITCODE_BD front_clip_z;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "front_clip_z", &front_clip_z, NULL) &&
        front_clip_z == viewport->front_clip_z)
      pass ("VIEWPORT.front_clip_z [BD] %g", front_clip_z);
    else
      {
        fail ("VIEWPORT.front_clip_z [BD] %g != %g", viewport->front_clip_z, front_clip_z); error++;
      }
    front_clip_z++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "front_clip_z", &front_clip_z) &&
        front_clip_z == viewport->front_clip_z)
      pass ("VIEWPORT.front_clip_z [BD] set+1 %g", front_clip_z);
    else
      {
        fail ("VIEWPORT.front_clip_z [BD] set+1 %g != %g", viewport->front_clip_z, front_clip_z); error++;
      }
    viewport->front_clip_z--;

  }
  {
    BITCODE_BS grid_major;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "grid_major", &grid_major, NULL) &&
        grid_major == viewport->grid_major)
      pass ("VIEWPORT.grid_major [BS] %hu", grid_major);
    else
      {
        fail ("VIEWPORT.grid_major [BS] %hu != %hu", viewport->grid_major, grid_major); error++;
      }
    grid_major++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "grid_major", &grid_major) &&
        grid_major == viewport->grid_major)
      pass ("VIEWPORT.grid_major [BS] set+1 %hu", grid_major);
    else
      {
        fail ("VIEWPORT.grid_major [BS] set+1 %hu != %hu", viewport->grid_major, grid_major); error++;
      }
    viewport->grid_major--;

  }
  {
    BITCODE_2RD grid_spacing;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "grid_spacing", &grid_spacing, NULL)
        && !memcmp(&grid_spacing, &viewport->grid_spacing, sizeof(viewport->grid_spacing)))
      pass ("VIEWPORT.grid_spacing [2RD]");
    else
      {
        fail ("VIEWPORT.grid_spacing [2RD]"); error++;
      }
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "height", &height, NULL) &&
        height == viewport->height)
      pass ("VIEWPORT.height [BD] %g", height);
    else
      {
        fail ("VIEWPORT.height [BD] %g != %g", viewport->height, height); error++;
      }
    height++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "height", &height) &&
        height == viewport->height)
      pass ("VIEWPORT.height [BD] set+1 %g", height);
    else
      {
        fail ("VIEWPORT.height [BD] set+1 %g != %g", viewport->height, height); error++;
      }
    viewport->height--;

  }
  {
    BITCODE_RS id;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "id", &id, NULL) &&
        id == viewport->id)
      pass ("VIEWPORT.id [RS] %hu", id);
    else
      {
        fail ("VIEWPORT.id [RS] %hu != %hu", viewport->id, id); error++;
      }
    id++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "id", &id) &&
        id == viewport->id)
      pass ("VIEWPORT.id [RS] set+1 %hu", id);
    else
      {
        fail ("VIEWPORT.id [RS] set+1 %hu != %hu", viewport->id, id); error++;
      }
    viewport->id--;

  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "lens_length", &lens_length, NULL) &&
        lens_length == viewport->lens_length)
      pass ("VIEWPORT.lens_length [BD] %g", lens_length);
    else
      {
        fail ("VIEWPORT.lens_length [BD] %g != %g", viewport->lens_length, lens_length); error++;
      }
    lens_length++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "lens_length", &lens_length) &&
        lens_length == viewport->lens_length)
      pass ("VIEWPORT.lens_length [BD] set+1 %g", lens_length);
    else
      {
        fail ("VIEWPORT.lens_length [BD] set+1 %g != %g", viewport->lens_length, lens_length); error++;
      }
    viewport->lens_length--;

  }
  {
    BITCODE_BL num_frozen_layers;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "num_frozen_layers", &num_frozen_layers, NULL) &&
        num_frozen_layers == viewport->num_frozen_layers)
      pass ("VIEWPORT.num_frozen_layers [BL] %u", num_frozen_layers);
    else
      {
        fail ("VIEWPORT.num_frozen_layers [BL] %u != %u", viewport->num_frozen_layers, num_frozen_layers); error++;
      }
    num_frozen_layers++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "num_frozen_layers", &num_frozen_layers) &&
        num_frozen_layers == viewport->num_frozen_layers)
      pass ("VIEWPORT.num_frozen_layers [BL] set+1 %u", num_frozen_layers);
    else
      {
        fail ("VIEWPORT.num_frozen_layers [BL] set+1 %u != %u", viewport->num_frozen_layers, num_frozen_layers); error++;
      }
    viewport->num_frozen_layers--;

  }
  {
    BITCODE_RS on_off;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "on_off", &on_off, NULL) &&
        on_off == viewport->on_off)
      pass ("VIEWPORT.on_off [RS] %hu", on_off);
    else
      {
        fail ("VIEWPORT.on_off [RS] %hu != %hu", viewport->on_off, on_off); error++;
      }
    on_off++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "on_off", &on_off) &&
        on_off == viewport->on_off)
      pass ("VIEWPORT.on_off [RS] set+1 %hu", on_off);
    else
      {
        fail ("VIEWPORT.on_off [RS] set+1 %hu != %hu", viewport->on_off, on_off); error++;
      }
    viewport->on_off--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "parent", &parent, NULL)
        && !memcmp(&parent, &viewport->parent, sizeof(viewport->parent)))
      pass ("VIEWPORT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("VIEWPORT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "render_mode", &render_mode, NULL) &&
        render_mode == viewport->render_mode)
      pass ("VIEWPORT.render_mode [RC] %u", render_mode);
    else
      {
        fail ("VIEWPORT.render_mode [RC] %u != %u", viewport->render_mode, render_mode); error++;
      }
    render_mode++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "render_mode", &render_mode) &&
        render_mode == viewport->render_mode)
      pass ("VIEWPORT.render_mode [RC] set+1 %u", render_mode);
    else
      {
        fail ("VIEWPORT.render_mode [RC] set+1 %u != %u", viewport->render_mode, render_mode); error++;
      }
    viewport->render_mode--;

  }
  {
    BITCODE_BS shadeplot_mode;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "shadeplot_mode", &shadeplot_mode, NULL) &&
        shadeplot_mode == viewport->shadeplot_mode)
      pass ("VIEWPORT.shadeplot_mode [BS] %hu", shadeplot_mode);
    else
      {
        fail ("VIEWPORT.shadeplot_mode [BS] %hu != %hu", viewport->shadeplot_mode, shadeplot_mode); error++;
      }
    shadeplot_mode++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "shadeplot_mode", &shadeplot_mode) &&
        shadeplot_mode == viewport->shadeplot_mode)
      pass ("VIEWPORT.shadeplot_mode [BS] set+1 %hu", shadeplot_mode);
    else
      {
        fail ("VIEWPORT.shadeplot_mode [BS] set+1 %hu != %hu", viewport->shadeplot_mode, shadeplot_mode); error++;
      }
    viewport->shadeplot_mode--;

  }
  {
    BITCODE_BD snap_angle;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "snap_angle", &snap_angle, NULL) &&
        snap_angle == viewport->snap_angle)
      pass ("VIEWPORT.snap_angle [BD] %g", snap_angle);
    else
      {
        fail ("VIEWPORT.snap_angle [BD] %g != %g", viewport->snap_angle, snap_angle); error++;
      }
    snap_angle++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "snap_angle", &snap_angle) &&
        snap_angle == viewport->snap_angle)
      pass ("VIEWPORT.snap_angle [BD] set+1 %g", snap_angle);
    else
      {
        fail ("VIEWPORT.snap_angle [BD] set+1 %g != %g", viewport->snap_angle, snap_angle); error++;
      }
    viewport->snap_angle--;

  }
  {
    BITCODE_2RD snap_base;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "snap_base", &snap_base, NULL)
        && !memcmp(&snap_base, &viewport->snap_base, sizeof(viewport->snap_base)))
      pass ("VIEWPORT.snap_base [2RD]");
    else
      {
        fail ("VIEWPORT.snap_base [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD snap_spacing;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "snap_spacing", &snap_spacing, NULL)
        && !memcmp(&snap_spacing, &viewport->snap_spacing, sizeof(viewport->snap_spacing)))
      pass ("VIEWPORT.snap_spacing [2RD]");
    else
      {
        fail ("VIEWPORT.snap_spacing [2RD]"); error++;
      }
  }
  {
    BITCODE_BL status_flag;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "status_flag", &status_flag, NULL) &&
        status_flag == viewport->status_flag)
      pass ("VIEWPORT.status_flag [BL] %u", status_flag);
    else
      {
        fail ("VIEWPORT.status_flag [BL] %u != %u", viewport->status_flag, status_flag); error++;
      }
    status_flag++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "status_flag", &status_flag) &&
        status_flag == viewport->status_flag)
      pass ("VIEWPORT.status_flag [BL] set+1 %u", status_flag);
    else
      {
        fail ("VIEWPORT.status_flag [BL] set+1 %u != %u", viewport->status_flag, status_flag); error++;
      }
    viewport->status_flag--;

  }
  {
    BITCODE_TV style_sheet;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "style_sheet", &style_sheet, NULL)
        && !strcmp((char*)&style_sheet, (char*)&viewport->style_sheet))
      pass ("VIEWPORT.style_sheet [TV]");
    else
      {
        fail ("VIEWPORT.style_sheet [TV]"); error++;
      }
  }
  {
    BITCODE_B ucs_at_origin;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_at_origin", &ucs_at_origin, NULL) &&
        ucs_at_origin == viewport->ucs_at_origin)
      pass ("VIEWPORT.ucs_at_origin [B] " FORMAT_B "", ucs_at_origin);
    else
      {
        fail ("VIEWPORT.ucs_at_origin [B] " FORMAT_B " != " FORMAT_B "", viewport->ucs_at_origin, ucs_at_origin); error++;
      }
    ucs_at_origin++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "ucs_at_origin", &ucs_at_origin) &&
        ucs_at_origin == viewport->ucs_at_origin)
      pass ("VIEWPORT.ucs_at_origin [B] set+1 " FORMAT_B "", ucs_at_origin);
    else
      {
        fail ("VIEWPORT.ucs_at_origin [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->ucs_at_origin, ucs_at_origin); error++;
      }
    viewport->ucs_at_origin--;

  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_elevation", &ucs_elevation, NULL) &&
        ucs_elevation == viewport->ucs_elevation)
      pass ("VIEWPORT.ucs_elevation [BD] %g", ucs_elevation);
    else
      {
        fail ("VIEWPORT.ucs_elevation [BD] %g != %g", viewport->ucs_elevation, ucs_elevation); error++;
      }
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "ucs_elevation", &ucs_elevation) &&
        ucs_elevation == viewport->ucs_elevation)
      pass ("VIEWPORT.ucs_elevation [BD] set+1 %g", ucs_elevation);
    else
      {
        fail ("VIEWPORT.ucs_elevation [BD] set+1 %g != %g", viewport->ucs_elevation, ucs_elevation); error++;
      }
    viewport->ucs_elevation--;

  }
  {
    BITCODE_3BD ucs_origin;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp(&ucs_origin, &viewport->ucs_origin, sizeof(viewport->ucs_origin)))
      pass ("VIEWPORT.ucs_origin [3BD]");
    else
      {
        fail ("VIEWPORT.ucs_origin [3BD]"); error++;
      }
  }
  {
    BITCODE_BS ucs_ortho_view_type;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_ortho_view_type", &ucs_ortho_view_type, NULL) &&
        ucs_ortho_view_type == viewport->ucs_ortho_view_type)
      pass ("VIEWPORT.ucs_ortho_view_type [BS] %hu", ucs_ortho_view_type);
    else
      {
        fail ("VIEWPORT.ucs_ortho_view_type [BS] %hu != %hu", viewport->ucs_ortho_view_type, ucs_ortho_view_type); error++;
      }
    ucs_ortho_view_type++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "ucs_ortho_view_type", &ucs_ortho_view_type) &&
        ucs_ortho_view_type == viewport->ucs_ortho_view_type)
      pass ("VIEWPORT.ucs_ortho_view_type [BS] set+1 %hu", ucs_ortho_view_type);
    else
      {
        fail ("VIEWPORT.ucs_ortho_view_type [BS] set+1 %hu != %hu", viewport->ucs_ortho_view_type, ucs_ortho_view_type); error++;
      }
    viewport->ucs_ortho_view_type--;

  }
  {
    BITCODE_B ucs_per_viewport;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_per_viewport", &ucs_per_viewport, NULL) &&
        ucs_per_viewport == viewport->ucs_per_viewport)
      pass ("VIEWPORT.ucs_per_viewport [B] " FORMAT_B "", ucs_per_viewport);
    else
      {
        fail ("VIEWPORT.ucs_per_viewport [B] " FORMAT_B " != " FORMAT_B "", viewport->ucs_per_viewport, ucs_per_viewport); error++;
      }
    ucs_per_viewport++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "ucs_per_viewport", &ucs_per_viewport) &&
        ucs_per_viewport == viewport->ucs_per_viewport)
      pass ("VIEWPORT.ucs_per_viewport [B] set+1 " FORMAT_B "", ucs_per_viewport);
    else
      {
        fail ("VIEWPORT.ucs_per_viewport [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->ucs_per_viewport, ucs_per_viewport); error++;
      }
    viewport->ucs_per_viewport--;

  }
  {
    BITCODE_3BD ucs_x_axis;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp(&ucs_x_axis, &viewport->ucs_x_axis, sizeof(viewport->ucs_x_axis)))
      pass ("VIEWPORT.ucs_x_axis [3BD]");
    else
      {
        fail ("VIEWPORT.ucs_x_axis [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucs_y_axis;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp(&ucs_y_axis, &viewport->ucs_y_axis, sizeof(viewport->ucs_y_axis)))
      pass ("VIEWPORT.ucs_y_axis [3BD]");
    else
      {
        fail ("VIEWPORT.ucs_y_axis [3BD]"); error++;
      }
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "use_default_lights", &use_default_lights, NULL) &&
        use_default_lights == viewport->use_default_lights)
      pass ("VIEWPORT.use_default_lights [B] " FORMAT_B "", use_default_lights);
    else
      {
        fail ("VIEWPORT.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", viewport->use_default_lights, use_default_lights); error++;
      }
    use_default_lights++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "use_default_lights", &use_default_lights) &&
        use_default_lights == viewport->use_default_lights)
      pass ("VIEWPORT.use_default_lights [B] set+1 " FORMAT_B "", use_default_lights);
    else
      {
        fail ("VIEWPORT.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->use_default_lights, use_default_lights); error++;
      }
    viewport->use_default_lights--;

  }
  {
    BITCODE_2RD view_center;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_center", &view_center, NULL)
        && !memcmp(&view_center, &viewport->view_center, sizeof(viewport->view_center)))
      pass ("VIEWPORT.view_center [2RD]");
    else
      {
        fail ("VIEWPORT.view_center [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD view_direction;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_direction", &view_direction, NULL)
        && !memcmp(&view_direction, &viewport->view_direction, sizeof(viewport->view_direction)))
      pass ("VIEWPORT.view_direction [3BD]");
    else
      {
        fail ("VIEWPORT.view_direction [3BD]"); error++;
      }
  }
  {
    BITCODE_BD view_height;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_height", &view_height, NULL) &&
        view_height == viewport->view_height)
      pass ("VIEWPORT.view_height [BD] %g", view_height);
    else
      {
        fail ("VIEWPORT.view_height [BD] %g != %g", viewport->view_height, view_height); error++;
      }
    view_height++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "view_height", &view_height) &&
        view_height == viewport->view_height)
      pass ("VIEWPORT.view_height [BD] set+1 %g", view_height);
    else
      {
        fail ("VIEWPORT.view_height [BD] set+1 %g != %g", viewport->view_height, view_height); error++;
      }
    viewport->view_height--;

  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_target", &view_target, NULL)
        && !memcmp(&view_target, &viewport->view_target, sizeof(viewport->view_target)))
      pass ("VIEWPORT.view_target [3BD]");
    else
      {
        fail ("VIEWPORT.view_target [3BD]"); error++;
      }
  }
  {
    BITCODE_BD view_twist;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_twist", &view_twist, NULL) &&
        view_twist == viewport->view_twist)
      pass ("VIEWPORT.view_twist [BD] %g", view_twist);
    else
      {
        fail ("VIEWPORT.view_twist [BD] %g != %g", viewport->view_twist, view_twist); error++;
      }
    view_twist++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "view_twist", &view_twist) &&
        view_twist == viewport->view_twist)
      pass ("VIEWPORT.view_twist [BD] set+1 %g", view_twist);
    else
      {
        fail ("VIEWPORT.view_twist [BD] set+1 %g != %g", viewport->view_twist, view_twist); error++;
      }
    viewport->view_twist--;

  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "width", &width, NULL) &&
        width == viewport->width)
      pass ("VIEWPORT.width [BD] %g", width);
    else
      {
        fail ("VIEWPORT.width [BD] %g != %g", viewport->width, width); error++;
      }
    width++;
    if (dwg_dynapi_entity_set_value(viewport, "VIEWPORT", "width", &width) &&
        width == viewport->width)
      pass ("VIEWPORT.width [BD] set+1 %g", width);
    else
      {
        fail ("VIEWPORT.width [BD] set+1 %g != %g", viewport->width, width); error++;
      }
    viewport->width--;

  }
  return error;
}
static int test_WIPEOUT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_WIPEOUT *wipeout = obj->tio.entity->tio.WIPEOUT;
  {
    BITCODE_2RD boundary_pt0;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "boundary_pt0", &boundary_pt0, NULL)
        && !memcmp(&boundary_pt0, &wipeout->boundary_pt0, sizeof(wipeout->boundary_pt0)))
      pass ("WIPEOUT.boundary_pt0 [2RD]");
    else
      {
        fail ("WIPEOUT.boundary_pt0 [2RD]"); error++;
      }
  }
  {
    BITCODE_2RD boundary_pt1;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "boundary_pt1", &boundary_pt1, NULL)
        && !memcmp(&boundary_pt1, &wipeout->boundary_pt1, sizeof(wipeout->boundary_pt1)))
      pass ("WIPEOUT.boundary_pt1 [2RD]");
    else
      {
        fail ("WIPEOUT.boundary_pt1 [2RD]"); error++;
      }
  }
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "brightness", &brightness, NULL) &&
        brightness == wipeout->brightness)
      pass ("WIPEOUT.brightness [RC] %u", brightness);
    else
      {
        fail ("WIPEOUT.brightness [RC] %u != %u", wipeout->brightness, brightness); error++;
      }
    brightness++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "brightness", &brightness) &&
        brightness == wipeout->brightness)
      pass ("WIPEOUT.brightness [RC] set+1 %u", brightness);
    else
      {
        fail ("WIPEOUT.brightness [RC] set+1 %u != %u", wipeout->brightness, brightness); error++;
      }
    wipeout->brightness--;

  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "class_version", &class_version, NULL) &&
        class_version == wipeout->class_version)
      pass ("WIPEOUT.class_version [BL] %u", class_version);
    else
      {
        fail ("WIPEOUT.class_version [BL] %u != %u", wipeout->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "class_version", &class_version) &&
        class_version == wipeout->class_version)
      pass ("WIPEOUT.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("WIPEOUT.class_version [BL] set+1 %u != %u", wipeout->class_version, class_version); error++;
      }
    wipeout->class_version--;

  }
  {
    BITCODE_BS clip_boundary_type;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "clip_boundary_type", &clip_boundary_type, NULL) &&
        clip_boundary_type == wipeout->clip_boundary_type)
      pass ("WIPEOUT.clip_boundary_type [BS] %hu", clip_boundary_type);
    else
      {
        fail ("WIPEOUT.clip_boundary_type [BS] %hu != %hu", wipeout->clip_boundary_type, clip_boundary_type); error++;
      }
    clip_boundary_type++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "clip_boundary_type", &clip_boundary_type) &&
        clip_boundary_type == wipeout->clip_boundary_type)
      pass ("WIPEOUT.clip_boundary_type [BS] set+1 %hu", clip_boundary_type);
    else
      {
        fail ("WIPEOUT.clip_boundary_type [BS] set+1 %hu != %hu", wipeout->clip_boundary_type, clip_boundary_type); error++;
      }
    wipeout->clip_boundary_type--;

  }
  {
    BITCODE_B clip_mode;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "clip_mode", &clip_mode, NULL) &&
        clip_mode == wipeout->clip_mode)
      pass ("WIPEOUT.clip_mode [B] " FORMAT_B "", clip_mode);
    else
      {
        fail ("WIPEOUT.clip_mode [B] " FORMAT_B " != " FORMAT_B "", wipeout->clip_mode, clip_mode); error++;
      }
    clip_mode++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "clip_mode", &clip_mode) &&
        clip_mode == wipeout->clip_mode)
      pass ("WIPEOUT.clip_mode [B] set+1 " FORMAT_B "", clip_mode);
    else
      {
        fail ("WIPEOUT.clip_mode [B] set+1 " FORMAT_B " != " FORMAT_B "", wipeout->clip_mode, clip_mode); error++;
      }
    wipeout->clip_mode--;

  }
  {
    BITCODE_2RD* clip_verts;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "clip_verts", &clip_verts, NULL)
        && !memcmp(&clip_verts, &wipeout->clip_verts, sizeof(wipeout->clip_verts)))
      pass ("WIPEOUT.clip_verts [2RD*]");
    else
      {
        fail ("WIPEOUT.clip_verts [2RD*]"); error++;
      }
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "clipping", &clipping, NULL) &&
        clipping == wipeout->clipping)
      pass ("WIPEOUT.clipping [B] " FORMAT_B "", clipping);
    else
      {
        fail ("WIPEOUT.clipping [B] " FORMAT_B " != " FORMAT_B "", wipeout->clipping, clipping); error++;
      }
    clipping++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "clipping", &clipping) &&
        clipping == wipeout->clipping)
      pass ("WIPEOUT.clipping [B] set+1 " FORMAT_B "", clipping);
    else
      {
        fail ("WIPEOUT.clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", wipeout->clipping, clipping); error++;
      }
    wipeout->clipping--;

  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "contrast", &contrast, NULL) &&
        contrast == wipeout->contrast)
      pass ("WIPEOUT.contrast [RC] %u", contrast);
    else
      {
        fail ("WIPEOUT.contrast [RC] %u != %u", wipeout->contrast, contrast); error++;
      }
    contrast++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "contrast", &contrast) &&
        contrast == wipeout->contrast)
      pass ("WIPEOUT.contrast [RC] set+1 %u", contrast);
    else
      {
        fail ("WIPEOUT.contrast [RC] set+1 %u != %u", wipeout->contrast, contrast); error++;
      }
    wipeout->contrast--;

  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "display_props", &display_props, NULL) &&
        display_props == wipeout->display_props)
      pass ("WIPEOUT.display_props [BS] %hu", display_props);
    else
      {
        fail ("WIPEOUT.display_props [BS] %hu != %hu", wipeout->display_props, display_props); error++;
      }
    display_props++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "display_props", &display_props) &&
        display_props == wipeout->display_props)
      pass ("WIPEOUT.display_props [BS] set+1 %hu", display_props);
    else
      {
        fail ("WIPEOUT.display_props [BS] set+1 %hu != %hu", wipeout->display_props, display_props); error++;
      }
    wipeout->display_props--;

  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "fade", &fade, NULL) &&
        fade == wipeout->fade)
      pass ("WIPEOUT.fade [RC] %u", fade);
    else
      {
        fail ("WIPEOUT.fade [RC] %u != %u", wipeout->fade, fade); error++;
      }
    fade++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "fade", &fade) &&
        fade == wipeout->fade)
      pass ("WIPEOUT.fade [RC] set+1 %u", fade);
    else
      {
        fail ("WIPEOUT.fade [RC] set+1 %u != %u", wipeout->fade, fade); error++;
      }
    wipeout->fade--;

  }
  {
    BITCODE_H imagedef;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "imagedef", &imagedef, NULL)
        && !memcmp(&imagedef, &wipeout->imagedef, sizeof(wipeout->imagedef)))
      pass ("WIPEOUT.imagedef [H]");
    else
      {
        fail ("WIPEOUT.imagedef [H]"); error++;
      }
  }
  {
    BITCODE_H imagedefreactor;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "imagedefreactor", &imagedefreactor, NULL)
        && !memcmp(&imagedefreactor, &wipeout->imagedefreactor, sizeof(wipeout->imagedefreactor)))
      pass ("WIPEOUT.imagedefreactor [H]");
    else
      {
        fail ("WIPEOUT.imagedefreactor [H]"); error++;
      }
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "num_clip_verts", &num_clip_verts, NULL) &&
        num_clip_verts == wipeout->num_clip_verts)
      pass ("WIPEOUT.num_clip_verts [BL] %u", num_clip_verts);
    else
      {
        fail ("WIPEOUT.num_clip_verts [BL] %u != %u", wipeout->num_clip_verts, num_clip_verts); error++;
      }
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value(wipeout, "WIPEOUT", "num_clip_verts", &num_clip_verts) &&
        num_clip_verts == wipeout->num_clip_verts)
      pass ("WIPEOUT.num_clip_verts [BL] set+1 %u", num_clip_verts);
    else
      {
        fail ("WIPEOUT.num_clip_verts [BL] set+1 %u != %u", wipeout->num_clip_verts, num_clip_verts); error++;
      }
    wipeout->num_clip_verts--;

  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "parent", &parent, NULL)
        && !memcmp(&parent, &wipeout->parent, sizeof(wipeout->parent)))
      pass ("WIPEOUT.parent [struct _dwg_object_entity*]");
    else
      {
        fail ("WIPEOUT.parent [struct _dwg_object_entity*]"); error++;
      }
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "pt0", &pt0, NULL)
        && !memcmp(&pt0, &wipeout->pt0, sizeof(wipeout->pt0)))
      pass ("WIPEOUT.pt0 [3BD]");
    else
      {
        fail ("WIPEOUT.pt0 [3BD]"); error++;
      }
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "size", &size, NULL)
        && !memcmp(&size, &wipeout->size, sizeof(wipeout->size)))
      pass ("WIPEOUT.size [2RD]");
    else
      {
        fail ("WIPEOUT.size [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD uvec;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "uvec", &uvec, NULL)
        && !memcmp(&uvec, &wipeout->uvec, sizeof(wipeout->uvec)))
      pass ("WIPEOUT.uvec [3BD]");
    else
      {
        fail ("WIPEOUT.uvec [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD vvec;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "vvec", &vvec, NULL)
        && !memcmp(&vvec, &wipeout->vvec, sizeof(wipeout->vvec)))
      pass ("WIPEOUT.vvec [3BD]");
    else
      {
        fail ("WIPEOUT.vvec [3BD]"); error++;
      }
  }
  return error;
}
static int test_ACDBNAVISWORKSMODELDEF (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ACDBNAVISWORKSMODELDEF *acdbnavisworksmodeldef = obj->tio.object->tio.ACDBNAVISWORKSMODELDEF;
  {
    BITCODE_B host_drawing_visibility;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "host_drawing_visibility", &host_drawing_visibility, NULL) &&
        host_drawing_visibility == acdbnavisworksmodeldef->host_drawing_visibility)
      pass ("ACDBNAVISWORKSMODELDEF.host_drawing_visibility [B] " FORMAT_B "", host_drawing_visibility);
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.host_drawing_visibility [B] " FORMAT_B " != " FORMAT_B "", acdbnavisworksmodeldef->host_drawing_visibility, host_drawing_visibility); error++;
      }
    host_drawing_visibility++;
    if (dwg_dynapi_entity_set_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "host_drawing_visibility", &host_drawing_visibility) &&
        host_drawing_visibility == acdbnavisworksmodeldef->host_drawing_visibility)
      pass ("ACDBNAVISWORKSMODELDEF.host_drawing_visibility [B] set+1 " FORMAT_B "", host_drawing_visibility);
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.host_drawing_visibility [B] set+1 " FORMAT_B " != " FORMAT_B "", acdbnavisworksmodeldef->host_drawing_visibility, host_drawing_visibility); error++;
      }
    acdbnavisworksmodeldef->host_drawing_visibility--;

  }
  {
    BITCODE_3BD max_extent;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "max_extent", &max_extent, NULL)
        && !memcmp(&max_extent, &acdbnavisworksmodeldef->max_extent, sizeof(acdbnavisworksmodeldef->max_extent)))
      pass ("ACDBNAVISWORKSMODELDEF.max_extent [3BD]");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.max_extent [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD min_extent;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "min_extent", &min_extent, NULL)
        && !memcmp(&min_extent, &acdbnavisworksmodeldef->min_extent, sizeof(acdbnavisworksmodeldef->min_extent)))
      pass ("ACDBNAVISWORKSMODELDEF.min_extent [3BD]");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.min_extent [3BD]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &acdbnavisworksmodeldef->ownerhandle, sizeof(acdbnavisworksmodeldef->ownerhandle)))
      pass ("ACDBNAVISWORKSMODELDEF.ownerhandle [H]");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "parent", &parent, NULL)
        && !memcmp(&parent, &acdbnavisworksmodeldef->parent, sizeof(acdbnavisworksmodeldef->parent)))
      pass ("ACDBNAVISWORKSMODELDEF.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_T path;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "path", &path, NULL)
        && !memcmp(&path, &acdbnavisworksmodeldef->path, sizeof(acdbnavisworksmodeldef->path)))
      pass ("ACDBNAVISWORKSMODELDEF.path [T]");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.path [T]"); error++;
      }
  }
  {
    BITCODE_B status;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "status", &status, NULL) &&
        status == acdbnavisworksmodeldef->status)
      pass ("ACDBNAVISWORKSMODELDEF.status [B] " FORMAT_B "", status);
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.status [B] " FORMAT_B " != " FORMAT_B "", acdbnavisworksmodeldef->status, status); error++;
      }
    status++;
    if (dwg_dynapi_entity_set_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "status", &status) &&
        status == acdbnavisworksmodeldef->status)
      pass ("ACDBNAVISWORKSMODELDEF.status [B] set+1 " FORMAT_B "", status);
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.status [B] set+1 " FORMAT_B " != " FORMAT_B "", acdbnavisworksmodeldef->status, status); error++;
      }
    acdbnavisworksmodeldef->status--;

  }
  return error;
}
static int test_ACSH_SWEEP_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ACSH_SWEEP_CLASS *acsh_sweep_class = obj->tio.object->tio.ACSH_SWEEP_CLASS;
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_angle", &align_angle, NULL) &&
        align_angle == acsh_sweep_class->align_angle)
      pass ("ACSH_SWEEP_CLASS.align_angle [BD] %g", align_angle);
    else
      {
        fail ("ACSH_SWEEP_CLASS.align_angle [BD] %g != %g", acsh_sweep_class->align_angle, align_angle); error++;
      }
    align_angle++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_angle", &align_angle) &&
        align_angle == acsh_sweep_class->align_angle)
      pass ("ACSH_SWEEP_CLASS.align_angle [BD] set+1 %g", align_angle);
    else
      {
        fail ("ACSH_SWEEP_CLASS.align_angle [BD] set+1 %g != %g", acsh_sweep_class->align_angle, align_angle); error++;
      }
    acsh_sweep_class->align_angle--;

  }
  {
    BITCODE_RC align_option;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_option", &align_option, NULL) &&
        align_option == acsh_sweep_class->align_option)
      pass ("ACSH_SWEEP_CLASS.align_option [RC] %u", align_option);
    else
      {
        fail ("ACSH_SWEEP_CLASS.align_option [RC] %u != %u", acsh_sweep_class->align_option, align_option); error++;
      }
    align_option++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_option", &align_option) &&
        align_option == acsh_sweep_class->align_option)
      pass ("ACSH_SWEEP_CLASS.align_option [RC] set+1 %u", align_option);
    else
      {
        fail ("ACSH_SWEEP_CLASS.align_option [RC] set+1 %u != %u", acsh_sweep_class->align_option, align_option); error++;
      }
    acsh_sweep_class->align_option--;

  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "bank", &bank, NULL) &&
        bank == acsh_sweep_class->bank)
      pass ("ACSH_SWEEP_CLASS.bank [B] " FORMAT_B "", bank);
    else
      {
        fail ("ACSH_SWEEP_CLASS.bank [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->bank, bank); error++;
      }
    bank++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "bank", &bank) &&
        bank == acsh_sweep_class->bank)
      pass ("ACSH_SWEEP_CLASS.bank [B] set+1 " FORMAT_B "", bank);
    else
      {
        fail ("ACSH_SWEEP_CLASS.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->bank, bank); error++;
      }
    acsh_sweep_class->bank--;

  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "basept", &basept, NULL)
        && !memcmp(&basept, &acsh_sweep_class->basept, sizeof(acsh_sweep_class->basept)))
      pass ("ACSH_SWEEP_CLASS.basept [3BD]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.basept [3BD]"); error++;
      }
  }
  {
    BITCODE_B check_intersections;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "check_intersections", &check_intersections, NULL) &&
        check_intersections == acsh_sweep_class->check_intersections)
      pass ("ACSH_SWEEP_CLASS.check_intersections [B] " FORMAT_B "", check_intersections);
    else
      {
        fail ("ACSH_SWEEP_CLASS.check_intersections [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->check_intersections, check_intersections); error++;
      }
    check_intersections++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "check_intersections", &check_intersections) &&
        check_intersections == acsh_sweep_class->check_intersections)
      pass ("ACSH_SWEEP_CLASS.check_intersections [B] set+1 " FORMAT_B "", check_intersections);
    else
      {
        fail ("ACSH_SWEEP_CLASS.check_intersections [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->check_intersections, check_intersections); error++;
      }
    acsh_sweep_class->check_intersections--;

  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "class_version", &class_version, NULL) &&
        class_version == acsh_sweep_class->class_version)
      pass ("ACSH_SWEEP_CLASS.class_version [BL] %u", class_version);
    else
      {
        fail ("ACSH_SWEEP_CLASS.class_version [BL] %u != %u", acsh_sweep_class->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "class_version", &class_version) &&
        class_version == acsh_sweep_class->class_version)
      pass ("ACSH_SWEEP_CLASS.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("ACSH_SWEEP_CLASS.class_version [BL] set+1 %u != %u", acsh_sweep_class->class_version, class_version); error++;
      }
    acsh_sweep_class->class_version--;

  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "color", &color, NULL)
        && !memcmp(&color, &acsh_sweep_class->color, sizeof(acsh_sweep_class->color)))
      pass ("ACSH_SWEEP_CLASS.color [CMC]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "draft_angle", &draft_angle, NULL) &&
        draft_angle == acsh_sweep_class->draft_angle)
      pass ("ACSH_SWEEP_CLASS.draft_angle [BD] %g", draft_angle);
    else
      {
        fail ("ACSH_SWEEP_CLASS.draft_angle [BD] %g != %g", acsh_sweep_class->draft_angle, draft_angle); error++;
      }
    draft_angle++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "draft_angle", &draft_angle) &&
        draft_angle == acsh_sweep_class->draft_angle)
      pass ("ACSH_SWEEP_CLASS.draft_angle [BD] set+1 %g", draft_angle);
    else
      {
        fail ("ACSH_SWEEP_CLASS.draft_angle [BD] set+1 %g != %g", acsh_sweep_class->draft_angle, draft_angle); error++;
      }
    acsh_sweep_class->draft_angle--;

  }
  {
    BITCODE_BL ee_bl98;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl98", &ee_bl98, NULL) &&
        ee_bl98 == acsh_sweep_class->ee_bl98)
      pass ("ACSH_SWEEP_CLASS.ee_bl98 [BL] %u", ee_bl98);
    else
      {
        fail ("ACSH_SWEEP_CLASS.ee_bl98 [BL] %u != %u", acsh_sweep_class->ee_bl98, ee_bl98); error++;
      }
    ee_bl98++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl98", &ee_bl98) &&
        ee_bl98 == acsh_sweep_class->ee_bl98)
      pass ("ACSH_SWEEP_CLASS.ee_bl98 [BL] set+1 %u", ee_bl98);
    else
      {
        fail ("ACSH_SWEEP_CLASS.ee_bl98 [BL] set+1 %u != %u", acsh_sweep_class->ee_bl98, ee_bl98); error++;
      }
    acsh_sweep_class->ee_bl98--;

  }
  {
    BITCODE_BL ee_bl99;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl99", &ee_bl99, NULL) &&
        ee_bl99 == acsh_sweep_class->ee_bl99)
      pass ("ACSH_SWEEP_CLASS.ee_bl99 [BL] %u", ee_bl99);
    else
      {
        fail ("ACSH_SWEEP_CLASS.ee_bl99 [BL] %u != %u", acsh_sweep_class->ee_bl99, ee_bl99); error++;
      }
    ee_bl99++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl99", &ee_bl99) &&
        ee_bl99 == acsh_sweep_class->ee_bl99)
      pass ("ACSH_SWEEP_CLASS.ee_bl99 [BL] set+1 %u", ee_bl99);
    else
      {
        fail ("ACSH_SWEEP_CLASS.ee_bl99 [BL] set+1 %u != %u", acsh_sweep_class->ee_bl99, ee_bl99); error++;
      }
    acsh_sweep_class->ee_bl99--;

  }
  {
    BITCODE_BD end_draft_dist;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "end_draft_dist", &end_draft_dist, NULL) &&
        end_draft_dist == acsh_sweep_class->end_draft_dist)
      pass ("ACSH_SWEEP_CLASS.end_draft_dist [BD] %g", end_draft_dist);
    else
      {
        fail ("ACSH_SWEEP_CLASS.end_draft_dist [BD] %g != %g", acsh_sweep_class->end_draft_dist, end_draft_dist); error++;
      }
    end_draft_dist++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "end_draft_dist", &end_draft_dist) &&
        end_draft_dist == acsh_sweep_class->end_draft_dist)
      pass ("ACSH_SWEEP_CLASS.end_draft_dist [BD] set+1 %g", end_draft_dist);
    else
      {
        fail ("ACSH_SWEEP_CLASS.end_draft_dist [BD] set+1 %g != %g", acsh_sweep_class->end_draft_dist, end_draft_dist); error++;
      }
    acsh_sweep_class->end_draft_dist--;

  }
  {
    BITCODE_B has_align_start;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "has_align_start", &has_align_start, NULL) &&
        has_align_start == acsh_sweep_class->has_align_start)
      pass ("ACSH_SWEEP_CLASS.has_align_start [B] " FORMAT_B "", has_align_start);
    else
      {
        fail ("ACSH_SWEEP_CLASS.has_align_start [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->has_align_start, has_align_start); error++;
      }
    has_align_start++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "has_align_start", &has_align_start) &&
        has_align_start == acsh_sweep_class->has_align_start)
      pass ("ACSH_SWEEP_CLASS.has_align_start [B] set+1 " FORMAT_B "", has_align_start);
    else
      {
        fail ("ACSH_SWEEP_CLASS.has_align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->has_align_start, has_align_start); error++;
      }
    acsh_sweep_class->has_align_start--;

  }
  {
    BITCODE_RC miter_option;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "miter_option", &miter_option, NULL) &&
        miter_option == acsh_sweep_class->miter_option)
      pass ("ACSH_SWEEP_CLASS.miter_option [RC] %u", miter_option);
    else
      {
        fail ("ACSH_SWEEP_CLASS.miter_option [RC] %u != %u", acsh_sweep_class->miter_option, miter_option); error++;
      }
    miter_option++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "miter_option", &miter_option) &&
        miter_option == acsh_sweep_class->miter_option)
      pass ("ACSH_SWEEP_CLASS.miter_option [RC] set+1 %u", miter_option);
    else
      {
        fail ("ACSH_SWEEP_CLASS.miter_option [RC] set+1 %u != %u", acsh_sweep_class->miter_option, miter_option); error++;
      }
    acsh_sweep_class->miter_option--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "parent", &parent, NULL)
        && !memcmp(&parent, &acsh_sweep_class->parent, sizeof(acsh_sweep_class->parent)))
      pass ("ACSH_SWEEP_CLASS.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BD* pathentity_transform;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "pathentity_transform", &pathentity_transform, NULL)
        && !memcmp(&pathentity_transform, &acsh_sweep_class->pathentity_transform, sizeof(acsh_sweep_class->pathentity_transform)))
      pass ("ACSH_SWEEP_CLASS.pathentity_transform [BD*]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.pathentity_transform [BD*]"); error++;
      }
  }
  {
    BITCODE_3BD pt2;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "pt2", &pt2, NULL)
        && !memcmp(&pt2, &acsh_sweep_class->pt2, sizeof(acsh_sweep_class->pt2)))
      pass ("ACSH_SWEEP_CLASS.pt2 [3BD]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.pt2 [3BD]"); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "scale_factor", &scale_factor, NULL) &&
        scale_factor == acsh_sweep_class->scale_factor)
      pass ("ACSH_SWEEP_CLASS.scale_factor [BD] %g", scale_factor);
    else
      {
        fail ("ACSH_SWEEP_CLASS.scale_factor [BD] %g != %g", acsh_sweep_class->scale_factor, scale_factor); error++;
      }
    scale_factor++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "scale_factor", &scale_factor) &&
        scale_factor == acsh_sweep_class->scale_factor)
      pass ("ACSH_SWEEP_CLASS.scale_factor [BD] set+1 %g", scale_factor);
    else
      {
        fail ("ACSH_SWEEP_CLASS.scale_factor [BD] set+1 %g != %g", acsh_sweep_class->scale_factor, scale_factor); error++;
      }
    acsh_sweep_class->scale_factor--;

  }
  {
    BITCODE_B shhn_b92;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_b92", &shhn_b92, NULL) &&
        shhn_b92 == acsh_sweep_class->shhn_b92)
      pass ("ACSH_SWEEP_CLASS.shhn_b92 [B] " FORMAT_B "", shhn_b92);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_b92 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shhn_b92, shhn_b92); error++;
      }
    shhn_b92++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_b92", &shhn_b92) &&
        shhn_b92 == acsh_sweep_class->shhn_b92)
      pass ("ACSH_SWEEP_CLASS.shhn_b92 [B] set+1 " FORMAT_B "", shhn_b92);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_b92 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shhn_b92, shhn_b92); error++;
      }
    acsh_sweep_class->shhn_b92--;

  }
  {
    BITCODE_BL shhn_bl347;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl347", &shhn_bl347, NULL) &&
        shhn_bl347 == acsh_sweep_class->shhn_bl347)
      pass ("ACSH_SWEEP_CLASS.shhn_bl347 [BL] %u", shhn_bl347);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl347 [BL] %u != %u", acsh_sweep_class->shhn_bl347, shhn_bl347); error++;
      }
    shhn_bl347++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl347", &shhn_bl347) &&
        shhn_bl347 == acsh_sweep_class->shhn_bl347)
      pass ("ACSH_SWEEP_CLASS.shhn_bl347 [BL] set+1 %u", shhn_bl347);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl347 [BL] set+1 %u != %u", acsh_sweep_class->shhn_bl347, shhn_bl347); error++;
      }
    acsh_sweep_class->shhn_bl347--;

  }
  {
    BITCODE_BL shhn_bl98;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl98", &shhn_bl98, NULL) &&
        shhn_bl98 == acsh_sweep_class->shhn_bl98)
      pass ("ACSH_SWEEP_CLASS.shhn_bl98 [BL] %u", shhn_bl98);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl98 [BL] %u != %u", acsh_sweep_class->shhn_bl98, shhn_bl98); error++;
      }
    shhn_bl98++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl98", &shhn_bl98) &&
        shhn_bl98 == acsh_sweep_class->shhn_bl98)
      pass ("ACSH_SWEEP_CLASS.shhn_bl98 [BL] set+1 %u", shhn_bl98);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl98 [BL] set+1 %u != %u", acsh_sweep_class->shhn_bl98, shhn_bl98); error++;
      }
    acsh_sweep_class->shhn_bl98--;

  }
  {
    BITCODE_BL shhn_bl99;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl99", &shhn_bl99, NULL) &&
        shhn_bl99 == acsh_sweep_class->shhn_bl99)
      pass ("ACSH_SWEEP_CLASS.shhn_bl99 [BL] %u", shhn_bl99);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl99 [BL] %u != %u", acsh_sweep_class->shhn_bl99, shhn_bl99); error++;
      }
    shhn_bl99++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl99", &shhn_bl99) &&
        shhn_bl99 == acsh_sweep_class->shhn_bl99)
      pass ("ACSH_SWEEP_CLASS.shhn_bl99 [BL] set+1 %u", shhn_bl99);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl99 [BL] set+1 %u != %u", acsh_sweep_class->shhn_bl99, shhn_bl99); error++;
      }
    acsh_sweep_class->shhn_bl99--;

  }
  {
    BITCODE_BD* shhn_pts;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_pts", &shhn_pts, NULL)
        && !memcmp(&shhn_pts, &acsh_sweep_class->shhn_pts, sizeof(acsh_sweep_class->shhn_pts)))
      pass ("ACSH_SWEEP_CLASS.shhn_pts [BD*]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_pts [BD*]"); error++;
      }
  }
  {
    BITCODE_B shsw_b294;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b294", &shsw_b294, NULL) &&
        shsw_b294 == acsh_sweep_class->shsw_b294)
      pass ("ACSH_SWEEP_CLASS.shsw_b294 [B] " FORMAT_B "", shsw_b294);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b294 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b294, shsw_b294); error++;
      }
    shsw_b294++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b294", &shsw_b294) &&
        shsw_b294 == acsh_sweep_class->shsw_b294)
      pass ("ACSH_SWEEP_CLASS.shsw_b294 [B] set+1 " FORMAT_B "", shsw_b294);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b294 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b294, shsw_b294); error++;
      }
    acsh_sweep_class->shsw_b294--;

  }
  {
    BITCODE_B shsw_b295;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b295", &shsw_b295, NULL) &&
        shsw_b295 == acsh_sweep_class->shsw_b295)
      pass ("ACSH_SWEEP_CLASS.shsw_b295 [B] " FORMAT_B "", shsw_b295);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b295 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b295, shsw_b295); error++;
      }
    shsw_b295++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b295", &shsw_b295) &&
        shsw_b295 == acsh_sweep_class->shsw_b295)
      pass ("ACSH_SWEEP_CLASS.shsw_b295 [B] set+1 " FORMAT_B "", shsw_b295);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b295 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b295, shsw_b295); error++;
      }
    acsh_sweep_class->shsw_b295--;

  }
  {
    BITCODE_B shsw_b296;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b296", &shsw_b296, NULL) &&
        shsw_b296 == acsh_sweep_class->shsw_b296)
      pass ("ACSH_SWEEP_CLASS.shsw_b296 [B] " FORMAT_B "", shsw_b296);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b296 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b296, shsw_b296); error++;
      }
    shsw_b296++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b296", &shsw_b296) &&
        shsw_b296 == acsh_sweep_class->shsw_b296)
      pass ("ACSH_SWEEP_CLASS.shsw_b296 [B] set+1 " FORMAT_B "", shsw_b296);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b296 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b296, shsw_b296); error++;
      }
    acsh_sweep_class->shsw_b296--;

  }
  {
    BITCODE_BL shsw_bl90;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl90", &shsw_bl90, NULL) &&
        shsw_bl90 == acsh_sweep_class->shsw_bl90)
      pass ("ACSH_SWEEP_CLASS.shsw_bl90 [BL] %u", shsw_bl90);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl90 [BL] %u != %u", acsh_sweep_class->shsw_bl90, shsw_bl90); error++;
      }
    shsw_bl90++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl90", &shsw_bl90) &&
        shsw_bl90 == acsh_sweep_class->shsw_bl90)
      pass ("ACSH_SWEEP_CLASS.shsw_bl90 [BL] set+1 %u", shsw_bl90);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl90 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl90, shsw_bl90); error++;
      }
    acsh_sweep_class->shsw_bl90--;

  }
  {
    BITCODE_BL shsw_bl91;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl91", &shsw_bl91, NULL) &&
        shsw_bl91 == acsh_sweep_class->shsw_bl91)
      pass ("ACSH_SWEEP_CLASS.shsw_bl91 [BL] %u", shsw_bl91);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl91 [BL] %u != %u", acsh_sweep_class->shsw_bl91, shsw_bl91); error++;
      }
    shsw_bl91++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl91", &shsw_bl91) &&
        shsw_bl91 == acsh_sweep_class->shsw_bl91)
      pass ("ACSH_SWEEP_CLASS.shsw_bl91 [BL] set+1 %u", shsw_bl91);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl91 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl91, shsw_bl91); error++;
      }
    acsh_sweep_class->shsw_bl91--;

  }
  {
    BITCODE_BL shsw_bl92;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl92", &shsw_bl92, NULL) &&
        shsw_bl92 == acsh_sweep_class->shsw_bl92)
      pass ("ACSH_SWEEP_CLASS.shsw_bl92 [BL] %u", shsw_bl92);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl92 [BL] %u != %u", acsh_sweep_class->shsw_bl92, shsw_bl92); error++;
      }
    shsw_bl92++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl92", &shsw_bl92) &&
        shsw_bl92 == acsh_sweep_class->shsw_bl92)
      pass ("ACSH_SWEEP_CLASS.shsw_bl92 [BL] set+1 %u", shsw_bl92);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl92 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl92, shsw_bl92); error++;
      }
    acsh_sweep_class->shsw_bl92--;

  }
  {
    BITCODE_BL shsw_bl93;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl93", &shsw_bl93, NULL) &&
        shsw_bl93 == acsh_sweep_class->shsw_bl93)
      pass ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] %u", shsw_bl93);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] %u != %u", acsh_sweep_class->shsw_bl93, shsw_bl93); error++;
      }
    shsw_bl93++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl93", &shsw_bl93) &&
        shsw_bl93 == acsh_sweep_class->shsw_bl93)
      pass ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] set+1 %u", shsw_bl93);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl93, shsw_bl93); error++;
      }
    acsh_sweep_class->shsw_bl93--;

  }
  {
    BITCODE_BL shsw_size_text;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_size_text", &shsw_size_text, NULL) &&
        shsw_size_text == acsh_sweep_class->shsw_size_text)
      pass ("ACSH_SWEEP_CLASS.shsw_size_text [BL] %u", shsw_size_text);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_size_text [BL] %u != %u", acsh_sweep_class->shsw_size_text, shsw_size_text); error++;
      }
    shsw_size_text++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_size_text", &shsw_size_text) &&
        shsw_size_text == acsh_sweep_class->shsw_size_text)
      pass ("ACSH_SWEEP_CLASS.shsw_size_text [BL] set+1 %u", shsw_size_text);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_size_text [BL] set+1 %u != %u", acsh_sweep_class->shsw_size_text, shsw_size_text); error++;
      }
    acsh_sweep_class->shsw_size_text--;

  }
  {
    BITCODE_BL shsw_size_text2;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_size_text2", &shsw_size_text2, NULL) &&
        shsw_size_text2 == acsh_sweep_class->shsw_size_text2)
      pass ("ACSH_SWEEP_CLASS.shsw_size_text2 [BL] %u", shsw_size_text2);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_size_text2 [BL] %u != %u", acsh_sweep_class->shsw_size_text2, shsw_size_text2); error++;
      }
    shsw_size_text2++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_size_text2", &shsw_size_text2) &&
        shsw_size_text2 == acsh_sweep_class->shsw_size_text2)
      pass ("ACSH_SWEEP_CLASS.shsw_size_text2 [BL] set+1 %u", shsw_size_text2);
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_size_text2 [BL] set+1 %u != %u", acsh_sweep_class->shsw_size_text2, shsw_size_text2); error++;
      }
    acsh_sweep_class->shsw_size_text2--;

  }
  {
    BITCODE_TF shsw_text;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text", &shsw_text, NULL)
        && !memcmp(&shsw_text, &acsh_sweep_class->shsw_text, sizeof(acsh_sweep_class->shsw_text)))
      pass ("ACSH_SWEEP_CLASS.shsw_text [TF]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_text [TF]"); error++;
      }
  }
  {
    BITCODE_TF shsw_text2;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text2", &shsw_text2, NULL)
        && !memcmp(&shsw_text2, &acsh_sweep_class->shsw_text2, sizeof(acsh_sweep_class->shsw_text2)))
      pass ("ACSH_SWEEP_CLASS.shsw_text2 [TF]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_text2 [TF]"); error++;
      }
  }
  {
    BITCODE_BD start_draft_dist;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "start_draft_dist", &start_draft_dist, NULL) &&
        start_draft_dist == acsh_sweep_class->start_draft_dist)
      pass ("ACSH_SWEEP_CLASS.start_draft_dist [BD] %g", start_draft_dist);
    else
      {
        fail ("ACSH_SWEEP_CLASS.start_draft_dist [BD] %g != %g", acsh_sweep_class->start_draft_dist, start_draft_dist); error++;
      }
    start_draft_dist++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "start_draft_dist", &start_draft_dist) &&
        start_draft_dist == acsh_sweep_class->start_draft_dist)
      pass ("ACSH_SWEEP_CLASS.start_draft_dist [BD] set+1 %g", start_draft_dist);
    else
      {
        fail ("ACSH_SWEEP_CLASS.start_draft_dist [BD] set+1 %g != %g", acsh_sweep_class->start_draft_dist, start_draft_dist); error++;
      }
    acsh_sweep_class->start_draft_dist--;

  }
  {
    BITCODE_BD* sweepentity_transform;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "sweepentity_transform", &sweepentity_transform, NULL)
        && !memcmp(&sweepentity_transform, &acsh_sweep_class->sweepentity_transform, sizeof(acsh_sweep_class->sweepentity_transform)))
      pass ("ACSH_SWEEP_CLASS.sweepentity_transform [BD*]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.sweepentity_transform [BD*]"); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "twist_angle", &twist_angle, NULL) &&
        twist_angle == acsh_sweep_class->twist_angle)
      pass ("ACSH_SWEEP_CLASS.twist_angle [BD] %g", twist_angle);
    else
      {
        fail ("ACSH_SWEEP_CLASS.twist_angle [BD] %g != %g", acsh_sweep_class->twist_angle, twist_angle); error++;
      }
    twist_angle++;
    if (dwg_dynapi_entity_set_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "twist_angle", &twist_angle) &&
        twist_angle == acsh_sweep_class->twist_angle)
      pass ("ACSH_SWEEP_CLASS.twist_angle [BD] set+1 %g", twist_angle);
    else
      {
        fail ("ACSH_SWEEP_CLASS.twist_angle [BD] set+1 %g != %g", acsh_sweep_class->twist_angle, twist_angle); error++;
      }
    acsh_sweep_class->twist_angle--;

  }
  return error;
}
static int test_APPID (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_APPID *appid = obj->tio.object->tio.APPID;
  {
    BITCODE_H app_control;
    if (dwg_dynapi_entity_value(appid, "APPID", "app_control", &app_control, NULL)
        && !memcmp(&app_control, &appid->app_control, sizeof(appid->app_control)))
      pass ("APPID.app_control [H]");
    else
      {
        fail ("APPID.app_control [H]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(appid, "APPID", "flag", &flag, NULL) &&
        flag == appid->flag)
      pass ("APPID.flag [RC] %u", flag);
    else
      {
        fail ("APPID.flag [RC] %u != %u", appid->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(appid, "APPID", "flag", &flag) &&
        flag == appid->flag)
      pass ("APPID.flag [RC] set+1 %u", flag);
    else
      {
        fail ("APPID.flag [RC] set+1 %u != %u", appid->flag, flag); error++;
      }
    appid->flag--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(appid, "APPID", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&appid->name))
      pass ("APPID.name [TV]");
    else
      {
        fail ("APPID.name [TV]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(appid, "APPID", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &appid->null_handle, sizeof(appid->null_handle)))
      pass ("APPID.null_handle [H]");
    else
      {
        fail ("APPID.null_handle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(appid, "APPID", "parent", &parent, NULL)
        && !memcmp(&parent, &appid->parent, sizeof(appid->parent)))
      pass ("APPID.parent [struct _dwg_object_object*]");
    else
      {
        fail ("APPID.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(appid, "APPID", "unknown", &unknown, NULL) &&
        unknown == appid->unknown)
      pass ("APPID.unknown [RC] %u", unknown);
    else
      {
        fail ("APPID.unknown [RC] %u != %u", appid->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(appid, "APPID", "unknown", &unknown) &&
        unknown == appid->unknown)
      pass ("APPID.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("APPID.unknown [RC] set+1 %u != %u", appid->unknown, unknown); error++;
      }
    appid->unknown--;

  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(appid, "APPID", "used", &used, NULL) &&
        used == appid->used)
      pass ("APPID.used [RS] %hu", used);
    else
      {
        fail ("APPID.used [RS] %hu != %hu", appid->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(appid, "APPID", "used", &used) &&
        used == appid->used)
      pass ("APPID.used [RS] set+1 %hu", used);
    else
      {
        fail ("APPID.used [RS] set+1 %hu != %hu", appid->used, used); error++;
      }
    appid->used--;

  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(appid, "APPID", "xrefdep", &xrefdep, NULL) &&
        xrefdep == appid->xrefdep)
      pass ("APPID.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("APPID.xrefdep [B] " FORMAT_B " != " FORMAT_B "", appid->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(appid, "APPID", "xrefdep", &xrefdep) &&
        xrefdep == appid->xrefdep)
      pass ("APPID.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("APPID.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", appid->xrefdep, xrefdep); error++;
      }
    appid->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(appid, "APPID", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == appid->xrefindex_plus1)
      pass ("APPID.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("APPID.xrefindex_plus1 [BS] %hu != %hu", appid->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(appid, "APPID", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == appid->xrefindex_plus1)
      pass ("APPID.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("APPID.xrefindex_plus1 [BS] set+1 %hu != %hu", appid->xrefindex_plus1, xrefindex_plus1); error++;
      }
    appid->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(appid, "APPID", "xrefref", &xrefref, NULL) &&
        xrefref == appid->xrefref)
      pass ("APPID.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("APPID.xrefref [B] " FORMAT_B " != " FORMAT_B "", appid->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(appid, "APPID", "xrefref", &xrefref) &&
        xrefref == appid->xrefref)
      pass ("APPID.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("APPID.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", appid->xrefref, xrefref); error++;
      }
    appid->xrefref--;

  }
  return error;
}
static int test_APPID_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_APPID_CONTROL *appid_control = obj->tio.object->tio.APPID_CONTROL;
  {
    BITCODE_H apps;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "apps", &apps, NULL)
        && !memcmp(&apps, &appid_control->apps, sizeof(appid_control->apps)))
      pass ("APPID_CONTROL.apps [H]");
    else
      {
        fail ("APPID_CONTROL.apps [H]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &appid_control->null_handle, sizeof(appid_control->null_handle)))
      pass ("APPID_CONTROL.null_handle [H]");
    else
      {
        fail ("APPID_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == appid_control->num_entries)
      pass ("APPID_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("APPID_CONTROL.num_entries [BS] %hu != %hu", appid_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(appid_control, "APPID_CONTROL", "num_entries", &num_entries) &&
        num_entries == appid_control->num_entries)
      pass ("APPID_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("APPID_CONTROL.num_entries [BS] set+1 %hu != %hu", appid_control->num_entries, num_entries); error++;
      }
    appid_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "objid", &objid, NULL) &&
        objid == appid_control->objid)
      pass ("APPID_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("APPID_CONTROL.objid [BL] %u != %u", appid_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(appid_control, "APPID_CONTROL", "objid", &objid) &&
        objid == appid_control->objid)
      pass ("APPID_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("APPID_CONTROL.objid [BL] set+1 %u != %u", appid_control->objid, objid); error++;
      }
    appid_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &appid_control->parent, sizeof(appid_control->parent)))
      pass ("APPID_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("APPID_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &appid_control->reactors, sizeof(appid_control->reactors)))
      pass ("APPID_CONTROL.reactors [H]");
    else
      {
        fail ("APPID_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &appid_control->xdicobjhandle, sizeof(appid_control->xdicobjhandle)))
      pass ("APPID_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("APPID_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_ASSOC2DCONSTRAINTGROUP (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOC2DCONSTRAINTGROUP *assoc2dconstraintgroup = obj->tio.object->tio.ASSOC2DCONSTRAINTGROUP;
  {
    BITCODE_B b1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1, NULL) &&
        b1 == assoc2dconstraintgroup->b1)
      pass ("ASSOC2DCONSTRAINTGROUP.b1 [B] " FORMAT_B "", b1);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1); error++;
      }
    b1++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1) &&
        b1 == assoc2dconstraintgroup->b1)
      pass ("ASSOC2DCONSTRAINTGROUP.b1 [B] set+1 " FORMAT_B "", b1);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1); error++;
      }
    assoc2dconstraintgroup->b1--;

  }
  {
    BITCODE_3BD c1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c1", &c1, NULL)
        && !memcmp(&c1, &assoc2dconstraintgroup->c1, sizeof(assoc2dconstraintgroup->c1)))
      pass ("ASSOC2DCONSTRAINTGROUP.c1 [3BD]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.c1 [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD c2;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c2", &c2, NULL)
        && !memcmp(&c2, &assoc2dconstraintgroup->c2, sizeof(assoc2dconstraintgroup->c2)))
      pass ("ASSOC2DCONSTRAINTGROUP.c2 [3BD]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.c2 [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD c3;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c3", &c3, NULL)
        && !memcmp(&c3, &assoc2dconstraintgroup->c3, sizeof(assoc2dconstraintgroup->c3)))
      pass ("ASSOC2DCONSTRAINTGROUP.c3 [3BD]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.c3 [3BD]"); error++;
      }
  }
  {
    BITCODE_BL cl1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl1", &cl1, NULL) &&
        cl1 == assoc2dconstraintgroup->cl1)
      pass ("ASSOC2DCONSTRAINTGROUP.cl1 [BL] %u", cl1);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl1 [BL] %u != %u", assoc2dconstraintgroup->cl1, cl1); error++;
      }
    cl1++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl1", &cl1) &&
        cl1 == assoc2dconstraintgroup->cl1)
      pass ("ASSOC2DCONSTRAINTGROUP.cl1 [BL] set+1 %u", cl1);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl1 [BL] set+1 %u != %u", assoc2dconstraintgroup->cl1, cl1); error++;
      }
    assoc2dconstraintgroup->cl1--;

  }
  {
    BITCODE_BL cl2;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl2", &cl2, NULL) &&
        cl2 == assoc2dconstraintgroup->cl2)
      pass ("ASSOC2DCONSTRAINTGROUP.cl2 [BL] %u", cl2);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl2 [BL] %u != %u", assoc2dconstraintgroup->cl2, cl2); error++;
      }
    cl2++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl2", &cl2) &&
        cl2 == assoc2dconstraintgroup->cl2)
      pass ("ASSOC2DCONSTRAINTGROUP.cl2 [BL] set+1 %u", cl2);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl2 [BL] set+1 %u != %u", assoc2dconstraintgroup->cl2, cl2); error++;
      }
    assoc2dconstraintgroup->cl2--;

  }
  {
    BITCODE_BL cl3;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl3", &cl3, NULL) &&
        cl3 == assoc2dconstraintgroup->cl3)
      pass ("ASSOC2DCONSTRAINTGROUP.cl3 [BL] %u", cl3);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl3 [BL] %u != %u", assoc2dconstraintgroup->cl3, cl3); error++;
      }
    cl3++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl3", &cl3) &&
        cl3 == assoc2dconstraintgroup->cl3)
      pass ("ASSOC2DCONSTRAINTGROUP.cl3 [BL] set+1 %u", cl3);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl3 [BL] set+1 %u != %u", assoc2dconstraintgroup->cl3, cl3); error++;
      }
    assoc2dconstraintgroup->cl3--;

  }
  {
    BITCODE_BL cl4;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl4", &cl4, NULL) &&
        cl4 == assoc2dconstraintgroup->cl4)
      pass ("ASSOC2DCONSTRAINTGROUP.cl4 [BL] %u", cl4);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl4 [BL] %u != %u", assoc2dconstraintgroup->cl4, cl4); error++;
      }
    cl4++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl4", &cl4) &&
        cl4 == assoc2dconstraintgroup->cl4)
      pass ("ASSOC2DCONSTRAINTGROUP.cl4 [BL] set+1 %u", cl4);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl4 [BL] set+1 %u != %u", assoc2dconstraintgroup->cl4, cl4); error++;
      }
    assoc2dconstraintgroup->cl4--;

  }
  {
    BITCODE_BL constraint_status;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "constraint_status", &constraint_status, NULL) &&
        constraint_status == assoc2dconstraintgroup->constraint_status)
      pass ("ASSOC2DCONSTRAINTGROUP.constraint_status [BL] %u", constraint_status);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.constraint_status [BL] %u != %u", assoc2dconstraintgroup->constraint_status, constraint_status); error++;
      }
    constraint_status++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "constraint_status", &constraint_status) &&
        constraint_status == assoc2dconstraintgroup->constraint_status)
      pass ("ASSOC2DCONSTRAINTGROUP.constraint_status [BL] set+1 %u", constraint_status);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.constraint_status [BL] set+1 %u != %u", assoc2dconstraintgroup->constraint_status, constraint_status); error++;
      }
    assoc2dconstraintgroup->constraint_status--;

  }
  {
    BITCODE_RC cs1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cs1", &cs1, NULL) &&
        cs1 == assoc2dconstraintgroup->cs1)
      pass ("ASSOC2DCONSTRAINTGROUP.cs1 [RC] %u", cs1);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cs1 [RC] %u != %u", assoc2dconstraintgroup->cs1, cs1); error++;
      }
    cs1++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cs1", &cs1) &&
        cs1 == assoc2dconstraintgroup->cs1)
      pass ("ASSOC2DCONSTRAINTGROUP.cs1 [RC] set+1 %u", cs1);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cs1 [RC] set+1 %u != %u", assoc2dconstraintgroup->cs1, cs1); error++;
      }
    assoc2dconstraintgroup->cs1--;

  }
  {
    BITCODE_BL dof;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "dof", &dof, NULL) &&
        dof == assoc2dconstraintgroup->dof)
      pass ("ASSOC2DCONSTRAINTGROUP.dof [BL] %u", dof);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.dof [BL] %u != %u", assoc2dconstraintgroup->dof, dof); error++;
      }
    dof++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "dof", &dof) &&
        dof == assoc2dconstraintgroup->dof)
      pass ("ASSOC2DCONSTRAINTGROUP.dof [BL] set+1 %u", dof);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.dof [BL] set+1 %u != %u", assoc2dconstraintgroup->dof, dof); error++;
      }
    assoc2dconstraintgroup->dof--;

  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status, NULL) &&
        geometry_status == assoc2dconstraintgroup->geometry_status)
      pass ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] %u", geometry_status);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status); error++;
      }
    geometry_status++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status) &&
        geometry_status == assoc2dconstraintgroup->geometry_status)
      pass ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] set+1 %u", geometry_status);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] set+1 %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status); error++;
      }
    assoc2dconstraintgroup->geometry_status--;

  }
  {
    BITCODE_BL l4;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l4", &l4, NULL) &&
        l4 == assoc2dconstraintgroup->l4)
      pass ("ASSOC2DCONSTRAINTGROUP.l4 [BL] %u", l4);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l4 [BL] %u != %u", assoc2dconstraintgroup->l4, l4); error++;
      }
    l4++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l4", &l4) &&
        l4 == assoc2dconstraintgroup->l4)
      pass ("ASSOC2DCONSTRAINTGROUP.l4 [BL] set+1 %u", l4);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l4 [BL] set+1 %u != %u", assoc2dconstraintgroup->l4, l4); error++;
      }
    assoc2dconstraintgroup->l4--;

  }
  {
    BITCODE_BL l5;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l5", &l5, NULL) &&
        l5 == assoc2dconstraintgroup->l5)
      pass ("ASSOC2DCONSTRAINTGROUP.l5 [BL] %u", l5);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l5 [BL] %u != %u", assoc2dconstraintgroup->l5, l5); error++;
      }
    l5++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l5", &l5) &&
        l5 == assoc2dconstraintgroup->l5)
      pass ("ASSOC2DCONSTRAINTGROUP.l5 [BL] set+1 %u", l5);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l5 [BL] set+1 %u != %u", assoc2dconstraintgroup->l5, l5); error++;
      }
    assoc2dconstraintgroup->l5--;

  }
  {
    BITCODE_BL l6;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l6", &l6, NULL) &&
        l6 == assoc2dconstraintgroup->l6)
      pass ("ASSOC2DCONSTRAINTGROUP.l6 [BL] %u", l6);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l6 [BL] %u != %u", assoc2dconstraintgroup->l6, l6); error++;
      }
    l6++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l6", &l6) &&
        l6 == assoc2dconstraintgroup->l6)
      pass ("ASSOC2DCONSTRAINTGROUP.l6 [BL] set+1 %u", l6);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l6 [BL] set+1 %u != %u", assoc2dconstraintgroup->l6, l6); error++;
      }
    assoc2dconstraintgroup->l6--;

  }
  {
    BITCODE_BL l7;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l7", &l7, NULL) &&
        l7 == assoc2dconstraintgroup->l7)
      pass ("ASSOC2DCONSTRAINTGROUP.l7 [BL] %u", l7);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l7 [BL] %u != %u", assoc2dconstraintgroup->l7, l7); error++;
      }
    l7++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l7", &l7) &&
        l7 == assoc2dconstraintgroup->l7)
      pass ("ASSOC2DCONSTRAINTGROUP.l7 [BL] set+1 %u", l7);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l7 [BL] set+1 %u != %u", assoc2dconstraintgroup->l7, l7); error++;
      }
    assoc2dconstraintgroup->l7--;

  }
  {
    BITCODE_BL l8;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l8", &l8, NULL) &&
        l8 == assoc2dconstraintgroup->l8)
      pass ("ASSOC2DCONSTRAINTGROUP.l8 [BL] %u", l8);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l8 [BL] %u != %u", assoc2dconstraintgroup->l8, l8); error++;
      }
    l8++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l8", &l8) &&
        l8 == assoc2dconstraintgroup->l8)
      pass ("ASSOC2DCONSTRAINTGROUP.l8 [BL] set+1 %u", l8);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l8 [BL] set+1 %u != %u", assoc2dconstraintgroup->l8, l8); error++;
      }
    assoc2dconstraintgroup->l8--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "parent", &parent, NULL)
        && !memcmp(&parent, &assoc2dconstraintgroup->parent, sizeof(assoc2dconstraintgroup->parent)))
      pass ("ASSOC2DCONSTRAINTGROUP.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BL solution_status;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "solution_status", &solution_status, NULL) &&
        solution_status == assoc2dconstraintgroup->solution_status)
      pass ("ASSOC2DCONSTRAINTGROUP.solution_status [BL] %u", solution_status);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.solution_status [BL] %u != %u", assoc2dconstraintgroup->solution_status, solution_status); error++;
      }
    solution_status++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "solution_status", &solution_status) &&
        solution_status == assoc2dconstraintgroup->solution_status)
      pass ("ASSOC2DCONSTRAINTGROUP.solution_status [BL] set+1 %u", solution_status);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.solution_status [BL] set+1 %u != %u", assoc2dconstraintgroup->solution_status, solution_status); error++;
      }
    assoc2dconstraintgroup->solution_status--;

  }
  {
    BITCODE_BD w1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w1", &w1, NULL) &&
        w1 == assoc2dconstraintgroup->w1)
      pass ("ASSOC2DCONSTRAINTGROUP.w1 [BD] %g", w1);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w1 [BD] %g != %g", assoc2dconstraintgroup->w1, w1); error++;
      }
    w1++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w1", &w1) &&
        w1 == assoc2dconstraintgroup->w1)
      pass ("ASSOC2DCONSTRAINTGROUP.w1 [BD] set+1 %g", w1);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w1 [BD] set+1 %g != %g", assoc2dconstraintgroup->w1, w1); error++;
      }
    assoc2dconstraintgroup->w1--;

  }
  {
    BITCODE_BD w2;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w2", &w2, NULL) &&
        w2 == assoc2dconstraintgroup->w2)
      pass ("ASSOC2DCONSTRAINTGROUP.w2 [BD] %g", w2);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w2 [BD] %g != %g", assoc2dconstraintgroup->w2, w2); error++;
      }
    w2++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w2", &w2) &&
        w2 == assoc2dconstraintgroup->w2)
      pass ("ASSOC2DCONSTRAINTGROUP.w2 [BD] set+1 %g", w2);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w2 [BD] set+1 %g != %g", assoc2dconstraintgroup->w2, w2); error++;
      }
    assoc2dconstraintgroup->w2--;

  }
  {
    BITCODE_BD w3;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w3", &w3, NULL) &&
        w3 == assoc2dconstraintgroup->w3)
      pass ("ASSOC2DCONSTRAINTGROUP.w3 [BD] %g", w3);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w3 [BD] %g != %g", assoc2dconstraintgroup->w3, w3); error++;
      }
    w3++;
    if (dwg_dynapi_entity_set_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w3", &w3) &&
        w3 == assoc2dconstraintgroup->w3)
      pass ("ASSOC2DCONSTRAINTGROUP.w3 [BD] set+1 %g", w3);
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w3 [BD] set+1 %g != %g", assoc2dconstraintgroup->w3, w3); error++;
      }
    assoc2dconstraintgroup->w3--;

  }
  {
    BITCODE_3BD workplane[3];
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "workplane[3]", &workplane, NULL)
        && !memcmp(&workplane, &assoc2dconstraintgroup->workplane, sizeof(assoc2dconstraintgroup->workplane)))
      pass ("ASSOC2DCONSTRAINTGROUP.workplane[3] [3BD]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.workplane[3] [3BD]"); error++;
      }
  }
  return error;
}
static int test_ASSOCACTION (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCACTION *assocaction = obj->tio.object->tio.ASSOCACTION;
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "actionbody", &actionbody, NULL)
        && !memcmp(&actionbody, &assocaction->actionbody, sizeof(assocaction->actionbody)))
      pass ("ASSOCACTION.actionbody [H]");
    else
      {
        fail ("ASSOCACTION.actionbody [H]"); error++;
      }
  }
  {
    Dwg_ACTIONBODY body;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "body", &body, NULL)
        && !memcmp(&body, &assocaction->body, sizeof(assocaction->body)))
      pass ("ASSOCACTION.body [Dwg_ACTIONBODY]");
    else
      {
        fail ("ASSOCACTION.body [Dwg_ACTIONBODY]"); error++;
      }
  }
  {
    BITCODE_H callback;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "callback", &callback, NULL)
        && !memcmp(&callback, &assocaction->callback, sizeof(assocaction->callback)))
      pass ("ASSOCACTION.callback [H]");
    else
      {
        fail ("ASSOCACTION.callback [H]"); error++;
      }
  }
  {
    BITCODE_B is_body_a_proxy;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "is_body_a_proxy", &is_body_a_proxy, NULL) &&
        is_body_a_proxy == assocaction->is_body_a_proxy)
      pass ("ASSOCACTION.is_body_a_proxy [B] " FORMAT_B "", is_body_a_proxy);
    else
      {
        fail ("ASSOCACTION.is_body_a_proxy [B] " FORMAT_B " != " FORMAT_B "", assocaction->is_body_a_proxy, is_body_a_proxy); error++;
      }
    is_body_a_proxy++;
    if (dwg_dynapi_entity_set_value(assocaction, "ASSOCACTION", "is_body_a_proxy", &is_body_a_proxy) &&
        is_body_a_proxy == assocaction->is_body_a_proxy)
      pass ("ASSOCACTION.is_body_a_proxy [B] set+1 " FORMAT_B "", is_body_a_proxy);
    else
      {
        fail ("ASSOCACTION.is_body_a_proxy [B] set+1 " FORMAT_B " != " FORMAT_B "", assocaction->is_body_a_proxy, is_body_a_proxy); error++;
      }
    assocaction->is_body_a_proxy--;

  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "num_deps", &num_deps, NULL) &&
        num_deps == assocaction->num_deps)
      pass ("ASSOCACTION.num_deps [BL] %u", num_deps);
    else
      {
        fail ("ASSOCACTION.num_deps [BL] %u != %u", assocaction->num_deps, num_deps); error++;
      }
    num_deps++;
    if (dwg_dynapi_entity_set_value(assocaction, "ASSOCACTION", "num_deps", &num_deps) &&
        num_deps == assocaction->num_deps)
      pass ("ASSOCACTION.num_deps [BL] set+1 %u", num_deps);
    else
      {
        fail ("ASSOCACTION.num_deps [BL] set+1 %u != %u", assocaction->num_deps, num_deps); error++;
      }
    assocaction->num_deps--;

  }
  {
    BITCODE_H owningnetwork;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "owningnetwork", &owningnetwork, NULL)
        && !memcmp(&owningnetwork, &assocaction->owningnetwork, sizeof(assocaction->owningnetwork)))
      pass ("ASSOCACTION.owningnetwork [H]");
    else
      {
        fail ("ASSOCACTION.owningnetwork [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "parent", &parent, NULL)
        && !memcmp(&parent, &assocaction->parent, sizeof(assocaction->parent)))
      pass ("ASSOCACTION.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ASSOCACTION.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H* readdeps;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "readdeps", &readdeps, NULL)
        && !memcmp(&readdeps, &assocaction->readdeps, sizeof(assocaction->readdeps)))
      pass ("ASSOCACTION.readdeps [H*]");
    else
      {
        fail ("ASSOCACTION.readdeps [H*]"); error++;
      }
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "status", &status, NULL) &&
        status == assocaction->status)
      pass ("ASSOCACTION.status [BL] %u", status);
    else
      {
        fail ("ASSOCACTION.status [BL] %u != %u", assocaction->status, status); error++;
      }
    status++;
    if (dwg_dynapi_entity_set_value(assocaction, "ASSOCACTION", "status", &status) &&
        status == assocaction->status)
      pass ("ASSOCACTION.status [BL] set+1 %u", status);
    else
      {
        fail ("ASSOCACTION.status [BL] set+1 %u != %u", assocaction->status, status); error++;
      }
    assocaction->status--;

  }
  {
    BITCODE_BL unknown_assoc;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "unknown_assoc", &unknown_assoc, NULL) &&
        unknown_assoc == assocaction->unknown_assoc)
      pass ("ASSOCACTION.unknown_assoc [BL] %u", unknown_assoc);
    else
      {
        fail ("ASSOCACTION.unknown_assoc [BL] %u != %u", assocaction->unknown_assoc, unknown_assoc); error++;
      }
    unknown_assoc++;
    if (dwg_dynapi_entity_set_value(assocaction, "ASSOCACTION", "unknown_assoc", &unknown_assoc) &&
        unknown_assoc == assocaction->unknown_assoc)
      pass ("ASSOCACTION.unknown_assoc [BL] set+1 %u", unknown_assoc);
    else
      {
        fail ("ASSOCACTION.unknown_assoc [BL] set+1 %u != %u", assocaction->unknown_assoc, unknown_assoc); error++;
      }
    assocaction->unknown_assoc--;

  }
  {
    BITCODE_H* writedeps;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "writedeps", &writedeps, NULL)
        && !memcmp(&writedeps, &assocaction->writedeps, sizeof(assocaction->writedeps)))
      pass ("ASSOCACTION.writedeps [H*]");
    else
      {
        fail ("ASSOCACTION.writedeps [H*]"); error++;
      }
  }
  return error;
}
static int test_ASSOCALIGNEDDIMACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCALIGNEDDIMACTIONBODY *assocaligneddimactionbody = obj->tio.object->tio.ASSOCALIGNEDDIMACTIONBODY;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aab_status", &aab_status, NULL) &&
        aab_status == assocaligneddimactionbody->aab_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.aab_status [BL] %u", aab_status);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.aab_status [BL] %u != %u", assocaligneddimactionbody->aab_status, aab_status); error++;
      }
    aab_status++;
    if (dwg_dynapi_entity_set_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aab_status", &aab_status) &&
        aab_status == assocaligneddimactionbody->aab_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.aab_status [BL] set+1 %u", aab_status);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.aab_status [BL] set+1 %u != %u", assocaligneddimactionbody->aab_status, aab_status); error++;
      }
    assocaligneddimactionbody->aab_status--;

  }
  {
    BITCODE_H d_node;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "d_node", &d_node, NULL)
        && !memcmp(&d_node, &assocaligneddimactionbody->d_node, sizeof(assocaligneddimactionbody->d_node)))
      pass ("ASSOCALIGNEDDIMACTIONBODY.d_node [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.d_node [H]"); error++;
      }
  }
  {
    BITCODE_BL dcm_status;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "dcm_status", &dcm_status, NULL) &&
        dcm_status == assocaligneddimactionbody->dcm_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.dcm_status [BL] %u", dcm_status);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.dcm_status [BL] %u != %u", assocaligneddimactionbody->dcm_status, dcm_status); error++;
      }
    dcm_status++;
    if (dwg_dynapi_entity_set_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "dcm_status", &dcm_status) &&
        dcm_status == assocaligneddimactionbody->dcm_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.dcm_status [BL] set+1 %u", dcm_status);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.dcm_status [BL] set+1 %u != %u", assocaligneddimactionbody->dcm_status, dcm_status); error++;
      }
    assocaligneddimactionbody->dcm_status--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &assocaligneddimactionbody->ownerhandle, sizeof(assocaligneddimactionbody->ownerhandle)))
      pass ("ASSOCALIGNEDDIMACTIONBODY.ownerhandle [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.ownerhandle [H]"); error++;
      }
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l2", &pab_l2, NULL) &&
        pab_l2 == assocaligneddimactionbody->pab_l2)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l2 [BL] %u", pab_l2);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l2 [BL] %u != %u", assocaligneddimactionbody->pab_l2, pab_l2); error++;
      }
    pab_l2++;
    if (dwg_dynapi_entity_set_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l2", &pab_l2) &&
        pab_l2 == assocaligneddimactionbody->pab_l2)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l2 [BL] set+1 %u", pab_l2);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l2 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l2, pab_l2); error++;
      }
    assocaligneddimactionbody->pab_l2--;

  }
  {
    BITCODE_BL pab_l3;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l3", &pab_l3, NULL) &&
        pab_l3 == assocaligneddimactionbody->pab_l3)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l3 [BL] %u", pab_l3);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l3 [BL] %u != %u", assocaligneddimactionbody->pab_l3, pab_l3); error++;
      }
    pab_l3++;
    if (dwg_dynapi_entity_set_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l3", &pab_l3) &&
        pab_l3 == assocaligneddimactionbody->pab_l3)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l3 [BL] set+1 %u", pab_l3);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l3 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l3, pab_l3); error++;
      }
    assocaligneddimactionbody->pab_l3--;

  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l4", &pab_l4, NULL) &&
        pab_l4 == assocaligneddimactionbody->pab_l4)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l4 [BL] %u", pab_l4);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l4 [BL] %u != %u", assocaligneddimactionbody->pab_l4, pab_l4); error++;
      }
    pab_l4++;
    if (dwg_dynapi_entity_set_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l4", &pab_l4) &&
        pab_l4 == assocaligneddimactionbody->pab_l4)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l4 [BL] set+1 %u", pab_l4);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l4 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l4, pab_l4); error++;
      }
    assocaligneddimactionbody->pab_l4--;

  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l5", &pab_l5, NULL) &&
        pab_l5 == assocaligneddimactionbody->pab_l5)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l5 [BL] %u", pab_l5);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l5 [BL] %u != %u", assocaligneddimactionbody->pab_l5, pab_l5); error++;
      }
    pab_l5++;
    if (dwg_dynapi_entity_set_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l5", &pab_l5) &&
        pab_l5 == assocaligneddimactionbody->pab_l5)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l5 [BL] set+1 %u", pab_l5);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l5 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l5, pab_l5); error++;
      }
    assocaligneddimactionbody->pab_l5--;

  }
  {
    BITCODE_BL pab_l6;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l6", &pab_l6, NULL) &&
        pab_l6 == assocaligneddimactionbody->pab_l6)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l6 [BL] %u", pab_l6);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l6 [BL] %u != %u", assocaligneddimactionbody->pab_l6, pab_l6); error++;
      }
    pab_l6++;
    if (dwg_dynapi_entity_set_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l6", &pab_l6) &&
        pab_l6 == assocaligneddimactionbody->pab_l6)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l6 [BL] set+1 %u", pab_l6);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l6 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l6, pab_l6); error++;
      }
    assocaligneddimactionbody->pab_l6--;

  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_status", &pab_status, NULL) &&
        pab_status == assocaligneddimactionbody->pab_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_status [BL] %u", pab_status);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_status [BL] %u != %u", assocaligneddimactionbody->pab_status, pab_status); error++;
      }
    pab_status++;
    if (dwg_dynapi_entity_set_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_status", &pab_status) &&
        pab_status == assocaligneddimactionbody->pab_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_status [BL] set+1 %u", pab_status);
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_status [BL] set+1 %u != %u", assocaligneddimactionbody->pab_status, pab_status); error++;
      }
    assocaligneddimactionbody->pab_status--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "parent", &parent, NULL)
        && !memcmp(&parent, &assocaligneddimactionbody->parent, sizeof(assocaligneddimactionbody->parent)))
      pass ("ASSOCALIGNEDDIMACTIONBODY.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H r_node;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "r_node", &r_node, NULL)
        && !memcmp(&r_node, &assocaligneddimactionbody->r_node, sizeof(assocaligneddimactionbody->r_node)))
      pass ("ASSOCALIGNEDDIMACTIONBODY.r_node [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.r_node [H]"); error++;
      }
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "readdep", &readdep, NULL)
        && !memcmp(&readdep, &assocaligneddimactionbody->readdep, sizeof(assocaligneddimactionbody->readdep)))
      pass ("ASSOCALIGNEDDIMACTIONBODY.readdep [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.readdep [H]"); error++;
      }
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "writedep", &writedep, NULL)
        && !memcmp(&writedep, &assocaligneddimactionbody->writedep, sizeof(assocaligneddimactionbody->writedep)))
      pass ("ASSOCALIGNEDDIMACTIONBODY.writedep [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.writedep [H]"); error++;
      }
  }
  return error;
}
static int test_ASSOCDEPENDENCY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCDEPENDENCY *assocdependency = obj->tio.object->tio.ASSOCDEPENDENCY;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "class_version", &class_version, NULL) &&
        class_version == assocdependency->class_version)
      pass ("ASSOCDEPENDENCY.class_version [BL] %u", class_version);
    else
      {
        fail ("ASSOCDEPENDENCY.class_version [BL] %u != %u", assocdependency->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "class_version", &class_version) &&
        class_version == assocdependency->class_version)
      pass ("ASSOCDEPENDENCY.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("ASSOCDEPENDENCY.class_version [BL] set+1 %u != %u", assocdependency->class_version, class_version); error++;
      }
    assocdependency->class_version--;

  }
  {
    BITCODE_BL depbodyid;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "depbodyid", &depbodyid, NULL) &&
        depbodyid == assocdependency->depbodyid)
      pass ("ASSOCDEPENDENCY.depbodyid [BL] %u", depbodyid);
    else
      {
        fail ("ASSOCDEPENDENCY.depbodyid [BL] %u != %u", assocdependency->depbodyid, depbodyid); error++;
      }
    depbodyid++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "depbodyid", &depbodyid) &&
        depbodyid == assocdependency->depbodyid)
      pass ("ASSOCDEPENDENCY.depbodyid [BL] set+1 %u", depbodyid);
    else
      {
        fail ("ASSOCDEPENDENCY.depbodyid [BL] set+1 %u != %u", assocdependency->depbodyid, depbodyid); error++;
      }
    assocdependency->depbodyid--;

  }
  {
    BITCODE_B isobjectstate_dep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "isobjectstate_dep", &isobjectstate_dep, NULL) &&
        isobjectstate_dep == assocdependency->isobjectstate_dep)
      pass ("ASSOCDEPENDENCY.isobjectstate_dep [B] " FORMAT_B "", isobjectstate_dep);
    else
      {
        fail ("ASSOCDEPENDENCY.isobjectstate_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->isobjectstate_dep, isobjectstate_dep); error++;
      }
    isobjectstate_dep++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "isobjectstate_dep", &isobjectstate_dep) &&
        isobjectstate_dep == assocdependency->isobjectstate_dep)
      pass ("ASSOCDEPENDENCY.isobjectstate_dep [B] set+1 " FORMAT_B "", isobjectstate_dep);
    else
      {
        fail ("ASSOCDEPENDENCY.isobjectstate_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->isobjectstate_dep, isobjectstate_dep); error++;
      }
    assocdependency->isobjectstate_dep--;

  }
  {
    BITCODE_B isread_dep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "isread_dep", &isread_dep, NULL) &&
        isread_dep == assocdependency->isread_dep)
      pass ("ASSOCDEPENDENCY.isread_dep [B] " FORMAT_B "", isread_dep);
    else
      {
        fail ("ASSOCDEPENDENCY.isread_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->isread_dep, isread_dep); error++;
      }
    isread_dep++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "isread_dep", &isread_dep) &&
        isread_dep == assocdependency->isread_dep)
      pass ("ASSOCDEPENDENCY.isread_dep [B] set+1 " FORMAT_B "", isread_dep);
    else
      {
        fail ("ASSOCDEPENDENCY.isread_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->isread_dep, isread_dep); error++;
      }
    assocdependency->isread_dep--;

  }
  {
    BITCODE_B iswrite_dep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "iswrite_dep", &iswrite_dep, NULL) &&
        iswrite_dep == assocdependency->iswrite_dep)
      pass ("ASSOCDEPENDENCY.iswrite_dep [B] " FORMAT_B "", iswrite_dep);
    else
      {
        fail ("ASSOCDEPENDENCY.iswrite_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->iswrite_dep, iswrite_dep); error++;
      }
    iswrite_dep++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "iswrite_dep", &iswrite_dep) &&
        iswrite_dep == assocdependency->iswrite_dep)
      pass ("ASSOCDEPENDENCY.iswrite_dep [B] set+1 " FORMAT_B "", iswrite_dep);
    else
      {
        fail ("ASSOCDEPENDENCY.iswrite_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->iswrite_dep, iswrite_dep); error++;
      }
    assocdependency->iswrite_dep--;

  }
  {
    BITCODE_H node;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "node", &node, NULL)
        && !memcmp(&node, &assocdependency->node, sizeof(assocdependency->node)))
      pass ("ASSOCDEPENDENCY.node [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.node [H]"); error++;
      }
  }
  {
    BITCODE_BL order;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "order", &order, NULL) &&
        order == assocdependency->order)
      pass ("ASSOCDEPENDENCY.order [BL] %u", order);
    else
      {
        fail ("ASSOCDEPENDENCY.order [BL] %u != %u", assocdependency->order, order); error++;
      }
    order++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "order", &order) &&
        order == assocdependency->order)
      pass ("ASSOCDEPENDENCY.order [BL] set+1 %u", order);
    else
      {
        fail ("ASSOCDEPENDENCY.order [BL] set+1 %u != %u", assocdependency->order, order); error++;
      }
    assocdependency->order--;

  }
  {
    BITCODE_H owner;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "owner", &owner, NULL)
        && !memcmp(&owner, &assocdependency->owner, sizeof(assocdependency->owner)))
      pass ("ASSOCDEPENDENCY.owner [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.owner [H]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &assocdependency->ownerhandle, sizeof(assocdependency->ownerhandle)))
      pass ("ASSOCDEPENDENCY.ownerhandle [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "parent", &parent, NULL)
        && !memcmp(&parent, &assocdependency->parent, sizeof(assocdependency->parent)))
      pass ("ASSOCDEPENDENCY.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ASSOCDEPENDENCY.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "readdep", &readdep, NULL)
        && !memcmp(&readdep, &assocdependency->readdep, sizeof(assocdependency->readdep)))
      pass ("ASSOCDEPENDENCY.readdep [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.readdep [H]"); error++;
      }
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "status", &status, NULL) &&
        status == assocdependency->status)
      pass ("ASSOCDEPENDENCY.status [BL] %u", status);
    else
      {
        fail ("ASSOCDEPENDENCY.status [BL] %u != %u", assocdependency->status, status); error++;
      }
    status++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "status", &status) &&
        status == assocdependency->status)
      pass ("ASSOCDEPENDENCY.status [BL] set+1 %u", status);
    else
      {
        fail ("ASSOCDEPENDENCY.status [BL] set+1 %u != %u", assocdependency->status, status); error++;
      }
    assocdependency->status--;

  }
  {
    BITCODE_B unknown_b4;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "unknown_b4", &unknown_b4, NULL) &&
        unknown_b4 == assocdependency->unknown_b4)
      pass ("ASSOCDEPENDENCY.unknown_b4 [B] " FORMAT_B "", unknown_b4);
    else
      {
        fail ("ASSOCDEPENDENCY.unknown_b4 [B] " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b4, unknown_b4); error++;
      }
    unknown_b4++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "unknown_b4", &unknown_b4) &&
        unknown_b4 == assocdependency->unknown_b4)
      pass ("ASSOCDEPENDENCY.unknown_b4 [B] set+1 " FORMAT_B "", unknown_b4);
    else
      {
        fail ("ASSOCDEPENDENCY.unknown_b4 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b4, unknown_b4); error++;
      }
    assocdependency->unknown_b4--;

  }
  {
    BITCODE_B unknown_b5;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "unknown_b5", &unknown_b5, NULL) &&
        unknown_b5 == assocdependency->unknown_b5)
      pass ("ASSOCDEPENDENCY.unknown_b5 [B] " FORMAT_B "", unknown_b5);
    else
      {
        fail ("ASSOCDEPENDENCY.unknown_b5 [B] " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b5, unknown_b5); error++;
      }
    unknown_b5++;
    if (dwg_dynapi_entity_set_value(assocdependency, "ASSOCDEPENDENCY", "unknown_b5", &unknown_b5) &&
        unknown_b5 == assocdependency->unknown_b5)
      pass ("ASSOCDEPENDENCY.unknown_b5 [B] set+1 " FORMAT_B "", unknown_b5);
    else
      {
        fail ("ASSOCDEPENDENCY.unknown_b5 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b5, unknown_b5); error++;
      }
    assocdependency->unknown_b5--;

  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "writedep", &writedep, NULL)
        && !memcmp(&writedep, &assocdependency->writedep, sizeof(assocdependency->writedep)))
      pass ("ASSOCDEPENDENCY.writedep [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.writedep [H]"); error++;
      }
  }
  return error;
}
static int test_ASSOCNETWORK (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCNETWORK *assocnetwork = obj->tio.object->tio.ASSOCNETWORK;
  {
    BITCODE_H* actions;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "actions", &actions, NULL)
        && !memcmp(&actions, &assocnetwork->actions, sizeof(assocnetwork->actions)))
      pass ("ASSOCNETWORK.actions [H*]");
    else
      {
        fail ("ASSOCNETWORK.actions [H*]"); error++;
      }
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "num_actions", &num_actions, NULL) &&
        num_actions == assocnetwork->num_actions)
      pass ("ASSOCNETWORK.num_actions [BL] %u", num_actions);
    else
      {
        fail ("ASSOCNETWORK.num_actions [BL] %u != %u", assocnetwork->num_actions, num_actions); error++;
      }
    num_actions++;
    if (dwg_dynapi_entity_set_value(assocnetwork, "ASSOCNETWORK", "num_actions", &num_actions) &&
        num_actions == assocnetwork->num_actions)
      pass ("ASSOCNETWORK.num_actions [BL] set+1 %u", num_actions);
    else
      {
        fail ("ASSOCNETWORK.num_actions [BL] set+1 %u != %u", assocnetwork->num_actions, num_actions); error++;
      }
    assocnetwork->num_actions--;

  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "num_deps", &num_deps, NULL) &&
        num_deps == assocnetwork->num_deps)
      pass ("ASSOCNETWORK.num_deps [BL] %u", num_deps);
    else
      {
        fail ("ASSOCNETWORK.num_deps [BL] %u != %u", assocnetwork->num_deps, num_deps); error++;
      }
    num_deps++;
    if (dwg_dynapi_entity_set_value(assocnetwork, "ASSOCNETWORK", "num_deps", &num_deps) &&
        num_deps == assocnetwork->num_deps)
      pass ("ASSOCNETWORK.num_deps [BL] set+1 %u", num_deps);
    else
      {
        fail ("ASSOCNETWORK.num_deps [BL] set+1 %u != %u", assocnetwork->num_deps, num_deps); error++;
      }
    assocnetwork->num_deps--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "parent", &parent, NULL)
        && !memcmp(&parent, &assocnetwork->parent, sizeof(assocnetwork->parent)))
      pass ("ASSOCNETWORK.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ASSOCNETWORK.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "readdep", &readdep, NULL)
        && !memcmp(&readdep, &assocnetwork->readdep, sizeof(assocnetwork->readdep)))
      pass ("ASSOCNETWORK.readdep [H]");
    else
      {
        fail ("ASSOCNETWORK.readdep [H]"); error++;
      }
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "status", &status, NULL) &&
        status == assocnetwork->status)
      pass ("ASSOCNETWORK.status [BL] %u", status);
    else
      {
        fail ("ASSOCNETWORK.status [BL] %u != %u", assocnetwork->status, status); error++;
      }
    status++;
    if (dwg_dynapi_entity_set_value(assocnetwork, "ASSOCNETWORK", "status", &status) &&
        status == assocnetwork->status)
      pass ("ASSOCNETWORK.status [BL] set+1 %u", status);
    else
      {
        fail ("ASSOCNETWORK.status [BL] set+1 %u != %u", assocnetwork->status, status); error++;
      }
    assocnetwork->status--;

  }
  {
    BITCODE_BL unknown_assoc;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "unknown_assoc", &unknown_assoc, NULL) &&
        unknown_assoc == assocnetwork->unknown_assoc)
      pass ("ASSOCNETWORK.unknown_assoc [BL] %u", unknown_assoc);
    else
      {
        fail ("ASSOCNETWORK.unknown_assoc [BL] %u != %u", assocnetwork->unknown_assoc, unknown_assoc); error++;
      }
    unknown_assoc++;
    if (dwg_dynapi_entity_set_value(assocnetwork, "ASSOCNETWORK", "unknown_assoc", &unknown_assoc) &&
        unknown_assoc == assocnetwork->unknown_assoc)
      pass ("ASSOCNETWORK.unknown_assoc [BL] set+1 %u", unknown_assoc);
    else
      {
        fail ("ASSOCNETWORK.unknown_assoc [BL] set+1 %u != %u", assocnetwork->unknown_assoc, unknown_assoc); error++;
      }
    assocnetwork->unknown_assoc--;

  }
  {
    BITCODE_BL unknown_n1;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "unknown_n1", &unknown_n1, NULL) &&
        unknown_n1 == assocnetwork->unknown_n1)
      pass ("ASSOCNETWORK.unknown_n1 [BL] %u", unknown_n1);
    else
      {
        fail ("ASSOCNETWORK.unknown_n1 [BL] %u != %u", assocnetwork->unknown_n1, unknown_n1); error++;
      }
    unknown_n1++;
    if (dwg_dynapi_entity_set_value(assocnetwork, "ASSOCNETWORK", "unknown_n1", &unknown_n1) &&
        unknown_n1 == assocnetwork->unknown_n1)
      pass ("ASSOCNETWORK.unknown_n1 [BL] set+1 %u", unknown_n1);
    else
      {
        fail ("ASSOCNETWORK.unknown_n1 [BL] set+1 %u != %u", assocnetwork->unknown_n1, unknown_n1); error++;
      }
    assocnetwork->unknown_n1--;

  }
  {
    BITCODE_BL unknown_n2;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "unknown_n2", &unknown_n2, NULL) &&
        unknown_n2 == assocnetwork->unknown_n2)
      pass ("ASSOCNETWORK.unknown_n2 [BL] %u", unknown_n2);
    else
      {
        fail ("ASSOCNETWORK.unknown_n2 [BL] %u != %u", assocnetwork->unknown_n2, unknown_n2); error++;
      }
    unknown_n2++;
    if (dwg_dynapi_entity_set_value(assocnetwork, "ASSOCNETWORK", "unknown_n2", &unknown_n2) &&
        unknown_n2 == assocnetwork->unknown_n2)
      pass ("ASSOCNETWORK.unknown_n2 [BL] set+1 %u", unknown_n2);
    else
      {
        fail ("ASSOCNETWORK.unknown_n2 [BL] set+1 %u != %u", assocnetwork->unknown_n2, unknown_n2); error++;
      }
    assocnetwork->unknown_n2--;

  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "writedep", &writedep, NULL)
        && !memcmp(&writedep, &assocnetwork->writedep, sizeof(assocnetwork->writedep)))
      pass ("ASSOCNETWORK.writedep [H]");
    else
      {
        fail ("ASSOCNETWORK.writedep [H]"); error++;
      }
  }
  return error;
}
static int test_ASSOCOSNAPPOINTREFACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM *assocosnappointrefactionparam = obj->tio.object->tio.ASSOCOSNAPPOINTREFACTIONPARAM;
  {
    BITCODE_H actionparam;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "actionparam", &actionparam, NULL)
        && !memcmp(&actionparam, &assocosnappointrefactionparam->actionparam, sizeof(assocosnappointrefactionparam->actionparam)))
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.actionparam [H]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.actionparam [H]"); error++;
      }
  }
  {
    BITCODE_RS flags;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "flags", &flags, NULL) &&
        flags == assocosnappointrefactionparam->flags)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.flags [RS] %hu", flags);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.flags [RS] %hu != %hu", assocosnappointrefactionparam->flags, flags); error++;
      }
    flags++;
    if (dwg_dynapi_entity_set_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "flags", &flags) &&
        flags == assocosnappointrefactionparam->flags)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.flags [RS] set+1 %hu", flags);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.flags [RS] set+1 %hu != %hu", assocosnappointrefactionparam->flags, flags); error++;
      }
    assocosnappointrefactionparam->flags--;

  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "name", &name, NULL)
        && !memcmp(&name, &assocosnappointrefactionparam->name, sizeof(assocosnappointrefactionparam->name)))
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.name [T]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.name [T]"); error++;
      }
  }
  {
    BITCODE_BS num_params;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "num_params", &num_params, NULL) &&
        num_params == assocosnappointrefactionparam->num_params)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BS] %hu", num_params);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BS] %hu != %hu", assocosnappointrefactionparam->num_params, num_params); error++;
      }
    num_params++;
    if (dwg_dynapi_entity_set_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "num_params", &num_params) &&
        num_params == assocosnappointrefactionparam->num_params)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BS] set+1 %hu", num_params);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BS] set+1 %hu != %hu", assocosnappointrefactionparam->num_params, num_params); error++;
      }
    assocosnappointrefactionparam->num_params--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "parent", &parent, NULL)
        && !memcmp(&parent, &assocosnappointrefactionparam->parent, sizeof(assocosnappointrefactionparam->parent)))
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BS status;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "status", &status, NULL) &&
        status == assocosnappointrefactionparam->status)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] %hu", status);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] %hu != %hu", assocosnappointrefactionparam->status, status); error++;
      }
    status++;
    if (dwg_dynapi_entity_set_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "status", &status) &&
        status == assocosnappointrefactionparam->status)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] set+1 %hu", status);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] set+1 %hu != %hu", assocosnappointrefactionparam->status, status); error++;
      }
    assocosnappointrefactionparam->status--;

  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown", &unknown, NULL) &&
        unknown == assocosnappointrefactionparam->unknown)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown [RC] %u", unknown);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown [RC] %u != %u", assocosnappointrefactionparam->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown", &unknown) &&
        unknown == assocosnappointrefactionparam->unknown)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown [RC] set+1 %u != %u", assocosnappointrefactionparam->unknown, unknown); error++;
      }
    assocosnappointrefactionparam->unknown--;

  }
  {
    BITCODE_B unknown1;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown1", &unknown1, NULL) &&
        unknown1 == assocosnappointrefactionparam->unknown1)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown1 [B] " FORMAT_B "", unknown1);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown1 [B] " FORMAT_B " != " FORMAT_B "", assocosnappointrefactionparam->unknown1, unknown1); error++;
      }
    unknown1++;
    if (dwg_dynapi_entity_set_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown1", &unknown1) &&
        unknown1 == assocosnappointrefactionparam->unknown1)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown1 [B] set+1 " FORMAT_B "", unknown1);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocosnappointrefactionparam->unknown1, unknown1); error++;
      }
    assocosnappointrefactionparam->unknown1--;

  }
  {
    BITCODE_BD unknown3;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown3", &unknown3, NULL) &&
        unknown3 == assocosnappointrefactionparam->unknown3)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown3 [BD] %g", unknown3);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown3 [BD] %g != %g", assocosnappointrefactionparam->unknown3, unknown3); error++;
      }
    unknown3++;
    if (dwg_dynapi_entity_set_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown3", &unknown3) &&
        unknown3 == assocosnappointrefactionparam->unknown3)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown3 [BD] set+1 %g", unknown3);
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown3 [BD] set+1 %g != %g", assocosnappointrefactionparam->unknown3, unknown3); error++;
      }
    assocosnappointrefactionparam->unknown3--;

  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "writedep", &writedep, NULL)
        && !memcmp(&writedep, &assocosnappointrefactionparam->writedep, sizeof(assocosnappointrefactionparam->writedep)))
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.writedep [H]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.writedep [H]"); error++;
      }
  }
  return error;
}
static int test_ASSOCPERSSUBENTMANAGER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCPERSSUBENTMANAGER *assocperssubentmanager = obj->tio.object->tio.ASSOCPERSSUBENTMANAGER;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "class_version", &class_version, NULL) &&
        class_version == assocperssubentmanager->class_version)
      pass ("ASSOCPERSSUBENTMANAGER.class_version [BL] %u", class_version);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.class_version [BL] %u != %u", assocperssubentmanager->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "class_version", &class_version) &&
        class_version == assocperssubentmanager->class_version)
      pass ("ASSOCPERSSUBENTMANAGER.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.class_version [BL] set+1 %u != %u", assocperssubentmanager->class_version, class_version); error++;
      }
    assocperssubentmanager->class_version--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &assocperssubentmanager->ownerhandle, sizeof(assocperssubentmanager->ownerhandle)))
      pass ("ASSOCPERSSUBENTMANAGER.ownerhandle [H]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "parent", &parent, NULL)
        && !memcmp(&parent, &assocperssubentmanager->parent, sizeof(assocperssubentmanager->parent)))
      pass ("ASSOCPERSSUBENTMANAGER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_B unknown_b37;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_b37", &unknown_b37, NULL) &&
        unknown_b37 == assocperssubentmanager->unknown_b37)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] " FORMAT_B "", unknown_b37);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] " FORMAT_B " != " FORMAT_B "", assocperssubentmanager->unknown_b37, unknown_b37); error++;
      }
    unknown_b37++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_b37", &unknown_b37) &&
        unknown_b37 == assocperssubentmanager->unknown_b37)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] set+1 " FORMAT_B "", unknown_b37);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocperssubentmanager->unknown_b37, unknown_b37); error++;
      }
    assocperssubentmanager->unknown_b37--;

  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1, NULL) &&
        unknown_bl1 == assocperssubentmanager->unknown_bl1)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl1 [BL] %u", unknown_bl1);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl1 [BL] %u != %u", assocperssubentmanager->unknown_bl1, unknown_bl1); error++;
      }
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1) &&
        unknown_bl1 == assocperssubentmanager->unknown_bl1)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl1 [BL] set+1 %u", unknown_bl1);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl1 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl1, unknown_bl1); error++;
      }
    assocperssubentmanager->unknown_bl1--;

  }
  {
    BITCODE_BL unknown_bl10;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl10", &unknown_bl10, NULL) &&
        unknown_bl10 == assocperssubentmanager->unknown_bl10)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] %u", unknown_bl10);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] %u != %u", assocperssubentmanager->unknown_bl10, unknown_bl10); error++;
      }
    unknown_bl10++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl10", &unknown_bl10) &&
        unknown_bl10 == assocperssubentmanager->unknown_bl10)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] set+1 %u", unknown_bl10);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl10, unknown_bl10); error++;
      }
    assocperssubentmanager->unknown_bl10--;

  }
  {
    BITCODE_BL unknown_bl11;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl11", &unknown_bl11, NULL) &&
        unknown_bl11 == assocperssubentmanager->unknown_bl11)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] %u", unknown_bl11);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] %u != %u", assocperssubentmanager->unknown_bl11, unknown_bl11); error++;
      }
    unknown_bl11++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl11", &unknown_bl11) &&
        unknown_bl11 == assocperssubentmanager->unknown_bl11)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] set+1 %u", unknown_bl11);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl11, unknown_bl11); error++;
      }
    assocperssubentmanager->unknown_bl11--;

  }
  {
    BITCODE_BL unknown_bl12;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl12", &unknown_bl12, NULL) &&
        unknown_bl12 == assocperssubentmanager->unknown_bl12)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] %u", unknown_bl12);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] %u != %u", assocperssubentmanager->unknown_bl12, unknown_bl12); error++;
      }
    unknown_bl12++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl12", &unknown_bl12) &&
        unknown_bl12 == assocperssubentmanager->unknown_bl12)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] set+1 %u", unknown_bl12);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl12, unknown_bl12); error++;
      }
    assocperssubentmanager->unknown_bl12--;

  }
  {
    BITCODE_BL unknown_bl13;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl13", &unknown_bl13, NULL) &&
        unknown_bl13 == assocperssubentmanager->unknown_bl13)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] %u", unknown_bl13);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] %u != %u", assocperssubentmanager->unknown_bl13, unknown_bl13); error++;
      }
    unknown_bl13++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl13", &unknown_bl13) &&
        unknown_bl13 == assocperssubentmanager->unknown_bl13)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] set+1 %u", unknown_bl13);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl13, unknown_bl13); error++;
      }
    assocperssubentmanager->unknown_bl13--;

  }
  {
    BITCODE_BL unknown_bl14;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl14", &unknown_bl14, NULL) &&
        unknown_bl14 == assocperssubentmanager->unknown_bl14)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] %u", unknown_bl14);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] %u != %u", assocperssubentmanager->unknown_bl14, unknown_bl14); error++;
      }
    unknown_bl14++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl14", &unknown_bl14) &&
        unknown_bl14 == assocperssubentmanager->unknown_bl14)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] set+1 %u", unknown_bl14);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl14, unknown_bl14); error++;
      }
    assocperssubentmanager->unknown_bl14--;

  }
  {
    BITCODE_BL unknown_bl15;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl15", &unknown_bl15, NULL) &&
        unknown_bl15 == assocperssubentmanager->unknown_bl15)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] %u", unknown_bl15);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] %u != %u", assocperssubentmanager->unknown_bl15, unknown_bl15); error++;
      }
    unknown_bl15++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl15", &unknown_bl15) &&
        unknown_bl15 == assocperssubentmanager->unknown_bl15)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] set+1 %u", unknown_bl15);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl15, unknown_bl15); error++;
      }
    assocperssubentmanager->unknown_bl15--;

  }
  {
    BITCODE_BL unknown_bl16;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl16", &unknown_bl16, NULL) &&
        unknown_bl16 == assocperssubentmanager->unknown_bl16)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] %u", unknown_bl16);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] %u != %u", assocperssubentmanager->unknown_bl16, unknown_bl16); error++;
      }
    unknown_bl16++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl16", &unknown_bl16) &&
        unknown_bl16 == assocperssubentmanager->unknown_bl16)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] set+1 %u", unknown_bl16);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl16, unknown_bl16); error++;
      }
    assocperssubentmanager->unknown_bl16--;

  }
  {
    BITCODE_BL unknown_bl17;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl17", &unknown_bl17, NULL) &&
        unknown_bl17 == assocperssubentmanager->unknown_bl17)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] %u", unknown_bl17);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] %u != %u", assocperssubentmanager->unknown_bl17, unknown_bl17); error++;
      }
    unknown_bl17++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl17", &unknown_bl17) &&
        unknown_bl17 == assocperssubentmanager->unknown_bl17)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] set+1 %u", unknown_bl17);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl17, unknown_bl17); error++;
      }
    assocperssubentmanager->unknown_bl17--;

  }
  {
    BITCODE_BL unknown_bl18;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl18", &unknown_bl18, NULL) &&
        unknown_bl18 == assocperssubentmanager->unknown_bl18)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] %u", unknown_bl18);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] %u != %u", assocperssubentmanager->unknown_bl18, unknown_bl18); error++;
      }
    unknown_bl18++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl18", &unknown_bl18) &&
        unknown_bl18 == assocperssubentmanager->unknown_bl18)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] set+1 %u", unknown_bl18);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl18, unknown_bl18); error++;
      }
    assocperssubentmanager->unknown_bl18--;

  }
  {
    BITCODE_BL unknown_bl19;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl19", &unknown_bl19, NULL) &&
        unknown_bl19 == assocperssubentmanager->unknown_bl19)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] %u", unknown_bl19);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] %u != %u", assocperssubentmanager->unknown_bl19, unknown_bl19); error++;
      }
    unknown_bl19++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl19", &unknown_bl19) &&
        unknown_bl19 == assocperssubentmanager->unknown_bl19)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] set+1 %u", unknown_bl19);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl19, unknown_bl19); error++;
      }
    assocperssubentmanager->unknown_bl19--;

  }
  {
    BITCODE_BL unknown_bl2;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2, NULL) &&
        unknown_bl2 == assocperssubentmanager->unknown_bl2)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl2 [BL] %u", unknown_bl2);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl2 [BL] %u != %u", assocperssubentmanager->unknown_bl2, unknown_bl2); error++;
      }
    unknown_bl2++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2) &&
        unknown_bl2 == assocperssubentmanager->unknown_bl2)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl2 [BL] set+1 %u", unknown_bl2);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl2 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl2, unknown_bl2); error++;
      }
    assocperssubentmanager->unknown_bl2--;

  }
  {
    BITCODE_BL unknown_bl20;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl20", &unknown_bl20, NULL) &&
        unknown_bl20 == assocperssubentmanager->unknown_bl20)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] %u", unknown_bl20);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] %u != %u", assocperssubentmanager->unknown_bl20, unknown_bl20); error++;
      }
    unknown_bl20++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl20", &unknown_bl20) &&
        unknown_bl20 == assocperssubentmanager->unknown_bl20)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] set+1 %u", unknown_bl20);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl20, unknown_bl20); error++;
      }
    assocperssubentmanager->unknown_bl20--;

  }
  {
    BITCODE_BL unknown_bl21;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl21", &unknown_bl21, NULL) &&
        unknown_bl21 == assocperssubentmanager->unknown_bl21)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] %u", unknown_bl21);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] %u != %u", assocperssubentmanager->unknown_bl21, unknown_bl21); error++;
      }
    unknown_bl21++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl21", &unknown_bl21) &&
        unknown_bl21 == assocperssubentmanager->unknown_bl21)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] set+1 %u", unknown_bl21);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl21, unknown_bl21); error++;
      }
    assocperssubentmanager->unknown_bl21--;

  }
  {
    BITCODE_BL unknown_bl22;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl22", &unknown_bl22, NULL) &&
        unknown_bl22 == assocperssubentmanager->unknown_bl22)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] %u", unknown_bl22);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] %u != %u", assocperssubentmanager->unknown_bl22, unknown_bl22); error++;
      }
    unknown_bl22++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl22", &unknown_bl22) &&
        unknown_bl22 == assocperssubentmanager->unknown_bl22)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] set+1 %u", unknown_bl22);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl22, unknown_bl22); error++;
      }
    assocperssubentmanager->unknown_bl22--;

  }
  {
    BITCODE_BL unknown_bl23;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl23", &unknown_bl23, NULL) &&
        unknown_bl23 == assocperssubentmanager->unknown_bl23)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] %u", unknown_bl23);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] %u != %u", assocperssubentmanager->unknown_bl23, unknown_bl23); error++;
      }
    unknown_bl23++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl23", &unknown_bl23) &&
        unknown_bl23 == assocperssubentmanager->unknown_bl23)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] set+1 %u", unknown_bl23);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl23, unknown_bl23); error++;
      }
    assocperssubentmanager->unknown_bl23--;

  }
  {
    BITCODE_BL unknown_bl24;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl24", &unknown_bl24, NULL) &&
        unknown_bl24 == assocperssubentmanager->unknown_bl24)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] %u", unknown_bl24);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] %u != %u", assocperssubentmanager->unknown_bl24, unknown_bl24); error++;
      }
    unknown_bl24++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl24", &unknown_bl24) &&
        unknown_bl24 == assocperssubentmanager->unknown_bl24)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] set+1 %u", unknown_bl24);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl24, unknown_bl24); error++;
      }
    assocperssubentmanager->unknown_bl24--;

  }
  {
    BITCODE_BL unknown_bl25;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl25", &unknown_bl25, NULL) &&
        unknown_bl25 == assocperssubentmanager->unknown_bl25)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] %u", unknown_bl25);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] %u != %u", assocperssubentmanager->unknown_bl25, unknown_bl25); error++;
      }
    unknown_bl25++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl25", &unknown_bl25) &&
        unknown_bl25 == assocperssubentmanager->unknown_bl25)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] set+1 %u", unknown_bl25);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl25, unknown_bl25); error++;
      }
    assocperssubentmanager->unknown_bl25--;

  }
  {
    BITCODE_BL unknown_bl26;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl26", &unknown_bl26, NULL) &&
        unknown_bl26 == assocperssubentmanager->unknown_bl26)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] %u", unknown_bl26);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] %u != %u", assocperssubentmanager->unknown_bl26, unknown_bl26); error++;
      }
    unknown_bl26++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl26", &unknown_bl26) &&
        unknown_bl26 == assocperssubentmanager->unknown_bl26)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] set+1 %u", unknown_bl26);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl26, unknown_bl26); error++;
      }
    assocperssubentmanager->unknown_bl26--;

  }
  {
    BITCODE_BL unknown_bl27;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl27", &unknown_bl27, NULL) &&
        unknown_bl27 == assocperssubentmanager->unknown_bl27)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] %u", unknown_bl27);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] %u != %u", assocperssubentmanager->unknown_bl27, unknown_bl27); error++;
      }
    unknown_bl27++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl27", &unknown_bl27) &&
        unknown_bl27 == assocperssubentmanager->unknown_bl27)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] set+1 %u", unknown_bl27);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl27, unknown_bl27); error++;
      }
    assocperssubentmanager->unknown_bl27--;

  }
  {
    BITCODE_BL unknown_bl28;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl28", &unknown_bl28, NULL) &&
        unknown_bl28 == assocperssubentmanager->unknown_bl28)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] %u", unknown_bl28);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] %u != %u", assocperssubentmanager->unknown_bl28, unknown_bl28); error++;
      }
    unknown_bl28++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl28", &unknown_bl28) &&
        unknown_bl28 == assocperssubentmanager->unknown_bl28)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] set+1 %u", unknown_bl28);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl28, unknown_bl28); error++;
      }
    assocperssubentmanager->unknown_bl28--;

  }
  {
    BITCODE_BL unknown_bl29;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl29", &unknown_bl29, NULL) &&
        unknown_bl29 == assocperssubentmanager->unknown_bl29)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] %u", unknown_bl29);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] %u != %u", assocperssubentmanager->unknown_bl29, unknown_bl29); error++;
      }
    unknown_bl29++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl29", &unknown_bl29) &&
        unknown_bl29 == assocperssubentmanager->unknown_bl29)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] set+1 %u", unknown_bl29);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl29, unknown_bl29); error++;
      }
    assocperssubentmanager->unknown_bl29--;

  }
  {
    BITCODE_BL unknown_bl3;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3, NULL) &&
        unknown_bl3 == assocperssubentmanager->unknown_bl3)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl3 [BL] %u", unknown_bl3);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl3 [BL] %u != %u", assocperssubentmanager->unknown_bl3, unknown_bl3); error++;
      }
    unknown_bl3++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3) &&
        unknown_bl3 == assocperssubentmanager->unknown_bl3)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl3 [BL] set+1 %u", unknown_bl3);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl3 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl3, unknown_bl3); error++;
      }
    assocperssubentmanager->unknown_bl3--;

  }
  {
    BITCODE_BL unknown_bl30;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl30", &unknown_bl30, NULL) &&
        unknown_bl30 == assocperssubentmanager->unknown_bl30)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] %u", unknown_bl30);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] %u != %u", assocperssubentmanager->unknown_bl30, unknown_bl30); error++;
      }
    unknown_bl30++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl30", &unknown_bl30) &&
        unknown_bl30 == assocperssubentmanager->unknown_bl30)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] set+1 %u", unknown_bl30);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl30, unknown_bl30); error++;
      }
    assocperssubentmanager->unknown_bl30--;

  }
  {
    BITCODE_BL unknown_bl31;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl31", &unknown_bl31, NULL) &&
        unknown_bl31 == assocperssubentmanager->unknown_bl31)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] %u", unknown_bl31);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] %u != %u", assocperssubentmanager->unknown_bl31, unknown_bl31); error++;
      }
    unknown_bl31++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl31", &unknown_bl31) &&
        unknown_bl31 == assocperssubentmanager->unknown_bl31)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] set+1 %u", unknown_bl31);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl31, unknown_bl31); error++;
      }
    assocperssubentmanager->unknown_bl31--;

  }
  {
    BITCODE_BL unknown_bl32;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl32", &unknown_bl32, NULL) &&
        unknown_bl32 == assocperssubentmanager->unknown_bl32)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] %u", unknown_bl32);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] %u != %u", assocperssubentmanager->unknown_bl32, unknown_bl32); error++;
      }
    unknown_bl32++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl32", &unknown_bl32) &&
        unknown_bl32 == assocperssubentmanager->unknown_bl32)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] set+1 %u", unknown_bl32);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl32, unknown_bl32); error++;
      }
    assocperssubentmanager->unknown_bl32--;

  }
  {
    BITCODE_BL unknown_bl33;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl33", &unknown_bl33, NULL) &&
        unknown_bl33 == assocperssubentmanager->unknown_bl33)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] %u", unknown_bl33);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] %u != %u", assocperssubentmanager->unknown_bl33, unknown_bl33); error++;
      }
    unknown_bl33++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl33", &unknown_bl33) &&
        unknown_bl33 == assocperssubentmanager->unknown_bl33)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] set+1 %u", unknown_bl33);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl33, unknown_bl33); error++;
      }
    assocperssubentmanager->unknown_bl33--;

  }
  {
    BITCODE_BL unknown_bl34;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl34", &unknown_bl34, NULL) &&
        unknown_bl34 == assocperssubentmanager->unknown_bl34)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] %u", unknown_bl34);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] %u != %u", assocperssubentmanager->unknown_bl34, unknown_bl34); error++;
      }
    unknown_bl34++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl34", &unknown_bl34) &&
        unknown_bl34 == assocperssubentmanager->unknown_bl34)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] set+1 %u", unknown_bl34);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl34, unknown_bl34); error++;
      }
    assocperssubentmanager->unknown_bl34--;

  }
  {
    BITCODE_BL unknown_bl35;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl35", &unknown_bl35, NULL) &&
        unknown_bl35 == assocperssubentmanager->unknown_bl35)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] %u", unknown_bl35);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] %u != %u", assocperssubentmanager->unknown_bl35, unknown_bl35); error++;
      }
    unknown_bl35++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl35", &unknown_bl35) &&
        unknown_bl35 == assocperssubentmanager->unknown_bl35)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] set+1 %u", unknown_bl35);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl35, unknown_bl35); error++;
      }
    assocperssubentmanager->unknown_bl35--;

  }
  {
    BITCODE_BL unknown_bl36;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl36", &unknown_bl36, NULL) &&
        unknown_bl36 == assocperssubentmanager->unknown_bl36)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] %u", unknown_bl36);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] %u != %u", assocperssubentmanager->unknown_bl36, unknown_bl36); error++;
      }
    unknown_bl36++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl36", &unknown_bl36) &&
        unknown_bl36 == assocperssubentmanager->unknown_bl36)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] set+1 %u", unknown_bl36);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl36, unknown_bl36); error++;
      }
    assocperssubentmanager->unknown_bl36--;

  }
  {
    BITCODE_BL unknown_bl4;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4, NULL) &&
        unknown_bl4 == assocperssubentmanager->unknown_bl4)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl4 [BL] %u", unknown_bl4);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl4 [BL] %u != %u", assocperssubentmanager->unknown_bl4, unknown_bl4); error++;
      }
    unknown_bl4++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4) &&
        unknown_bl4 == assocperssubentmanager->unknown_bl4)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl4 [BL] set+1 %u", unknown_bl4);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl4 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl4, unknown_bl4); error++;
      }
    assocperssubentmanager->unknown_bl4--;

  }
  {
    BITCODE_BL unknown_bl5;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5, NULL) &&
        unknown_bl5 == assocperssubentmanager->unknown_bl5)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl5 [BL] %u", unknown_bl5);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl5 [BL] %u != %u", assocperssubentmanager->unknown_bl5, unknown_bl5); error++;
      }
    unknown_bl5++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5) &&
        unknown_bl5 == assocperssubentmanager->unknown_bl5)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl5 [BL] set+1 %u", unknown_bl5);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl5 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl5, unknown_bl5); error++;
      }
    assocperssubentmanager->unknown_bl5--;

  }
  {
    BITCODE_BL unknown_bl6;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, NULL) &&
        unknown_bl6 == assocperssubentmanager->unknown_bl6)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] %u", unknown_bl6);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] %u != %u", assocperssubentmanager->unknown_bl6, unknown_bl6); error++;
      }
    unknown_bl6++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6) &&
        unknown_bl6 == assocperssubentmanager->unknown_bl6)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] set+1 %u", unknown_bl6);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl6, unknown_bl6); error++;
      }
    assocperssubentmanager->unknown_bl6--;

  }
  {
    BITCODE_BL unknown_bl6a;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6a", &unknown_bl6a, NULL) &&
        unknown_bl6a == assocperssubentmanager->unknown_bl6a)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] %u", unknown_bl6a);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] %u != %u", assocperssubentmanager->unknown_bl6a, unknown_bl6a); error++;
      }
    unknown_bl6a++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6a", &unknown_bl6a) &&
        unknown_bl6a == assocperssubentmanager->unknown_bl6a)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] set+1 %u", unknown_bl6a);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl6a, unknown_bl6a); error++;
      }
    assocperssubentmanager->unknown_bl6a--;

  }
  {
    BITCODE_BL unknown_bl7;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7", &unknown_bl7, NULL) &&
        unknown_bl7 == assocperssubentmanager->unknown_bl7)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] %u", unknown_bl7);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] %u != %u", assocperssubentmanager->unknown_bl7, unknown_bl7); error++;
      }
    unknown_bl7++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7", &unknown_bl7) &&
        unknown_bl7 == assocperssubentmanager->unknown_bl7)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] set+1 %u", unknown_bl7);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl7, unknown_bl7); error++;
      }
    assocperssubentmanager->unknown_bl7--;

  }
  {
    BITCODE_BL unknown_bl7a;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7a", &unknown_bl7a, NULL) &&
        unknown_bl7a == assocperssubentmanager->unknown_bl7a)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] %u", unknown_bl7a);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] %u != %u", assocperssubentmanager->unknown_bl7a, unknown_bl7a); error++;
      }
    unknown_bl7a++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7a", &unknown_bl7a) &&
        unknown_bl7a == assocperssubentmanager->unknown_bl7a)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] set+1 %u", unknown_bl7a);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl7a, unknown_bl7a); error++;
      }
    assocperssubentmanager->unknown_bl7a--;

  }
  {
    BITCODE_BL unknown_bl8;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl8", &unknown_bl8, NULL) &&
        unknown_bl8 == assocperssubentmanager->unknown_bl8)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] %u", unknown_bl8);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] %u != %u", assocperssubentmanager->unknown_bl8, unknown_bl8); error++;
      }
    unknown_bl8++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl8", &unknown_bl8) &&
        unknown_bl8 == assocperssubentmanager->unknown_bl8)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] set+1 %u", unknown_bl8);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl8, unknown_bl8); error++;
      }
    assocperssubentmanager->unknown_bl8--;

  }
  {
    BITCODE_BL unknown_bl9;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl9", &unknown_bl9, NULL) &&
        unknown_bl9 == assocperssubentmanager->unknown_bl9)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] %u", unknown_bl9);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] %u != %u", assocperssubentmanager->unknown_bl9, unknown_bl9); error++;
      }
    unknown_bl9++;
    if (dwg_dynapi_entity_set_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl9", &unknown_bl9) &&
        unknown_bl9 == assocperssubentmanager->unknown_bl9)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] set+1 %u", unknown_bl9);
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl9, unknown_bl9); error++;
      }
    assocperssubentmanager->unknown_bl9--;

  }
  return error;
}
static int test_ASSOCPLANESURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCPLANESURFACEACTIONBODY *assocplanesurfaceactionbody = obj->tio.object->tio.ASSOCPLANESURFACEACTIONBODY;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "aab_status", &aab_status, NULL) &&
        aab_status == assocplanesurfaceactionbody->aab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.aab_status [BL] %u", aab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.aab_status [BL] %u != %u", assocplanesurfaceactionbody->aab_status, aab_status); error++;
      }
    aab_status++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "aab_status", &aab_status) &&
        aab_status == assocplanesurfaceactionbody->aab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.aab_status [BL] set+1 %u", aab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.aab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->aab_status, aab_status); error++;
      }
    assocplanesurfaceactionbody->aab_status--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &assocplanesurfaceactionbody->ownerhandle, sizeof(assocplanesurfaceactionbody->ownerhandle)))
      pass ("ASSOCPLANESURFACEACTIONBODY.ownerhandle [H]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.ownerhandle [H]"); error++;
      }
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l2", &pab_l2, NULL) &&
        pab_l2 == assocplanesurfaceactionbody->pab_l2)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l2 [BL] %u", pab_l2);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l2 [BL] %u != %u", assocplanesurfaceactionbody->pab_l2, pab_l2); error++;
      }
    pab_l2++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l2", &pab_l2) &&
        pab_l2 == assocplanesurfaceactionbody->pab_l2)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l2 [BL] set+1 %u", pab_l2);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l2 [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_l2, pab_l2); error++;
      }
    assocplanesurfaceactionbody->pab_l2--;

  }
  {
    BITCODE_BL pab_l3;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l3", &pab_l3, NULL) &&
        pab_l3 == assocplanesurfaceactionbody->pab_l3)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l3 [BL] %u", pab_l3);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l3 [BL] %u != %u", assocplanesurfaceactionbody->pab_l3, pab_l3); error++;
      }
    pab_l3++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l3", &pab_l3) &&
        pab_l3 == assocplanesurfaceactionbody->pab_l3)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l3 [BL] set+1 %u", pab_l3);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l3 [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_l3, pab_l3); error++;
      }
    assocplanesurfaceactionbody->pab_l3--;

  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l4", &pab_l4, NULL) &&
        pab_l4 == assocplanesurfaceactionbody->pab_l4)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l4 [BL] %u", pab_l4);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l4 [BL] %u != %u", assocplanesurfaceactionbody->pab_l4, pab_l4); error++;
      }
    pab_l4++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l4", &pab_l4) &&
        pab_l4 == assocplanesurfaceactionbody->pab_l4)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l4 [BL] set+1 %u", pab_l4);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l4 [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_l4, pab_l4); error++;
      }
    assocplanesurfaceactionbody->pab_l4--;

  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l5", &pab_l5, NULL) &&
        pab_l5 == assocplanesurfaceactionbody->pab_l5)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l5 [BL] %u", pab_l5);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l5 [BL] %u != %u", assocplanesurfaceactionbody->pab_l5, pab_l5); error++;
      }
    pab_l5++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l5", &pab_l5) &&
        pab_l5 == assocplanesurfaceactionbody->pab_l5)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l5 [BL] set+1 %u", pab_l5);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l5 [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_l5, pab_l5); error++;
      }
    assocplanesurfaceactionbody->pab_l5--;

  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_status", &pab_status, NULL) &&
        pab_status == assocplanesurfaceactionbody->pab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_status [BL] %u", pab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_status [BL] %u != %u", assocplanesurfaceactionbody->pab_status, pab_status); error++;
      }
    pab_status++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_status", &pab_status) &&
        pab_status == assocplanesurfaceactionbody->pab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_status [BL] set+1 %u", pab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_status, pab_status); error++;
      }
    assocplanesurfaceactionbody->pab_status--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp(&parent, &assocplanesurfaceactionbody->parent, sizeof(assocplanesurfaceactionbody->parent)))
      pass ("ASSOCPLANESURFACEACTIONBODY.parent [struct _dwg_object_object*]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL) &&
        pbsab_status == assocplanesurfaceactionbody->pbsab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] %u", pbsab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocplanesurfaceactionbody->pbsab_status, pbsab_status); error++;
      }
    pbsab_status++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pbsab_status", &pbsab_status) &&
        pbsab_status == assocplanesurfaceactionbody->pbsab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] set+1 %u", pbsab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->pbsab_status, pbsab_status); error++;
      }
    assocplanesurfaceactionbody->pbsab_status--;

  }
  {
    BITCODE_BL psab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "psab_status", &psab_status, NULL) &&
        psab_status == assocplanesurfaceactionbody->psab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.psab_status [BL] %u", psab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.psab_status [BL] %u != %u", assocplanesurfaceactionbody->psab_status, psab_status); error++;
      }
    psab_status++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "psab_status", &psab_status) &&
        psab_status == assocplanesurfaceactionbody->psab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.psab_status [BL] set+1 %u", psab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.psab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->psab_status, psab_status); error++;
      }
    assocplanesurfaceactionbody->psab_status--;

  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "readdep", &readdep, NULL)
        && !memcmp(&readdep, &assocplanesurfaceactionbody->readdep, sizeof(assocplanesurfaceactionbody->readdep)))
      pass ("ASSOCPLANESURFACEACTIONBODY.readdep [H]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.readdep [H]"); error++;
      }
  }
  {
    BITCODE_B sab_b1;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b1", &sab_b1, NULL) &&
        sab_b1 == assocplanesurfaceactionbody->sab_b1)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_b1 [B] " FORMAT_B "", sab_b1);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_b1 [B] " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b1, sab_b1); error++;
      }
    sab_b1++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b1", &sab_b1) &&
        sab_b1 == assocplanesurfaceactionbody->sab_b1)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_b1 [B] set+1 " FORMAT_B "", sab_b1);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b1, sab_b1); error++;
      }
    assocplanesurfaceactionbody->sab_b1--;

  }
  {
    BITCODE_B sab_b2;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b2", &sab_b2, NULL) &&
        sab_b2 == assocplanesurfaceactionbody->sab_b2)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_b2 [B] " FORMAT_B "", sab_b2);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_b2 [B] " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b2, sab_b2); error++;
      }
    sab_b2++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b2", &sab_b2) &&
        sab_b2 == assocplanesurfaceactionbody->sab_b2)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_b2 [B] set+1 " FORMAT_B "", sab_b2);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b2, sab_b2); error++;
      }
    assocplanesurfaceactionbody->sab_b2--;

  }
  {
    BITCODE_BL sab_l2;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_l2", &sab_l2, NULL) &&
        sab_l2 == assocplanesurfaceactionbody->sab_l2)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_l2 [BL] %u", sab_l2);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_l2 [BL] %u != %u", assocplanesurfaceactionbody->sab_l2, sab_l2); error++;
      }
    sab_l2++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_l2", &sab_l2) &&
        sab_l2 == assocplanesurfaceactionbody->sab_l2)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_l2 [BL] set+1 %u", sab_l2);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_l2 [BL] set+1 %u != %u", assocplanesurfaceactionbody->sab_l2, sab_l2); error++;
      }
    assocplanesurfaceactionbody->sab_l2--;

  }
  {
    BITCODE_BS sab_s1;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_s1", &sab_s1, NULL) &&
        sab_s1 == assocplanesurfaceactionbody->sab_s1)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_s1 [BS] %hu", sab_s1);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_s1 [BS] %hu != %hu", assocplanesurfaceactionbody->sab_s1, sab_s1); error++;
      }
    sab_s1++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_s1", &sab_s1) &&
        sab_s1 == assocplanesurfaceactionbody->sab_s1)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_s1 [BS] set+1 %hu", sab_s1);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_s1 [BS] set+1 %hu != %hu", assocplanesurfaceactionbody->sab_s1, sab_s1); error++;
      }
    assocplanesurfaceactionbody->sab_s1--;

  }
  {
    BITCODE_BL sab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_status", &sab_status, NULL) &&
        sab_status == assocplanesurfaceactionbody->sab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_status [BL] %u", sab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_status [BL] %u != %u", assocplanesurfaceactionbody->sab_status, sab_status); error++;
      }
    sab_status++;
    if (dwg_dynapi_entity_set_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_status", &sab_status) &&
        sab_status == assocplanesurfaceactionbody->sab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_status [BL] set+1 %u", sab_status);
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->sab_status, sab_status); error++;
      }
    assocplanesurfaceactionbody->sab_status--;

  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "writedep", &writedep, NULL)
        && !memcmp(&writedep, &assocplanesurfaceactionbody->writedep, sizeof(assocplanesurfaceactionbody->writedep)))
      pass ("ASSOCPLANESURFACEACTIONBODY.writedep [H]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.writedep [H]"); error++;
      }
  }
  return error;
}
static int test_BLOCK_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_BLOCK_CONTROL *block_control = obj->tio.object->tio.BLOCK_CONTROL;
  {
    BITCODE_H block_headers;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "block_headers", &block_headers, NULL)
        && !memcmp(&block_headers, &block_control->block_headers, sizeof(block_control->block_headers)))
      pass ("BLOCK_CONTROL.block_headers [H]");
    else
      {
        fail ("BLOCK_CONTROL.block_headers [H]"); error++;
      }
  }
  {
    BITCODE_H model_space;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "model_space", &model_space, NULL)
        && !memcmp(&model_space, &block_control->model_space, sizeof(block_control->model_space)))
      pass ("BLOCK_CONTROL.model_space [H]");
    else
      {
        fail ("BLOCK_CONTROL.model_space [H]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &block_control->null_handle, sizeof(block_control->null_handle)))
      pass ("BLOCK_CONTROL.null_handle [H]");
    else
      {
        fail ("BLOCK_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == block_control->num_entries)
      pass ("BLOCK_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("BLOCK_CONTROL.num_entries [BS] %hu != %hu", block_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(block_control, "BLOCK_CONTROL", "num_entries", &num_entries) &&
        num_entries == block_control->num_entries)
      pass ("BLOCK_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("BLOCK_CONTROL.num_entries [BS] set+1 %hu != %hu", block_control->num_entries, num_entries); error++;
      }
    block_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "objid", &objid, NULL) &&
        objid == block_control->objid)
      pass ("BLOCK_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("BLOCK_CONTROL.objid [BL] %u != %u", block_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(block_control, "BLOCK_CONTROL", "objid", &objid) &&
        objid == block_control->objid)
      pass ("BLOCK_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("BLOCK_CONTROL.objid [BL] set+1 %u != %u", block_control->objid, objid); error++;
      }
    block_control->objid--;

  }
  {
    BITCODE_H paper_space;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "paper_space", &paper_space, NULL)
        && !memcmp(&paper_space, &block_control->paper_space, sizeof(block_control->paper_space)))
      pass ("BLOCK_CONTROL.paper_space [H]");
    else
      {
        fail ("BLOCK_CONTROL.paper_space [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &block_control->parent, sizeof(block_control->parent)))
      pass ("BLOCK_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("BLOCK_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &block_control->reactors, sizeof(block_control->reactors)))
      pass ("BLOCK_CONTROL.reactors [H]");
    else
      {
        fail ("BLOCK_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &block_control->xdicobjhandle, sizeof(block_control->xdicobjhandle)))
      pass ("BLOCK_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("BLOCK_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_BLOCK_HEADER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_BLOCK_HEADER *block_header = obj->tio.object->tio.BLOCK_HEADER;
  {
    BITCODE_BL __iterator;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "__iterator", &__iterator, NULL) &&
        __iterator == block_header->__iterator)
      pass ("BLOCK_HEADER.__iterator [BL] %u", __iterator);
    else
      {
        fail ("BLOCK_HEADER.__iterator [BL] %u != %u", block_header->__iterator, __iterator); error++;
      }
    __iterator++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "__iterator", &__iterator) &&
        __iterator == block_header->__iterator)
      pass ("BLOCK_HEADER.__iterator [BL] set+1 %u", __iterator);
    else
      {
        fail ("BLOCK_HEADER.__iterator [BL] set+1 %u != %u", block_header->__iterator, __iterator); error++;
      }
    block_header->__iterator--;

  }
  {
    BITCODE_B anonymous;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "anonymous", &anonymous, NULL) &&
        anonymous == block_header->anonymous)
      pass ("BLOCK_HEADER.anonymous [B] " FORMAT_B "", anonymous);
    else
      {
        fail ("BLOCK_HEADER.anonymous [B] " FORMAT_B " != " FORMAT_B "", block_header->anonymous, anonymous); error++;
      }
    anonymous++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "anonymous", &anonymous) &&
        anonymous == block_header->anonymous)
      pass ("BLOCK_HEADER.anonymous [B] set+1 " FORMAT_B "", anonymous);
    else
      {
        fail ("BLOCK_HEADER.anonymous [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->anonymous, anonymous); error++;
      }
    block_header->anonymous--;

  }
  {
    BITCODE_3DPOINT base_pt;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "base_pt", &base_pt, NULL)
        && !memcmp(&base_pt, &block_header->base_pt, sizeof(block_header->base_pt)))
      pass ("BLOCK_HEADER.base_pt [3DPOINT]");
    else
      {
        fail ("BLOCK_HEADER.base_pt [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_B blkisxref;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "blkisxref", &blkisxref, NULL) &&
        blkisxref == block_header->blkisxref)
      pass ("BLOCK_HEADER.blkisxref [B] " FORMAT_B "", blkisxref);
    else
      {
        fail ("BLOCK_HEADER.blkisxref [B] " FORMAT_B " != " FORMAT_B "", block_header->blkisxref, blkisxref); error++;
      }
    blkisxref++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "blkisxref", &blkisxref) &&
        blkisxref == block_header->blkisxref)
      pass ("BLOCK_HEADER.blkisxref [B] set+1 " FORMAT_B "", blkisxref);
    else
      {
        fail ("BLOCK_HEADER.blkisxref [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->blkisxref, blkisxref); error++;
      }
    block_header->blkisxref--;

  }
  {
    BITCODE_H block_control;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "block_control", &block_control, NULL)
        && !memcmp(&block_control, &block_header->block_control, sizeof(block_header->block_control)))
      pass ("BLOCK_HEADER.block_control [H]");
    else
      {
        fail ("BLOCK_HEADER.block_control [H]"); error++;
      }
  }
  {
    BITCODE_H block_entity;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "block_entity", &block_entity, NULL)
        && !memcmp(&block_entity, &block_header->block_entity, sizeof(block_header->block_entity)))
      pass ("BLOCK_HEADER.block_entity [H]");
    else
      {
        fail ("BLOCK_HEADER.block_entity [H]"); error++;
      }
  }
  {
    BITCODE_RC block_scaling;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "block_scaling", &block_scaling, NULL) &&
        block_scaling == block_header->block_scaling)
      pass ("BLOCK_HEADER.block_scaling [RC] %u", block_scaling);
    else
      {
        fail ("BLOCK_HEADER.block_scaling [RC] %u != %u", block_header->block_scaling, block_scaling); error++;
      }
    block_scaling++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "block_scaling", &block_scaling) &&
        block_scaling == block_header->block_scaling)
      pass ("BLOCK_HEADER.block_scaling [RC] set+1 %u", block_scaling);
    else
      {
        fail ("BLOCK_HEADER.block_scaling [RC] set+1 %u != %u", block_header->block_scaling, block_scaling); error++;
      }
    block_header->block_scaling--;

  }
  {
    BITCODE_TV description;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "description", &description, NULL)
        && !strcmp((char*)&description, (char*)&block_header->description))
      pass ("BLOCK_HEADER.description [TV]");
    else
      {
        fail ("BLOCK_HEADER.description [TV]"); error++;
      }
  }
  {
    BITCODE_H endblk_entity;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "endblk_entity", &endblk_entity, NULL)
        && !memcmp(&endblk_entity, &block_header->endblk_entity, sizeof(block_header->endblk_entity)))
      pass ("BLOCK_HEADER.endblk_entity [H]");
    else
      {
        fail ("BLOCK_HEADER.endblk_entity [H]"); error++;
      }
  }
  {
    BITCODE_H* entities;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "entities", &entities, NULL)
        && !memcmp(&entities, &block_header->entities, sizeof(block_header->entities)))
      pass ("BLOCK_HEADER.entities [H*]");
    else
      {
        fail ("BLOCK_HEADER.entities [H*]"); error++;
      }
  }
  {
    BITCODE_B explodable;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "explodable", &explodable, NULL) &&
        explodable == block_header->explodable)
      pass ("BLOCK_HEADER.explodable [B] " FORMAT_B "", explodable);
    else
      {
        fail ("BLOCK_HEADER.explodable [B] " FORMAT_B " != " FORMAT_B "", block_header->explodable, explodable); error++;
      }
    explodable++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "explodable", &explodable) &&
        explodable == block_header->explodable)
      pass ("BLOCK_HEADER.explodable [B] set+1 " FORMAT_B "", explodable);
    else
      {
        fail ("BLOCK_HEADER.explodable [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->explodable, explodable); error++;
      }
    block_header->explodable--;

  }
  {
    BITCODE_H first_entity;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "first_entity", &first_entity, NULL)
        && !memcmp(&first_entity, &block_header->first_entity, sizeof(block_header->first_entity)))
      pass ("BLOCK_HEADER.first_entity [H]");
    else
      {
        fail ("BLOCK_HEADER.first_entity [H]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "flag", &flag, NULL) &&
        flag == block_header->flag)
      pass ("BLOCK_HEADER.flag [RC] %u", flag);
    else
      {
        fail ("BLOCK_HEADER.flag [RC] %u != %u", block_header->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "flag", &flag) &&
        flag == block_header->flag)
      pass ("BLOCK_HEADER.flag [RC] set+1 %u", flag);
    else
      {
        fail ("BLOCK_HEADER.flag [RC] set+1 %u != %u", block_header->flag, flag); error++;
      }
    block_header->flag--;

  }
  {
    BITCODE_RC flag2;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "flag2", &flag2, NULL) &&
        flag2 == block_header->flag2)
      pass ("BLOCK_HEADER.flag2 [RC] %u", flag2);
    else
      {
        fail ("BLOCK_HEADER.flag2 [RC] %u != %u", block_header->flag2, flag2); error++;
      }
    flag2++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "flag2", &flag2) &&
        flag2 == block_header->flag2)
      pass ("BLOCK_HEADER.flag2 [RC] set+1 %u", flag2);
    else
      {
        fail ("BLOCK_HEADER.flag2 [RC] set+1 %u != %u", block_header->flag2, flag2); error++;
      }
    block_header->flag2--;

  }
  {
    BITCODE_RS flag3;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "flag3", &flag3, NULL) &&
        flag3 == block_header->flag3)
      pass ("BLOCK_HEADER.flag3 [RS] %hu", flag3);
    else
      {
        fail ("BLOCK_HEADER.flag3 [RS] %hu != %hu", block_header->flag3, flag3); error++;
      }
    flag3++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "flag3", &flag3) &&
        flag3 == block_header->flag3)
      pass ("BLOCK_HEADER.flag3 [RS] set+1 %hu", flag3);
    else
      {
        fail ("BLOCK_HEADER.flag3 [RS] set+1 %hu != %hu", block_header->flag3, flag3); error++;
      }
    block_header->flag3--;

  }
  {
    BITCODE_B hasattrs;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "hasattrs", &hasattrs, NULL) &&
        hasattrs == block_header->hasattrs)
      pass ("BLOCK_HEADER.hasattrs [B] " FORMAT_B "", hasattrs);
    else
      {
        fail ("BLOCK_HEADER.hasattrs [B] " FORMAT_B " != " FORMAT_B "", block_header->hasattrs, hasattrs); error++;
      }
    hasattrs++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "hasattrs", &hasattrs) &&
        hasattrs == block_header->hasattrs)
      pass ("BLOCK_HEADER.hasattrs [B] set+1 " FORMAT_B "", hasattrs);
    else
      {
        fail ("BLOCK_HEADER.hasattrs [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->hasattrs, hasattrs); error++;
      }
    block_header->hasattrs--;

  }
  {
    BITCODE_H* insert_handles;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "insert_handles", &insert_handles, NULL)
        && !memcmp(&insert_handles, &block_header->insert_handles, sizeof(block_header->insert_handles)))
      pass ("BLOCK_HEADER.insert_handles [H*]");
    else
      {
        fail ("BLOCK_HEADER.insert_handles [H*]"); error++;
      }
  }
  {
    BITCODE_BS insert_units;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "insert_units", &insert_units, NULL) &&
        insert_units == block_header->insert_units)
      pass ("BLOCK_HEADER.insert_units [BS] %hu", insert_units);
    else
      {
        fail ("BLOCK_HEADER.insert_units [BS] %hu != %hu", block_header->insert_units, insert_units); error++;
      }
    insert_units++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "insert_units", &insert_units) &&
        insert_units == block_header->insert_units)
      pass ("BLOCK_HEADER.insert_units [BS] set+1 %hu", insert_units);
    else
      {
        fail ("BLOCK_HEADER.insert_units [BS] set+1 %hu != %hu", block_header->insert_units, insert_units); error++;
      }
    block_header->insert_units--;

  }
  {
    BITCODE_H last_entity;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "last_entity", &last_entity, NULL)
        && !memcmp(&last_entity, &block_header->last_entity, sizeof(block_header->last_entity)))
      pass ("BLOCK_HEADER.last_entity [H]");
    else
      {
        fail ("BLOCK_HEADER.last_entity [H]"); error++;
      }
  }
  {
    BITCODE_H layout_handle;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "layout_handle", &layout_handle, NULL)
        && !memcmp(&layout_handle, &block_header->layout_handle, sizeof(block_header->layout_handle)))
      pass ("BLOCK_HEADER.layout_handle [H]");
    else
      {
        fail ("BLOCK_HEADER.layout_handle [H]"); error++;
      }
  }
  {
    BITCODE_B loaded_bit;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "loaded_bit", &loaded_bit, NULL) &&
        loaded_bit == block_header->loaded_bit)
      pass ("BLOCK_HEADER.loaded_bit [B] " FORMAT_B "", loaded_bit);
    else
      {
        fail ("BLOCK_HEADER.loaded_bit [B] " FORMAT_B " != " FORMAT_B "", block_header->loaded_bit, loaded_bit); error++;
      }
    loaded_bit++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "loaded_bit", &loaded_bit) &&
        loaded_bit == block_header->loaded_bit)
      pass ("BLOCK_HEADER.loaded_bit [B] set+1 " FORMAT_B "", loaded_bit);
    else
      {
        fail ("BLOCK_HEADER.loaded_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->loaded_bit, loaded_bit); error++;
      }
    block_header->loaded_bit--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&block_header->name))
      pass ("BLOCK_HEADER.name [TV]");
    else
      {
        fail ("BLOCK_HEADER.name [TV]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &block_header->null_handle, sizeof(block_header->null_handle)))
      pass ("BLOCK_HEADER.null_handle [H]");
    else
      {
        fail ("BLOCK_HEADER.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_RL num_inserts;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "num_inserts", &num_inserts, NULL) &&
        num_inserts == block_header->num_inserts)
      pass ("BLOCK_HEADER.num_inserts [RL] %u", num_inserts);
    else
      {
        fail ("BLOCK_HEADER.num_inserts [RL] %u != %u", block_header->num_inserts, num_inserts); error++;
      }
    num_inserts++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "num_inserts", &num_inserts) &&
        num_inserts == block_header->num_inserts)
      pass ("BLOCK_HEADER.num_inserts [RL] set+1 %u", num_inserts);
    else
      {
        fail ("BLOCK_HEADER.num_inserts [RL] set+1 %u != %u", block_header->num_inserts, num_inserts); error++;
      }
    block_header->num_inserts--;

  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "num_owned", &num_owned, NULL) &&
        num_owned == block_header->num_owned)
      pass ("BLOCK_HEADER.num_owned [BL] %u", num_owned);
    else
      {
        fail ("BLOCK_HEADER.num_owned [BL] %u != %u", block_header->num_owned, num_owned); error++;
      }
    num_owned++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "num_owned", &num_owned) &&
        num_owned == block_header->num_owned)
      pass ("BLOCK_HEADER.num_owned [BL] set+1 %u", num_owned);
    else
      {
        fail ("BLOCK_HEADER.num_owned [BL] set+1 %u != %u", block_header->num_owned, num_owned); error++;
      }
    block_header->num_owned--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "parent", &parent, NULL)
        && !memcmp(&parent, &block_header->parent, sizeof(block_header->parent)))
      pass ("BLOCK_HEADER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("BLOCK_HEADER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_TV preview_data;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "preview_data", &preview_data, NULL)
        && !strcmp((char*)&preview_data, (char*)&block_header->preview_data))
      pass ("BLOCK_HEADER.preview_data [TV]");
    else
      {
        fail ("BLOCK_HEADER.preview_data [TV]"); error++;
      }
  }
  {
    BITCODE_BL preview_data_size;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "preview_data_size", &preview_data_size, NULL) &&
        preview_data_size == block_header->preview_data_size)
      pass ("BLOCK_HEADER.preview_data_size [BL] %u", preview_data_size);
    else
      {
        fail ("BLOCK_HEADER.preview_data_size [BL] %u != %u", block_header->preview_data_size, preview_data_size); error++;
      }
    preview_data_size++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "preview_data_size", &preview_data_size) &&
        preview_data_size == block_header->preview_data_size)
      pass ("BLOCK_HEADER.preview_data_size [BL] set+1 %u", preview_data_size);
    else
      {
        fail ("BLOCK_HEADER.preview_data_size [BL] set+1 %u != %u", block_header->preview_data_size, preview_data_size); error++;
      }
    block_header->preview_data_size--;

  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "used", &used, NULL) &&
        used == block_header->used)
      pass ("BLOCK_HEADER.used [RS] %hu", used);
    else
      {
        fail ("BLOCK_HEADER.used [RS] %hu != %hu", block_header->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "used", &used) &&
        used == block_header->used)
      pass ("BLOCK_HEADER.used [RS] set+1 %hu", used);
    else
      {
        fail ("BLOCK_HEADER.used [RS] set+1 %hu != %hu", block_header->used, used); error++;
      }
    block_header->used--;

  }
  {
    BITCODE_TV xref_pname;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xref_pname", &xref_pname, NULL)
        && !strcmp((char*)&xref_pname, (char*)&block_header->xref_pname))
      pass ("BLOCK_HEADER.xref_pname [TV]");
    else
      {
        fail ("BLOCK_HEADER.xref_pname [TV]"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xrefdep", &xrefdep, NULL) &&
        xrefdep == block_header->xrefdep)
      pass ("BLOCK_HEADER.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("BLOCK_HEADER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "xrefdep", &xrefdep) &&
        xrefdep == block_header->xrefdep)
      pass ("BLOCK_HEADER.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("BLOCK_HEADER.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->xrefdep, xrefdep); error++;
      }
    block_header->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == block_header->xrefindex_plus1)
      pass ("BLOCK_HEADER.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("BLOCK_HEADER.xrefindex_plus1 [BS] %hu != %hu", block_header->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == block_header->xrefindex_plus1)
      pass ("BLOCK_HEADER.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("BLOCK_HEADER.xrefindex_plus1 [BS] set+1 %hu != %hu", block_header->xrefindex_plus1, xrefindex_plus1); error++;
      }
    block_header->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefoverlaid;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xrefoverlaid", &xrefoverlaid, NULL) &&
        xrefoverlaid == block_header->xrefoverlaid)
      pass ("BLOCK_HEADER.xrefoverlaid [B] " FORMAT_B "", xrefoverlaid);
    else
      {
        fail ("BLOCK_HEADER.xrefoverlaid [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefoverlaid, xrefoverlaid); error++;
      }
    xrefoverlaid++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "xrefoverlaid", &xrefoverlaid) &&
        xrefoverlaid == block_header->xrefoverlaid)
      pass ("BLOCK_HEADER.xrefoverlaid [B] set+1 " FORMAT_B "", xrefoverlaid);
    else
      {
        fail ("BLOCK_HEADER.xrefoverlaid [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->xrefoverlaid, xrefoverlaid); error++;
      }
    block_header->xrefoverlaid--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xrefref", &xrefref, NULL) &&
        xrefref == block_header->xrefref)
      pass ("BLOCK_HEADER.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("BLOCK_HEADER.xrefref [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(block_header, "BLOCK_HEADER", "xrefref", &xrefref) &&
        xrefref == block_header->xrefref)
      pass ("BLOCK_HEADER.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("BLOCK_HEADER.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->xrefref, xrefref); error++;
      }
    block_header->xrefref--;

  }
  return error;
}
static int test_CELLSTYLEMAP (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_CELLSTYLEMAP *cellstylemap = obj->tio.object->tio.CELLSTYLEMAP;
  {
    Dwg_CELLSTYLEMAP_Cell* cells;
    if (dwg_dynapi_entity_value(cellstylemap, "CELLSTYLEMAP", "cells", &cells, NULL)
        && !memcmp(&cells, &cellstylemap->cells, sizeof(cellstylemap->cells)))
      pass ("CELLSTYLEMAP.cells [Dwg_CELLSTYLEMAP_Cell*]");
    else
      {
        fail ("CELLSTYLEMAP.cells [Dwg_CELLSTYLEMAP_Cell*]"); error++;
      }
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value(cellstylemap, "CELLSTYLEMAP", "num_cells", &num_cells, NULL) &&
        num_cells == cellstylemap->num_cells)
      pass ("CELLSTYLEMAP.num_cells [BL] %u", num_cells);
    else
      {
        fail ("CELLSTYLEMAP.num_cells [BL] %u != %u", cellstylemap->num_cells, num_cells); error++;
      }
    num_cells++;
    if (dwg_dynapi_entity_set_value(cellstylemap, "CELLSTYLEMAP", "num_cells", &num_cells) &&
        num_cells == cellstylemap->num_cells)
      pass ("CELLSTYLEMAP.num_cells [BL] set+1 %u", num_cells);
    else
      {
        fail ("CELLSTYLEMAP.num_cells [BL] set+1 %u != %u", cellstylemap->num_cells, num_cells); error++;
      }
    cellstylemap->num_cells--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(cellstylemap, "CELLSTYLEMAP", "parent", &parent, NULL)
        && !memcmp(&parent, &cellstylemap->parent, sizeof(cellstylemap->parent)))
      pass ("CELLSTYLEMAP.parent [struct _dwg_object_object*]");
    else
      {
        fail ("CELLSTYLEMAP.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_DATATABLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DATATABLE *datatable = obj->tio.object->tio.DATATABLE;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(datatable, "DATATABLE", "parent", &parent, NULL)
        && !memcmp(&parent, &datatable->parent, sizeof(datatable->parent)))
      pass ("DATATABLE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DATATABLE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_DBCOLOR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DBCOLOR *dbcolor = obj->tio.object->tio.DBCOLOR;
  {
    BITCODE_T catalog;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "catalog", &catalog, NULL)
        && !memcmp(&catalog, &dbcolor->catalog, sizeof(dbcolor->catalog)))
      pass ("DBCOLOR.catalog [T]");
    else
      {
        fail ("DBCOLOR.catalog [T]"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "class_version", &class_version, NULL) &&
        class_version == dbcolor->class_version)
      pass ("DBCOLOR.class_version [BL] %u", class_version);
    else
      {
        fail ("DBCOLOR.class_version [BL] %u != %u", dbcolor->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(dbcolor, "DBCOLOR", "class_version", &class_version) &&
        class_version == dbcolor->class_version)
      pass ("DBCOLOR.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("DBCOLOR.class_version [BL] set+1 %u != %u", dbcolor->class_version, class_version); error++;
      }
    dbcolor->class_version--;

  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "name", &name, NULL)
        && !memcmp(&name, &dbcolor->name, sizeof(dbcolor->name)))
      pass ("DBCOLOR.name [T]");
    else
      {
        fail ("DBCOLOR.name [T]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &dbcolor->ownerhandle, sizeof(dbcolor->ownerhandle)))
      pass ("DBCOLOR.ownerhandle [H]");
    else
      {
        fail ("DBCOLOR.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "parent", &parent, NULL)
        && !memcmp(&parent, &dbcolor->parent, sizeof(dbcolor->parent)))
      pass ("DBCOLOR.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DBCOLOR.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_RL rgb;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "rgb", &rgb, NULL) &&
        rgb == dbcolor->rgb)
      pass ("DBCOLOR.rgb [RL] %u", rgb);
    else
      {
        fail ("DBCOLOR.rgb [RL] %u != %u", dbcolor->rgb, rgb); error++;
      }
    rgb++;
    if (dwg_dynapi_entity_set_value(dbcolor, "DBCOLOR", "rgb", &rgb) &&
        rgb == dbcolor->rgb)
      pass ("DBCOLOR.rgb [RL] set+1 %u", rgb);
    else
      {
        fail ("DBCOLOR.rgb [RL] set+1 %u != %u", dbcolor->rgb, rgb); error++;
      }
    dbcolor->rgb--;

  }
  {
    BITCODE_BB unknown1;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "unknown1", &unknown1, NULL) &&
        unknown1 == dbcolor->unknown1)
      pass ("DBCOLOR.unknown1 [BB] " FORMAT_BB "", unknown1);
    else
      {
        fail ("DBCOLOR.unknown1 [BB] " FORMAT_BB " != " FORMAT_BB "", dbcolor->unknown1, unknown1); error++;
      }
    unknown1++;
    if (dwg_dynapi_entity_set_value(dbcolor, "DBCOLOR", "unknown1", &unknown1) &&
        unknown1 == dbcolor->unknown1)
      pass ("DBCOLOR.unknown1 [BB] set+1 " FORMAT_BB "", unknown1);
    else
      {
        fail ("DBCOLOR.unknown1 [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", dbcolor->unknown1, unknown1); error++;
      }
    dbcolor->unknown1--;

  }
  {
    BITCODE_RC unknown2;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "unknown2", &unknown2, NULL) &&
        unknown2 == dbcolor->unknown2)
      pass ("DBCOLOR.unknown2 [RC] %u", unknown2);
    else
      {
        fail ("DBCOLOR.unknown2 [RC] %u != %u", dbcolor->unknown2, unknown2); error++;
      }
    unknown2++;
    if (dwg_dynapi_entity_set_value(dbcolor, "DBCOLOR", "unknown2", &unknown2) &&
        unknown2 == dbcolor->unknown2)
      pass ("DBCOLOR.unknown2 [RC] set+1 %u", unknown2);
    else
      {
        fail ("DBCOLOR.unknown2 [RC] set+1 %u != %u", dbcolor->unknown2, unknown2); error++;
      }
    dbcolor->unknown2--;

  }
  return error;
}
static int test_DICTIONARY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DICTIONARY *dictionary = obj->tio.object->tio.DICTIONARY;
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "cloning", &cloning, NULL) &&
        cloning == dictionary->cloning)
      pass ("DICTIONARY.cloning [BS] %hu", cloning);
    else
      {
        fail ("DICTIONARY.cloning [BS] %hu != %hu", dictionary->cloning, cloning); error++;
      }
    cloning++;
    if (dwg_dynapi_entity_set_value(dictionary, "DICTIONARY", "cloning", &cloning) &&
        cloning == dictionary->cloning)
      pass ("DICTIONARY.cloning [BS] set+1 %hu", cloning);
    else
      {
        fail ("DICTIONARY.cloning [BS] set+1 %hu != %hu", dictionary->cloning, cloning); error++;
      }
    dictionary->cloning--;

  }
  {
    BITCODE_RC hard_owner;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "hard_owner", &hard_owner, NULL) &&
        hard_owner == dictionary->hard_owner)
      pass ("DICTIONARY.hard_owner [RC] %u", hard_owner);
    else
      {
        fail ("DICTIONARY.hard_owner [RC] %u != %u", dictionary->hard_owner, hard_owner); error++;
      }
    hard_owner++;
    if (dwg_dynapi_entity_set_value(dictionary, "DICTIONARY", "hard_owner", &hard_owner) &&
        hard_owner == dictionary->hard_owner)
      pass ("DICTIONARY.hard_owner [RC] set+1 %u", hard_owner);
    else
      {
        fail ("DICTIONARY.hard_owner [RC] set+1 %u != %u", dictionary->hard_owner, hard_owner); error++;
      }
    dictionary->hard_owner--;

  }
  {
    BITCODE_H* itemhandles;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "itemhandles", &itemhandles, NULL)
        && !memcmp(&itemhandles, &dictionary->itemhandles, sizeof(dictionary->itemhandles)))
      pass ("DICTIONARY.itemhandles [H*]");
    else
      {
        fail ("DICTIONARY.itemhandles [H*]"); error++;
      }
  }
  {
    BITCODE_BL numitems;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "numitems", &numitems, NULL) &&
        numitems == dictionary->numitems)
      pass ("DICTIONARY.numitems [BL] %u", numitems);
    else
      {
        fail ("DICTIONARY.numitems [BL] %u != %u", dictionary->numitems, numitems); error++;
      }
    numitems++;
    if (dwg_dynapi_entity_set_value(dictionary, "DICTIONARY", "numitems", &numitems) &&
        numitems == dictionary->numitems)
      pass ("DICTIONARY.numitems [BL] set+1 %u", numitems);
    else
      {
        fail ("DICTIONARY.numitems [BL] set+1 %u != %u", dictionary->numitems, numitems); error++;
      }
    dictionary->numitems--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &dictionary->ownerhandle, sizeof(dictionary->ownerhandle)))
      pass ("DICTIONARY.ownerhandle [H]");
    else
      {
        fail ("DICTIONARY.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "parent", &parent, NULL)
        && !memcmp(&parent, &dictionary->parent, sizeof(dictionary->parent)))
      pass ("DICTIONARY.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DICTIONARY.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_TV* text;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "text", &text, NULL)
        && !memcmp(&text, &dictionary->text, sizeof(dictionary->text)))
      pass ("DICTIONARY.text [TV*]");
    else
      {
        fail ("DICTIONARY.text [TV*]"); error++;
      }
  }
  {
    BITCODE_RC unknown_r14;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "unknown_r14", &unknown_r14, NULL) &&
        unknown_r14 == dictionary->unknown_r14)
      pass ("DICTIONARY.unknown_r14 [RC] %u", unknown_r14);
    else
      {
        fail ("DICTIONARY.unknown_r14 [RC] %u != %u", dictionary->unknown_r14, unknown_r14); error++;
      }
    unknown_r14++;
    if (dwg_dynapi_entity_set_value(dictionary, "DICTIONARY", "unknown_r14", &unknown_r14) &&
        unknown_r14 == dictionary->unknown_r14)
      pass ("DICTIONARY.unknown_r14 [RC] set+1 %u", unknown_r14);
    else
      {
        fail ("DICTIONARY.unknown_r14 [RC] set+1 %u != %u", dictionary->unknown_r14, unknown_r14); error++;
      }
    dictionary->unknown_r14--;

  }
  return error;
}
static int test_DICTIONARYVAR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DICTIONARYVAR *dictionaryvar = obj->tio.object->tio.DICTIONARYVAR;
  {
    BITCODE_RC intval;
    if (dwg_dynapi_entity_value(dictionaryvar, "DICTIONARYVAR", "intval", &intval, NULL) &&
        intval == dictionaryvar->intval)
      pass ("DICTIONARYVAR.intval [RC] %u", intval);
    else
      {
        fail ("DICTIONARYVAR.intval [RC] %u != %u", dictionaryvar->intval, intval); error++;
      }
    intval++;
    if (dwg_dynapi_entity_set_value(dictionaryvar, "DICTIONARYVAR", "intval", &intval) &&
        intval == dictionaryvar->intval)
      pass ("DICTIONARYVAR.intval [RC] set+1 %u", intval);
    else
      {
        fail ("DICTIONARYVAR.intval [RC] set+1 %u != %u", dictionaryvar->intval, intval); error++;
      }
    dictionaryvar->intval--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dictionaryvar, "DICTIONARYVAR", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &dictionaryvar->ownerhandle, sizeof(dictionaryvar->ownerhandle)))
      pass ("DICTIONARYVAR.ownerhandle [H]");
    else
      {
        fail ("DICTIONARYVAR.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dictionaryvar, "DICTIONARYVAR", "parent", &parent, NULL)
        && !memcmp(&parent, &dictionaryvar->parent, sizeof(dictionaryvar->parent)))
      pass ("DICTIONARYVAR.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DICTIONARYVAR.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_TV str;
    if (dwg_dynapi_entity_value(dictionaryvar, "DICTIONARYVAR", "str", &str, NULL)
        && !strcmp((char*)&str, (char*)&dictionaryvar->str))
      pass ("DICTIONARYVAR.str [TV]");
    else
      {
        fail ("DICTIONARYVAR.str [TV]"); error++;
      }
  }
  return error;
}
static int test_DICTIONARYWDFLT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DICTIONARYWDFLT *dictionarywdflt = obj->tio.object->tio.DICTIONARYWDFLT;
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "cloning", &cloning, NULL) &&
        cloning == dictionarywdflt->cloning)
      pass ("DICTIONARYWDFLT.cloning [BS] %hu", cloning);
    else
      {
        fail ("DICTIONARYWDFLT.cloning [BS] %hu != %hu", dictionarywdflt->cloning, cloning); error++;
      }
    cloning++;
    if (dwg_dynapi_entity_set_value(dictionarywdflt, "DICTIONARYWDFLT", "cloning", &cloning) &&
        cloning == dictionarywdflt->cloning)
      pass ("DICTIONARYWDFLT.cloning [BS] set+1 %hu", cloning);
    else
      {
        fail ("DICTIONARYWDFLT.cloning [BS] set+1 %hu != %hu", dictionarywdflt->cloning, cloning); error++;
      }
    dictionarywdflt->cloning--;

  }
  {
    BITCODE_RL cloning_rl;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "cloning_rl", &cloning_rl, NULL) &&
        cloning_rl == dictionarywdflt->cloning_rl)
      pass ("DICTIONARYWDFLT.cloning_rl [RL] %u", cloning_rl);
    else
      {
        fail ("DICTIONARYWDFLT.cloning_rl [RL] %u != %u", dictionarywdflt->cloning_rl, cloning_rl); error++;
      }
    cloning_rl++;
    if (dwg_dynapi_entity_set_value(dictionarywdflt, "DICTIONARYWDFLT", "cloning_rl", &cloning_rl) &&
        cloning_rl == dictionarywdflt->cloning_rl)
      pass ("DICTIONARYWDFLT.cloning_rl [RL] set+1 %u", cloning_rl);
    else
      {
        fail ("DICTIONARYWDFLT.cloning_rl [RL] set+1 %u != %u", dictionarywdflt->cloning_rl, cloning_rl); error++;
      }
    dictionarywdflt->cloning_rl--;

  }
  {
    BITCODE_H defaultid;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "defaultid", &defaultid, NULL)
        && !memcmp(&defaultid, &dictionarywdflt->defaultid, sizeof(dictionarywdflt->defaultid)))
      pass ("DICTIONARYWDFLT.defaultid [H]");
    else
      {
        fail ("DICTIONARYWDFLT.defaultid [H]"); error++;
      }
  }
  {
    BITCODE_RC hard_owner;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "hard_owner", &hard_owner, NULL) &&
        hard_owner == dictionarywdflt->hard_owner)
      pass ("DICTIONARYWDFLT.hard_owner [RC] %u", hard_owner);
    else
      {
        fail ("DICTIONARYWDFLT.hard_owner [RC] %u != %u", dictionarywdflt->hard_owner, hard_owner); error++;
      }
    hard_owner++;
    if (dwg_dynapi_entity_set_value(dictionarywdflt, "DICTIONARYWDFLT", "hard_owner", &hard_owner) &&
        hard_owner == dictionarywdflt->hard_owner)
      pass ("DICTIONARYWDFLT.hard_owner [RC] set+1 %u", hard_owner);
    else
      {
        fail ("DICTIONARYWDFLT.hard_owner [RC] set+1 %u != %u", dictionarywdflt->hard_owner, hard_owner); error++;
      }
    dictionarywdflt->hard_owner--;

  }
  {
    BITCODE_H* itemhandles;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "itemhandles", &itemhandles, NULL)
        && !memcmp(&itemhandles, &dictionarywdflt->itemhandles, sizeof(dictionarywdflt->itemhandles)))
      pass ("DICTIONARYWDFLT.itemhandles [H*]");
    else
      {
        fail ("DICTIONARYWDFLT.itemhandles [H*]"); error++;
      }
  }
  {
    BITCODE_BL numitems;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "numitems", &numitems, NULL) &&
        numitems == dictionarywdflt->numitems)
      pass ("DICTIONARYWDFLT.numitems [BL] %u", numitems);
    else
      {
        fail ("DICTIONARYWDFLT.numitems [BL] %u != %u", dictionarywdflt->numitems, numitems); error++;
      }
    numitems++;
    if (dwg_dynapi_entity_set_value(dictionarywdflt, "DICTIONARYWDFLT", "numitems", &numitems) &&
        numitems == dictionarywdflt->numitems)
      pass ("DICTIONARYWDFLT.numitems [BL] set+1 %u", numitems);
    else
      {
        fail ("DICTIONARYWDFLT.numitems [BL] set+1 %u != %u", dictionarywdflt->numitems, numitems); error++;
      }
    dictionarywdflt->numitems--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &dictionarywdflt->ownerhandle, sizeof(dictionarywdflt->ownerhandle)))
      pass ("DICTIONARYWDFLT.ownerhandle [H]");
    else
      {
        fail ("DICTIONARYWDFLT.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "parent", &parent, NULL)
        && !memcmp(&parent, &dictionarywdflt->parent, sizeof(dictionarywdflt->parent)))
      pass ("DICTIONARYWDFLT.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DICTIONARYWDFLT.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_TV* text;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "text", &text, NULL)
        && !memcmp(&text, &dictionarywdflt->text, sizeof(dictionarywdflt->text)))
      pass ("DICTIONARYWDFLT.text [TV*]");
    else
      {
        fail ("DICTIONARYWDFLT.text [TV*]"); error++;
      }
  }
  return error;
}
static int test_DIMASSOC (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DIMASSOC *dimassoc = obj->tio.object->tio.DIMASSOC;
  {
    BITCODE_BL associativity;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "associativity", &associativity, NULL) &&
        associativity == dimassoc->associativity)
      pass ("DIMASSOC.associativity [BL] %u", associativity);
    else
      {
        fail ("DIMASSOC.associativity [BL] %u != %u", dimassoc->associativity, associativity); error++;
      }
    associativity++;
    if (dwg_dynapi_entity_set_value(dimassoc, "DIMASSOC", "associativity", &associativity) &&
        associativity == dimassoc->associativity)
      pass ("DIMASSOC.associativity [BL] set+1 %u", associativity);
    else
      {
        fail ("DIMASSOC.associativity [BL] set+1 %u != %u", dimassoc->associativity, associativity); error++;
      }
    dimassoc->associativity--;

  }
  {
    BITCODE_H dimensionobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "dimensionobj", &dimensionobj, NULL)
        && !memcmp(&dimensionobj, &dimassoc->dimensionobj, sizeof(dimassoc->dimensionobj)))
      pass ("DIMASSOC.dimensionobj [H]");
    else
      {
        fail ("DIMASSOC.dimensionobj [H]"); error++;
      }
  }
  {
    BITCODE_BL intsect_gsmarker;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "intsect_gsmarker", &intsect_gsmarker, NULL) &&
        intsect_gsmarker == dimassoc->intsect_gsmarker)
      pass ("DIMASSOC.intsect_gsmarker [BL] %u", intsect_gsmarker);
    else
      {
        fail ("DIMASSOC.intsect_gsmarker [BL] %u != %u", dimassoc->intsect_gsmarker, intsect_gsmarker); error++;
      }
    intsect_gsmarker++;
    if (dwg_dynapi_entity_set_value(dimassoc, "DIMASSOC", "intsect_gsmarker", &intsect_gsmarker) &&
        intsect_gsmarker == dimassoc->intsect_gsmarker)
      pass ("DIMASSOC.intsect_gsmarker [BL] set+1 %u", intsect_gsmarker);
    else
      {
        fail ("DIMASSOC.intsect_gsmarker [BL] set+1 %u != %u", dimassoc->intsect_gsmarker, intsect_gsmarker); error++;
      }
    dimassoc->intsect_gsmarker--;

  }
  {
    BITCODE_H intsectobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "intsectobj", &intsectobj, NULL)
        && !memcmp(&intsectobj, &dimassoc->intsectobj, sizeof(dimassoc->intsectobj)))
      pass ("DIMASSOC.intsectobj [H]");
    else
      {
        fail ("DIMASSOC.intsectobj [H]"); error++;
      }
  }
  {
    BITCODE_H intsectxrefobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "intsectxrefobj", &intsectxrefobj, NULL)
        && !memcmp(&intsectxrefobj, &dimassoc->intsectxrefobj, sizeof(dimassoc->intsectxrefobj)))
      pass ("DIMASSOC.intsectxrefobj [H]");
    else
      {
        fail ("DIMASSOC.intsectxrefobj [H]"); error++;
      }
  }
  {
    BITCODE_H mainobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "mainobj", &mainobj, NULL)
        && !memcmp(&mainobj, &dimassoc->mainobj, sizeof(dimassoc->mainobj)))
      pass ("DIMASSOC.mainobj [H]");
    else
      {
        fail ("DIMASSOC.mainobj [H]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &dimassoc->ownerhandle, sizeof(dimassoc->ownerhandle)))
      pass ("DIMASSOC.ownerhandle [H]");
    else
      {
        fail ("DIMASSOC.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "parent", &parent, NULL)
        && !memcmp(&parent, &dimassoc->parent, sizeof(dimassoc->parent)))
      pass ("DIMASSOC.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DIMASSOC.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    Dwg_DIMASSOC_Ref* ref;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "ref", &ref, NULL)
        && !memcmp(&ref, &dimassoc->ref, sizeof(dimassoc->ref)))
      pass ("DIMASSOC.ref [Dwg_DIMASSOC_Ref*]");
    else
      {
        fail ("DIMASSOC.ref [Dwg_DIMASSOC_Ref*]"); error++;
      }
  }
  {
    BITCODE_RC trans_space_flag;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "trans_space_flag", &trans_space_flag, NULL) &&
        trans_space_flag == dimassoc->trans_space_flag)
      pass ("DIMASSOC.trans_space_flag [RC] %u", trans_space_flag);
    else
      {
        fail ("DIMASSOC.trans_space_flag [RC] %u != %u", dimassoc->trans_space_flag, trans_space_flag); error++;
      }
    trans_space_flag++;
    if (dwg_dynapi_entity_set_value(dimassoc, "DIMASSOC", "trans_space_flag", &trans_space_flag) &&
        trans_space_flag == dimassoc->trans_space_flag)
      pass ("DIMASSOC.trans_space_flag [RC] set+1 %u", trans_space_flag);
    else
      {
        fail ("DIMASSOC.trans_space_flag [RC] set+1 %u != %u", dimassoc->trans_space_flag, trans_space_flag); error++;
      }
    dimassoc->trans_space_flag--;

  }
  {
    BITCODE_H xrefobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "xrefobj", &xrefobj, NULL)
        && !memcmp(&xrefobj, &dimassoc->xrefobj, sizeof(dimassoc->xrefobj)))
      pass ("DIMASSOC.xrefobj [H]");
    else
      {
        fail ("DIMASSOC.xrefobj [H]"); error++;
      }
  }
  return error;
}
static int test_DIMSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DIMSTYLE *dimstyle = obj->tio.object->tio.DIMSTYLE;
  {
    BITCODE_BS DIMADEC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMADEC", &DIMADEC, NULL) &&
        DIMADEC == dimstyle->DIMADEC)
      pass ("DIMSTYLE.DIMADEC [BS] %hu", DIMADEC);
    else
      {
        fail ("DIMSTYLE.DIMADEC [BS] %hu != %hu", dimstyle->DIMADEC, DIMADEC); error++;
      }
    DIMADEC++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMADEC", &DIMADEC) &&
        DIMADEC == dimstyle->DIMADEC)
      pass ("DIMSTYLE.DIMADEC [BS] set+1 %hu", DIMADEC);
    else
      {
        fail ("DIMSTYLE.DIMADEC [BS] set+1 %hu != %hu", dimstyle->DIMADEC, DIMADEC); error++;
      }
    dimstyle->DIMADEC--;

  }
  {
    BITCODE_B DIMALT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALT", &DIMALT, NULL) &&
        DIMALT == dimstyle->DIMALT)
      pass ("DIMSTYLE.DIMALT [B] " FORMAT_B "", DIMALT);
    else
      {
        fail ("DIMSTYLE.DIMALT [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMALT, DIMALT); error++;
      }
    DIMALT++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALT", &DIMALT) &&
        DIMALT == dimstyle->DIMALT)
      pass ("DIMSTYLE.DIMALT [B] set+1 " FORMAT_B "", DIMALT);
    else
      {
        fail ("DIMSTYLE.DIMALT [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMALT, DIMALT); error++;
      }
    dimstyle->DIMALT--;

  }
  {
    BITCODE_BS DIMALTD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTD", &DIMALTD, NULL) &&
        DIMALTD == dimstyle->DIMALTD)
      pass ("DIMSTYLE.DIMALTD [BS] %hu", DIMALTD);
    else
      {
        fail ("DIMSTYLE.DIMALTD [BS] %hu != %hu", dimstyle->DIMALTD, DIMALTD); error++;
      }
    DIMALTD++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALTD", &DIMALTD) &&
        DIMALTD == dimstyle->DIMALTD)
      pass ("DIMSTYLE.DIMALTD [BS] set+1 %hu", DIMALTD);
    else
      {
        fail ("DIMSTYLE.DIMALTD [BS] set+1 %hu != %hu", dimstyle->DIMALTD, DIMALTD); error++;
      }
    dimstyle->DIMALTD--;

  }
  {
    BITCODE_BD DIMALTF;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTF", &DIMALTF, NULL) &&
        DIMALTF == dimstyle->DIMALTF)
      pass ("DIMSTYLE.DIMALTF [BD] %g", DIMALTF);
    else
      {
        fail ("DIMSTYLE.DIMALTF [BD] %g != %g", dimstyle->DIMALTF, DIMALTF); error++;
      }
    DIMALTF++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALTF", &DIMALTF) &&
        DIMALTF == dimstyle->DIMALTF)
      pass ("DIMSTYLE.DIMALTF [BD] set+1 %g", DIMALTF);
    else
      {
        fail ("DIMSTYLE.DIMALTF [BD] set+1 %g != %g", dimstyle->DIMALTF, DIMALTF); error++;
      }
    dimstyle->DIMALTF--;

  }
  {
    BITCODE_BD DIMALTMZF;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTMZF", &DIMALTMZF, NULL) &&
        DIMALTMZF == dimstyle->DIMALTMZF)
      pass ("DIMSTYLE.DIMALTMZF [BD] %g", DIMALTMZF);
    else
      {
        fail ("DIMSTYLE.DIMALTMZF [BD] %g != %g", dimstyle->DIMALTMZF, DIMALTMZF); error++;
      }
    DIMALTMZF++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALTMZF", &DIMALTMZF) &&
        DIMALTMZF == dimstyle->DIMALTMZF)
      pass ("DIMSTYLE.DIMALTMZF [BD] set+1 %g", DIMALTMZF);
    else
      {
        fail ("DIMSTYLE.DIMALTMZF [BD] set+1 %g != %g", dimstyle->DIMALTMZF, DIMALTMZF); error++;
      }
    dimstyle->DIMALTMZF--;

  }
  {
    BITCODE_T DIMALTMZS;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTMZS", &DIMALTMZS, NULL)
        && !memcmp(&DIMALTMZS, &dimstyle->DIMALTMZS, sizeof(dimstyle->DIMALTMZS)))
      pass ("DIMSTYLE.DIMALTMZS [T]");
    else
      {
        fail ("DIMSTYLE.DIMALTMZS [T]"); error++;
      }
  }
  {
    BITCODE_BD DIMALTRND;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTRND", &DIMALTRND, NULL) &&
        DIMALTRND == dimstyle->DIMALTRND)
      pass ("DIMSTYLE.DIMALTRND [BD] %g", DIMALTRND);
    else
      {
        fail ("DIMSTYLE.DIMALTRND [BD] %g != %g", dimstyle->DIMALTRND, DIMALTRND); error++;
      }
    DIMALTRND++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALTRND", &DIMALTRND) &&
        DIMALTRND == dimstyle->DIMALTRND)
      pass ("DIMSTYLE.DIMALTRND [BD] set+1 %g", DIMALTRND);
    else
      {
        fail ("DIMSTYLE.DIMALTRND [BD] set+1 %g != %g", dimstyle->DIMALTRND, DIMALTRND); error++;
      }
    dimstyle->DIMALTRND--;

  }
  {
    BITCODE_BS DIMALTTD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTTD", &DIMALTTD, NULL) &&
        DIMALTTD == dimstyle->DIMALTTD)
      pass ("DIMSTYLE.DIMALTTD [BS] %hu", DIMALTTD);
    else
      {
        fail ("DIMSTYLE.DIMALTTD [BS] %hu != %hu", dimstyle->DIMALTTD, DIMALTTD); error++;
      }
    DIMALTTD++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALTTD", &DIMALTTD) &&
        DIMALTTD == dimstyle->DIMALTTD)
      pass ("DIMSTYLE.DIMALTTD [BS] set+1 %hu", DIMALTTD);
    else
      {
        fail ("DIMSTYLE.DIMALTTD [BS] set+1 %hu != %hu", dimstyle->DIMALTTD, DIMALTTD); error++;
      }
    dimstyle->DIMALTTD--;

  }
  {
    BITCODE_BS DIMALTTZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTTZ", &DIMALTTZ, NULL) &&
        DIMALTTZ == dimstyle->DIMALTTZ)
      pass ("DIMSTYLE.DIMALTTZ [BS] %hu", DIMALTTZ);
    else
      {
        fail ("DIMSTYLE.DIMALTTZ [BS] %hu != %hu", dimstyle->DIMALTTZ, DIMALTTZ); error++;
      }
    DIMALTTZ++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALTTZ", &DIMALTTZ) &&
        DIMALTTZ == dimstyle->DIMALTTZ)
      pass ("DIMSTYLE.DIMALTTZ [BS] set+1 %hu", DIMALTTZ);
    else
      {
        fail ("DIMSTYLE.DIMALTTZ [BS] set+1 %hu != %hu", dimstyle->DIMALTTZ, DIMALTTZ); error++;
      }
    dimstyle->DIMALTTZ--;

  }
  {
    BITCODE_BS DIMALTU;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTU", &DIMALTU, NULL) &&
        DIMALTU == dimstyle->DIMALTU)
      pass ("DIMSTYLE.DIMALTU [BS] %hu", DIMALTU);
    else
      {
        fail ("DIMSTYLE.DIMALTU [BS] %hu != %hu", dimstyle->DIMALTU, DIMALTU); error++;
      }
    DIMALTU++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALTU", &DIMALTU) &&
        DIMALTU == dimstyle->DIMALTU)
      pass ("DIMSTYLE.DIMALTU [BS] set+1 %hu", DIMALTU);
    else
      {
        fail ("DIMSTYLE.DIMALTU [BS] set+1 %hu != %hu", dimstyle->DIMALTU, DIMALTU); error++;
      }
    dimstyle->DIMALTU--;

  }
  {
    BITCODE_BS DIMALTZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTZ", &DIMALTZ, NULL) &&
        DIMALTZ == dimstyle->DIMALTZ)
      pass ("DIMSTYLE.DIMALTZ [BS] %hu", DIMALTZ);
    else
      {
        fail ("DIMSTYLE.DIMALTZ [BS] %hu != %hu", dimstyle->DIMALTZ, DIMALTZ); error++;
      }
    DIMALTZ++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMALTZ", &DIMALTZ) &&
        DIMALTZ == dimstyle->DIMALTZ)
      pass ("DIMSTYLE.DIMALTZ [BS] set+1 %hu", DIMALTZ);
    else
      {
        fail ("DIMSTYLE.DIMALTZ [BS] set+1 %hu != %hu", dimstyle->DIMALTZ, DIMALTZ); error++;
      }
    dimstyle->DIMALTZ--;

  }
  {
    BITCODE_T DIMAPOST;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMAPOST", &DIMAPOST, NULL)
        && !memcmp(&DIMAPOST, &dimstyle->DIMAPOST, sizeof(dimstyle->DIMAPOST)))
      pass ("DIMSTYLE.DIMAPOST [T]");
    else
      {
        fail ("DIMSTYLE.DIMAPOST [T]"); error++;
      }
  }
  {
    BITCODE_BS DIMARCSYM;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMARCSYM", &DIMARCSYM, NULL) &&
        DIMARCSYM == dimstyle->DIMARCSYM)
      pass ("DIMSTYLE.DIMARCSYM [BS] %hu", DIMARCSYM);
    else
      {
        fail ("DIMSTYLE.DIMARCSYM [BS] %hu != %hu", dimstyle->DIMARCSYM, DIMARCSYM); error++;
      }
    DIMARCSYM++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMARCSYM", &DIMARCSYM) &&
        DIMARCSYM == dimstyle->DIMARCSYM)
      pass ("DIMSTYLE.DIMARCSYM [BS] set+1 %hu", DIMARCSYM);
    else
      {
        fail ("DIMSTYLE.DIMARCSYM [BS] set+1 %hu != %hu", dimstyle->DIMARCSYM, DIMARCSYM); error++;
      }
    dimstyle->DIMARCSYM--;

  }
  {
    BITCODE_BD DIMASZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMASZ", &DIMASZ, NULL) &&
        DIMASZ == dimstyle->DIMASZ)
      pass ("DIMSTYLE.DIMASZ [BD] %g", DIMASZ);
    else
      {
        fail ("DIMSTYLE.DIMASZ [BD] %g != %g", dimstyle->DIMASZ, DIMASZ); error++;
      }
    DIMASZ++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMASZ", &DIMASZ) &&
        DIMASZ == dimstyle->DIMASZ)
      pass ("DIMSTYLE.DIMASZ [BD] set+1 %g", DIMASZ);
    else
      {
        fail ("DIMSTYLE.DIMASZ [BD] set+1 %g != %g", dimstyle->DIMASZ, DIMASZ); error++;
      }
    dimstyle->DIMASZ--;

  }
  {
    BITCODE_BS DIMATFIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMATFIT", &DIMATFIT, NULL) &&
        DIMATFIT == dimstyle->DIMATFIT)
      pass ("DIMSTYLE.DIMATFIT [BS] %hu", DIMATFIT);
    else
      {
        fail ("DIMSTYLE.DIMATFIT [BS] %hu != %hu", dimstyle->DIMATFIT, DIMATFIT); error++;
      }
    DIMATFIT++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMATFIT", &DIMATFIT) &&
        DIMATFIT == dimstyle->DIMATFIT)
      pass ("DIMSTYLE.DIMATFIT [BS] set+1 %hu", DIMATFIT);
    else
      {
        fail ("DIMSTYLE.DIMATFIT [BS] set+1 %hu != %hu", dimstyle->DIMATFIT, DIMATFIT); error++;
      }
    dimstyle->DIMATFIT--;

  }
  {
    BITCODE_BS DIMAUNIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMAUNIT", &DIMAUNIT, NULL) &&
        DIMAUNIT == dimstyle->DIMAUNIT)
      pass ("DIMSTYLE.DIMAUNIT [BS] %hu", DIMAUNIT);
    else
      {
        fail ("DIMSTYLE.DIMAUNIT [BS] %hu != %hu", dimstyle->DIMAUNIT, DIMAUNIT); error++;
      }
    DIMAUNIT++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMAUNIT", &DIMAUNIT) &&
        DIMAUNIT == dimstyle->DIMAUNIT)
      pass ("DIMSTYLE.DIMAUNIT [BS] set+1 %hu", DIMAUNIT);
    else
      {
        fail ("DIMSTYLE.DIMAUNIT [BS] set+1 %hu != %hu", dimstyle->DIMAUNIT, DIMAUNIT); error++;
      }
    dimstyle->DIMAUNIT--;

  }
  {
    BITCODE_BS DIMAZIN;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMAZIN", &DIMAZIN, NULL) &&
        DIMAZIN == dimstyle->DIMAZIN)
      pass ("DIMSTYLE.DIMAZIN [BS] %hu", DIMAZIN);
    else
      {
        fail ("DIMSTYLE.DIMAZIN [BS] %hu != %hu", dimstyle->DIMAZIN, DIMAZIN); error++;
      }
    DIMAZIN++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMAZIN", &DIMAZIN) &&
        DIMAZIN == dimstyle->DIMAZIN)
      pass ("DIMSTYLE.DIMAZIN [BS] set+1 %hu", DIMAZIN);
    else
      {
        fail ("DIMSTYLE.DIMAZIN [BS] set+1 %hu != %hu", dimstyle->DIMAZIN, DIMAZIN); error++;
      }
    dimstyle->DIMAZIN--;

  }
  {
    BITCODE_H DIMBLK;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK", &DIMBLK, NULL)
        && !memcmp(&DIMBLK, &dimstyle->DIMBLK, sizeof(dimstyle->DIMBLK)))
      pass ("DIMSTYLE.DIMBLK [H]");
    else
      {
        fail ("DIMSTYLE.DIMBLK [H]"); error++;
      }
  }
  {
    BITCODE_H DIMBLK1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK1", &DIMBLK1, NULL)
        && !memcmp(&DIMBLK1, &dimstyle->DIMBLK1, sizeof(dimstyle->DIMBLK1)))
      pass ("DIMSTYLE.DIMBLK1 [H]");
    else
      {
        fail ("DIMSTYLE.DIMBLK1 [H]"); error++;
      }
  }
  {
    BITCODE_T DIMBLK1_T;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK1_T", &DIMBLK1_T, NULL)
        && !memcmp(&DIMBLK1_T, &dimstyle->DIMBLK1_T, sizeof(dimstyle->DIMBLK1_T)))
      pass ("DIMSTYLE.DIMBLK1_T [T]");
    else
      {
        fail ("DIMSTYLE.DIMBLK1_T [T]"); error++;
      }
  }
  {
    BITCODE_H DIMBLK2;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK2", &DIMBLK2, NULL)
        && !memcmp(&DIMBLK2, &dimstyle->DIMBLK2, sizeof(dimstyle->DIMBLK2)))
      pass ("DIMSTYLE.DIMBLK2 [H]");
    else
      {
        fail ("DIMSTYLE.DIMBLK2 [H]"); error++;
      }
  }
  {
    BITCODE_T DIMBLK2_T;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK2_T", &DIMBLK2_T, NULL)
        && !memcmp(&DIMBLK2_T, &dimstyle->DIMBLK2_T, sizeof(dimstyle->DIMBLK2_T)))
      pass ("DIMSTYLE.DIMBLK2_T [T]");
    else
      {
        fail ("DIMSTYLE.DIMBLK2_T [T]"); error++;
      }
  }
  {
    BITCODE_T DIMBLK_T;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK_T", &DIMBLK_T, NULL)
        && !memcmp(&DIMBLK_T, &dimstyle->DIMBLK_T, sizeof(dimstyle->DIMBLK_T)))
      pass ("DIMSTYLE.DIMBLK_T [T]");
    else
      {
        fail ("DIMSTYLE.DIMBLK_T [T]"); error++;
      }
  }
  {
    BITCODE_BD DIMCEN;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCEN", &DIMCEN, NULL) &&
        DIMCEN == dimstyle->DIMCEN)
      pass ("DIMSTYLE.DIMCEN [BD] %g", DIMCEN);
    else
      {
        fail ("DIMSTYLE.DIMCEN [BD] %g != %g", dimstyle->DIMCEN, DIMCEN); error++;
      }
    DIMCEN++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMCEN", &DIMCEN) &&
        DIMCEN == dimstyle->DIMCEN)
      pass ("DIMSTYLE.DIMCEN [BD] set+1 %g", DIMCEN);
    else
      {
        fail ("DIMSTYLE.DIMCEN [BD] set+1 %g != %g", dimstyle->DIMCEN, DIMCEN); error++;
      }
    dimstyle->DIMCEN--;

  }
  {
    BITCODE_CMC DIMCLRD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRD", &DIMCLRD, NULL)
        && !memcmp(&DIMCLRD, &dimstyle->DIMCLRD, sizeof(dimstyle->DIMCLRD)))
      pass ("DIMSTYLE.DIMCLRD [CMC]");
    else
      {
        fail ("DIMSTYLE.DIMCLRD [CMC]"); error++;
      }
  }
  {
    BITCODE_RS DIMCLRD_N;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRD_N", &DIMCLRD_N, NULL) &&
        DIMCLRD_N == dimstyle->DIMCLRD_N)
      pass ("DIMSTYLE.DIMCLRD_N [RS] %hu", DIMCLRD_N);
    else
      {
        fail ("DIMSTYLE.DIMCLRD_N [RS] %hu != %hu", dimstyle->DIMCLRD_N, DIMCLRD_N); error++;
      }
    DIMCLRD_N++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMCLRD_N", &DIMCLRD_N) &&
        DIMCLRD_N == dimstyle->DIMCLRD_N)
      pass ("DIMSTYLE.DIMCLRD_N [RS] set+1 %hu", DIMCLRD_N);
    else
      {
        fail ("DIMSTYLE.DIMCLRD_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRD_N, DIMCLRD_N); error++;
      }
    dimstyle->DIMCLRD_N--;

  }
  {
    BITCODE_CMC DIMCLRE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRE", &DIMCLRE, NULL)
        && !memcmp(&DIMCLRE, &dimstyle->DIMCLRE, sizeof(dimstyle->DIMCLRE)))
      pass ("DIMSTYLE.DIMCLRE [CMC]");
    else
      {
        fail ("DIMSTYLE.DIMCLRE [CMC]"); error++;
      }
  }
  {
    BITCODE_RS DIMCLRE_N;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRE_N", &DIMCLRE_N, NULL) &&
        DIMCLRE_N == dimstyle->DIMCLRE_N)
      pass ("DIMSTYLE.DIMCLRE_N [RS] %hu", DIMCLRE_N);
    else
      {
        fail ("DIMSTYLE.DIMCLRE_N [RS] %hu != %hu", dimstyle->DIMCLRE_N, DIMCLRE_N); error++;
      }
    DIMCLRE_N++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMCLRE_N", &DIMCLRE_N) &&
        DIMCLRE_N == dimstyle->DIMCLRE_N)
      pass ("DIMSTYLE.DIMCLRE_N [RS] set+1 %hu", DIMCLRE_N);
    else
      {
        fail ("DIMSTYLE.DIMCLRE_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRE_N, DIMCLRE_N); error++;
      }
    dimstyle->DIMCLRE_N--;

  }
  {
    BITCODE_CMC DIMCLRT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRT", &DIMCLRT, NULL)
        && !memcmp(&DIMCLRT, &dimstyle->DIMCLRT, sizeof(dimstyle->DIMCLRT)))
      pass ("DIMSTYLE.DIMCLRT [CMC]");
    else
      {
        fail ("DIMSTYLE.DIMCLRT [CMC]"); error++;
      }
  }
  {
    BITCODE_RS DIMCLRT_N;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRT_N", &DIMCLRT_N, NULL) &&
        DIMCLRT_N == dimstyle->DIMCLRT_N)
      pass ("DIMSTYLE.DIMCLRT_N [RS] %hu", DIMCLRT_N);
    else
      {
        fail ("DIMSTYLE.DIMCLRT_N [RS] %hu != %hu", dimstyle->DIMCLRT_N, DIMCLRT_N); error++;
      }
    DIMCLRT_N++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMCLRT_N", &DIMCLRT_N) &&
        DIMCLRT_N == dimstyle->DIMCLRT_N)
      pass ("DIMSTYLE.DIMCLRT_N [RS] set+1 %hu", DIMCLRT_N);
    else
      {
        fail ("DIMSTYLE.DIMCLRT_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRT_N, DIMCLRT_N); error++;
      }
    dimstyle->DIMCLRT_N--;

  }
  {
    BITCODE_BS DIMDEC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMDEC", &DIMDEC, NULL) &&
        DIMDEC == dimstyle->DIMDEC)
      pass ("DIMSTYLE.DIMDEC [BS] %hu", DIMDEC);
    else
      {
        fail ("DIMSTYLE.DIMDEC [BS] %hu != %hu", dimstyle->DIMDEC, DIMDEC); error++;
      }
    DIMDEC++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMDEC", &DIMDEC) &&
        DIMDEC == dimstyle->DIMDEC)
      pass ("DIMSTYLE.DIMDEC [BS] set+1 %hu", DIMDEC);
    else
      {
        fail ("DIMSTYLE.DIMDEC [BS] set+1 %hu != %hu", dimstyle->DIMDEC, DIMDEC); error++;
      }
    dimstyle->DIMDEC--;

  }
  {
    BITCODE_BD DIMDLE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMDLE", &DIMDLE, NULL) &&
        DIMDLE == dimstyle->DIMDLE)
      pass ("DIMSTYLE.DIMDLE [BD] %g", DIMDLE);
    else
      {
        fail ("DIMSTYLE.DIMDLE [BD] %g != %g", dimstyle->DIMDLE, DIMDLE); error++;
      }
    DIMDLE++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMDLE", &DIMDLE) &&
        DIMDLE == dimstyle->DIMDLE)
      pass ("DIMSTYLE.DIMDLE [BD] set+1 %g", DIMDLE);
    else
      {
        fail ("DIMSTYLE.DIMDLE [BD] set+1 %g != %g", dimstyle->DIMDLE, DIMDLE); error++;
      }
    dimstyle->DIMDLE--;

  }
  {
    BITCODE_BD DIMDLI;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMDLI", &DIMDLI, NULL) &&
        DIMDLI == dimstyle->DIMDLI)
      pass ("DIMSTYLE.DIMDLI [BD] %g", DIMDLI);
    else
      {
        fail ("DIMSTYLE.DIMDLI [BD] %g != %g", dimstyle->DIMDLI, DIMDLI); error++;
      }
    DIMDLI++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMDLI", &DIMDLI) &&
        DIMDLI == dimstyle->DIMDLI)
      pass ("DIMSTYLE.DIMDLI [BD] set+1 %g", DIMDLI);
    else
      {
        fail ("DIMSTYLE.DIMDLI [BD] set+1 %g != %g", dimstyle->DIMDLI, DIMDLI); error++;
      }
    dimstyle->DIMDLI--;

  }
  {
    BITCODE_BS DIMDSEP;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMDSEP", &DIMDSEP, NULL) &&
        DIMDSEP == dimstyle->DIMDSEP)
      pass ("DIMSTYLE.DIMDSEP [BS] %hu", DIMDSEP);
    else
      {
        fail ("DIMSTYLE.DIMDSEP [BS] %hu != %hu", dimstyle->DIMDSEP, DIMDSEP); error++;
      }
    DIMDSEP++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMDSEP", &DIMDSEP) &&
        DIMDSEP == dimstyle->DIMDSEP)
      pass ("DIMSTYLE.DIMDSEP [BS] set+1 %hu", DIMDSEP);
    else
      {
        fail ("DIMSTYLE.DIMDSEP [BS] set+1 %hu != %hu", dimstyle->DIMDSEP, DIMDSEP); error++;
      }
    dimstyle->DIMDSEP--;

  }
  {
    BITCODE_BD DIMEXE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMEXE", &DIMEXE, NULL) &&
        DIMEXE == dimstyle->DIMEXE)
      pass ("DIMSTYLE.DIMEXE [BD] %g", DIMEXE);
    else
      {
        fail ("DIMSTYLE.DIMEXE [BD] %g != %g", dimstyle->DIMEXE, DIMEXE); error++;
      }
    DIMEXE++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMEXE", &DIMEXE) &&
        DIMEXE == dimstyle->DIMEXE)
      pass ("DIMSTYLE.DIMEXE [BD] set+1 %g", DIMEXE);
    else
      {
        fail ("DIMSTYLE.DIMEXE [BD] set+1 %g != %g", dimstyle->DIMEXE, DIMEXE); error++;
      }
    dimstyle->DIMEXE--;

  }
  {
    BITCODE_BD DIMEXO;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMEXO", &DIMEXO, NULL) &&
        DIMEXO == dimstyle->DIMEXO)
      pass ("DIMSTYLE.DIMEXO [BD] %g", DIMEXO);
    else
      {
        fail ("DIMSTYLE.DIMEXO [BD] %g != %g", dimstyle->DIMEXO, DIMEXO); error++;
      }
    DIMEXO++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMEXO", &DIMEXO) &&
        DIMEXO == dimstyle->DIMEXO)
      pass ("DIMSTYLE.DIMEXO [BD] set+1 %g", DIMEXO);
    else
      {
        fail ("DIMSTYLE.DIMEXO [BD] set+1 %g != %g", dimstyle->DIMEXO, DIMEXO); error++;
      }
    dimstyle->DIMEXO--;

  }
  {
    BITCODE_BS DIMFIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMFIT", &DIMFIT, NULL) &&
        DIMFIT == dimstyle->DIMFIT)
      pass ("DIMSTYLE.DIMFIT [BS] %hu", DIMFIT);
    else
      {
        fail ("DIMSTYLE.DIMFIT [BS] %hu != %hu", dimstyle->DIMFIT, DIMFIT); error++;
      }
    DIMFIT++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMFIT", &DIMFIT) &&
        DIMFIT == dimstyle->DIMFIT)
      pass ("DIMSTYLE.DIMFIT [BS] set+1 %hu", DIMFIT);
    else
      {
        fail ("DIMSTYLE.DIMFIT [BS] set+1 %hu != %hu", dimstyle->DIMFIT, DIMFIT); error++;
      }
    dimstyle->DIMFIT--;

  }
  {
    BITCODE_BS DIMFRAC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMFRAC", &DIMFRAC, NULL) &&
        DIMFRAC == dimstyle->DIMFRAC)
      pass ("DIMSTYLE.DIMFRAC [BS] %hu", DIMFRAC);
    else
      {
        fail ("DIMSTYLE.DIMFRAC [BS] %hu != %hu", dimstyle->DIMFRAC, DIMFRAC); error++;
      }
    DIMFRAC++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMFRAC", &DIMFRAC) &&
        DIMFRAC == dimstyle->DIMFRAC)
      pass ("DIMSTYLE.DIMFRAC [BS] set+1 %hu", DIMFRAC);
    else
      {
        fail ("DIMSTYLE.DIMFRAC [BS] set+1 %hu != %hu", dimstyle->DIMFRAC, DIMFRAC); error++;
      }
    dimstyle->DIMFRAC--;

  }
  {
    BITCODE_BD DIMFXL;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMFXL", &DIMFXL, NULL) &&
        DIMFXL == dimstyle->DIMFXL)
      pass ("DIMSTYLE.DIMFXL [BD] %g", DIMFXL);
    else
      {
        fail ("DIMSTYLE.DIMFXL [BD] %g != %g", dimstyle->DIMFXL, DIMFXL); error++;
      }
    DIMFXL++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMFXL", &DIMFXL) &&
        DIMFXL == dimstyle->DIMFXL)
      pass ("DIMSTYLE.DIMFXL [BD] set+1 %g", DIMFXL);
    else
      {
        fail ("DIMSTYLE.DIMFXL [BD] set+1 %g != %g", dimstyle->DIMFXL, DIMFXL); error++;
      }
    dimstyle->DIMFXL--;

  }
  {
    BITCODE_B DIMFXLON;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMFXLON", &DIMFXLON, NULL) &&
        DIMFXLON == dimstyle->DIMFXLON)
      pass ("DIMSTYLE.DIMFXLON [B] " FORMAT_B "", DIMFXLON);
    else
      {
        fail ("DIMSTYLE.DIMFXLON [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMFXLON, DIMFXLON); error++;
      }
    DIMFXLON++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMFXLON", &DIMFXLON) &&
        DIMFXLON == dimstyle->DIMFXLON)
      pass ("DIMSTYLE.DIMFXLON [B] set+1 " FORMAT_B "", DIMFXLON);
    else
      {
        fail ("DIMSTYLE.DIMFXLON [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMFXLON, DIMFXLON); error++;
      }
    dimstyle->DIMFXLON--;

  }
  {
    BITCODE_BD DIMGAP;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMGAP", &DIMGAP, NULL) &&
        DIMGAP == dimstyle->DIMGAP)
      pass ("DIMSTYLE.DIMGAP [BD] %g", DIMGAP);
    else
      {
        fail ("DIMSTYLE.DIMGAP [BD] %g != %g", dimstyle->DIMGAP, DIMGAP); error++;
      }
    DIMGAP++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMGAP", &DIMGAP) &&
        DIMGAP == dimstyle->DIMGAP)
      pass ("DIMSTYLE.DIMGAP [BD] set+1 %g", DIMGAP);
    else
      {
        fail ("DIMSTYLE.DIMGAP [BD] set+1 %g != %g", dimstyle->DIMGAP, DIMGAP); error++;
      }
    dimstyle->DIMGAP--;

  }
  {
    BITCODE_BD DIMJOGANG;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMJOGANG", &DIMJOGANG, NULL) &&
        DIMJOGANG == dimstyle->DIMJOGANG)
      pass ("DIMSTYLE.DIMJOGANG [BD] %g", DIMJOGANG);
    else
      {
        fail ("DIMSTYLE.DIMJOGANG [BD] %g != %g", dimstyle->DIMJOGANG, DIMJOGANG); error++;
      }
    DIMJOGANG++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMJOGANG", &DIMJOGANG) &&
        DIMJOGANG == dimstyle->DIMJOGANG)
      pass ("DIMSTYLE.DIMJOGANG [BD] set+1 %g", DIMJOGANG);
    else
      {
        fail ("DIMSTYLE.DIMJOGANG [BD] set+1 %g != %g", dimstyle->DIMJOGANG, DIMJOGANG); error++;
      }
    dimstyle->DIMJOGANG--;

  }
  {
    BITCODE_BS DIMJUST;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMJUST", &DIMJUST, NULL) &&
        DIMJUST == dimstyle->DIMJUST)
      pass ("DIMSTYLE.DIMJUST [BS] %hu", DIMJUST);
    else
      {
        fail ("DIMSTYLE.DIMJUST [BS] %hu != %hu", dimstyle->DIMJUST, DIMJUST); error++;
      }
    DIMJUST++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMJUST", &DIMJUST) &&
        DIMJUST == dimstyle->DIMJUST)
      pass ("DIMSTYLE.DIMJUST [BS] set+1 %hu", DIMJUST);
    else
      {
        fail ("DIMSTYLE.DIMJUST [BS] set+1 %hu != %hu", dimstyle->DIMJUST, DIMJUST); error++;
      }
    dimstyle->DIMJUST--;

  }
  {
    BITCODE_H DIMLDRBLK;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLDRBLK", &DIMLDRBLK, NULL)
        && !memcmp(&DIMLDRBLK, &dimstyle->DIMLDRBLK, sizeof(dimstyle->DIMLDRBLK)))
      pass ("DIMSTYLE.DIMLDRBLK [H]");
    else
      {
        fail ("DIMSTYLE.DIMLDRBLK [H]"); error++;
      }
  }
  {
    BITCODE_BD DIMLFAC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLFAC", &DIMLFAC, NULL) &&
        DIMLFAC == dimstyle->DIMLFAC)
      pass ("DIMSTYLE.DIMLFAC [BD] %g", DIMLFAC);
    else
      {
        fail ("DIMSTYLE.DIMLFAC [BD] %g != %g", dimstyle->DIMLFAC, DIMLFAC); error++;
      }
    DIMLFAC++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMLFAC", &DIMLFAC) &&
        DIMLFAC == dimstyle->DIMLFAC)
      pass ("DIMSTYLE.DIMLFAC [BD] set+1 %g", DIMLFAC);
    else
      {
        fail ("DIMSTYLE.DIMLFAC [BD] set+1 %g != %g", dimstyle->DIMLFAC, DIMLFAC); error++;
      }
    dimstyle->DIMLFAC--;

  }
  {
    BITCODE_B DIMLIM;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLIM", &DIMLIM, NULL) &&
        DIMLIM == dimstyle->DIMLIM)
      pass ("DIMSTYLE.DIMLIM [B] " FORMAT_B "", DIMLIM);
    else
      {
        fail ("DIMSTYLE.DIMLIM [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMLIM, DIMLIM); error++;
      }
    DIMLIM++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMLIM", &DIMLIM) &&
        DIMLIM == dimstyle->DIMLIM)
      pass ("DIMSTYLE.DIMLIM [B] set+1 " FORMAT_B "", DIMLIM);
    else
      {
        fail ("DIMSTYLE.DIMLIM [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMLIM, DIMLIM); error++;
      }
    dimstyle->DIMLIM--;

  }
  {
    BITCODE_H DIMLTEX1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLTEX1", &DIMLTEX1, NULL)
        && !memcmp(&DIMLTEX1, &dimstyle->DIMLTEX1, sizeof(dimstyle->DIMLTEX1)))
      pass ("DIMSTYLE.DIMLTEX1 [H]");
    else
      {
        fail ("DIMSTYLE.DIMLTEX1 [H]"); error++;
      }
  }
  {
    BITCODE_H DIMLTEX2;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLTEX2", &DIMLTEX2, NULL)
        && !memcmp(&DIMLTEX2, &dimstyle->DIMLTEX2, sizeof(dimstyle->DIMLTEX2)))
      pass ("DIMSTYLE.DIMLTEX2 [H]");
    else
      {
        fail ("DIMSTYLE.DIMLTEX2 [H]"); error++;
      }
  }
  {
    BITCODE_H DIMLTYPE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLTYPE", &DIMLTYPE, NULL)
        && !memcmp(&DIMLTYPE, &dimstyle->DIMLTYPE, sizeof(dimstyle->DIMLTYPE)))
      pass ("DIMSTYLE.DIMLTYPE [H]");
    else
      {
        fail ("DIMSTYLE.DIMLTYPE [H]"); error++;
      }
  }
  {
    BITCODE_BS DIMLUNIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLUNIT", &DIMLUNIT, NULL) &&
        DIMLUNIT == dimstyle->DIMLUNIT)
      pass ("DIMSTYLE.DIMLUNIT [BS] %hu", DIMLUNIT);
    else
      {
        fail ("DIMSTYLE.DIMLUNIT [BS] %hu != %hu", dimstyle->DIMLUNIT, DIMLUNIT); error++;
      }
    DIMLUNIT++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMLUNIT", &DIMLUNIT) &&
        DIMLUNIT == dimstyle->DIMLUNIT)
      pass ("DIMSTYLE.DIMLUNIT [BS] set+1 %hu", DIMLUNIT);
    else
      {
        fail ("DIMSTYLE.DIMLUNIT [BS] set+1 %hu != %hu", dimstyle->DIMLUNIT, DIMLUNIT); error++;
      }
    dimstyle->DIMLUNIT--;

  }
  {
    BITCODE_BS DIMLWD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLWD", &DIMLWD, NULL) &&
        DIMLWD == dimstyle->DIMLWD)
      pass ("DIMSTYLE.DIMLWD [BS] %hu", DIMLWD);
    else
      {
        fail ("DIMSTYLE.DIMLWD [BS] %hu != %hu", dimstyle->DIMLWD, DIMLWD); error++;
      }
    DIMLWD++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMLWD", &DIMLWD) &&
        DIMLWD == dimstyle->DIMLWD)
      pass ("DIMSTYLE.DIMLWD [BS] set+1 %hu", DIMLWD);
    else
      {
        fail ("DIMSTYLE.DIMLWD [BS] set+1 %hu != %hu", dimstyle->DIMLWD, DIMLWD); error++;
      }
    dimstyle->DIMLWD--;

  }
  {
    BITCODE_BS DIMLWE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLWE", &DIMLWE, NULL) &&
        DIMLWE == dimstyle->DIMLWE)
      pass ("DIMSTYLE.DIMLWE [BS] %hu", DIMLWE);
    else
      {
        fail ("DIMSTYLE.DIMLWE [BS] %hu != %hu", dimstyle->DIMLWE, DIMLWE); error++;
      }
    DIMLWE++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMLWE", &DIMLWE) &&
        DIMLWE == dimstyle->DIMLWE)
      pass ("DIMSTYLE.DIMLWE [BS] set+1 %hu", DIMLWE);
    else
      {
        fail ("DIMSTYLE.DIMLWE [BS] set+1 %hu != %hu", dimstyle->DIMLWE, DIMLWE); error++;
      }
    dimstyle->DIMLWE--;

  }
  {
    BITCODE_BS DIMMALTTZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMMALTTZ", &DIMMALTTZ, NULL) &&
        DIMMALTTZ == dimstyle->DIMMALTTZ)
      pass ("DIMSTYLE.DIMMALTTZ [BS] %hu", DIMMALTTZ);
    else
      {
        fail ("DIMSTYLE.DIMMALTTZ [BS] %hu != %hu", dimstyle->DIMMALTTZ, DIMMALTTZ); error++;
      }
    DIMMALTTZ++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMMALTTZ", &DIMMALTTZ) &&
        DIMMALTTZ == dimstyle->DIMMALTTZ)
      pass ("DIMSTYLE.DIMMALTTZ [BS] set+1 %hu", DIMMALTTZ);
    else
      {
        fail ("DIMSTYLE.DIMMALTTZ [BS] set+1 %hu != %hu", dimstyle->DIMMALTTZ, DIMMALTTZ); error++;
      }
    dimstyle->DIMMALTTZ--;

  }
  {
    BITCODE_BS DIMMALTZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMMALTZ", &DIMMALTZ, NULL) &&
        DIMMALTZ == dimstyle->DIMMALTZ)
      pass ("DIMSTYLE.DIMMALTZ [BS] %hu", DIMMALTZ);
    else
      {
        fail ("DIMSTYLE.DIMMALTZ [BS] %hu != %hu", dimstyle->DIMMALTZ, DIMMALTZ); error++;
      }
    DIMMALTZ++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMMALTZ", &DIMMALTZ) &&
        DIMMALTZ == dimstyle->DIMMALTZ)
      pass ("DIMSTYLE.DIMMALTZ [BS] set+1 %hu", DIMMALTZ);
    else
      {
        fail ("DIMSTYLE.DIMMALTZ [BS] set+1 %hu != %hu", dimstyle->DIMMALTZ, DIMMALTZ); error++;
      }
    dimstyle->DIMMALTZ--;

  }
  {
    BITCODE_BD DIMMZF;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMMZF", &DIMMZF, NULL) &&
        DIMMZF == dimstyle->DIMMZF)
      pass ("DIMSTYLE.DIMMZF [BD] %g", DIMMZF);
    else
      {
        fail ("DIMSTYLE.DIMMZF [BD] %g != %g", dimstyle->DIMMZF, DIMMZF); error++;
      }
    DIMMZF++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMMZF", &DIMMZF) &&
        DIMMZF == dimstyle->DIMMZF)
      pass ("DIMSTYLE.DIMMZF [BD] set+1 %g", DIMMZF);
    else
      {
        fail ("DIMSTYLE.DIMMZF [BD] set+1 %g != %g", dimstyle->DIMMZF, DIMMZF); error++;
      }
    dimstyle->DIMMZF--;

  }
  {
    BITCODE_T DIMMZS;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMMZS", &DIMMZS, NULL)
        && !memcmp(&DIMMZS, &dimstyle->DIMMZS, sizeof(dimstyle->DIMMZS)))
      pass ("DIMSTYLE.DIMMZS [T]");
    else
      {
        fail ("DIMSTYLE.DIMMZS [T]"); error++;
      }
  }
  {
    BITCODE_T DIMPOST;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMPOST", &DIMPOST, NULL)
        && !memcmp(&DIMPOST, &dimstyle->DIMPOST, sizeof(dimstyle->DIMPOST)))
      pass ("DIMSTYLE.DIMPOST [T]");
    else
      {
        fail ("DIMSTYLE.DIMPOST [T]"); error++;
      }
  }
  {
    BITCODE_BD DIMRND;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMRND", &DIMRND, NULL) &&
        DIMRND == dimstyle->DIMRND)
      pass ("DIMSTYLE.DIMRND [BD] %g", DIMRND);
    else
      {
        fail ("DIMSTYLE.DIMRND [BD] %g != %g", dimstyle->DIMRND, DIMRND); error++;
      }
    DIMRND++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMRND", &DIMRND) &&
        DIMRND == dimstyle->DIMRND)
      pass ("DIMSTYLE.DIMRND [BD] set+1 %g", DIMRND);
    else
      {
        fail ("DIMSTYLE.DIMRND [BD] set+1 %g != %g", dimstyle->DIMRND, DIMRND); error++;
      }
    dimstyle->DIMRND--;

  }
  {
    BITCODE_B DIMSAH;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSAH", &DIMSAH, NULL) &&
        DIMSAH == dimstyle->DIMSAH)
      pass ("DIMSTYLE.DIMSAH [B] " FORMAT_B "", DIMSAH);
    else
      {
        fail ("DIMSTYLE.DIMSAH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSAH, DIMSAH); error++;
      }
    DIMSAH++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMSAH", &DIMSAH) &&
        DIMSAH == dimstyle->DIMSAH)
      pass ("DIMSTYLE.DIMSAH [B] set+1 " FORMAT_B "", DIMSAH);
    else
      {
        fail ("DIMSTYLE.DIMSAH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSAH, DIMSAH); error++;
      }
    dimstyle->DIMSAH--;

  }
  {
    BITCODE_BD DIMSCALE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSCALE", &DIMSCALE, NULL) &&
        DIMSCALE == dimstyle->DIMSCALE)
      pass ("DIMSTYLE.DIMSCALE [BD] %g", DIMSCALE);
    else
      {
        fail ("DIMSTYLE.DIMSCALE [BD] %g != %g", dimstyle->DIMSCALE, DIMSCALE); error++;
      }
    DIMSCALE++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMSCALE", &DIMSCALE) &&
        DIMSCALE == dimstyle->DIMSCALE)
      pass ("DIMSTYLE.DIMSCALE [BD] set+1 %g", DIMSCALE);
    else
      {
        fail ("DIMSTYLE.DIMSCALE [BD] set+1 %g != %g", dimstyle->DIMSCALE, DIMSCALE); error++;
      }
    dimstyle->DIMSCALE--;

  }
  {
    BITCODE_B DIMSD1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSD1", &DIMSD1, NULL) &&
        DIMSD1 == dimstyle->DIMSD1)
      pass ("DIMSTYLE.DIMSD1 [B] " FORMAT_B "", DIMSD1);
    else
      {
        fail ("DIMSTYLE.DIMSD1 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD1, DIMSD1); error++;
      }
    DIMSD1++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMSD1", &DIMSD1) &&
        DIMSD1 == dimstyle->DIMSD1)
      pass ("DIMSTYLE.DIMSD1 [B] set+1 " FORMAT_B "", DIMSD1);
    else
      {
        fail ("DIMSTYLE.DIMSD1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD1, DIMSD1); error++;
      }
    dimstyle->DIMSD1--;

  }
  {
    BITCODE_B DIMSD2;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSD2", &DIMSD2, NULL) &&
        DIMSD2 == dimstyle->DIMSD2)
      pass ("DIMSTYLE.DIMSD2 [B] " FORMAT_B "", DIMSD2);
    else
      {
        fail ("DIMSTYLE.DIMSD2 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD2, DIMSD2); error++;
      }
    DIMSD2++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMSD2", &DIMSD2) &&
        DIMSD2 == dimstyle->DIMSD2)
      pass ("DIMSTYLE.DIMSD2 [B] set+1 " FORMAT_B "", DIMSD2);
    else
      {
        fail ("DIMSTYLE.DIMSD2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD2, DIMSD2); error++;
      }
    dimstyle->DIMSD2--;

  }
  {
    BITCODE_B DIMSE1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSE1", &DIMSE1, NULL) &&
        DIMSE1 == dimstyle->DIMSE1)
      pass ("DIMSTYLE.DIMSE1 [B] " FORMAT_B "", DIMSE1);
    else
      {
        fail ("DIMSTYLE.DIMSE1 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE1, DIMSE1); error++;
      }
    DIMSE1++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMSE1", &DIMSE1) &&
        DIMSE1 == dimstyle->DIMSE1)
      pass ("DIMSTYLE.DIMSE1 [B] set+1 " FORMAT_B "", DIMSE1);
    else
      {
        fail ("DIMSTYLE.DIMSE1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE1, DIMSE1); error++;
      }
    dimstyle->DIMSE1--;

  }
  {
    BITCODE_B DIMSE2;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSE2", &DIMSE2, NULL) &&
        DIMSE2 == dimstyle->DIMSE2)
      pass ("DIMSTYLE.DIMSE2 [B] " FORMAT_B "", DIMSE2);
    else
      {
        fail ("DIMSTYLE.DIMSE2 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE2, DIMSE2); error++;
      }
    DIMSE2++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMSE2", &DIMSE2) &&
        DIMSE2 == dimstyle->DIMSE2)
      pass ("DIMSTYLE.DIMSE2 [B] set+1 " FORMAT_B "", DIMSE2);
    else
      {
        fail ("DIMSTYLE.DIMSE2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE2, DIMSE2); error++;
      }
    dimstyle->DIMSE2--;

  }
  {
    BITCODE_B DIMSOXD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSOXD", &DIMSOXD, NULL) &&
        DIMSOXD == dimstyle->DIMSOXD)
      pass ("DIMSTYLE.DIMSOXD [B] " FORMAT_B "", DIMSOXD);
    else
      {
        fail ("DIMSTYLE.DIMSOXD [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSOXD, DIMSOXD); error++;
      }
    DIMSOXD++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMSOXD", &DIMSOXD) &&
        DIMSOXD == dimstyle->DIMSOXD)
      pass ("DIMSTYLE.DIMSOXD [B] set+1 " FORMAT_B "", DIMSOXD);
    else
      {
        fail ("DIMSTYLE.DIMSOXD [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSOXD, DIMSOXD); error++;
      }
    dimstyle->DIMSOXD--;

  }
  {
    BITCODE_BS DIMTAD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTAD", &DIMTAD, NULL) &&
        DIMTAD == dimstyle->DIMTAD)
      pass ("DIMSTYLE.DIMTAD [BS] %hu", DIMTAD);
    else
      {
        fail ("DIMSTYLE.DIMTAD [BS] %hu != %hu", dimstyle->DIMTAD, DIMTAD); error++;
      }
    DIMTAD++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTAD", &DIMTAD) &&
        DIMTAD == dimstyle->DIMTAD)
      pass ("DIMSTYLE.DIMTAD [BS] set+1 %hu", DIMTAD);
    else
      {
        fail ("DIMSTYLE.DIMTAD [BS] set+1 %hu != %hu", dimstyle->DIMTAD, DIMTAD); error++;
      }
    dimstyle->DIMTAD--;

  }
  {
    BITCODE_BS DIMTDEC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTDEC", &DIMTDEC, NULL) &&
        DIMTDEC == dimstyle->DIMTDEC)
      pass ("DIMSTYLE.DIMTDEC [BS] %hu", DIMTDEC);
    else
      {
        fail ("DIMSTYLE.DIMTDEC [BS] %hu != %hu", dimstyle->DIMTDEC, DIMTDEC); error++;
      }
    DIMTDEC++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTDEC", &DIMTDEC) &&
        DIMTDEC == dimstyle->DIMTDEC)
      pass ("DIMSTYLE.DIMTDEC [BS] set+1 %hu", DIMTDEC);
    else
      {
        fail ("DIMSTYLE.DIMTDEC [BS] set+1 %hu != %hu", dimstyle->DIMTDEC, DIMTDEC); error++;
      }
    dimstyle->DIMTDEC--;

  }
  {
    BITCODE_BD DIMTFAC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTFAC", &DIMTFAC, NULL) &&
        DIMTFAC == dimstyle->DIMTFAC)
      pass ("DIMSTYLE.DIMTFAC [BD] %g", DIMTFAC);
    else
      {
        fail ("DIMSTYLE.DIMTFAC [BD] %g != %g", dimstyle->DIMTFAC, DIMTFAC); error++;
      }
    DIMTFAC++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTFAC", &DIMTFAC) &&
        DIMTFAC == dimstyle->DIMTFAC)
      pass ("DIMSTYLE.DIMTFAC [BD] set+1 %g", DIMTFAC);
    else
      {
        fail ("DIMSTYLE.DIMTFAC [BD] set+1 %g != %g", dimstyle->DIMTFAC, DIMTFAC); error++;
      }
    dimstyle->DIMTFAC--;

  }
  {
    BITCODE_BS DIMTFILL;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTFILL", &DIMTFILL, NULL) &&
        DIMTFILL == dimstyle->DIMTFILL)
      pass ("DIMSTYLE.DIMTFILL [BS] %hu", DIMTFILL);
    else
      {
        fail ("DIMSTYLE.DIMTFILL [BS] %hu != %hu", dimstyle->DIMTFILL, DIMTFILL); error++;
      }
    DIMTFILL++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTFILL", &DIMTFILL) &&
        DIMTFILL == dimstyle->DIMTFILL)
      pass ("DIMSTYLE.DIMTFILL [BS] set+1 %hu", DIMTFILL);
    else
      {
        fail ("DIMSTYLE.DIMTFILL [BS] set+1 %hu != %hu", dimstyle->DIMTFILL, DIMTFILL); error++;
      }
    dimstyle->DIMTFILL--;

  }
  {
    BITCODE_CMC DIMTFILLCLR;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTFILLCLR", &DIMTFILLCLR, NULL)
        && !memcmp(&DIMTFILLCLR, &dimstyle->DIMTFILLCLR, sizeof(dimstyle->DIMTFILLCLR)))
      pass ("DIMSTYLE.DIMTFILLCLR [CMC]");
    else
      {
        fail ("DIMSTYLE.DIMTFILLCLR [CMC]"); error++;
      }
  }
  {
    BITCODE_B DIMTIH;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTIH", &DIMTIH, NULL) &&
        DIMTIH == dimstyle->DIMTIH)
      pass ("DIMSTYLE.DIMTIH [B] " FORMAT_B "", DIMTIH);
    else
      {
        fail ("DIMSTYLE.DIMTIH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIH, DIMTIH); error++;
      }
    DIMTIH++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTIH", &DIMTIH) &&
        DIMTIH == dimstyle->DIMTIH)
      pass ("DIMSTYLE.DIMTIH [B] set+1 " FORMAT_B "", DIMTIH);
    else
      {
        fail ("DIMSTYLE.DIMTIH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIH, DIMTIH); error++;
      }
    dimstyle->DIMTIH--;

  }
  {
    BITCODE_B DIMTIX;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTIX", &DIMTIX, NULL) &&
        DIMTIX == dimstyle->DIMTIX)
      pass ("DIMSTYLE.DIMTIX [B] " FORMAT_B "", DIMTIX);
    else
      {
        fail ("DIMSTYLE.DIMTIX [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIX, DIMTIX); error++;
      }
    DIMTIX++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTIX", &DIMTIX) &&
        DIMTIX == dimstyle->DIMTIX)
      pass ("DIMSTYLE.DIMTIX [B] set+1 " FORMAT_B "", DIMTIX);
    else
      {
        fail ("DIMSTYLE.DIMTIX [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIX, DIMTIX); error++;
      }
    dimstyle->DIMTIX--;

  }
  {
    BITCODE_BD DIMTM;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTM", &DIMTM, NULL) &&
        DIMTM == dimstyle->DIMTM)
      pass ("DIMSTYLE.DIMTM [BD] %g", DIMTM);
    else
      {
        fail ("DIMSTYLE.DIMTM [BD] %g != %g", dimstyle->DIMTM, DIMTM); error++;
      }
    DIMTM++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTM", &DIMTM) &&
        DIMTM == dimstyle->DIMTM)
      pass ("DIMSTYLE.DIMTM [BD] set+1 %g", DIMTM);
    else
      {
        fail ("DIMSTYLE.DIMTM [BD] set+1 %g != %g", dimstyle->DIMTM, DIMTM); error++;
      }
    dimstyle->DIMTM--;

  }
  {
    BITCODE_BS DIMTMOVE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTMOVE", &DIMTMOVE, NULL) &&
        DIMTMOVE == dimstyle->DIMTMOVE)
      pass ("DIMSTYLE.DIMTMOVE [BS] %hu", DIMTMOVE);
    else
      {
        fail ("DIMSTYLE.DIMTMOVE [BS] %hu != %hu", dimstyle->DIMTMOVE, DIMTMOVE); error++;
      }
    DIMTMOVE++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTMOVE", &DIMTMOVE) &&
        DIMTMOVE == dimstyle->DIMTMOVE)
      pass ("DIMSTYLE.DIMTMOVE [BS] set+1 %hu", DIMTMOVE);
    else
      {
        fail ("DIMSTYLE.DIMTMOVE [BS] set+1 %hu != %hu", dimstyle->DIMTMOVE, DIMTMOVE); error++;
      }
    dimstyle->DIMTMOVE--;

  }
  {
    BITCODE_B DIMTOFL;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTOFL", &DIMTOFL, NULL) &&
        DIMTOFL == dimstyle->DIMTOFL)
      pass ("DIMSTYLE.DIMTOFL [B] " FORMAT_B "", DIMTOFL);
    else
      {
        fail ("DIMSTYLE.DIMTOFL [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOFL, DIMTOFL); error++;
      }
    DIMTOFL++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTOFL", &DIMTOFL) &&
        DIMTOFL == dimstyle->DIMTOFL)
      pass ("DIMSTYLE.DIMTOFL [B] set+1 " FORMAT_B "", DIMTOFL);
    else
      {
        fail ("DIMSTYLE.DIMTOFL [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOFL, DIMTOFL); error++;
      }
    dimstyle->DIMTOFL--;

  }
  {
    BITCODE_B DIMTOH;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTOH", &DIMTOH, NULL) &&
        DIMTOH == dimstyle->DIMTOH)
      pass ("DIMSTYLE.DIMTOH [B] " FORMAT_B "", DIMTOH);
    else
      {
        fail ("DIMSTYLE.DIMTOH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOH, DIMTOH); error++;
      }
    DIMTOH++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTOH", &DIMTOH) &&
        DIMTOH == dimstyle->DIMTOH)
      pass ("DIMSTYLE.DIMTOH [B] set+1 " FORMAT_B "", DIMTOH);
    else
      {
        fail ("DIMSTYLE.DIMTOH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOH, DIMTOH); error++;
      }
    dimstyle->DIMTOH--;

  }
  {
    BITCODE_B DIMTOL;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTOL", &DIMTOL, NULL) &&
        DIMTOL == dimstyle->DIMTOL)
      pass ("DIMSTYLE.DIMTOL [B] " FORMAT_B "", DIMTOL);
    else
      {
        fail ("DIMSTYLE.DIMTOL [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOL, DIMTOL); error++;
      }
    DIMTOL++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTOL", &DIMTOL) &&
        DIMTOL == dimstyle->DIMTOL)
      pass ("DIMSTYLE.DIMTOL [B] set+1 " FORMAT_B "", DIMTOL);
    else
      {
        fail ("DIMSTYLE.DIMTOL [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOL, DIMTOL); error++;
      }
    dimstyle->DIMTOL--;

  }
  {
    BITCODE_BS DIMTOLJ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTOLJ", &DIMTOLJ, NULL) &&
        DIMTOLJ == dimstyle->DIMTOLJ)
      pass ("DIMSTYLE.DIMTOLJ [BS] %hu", DIMTOLJ);
    else
      {
        fail ("DIMSTYLE.DIMTOLJ [BS] %hu != %hu", dimstyle->DIMTOLJ, DIMTOLJ); error++;
      }
    DIMTOLJ++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTOLJ", &DIMTOLJ) &&
        DIMTOLJ == dimstyle->DIMTOLJ)
      pass ("DIMSTYLE.DIMTOLJ [BS] set+1 %hu", DIMTOLJ);
    else
      {
        fail ("DIMSTYLE.DIMTOLJ [BS] set+1 %hu != %hu", dimstyle->DIMTOLJ, DIMTOLJ); error++;
      }
    dimstyle->DIMTOLJ--;

  }
  {
    BITCODE_BD DIMTP;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTP", &DIMTP, NULL) &&
        DIMTP == dimstyle->DIMTP)
      pass ("DIMSTYLE.DIMTP [BD] %g", DIMTP);
    else
      {
        fail ("DIMSTYLE.DIMTP [BD] %g != %g", dimstyle->DIMTP, DIMTP); error++;
      }
    DIMTP++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTP", &DIMTP) &&
        DIMTP == dimstyle->DIMTP)
      pass ("DIMSTYLE.DIMTP [BD] set+1 %g", DIMTP);
    else
      {
        fail ("DIMSTYLE.DIMTP [BD] set+1 %g != %g", dimstyle->DIMTP, DIMTP); error++;
      }
    dimstyle->DIMTP--;

  }
  {
    BITCODE_BD DIMTSZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTSZ", &DIMTSZ, NULL) &&
        DIMTSZ == dimstyle->DIMTSZ)
      pass ("DIMSTYLE.DIMTSZ [BD] %g", DIMTSZ);
    else
      {
        fail ("DIMSTYLE.DIMTSZ [BD] %g != %g", dimstyle->DIMTSZ, DIMTSZ); error++;
      }
    DIMTSZ++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTSZ", &DIMTSZ) &&
        DIMTSZ == dimstyle->DIMTSZ)
      pass ("DIMSTYLE.DIMTSZ [BD] set+1 %g", DIMTSZ);
    else
      {
        fail ("DIMSTYLE.DIMTSZ [BD] set+1 %g != %g", dimstyle->DIMTSZ, DIMTSZ); error++;
      }
    dimstyle->DIMTSZ--;

  }
  {
    BITCODE_BD DIMTVP;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTVP", &DIMTVP, NULL) &&
        DIMTVP == dimstyle->DIMTVP)
      pass ("DIMSTYLE.DIMTVP [BD] %g", DIMTVP);
    else
      {
        fail ("DIMSTYLE.DIMTVP [BD] %g != %g", dimstyle->DIMTVP, DIMTVP); error++;
      }
    DIMTVP++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTVP", &DIMTVP) &&
        DIMTVP == dimstyle->DIMTVP)
      pass ("DIMSTYLE.DIMTVP [BD] set+1 %g", DIMTVP);
    else
      {
        fail ("DIMSTYLE.DIMTVP [BD] set+1 %g != %g", dimstyle->DIMTVP, DIMTVP); error++;
      }
    dimstyle->DIMTVP--;

  }
  {
    BITCODE_H DIMTXSTY;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTXSTY", &DIMTXSTY, NULL)
        && !memcmp(&DIMTXSTY, &dimstyle->DIMTXSTY, sizeof(dimstyle->DIMTXSTY)))
      pass ("DIMSTYLE.DIMTXSTY [H]");
    else
      {
        fail ("DIMSTYLE.DIMTXSTY [H]"); error++;
      }
  }
  {
    BITCODE_BD DIMTXT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTXT", &DIMTXT, NULL) &&
        DIMTXT == dimstyle->DIMTXT)
      pass ("DIMSTYLE.DIMTXT [BD] %g", DIMTXT);
    else
      {
        fail ("DIMSTYLE.DIMTXT [BD] %g != %g", dimstyle->DIMTXT, DIMTXT); error++;
      }
    DIMTXT++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTXT", &DIMTXT) &&
        DIMTXT == dimstyle->DIMTXT)
      pass ("DIMSTYLE.DIMTXT [BD] set+1 %g", DIMTXT);
    else
      {
        fail ("DIMSTYLE.DIMTXT [BD] set+1 %g != %g", dimstyle->DIMTXT, DIMTXT); error++;
      }
    dimstyle->DIMTXT--;

  }
  {
    BITCODE_B DIMTXTDIRECTION;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTXTDIRECTION", &DIMTXTDIRECTION, NULL) &&
        DIMTXTDIRECTION == dimstyle->DIMTXTDIRECTION)
      pass ("DIMSTYLE.DIMTXTDIRECTION [B] " FORMAT_B "", DIMTXTDIRECTION);
    else
      {
        fail ("DIMSTYLE.DIMTXTDIRECTION [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTXTDIRECTION, DIMTXTDIRECTION); error++;
      }
    DIMTXTDIRECTION++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTXTDIRECTION", &DIMTXTDIRECTION) &&
        DIMTXTDIRECTION == dimstyle->DIMTXTDIRECTION)
      pass ("DIMSTYLE.DIMTXTDIRECTION [B] set+1 " FORMAT_B "", DIMTXTDIRECTION);
    else
      {
        fail ("DIMSTYLE.DIMTXTDIRECTION [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTXTDIRECTION, DIMTXTDIRECTION); error++;
      }
    dimstyle->DIMTXTDIRECTION--;

  }
  {
    BITCODE_BS DIMTZIN;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTZIN", &DIMTZIN, NULL) &&
        DIMTZIN == dimstyle->DIMTZIN)
      pass ("DIMSTYLE.DIMTZIN [BS] %hu", DIMTZIN);
    else
      {
        fail ("DIMSTYLE.DIMTZIN [BS] %hu != %hu", dimstyle->DIMTZIN, DIMTZIN); error++;
      }
    DIMTZIN++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMTZIN", &DIMTZIN) &&
        DIMTZIN == dimstyle->DIMTZIN)
      pass ("DIMSTYLE.DIMTZIN [BS] set+1 %hu", DIMTZIN);
    else
      {
        fail ("DIMSTYLE.DIMTZIN [BS] set+1 %hu != %hu", dimstyle->DIMTZIN, DIMTZIN); error++;
      }
    dimstyle->DIMTZIN--;

  }
  {
    BITCODE_BS DIMUNIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMUNIT", &DIMUNIT, NULL) &&
        DIMUNIT == dimstyle->DIMUNIT)
      pass ("DIMSTYLE.DIMUNIT [BS] %hu", DIMUNIT);
    else
      {
        fail ("DIMSTYLE.DIMUNIT [BS] %hu != %hu", dimstyle->DIMUNIT, DIMUNIT); error++;
      }
    DIMUNIT++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMUNIT", &DIMUNIT) &&
        DIMUNIT == dimstyle->DIMUNIT)
      pass ("DIMSTYLE.DIMUNIT [BS] set+1 %hu", DIMUNIT);
    else
      {
        fail ("DIMSTYLE.DIMUNIT [BS] set+1 %hu != %hu", dimstyle->DIMUNIT, DIMUNIT); error++;
      }
    dimstyle->DIMUNIT--;

  }
  {
    BITCODE_B DIMUPT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMUPT", &DIMUPT, NULL) &&
        DIMUPT == dimstyle->DIMUPT)
      pass ("DIMSTYLE.DIMUPT [B] " FORMAT_B "", DIMUPT);
    else
      {
        fail ("DIMSTYLE.DIMUPT [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMUPT, DIMUPT); error++;
      }
    DIMUPT++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMUPT", &DIMUPT) &&
        DIMUPT == dimstyle->DIMUPT)
      pass ("DIMSTYLE.DIMUPT [B] set+1 " FORMAT_B "", DIMUPT);
    else
      {
        fail ("DIMSTYLE.DIMUPT [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMUPT, DIMUPT); error++;
      }
    dimstyle->DIMUPT--;

  }
  {
    BITCODE_BS DIMZIN;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMZIN", &DIMZIN, NULL) &&
        DIMZIN == dimstyle->DIMZIN)
      pass ("DIMSTYLE.DIMZIN [BS] %hu", DIMZIN);
    else
      {
        fail ("DIMSTYLE.DIMZIN [BS] %hu != %hu", dimstyle->DIMZIN, DIMZIN); error++;
      }
    DIMZIN++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "DIMZIN", &DIMZIN) &&
        DIMZIN == dimstyle->DIMZIN)
      pass ("DIMSTYLE.DIMZIN [BS] set+1 %hu", DIMZIN);
    else
      {
        fail ("DIMSTYLE.DIMZIN [BS] set+1 %hu != %hu", dimstyle->DIMZIN, DIMZIN); error++;
      }
    dimstyle->DIMZIN--;

  }
  {
    BITCODE_H dimstyle_control;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "dimstyle_control", &dimstyle_control, NULL)
        && !memcmp(&dimstyle_control, &dimstyle->dimstyle_control, sizeof(dimstyle->dimstyle_control)))
      pass ("DIMSTYLE.dimstyle_control [H]");
    else
      {
        fail ("DIMSTYLE.dimstyle_control [H]"); error++;
      }
  }
  {
    BITCODE_H extref_handle;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "extref_handle", &extref_handle, NULL)
        && !memcmp(&extref_handle, &dimstyle->extref_handle, sizeof(dimstyle->extref_handle)))
      pass ("DIMSTYLE.extref_handle [H]");
    else
      {
        fail ("DIMSTYLE.extref_handle [H]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "flag", &flag, NULL) &&
        flag == dimstyle->flag)
      pass ("DIMSTYLE.flag [RC] %u", flag);
    else
      {
        fail ("DIMSTYLE.flag [RC] %u != %u", dimstyle->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "flag", &flag) &&
        flag == dimstyle->flag)
      pass ("DIMSTYLE.flag [RC] set+1 %u", flag);
    else
      {
        fail ("DIMSTYLE.flag [RC] set+1 %u != %u", dimstyle->flag, flag); error++;
      }
    dimstyle->flag--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&dimstyle->name))
      pass ("DIMSTYLE.name [TV]");
    else
      {
        fail ("DIMSTYLE.name [TV]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &dimstyle->parent, sizeof(dimstyle->parent)))
      pass ("DIMSTYLE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DIMSTYLE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "used", &used, NULL) &&
        used == dimstyle->used)
      pass ("DIMSTYLE.used [RS] %hu", used);
    else
      {
        fail ("DIMSTYLE.used [RS] %hu != %hu", dimstyle->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "used", &used) &&
        used == dimstyle->used)
      pass ("DIMSTYLE.used [RS] set+1 %hu", used);
    else
      {
        fail ("DIMSTYLE.used [RS] set+1 %hu != %hu", dimstyle->used, used); error++;
      }
    dimstyle->used--;

  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "xrefdep", &xrefdep, NULL) &&
        xrefdep == dimstyle->xrefdep)
      pass ("DIMSTYLE.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("DIMSTYLE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", dimstyle->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "xrefdep", &xrefdep) &&
        xrefdep == dimstyle->xrefdep)
      pass ("DIMSTYLE.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("DIMSTYLE.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->xrefdep, xrefdep); error++;
      }
    dimstyle->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == dimstyle->xrefindex_plus1)
      pass ("DIMSTYLE.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("DIMSTYLE.xrefindex_plus1 [BS] %hu != %hu", dimstyle->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == dimstyle->xrefindex_plus1)
      pass ("DIMSTYLE.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("DIMSTYLE.xrefindex_plus1 [BS] set+1 %hu != %hu", dimstyle->xrefindex_plus1, xrefindex_plus1); error++;
      }
    dimstyle->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "xrefref", &xrefref, NULL) &&
        xrefref == dimstyle->xrefref)
      pass ("DIMSTYLE.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("DIMSTYLE.xrefref [B] " FORMAT_B " != " FORMAT_B "", dimstyle->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(dimstyle, "DIMSTYLE", "xrefref", &xrefref) &&
        xrefref == dimstyle->xrefref)
      pass ("DIMSTYLE.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("DIMSTYLE.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->xrefref, xrefref); error++;
      }
    dimstyle->xrefref--;

  }
  return error;
}
static int test_DIMSTYLE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DIMSTYLE_CONTROL *dimstyle_control = obj->tio.object->tio.DIMSTYLE_CONTROL;
  {
    BITCODE_H dimstyles;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "dimstyles", &dimstyles, NULL)
        && !memcmp(&dimstyles, &dimstyle_control->dimstyles, sizeof(dimstyle_control->dimstyles)))
      pass ("DIMSTYLE_CONTROL.dimstyles [H]");
    else
      {
        fail ("DIMSTYLE_CONTROL.dimstyles [H]"); error++;
      }
  }
  {
    BITCODE_H* morehandles;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "morehandles", &morehandles, NULL)
        && !memcmp(&morehandles, &dimstyle_control->morehandles, sizeof(dimstyle_control->morehandles)))
      pass ("DIMSTYLE_CONTROL.morehandles [H*]");
    else
      {
        fail ("DIMSTYLE_CONTROL.morehandles [H*]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &dimstyle_control->null_handle, sizeof(dimstyle_control->null_handle)))
      pass ("DIMSTYLE_CONTROL.null_handle [H]");
    else
      {
        fail ("DIMSTYLE_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == dimstyle_control->num_entries)
      pass ("DIMSTYLE_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("DIMSTYLE_CONTROL.num_entries [BS] %hu != %hu", dimstyle_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &num_entries) &&
        num_entries == dimstyle_control->num_entries)
      pass ("DIMSTYLE_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("DIMSTYLE_CONTROL.num_entries [BS] set+1 %hu != %hu", dimstyle_control->num_entries, num_entries); error++;
      }
    dimstyle_control->num_entries--;

  }
  {
    BITCODE_RC num_morehandles;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &num_morehandles, NULL) &&
        num_morehandles == dimstyle_control->num_morehandles)
      pass ("DIMSTYLE_CONTROL.num_morehandles [RC] %u", num_morehandles);
    else
      {
        fail ("DIMSTYLE_CONTROL.num_morehandles [RC] %u != %u", dimstyle_control->num_morehandles, num_morehandles); error++;
      }
    num_morehandles++;
    if (dwg_dynapi_entity_set_value(dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &num_morehandles) &&
        num_morehandles == dimstyle_control->num_morehandles)
      pass ("DIMSTYLE_CONTROL.num_morehandles [RC] set+1 %u", num_morehandles);
    else
      {
        fail ("DIMSTYLE_CONTROL.num_morehandles [RC] set+1 %u != %u", dimstyle_control->num_morehandles, num_morehandles); error++;
      }
    dimstyle_control->num_morehandles--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "objid", &objid, NULL) &&
        objid == dimstyle_control->objid)
      pass ("DIMSTYLE_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("DIMSTYLE_CONTROL.objid [BL] %u != %u", dimstyle_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(dimstyle_control, "DIMSTYLE_CONTROL", "objid", &objid) &&
        objid == dimstyle_control->objid)
      pass ("DIMSTYLE_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("DIMSTYLE_CONTROL.objid [BL] set+1 %u != %u", dimstyle_control->objid, objid); error++;
      }
    dimstyle_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &dimstyle_control->parent, sizeof(dimstyle_control->parent)))
      pass ("DIMSTYLE_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DIMSTYLE_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &dimstyle_control->reactors, sizeof(dimstyle_control->reactors)))
      pass ("DIMSTYLE_CONTROL.reactors [H]");
    else
      {
        fail ("DIMSTYLE_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &dimstyle_control->xdicobjhandle, sizeof(dimstyle_control->xdicobjhandle)))
      pass ("DIMSTYLE_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("DIMSTYLE_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_DUMMY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DUMMY *dummy = obj->tio.object->tio.DUMMY;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dummy, "DUMMY", "parent", &parent, NULL)
        && !memcmp(&parent, &dummy->parent, sizeof(dummy->parent)))
      pass ("DUMMY.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DUMMY.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_DYNAMICBLOCKPURGEPREVENTER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DYNAMICBLOCKPURGEPREVENTER *dynamicblockpurgepreventer = obj->tio.object->tio.DYNAMICBLOCKPURGEPREVENTER;
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "flag", &flag, NULL) &&
        flag == dynamicblockpurgepreventer->flag)
      pass ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] %hu", flag);
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] %hu != %hu", dynamicblockpurgepreventer->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "flag", &flag) &&
        flag == dynamicblockpurgepreventer->flag)
      pass ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] set+1 %hu != %hu", dynamicblockpurgepreventer->flag, flag); error++;
      }
    dynamicblockpurgepreventer->flag--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &dynamicblockpurgepreventer->ownerhandle, sizeof(dynamicblockpurgepreventer->ownerhandle)))
      pass ("DYNAMICBLOCKPURGEPREVENTER.ownerhandle [H]");
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "parent", &parent, NULL)
        && !memcmp(&parent, &dynamicblockpurgepreventer->parent, sizeof(dynamicblockpurgepreventer->parent)))
      pass ("DYNAMICBLOCKPURGEPREVENTER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_RS unknown_rs1;
    if (dwg_dynapi_entity_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "unknown_rs1", &unknown_rs1, NULL) &&
        unknown_rs1 == dynamicblockpurgepreventer->unknown_rs1)
      pass ("DYNAMICBLOCKPURGEPREVENTER.unknown_rs1 [RS] %hu", unknown_rs1);
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.unknown_rs1 [RS] %hu != %hu", dynamicblockpurgepreventer->unknown_rs1, unknown_rs1); error++;
      }
    unknown_rs1++;
    if (dwg_dynapi_entity_set_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "unknown_rs1", &unknown_rs1) &&
        unknown_rs1 == dynamicblockpurgepreventer->unknown_rs1)
      pass ("DYNAMICBLOCKPURGEPREVENTER.unknown_rs1 [RS] set+1 %hu", unknown_rs1);
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.unknown_rs1 [RS] set+1 %hu != %hu", dynamicblockpurgepreventer->unknown_rs1, unknown_rs1); error++;
      }
    dynamicblockpurgepreventer->unknown_rs1--;

  }
  return error;
}
static int test_EVALUATION_GRAPH (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_EVALUATION_GRAPH *evaluation_graph = obj->tio.object->tio.EVALUATION_GRAPH;
  {
    BITCODE_BL edge_flags;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "edge_flags", &edge_flags, NULL) &&
        edge_flags == evaluation_graph->edge_flags)
      pass ("EVALUATION_GRAPH.edge_flags [BL] %u", edge_flags);
    else
      {
        fail ("EVALUATION_GRAPH.edge_flags [BL] %u != %u", evaluation_graph->edge_flags, edge_flags); error++;
      }
    edge_flags++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "edge_flags", &edge_flags) &&
        edge_flags == evaluation_graph->edge_flags)
      pass ("EVALUATION_GRAPH.edge_flags [BL] set+1 %u", edge_flags);
    else
      {
        fail ("EVALUATION_GRAPH.edge_flags [BL] set+1 %u != %u", evaluation_graph->edge_flags, edge_flags); error++;
      }
    evaluation_graph->edge_flags--;

  }
  {
    BITCODE_H evalexpr;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "evalexpr", &evalexpr, NULL)
        && !memcmp(&evalexpr, &evaluation_graph->evalexpr, sizeof(evaluation_graph->evalexpr)))
      pass ("EVALUATION_GRAPH.evalexpr [H]");
    else
      {
        fail ("EVALUATION_GRAPH.evalexpr [H]"); error++;
      }
  }
  {
    BITCODE_BL has_graph;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "has_graph", &has_graph, NULL) &&
        has_graph == evaluation_graph->has_graph)
      pass ("EVALUATION_GRAPH.has_graph [BL] %u", has_graph);
    else
      {
        fail ("EVALUATION_GRAPH.has_graph [BL] %u != %u", evaluation_graph->has_graph, has_graph); error++;
      }
    has_graph++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "has_graph", &has_graph) &&
        has_graph == evaluation_graph->has_graph)
      pass ("EVALUATION_GRAPH.has_graph [BL] set+1 %u", has_graph);
    else
      {
        fail ("EVALUATION_GRAPH.has_graph [BL] set+1 %u != %u", evaluation_graph->has_graph, has_graph); error++;
      }
    evaluation_graph->has_graph--;

  }
  {
    BITCODE_BL node_edge1;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge1", &node_edge1, NULL) &&
        node_edge1 == evaluation_graph->node_edge1)
      pass ("EVALUATION_GRAPH.node_edge1 [BL] %u", node_edge1);
    else
      {
        fail ("EVALUATION_GRAPH.node_edge1 [BL] %u != %u", evaluation_graph->node_edge1, node_edge1); error++;
      }
    node_edge1++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge1", &node_edge1) &&
        node_edge1 == evaluation_graph->node_edge1)
      pass ("EVALUATION_GRAPH.node_edge1 [BL] set+1 %u", node_edge1);
    else
      {
        fail ("EVALUATION_GRAPH.node_edge1 [BL] set+1 %u != %u", evaluation_graph->node_edge1, node_edge1); error++;
      }
    evaluation_graph->node_edge1--;

  }
  {
    BITCODE_BL node_edge2;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge2", &node_edge2, NULL) &&
        node_edge2 == evaluation_graph->node_edge2)
      pass ("EVALUATION_GRAPH.node_edge2 [BL] %u", node_edge2);
    else
      {
        fail ("EVALUATION_GRAPH.node_edge2 [BL] %u != %u", evaluation_graph->node_edge2, node_edge2); error++;
      }
    node_edge2++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge2", &node_edge2) &&
        node_edge2 == evaluation_graph->node_edge2)
      pass ("EVALUATION_GRAPH.node_edge2 [BL] set+1 %u", node_edge2);
    else
      {
        fail ("EVALUATION_GRAPH.node_edge2 [BL] set+1 %u != %u", evaluation_graph->node_edge2, node_edge2); error++;
      }
    evaluation_graph->node_edge2--;

  }
  {
    BITCODE_BL node_edge3;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge3", &node_edge3, NULL) &&
        node_edge3 == evaluation_graph->node_edge3)
      pass ("EVALUATION_GRAPH.node_edge3 [BL] %u", node_edge3);
    else
      {
        fail ("EVALUATION_GRAPH.node_edge3 [BL] %u != %u", evaluation_graph->node_edge3, node_edge3); error++;
      }
    node_edge3++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge3", &node_edge3) &&
        node_edge3 == evaluation_graph->node_edge3)
      pass ("EVALUATION_GRAPH.node_edge3 [BL] set+1 %u", node_edge3);
    else
      {
        fail ("EVALUATION_GRAPH.node_edge3 [BL] set+1 %u != %u", evaluation_graph->node_edge3, node_edge3); error++;
      }
    evaluation_graph->node_edge3--;

  }
  {
    BITCODE_BL node_edge4;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge4", &node_edge4, NULL) &&
        node_edge4 == evaluation_graph->node_edge4)
      pass ("EVALUATION_GRAPH.node_edge4 [BL] %u", node_edge4);
    else
      {
        fail ("EVALUATION_GRAPH.node_edge4 [BL] %u != %u", evaluation_graph->node_edge4, node_edge4); error++;
      }
    node_edge4++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge4", &node_edge4) &&
        node_edge4 == evaluation_graph->node_edge4)
      pass ("EVALUATION_GRAPH.node_edge4 [BL] set+1 %u", node_edge4);
    else
      {
        fail ("EVALUATION_GRAPH.node_edge4 [BL] set+1 %u != %u", evaluation_graph->node_edge4, node_edge4); error++;
      }
    evaluation_graph->node_edge4--;

  }
  {
    BITCODE_BL nodeid;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "nodeid", &nodeid, NULL) &&
        nodeid == evaluation_graph->nodeid)
      pass ("EVALUATION_GRAPH.nodeid [BL] %u", nodeid);
    else
      {
        fail ("EVALUATION_GRAPH.nodeid [BL] %u != %u", evaluation_graph->nodeid, nodeid); error++;
      }
    nodeid++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "nodeid", &nodeid) &&
        nodeid == evaluation_graph->nodeid)
      pass ("EVALUATION_GRAPH.nodeid [BL] set+1 %u", nodeid);
    else
      {
        fail ("EVALUATION_GRAPH.nodeid [BL] set+1 %u != %u", evaluation_graph->nodeid, nodeid); error++;
      }
    evaluation_graph->nodeid--;

  }
  {
    BITCODE_BL num_evalexpr;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "num_evalexpr", &num_evalexpr, NULL) &&
        num_evalexpr == evaluation_graph->num_evalexpr)
      pass ("EVALUATION_GRAPH.num_evalexpr [BL] %u", num_evalexpr);
    else
      {
        fail ("EVALUATION_GRAPH.num_evalexpr [BL] %u != %u", evaluation_graph->num_evalexpr, num_evalexpr); error++;
      }
    num_evalexpr++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "num_evalexpr", &num_evalexpr) &&
        num_evalexpr == evaluation_graph->num_evalexpr)
      pass ("EVALUATION_GRAPH.num_evalexpr [BL] set+1 %u", num_evalexpr);
    else
      {
        fail ("EVALUATION_GRAPH.num_evalexpr [BL] set+1 %u != %u", evaluation_graph->num_evalexpr, num_evalexpr); error++;
      }
    evaluation_graph->num_evalexpr--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &evaluation_graph->ownerhandle, sizeof(evaluation_graph->ownerhandle)))
      pass ("EVALUATION_GRAPH.ownerhandle [H]");
    else
      {
        fail ("EVALUATION_GRAPH.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "parent", &parent, NULL)
        && !memcmp(&parent, &evaluation_graph->parent, sizeof(evaluation_graph->parent)))
      pass ("EVALUATION_GRAPH.parent [struct _dwg_object_object*]");
    else
      {
        fail ("EVALUATION_GRAPH.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BL unknown1;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "unknown1", &unknown1, NULL) &&
        unknown1 == evaluation_graph->unknown1)
      pass ("EVALUATION_GRAPH.unknown1 [BL] %u", unknown1);
    else
      {
        fail ("EVALUATION_GRAPH.unknown1 [BL] %u != %u", evaluation_graph->unknown1, unknown1); error++;
      }
    unknown1++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "unknown1", &unknown1) &&
        unknown1 == evaluation_graph->unknown1)
      pass ("EVALUATION_GRAPH.unknown1 [BL] set+1 %u", unknown1);
    else
      {
        fail ("EVALUATION_GRAPH.unknown1 [BL] set+1 %u != %u", evaluation_graph->unknown1, unknown1); error++;
      }
    evaluation_graph->unknown1--;

  }
  {
    BITCODE_BL unknown2;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "unknown2", &unknown2, NULL) &&
        unknown2 == evaluation_graph->unknown2)
      pass ("EVALUATION_GRAPH.unknown2 [BL] %u", unknown2);
    else
      {
        fail ("EVALUATION_GRAPH.unknown2 [BL] %u != %u", evaluation_graph->unknown2, unknown2); error++;
      }
    unknown2++;
    if (dwg_dynapi_entity_set_value(evaluation_graph, "EVALUATION_GRAPH", "unknown2", &unknown2) &&
        unknown2 == evaluation_graph->unknown2)
      pass ("EVALUATION_GRAPH.unknown2 [BL] set+1 %u", unknown2);
    else
      {
        fail ("EVALUATION_GRAPH.unknown2 [BL] set+1 %u != %u", evaluation_graph->unknown2, unknown2); error++;
      }
    evaluation_graph->unknown2--;

  }
  return error;
}
static int test_FIELD (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_FIELD *field = obj->tio.object->tio.FIELD;
  {
    BITCODE_H childs;
    if (dwg_dynapi_entity_value(field, "FIELD", "childs", &childs, NULL)
        && !memcmp(&childs, &field->childs, sizeof(field->childs)))
      pass ("FIELD.childs [H]");
    else
      {
        fail ("FIELD.childs [H]"); error++;
      }
  }
  {
    Dwg_FIELD_ChildValue* childval;
    if (dwg_dynapi_entity_value(field, "FIELD", "childval", &childval, NULL)
        && !memcmp(&childval, &field->childval, sizeof(field->childval)))
      pass ("FIELD.childval [Dwg_FIELD_ChildValue*]");
    else
      {
        fail ("FIELD.childval [Dwg_FIELD_ChildValue*]"); error++;
      }
  }
  {
    BITCODE_TV code;
    if (dwg_dynapi_entity_value(field, "FIELD", "code", &code, NULL)
        && !strcmp((char*)&code, (char*)&field->code))
      pass ("FIELD.code [TV]");
    else
      {
        fail ("FIELD.code [TV]"); error++;
      }
  }
  {
    BITCODE_BL evaluation_error_code;
    if (dwg_dynapi_entity_value(field, "FIELD", "evaluation_error_code", &evaluation_error_code, NULL) &&
        evaluation_error_code == field->evaluation_error_code)
      pass ("FIELD.evaluation_error_code [BL] %u", evaluation_error_code);
    else
      {
        fail ("FIELD.evaluation_error_code [BL] %u != %u", field->evaluation_error_code, evaluation_error_code); error++;
      }
    evaluation_error_code++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "evaluation_error_code", &evaluation_error_code) &&
        evaluation_error_code == field->evaluation_error_code)
      pass ("FIELD.evaluation_error_code [BL] set+1 %u", evaluation_error_code);
    else
      {
        fail ("FIELD.evaluation_error_code [BL] set+1 %u != %u", field->evaluation_error_code, evaluation_error_code); error++;
      }
    field->evaluation_error_code--;

  }
  {
    BITCODE_TV evaluation_error_msg;
    if (dwg_dynapi_entity_value(field, "FIELD", "evaluation_error_msg", &evaluation_error_msg, NULL)
        && !strcmp((char*)&evaluation_error_msg, (char*)&field->evaluation_error_msg))
      pass ("FIELD.evaluation_error_msg [TV]");
    else
      {
        fail ("FIELD.evaluation_error_msg [TV]"); error++;
      }
  }
  {
    BITCODE_BL evaluation_option;
    if (dwg_dynapi_entity_value(field, "FIELD", "evaluation_option", &evaluation_option, NULL) &&
        evaluation_option == field->evaluation_option)
      pass ("FIELD.evaluation_option [BL] %u", evaluation_option);
    else
      {
        fail ("FIELD.evaluation_option [BL] %u != %u", field->evaluation_option, evaluation_option); error++;
      }
    evaluation_option++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "evaluation_option", &evaluation_option) &&
        evaluation_option == field->evaluation_option)
      pass ("FIELD.evaluation_option [BL] set+1 %u", evaluation_option);
    else
      {
        fail ("FIELD.evaluation_option [BL] set+1 %u != %u", field->evaluation_option, evaluation_option); error++;
      }
    field->evaluation_option--;

  }
  {
    BITCODE_BL evaluation_status;
    if (dwg_dynapi_entity_value(field, "FIELD", "evaluation_status", &evaluation_status, NULL) &&
        evaluation_status == field->evaluation_status)
      pass ("FIELD.evaluation_status [BL] %u", evaluation_status);
    else
      {
        fail ("FIELD.evaluation_status [BL] %u != %u", field->evaluation_status, evaluation_status); error++;
      }
    evaluation_status++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "evaluation_status", &evaluation_status) &&
        evaluation_status == field->evaluation_status)
      pass ("FIELD.evaluation_status [BL] set+1 %u", evaluation_status);
    else
      {
        fail ("FIELD.evaluation_status [BL] set+1 %u != %u", field->evaluation_status, evaluation_status); error++;
      }
    field->evaluation_status--;

  }
  {
    BITCODE_BL field_state;
    if (dwg_dynapi_entity_value(field, "FIELD", "field_state", &field_state, NULL) &&
        field_state == field->field_state)
      pass ("FIELD.field_state [BL] %u", field_state);
    else
      {
        fail ("FIELD.field_state [BL] %u != %u", field->field_state, field_state); error++;
      }
    field_state++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "field_state", &field_state) &&
        field_state == field->field_state)
      pass ("FIELD.field_state [BL] set+1 %u", field_state);
    else
      {
        fail ("FIELD.field_state [BL] set+1 %u != %u", field->field_state, field_state); error++;
      }
    field->field_state--;

  }
  {
    BITCODE_BL filing_option;
    if (dwg_dynapi_entity_value(field, "FIELD", "filing_option", &filing_option, NULL) &&
        filing_option == field->filing_option)
      pass ("FIELD.filing_option [BL] %u", filing_option);
    else
      {
        fail ("FIELD.filing_option [BL] %u != %u", field->filing_option, filing_option); error++;
      }
    filing_option++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "filing_option", &filing_option) &&
        filing_option == field->filing_option)
      pass ("FIELD.filing_option [BL] set+1 %u", filing_option);
    else
      {
        fail ("FIELD.filing_option [BL] set+1 %u != %u", field->filing_option, filing_option); error++;
      }
    field->filing_option--;

  }
  {
    BITCODE_TV format;
    if (dwg_dynapi_entity_value(field, "FIELD", "format", &format, NULL)
        && !strcmp((char*)&format, (char*)&field->format))
      pass ("FIELD.format [TV]");
    else
      {
        fail ("FIELD.format [TV]"); error++;
      }
  }
  {
    BITCODE_TV id;
    if (dwg_dynapi_entity_value(field, "FIELD", "id", &id, NULL)
        && !strcmp((char*)&id, (char*)&field->id))
      pass ("FIELD.id [TV]");
    else
      {
        fail ("FIELD.id [TV]"); error++;
      }
  }
  {
    BITCODE_BL num_childs;
    if (dwg_dynapi_entity_value(field, "FIELD", "num_childs", &num_childs, NULL) &&
        num_childs == field->num_childs)
      pass ("FIELD.num_childs [BL] %u", num_childs);
    else
      {
        fail ("FIELD.num_childs [BL] %u != %u", field->num_childs, num_childs); error++;
      }
    num_childs++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "num_childs", &num_childs) &&
        num_childs == field->num_childs)
      pass ("FIELD.num_childs [BL] set+1 %u", num_childs);
    else
      {
        fail ("FIELD.num_childs [BL] set+1 %u != %u", field->num_childs, num_childs); error++;
      }
    field->num_childs--;

  }
  {
    BITCODE_BL num_childval;
    if (dwg_dynapi_entity_value(field, "FIELD", "num_childval", &num_childval, NULL) &&
        num_childval == field->num_childval)
      pass ("FIELD.num_childval [BL] %u", num_childval);
    else
      {
        fail ("FIELD.num_childval [BL] %u != %u", field->num_childval, num_childval); error++;
      }
    num_childval++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "num_childval", &num_childval) &&
        num_childval == field->num_childval)
      pass ("FIELD.num_childval [BL] set+1 %u", num_childval);
    else
      {
        fail ("FIELD.num_childval [BL] set+1 %u != %u", field->num_childval, num_childval); error++;
      }
    field->num_childval--;

  }
  {
    BITCODE_BL num_objects;
    if (dwg_dynapi_entity_value(field, "FIELD", "num_objects", &num_objects, NULL) &&
        num_objects == field->num_objects)
      pass ("FIELD.num_objects [BL] %u", num_objects);
    else
      {
        fail ("FIELD.num_objects [BL] %u != %u", field->num_objects, num_objects); error++;
      }
    num_objects++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "num_objects", &num_objects) &&
        num_objects == field->num_objects)
      pass ("FIELD.num_objects [BL] set+1 %u", num_objects);
    else
      {
        fail ("FIELD.num_objects [BL] set+1 %u != %u", field->num_objects, num_objects); error++;
      }
    field->num_objects--;

  }
  {
    BITCODE_H objects;
    if (dwg_dynapi_entity_value(field, "FIELD", "objects", &objects, NULL)
        && !memcmp(&objects, &field->objects, sizeof(field->objects)))
      pass ("FIELD.objects [H]");
    else
      {
        fail ("FIELD.objects [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(field, "FIELD", "parent", &parent, NULL)
        && !memcmp(&parent, &field->parent, sizeof(field->parent)))
      pass ("FIELD.parent [struct _dwg_object_object*]");
    else
      {
        fail ("FIELD.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    Dwg_TABLE_value value;
    if (dwg_dynapi_entity_value(field, "FIELD", "value", &value, NULL)
        && !memcmp(&value, &field->value, sizeof(field->value)))
      pass ("FIELD.value [Dwg_TABLE_value]");
    else
      {
        fail ("FIELD.value [Dwg_TABLE_value]"); error++;
      }
  }
  {
    BITCODE_TV value_string;
    if (dwg_dynapi_entity_value(field, "FIELD", "value_string", &value_string, NULL)
        && !strcmp((char*)&value_string, (char*)&field->value_string))
      pass ("FIELD.value_string [TV]");
    else
      {
        fail ("FIELD.value_string [TV]"); error++;
      }
  }
  {
    BITCODE_BL value_string_length;
    if (dwg_dynapi_entity_value(field, "FIELD", "value_string_length", &value_string_length, NULL) &&
        value_string_length == field->value_string_length)
      pass ("FIELD.value_string_length [BL] %u", value_string_length);
    else
      {
        fail ("FIELD.value_string_length [BL] %u != %u", field->value_string_length, value_string_length); error++;
      }
    value_string_length++;
    if (dwg_dynapi_entity_set_value(field, "FIELD", "value_string_length", &value_string_length) &&
        value_string_length == field->value_string_length)
      pass ("FIELD.value_string_length [BL] set+1 %u", value_string_length);
    else
      {
        fail ("FIELD.value_string_length [BL] set+1 %u != %u", field->value_string_length, value_string_length); error++;
      }
    field->value_string_length--;

  }
  return error;
}
static int test_FIELDLIST (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_FIELDLIST *fieldlist = obj->tio.object->tio.FIELDLIST;
  {
    BITCODE_H field_handles;
    if (dwg_dynapi_entity_value(fieldlist, "FIELDLIST", "field_handles", &field_handles, NULL)
        && !memcmp(&field_handles, &fieldlist->field_handles, sizeof(fieldlist->field_handles)))
      pass ("FIELDLIST.field_handles [H]");
    else
      {
        fail ("FIELDLIST.field_handles [H]"); error++;
      }
  }
  {
    BITCODE_BL num_fields;
    if (dwg_dynapi_entity_value(fieldlist, "FIELDLIST", "num_fields", &num_fields, NULL) &&
        num_fields == fieldlist->num_fields)
      pass ("FIELDLIST.num_fields [BL] %u", num_fields);
    else
      {
        fail ("FIELDLIST.num_fields [BL] %u != %u", fieldlist->num_fields, num_fields); error++;
      }
    num_fields++;
    if (dwg_dynapi_entity_set_value(fieldlist, "FIELDLIST", "num_fields", &num_fields) &&
        num_fields == fieldlist->num_fields)
      pass ("FIELDLIST.num_fields [BL] set+1 %u", num_fields);
    else
      {
        fail ("FIELDLIST.num_fields [BL] set+1 %u != %u", fieldlist->num_fields, num_fields); error++;
      }
    fieldlist->num_fields--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(fieldlist, "FIELDLIST", "parent", &parent, NULL)
        && !memcmp(&parent, &fieldlist->parent, sizeof(fieldlist->parent)))
      pass ("FIELDLIST.parent [struct _dwg_object_object*]");
    else
      {
        fail ("FIELDLIST.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value(fieldlist, "FIELDLIST", "unknown", &unknown, NULL) &&
        unknown == fieldlist->unknown)
      pass ("FIELDLIST.unknown [B] " FORMAT_B "", unknown);
    else
      {
        fail ("FIELDLIST.unknown [B] " FORMAT_B " != " FORMAT_B "", fieldlist->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(fieldlist, "FIELDLIST", "unknown", &unknown) &&
        unknown == fieldlist->unknown)
      pass ("FIELDLIST.unknown [B] set+1 " FORMAT_B "", unknown);
    else
      {
        fail ("FIELDLIST.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", fieldlist->unknown, unknown); error++;
      }
    fieldlist->unknown--;

  }
  return error;
}
static int test_GEODATA (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_GEODATA *geodata = obj->tio.object->tio.GEODATA;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "class_version", &class_version, NULL) &&
        class_version == geodata->class_version)
      pass ("GEODATA.class_version [BL] %u", class_version);
    else
      {
        fail ("GEODATA.class_version [BL] %u != %u", geodata->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "class_version", &class_version) &&
        class_version == geodata->class_version)
      pass ("GEODATA.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("GEODATA.class_version [BL] set+1 %u != %u", geodata->class_version, class_version); error++;
      }
    geodata->class_version--;

  }
  {
    BITCODE_BD coord_proj_radius;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_proj_radius", &coord_proj_radius, NULL) &&
        coord_proj_radius == geodata->coord_proj_radius)
      pass ("GEODATA.coord_proj_radius [BD] %g", coord_proj_radius);
    else
      {
        fail ("GEODATA.coord_proj_radius [BD] %g != %g", geodata->coord_proj_radius, coord_proj_radius); error++;
      }
    coord_proj_radius++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "coord_proj_radius", &coord_proj_radius) &&
        coord_proj_radius == geodata->coord_proj_radius)
      pass ("GEODATA.coord_proj_radius [BD] set+1 %g", coord_proj_radius);
    else
      {
        fail ("GEODATA.coord_proj_radius [BD] set+1 %g != %g", geodata->coord_proj_radius, coord_proj_radius); error++;
      }
    geodata->coord_proj_radius--;

  }
  {
    BITCODE_T coord_system_datum;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_system_datum", &coord_system_datum, NULL)
        && !memcmp(&coord_system_datum, &geodata->coord_system_datum, sizeof(geodata->coord_system_datum)))
      pass ("GEODATA.coord_system_datum [T]");
    else
      {
        fail ("GEODATA.coord_system_datum [T]"); error++;
      }
  }
  {
    BITCODE_T coord_system_def;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_system_def", &coord_system_def, NULL)
        && !memcmp(&coord_system_def, &geodata->coord_system_def, sizeof(geodata->coord_system_def)))
      pass ("GEODATA.coord_system_def [T]");
    else
      {
        fail ("GEODATA.coord_system_def [T]"); error++;
      }
  }
  {
    BITCODE_T coord_system_wkt;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_system_wkt", &coord_system_wkt, NULL)
        && !memcmp(&coord_system_wkt, &geodata->coord_system_wkt, sizeof(geodata->coord_system_wkt)))
      pass ("GEODATA.coord_system_wkt [T]");
    else
      {
        fail ("GEODATA.coord_system_wkt [T]"); error++;
      }
  }
  {
    BITCODE_BS coord_type;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_type", &coord_type, NULL) &&
        coord_type == geodata->coord_type)
      pass ("GEODATA.coord_type [BS] %hu", coord_type);
    else
      {
        fail ("GEODATA.coord_type [BS] %hu != %hu", geodata->coord_type, coord_type); error++;
      }
    coord_type++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "coord_type", &coord_type) &&
        coord_type == geodata->coord_type)
      pass ("GEODATA.coord_type [BS] set+1 %hu", coord_type);
    else
      {
        fail ("GEODATA.coord_type [BS] set+1 %hu != %hu", geodata->coord_type, coord_type); error++;
      }
    geodata->coord_type--;

  }
  {
    BITCODE_3BD design_pt;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "design_pt", &design_pt, NULL)
        && !memcmp(&design_pt, &geodata->design_pt, sizeof(geodata->design_pt)))
      pass ("GEODATA.design_pt [3BD]");
    else
      {
        fail ("GEODATA.design_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_T geo_rss_tag;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "geo_rss_tag", &geo_rss_tag, NULL)
        && !memcmp(&geo_rss_tag, &geodata->geo_rss_tag, sizeof(geodata->geo_rss_tag)))
      pass ("GEODATA.geo_rss_tag [T]");
    else
      {
        fail ("GEODATA.geo_rss_tag [T]"); error++;
      }
  }
  {
    Dwg_GEODATA_meshface* geomesh_faces;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "geomesh_faces", &geomesh_faces, NULL)
        && !memcmp(&geomesh_faces, &geodata->geomesh_faces, sizeof(geodata->geomesh_faces)))
      pass ("GEODATA.geomesh_faces [Dwg_GEODATA_meshface*]");
    else
      {
        fail ("GEODATA.geomesh_faces [Dwg_GEODATA_meshface*]"); error++;
      }
  }
  {
    Dwg_GEODATA_meshpt* geomesh_pts;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "geomesh_pts", &geomesh_pts, NULL)
        && !memcmp(&geomesh_pts, &geodata->geomesh_pts, sizeof(geodata->geomesh_pts)))
      pass ("GEODATA.geomesh_pts [Dwg_GEODATA_meshpt*]");
    else
      {
        fail ("GEODATA.geomesh_pts [Dwg_GEODATA_meshpt*]"); error++;
      }
  }
  {
    BITCODE_B has_civil_data;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "has_civil_data", &has_civil_data, NULL) &&
        has_civil_data == geodata->has_civil_data)
      pass ("GEODATA.has_civil_data [B] " FORMAT_B "", has_civil_data);
    else
      {
        fail ("GEODATA.has_civil_data [B] " FORMAT_B " != " FORMAT_B "", geodata->has_civil_data, has_civil_data); error++;
      }
    has_civil_data++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "has_civil_data", &has_civil_data) &&
        has_civil_data == geodata->has_civil_data)
      pass ("GEODATA.has_civil_data [B] set+1 " FORMAT_B "", has_civil_data);
    else
      {
        fail ("GEODATA.has_civil_data [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->has_civil_data, has_civil_data); error++;
      }
    geodata->has_civil_data--;

  }
  {
    BITCODE_H host_block;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "host_block", &host_block, NULL)
        && !memcmp(&host_block, &geodata->host_block, sizeof(geodata->host_block)))
      pass ("GEODATA.host_block [H]");
    else
      {
        fail ("GEODATA.host_block [H]"); error++;
      }
  }
  {
    BITCODE_3BD north_dir;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "north_dir", &north_dir, NULL)
        && !memcmp(&north_dir, &geodata->north_dir, sizeof(geodata->north_dir)))
      pass ("GEODATA.north_dir [3BD]");
    else
      {
        fail ("GEODATA.north_dir [3BD]"); error++;
      }
  }
  {
    BITCODE_BD north_dir_angle_deg;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "north_dir_angle_deg", &north_dir_angle_deg, NULL) &&
        north_dir_angle_deg == geodata->north_dir_angle_deg)
      pass ("GEODATA.north_dir_angle_deg [BD] %g", north_dir_angle_deg);
    else
      {
        fail ("GEODATA.north_dir_angle_deg [BD] %g != %g", geodata->north_dir_angle_deg, north_dir_angle_deg); error++;
      }
    north_dir_angle_deg++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "north_dir_angle_deg", &north_dir_angle_deg) &&
        north_dir_angle_deg == geodata->north_dir_angle_deg)
      pass ("GEODATA.north_dir_angle_deg [BD] set+1 %g", north_dir_angle_deg);
    else
      {
        fail ("GEODATA.north_dir_angle_deg [BD] set+1 %g != %g", geodata->north_dir_angle_deg, north_dir_angle_deg); error++;
      }
    geodata->north_dir_angle_deg--;

  }
  {
    BITCODE_BD north_dir_angle_rad;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "north_dir_angle_rad", &north_dir_angle_rad, NULL) &&
        north_dir_angle_rad == geodata->north_dir_angle_rad)
      pass ("GEODATA.north_dir_angle_rad [BD] %g", north_dir_angle_rad);
    else
      {
        fail ("GEODATA.north_dir_angle_rad [BD] %g != %g", geodata->north_dir_angle_rad, north_dir_angle_rad); error++;
      }
    north_dir_angle_rad++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "north_dir_angle_rad", &north_dir_angle_rad) &&
        north_dir_angle_rad == geodata->north_dir_angle_rad)
      pass ("GEODATA.north_dir_angle_rad [BD] set+1 %g", north_dir_angle_rad);
    else
      {
        fail ("GEODATA.north_dir_angle_rad [BD] set+1 %g != %g", geodata->north_dir_angle_rad, north_dir_angle_rad); error++;
      }
    geodata->north_dir_angle_rad--;

  }
  {
    BITCODE_BL num_geomesh_faces;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "num_geomesh_faces", &num_geomesh_faces, NULL) &&
        num_geomesh_faces == geodata->num_geomesh_faces)
      pass ("GEODATA.num_geomesh_faces [BL] %u", num_geomesh_faces);
    else
      {
        fail ("GEODATA.num_geomesh_faces [BL] %u != %u", geodata->num_geomesh_faces, num_geomesh_faces); error++;
      }
    num_geomesh_faces++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "num_geomesh_faces", &num_geomesh_faces) &&
        num_geomesh_faces == geodata->num_geomesh_faces)
      pass ("GEODATA.num_geomesh_faces [BL] set+1 %u", num_geomesh_faces);
    else
      {
        fail ("GEODATA.num_geomesh_faces [BL] set+1 %u != %u", geodata->num_geomesh_faces, num_geomesh_faces); error++;
      }
    geodata->num_geomesh_faces--;

  }
  {
    BITCODE_BL num_geomesh_pts;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "num_geomesh_pts", &num_geomesh_pts, NULL) &&
        num_geomesh_pts == geodata->num_geomesh_pts)
      pass ("GEODATA.num_geomesh_pts [BL] %u", num_geomesh_pts);
    else
      {
        fail ("GEODATA.num_geomesh_pts [BL] %u != %u", geodata->num_geomesh_pts, num_geomesh_pts); error++;
      }
    num_geomesh_pts++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "num_geomesh_pts", &num_geomesh_pts) &&
        num_geomesh_pts == geodata->num_geomesh_pts)
      pass ("GEODATA.num_geomesh_pts [BL] set+1 %u", num_geomesh_pts);
    else
      {
        fail ("GEODATA.num_geomesh_pts [BL] set+1 %u != %u", geodata->num_geomesh_pts, num_geomesh_pts); error++;
      }
    geodata->num_geomesh_pts--;

  }
  {
    BITCODE_3BD obs_pt;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "obs_pt", &obs_pt, NULL)
        && !memcmp(&obs_pt, &geodata->obs_pt, sizeof(geodata->obs_pt)))
      pass ("GEODATA.obs_pt [3BD]");
    else
      {
        fail ("GEODATA.obs_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_T observation_coverage_tag;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "observation_coverage_tag", &observation_coverage_tag, NULL)
        && !memcmp(&observation_coverage_tag, &geodata->observation_coverage_tag, sizeof(geodata->observation_coverage_tag)))
      pass ("GEODATA.observation_coverage_tag [T]");
    else
      {
        fail ("GEODATA.observation_coverage_tag [T]"); error++;
      }
  }
  {
    BITCODE_T observation_from_tag;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "observation_from_tag", &observation_from_tag, NULL)
        && !memcmp(&observation_from_tag, &geodata->observation_from_tag, sizeof(geodata->observation_from_tag)))
      pass ("GEODATA.observation_from_tag [T]");
    else
      {
        fail ("GEODATA.observation_from_tag [T]"); error++;
      }
  }
  {
    BITCODE_T observation_to_tag;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "observation_to_tag", &observation_to_tag, NULL)
        && !memcmp(&observation_to_tag, &geodata->observation_to_tag, sizeof(geodata->observation_to_tag)))
      pass ("GEODATA.observation_to_tag [T]");
    else
      {
        fail ("GEODATA.observation_to_tag [T]"); error++;
      }
  }
  {
    BITCODE_B obsolete_false;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "obsolete_false", &obsolete_false, NULL) &&
        obsolete_false == geodata->obsolete_false)
      pass ("GEODATA.obsolete_false [B] " FORMAT_B "", obsolete_false);
    else
      {
        fail ("GEODATA.obsolete_false [B] " FORMAT_B " != " FORMAT_B "", geodata->obsolete_false, obsolete_false); error++;
      }
    obsolete_false++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "obsolete_false", &obsolete_false) &&
        obsolete_false == geodata->obsolete_false)
      pass ("GEODATA.obsolete_false [B] set+1 " FORMAT_B "", obsolete_false);
    else
      {
        fail ("GEODATA.obsolete_false [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->obsolete_false, obsolete_false); error++;
      }
    geodata->obsolete_false--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "parent", &parent, NULL)
        && !memcmp(&parent, &geodata->parent, sizeof(geodata->parent)))
      pass ("GEODATA.parent [struct _dwg_object_object*]");
    else
      {
        fail ("GEODATA.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_3BD ref_pt;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "ref_pt", &ref_pt, NULL)
        && !memcmp(&ref_pt, &geodata->ref_pt, sizeof(geodata->ref_pt)))
      pass ("GEODATA.ref_pt [3BD]");
    else
      {
        fail ("GEODATA.ref_pt [3BD]"); error++;
      }
  }
  {
    BITCODE_BL scale_est;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "scale_est", &scale_est, NULL) &&
        scale_est == geodata->scale_est)
      pass ("GEODATA.scale_est [BL] %u", scale_est);
    else
      {
        fail ("GEODATA.scale_est [BL] %u != %u", geodata->scale_est, scale_est); error++;
      }
    scale_est++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "scale_est", &scale_est) &&
        scale_est == geodata->scale_est)
      pass ("GEODATA.scale_est [BL] set+1 %u", scale_est);
    else
      {
        fail ("GEODATA.scale_est [BL] set+1 %u != %u", geodata->scale_est, scale_est); error++;
      }
    geodata->scale_est--;

  }
  {
    BITCODE_B sea_level_corr;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "sea_level_corr", &sea_level_corr, NULL) &&
        sea_level_corr == geodata->sea_level_corr)
      pass ("GEODATA.sea_level_corr [B] " FORMAT_B "", sea_level_corr);
    else
      {
        fail ("GEODATA.sea_level_corr [B] " FORMAT_B " != " FORMAT_B "", geodata->sea_level_corr, sea_level_corr); error++;
      }
    sea_level_corr++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "sea_level_corr", &sea_level_corr) &&
        sea_level_corr == geodata->sea_level_corr)
      pass ("GEODATA.sea_level_corr [B] set+1 " FORMAT_B "", sea_level_corr);
    else
      {
        fail ("GEODATA.sea_level_corr [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->sea_level_corr, sea_level_corr); error++;
      }
    geodata->sea_level_corr--;

  }
  {
    BITCODE_BD sea_level_elev;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "sea_level_elev", &sea_level_elev, NULL) &&
        sea_level_elev == geodata->sea_level_elev)
      pass ("GEODATA.sea_level_elev [BD] %g", sea_level_elev);
    else
      {
        fail ("GEODATA.sea_level_elev [BD] %g != %g", geodata->sea_level_elev, sea_level_elev); error++;
      }
    sea_level_elev++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "sea_level_elev", &sea_level_elev) &&
        sea_level_elev == geodata->sea_level_elev)
      pass ("GEODATA.sea_level_elev [BD] set+1 %g", sea_level_elev);
    else
      {
        fail ("GEODATA.sea_level_elev [BD] set+1 %g != %g", geodata->sea_level_elev, sea_level_elev); error++;
      }
    geodata->sea_level_elev--;

  }
  {
    BITCODE_BD unit_scale_horiz;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "unit_scale_horiz", &unit_scale_horiz, NULL) &&
        unit_scale_horiz == geodata->unit_scale_horiz)
      pass ("GEODATA.unit_scale_horiz [BD] %g", unit_scale_horiz);
    else
      {
        fail ("GEODATA.unit_scale_horiz [BD] %g != %g", geodata->unit_scale_horiz, unit_scale_horiz); error++;
      }
    unit_scale_horiz++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "unit_scale_horiz", &unit_scale_horiz) &&
        unit_scale_horiz == geodata->unit_scale_horiz)
      pass ("GEODATA.unit_scale_horiz [BD] set+1 %g", unit_scale_horiz);
    else
      {
        fail ("GEODATA.unit_scale_horiz [BD] set+1 %g != %g", geodata->unit_scale_horiz, unit_scale_horiz); error++;
      }
    geodata->unit_scale_horiz--;

  }
  {
    BITCODE_BD unit_scale_vert;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "unit_scale_vert", &unit_scale_vert, NULL) &&
        unit_scale_vert == geodata->unit_scale_vert)
      pass ("GEODATA.unit_scale_vert [BD] %g", unit_scale_vert);
    else
      {
        fail ("GEODATA.unit_scale_vert [BD] %g != %g", geodata->unit_scale_vert, unit_scale_vert); error++;
      }
    unit_scale_vert++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "unit_scale_vert", &unit_scale_vert) &&
        unit_scale_vert == geodata->unit_scale_vert)
      pass ("GEODATA.unit_scale_vert [BD] set+1 %g", unit_scale_vert);
    else
      {
        fail ("GEODATA.unit_scale_vert [BD] set+1 %g != %g", geodata->unit_scale_vert, unit_scale_vert); error++;
      }
    geodata->unit_scale_vert--;

  }
  {
    BITCODE_BL units_value_horiz;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "units_value_horiz", &units_value_horiz, NULL) &&
        units_value_horiz == geodata->units_value_horiz)
      pass ("GEODATA.units_value_horiz [BL] %u", units_value_horiz);
    else
      {
        fail ("GEODATA.units_value_horiz [BL] %u != %u", geodata->units_value_horiz, units_value_horiz); error++;
      }
    units_value_horiz++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "units_value_horiz", &units_value_horiz) &&
        units_value_horiz == geodata->units_value_horiz)
      pass ("GEODATA.units_value_horiz [BL] set+1 %u", units_value_horiz);
    else
      {
        fail ("GEODATA.units_value_horiz [BL] set+1 %u != %u", geodata->units_value_horiz, units_value_horiz); error++;
      }
    geodata->units_value_horiz--;

  }
  {
    BITCODE_BL units_value_vert;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "units_value_vert", &units_value_vert, NULL) &&
        units_value_vert == geodata->units_value_vert)
      pass ("GEODATA.units_value_vert [BL] %u", units_value_vert);
    else
      {
        fail ("GEODATA.units_value_vert [BL] %u != %u", geodata->units_value_vert, units_value_vert); error++;
      }
    units_value_vert++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "units_value_vert", &units_value_vert) &&
        units_value_vert == geodata->units_value_vert)
      pass ("GEODATA.units_value_vert [BL] set+1 %u", units_value_vert);
    else
      {
        fail ("GEODATA.units_value_vert [BL] set+1 %u != %u", geodata->units_value_vert, units_value_vert); error++;
      }
    geodata->units_value_vert--;

  }
  {
    BITCODE_3BD up_dir;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "up_dir", &up_dir, NULL)
        && !memcmp(&up_dir, &geodata->up_dir, sizeof(geodata->up_dir)))
      pass ("GEODATA.up_dir [3BD]");
    else
      {
        fail ("GEODATA.up_dir [3BD]"); error++;
      }
  }
  {
    BITCODE_BD user_scale_factor;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "user_scale_factor", &user_scale_factor, NULL) &&
        user_scale_factor == geodata->user_scale_factor)
      pass ("GEODATA.user_scale_factor [BD] %g", user_scale_factor);
    else
      {
        fail ("GEODATA.user_scale_factor [BD] %g != %g", geodata->user_scale_factor, user_scale_factor); error++;
      }
    user_scale_factor++;
    if (dwg_dynapi_entity_set_value(geodata, "GEODATA", "user_scale_factor", &user_scale_factor) &&
        user_scale_factor == geodata->user_scale_factor)
      pass ("GEODATA.user_scale_factor [BD] set+1 %g", user_scale_factor);
    else
      {
        fail ("GEODATA.user_scale_factor [BD] set+1 %g != %g", geodata->user_scale_factor, user_scale_factor); error++;
      }
    geodata->user_scale_factor--;

  }
  return error;
}
static int test_GROUP (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_GROUP *group = obj->tio.object->tio.GROUP;
  {
    BITCODE_H* group_entries;
    if (dwg_dynapi_entity_value(group, "GROUP", "group_entries", &group_entries, NULL)
        && !memcmp(&group_entries, &group->group_entries, sizeof(group->group_entries)))
      pass ("GROUP.group_entries [H*]");
    else
      {
        fail ("GROUP.group_entries [H*]"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(group, "GROUP", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&group->name))
      pass ("GROUP.name [TV]");
    else
      {
        fail ("GROUP.name [TV]"); error++;
      }
  }
  {
    BITCODE_BL num_handles;
    if (dwg_dynapi_entity_value(group, "GROUP", "num_handles", &num_handles, NULL) &&
        num_handles == group->num_handles)
      pass ("GROUP.num_handles [BL] %u", num_handles);
    else
      {
        fail ("GROUP.num_handles [BL] %u != %u", group->num_handles, num_handles); error++;
      }
    num_handles++;
    if (dwg_dynapi_entity_set_value(group, "GROUP", "num_handles", &num_handles) &&
        num_handles == group->num_handles)
      pass ("GROUP.num_handles [BL] set+1 %u", num_handles);
    else
      {
        fail ("GROUP.num_handles [BL] set+1 %u != %u", group->num_handles, num_handles); error++;
      }
    group->num_handles--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(group, "GROUP", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &group->ownerhandle, sizeof(group->ownerhandle)))
      pass ("GROUP.ownerhandle [H]");
    else
      {
        fail ("GROUP.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(group, "GROUP", "parent", &parent, NULL)
        && !memcmp(&parent, &group->parent, sizeof(group->parent)))
      pass ("GROUP.parent [struct _dwg_object_object*]");
    else
      {
        fail ("GROUP.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BS selectable;
    if (dwg_dynapi_entity_value(group, "GROUP", "selectable", &selectable, NULL) &&
        selectable == group->selectable)
      pass ("GROUP.selectable [BS] %hu", selectable);
    else
      {
        fail ("GROUP.selectable [BS] %hu != %hu", group->selectable, selectable); error++;
      }
    selectable++;
    if (dwg_dynapi_entity_set_value(group, "GROUP", "selectable", &selectable) &&
        selectable == group->selectable)
      pass ("GROUP.selectable [BS] set+1 %hu", selectable);
    else
      {
        fail ("GROUP.selectable [BS] set+1 %hu != %hu", group->selectable, selectable); error++;
      }
    group->selectable--;

  }
  {
    BITCODE_BS unnamed;
    if (dwg_dynapi_entity_value(group, "GROUP", "unnamed", &unnamed, NULL) &&
        unnamed == group->unnamed)
      pass ("GROUP.unnamed [BS] %hu", unnamed);
    else
      {
        fail ("GROUP.unnamed [BS] %hu != %hu", group->unnamed, unnamed); error++;
      }
    unnamed++;
    if (dwg_dynapi_entity_set_value(group, "GROUP", "unnamed", &unnamed) &&
        unnamed == group->unnamed)
      pass ("GROUP.unnamed [BS] set+1 %hu", unnamed);
    else
      {
        fail ("GROUP.unnamed [BS] set+1 %hu != %hu", group->unnamed, unnamed); error++;
      }
    group->unnamed--;

  }
  return error;
}
static int test_IDBUFFER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_IDBUFFER *idbuffer = obj->tio.object->tio.IDBUFFER;
  {
    BITCODE_BL num_obj_ids;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "num_obj_ids", &num_obj_ids, NULL) &&
        num_obj_ids == idbuffer->num_obj_ids)
      pass ("IDBUFFER.num_obj_ids [BL] %u", num_obj_ids);
    else
      {
        fail ("IDBUFFER.num_obj_ids [BL] %u != %u", idbuffer->num_obj_ids, num_obj_ids); error++;
      }
    num_obj_ids++;
    if (dwg_dynapi_entity_set_value(idbuffer, "IDBUFFER", "num_obj_ids", &num_obj_ids) &&
        num_obj_ids == idbuffer->num_obj_ids)
      pass ("IDBUFFER.num_obj_ids [BL] set+1 %u", num_obj_ids);
    else
      {
        fail ("IDBUFFER.num_obj_ids [BL] set+1 %u != %u", idbuffer->num_obj_ids, num_obj_ids); error++;
      }
    idbuffer->num_obj_ids--;

  }
  {
    BITCODE_H* obj_ids;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "obj_ids", &obj_ids, NULL)
        && !memcmp(&obj_ids, &idbuffer->obj_ids, sizeof(idbuffer->obj_ids)))
      pass ("IDBUFFER.obj_ids [H*]");
    else
      {
        fail ("IDBUFFER.obj_ids [H*]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &idbuffer->ownerhandle, sizeof(idbuffer->ownerhandle)))
      pass ("IDBUFFER.ownerhandle [H]");
    else
      {
        fail ("IDBUFFER.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "parent", &parent, NULL)
        && !memcmp(&parent, &idbuffer->parent, sizeof(idbuffer->parent)))
      pass ("IDBUFFER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("IDBUFFER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "unknown", &unknown, NULL) &&
        unknown == idbuffer->unknown)
      pass ("IDBUFFER.unknown [RC] %u", unknown);
    else
      {
        fail ("IDBUFFER.unknown [RC] %u != %u", idbuffer->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(idbuffer, "IDBUFFER", "unknown", &unknown) &&
        unknown == idbuffer->unknown)
      pass ("IDBUFFER.unknown [RC] set+1 %u", unknown);
    else
      {
        fail ("IDBUFFER.unknown [RC] set+1 %u != %u", idbuffer->unknown, unknown); error++;
      }
    idbuffer->unknown--;

  }
  return error;
}
static int test_IMAGEDEF (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_IMAGEDEF *imagedef = obj->tio.object->tio.IMAGEDEF;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "class_version", &class_version, NULL) &&
        class_version == imagedef->class_version)
      pass ("IMAGEDEF.class_version [BL] %u", class_version);
    else
      {
        fail ("IMAGEDEF.class_version [BL] %u != %u", imagedef->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(imagedef, "IMAGEDEF", "class_version", &class_version) &&
        class_version == imagedef->class_version)
      pass ("IMAGEDEF.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("IMAGEDEF.class_version [BL] set+1 %u != %u", imagedef->class_version, class_version); error++;
      }
    imagedef->class_version--;

  }
  {
    BITCODE_TV file_path;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "file_path", &file_path, NULL)
        && !strcmp((char*)&file_path, (char*)&imagedef->file_path))
      pass ("IMAGEDEF.file_path [TV]");
    else
      {
        fail ("IMAGEDEF.file_path [TV]"); error++;
      }
  }
  {
    BITCODE_2RD image_size;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "image_size", &image_size, NULL)
        && !memcmp(&image_size, &imagedef->image_size, sizeof(imagedef->image_size)))
      pass ("IMAGEDEF.image_size [2RD]");
    else
      {
        fail ("IMAGEDEF.image_size [2RD]"); error++;
      }
  }
  {
    BITCODE_B is_loaded;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "is_loaded", &is_loaded, NULL) &&
        is_loaded == imagedef->is_loaded)
      pass ("IMAGEDEF.is_loaded [B] " FORMAT_B "", is_loaded);
    else
      {
        fail ("IMAGEDEF.is_loaded [B] " FORMAT_B " != " FORMAT_B "", imagedef->is_loaded, is_loaded); error++;
      }
    is_loaded++;
    if (dwg_dynapi_entity_set_value(imagedef, "IMAGEDEF", "is_loaded", &is_loaded) &&
        is_loaded == imagedef->is_loaded)
      pass ("IMAGEDEF.is_loaded [B] set+1 " FORMAT_B "", is_loaded);
    else
      {
        fail ("IMAGEDEF.is_loaded [B] set+1 " FORMAT_B " != " FORMAT_B "", imagedef->is_loaded, is_loaded); error++;
      }
    imagedef->is_loaded--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &imagedef->ownerhandle, sizeof(imagedef->ownerhandle)))
      pass ("IMAGEDEF.ownerhandle [H]");
    else
      {
        fail ("IMAGEDEF.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "parent", &parent, NULL)
        && !memcmp(&parent, &imagedef->parent, sizeof(imagedef->parent)))
      pass ("IMAGEDEF.parent [struct _dwg_object_object*]");
    else
      {
        fail ("IMAGEDEF.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_2RD pixel_size;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "pixel_size", &pixel_size, NULL)
        && !memcmp(&pixel_size, &imagedef->pixel_size, sizeof(imagedef->pixel_size)))
      pass ("IMAGEDEF.pixel_size [2RD]");
    else
      {
        fail ("IMAGEDEF.pixel_size [2RD]"); error++;
      }
  }
  {
    BITCODE_RC resunits;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "resunits", &resunits, NULL) &&
        resunits == imagedef->resunits)
      pass ("IMAGEDEF.resunits [RC] %u", resunits);
    else
      {
        fail ("IMAGEDEF.resunits [RC] %u != %u", imagedef->resunits, resunits); error++;
      }
    resunits++;
    if (dwg_dynapi_entity_set_value(imagedef, "IMAGEDEF", "resunits", &resunits) &&
        resunits == imagedef->resunits)
      pass ("IMAGEDEF.resunits [RC] set+1 %u", resunits);
    else
      {
        fail ("IMAGEDEF.resunits [RC] set+1 %u != %u", imagedef->resunits, resunits); error++;
      }
    imagedef->resunits--;

  }
  return error;
}
static int test_IMAGEDEF_REACTOR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_IMAGEDEF_REACTOR *imagedef_reactor = obj->tio.object->tio.IMAGEDEF_REACTOR;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(imagedef_reactor, "IMAGEDEF_REACTOR", "class_version", &class_version, NULL) &&
        class_version == imagedef_reactor->class_version)
      pass ("IMAGEDEF_REACTOR.class_version [BL] %u", class_version);
    else
      {
        fail ("IMAGEDEF_REACTOR.class_version [BL] %u != %u", imagedef_reactor->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(imagedef_reactor, "IMAGEDEF_REACTOR", "class_version", &class_version) &&
        class_version == imagedef_reactor->class_version)
      pass ("IMAGEDEF_REACTOR.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("IMAGEDEF_REACTOR.class_version [BL] set+1 %u != %u", imagedef_reactor->class_version, class_version); error++;
      }
    imagedef_reactor->class_version--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(imagedef_reactor, "IMAGEDEF_REACTOR", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &imagedef_reactor->ownerhandle, sizeof(imagedef_reactor->ownerhandle)))
      pass ("IMAGEDEF_REACTOR.ownerhandle [H]");
    else
      {
        fail ("IMAGEDEF_REACTOR.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(imagedef_reactor, "IMAGEDEF_REACTOR", "parent", &parent, NULL)
        && !memcmp(&parent, &imagedef_reactor->parent, sizeof(imagedef_reactor->parent)))
      pass ("IMAGEDEF_REACTOR.parent [struct _dwg_object_object*]");
    else
      {
        fail ("IMAGEDEF_REACTOR.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_LAYER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LAYER *layer = obj->tio.object->tio.LAYER;
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(layer, "LAYER", "color", &color, NULL)
        && !memcmp(&color, &layer->color, sizeof(layer->color)))
      pass ("LAYER.color [CMC]");
    else
      {
        fail ("LAYER.color [CMC]"); error++;
      }
  }
  {
    short color_rs;
    if (dwg_dynapi_entity_value(layer, "LAYER", "color_rs", &color_rs, NULL) &&
        color_rs == layer->color_rs)
      pass ("LAYER.color_rs [short] %hd", color_rs);
    else
      {
        fail ("LAYER.color_rs [short] %hd != %hd", layer->color_rs, color_rs); error++;
      }
    color_rs++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "color_rs", &color_rs) &&
        color_rs == layer->color_rs)
      pass ("LAYER.color_rs [short] set+1 %hd", color_rs);
    else
      {
        fail ("LAYER.color_rs [short] set+1 %hd != %hd", layer->color_rs, color_rs); error++;
      }
    layer->color_rs--;

  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(layer, "LAYER", "flag", &flag, NULL) &&
        flag == layer->flag)
      pass ("LAYER.flag [BS] %hu", flag);
    else
      {
        fail ("LAYER.flag [BS] %hu != %hu", layer->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "flag", &flag) &&
        flag == layer->flag)
      pass ("LAYER.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("LAYER.flag [BS] set+1 %hu != %hu", layer->flag, flag); error++;
      }
    layer->flag--;

  }
  {
    BITCODE_B frozen;
    if (dwg_dynapi_entity_value(layer, "LAYER", "frozen", &frozen, NULL) &&
        frozen == layer->frozen)
      pass ("LAYER.frozen [B] " FORMAT_B "", frozen);
    else
      {
        fail ("LAYER.frozen [B] " FORMAT_B " != " FORMAT_B "", layer->frozen, frozen); error++;
      }
    frozen++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "frozen", &frozen) &&
        frozen == layer->frozen)
      pass ("LAYER.frozen [B] set+1 " FORMAT_B "", frozen);
    else
      {
        fail ("LAYER.frozen [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->frozen, frozen); error++;
      }
    layer->frozen--;

  }
  {
    BITCODE_B frozen_in_new;
    if (dwg_dynapi_entity_value(layer, "LAYER", "frozen_in_new", &frozen_in_new, NULL) &&
        frozen_in_new == layer->frozen_in_new)
      pass ("LAYER.frozen_in_new [B] " FORMAT_B "", frozen_in_new);
    else
      {
        fail ("LAYER.frozen_in_new [B] " FORMAT_B " != " FORMAT_B "", layer->frozen_in_new, frozen_in_new); error++;
      }
    frozen_in_new++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "frozen_in_new", &frozen_in_new) &&
        frozen_in_new == layer->frozen_in_new)
      pass ("LAYER.frozen_in_new [B] set+1 " FORMAT_B "", frozen_in_new);
    else
      {
        fail ("LAYER.frozen_in_new [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->frozen_in_new, frozen_in_new); error++;
      }
    layer->frozen_in_new--;

  }
  {
    BITCODE_H layer_control;
    if (dwg_dynapi_entity_value(layer, "LAYER", "layer_control", &layer_control, NULL)
        && !memcmp(&layer_control, &layer->layer_control, sizeof(layer->layer_control)))
      pass ("LAYER.layer_control [H]");
    else
      {
        fail ("LAYER.layer_control [H]"); error++;
      }
  }
  {
    BITCODE_H linetype;
    if (dwg_dynapi_entity_value(layer, "LAYER", "linetype", &linetype, NULL)
        && !memcmp(&linetype, &layer->linetype, sizeof(layer->linetype)))
      pass ("LAYER.linetype [H]");
    else
      {
        fail ("LAYER.linetype [H]"); error++;
      }
  }
  {
    BITCODE_RS linetype_rs;
    if (dwg_dynapi_entity_value(layer, "LAYER", "linetype_rs", &linetype_rs, NULL) &&
        linetype_rs == layer->linetype_rs)
      pass ("LAYER.linetype_rs [RS] %hu", linetype_rs);
    else
      {
        fail ("LAYER.linetype_rs [RS] %hu != %hu", layer->linetype_rs, linetype_rs); error++;
      }
    linetype_rs++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "linetype_rs", &linetype_rs) &&
        linetype_rs == layer->linetype_rs)
      pass ("LAYER.linetype_rs [RS] set+1 %hu", linetype_rs);
    else
      {
        fail ("LAYER.linetype_rs [RS] set+1 %hu != %hu", layer->linetype_rs, linetype_rs); error++;
      }
    layer->linetype_rs--;

  }
  {
    BITCODE_RC linewt;
    if (dwg_dynapi_entity_value(layer, "LAYER", "linewt", &linewt, NULL) &&
        linewt == layer->linewt)
      pass ("LAYER.linewt [RC] %u", linewt);
    else
      {
        fail ("LAYER.linewt [RC] %u != %u", layer->linewt, linewt); error++;
      }
    linewt++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "linewt", &linewt) &&
        linewt == layer->linewt)
      pass ("LAYER.linewt [RC] set+1 %u", linewt);
    else
      {
        fail ("LAYER.linewt [RC] set+1 %u != %u", layer->linewt, linewt); error++;
      }
    layer->linewt--;

  }
  {
    BITCODE_B locked;
    if (dwg_dynapi_entity_value(layer, "LAYER", "locked", &locked, NULL) &&
        locked == layer->locked)
      pass ("LAYER.locked [B] " FORMAT_B "", locked);
    else
      {
        fail ("LAYER.locked [B] " FORMAT_B " != " FORMAT_B "", layer->locked, locked); error++;
      }
    locked++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "locked", &locked) &&
        locked == layer->locked)
      pass ("LAYER.locked [B] set+1 " FORMAT_B "", locked);
    else
      {
        fail ("LAYER.locked [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->locked, locked); error++;
      }
    layer->locked--;

  }
  {
    BITCODE_H material;
    if (dwg_dynapi_entity_value(layer, "LAYER", "material", &material, NULL)
        && !memcmp(&material, &layer->material, sizeof(layer->material)))
      pass ("LAYER.material [H]");
    else
      {
        fail ("LAYER.material [H]"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(layer, "LAYER", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&layer->name))
      pass ("LAYER.name [TV]");
    else
      {
        fail ("LAYER.name [TV]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(layer, "LAYER", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &layer->null_handle, sizeof(layer->null_handle)))
      pass ("LAYER.null_handle [H]");
    else
      {
        fail ("LAYER.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_B on;
    if (dwg_dynapi_entity_value(layer, "LAYER", "on", &on, NULL) &&
        on == layer->on)
      pass ("LAYER.on [B] " FORMAT_B "", on);
    else
      {
        fail ("LAYER.on [B] " FORMAT_B " != " FORMAT_B "", layer->on, on); error++;
      }
    on++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "on", &on) &&
        on == layer->on)
      pass ("LAYER.on [B] set+1 " FORMAT_B "", on);
    else
      {
        fail ("LAYER.on [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->on, on); error++;
      }
    layer->on--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(layer, "LAYER", "parent", &parent, NULL)
        && !memcmp(&parent, &layer->parent, sizeof(layer->parent)))
      pass ("LAYER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("LAYER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_B plotflag;
    if (dwg_dynapi_entity_value(layer, "LAYER", "plotflag", &plotflag, NULL) &&
        plotflag == layer->plotflag)
      pass ("LAYER.plotflag [B] " FORMAT_B "", plotflag);
    else
      {
        fail ("LAYER.plotflag [B] " FORMAT_B " != " FORMAT_B "", layer->plotflag, plotflag); error++;
      }
    plotflag++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "plotflag", &plotflag) &&
        plotflag == layer->plotflag)
      pass ("LAYER.plotflag [B] set+1 " FORMAT_B "", plotflag);
    else
      {
        fail ("LAYER.plotflag [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->plotflag, plotflag); error++;
      }
    layer->plotflag--;

  }
  {
    BITCODE_H plotstyle;
    if (dwg_dynapi_entity_value(layer, "LAYER", "plotstyle", &plotstyle, NULL)
        && !memcmp(&plotstyle, &layer->plotstyle, sizeof(layer->plotstyle)))
      pass ("LAYER.plotstyle [H]");
    else
      {
        fail ("LAYER.plotstyle [H]"); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(layer, "LAYER", "used", &used, NULL) &&
        used == layer->used)
      pass ("LAYER.used [RS] %hu", used);
    else
      {
        fail ("LAYER.used [RS] %hu != %hu", layer->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "used", &used) &&
        used == layer->used)
      pass ("LAYER.used [RS] set+1 %hu", used);
    else
      {
        fail ("LAYER.used [RS] set+1 %hu != %hu", layer->used, used); error++;
      }
    layer->used--;

  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value(layer, "LAYER", "xref", &xref, NULL)
        && !memcmp(&xref, &layer->xref, sizeof(layer->xref)))
      pass ("LAYER.xref [H]");
    else
      {
        fail ("LAYER.xref [H]"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(layer, "LAYER", "xrefdep", &xrefdep, NULL) &&
        xrefdep == layer->xrefdep)
      pass ("LAYER.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("LAYER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", layer->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "xrefdep", &xrefdep) &&
        xrefdep == layer->xrefdep)
      pass ("LAYER.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("LAYER.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->xrefdep, xrefdep); error++;
      }
    layer->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(layer, "LAYER", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == layer->xrefindex_plus1)
      pass ("LAYER.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("LAYER.xrefindex_plus1 [BS] %hu != %hu", layer->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == layer->xrefindex_plus1)
      pass ("LAYER.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("LAYER.xrefindex_plus1 [BS] set+1 %hu != %hu", layer->xrefindex_plus1, xrefindex_plus1); error++;
      }
    layer->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(layer, "LAYER", "xrefref", &xrefref, NULL) &&
        xrefref == layer->xrefref)
      pass ("LAYER.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("LAYER.xrefref [B] " FORMAT_B " != " FORMAT_B "", layer->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(layer, "LAYER", "xrefref", &xrefref) &&
        xrefref == layer->xrefref)
      pass ("LAYER.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("LAYER.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->xrefref, xrefref); error++;
      }
    layer->xrefref--;

  }
  return error;
}
static int test_LAYER_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LAYER_CONTROL *layer_control = obj->tio.object->tio.LAYER_CONTROL;
  {
    BITCODE_H layers;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "layers", &layers, NULL)
        && !memcmp(&layers, &layer_control->layers, sizeof(layer_control->layers)))
      pass ("LAYER_CONTROL.layers [H]");
    else
      {
        fail ("LAYER_CONTROL.layers [H]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &layer_control->null_handle, sizeof(layer_control->null_handle)))
      pass ("LAYER_CONTROL.null_handle [H]");
    else
      {
        fail ("LAYER_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == layer_control->num_entries)
      pass ("LAYER_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("LAYER_CONTROL.num_entries [BS] %hu != %hu", layer_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(layer_control, "LAYER_CONTROL", "num_entries", &num_entries) &&
        num_entries == layer_control->num_entries)
      pass ("LAYER_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("LAYER_CONTROL.num_entries [BS] set+1 %hu != %hu", layer_control->num_entries, num_entries); error++;
      }
    layer_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "objid", &objid, NULL) &&
        objid == layer_control->objid)
      pass ("LAYER_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("LAYER_CONTROL.objid [BL] %u != %u", layer_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(layer_control, "LAYER_CONTROL", "objid", &objid) &&
        objid == layer_control->objid)
      pass ("LAYER_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("LAYER_CONTROL.objid [BL] set+1 %u != %u", layer_control->objid, objid); error++;
      }
    layer_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &layer_control->parent, sizeof(layer_control->parent)))
      pass ("LAYER_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("LAYER_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &layer_control->reactors, sizeof(layer_control->reactors)))
      pass ("LAYER_CONTROL.reactors [H]");
    else
      {
        fail ("LAYER_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &layer_control->xdicobjhandle, sizeof(layer_control->xdicobjhandle)))
      pass ("LAYER_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("LAYER_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_LAYER_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LAYER_INDEX *layer_index = obj->tio.object->tio.LAYER_INDEX;
  {
    Dwg_LAYER_entry* entries;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "entries", &entries, NULL)
        && !memcmp(&entries, &layer_index->entries, sizeof(layer_index->entries)))
      pass ("LAYER_INDEX.entries [Dwg_LAYER_entry*]");
    else
      {
        fail ("LAYER_INDEX.entries [Dwg_LAYER_entry*]"); error++;
      }
  }
  {
    BITCODE_H* entry_handles;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "entry_handles", &entry_handles, NULL)
        && !memcmp(&entry_handles, &layer_index->entry_handles, sizeof(layer_index->entry_handles)))
      pass ("LAYER_INDEX.entry_handles [H*]");
    else
      {
        fail ("LAYER_INDEX.entry_handles [H*]"); error++;
      }
  }
  {
    BITCODE_BL num_entries;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "num_entries", &num_entries, NULL) &&
        num_entries == layer_index->num_entries)
      pass ("LAYER_INDEX.num_entries [BL] %u", num_entries);
    else
      {
        fail ("LAYER_INDEX.num_entries [BL] %u != %u", layer_index->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(layer_index, "LAYER_INDEX", "num_entries", &num_entries) &&
        num_entries == layer_index->num_entries)
      pass ("LAYER_INDEX.num_entries [BL] set+1 %u", num_entries);
    else
      {
        fail ("LAYER_INDEX.num_entries [BL] set+1 %u != %u", layer_index->num_entries, num_entries); error++;
      }
    layer_index->num_entries--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &layer_index->ownerhandle, sizeof(layer_index->ownerhandle)))
      pass ("LAYER_INDEX.ownerhandle [H]");
    else
      {
        fail ("LAYER_INDEX.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "parent", &parent, NULL)
        && !memcmp(&parent, &layer_index->parent, sizeof(layer_index->parent)))
      pass ("LAYER_INDEX.parent [struct _dwg_object_object*]");
    else
      {
        fail ("LAYER_INDEX.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BL timestamp1;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "timestamp1", &timestamp1, NULL) &&
        timestamp1 == layer_index->timestamp1)
      pass ("LAYER_INDEX.timestamp1 [BL] %u", timestamp1);
    else
      {
        fail ("LAYER_INDEX.timestamp1 [BL] %u != %u", layer_index->timestamp1, timestamp1); error++;
      }
    timestamp1++;
    if (dwg_dynapi_entity_set_value(layer_index, "LAYER_INDEX", "timestamp1", &timestamp1) &&
        timestamp1 == layer_index->timestamp1)
      pass ("LAYER_INDEX.timestamp1 [BL] set+1 %u", timestamp1);
    else
      {
        fail ("LAYER_INDEX.timestamp1 [BL] set+1 %u != %u", layer_index->timestamp1, timestamp1); error++;
      }
    layer_index->timestamp1--;

  }
  {
    BITCODE_BL timestamp2;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "timestamp2", &timestamp2, NULL) &&
        timestamp2 == layer_index->timestamp2)
      pass ("LAYER_INDEX.timestamp2 [BL] %u", timestamp2);
    else
      {
        fail ("LAYER_INDEX.timestamp2 [BL] %u != %u", layer_index->timestamp2, timestamp2); error++;
      }
    timestamp2++;
    if (dwg_dynapi_entity_set_value(layer_index, "LAYER_INDEX", "timestamp2", &timestamp2) &&
        timestamp2 == layer_index->timestamp2)
      pass ("LAYER_INDEX.timestamp2 [BL] set+1 %u", timestamp2);
    else
      {
        fail ("LAYER_INDEX.timestamp2 [BL] set+1 %u != %u", layer_index->timestamp2, timestamp2); error++;
      }
    layer_index->timestamp2--;

  }
  return error;
}
static int test_LAYOUT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LAYOUT *layout = obj->tio.object->tio.LAYOUT;
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "base_ucs", &base_ucs, NULL)
        && !memcmp(&base_ucs, &layout->base_ucs, sizeof(layout->base_ucs)))
      pass ("LAYOUT.base_ucs [H]");
    else
      {
        fail ("LAYOUT.base_ucs [H]"); error++;
      }
  }
  {
    BITCODE_BD bottom_margin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "bottom_margin", &bottom_margin, NULL) &&
        bottom_margin == layout->bottom_margin)
      pass ("LAYOUT.bottom_margin [BD] %g", bottom_margin);
    else
      {
        fail ("LAYOUT.bottom_margin [BD] %g != %g", layout->bottom_margin, bottom_margin); error++;
      }
    bottom_margin++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "bottom_margin", &bottom_margin) &&
        bottom_margin == layout->bottom_margin)
      pass ("LAYOUT.bottom_margin [BD] set+1 %g", bottom_margin);
    else
      {
        fail ("LAYOUT.bottom_margin [BD] set+1 %g != %g", layout->bottom_margin, bottom_margin); error++;
      }
    layout->bottom_margin--;

  }
  {
    BITCODE_TV current_style_sheet;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "current_style_sheet", &current_style_sheet, NULL)
        && !strcmp((char*)&current_style_sheet, (char*)&layout->current_style_sheet))
      pass ("LAYOUT.current_style_sheet [TV]");
    else
      {
        fail ("LAYOUT.current_style_sheet [TV]"); error++;
      }
  }
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "drawing_units", &drawing_units, NULL) &&
        drawing_units == layout->drawing_units)
      pass ("LAYOUT.drawing_units [BD] %g", drawing_units);
    else
      {
        fail ("LAYOUT.drawing_units [BD] %g != %g", layout->drawing_units, drawing_units); error++;
      }
    drawing_units++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "drawing_units", &drawing_units) &&
        drawing_units == layout->drawing_units)
      pass ("LAYOUT.drawing_units [BD] set+1 %g", drawing_units);
    else
      {
        fail ("LAYOUT.drawing_units [BD] set+1 %g != %g", layout->drawing_units, drawing_units); error++;
      }
    layout->drawing_units--;

  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "elevation", &elevation, NULL) &&
        elevation == layout->elevation)
      pass ("LAYOUT.elevation [BD] %g", elevation);
    else
      {
        fail ("LAYOUT.elevation [BD] %g != %g", layout->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "elevation", &elevation) &&
        elevation == layout->elevation)
      pass ("LAYOUT.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("LAYOUT.elevation [BD] set+1 %g != %g", layout->elevation, elevation); error++;
      }
    layout->elevation--;

  }
  {
    BITCODE_3DPOINT extent_max;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "extent_max", &extent_max, NULL)
        && !memcmp(&extent_max, &layout->extent_max, sizeof(layout->extent_max)))
      pass ("LAYOUT.extent_max [3DPOINT]");
    else
      {
        fail ("LAYOUT.extent_max [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_3DPOINT extent_min;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "extent_min", &extent_min, NULL)
        && !memcmp(&extent_min, &layout->extent_min, sizeof(layout->extent_min)))
      pass ("LAYOUT.extent_min [3DPOINT]");
    else
      {
        fail ("LAYOUT.extent_min [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "flag", &flag, NULL) &&
        flag == layout->flag)
      pass ("LAYOUT.flag [BS] %hu", flag);
    else
      {
        fail ("LAYOUT.flag [BS] %hu != %hu", layout->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "flag", &flag) &&
        flag == layout->flag)
      pass ("LAYOUT.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("LAYOUT.flag [BS] set+1 %hu != %hu", layout->flag, flag); error++;
      }
    layout->flag--;

  }
  {
    BITCODE_3DPOINT ins_point;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ins_point", &ins_point, NULL)
        && !memcmp(&ins_point, &layout->ins_point, sizeof(layout->ins_point)))
      pass ("LAYOUT.ins_point [3DPOINT]");
    else
      {
        fail ("LAYOUT.ins_point [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_H last_viewport;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "last_viewport", &last_viewport, NULL)
        && !memcmp(&last_viewport, &layout->last_viewport, sizeof(layout->last_viewport)))
      pass ("LAYOUT.last_viewport [H]");
    else
      {
        fail ("LAYOUT.last_viewport [H]"); error++;
      }
  }
  {
    BITCODE_TV layout_name;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "layout_name", &layout_name, NULL)
        && !strcmp((char*)&layout_name, (char*)&layout->layout_name))
      pass ("LAYOUT.layout_name [TV]");
    else
      {
        fail ("LAYOUT.layout_name [TV]"); error++;
      }
  }
  {
    BITCODE_BD left_margin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "left_margin", &left_margin, NULL) &&
        left_margin == layout->left_margin)
      pass ("LAYOUT.left_margin [BD] %g", left_margin);
    else
      {
        fail ("LAYOUT.left_margin [BD] %g != %g", layout->left_margin, left_margin); error++;
      }
    left_margin++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "left_margin", &left_margin) &&
        left_margin == layout->left_margin)
      pass ("LAYOUT.left_margin [BD] set+1 %g", left_margin);
    else
      {
        fail ("LAYOUT.left_margin [BD] set+1 %g != %g", layout->left_margin, left_margin); error++;
      }
    layout->left_margin--;

  }
  {
    BITCODE_2DPOINT maximum_limits;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "maximum_limits", &maximum_limits, NULL)
        && !memcmp(&maximum_limits, &layout->maximum_limits, sizeof(layout->maximum_limits)))
      pass ("LAYOUT.maximum_limits [2DPOINT]");
    else
      {
        fail ("LAYOUT.maximum_limits [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_2DPOINT minimum_limits;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "minimum_limits", &minimum_limits, NULL)
        && !memcmp(&minimum_limits, &layout->minimum_limits, sizeof(layout->minimum_limits)))
      pass ("LAYOUT.minimum_limits [2DPOINT]");
    else
      {
        fail ("LAYOUT.minimum_limits [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "named_ucs", &named_ucs, NULL)
        && !memcmp(&named_ucs, &layout->named_ucs, sizeof(layout->named_ucs)))
      pass ("LAYOUT.named_ucs [H]");
    else
      {
        fail ("LAYOUT.named_ucs [H]"); error++;
      }
  }
  {
    BITCODE_RL num_viewports;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "num_viewports", &num_viewports, NULL) &&
        num_viewports == layout->num_viewports)
      pass ("LAYOUT.num_viewports [RL] %u", num_viewports);
    else
      {
        fail ("LAYOUT.num_viewports [RL] %u != %u", layout->num_viewports, num_viewports); error++;
      }
    num_viewports++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "num_viewports", &num_viewports) &&
        num_viewports == layout->num_viewports)
      pass ("LAYOUT.num_viewports [RL] set+1 %u", num_viewports);
    else
      {
        fail ("LAYOUT.num_viewports [RL] set+1 %u != %u", layout->num_viewports, num_viewports); error++;
      }
    layout->num_viewports--;

  }
  {
    BITCODE_BS orthoview_type;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "orthoview_type", &orthoview_type, NULL) &&
        orthoview_type == layout->orthoview_type)
      pass ("LAYOUT.orthoview_type [BS] %hu", orthoview_type);
    else
      {
        fail ("LAYOUT.orthoview_type [BS] %hu != %hu", layout->orthoview_type, orthoview_type); error++;
      }
    orthoview_type++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "orthoview_type", &orthoview_type) &&
        orthoview_type == layout->orthoview_type)
      pass ("LAYOUT.orthoview_type [BS] set+1 %hu", orthoview_type);
    else
      {
        fail ("LAYOUT.orthoview_type [BS] set+1 %hu != %hu", layout->orthoview_type, orthoview_type); error++;
      }
    layout->orthoview_type--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &layout->ownerhandle, sizeof(layout->ownerhandle)))
      pass ("LAYOUT.ownerhandle [H]");
    else
      {
        fail ("LAYOUT.ownerhandle [H]"); error++;
      }
  }
  {
    BITCODE_TV page_setup_name;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "page_setup_name", &page_setup_name, NULL)
        && !strcmp((char*)&page_setup_name, (char*)&layout->page_setup_name))
      pass ("LAYOUT.page_setup_name [TV]");
    else
      {
        fail ("LAYOUT.page_setup_name [TV]"); error++;
      }
  }
  {
    BITCODE_BD paper_height;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_height", &paper_height, NULL) &&
        paper_height == layout->paper_height)
      pass ("LAYOUT.paper_height [BD] %g", paper_height);
    else
      {
        fail ("LAYOUT.paper_height [BD] %g != %g", layout->paper_height, paper_height); error++;
      }
    paper_height++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "paper_height", &paper_height) &&
        paper_height == layout->paper_height)
      pass ("LAYOUT.paper_height [BD] set+1 %g", paper_height);
    else
      {
        fail ("LAYOUT.paper_height [BD] set+1 %g != %g", layout->paper_height, paper_height); error++;
      }
    layout->paper_height--;

  }
  {
    BITCODE_2DPOINT paper_image_origin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_image_origin", &paper_image_origin, NULL)
        && !memcmp(&paper_image_origin, &layout->paper_image_origin, sizeof(layout->paper_image_origin)))
      pass ("LAYOUT.paper_image_origin [2DPOINT]");
    else
      {
        fail ("LAYOUT.paper_image_origin [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_TV paper_size;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_size", &paper_size, NULL)
        && !strcmp((char*)&paper_size, (char*)&layout->paper_size))
      pass ("LAYOUT.paper_size [TV]");
    else
      {
        fail ("LAYOUT.paper_size [TV]"); error++;
      }
  }
  {
    BITCODE_BS paper_units;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_units", &paper_units, NULL) &&
        paper_units == layout->paper_units)
      pass ("LAYOUT.paper_units [BS] %hu", paper_units);
    else
      {
        fail ("LAYOUT.paper_units [BS] %hu != %hu", layout->paper_units, paper_units); error++;
      }
    paper_units++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "paper_units", &paper_units) &&
        paper_units == layout->paper_units)
      pass ("LAYOUT.paper_units [BS] set+1 %hu", paper_units);
    else
      {
        fail ("LAYOUT.paper_units [BS] set+1 %hu != %hu", layout->paper_units, paper_units); error++;
      }
    layout->paper_units--;

  }
  {
    BITCODE_BD paper_width;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_width", &paper_width, NULL) &&
        paper_width == layout->paper_width)
      pass ("LAYOUT.paper_width [BD] %g", paper_width);
    else
      {
        fail ("LAYOUT.paper_width [BD] %g != %g", layout->paper_width, paper_width); error++;
      }
    paper_width++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "paper_width", &paper_width) &&
        paper_width == layout->paper_width)
      pass ("LAYOUT.paper_width [BD] set+1 %g", paper_width);
    else
      {
        fail ("LAYOUT.paper_width [BD] set+1 %g != %g", layout->paper_width, paper_width); error++;
      }
    layout->paper_width--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "parent", &parent, NULL)
        && !memcmp(&parent, &layout->parent, sizeof(layout->parent)))
      pass ("LAYOUT.parent [struct _dwg_object_object*]");
    else
      {
        fail ("LAYOUT.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BS plot_layout_flags;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_layout_flags", &plot_layout_flags, NULL) &&
        plot_layout_flags == layout->plot_layout_flags)
      pass ("LAYOUT.plot_layout_flags [BS] %hu", plot_layout_flags);
    else
      {
        fail ("LAYOUT.plot_layout_flags [BS] %hu != %hu", layout->plot_layout_flags, plot_layout_flags); error++;
      }
    plot_layout_flags++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "plot_layout_flags", &plot_layout_flags) &&
        plot_layout_flags == layout->plot_layout_flags)
      pass ("LAYOUT.plot_layout_flags [BS] set+1 %hu", plot_layout_flags);
    else
      {
        fail ("LAYOUT.plot_layout_flags [BS] set+1 %hu != %hu", layout->plot_layout_flags, plot_layout_flags); error++;
      }
    layout->plot_layout_flags--;

  }
  {
    BITCODE_2DPOINT plot_origin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_origin", &plot_origin, NULL)
        && !memcmp(&plot_origin, &layout->plot_origin, sizeof(layout->plot_origin)))
      pass ("LAYOUT.plot_origin [2DPOINT]");
    else
      {
        fail ("LAYOUT.plot_origin [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_BS plot_rotation;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_rotation", &plot_rotation, NULL) &&
        plot_rotation == layout->plot_rotation)
      pass ("LAYOUT.plot_rotation [BS] %hu", plot_rotation);
    else
      {
        fail ("LAYOUT.plot_rotation [BS] %hu != %hu", layout->plot_rotation, plot_rotation); error++;
      }
    plot_rotation++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "plot_rotation", &plot_rotation) &&
        plot_rotation == layout->plot_rotation)
      pass ("LAYOUT.plot_rotation [BS] set+1 %hu", plot_rotation);
    else
      {
        fail ("LAYOUT.plot_rotation [BS] set+1 %hu != %hu", layout->plot_rotation, plot_rotation); error++;
      }
    layout->plot_rotation--;

  }
  {
    BITCODE_BS plot_type;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_type", &plot_type, NULL) &&
        plot_type == layout->plot_type)
      pass ("LAYOUT.plot_type [BS] %hu", plot_type);
    else
      {
        fail ("LAYOUT.plot_type [BS] %hu != %hu", layout->plot_type, plot_type); error++;
      }
    plot_type++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "plot_type", &plot_type) &&
        plot_type == layout->plot_type)
      pass ("LAYOUT.plot_type [BS] set+1 %hu", plot_type);
    else
      {
        fail ("LAYOUT.plot_type [BS] set+1 %hu != %hu", layout->plot_type, plot_type); error++;
      }
    layout->plot_type--;

  }
  {
    BITCODE_H plot_view;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_view", &plot_view, NULL)
        && !memcmp(&plot_view, &layout->plot_view, sizeof(layout->plot_view)))
      pass ("LAYOUT.plot_view [H]");
    else
      {
        fail ("LAYOUT.plot_view [H]"); error++;
      }
  }
  {
    BITCODE_TV plot_view_name;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_view_name", &plot_view_name, NULL)
        && !strcmp((char*)&plot_view_name, (char*)&layout->plot_view_name))
      pass ("LAYOUT.plot_view_name [TV]");
    else
      {
        fail ("LAYOUT.plot_view_name [TV]"); error++;
      }
  }
  {
    BITCODE_TV printer_or_config;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "printer_or_config", &printer_or_config, NULL)
        && !strcmp((char*)&printer_or_config, (char*)&layout->printer_or_config))
      pass ("LAYOUT.printer_or_config [TV]");
    else
      {
        fail ("LAYOUT.printer_or_config [TV]"); error++;
      }
  }
  {
    BITCODE_H pspace_block_record;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "pspace_block_record", &pspace_block_record, NULL)
        && !memcmp(&pspace_block_record, &layout->pspace_block_record, sizeof(layout->pspace_block_record)))
      pass ("LAYOUT.pspace_block_record [H]");
    else
      {
        fail ("LAYOUT.pspace_block_record [H]"); error++;
      }
  }
  {
    BITCODE_BD real_world_units;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "real_world_units", &real_world_units, NULL) &&
        real_world_units == layout->real_world_units)
      pass ("LAYOUT.real_world_units [BD] %g", real_world_units);
    else
      {
        fail ("LAYOUT.real_world_units [BD] %g != %g", layout->real_world_units, real_world_units); error++;
      }
    real_world_units++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "real_world_units", &real_world_units) &&
        real_world_units == layout->real_world_units)
      pass ("LAYOUT.real_world_units [BD] set+1 %g", real_world_units);
    else
      {
        fail ("LAYOUT.real_world_units [BD] set+1 %g != %g", layout->real_world_units, real_world_units); error++;
      }
    layout->real_world_units--;

  }
  {
    BITCODE_BD right_margin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "right_margin", &right_margin, NULL) &&
        right_margin == layout->right_margin)
      pass ("LAYOUT.right_margin [BD] %g", right_margin);
    else
      {
        fail ("LAYOUT.right_margin [BD] %g != %g", layout->right_margin, right_margin); error++;
      }
    right_margin++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "right_margin", &right_margin) &&
        right_margin == layout->right_margin)
      pass ("LAYOUT.right_margin [BD] set+1 %g", right_margin);
    else
      {
        fail ("LAYOUT.right_margin [BD] set+1 %g != %g", layout->right_margin, right_margin); error++;
      }
    layout->right_margin--;

  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "scale_factor", &scale_factor, NULL) &&
        scale_factor == layout->scale_factor)
      pass ("LAYOUT.scale_factor [BD] %g", scale_factor);
    else
      {
        fail ("LAYOUT.scale_factor [BD] %g != %g", layout->scale_factor, scale_factor); error++;
      }
    scale_factor++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "scale_factor", &scale_factor) &&
        scale_factor == layout->scale_factor)
      pass ("LAYOUT.scale_factor [BD] set+1 %g", scale_factor);
    else
      {
        fail ("LAYOUT.scale_factor [BD] set+1 %g != %g", layout->scale_factor, scale_factor); error++;
      }
    layout->scale_factor--;

  }
  {
    BITCODE_BS scale_type;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "scale_type", &scale_type, NULL) &&
        scale_type == layout->scale_type)
      pass ("LAYOUT.scale_type [BS] %hu", scale_type);
    else
      {
        fail ("LAYOUT.scale_type [BS] %hu != %hu", layout->scale_type, scale_type); error++;
      }
    scale_type++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "scale_type", &scale_type) &&
        scale_type == layout->scale_type)
      pass ("LAYOUT.scale_type [BS] set+1 %hu", scale_type);
    else
      {
        fail ("LAYOUT.scale_type [BS] set+1 %hu != %hu", layout->scale_type, scale_type); error++;
      }
    layout->scale_type--;

  }
  {
    BITCODE_BS shade_plot_custom_dpi;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "shade_plot_custom_dpi", &shade_plot_custom_dpi, NULL) &&
        shade_plot_custom_dpi == layout->shade_plot_custom_dpi)
      pass ("LAYOUT.shade_plot_custom_dpi [BS] %hu", shade_plot_custom_dpi);
    else
      {
        fail ("LAYOUT.shade_plot_custom_dpi [BS] %hu != %hu", layout->shade_plot_custom_dpi, shade_plot_custom_dpi); error++;
      }
    shade_plot_custom_dpi++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "shade_plot_custom_dpi", &shade_plot_custom_dpi) &&
        shade_plot_custom_dpi == layout->shade_plot_custom_dpi)
      pass ("LAYOUT.shade_plot_custom_dpi [BS] set+1 %hu", shade_plot_custom_dpi);
    else
      {
        fail ("LAYOUT.shade_plot_custom_dpi [BS] set+1 %hu != %hu", layout->shade_plot_custom_dpi, shade_plot_custom_dpi); error++;
      }
    layout->shade_plot_custom_dpi--;

  }
  {
    BITCODE_BS shade_plot_mode;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "shade_plot_mode", &shade_plot_mode, NULL) &&
        shade_plot_mode == layout->shade_plot_mode)
      pass ("LAYOUT.shade_plot_mode [BS] %hu", shade_plot_mode);
    else
      {
        fail ("LAYOUT.shade_plot_mode [BS] %hu != %hu", layout->shade_plot_mode, shade_plot_mode); error++;
      }
    shade_plot_mode++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "shade_plot_mode", &shade_plot_mode) &&
        shade_plot_mode == layout->shade_plot_mode)
      pass ("LAYOUT.shade_plot_mode [BS] set+1 %hu", shade_plot_mode);
    else
      {
        fail ("LAYOUT.shade_plot_mode [BS] set+1 %hu != %hu", layout->shade_plot_mode, shade_plot_mode); error++;
      }
    layout->shade_plot_mode--;

  }
  {
    BITCODE_BS shade_plot_res_level;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "shade_plot_res_level", &shade_plot_res_level, NULL) &&
        shade_plot_res_level == layout->shade_plot_res_level)
      pass ("LAYOUT.shade_plot_res_level [BS] %hu", shade_plot_res_level);
    else
      {
        fail ("LAYOUT.shade_plot_res_level [BS] %hu != %hu", layout->shade_plot_res_level, shade_plot_res_level); error++;
      }
    shade_plot_res_level++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "shade_plot_res_level", &shade_plot_res_level) &&
        shade_plot_res_level == layout->shade_plot_res_level)
      pass ("LAYOUT.shade_plot_res_level [BS] set+1 %hu", shade_plot_res_level);
    else
      {
        fail ("LAYOUT.shade_plot_res_level [BS] set+1 %hu != %hu", layout->shade_plot_res_level, shade_plot_res_level); error++;
      }
    layout->shade_plot_res_level--;

  }
  {
    BITCODE_BS tab_order;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "tab_order", &tab_order, NULL) &&
        tab_order == layout->tab_order)
      pass ("LAYOUT.tab_order [BS] %hu", tab_order);
    else
      {
        fail ("LAYOUT.tab_order [BS] %hu != %hu", layout->tab_order, tab_order); error++;
      }
    tab_order++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "tab_order", &tab_order) &&
        tab_order == layout->tab_order)
      pass ("LAYOUT.tab_order [BS] set+1 %hu", tab_order);
    else
      {
        fail ("LAYOUT.tab_order [BS] set+1 %hu != %hu", layout->tab_order, tab_order); error++;
      }
    layout->tab_order--;

  }
  {
    BITCODE_BD top_margin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "top_margin", &top_margin, NULL) &&
        top_margin == layout->top_margin)
      pass ("LAYOUT.top_margin [BD] %g", top_margin);
    else
      {
        fail ("LAYOUT.top_margin [BD] %g != %g", layout->top_margin, top_margin); error++;
      }
    top_margin++;
    if (dwg_dynapi_entity_set_value(layout, "LAYOUT", "top_margin", &top_margin) &&
        top_margin == layout->top_margin)
      pass ("LAYOUT.top_margin [BD] set+1 %g", top_margin);
    else
      {
        fail ("LAYOUT.top_margin [BD] set+1 %g != %g", layout->top_margin, top_margin); error++;
      }
    layout->top_margin--;

  }
  {
    BITCODE_3DPOINT ucs_origin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp(&ucs_origin, &layout->ucs_origin, sizeof(layout->ucs_origin)))
      pass ("LAYOUT.ucs_origin [3DPOINT]");
    else
      {
        fail ("LAYOUT.ucs_origin [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_3DPOINT ucs_x_axis;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp(&ucs_x_axis, &layout->ucs_x_axis, sizeof(layout->ucs_x_axis)))
      pass ("LAYOUT.ucs_x_axis [3DPOINT]");
    else
      {
        fail ("LAYOUT.ucs_x_axis [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_3DPOINT ucs_y_axis;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp(&ucs_y_axis, &layout->ucs_y_axis, sizeof(layout->ucs_y_axis)))
      pass ("LAYOUT.ucs_y_axis [3DPOINT]");
    else
      {
        fail ("LAYOUT.ucs_y_axis [3DPOINT]"); error++;
      }
  }
  {
    BITCODE_H* viewports;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "viewports", &viewports, NULL)
        && !memcmp(&viewports, &layout->viewports, sizeof(layout->viewports)))
      pass ("LAYOUT.viewports [H*]");
    else
      {
        fail ("LAYOUT.viewports [H*]"); error++;
      }
  }
  {
    BITCODE_H visual_style;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "visual_style", &visual_style, NULL)
        && !memcmp(&visual_style, &layout->visual_style, sizeof(layout->visual_style)))
      pass ("LAYOUT.visual_style [H]");
    else
      {
        fail ("LAYOUT.visual_style [H]"); error++;
      }
  }
  {
    BITCODE_2DPOINT window_max;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "window_max", &window_max, NULL)
        && !memcmp(&window_max, &layout->window_max, sizeof(layout->window_max)))
      pass ("LAYOUT.window_max [2DPOINT]");
    else
      {
        fail ("LAYOUT.window_max [2DPOINT]"); error++;
      }
  }
  {
    BITCODE_2DPOINT window_min;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "window_min", &window_min, NULL)
        && !memcmp(&window_min, &layout->window_min, sizeof(layout->window_min)))
      pass ("LAYOUT.window_min [2DPOINT]");
    else
      {
        fail ("LAYOUT.window_min [2DPOINT]"); error++;
      }
  }
  return error;
}
static int test_LIGHTLIST (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LIGHTLIST *lightlist = obj->tio.object->tio.LIGHTLIST;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "class_version", &class_version, NULL) &&
        class_version == lightlist->class_version)
      pass ("LIGHTLIST.class_version [BS] %hu", class_version);
    else
      {
        fail ("LIGHTLIST.class_version [BS] %hu != %hu", lightlist->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(lightlist, "LIGHTLIST", "class_version", &class_version) &&
        class_version == lightlist->class_version)
      pass ("LIGHTLIST.class_version [BS] set+1 %hu", class_version);
    else
      {
        fail ("LIGHTLIST.class_version [BS] set+1 %hu != %hu", lightlist->class_version, class_version); error++;
      }
    lightlist->class_version--;

  }
  {
    BITCODE_H* dictionary;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "dictionary", &dictionary, NULL)
        && !memcmp(&dictionary, &lightlist->dictionary, sizeof(lightlist->dictionary)))
      pass ("LIGHTLIST.dictionary [H*]");
    else
      {
        fail ("LIGHTLIST.dictionary [H*]"); error++;
      }
  }
  {
    BITCODE_H light_handle;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "light_handle", &light_handle, NULL)
        && !memcmp(&light_handle, &lightlist->light_handle, sizeof(lightlist->light_handle)))
      pass ("LIGHTLIST.light_handle [H]");
    else
      {
        fail ("LIGHTLIST.light_handle [H]"); error++;
      }
  }
  {
    BITCODE_TV light_name;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "light_name", &light_name, NULL)
        && !strcmp((char*)&light_name, (char*)&lightlist->light_name))
      pass ("LIGHTLIST.light_name [TV]");
    else
      {
        fail ("LIGHTLIST.light_name [TV]"); error++;
      }
  }
  {
    BITCODE_BS num_lights;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "num_lights", &num_lights, NULL) &&
        num_lights == lightlist->num_lights)
      pass ("LIGHTLIST.num_lights [BS] %hu", num_lights);
    else
      {
        fail ("LIGHTLIST.num_lights [BS] %hu != %hu", lightlist->num_lights, num_lights); error++;
      }
    num_lights++;
    if (dwg_dynapi_entity_set_value(lightlist, "LIGHTLIST", "num_lights", &num_lights) &&
        num_lights == lightlist->num_lights)
      pass ("LIGHTLIST.num_lights [BS] set+1 %hu", num_lights);
    else
      {
        fail ("LIGHTLIST.num_lights [BS] set+1 %hu != %hu", lightlist->num_lights, num_lights); error++;
      }
    lightlist->num_lights--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "parent", &parent, NULL)
        && !memcmp(&parent, &lightlist->parent, sizeof(lightlist->parent)))
      pass ("LIGHTLIST.parent [struct _dwg_object_object*]");
    else
      {
        fail ("LIGHTLIST.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_LONG_TRANSACTION (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LONG_TRANSACTION *long_transaction = obj->tio.object->tio.LONG_TRANSACTION;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(long_transaction, "LONG_TRANSACTION", "parent", &parent, NULL)
        && !memcmp(&parent, &long_transaction->parent, sizeof(long_transaction->parent)))
      pass ("LONG_TRANSACTION.parent [struct _dwg_object_object*]");
    else
      {
        fail ("LONG_TRANSACTION.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_LTYPE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LTYPE *ltype = obj->tio.object->tio.LTYPE;
  {
    BITCODE_RC alignment;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "alignment", &alignment, NULL) &&
        alignment == ltype->alignment)
      pass ("LTYPE.alignment [RC] %u", alignment);
    else
      {
        fail ("LTYPE.alignment [RC] %u != %u", ltype->alignment, alignment); error++;
      }
    alignment++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "alignment", &alignment) &&
        alignment == ltype->alignment)
      pass ("LTYPE.alignment [RC] set+1 %u", alignment);
    else
      {
        fail ("LTYPE.alignment [RC] set+1 %u != %u", ltype->alignment, alignment); error++;
      }
    ltype->alignment--;

  }
  {
    Dwg_LTYPE_dash* dash;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "dash", &dash, NULL)
        && !memcmp(&dash, &ltype->dash, sizeof(ltype->dash)))
      pass ("LTYPE.dash [Dwg_LTYPE_dash*]");
    else
      {
        fail ("LTYPE.dash [Dwg_LTYPE_dash*]"); error++;
      }
  }
  {
    BITCODE_RD* dashes_r11;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "dashes_r11", &dashes_r11, NULL)
        && !memcmp(&dashes_r11, &ltype->dashes_r11, sizeof(ltype->dashes_r11)))
      pass ("LTYPE.dashes_r11 [RD*]");
    else
      {
        fail ("LTYPE.dashes_r11 [RD*]"); error++;
      }
  }
  {
    BITCODE_TV description;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "description", &description, NULL)
        && !strcmp((char*)&description, (char*)&ltype->description))
      pass ("LTYPE.description [TV]");
    else
      {
        fail ("LTYPE.description [TV]"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "flag", &flag, NULL) &&
        flag == ltype->flag)
      pass ("LTYPE.flag [RC] %u", flag);
    else
      {
        fail ("LTYPE.flag [RC] %u != %u", ltype->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "flag", &flag) &&
        flag == ltype->flag)
      pass ("LTYPE.flag [RC] set+1 %u", flag);
    else
      {
        fail ("LTYPE.flag [RC] set+1 %u != %u", ltype->flag, flag); error++;
      }
    ltype->flag--;

  }
  {
    BITCODE_H linetype_control;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "linetype_control", &linetype_control, NULL)
        && !memcmp(&linetype_control, &ltype->linetype_control, sizeof(ltype->linetype_control)))
      pass ("LTYPE.linetype_control [H]");
    else
      {
        fail ("LTYPE.linetype_control [H]"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&ltype->name))
      pass ("LTYPE.name [TV]");
    else
      {
        fail ("LTYPE.name [TV]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &ltype->null_handle, sizeof(ltype->null_handle)))
      pass ("LTYPE.null_handle [H]");
    else
      {
        fail ("LTYPE.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_RC num_dashes;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "num_dashes", &num_dashes, NULL) &&
        num_dashes == ltype->num_dashes)
      pass ("LTYPE.num_dashes [RC] %u", num_dashes);
    else
      {
        fail ("LTYPE.num_dashes [RC] %u != %u", ltype->num_dashes, num_dashes); error++;
      }
    num_dashes++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "num_dashes", &num_dashes) &&
        num_dashes == ltype->num_dashes)
      pass ("LTYPE.num_dashes [RC] set+1 %u", num_dashes);
    else
      {
        fail ("LTYPE.num_dashes [RC] set+1 %u != %u", ltype->num_dashes, num_dashes); error++;
      }
    ltype->num_dashes--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "parent", &parent, NULL)
        && !memcmp(&parent, &ltype->parent, sizeof(ltype->parent)))
      pass ("LTYPE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("LTYPE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BD pattern_len;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "pattern_len", &pattern_len, NULL) &&
        pattern_len == ltype->pattern_len)
      pass ("LTYPE.pattern_len [BD] %g", pattern_len);
    else
      {
        fail ("LTYPE.pattern_len [BD] %g != %g", ltype->pattern_len, pattern_len); error++;
      }
    pattern_len++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "pattern_len", &pattern_len) &&
        pattern_len == ltype->pattern_len)
      pass ("LTYPE.pattern_len [BD] set+1 %g", pattern_len);
    else
      {
        fail ("LTYPE.pattern_len [BD] set+1 %g != %g", ltype->pattern_len, pattern_len); error++;
      }
    ltype->pattern_len--;

  }
  {
    BITCODE_TV strings_area;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "strings_area", &strings_area, NULL)
        && !strcmp((char*)&strings_area, (char*)&ltype->strings_area))
      pass ("LTYPE.strings_area [TV]");
    else
      {
        fail ("LTYPE.strings_area [TV]"); error++;
      }
  }
  {
    BITCODE_H* styles;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "styles", &styles, NULL)
        && !memcmp(&styles, &ltype->styles, sizeof(ltype->styles)))
      pass ("LTYPE.styles [H*]");
    else
      {
        fail ("LTYPE.styles [H*]"); error++;
      }
  }
  {
    BITCODE_B text_area_is_present;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "text_area_is_present", &text_area_is_present, NULL) &&
        text_area_is_present == ltype->text_area_is_present)
      pass ("LTYPE.text_area_is_present [B] " FORMAT_B "", text_area_is_present);
    else
      {
        fail ("LTYPE.text_area_is_present [B] " FORMAT_B " != " FORMAT_B "", ltype->text_area_is_present, text_area_is_present); error++;
      }
    text_area_is_present++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "text_area_is_present", &text_area_is_present) &&
        text_area_is_present == ltype->text_area_is_present)
      pass ("LTYPE.text_area_is_present [B] set+1 " FORMAT_B "", text_area_is_present);
    else
      {
        fail ("LTYPE.text_area_is_present [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->text_area_is_present, text_area_is_present); error++;
      }
    ltype->text_area_is_present--;

  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "used", &used, NULL) &&
        used == ltype->used)
      pass ("LTYPE.used [RS] %hu", used);
    else
      {
        fail ("LTYPE.used [RS] %hu != %hu", ltype->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "used", &used) &&
        used == ltype->used)
      pass ("LTYPE.used [RS] set+1 %hu", used);
    else
      {
        fail ("LTYPE.used [RS] set+1 %hu != %hu", ltype->used, used); error++;
      }
    ltype->used--;

  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "xrefdep", &xrefdep, NULL) &&
        xrefdep == ltype->xrefdep)
      pass ("LTYPE.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("LTYPE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", ltype->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "xrefdep", &xrefdep) &&
        xrefdep == ltype->xrefdep)
      pass ("LTYPE.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("LTYPE.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->xrefdep, xrefdep); error++;
      }
    ltype->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == ltype->xrefindex_plus1)
      pass ("LTYPE.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("LTYPE.xrefindex_plus1 [BS] %hu != %hu", ltype->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == ltype->xrefindex_plus1)
      pass ("LTYPE.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("LTYPE.xrefindex_plus1 [BS] set+1 %hu != %hu", ltype->xrefindex_plus1, xrefindex_plus1); error++;
      }
    ltype->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "xrefref", &xrefref, NULL) &&
        xrefref == ltype->xrefref)
      pass ("LTYPE.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("LTYPE.xrefref [B] " FORMAT_B " != " FORMAT_B "", ltype->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(ltype, "LTYPE", "xrefref", &xrefref) &&
        xrefref == ltype->xrefref)
      pass ("LTYPE.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("LTYPE.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->xrefref, xrefref); error++;
      }
    ltype->xrefref--;

  }
  return error;
}
static int test_LTYPE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LTYPE_CONTROL *ltype_control = obj->tio.object->tio.LTYPE_CONTROL;
  {
    BITCODE_H byblock;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "byblock", &byblock, NULL)
        && !memcmp(&byblock, &ltype_control->byblock, sizeof(ltype_control->byblock)))
      pass ("LTYPE_CONTROL.byblock [H]");
    else
      {
        fail ("LTYPE_CONTROL.byblock [H]"); error++;
      }
  }
  {
    BITCODE_H bylayer;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "bylayer", &bylayer, NULL)
        && !memcmp(&bylayer, &ltype_control->bylayer, sizeof(ltype_control->bylayer)))
      pass ("LTYPE_CONTROL.bylayer [H]");
    else
      {
        fail ("LTYPE_CONTROL.bylayer [H]"); error++;
      }
  }
  {
    BITCODE_H linetypes;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "linetypes", &linetypes, NULL)
        && !memcmp(&linetypes, &ltype_control->linetypes, sizeof(ltype_control->linetypes)))
      pass ("LTYPE_CONTROL.linetypes [H]");
    else
      {
        fail ("LTYPE_CONTROL.linetypes [H]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &ltype_control->null_handle, sizeof(ltype_control->null_handle)))
      pass ("LTYPE_CONTROL.null_handle [H]");
    else
      {
        fail ("LTYPE_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == ltype_control->num_entries)
      pass ("LTYPE_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("LTYPE_CONTROL.num_entries [BS] %hu != %hu", ltype_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(ltype_control, "LTYPE_CONTROL", "num_entries", &num_entries) &&
        num_entries == ltype_control->num_entries)
      pass ("LTYPE_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("LTYPE_CONTROL.num_entries [BS] set+1 %hu != %hu", ltype_control->num_entries, num_entries); error++;
      }
    ltype_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "objid", &objid, NULL) &&
        objid == ltype_control->objid)
      pass ("LTYPE_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("LTYPE_CONTROL.objid [BL] %u != %u", ltype_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(ltype_control, "LTYPE_CONTROL", "objid", &objid) &&
        objid == ltype_control->objid)
      pass ("LTYPE_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("LTYPE_CONTROL.objid [BL] set+1 %u != %u", ltype_control->objid, objid); error++;
      }
    ltype_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &ltype_control->parent, sizeof(ltype_control->parent)))
      pass ("LTYPE_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("LTYPE_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &ltype_control->reactors, sizeof(ltype_control->reactors)))
      pass ("LTYPE_CONTROL.reactors [H]");
    else
      {
        fail ("LTYPE_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &ltype_control->xdicobjhandle, sizeof(ltype_control->xdicobjhandle)))
      pass ("LTYPE_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("LTYPE_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_MATERIAL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_MATERIAL *material = obj->tio.object->tio.MATERIAL;
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "ambient_color", &ambient_color, NULL)
        && !memcmp(&ambient_color, &material->ambient_color, sizeof(material->ambient_color)))
      pass ("MATERIAL.ambient_color [CMC]");
    else
      {
        fail ("MATERIAL.ambient_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD ambient_color_factor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "ambient_color_factor", &ambient_color_factor, NULL) &&
        ambient_color_factor == material->ambient_color_factor)
      pass ("MATERIAL.ambient_color_factor [BD] %g", ambient_color_factor);
    else
      {
        fail ("MATERIAL.ambient_color_factor [BD] %g != %g", material->ambient_color_factor, ambient_color_factor); error++;
      }
    ambient_color_factor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "ambient_color_factor", &ambient_color_factor) &&
        ambient_color_factor == material->ambient_color_factor)
      pass ("MATERIAL.ambient_color_factor [BD] set+1 %g", ambient_color_factor);
    else
      {
        fail ("MATERIAL.ambient_color_factor [BD] set+1 %g != %g", material->ambient_color_factor, ambient_color_factor); error++;
      }
    material->ambient_color_factor--;

  }
  {
    BITCODE_BS ambient_color_flag;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "ambient_color_flag", &ambient_color_flag, NULL) &&
        ambient_color_flag == material->ambient_color_flag)
      pass ("MATERIAL.ambient_color_flag [BS] %hu", ambient_color_flag);
    else
      {
        fail ("MATERIAL.ambient_color_flag [BS] %hu != %hu", material->ambient_color_flag, ambient_color_flag); error++;
      }
    ambient_color_flag++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "ambient_color_flag", &ambient_color_flag) &&
        ambient_color_flag == material->ambient_color_flag)
      pass ("MATERIAL.ambient_color_flag [BS] set+1 %hu", ambient_color_flag);
    else
      {
        fail ("MATERIAL.ambient_color_flag [BS] set+1 %hu != %hu", material->ambient_color_flag, ambient_color_flag); error++;
      }
    material->ambient_color_flag--;

  }
  {
    BITCODE_BS bumpmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_autotransform", &bumpmap_autotransform, NULL) &&
        bumpmap_autotransform == material->bumpmap_autotransform)
      pass ("MATERIAL.bumpmap_autotransform [BS] %hu", bumpmap_autotransform);
    else
      {
        fail ("MATERIAL.bumpmap_autotransform [BS] %hu != %hu", material->bumpmap_autotransform, bumpmap_autotransform); error++;
      }
    bumpmap_autotransform++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "bumpmap_autotransform", &bumpmap_autotransform) &&
        bumpmap_autotransform == material->bumpmap_autotransform)
      pass ("MATERIAL.bumpmap_autotransform [BS] set+1 %hu", bumpmap_autotransform);
    else
      {
        fail ("MATERIAL.bumpmap_autotransform [BS] set+1 %hu != %hu", material->bumpmap_autotransform, bumpmap_autotransform); error++;
      }
    material->bumpmap_autotransform--;

  }
  {
    BITCODE_BD bumpmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_blendfactor", &bumpmap_blendfactor, NULL) &&
        bumpmap_blendfactor == material->bumpmap_blendfactor)
      pass ("MATERIAL.bumpmap_blendfactor [BD] %g", bumpmap_blendfactor);
    else
      {
        fail ("MATERIAL.bumpmap_blendfactor [BD] %g != %g", material->bumpmap_blendfactor, bumpmap_blendfactor); error++;
      }
    bumpmap_blendfactor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "bumpmap_blendfactor", &bumpmap_blendfactor) &&
        bumpmap_blendfactor == material->bumpmap_blendfactor)
      pass ("MATERIAL.bumpmap_blendfactor [BD] set+1 %g", bumpmap_blendfactor);
    else
      {
        fail ("MATERIAL.bumpmap_blendfactor [BD] set+1 %g != %g", material->bumpmap_blendfactor, bumpmap_blendfactor); error++;
      }
    material->bumpmap_blendfactor--;

  }
  {
    BITCODE_T bumpmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_filename", &bumpmap_filename, NULL)
        && !memcmp(&bumpmap_filename, &material->bumpmap_filename, sizeof(material->bumpmap_filename)))
      pass ("MATERIAL.bumpmap_filename [T]");
    else
      {
        fail ("MATERIAL.bumpmap_filename [T]"); error++;
      }
  }
  {
    BITCODE_BS bumpmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_projection", &bumpmap_projection, NULL) &&
        bumpmap_projection == material->bumpmap_projection)
      pass ("MATERIAL.bumpmap_projection [BS] %hu", bumpmap_projection);
    else
      {
        fail ("MATERIAL.bumpmap_projection [BS] %hu != %hu", material->bumpmap_projection, bumpmap_projection); error++;
      }
    bumpmap_projection++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "bumpmap_projection", &bumpmap_projection) &&
        bumpmap_projection == material->bumpmap_projection)
      pass ("MATERIAL.bumpmap_projection [BS] set+1 %hu", bumpmap_projection);
    else
      {
        fail ("MATERIAL.bumpmap_projection [BS] set+1 %hu != %hu", material->bumpmap_projection, bumpmap_projection); error++;
      }
    material->bumpmap_projection--;

  }
  {
    BITCODE_BS bumpmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_source", &bumpmap_source, NULL) &&
        bumpmap_source == material->bumpmap_source)
      pass ("MATERIAL.bumpmap_source [BS] %hu", bumpmap_source);
    else
      {
        fail ("MATERIAL.bumpmap_source [BS] %hu != %hu", material->bumpmap_source, bumpmap_source); error++;
      }
    bumpmap_source++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "bumpmap_source", &bumpmap_source) &&
        bumpmap_source == material->bumpmap_source)
      pass ("MATERIAL.bumpmap_source [BS] set+1 %hu", bumpmap_source);
    else
      {
        fail ("MATERIAL.bumpmap_source [BS] set+1 %hu != %hu", material->bumpmap_source, bumpmap_source); error++;
      }
    material->bumpmap_source--;

  }
  {
    BITCODE_BS bumpmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_tiling", &bumpmap_tiling, NULL) &&
        bumpmap_tiling == material->bumpmap_tiling)
      pass ("MATERIAL.bumpmap_tiling [BS] %hu", bumpmap_tiling);
    else
      {
        fail ("MATERIAL.bumpmap_tiling [BS] %hu != %hu", material->bumpmap_tiling, bumpmap_tiling); error++;
      }
    bumpmap_tiling++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "bumpmap_tiling", &bumpmap_tiling) &&
        bumpmap_tiling == material->bumpmap_tiling)
      pass ("MATERIAL.bumpmap_tiling [BS] set+1 %hu", bumpmap_tiling);
    else
      {
        fail ("MATERIAL.bumpmap_tiling [BS] set+1 %hu != %hu", material->bumpmap_tiling, bumpmap_tiling); error++;
      }
    material->bumpmap_tiling--;

  }
  {
    BITCODE_BD* bumpmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_transmatrix", &bumpmap_transmatrix, NULL)
        && !memcmp(&bumpmap_transmatrix, &material->bumpmap_transmatrix, sizeof(material->bumpmap_transmatrix)))
      pass ("MATERIAL.bumpmap_transmatrix [BD*]");
    else
      {
        fail ("MATERIAL.bumpmap_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BL channel_flags;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "channel_flags", &channel_flags, NULL) &&
        channel_flags == material->channel_flags)
      pass ("MATERIAL.channel_flags [BL] %u", channel_flags);
    else
      {
        fail ("MATERIAL.channel_flags [BL] %u != %u", material->channel_flags, channel_flags); error++;
      }
    channel_flags++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "channel_flags", &channel_flags) &&
        channel_flags == material->channel_flags)
      pass ("MATERIAL.channel_flags [BL] set+1 %u", channel_flags);
    else
      {
        fail ("MATERIAL.channel_flags [BL] set+1 %u != %u", material->channel_flags, channel_flags); error++;
      }
    material->channel_flags--;

  }
  {
    BITCODE_BD color_bleed_scale;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "color_bleed_scale", &color_bleed_scale, NULL) &&
        color_bleed_scale == material->color_bleed_scale)
      pass ("MATERIAL.color_bleed_scale [BD] %g", color_bleed_scale);
    else
      {
        fail ("MATERIAL.color_bleed_scale [BD] %g != %g", material->color_bleed_scale, color_bleed_scale); error++;
      }
    color_bleed_scale++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "color_bleed_scale", &color_bleed_scale) &&
        color_bleed_scale == material->color_bleed_scale)
      pass ("MATERIAL.color_bleed_scale [BD] set+1 %g", color_bleed_scale);
    else
      {
        fail ("MATERIAL.color_bleed_scale [BD] set+1 %g != %g", material->color_bleed_scale, color_bleed_scale); error++;
      }
    material->color_bleed_scale--;

  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "desc", &desc, NULL)
        && !memcmp(&desc, &material->desc, sizeof(material->desc)))
      pass ("MATERIAL.desc [T]");
    else
      {
        fail ("MATERIAL.desc [T]"); error++;
      }
  }
  {
    BITCODE_CMC diffuse_color;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffuse_color", &diffuse_color, NULL)
        && !memcmp(&diffuse_color, &material->diffuse_color, sizeof(material->diffuse_color)))
      pass ("MATERIAL.diffuse_color [CMC]");
    else
      {
        fail ("MATERIAL.diffuse_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD diffuse_color_factor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffuse_color_factor", &diffuse_color_factor, NULL) &&
        diffuse_color_factor == material->diffuse_color_factor)
      pass ("MATERIAL.diffuse_color_factor [BD] %g", diffuse_color_factor);
    else
      {
        fail ("MATERIAL.diffuse_color_factor [BD] %g != %g", material->diffuse_color_factor, diffuse_color_factor); error++;
      }
    diffuse_color_factor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "diffuse_color_factor", &diffuse_color_factor) &&
        diffuse_color_factor == material->diffuse_color_factor)
      pass ("MATERIAL.diffuse_color_factor [BD] set+1 %g", diffuse_color_factor);
    else
      {
        fail ("MATERIAL.diffuse_color_factor [BD] set+1 %g != %g", material->diffuse_color_factor, diffuse_color_factor); error++;
      }
    material->diffuse_color_factor--;

  }
  {
    BITCODE_BS diffuse_color_flag;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffuse_color_flag", &diffuse_color_flag, NULL) &&
        diffuse_color_flag == material->diffuse_color_flag)
      pass ("MATERIAL.diffuse_color_flag [BS] %hu", diffuse_color_flag);
    else
      {
        fail ("MATERIAL.diffuse_color_flag [BS] %hu != %hu", material->diffuse_color_flag, diffuse_color_flag); error++;
      }
    diffuse_color_flag++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "diffuse_color_flag", &diffuse_color_flag) &&
        diffuse_color_flag == material->diffuse_color_flag)
      pass ("MATERIAL.diffuse_color_flag [BS] set+1 %hu", diffuse_color_flag);
    else
      {
        fail ("MATERIAL.diffuse_color_flag [BS] set+1 %hu != %hu", material->diffuse_color_flag, diffuse_color_flag); error++;
      }
    material->diffuse_color_flag--;

  }
  {
    BITCODE_BS diffusemap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_autotransform", &diffusemap_autotransform, NULL) &&
        diffusemap_autotransform == material->diffusemap_autotransform)
      pass ("MATERIAL.diffusemap_autotransform [BS] %hu", diffusemap_autotransform);
    else
      {
        fail ("MATERIAL.diffusemap_autotransform [BS] %hu != %hu", material->diffusemap_autotransform, diffusemap_autotransform); error++;
      }
    diffusemap_autotransform++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "diffusemap_autotransform", &diffusemap_autotransform) &&
        diffusemap_autotransform == material->diffusemap_autotransform)
      pass ("MATERIAL.diffusemap_autotransform [BS] set+1 %hu", diffusemap_autotransform);
    else
      {
        fail ("MATERIAL.diffusemap_autotransform [BS] set+1 %hu != %hu", material->diffusemap_autotransform, diffusemap_autotransform); error++;
      }
    material->diffusemap_autotransform--;

  }
  {
    BITCODE_BD diffusemap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_blendfactor", &diffusemap_blendfactor, NULL) &&
        diffusemap_blendfactor == material->diffusemap_blendfactor)
      pass ("MATERIAL.diffusemap_blendfactor [BD] %g", diffusemap_blendfactor);
    else
      {
        fail ("MATERIAL.diffusemap_blendfactor [BD] %g != %g", material->diffusemap_blendfactor, diffusemap_blendfactor); error++;
      }
    diffusemap_blendfactor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "diffusemap_blendfactor", &diffusemap_blendfactor) &&
        diffusemap_blendfactor == material->diffusemap_blendfactor)
      pass ("MATERIAL.diffusemap_blendfactor [BD] set+1 %g", diffusemap_blendfactor);
    else
      {
        fail ("MATERIAL.diffusemap_blendfactor [BD] set+1 %g != %g", material->diffusemap_blendfactor, diffusemap_blendfactor); error++;
      }
    material->diffusemap_blendfactor--;

  }
  {
    BITCODE_T diffusemap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_filename", &diffusemap_filename, NULL)
        && !memcmp(&diffusemap_filename, &material->diffusemap_filename, sizeof(material->diffusemap_filename)))
      pass ("MATERIAL.diffusemap_filename [T]");
    else
      {
        fail ("MATERIAL.diffusemap_filename [T]"); error++;
      }
  }
  {
    BITCODE_BS diffusemap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_projection", &diffusemap_projection, NULL) &&
        diffusemap_projection == material->diffusemap_projection)
      pass ("MATERIAL.diffusemap_projection [BS] %hu", diffusemap_projection);
    else
      {
        fail ("MATERIAL.diffusemap_projection [BS] %hu != %hu", material->diffusemap_projection, diffusemap_projection); error++;
      }
    diffusemap_projection++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "diffusemap_projection", &diffusemap_projection) &&
        diffusemap_projection == material->diffusemap_projection)
      pass ("MATERIAL.diffusemap_projection [BS] set+1 %hu", diffusemap_projection);
    else
      {
        fail ("MATERIAL.diffusemap_projection [BS] set+1 %hu != %hu", material->diffusemap_projection, diffusemap_projection); error++;
      }
    material->diffusemap_projection--;

  }
  {
    BITCODE_BS diffusemap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_source", &diffusemap_source, NULL) &&
        diffusemap_source == material->diffusemap_source)
      pass ("MATERIAL.diffusemap_source [BS] %hu", diffusemap_source);
    else
      {
        fail ("MATERIAL.diffusemap_source [BS] %hu != %hu", material->diffusemap_source, diffusemap_source); error++;
      }
    diffusemap_source++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "diffusemap_source", &diffusemap_source) &&
        diffusemap_source == material->diffusemap_source)
      pass ("MATERIAL.diffusemap_source [BS] set+1 %hu", diffusemap_source);
    else
      {
        fail ("MATERIAL.diffusemap_source [BS] set+1 %hu != %hu", material->diffusemap_source, diffusemap_source); error++;
      }
    material->diffusemap_source--;

  }
  {
    BITCODE_BS diffusemap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_tiling", &diffusemap_tiling, NULL) &&
        diffusemap_tiling == material->diffusemap_tiling)
      pass ("MATERIAL.diffusemap_tiling [BS] %hu", diffusemap_tiling);
    else
      {
        fail ("MATERIAL.diffusemap_tiling [BS] %hu != %hu", material->diffusemap_tiling, diffusemap_tiling); error++;
      }
    diffusemap_tiling++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "diffusemap_tiling", &diffusemap_tiling) &&
        diffusemap_tiling == material->diffusemap_tiling)
      pass ("MATERIAL.diffusemap_tiling [BS] set+1 %hu", diffusemap_tiling);
    else
      {
        fail ("MATERIAL.diffusemap_tiling [BS] set+1 %hu != %hu", material->diffusemap_tiling, diffusemap_tiling); error++;
      }
    material->diffusemap_tiling--;

  }
  {
    BITCODE_BD* diffusemap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_transmatrix", &diffusemap_transmatrix, NULL)
        && !memcmp(&diffusemap_transmatrix, &material->diffusemap_transmatrix, sizeof(material->diffusemap_transmatrix)))
      pass ("MATERIAL.diffusemap_transmatrix [BD*]");
    else
      {
        fail ("MATERIAL.diffusemap_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BS final_gather_mode;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "final_gather_mode", &final_gather_mode, NULL) &&
        final_gather_mode == material->final_gather_mode)
      pass ("MATERIAL.final_gather_mode [BS] %hu", final_gather_mode);
    else
      {
        fail ("MATERIAL.final_gather_mode [BS] %hu != %hu", material->final_gather_mode, final_gather_mode); error++;
      }
    final_gather_mode++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "final_gather_mode", &final_gather_mode) &&
        final_gather_mode == material->final_gather_mode)
      pass ("MATERIAL.final_gather_mode [BS] set+1 %hu", final_gather_mode);
    else
      {
        fail ("MATERIAL.final_gather_mode [BS] set+1 %hu != %hu", material->final_gather_mode, final_gather_mode); error++;
      }
    material->final_gather_mode--;

  }
  {
    BITCODE_T genprocname;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocname", &genprocname, NULL)
        && !memcmp(&genprocname, &material->genprocname, sizeof(material->genprocname)))
      pass ("MATERIAL.genprocname [T]");
    else
      {
        fail ("MATERIAL.genprocname [T]"); error++;
      }
  }
  {
    BITCODE_B genproctableend;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genproctableend", &genproctableend, NULL) &&
        genproctableend == material->genproctableend)
      pass ("MATERIAL.genproctableend [B] " FORMAT_B "", genproctableend);
    else
      {
        fail ("MATERIAL.genproctableend [B] " FORMAT_B " != " FORMAT_B "", material->genproctableend, genproctableend); error++;
      }
    genproctableend++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "genproctableend", &genproctableend) &&
        genproctableend == material->genproctableend)
      pass ("MATERIAL.genproctableend [B] set+1 " FORMAT_B "", genproctableend);
    else
      {
        fail ("MATERIAL.genproctableend [B] set+1 " FORMAT_B " != " FORMAT_B "", material->genproctableend, genproctableend); error++;
      }
    material->genproctableend--;

  }
  {
    BITCODE_B genprocvalbool;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalbool", &genprocvalbool, NULL) &&
        genprocvalbool == material->genprocvalbool)
      pass ("MATERIAL.genprocvalbool [B] " FORMAT_B "", genprocvalbool);
    else
      {
        fail ("MATERIAL.genprocvalbool [B] " FORMAT_B " != " FORMAT_B "", material->genprocvalbool, genprocvalbool); error++;
      }
    genprocvalbool++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "genprocvalbool", &genprocvalbool) &&
        genprocvalbool == material->genprocvalbool)
      pass ("MATERIAL.genprocvalbool [B] set+1 " FORMAT_B "", genprocvalbool);
    else
      {
        fail ("MATERIAL.genprocvalbool [B] set+1 " FORMAT_B " != " FORMAT_B "", material->genprocvalbool, genprocvalbool); error++;
      }
    material->genprocvalbool--;

  }
  {
    BITCODE_CMC genprocvalcolorindex;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalcolorindex", &genprocvalcolorindex, NULL)
        && !memcmp(&genprocvalcolorindex, &material->genprocvalcolorindex, sizeof(material->genprocvalcolorindex)))
      pass ("MATERIAL.genprocvalcolorindex [CMC]");
    else
      {
        fail ("MATERIAL.genprocvalcolorindex [CMC]"); error++;
      }
  }
  {
    BITCODE_T genprocvalcolorname;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalcolorname", &genprocvalcolorname, NULL)
        && !memcmp(&genprocvalcolorname, &material->genprocvalcolorname, sizeof(material->genprocvalcolorname)))
      pass ("MATERIAL.genprocvalcolorname [T]");
    else
      {
        fail ("MATERIAL.genprocvalcolorname [T]"); error++;
      }
  }
  {
    BITCODE_BS genprocvalcolorrgb;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalcolorrgb", &genprocvalcolorrgb, NULL) &&
        genprocvalcolorrgb == material->genprocvalcolorrgb)
      pass ("MATERIAL.genprocvalcolorrgb [BS] %hu", genprocvalcolorrgb);
    else
      {
        fail ("MATERIAL.genprocvalcolorrgb [BS] %hu != %hu", material->genprocvalcolorrgb, genprocvalcolorrgb); error++;
      }
    genprocvalcolorrgb++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "genprocvalcolorrgb", &genprocvalcolorrgb) &&
        genprocvalcolorrgb == material->genprocvalcolorrgb)
      pass ("MATERIAL.genprocvalcolorrgb [BS] set+1 %hu", genprocvalcolorrgb);
    else
      {
        fail ("MATERIAL.genprocvalcolorrgb [BS] set+1 %hu != %hu", material->genprocvalcolorrgb, genprocvalcolorrgb); error++;
      }
    material->genprocvalcolorrgb--;

  }
  {
    BITCODE_BS genprocvalint;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalint", &genprocvalint, NULL) &&
        genprocvalint == material->genprocvalint)
      pass ("MATERIAL.genprocvalint [BS] %hu", genprocvalint);
    else
      {
        fail ("MATERIAL.genprocvalint [BS] %hu != %hu", material->genprocvalint, genprocvalint); error++;
      }
    genprocvalint++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "genprocvalint", &genprocvalint) &&
        genprocvalint == material->genprocvalint)
      pass ("MATERIAL.genprocvalint [BS] set+1 %hu", genprocvalint);
    else
      {
        fail ("MATERIAL.genprocvalint [BS] set+1 %hu != %hu", material->genprocvalint, genprocvalint); error++;
      }
    material->genprocvalint--;

  }
  {
    BITCODE_BD genprocvalreal;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalreal", &genprocvalreal, NULL) &&
        genprocvalreal == material->genprocvalreal)
      pass ("MATERIAL.genprocvalreal [BD] %g", genprocvalreal);
    else
      {
        fail ("MATERIAL.genprocvalreal [BD] %g != %g", material->genprocvalreal, genprocvalreal); error++;
      }
    genprocvalreal++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "genprocvalreal", &genprocvalreal) &&
        genprocvalreal == material->genprocvalreal)
      pass ("MATERIAL.genprocvalreal [BD] set+1 %g", genprocvalreal);
    else
      {
        fail ("MATERIAL.genprocvalreal [BD] set+1 %g != %g", material->genprocvalreal, genprocvalreal); error++;
      }
    material->genprocvalreal--;

  }
  {
    BITCODE_T genprocvaltext;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvaltext", &genprocvaltext, NULL)
        && !memcmp(&genprocvaltext, &material->genprocvaltext, sizeof(material->genprocvaltext)))
      pass ("MATERIAL.genprocvaltext [T]");
    else
      {
        fail ("MATERIAL.genprocvaltext [T]"); error++;
      }
  }
  {
    BITCODE_BS global_illumination_mode;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "global_illumination_mode", &global_illumination_mode, NULL) &&
        global_illumination_mode == material->global_illumination_mode)
      pass ("MATERIAL.global_illumination_mode [BS] %hu", global_illumination_mode);
    else
      {
        fail ("MATERIAL.global_illumination_mode [BS] %hu != %hu", material->global_illumination_mode, global_illumination_mode); error++;
      }
    global_illumination_mode++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "global_illumination_mode", &global_illumination_mode) &&
        global_illumination_mode == material->global_illumination_mode)
      pass ("MATERIAL.global_illumination_mode [BS] set+1 %hu", global_illumination_mode);
    else
      {
        fail ("MATERIAL.global_illumination_mode [BS] set+1 %hu != %hu", material->global_illumination_mode, global_illumination_mode); error++;
      }
    material->global_illumination_mode--;

  }
  {
    BITCODE_BL illumination_model;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "illumination_model", &illumination_model, NULL) &&
        illumination_model == material->illumination_model)
      pass ("MATERIAL.illumination_model [BL] %u", illumination_model);
    else
      {
        fail ("MATERIAL.illumination_model [BL] %u != %u", material->illumination_model, illumination_model); error++;
      }
    illumination_model++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "illumination_model", &illumination_model) &&
        illumination_model == material->illumination_model)
      pass ("MATERIAL.illumination_model [BL] set+1 %u", illumination_model);
    else
      {
        fail ("MATERIAL.illumination_model [BL] set+1 %u != %u", material->illumination_model, illumination_model); error++;
      }
    material->illumination_model--;

  }
  {
    BITCODE_BD indirect_dump_scale;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "indirect_dump_scale", &indirect_dump_scale, NULL) &&
        indirect_dump_scale == material->indirect_dump_scale)
      pass ("MATERIAL.indirect_dump_scale [BD] %g", indirect_dump_scale);
    else
      {
        fail ("MATERIAL.indirect_dump_scale [BD] %g != %g", material->indirect_dump_scale, indirect_dump_scale); error++;
      }
    indirect_dump_scale++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "indirect_dump_scale", &indirect_dump_scale) &&
        indirect_dump_scale == material->indirect_dump_scale)
      pass ("MATERIAL.indirect_dump_scale [BD] set+1 %g", indirect_dump_scale);
    else
      {
        fail ("MATERIAL.indirect_dump_scale [BD] set+1 %g != %g", material->indirect_dump_scale, indirect_dump_scale); error++;
      }
    material->indirect_dump_scale--;

  }
  {
    BITCODE_BD luminance;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "luminance", &luminance, NULL) &&
        luminance == material->luminance)
      pass ("MATERIAL.luminance [BD] %g", luminance);
    else
      {
        fail ("MATERIAL.luminance [BD] %g != %g", material->luminance, luminance); error++;
      }
    luminance++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "luminance", &luminance) &&
        luminance == material->luminance)
      pass ("MATERIAL.luminance [BD] set+1 %g", luminance);
    else
      {
        fail ("MATERIAL.luminance [BD] set+1 %g != %g", material->luminance, luminance); error++;
      }
    material->luminance--;

  }
  {
    BITCODE_BS luminance_mode;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "luminance_mode", &luminance_mode, NULL) &&
        luminance_mode == material->luminance_mode)
      pass ("MATERIAL.luminance_mode [BS] %hu", luminance_mode);
    else
      {
        fail ("MATERIAL.luminance_mode [BS] %hu != %hu", material->luminance_mode, luminance_mode); error++;
      }
    luminance_mode++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "luminance_mode", &luminance_mode) &&
        luminance_mode == material->luminance_mode)
      pass ("MATERIAL.luminance_mode [BS] set+1 %hu", luminance_mode);
    else
      {
        fail ("MATERIAL.luminance_mode [BS] set+1 %hu != %hu", material->luminance_mode, luminance_mode); error++;
      }
    material->luminance_mode--;

  }
  {
    BITCODE_BS map_utile;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "map_utile", &map_utile, NULL) &&
        map_utile == material->map_utile)
      pass ("MATERIAL.map_utile [BS] %hu", map_utile);
    else
      {
        fail ("MATERIAL.map_utile [BS] %hu != %hu", material->map_utile, map_utile); error++;
      }
    map_utile++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "map_utile", &map_utile) &&
        map_utile == material->map_utile)
      pass ("MATERIAL.map_utile [BS] set+1 %hu", map_utile);
    else
      {
        fail ("MATERIAL.map_utile [BS] set+1 %hu != %hu", material->map_utile, map_utile); error++;
      }
    material->map_utile--;

  }
  {
    BITCODE_B materials_anonymous;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "materials_anonymous", &materials_anonymous, NULL) &&
        materials_anonymous == material->materials_anonymous)
      pass ("MATERIAL.materials_anonymous [B] " FORMAT_B "", materials_anonymous);
    else
      {
        fail ("MATERIAL.materials_anonymous [B] " FORMAT_B " != " FORMAT_B "", material->materials_anonymous, materials_anonymous); error++;
      }
    materials_anonymous++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "materials_anonymous", &materials_anonymous) &&
        materials_anonymous == material->materials_anonymous)
      pass ("MATERIAL.materials_anonymous [B] set+1 " FORMAT_B "", materials_anonymous);
    else
      {
        fail ("MATERIAL.materials_anonymous [B] set+1 " FORMAT_B " != " FORMAT_B "", material->materials_anonymous, materials_anonymous); error++;
      }
    material->materials_anonymous--;

  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "name", &name, NULL)
        && !memcmp(&name, &material->name, sizeof(material->name)))
      pass ("MATERIAL.name [T]");
    else
      {
        fail ("MATERIAL.name [T]"); error++;
      }
  }
  {
    BITCODE_BS normalmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_autotransform", &normalmap_autotransform, NULL) &&
        normalmap_autotransform == material->normalmap_autotransform)
      pass ("MATERIAL.normalmap_autotransform [BS] %hu", normalmap_autotransform);
    else
      {
        fail ("MATERIAL.normalmap_autotransform [BS] %hu != %hu", material->normalmap_autotransform, normalmap_autotransform); error++;
      }
    normalmap_autotransform++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "normalmap_autotransform", &normalmap_autotransform) &&
        normalmap_autotransform == material->normalmap_autotransform)
      pass ("MATERIAL.normalmap_autotransform [BS] set+1 %hu", normalmap_autotransform);
    else
      {
        fail ("MATERIAL.normalmap_autotransform [BS] set+1 %hu != %hu", material->normalmap_autotransform, normalmap_autotransform); error++;
      }
    material->normalmap_autotransform--;

  }
  {
    BITCODE_BD normalmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_blendfactor", &normalmap_blendfactor, NULL) &&
        normalmap_blendfactor == material->normalmap_blendfactor)
      pass ("MATERIAL.normalmap_blendfactor [BD] %g", normalmap_blendfactor);
    else
      {
        fail ("MATERIAL.normalmap_blendfactor [BD] %g != %g", material->normalmap_blendfactor, normalmap_blendfactor); error++;
      }
    normalmap_blendfactor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "normalmap_blendfactor", &normalmap_blendfactor) &&
        normalmap_blendfactor == material->normalmap_blendfactor)
      pass ("MATERIAL.normalmap_blendfactor [BD] set+1 %g", normalmap_blendfactor);
    else
      {
        fail ("MATERIAL.normalmap_blendfactor [BD] set+1 %g != %g", material->normalmap_blendfactor, normalmap_blendfactor); error++;
      }
    material->normalmap_blendfactor--;

  }
  {
    BITCODE_T normalmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_filename", &normalmap_filename, NULL)
        && !memcmp(&normalmap_filename, &material->normalmap_filename, sizeof(material->normalmap_filename)))
      pass ("MATERIAL.normalmap_filename [T]");
    else
      {
        fail ("MATERIAL.normalmap_filename [T]"); error++;
      }
  }
  {
    BITCODE_BS normalmap_method;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_method", &normalmap_method, NULL) &&
        normalmap_method == material->normalmap_method)
      pass ("MATERIAL.normalmap_method [BS] %hu", normalmap_method);
    else
      {
        fail ("MATERIAL.normalmap_method [BS] %hu != %hu", material->normalmap_method, normalmap_method); error++;
      }
    normalmap_method++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "normalmap_method", &normalmap_method) &&
        normalmap_method == material->normalmap_method)
      pass ("MATERIAL.normalmap_method [BS] set+1 %hu", normalmap_method);
    else
      {
        fail ("MATERIAL.normalmap_method [BS] set+1 %hu != %hu", material->normalmap_method, normalmap_method); error++;
      }
    material->normalmap_method--;

  }
  {
    BITCODE_BS normalmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_projection", &normalmap_projection, NULL) &&
        normalmap_projection == material->normalmap_projection)
      pass ("MATERIAL.normalmap_projection [BS] %hu", normalmap_projection);
    else
      {
        fail ("MATERIAL.normalmap_projection [BS] %hu != %hu", material->normalmap_projection, normalmap_projection); error++;
      }
    normalmap_projection++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "normalmap_projection", &normalmap_projection) &&
        normalmap_projection == material->normalmap_projection)
      pass ("MATERIAL.normalmap_projection [BS] set+1 %hu", normalmap_projection);
    else
      {
        fail ("MATERIAL.normalmap_projection [BS] set+1 %hu != %hu", material->normalmap_projection, normalmap_projection); error++;
      }
    material->normalmap_projection--;

  }
  {
    BITCODE_BS normalmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_source", &normalmap_source, NULL) &&
        normalmap_source == material->normalmap_source)
      pass ("MATERIAL.normalmap_source [BS] %hu", normalmap_source);
    else
      {
        fail ("MATERIAL.normalmap_source [BS] %hu != %hu", material->normalmap_source, normalmap_source); error++;
      }
    normalmap_source++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "normalmap_source", &normalmap_source) &&
        normalmap_source == material->normalmap_source)
      pass ("MATERIAL.normalmap_source [BS] set+1 %hu", normalmap_source);
    else
      {
        fail ("MATERIAL.normalmap_source [BS] set+1 %hu != %hu", material->normalmap_source, normalmap_source); error++;
      }
    material->normalmap_source--;

  }
  {
    BITCODE_BD normalmap_strength;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_strength", &normalmap_strength, NULL) &&
        normalmap_strength == material->normalmap_strength)
      pass ("MATERIAL.normalmap_strength [BD] %g", normalmap_strength);
    else
      {
        fail ("MATERIAL.normalmap_strength [BD] %g != %g", material->normalmap_strength, normalmap_strength); error++;
      }
    normalmap_strength++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "normalmap_strength", &normalmap_strength) &&
        normalmap_strength == material->normalmap_strength)
      pass ("MATERIAL.normalmap_strength [BD] set+1 %g", normalmap_strength);
    else
      {
        fail ("MATERIAL.normalmap_strength [BD] set+1 %g != %g", material->normalmap_strength, normalmap_strength); error++;
      }
    material->normalmap_strength--;

  }
  {
    BITCODE_BS normalmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_tiling", &normalmap_tiling, NULL) &&
        normalmap_tiling == material->normalmap_tiling)
      pass ("MATERIAL.normalmap_tiling [BS] %hu", normalmap_tiling);
    else
      {
        fail ("MATERIAL.normalmap_tiling [BS] %hu != %hu", material->normalmap_tiling, normalmap_tiling); error++;
      }
    normalmap_tiling++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "normalmap_tiling", &normalmap_tiling) &&
        normalmap_tiling == material->normalmap_tiling)
      pass ("MATERIAL.normalmap_tiling [BS] set+1 %hu", normalmap_tiling);
    else
      {
        fail ("MATERIAL.normalmap_tiling [BS] set+1 %hu != %hu", material->normalmap_tiling, normalmap_tiling); error++;
      }
    material->normalmap_tiling--;

  }
  {
    BITCODE_BD* normalmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_transmatrix", &normalmap_transmatrix, NULL)
        && !memcmp(&normalmap_transmatrix, &material->normalmap_transmatrix, sizeof(material->normalmap_transmatrix)))
      pass ("MATERIAL.normalmap_transmatrix [BD*]");
    else
      {
        fail ("MATERIAL.normalmap_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BD opacity_percent;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacity_percent", &opacity_percent, NULL) &&
        opacity_percent == material->opacity_percent)
      pass ("MATERIAL.opacity_percent [BD] %g", opacity_percent);
    else
      {
        fail ("MATERIAL.opacity_percent [BD] %g != %g", material->opacity_percent, opacity_percent); error++;
      }
    opacity_percent++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "opacity_percent", &opacity_percent) &&
        opacity_percent == material->opacity_percent)
      pass ("MATERIAL.opacity_percent [BD] set+1 %g", opacity_percent);
    else
      {
        fail ("MATERIAL.opacity_percent [BD] set+1 %g != %g", material->opacity_percent, opacity_percent); error++;
      }
    material->opacity_percent--;

  }
  {
    BITCODE_BS opacitymap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_autotransform", &opacitymap_autotransform, NULL) &&
        opacitymap_autotransform == material->opacitymap_autotransform)
      pass ("MATERIAL.opacitymap_autotransform [BS] %hu", opacitymap_autotransform);
    else
      {
        fail ("MATERIAL.opacitymap_autotransform [BS] %hu != %hu", material->opacitymap_autotransform, opacitymap_autotransform); error++;
      }
    opacitymap_autotransform++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "opacitymap_autotransform", &opacitymap_autotransform) &&
        opacitymap_autotransform == material->opacitymap_autotransform)
      pass ("MATERIAL.opacitymap_autotransform [BS] set+1 %hu", opacitymap_autotransform);
    else
      {
        fail ("MATERIAL.opacitymap_autotransform [BS] set+1 %hu != %hu", material->opacitymap_autotransform, opacitymap_autotransform); error++;
      }
    material->opacitymap_autotransform--;

  }
  {
    BITCODE_BD opacitymap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_blendfactor", &opacitymap_blendfactor, NULL) &&
        opacitymap_blendfactor == material->opacitymap_blendfactor)
      pass ("MATERIAL.opacitymap_blendfactor [BD] %g", opacitymap_blendfactor);
    else
      {
        fail ("MATERIAL.opacitymap_blendfactor [BD] %g != %g", material->opacitymap_blendfactor, opacitymap_blendfactor); error++;
      }
    opacitymap_blendfactor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "opacitymap_blendfactor", &opacitymap_blendfactor) &&
        opacitymap_blendfactor == material->opacitymap_blendfactor)
      pass ("MATERIAL.opacitymap_blendfactor [BD] set+1 %g", opacitymap_blendfactor);
    else
      {
        fail ("MATERIAL.opacitymap_blendfactor [BD] set+1 %g != %g", material->opacitymap_blendfactor, opacitymap_blendfactor); error++;
      }
    material->opacitymap_blendfactor--;

  }
  {
    BITCODE_T opacitymap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_filename", &opacitymap_filename, NULL)
        && !memcmp(&opacitymap_filename, &material->opacitymap_filename, sizeof(material->opacitymap_filename)))
      pass ("MATERIAL.opacitymap_filename [T]");
    else
      {
        fail ("MATERIAL.opacitymap_filename [T]"); error++;
      }
  }
  {
    BITCODE_BS opacitymap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_projection", &opacitymap_projection, NULL) &&
        opacitymap_projection == material->opacitymap_projection)
      pass ("MATERIAL.opacitymap_projection [BS] %hu", opacitymap_projection);
    else
      {
        fail ("MATERIAL.opacitymap_projection [BS] %hu != %hu", material->opacitymap_projection, opacitymap_projection); error++;
      }
    opacitymap_projection++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "opacitymap_projection", &opacitymap_projection) &&
        opacitymap_projection == material->opacitymap_projection)
      pass ("MATERIAL.opacitymap_projection [BS] set+1 %hu", opacitymap_projection);
    else
      {
        fail ("MATERIAL.opacitymap_projection [BS] set+1 %hu != %hu", material->opacitymap_projection, opacitymap_projection); error++;
      }
    material->opacitymap_projection--;

  }
  {
    BITCODE_BS opacitymap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_source", &opacitymap_source, NULL) &&
        opacitymap_source == material->opacitymap_source)
      pass ("MATERIAL.opacitymap_source [BS] %hu", opacitymap_source);
    else
      {
        fail ("MATERIAL.opacitymap_source [BS] %hu != %hu", material->opacitymap_source, opacitymap_source); error++;
      }
    opacitymap_source++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "opacitymap_source", &opacitymap_source) &&
        opacitymap_source == material->opacitymap_source)
      pass ("MATERIAL.opacitymap_source [BS] set+1 %hu", opacitymap_source);
    else
      {
        fail ("MATERIAL.opacitymap_source [BS] set+1 %hu != %hu", material->opacitymap_source, opacitymap_source); error++;
      }
    material->opacitymap_source--;

  }
  {
    BITCODE_BS opacitymap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_tiling", &opacitymap_tiling, NULL) &&
        opacitymap_tiling == material->opacitymap_tiling)
      pass ("MATERIAL.opacitymap_tiling [BS] %hu", opacitymap_tiling);
    else
      {
        fail ("MATERIAL.opacitymap_tiling [BS] %hu != %hu", material->opacitymap_tiling, opacitymap_tiling); error++;
      }
    opacitymap_tiling++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "opacitymap_tiling", &opacitymap_tiling) &&
        opacitymap_tiling == material->opacitymap_tiling)
      pass ("MATERIAL.opacitymap_tiling [BS] set+1 %hu", opacitymap_tiling);
    else
      {
        fail ("MATERIAL.opacitymap_tiling [BS] set+1 %hu != %hu", material->opacitymap_tiling, opacitymap_tiling); error++;
      }
    material->opacitymap_tiling--;

  }
  {
    BITCODE_BD* opacitymap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_transmatrix", &opacitymap_transmatrix, NULL)
        && !memcmp(&opacitymap_transmatrix, &material->opacitymap_transmatrix, sizeof(material->opacitymap_transmatrix)))
      pass ("MATERIAL.opacitymap_transmatrix [BD*]");
    else
      {
        fail ("MATERIAL.opacitymap_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &material->ownerhandle, sizeof(material->ownerhandle)))
      pass ("MATERIAL.ownerhandle [H]");
    else
      {
        fail ("MATERIAL.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "parent", &parent, NULL)
        && !memcmp(&parent, &material->parent, sizeof(material->parent)))
      pass ("MATERIAL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("MATERIAL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BD reflectance_scale;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectance_scale", &reflectance_scale, NULL) &&
        reflectance_scale == material->reflectance_scale)
      pass ("MATERIAL.reflectance_scale [BD] %g", reflectance_scale);
    else
      {
        fail ("MATERIAL.reflectance_scale [BD] %g != %g", material->reflectance_scale, reflectance_scale); error++;
      }
    reflectance_scale++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "reflectance_scale", &reflectance_scale) &&
        reflectance_scale == material->reflectance_scale)
      pass ("MATERIAL.reflectance_scale [BD] set+1 %g", reflectance_scale);
    else
      {
        fail ("MATERIAL.reflectance_scale [BD] set+1 %g != %g", material->reflectance_scale, reflectance_scale); error++;
      }
    material->reflectance_scale--;

  }
  {
    BITCODE_BS reflectionmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_autotransform", &reflectionmap_autotransform, NULL) &&
        reflectionmap_autotransform == material->reflectionmap_autotransform)
      pass ("MATERIAL.reflectionmap_autotransform [BS] %hu", reflectionmap_autotransform);
    else
      {
        fail ("MATERIAL.reflectionmap_autotransform [BS] %hu != %hu", material->reflectionmap_autotransform, reflectionmap_autotransform); error++;
      }
    reflectionmap_autotransform++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "reflectionmap_autotransform", &reflectionmap_autotransform) &&
        reflectionmap_autotransform == material->reflectionmap_autotransform)
      pass ("MATERIAL.reflectionmap_autotransform [BS] set+1 %hu", reflectionmap_autotransform);
    else
      {
        fail ("MATERIAL.reflectionmap_autotransform [BS] set+1 %hu != %hu", material->reflectionmap_autotransform, reflectionmap_autotransform); error++;
      }
    material->reflectionmap_autotransform--;

  }
  {
    BITCODE_BD reflectionmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_blendfactor", &reflectionmap_blendfactor, NULL) &&
        reflectionmap_blendfactor == material->reflectionmap_blendfactor)
      pass ("MATERIAL.reflectionmap_blendfactor [BD] %g", reflectionmap_blendfactor);
    else
      {
        fail ("MATERIAL.reflectionmap_blendfactor [BD] %g != %g", material->reflectionmap_blendfactor, reflectionmap_blendfactor); error++;
      }
    reflectionmap_blendfactor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "reflectionmap_blendfactor", &reflectionmap_blendfactor) &&
        reflectionmap_blendfactor == material->reflectionmap_blendfactor)
      pass ("MATERIAL.reflectionmap_blendfactor [BD] set+1 %g", reflectionmap_blendfactor);
    else
      {
        fail ("MATERIAL.reflectionmap_blendfactor [BD] set+1 %g != %g", material->reflectionmap_blendfactor, reflectionmap_blendfactor); error++;
      }
    material->reflectionmap_blendfactor--;

  }
  {
    BITCODE_T reflectionmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_filename", &reflectionmap_filename, NULL)
        && !memcmp(&reflectionmap_filename, &material->reflectionmap_filename, sizeof(material->reflectionmap_filename)))
      pass ("MATERIAL.reflectionmap_filename [T]");
    else
      {
        fail ("MATERIAL.reflectionmap_filename [T]"); error++;
      }
  }
  {
    BITCODE_BS reflectionmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_projection", &reflectionmap_projection, NULL) &&
        reflectionmap_projection == material->reflectionmap_projection)
      pass ("MATERIAL.reflectionmap_projection [BS] %hu", reflectionmap_projection);
    else
      {
        fail ("MATERIAL.reflectionmap_projection [BS] %hu != %hu", material->reflectionmap_projection, reflectionmap_projection); error++;
      }
    reflectionmap_projection++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "reflectionmap_projection", &reflectionmap_projection) &&
        reflectionmap_projection == material->reflectionmap_projection)
      pass ("MATERIAL.reflectionmap_projection [BS] set+1 %hu", reflectionmap_projection);
    else
      {
        fail ("MATERIAL.reflectionmap_projection [BS] set+1 %hu != %hu", material->reflectionmap_projection, reflectionmap_projection); error++;
      }
    material->reflectionmap_projection--;

  }
  {
    BITCODE_BS reflectionmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_source", &reflectionmap_source, NULL) &&
        reflectionmap_source == material->reflectionmap_source)
      pass ("MATERIAL.reflectionmap_source [BS] %hu", reflectionmap_source);
    else
      {
        fail ("MATERIAL.reflectionmap_source [BS] %hu != %hu", material->reflectionmap_source, reflectionmap_source); error++;
      }
    reflectionmap_source++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "reflectionmap_source", &reflectionmap_source) &&
        reflectionmap_source == material->reflectionmap_source)
      pass ("MATERIAL.reflectionmap_source [BS] set+1 %hu", reflectionmap_source);
    else
      {
        fail ("MATERIAL.reflectionmap_source [BS] set+1 %hu != %hu", material->reflectionmap_source, reflectionmap_source); error++;
      }
    material->reflectionmap_source--;

  }
  {
    BITCODE_BS reflectionmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_tiling", &reflectionmap_tiling, NULL) &&
        reflectionmap_tiling == material->reflectionmap_tiling)
      pass ("MATERIAL.reflectionmap_tiling [BS] %hu", reflectionmap_tiling);
    else
      {
        fail ("MATERIAL.reflectionmap_tiling [BS] %hu != %hu", material->reflectionmap_tiling, reflectionmap_tiling); error++;
      }
    reflectionmap_tiling++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "reflectionmap_tiling", &reflectionmap_tiling) &&
        reflectionmap_tiling == material->reflectionmap_tiling)
      pass ("MATERIAL.reflectionmap_tiling [BS] set+1 %hu", reflectionmap_tiling);
    else
      {
        fail ("MATERIAL.reflectionmap_tiling [BS] set+1 %hu != %hu", material->reflectionmap_tiling, reflectionmap_tiling); error++;
      }
    material->reflectionmap_tiling--;

  }
  {
    BITCODE_BD* reflectionmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_transmatrix", &reflectionmap_transmatrix, NULL)
        && !memcmp(&reflectionmap_transmatrix, &material->reflectionmap_transmatrix, sizeof(material->reflectionmap_transmatrix)))
      pass ("MATERIAL.reflectionmap_transmatrix [BD*]");
    else
      {
        fail ("MATERIAL.reflectionmap_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BD reflectivity;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectivity", &reflectivity, NULL) &&
        reflectivity == material->reflectivity)
      pass ("MATERIAL.reflectivity [BD] %g", reflectivity);
    else
      {
        fail ("MATERIAL.reflectivity [BD] %g != %g", material->reflectivity, reflectivity); error++;
      }
    reflectivity++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "reflectivity", &reflectivity) &&
        reflectivity == material->reflectivity)
      pass ("MATERIAL.reflectivity [BD] set+1 %g", reflectivity);
    else
      {
        fail ("MATERIAL.reflectivity [BD] set+1 %g != %g", material->reflectivity, reflectivity); error++;
      }
    material->reflectivity--;

  }
  {
    BITCODE_BD refraction_index;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refraction_index", &refraction_index, NULL) &&
        refraction_index == material->refraction_index)
      pass ("MATERIAL.refraction_index [BD] %g", refraction_index);
    else
      {
        fail ("MATERIAL.refraction_index [BD] %g != %g", material->refraction_index, refraction_index); error++;
      }
    refraction_index++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "refraction_index", &refraction_index) &&
        refraction_index == material->refraction_index)
      pass ("MATERIAL.refraction_index [BD] set+1 %g", refraction_index);
    else
      {
        fail ("MATERIAL.refraction_index [BD] set+1 %g != %g", material->refraction_index, refraction_index); error++;
      }
    material->refraction_index--;

  }
  {
    BITCODE_BS refractionmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_autotransform", &refractionmap_autotransform, NULL) &&
        refractionmap_autotransform == material->refractionmap_autotransform)
      pass ("MATERIAL.refractionmap_autotransform [BS] %hu", refractionmap_autotransform);
    else
      {
        fail ("MATERIAL.refractionmap_autotransform [BS] %hu != %hu", material->refractionmap_autotransform, refractionmap_autotransform); error++;
      }
    refractionmap_autotransform++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "refractionmap_autotransform", &refractionmap_autotransform) &&
        refractionmap_autotransform == material->refractionmap_autotransform)
      pass ("MATERIAL.refractionmap_autotransform [BS] set+1 %hu", refractionmap_autotransform);
    else
      {
        fail ("MATERIAL.refractionmap_autotransform [BS] set+1 %hu != %hu", material->refractionmap_autotransform, refractionmap_autotransform); error++;
      }
    material->refractionmap_autotransform--;

  }
  {
    BITCODE_BD refractionmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_blendfactor", &refractionmap_blendfactor, NULL) &&
        refractionmap_blendfactor == material->refractionmap_blendfactor)
      pass ("MATERIAL.refractionmap_blendfactor [BD] %g", refractionmap_blendfactor);
    else
      {
        fail ("MATERIAL.refractionmap_blendfactor [BD] %g != %g", material->refractionmap_blendfactor, refractionmap_blendfactor); error++;
      }
    refractionmap_blendfactor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "refractionmap_blendfactor", &refractionmap_blendfactor) &&
        refractionmap_blendfactor == material->refractionmap_blendfactor)
      pass ("MATERIAL.refractionmap_blendfactor [BD] set+1 %g", refractionmap_blendfactor);
    else
      {
        fail ("MATERIAL.refractionmap_blendfactor [BD] set+1 %g != %g", material->refractionmap_blendfactor, refractionmap_blendfactor); error++;
      }
    material->refractionmap_blendfactor--;

  }
  {
    BITCODE_T refractionmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_filename", &refractionmap_filename, NULL)
        && !memcmp(&refractionmap_filename, &material->refractionmap_filename, sizeof(material->refractionmap_filename)))
      pass ("MATERIAL.refractionmap_filename [T]");
    else
      {
        fail ("MATERIAL.refractionmap_filename [T]"); error++;
      }
  }
  {
    BITCODE_BS refractionmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_projection", &refractionmap_projection, NULL) &&
        refractionmap_projection == material->refractionmap_projection)
      pass ("MATERIAL.refractionmap_projection [BS] %hu", refractionmap_projection);
    else
      {
        fail ("MATERIAL.refractionmap_projection [BS] %hu != %hu", material->refractionmap_projection, refractionmap_projection); error++;
      }
    refractionmap_projection++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "refractionmap_projection", &refractionmap_projection) &&
        refractionmap_projection == material->refractionmap_projection)
      pass ("MATERIAL.refractionmap_projection [BS] set+1 %hu", refractionmap_projection);
    else
      {
        fail ("MATERIAL.refractionmap_projection [BS] set+1 %hu != %hu", material->refractionmap_projection, refractionmap_projection); error++;
      }
    material->refractionmap_projection--;

  }
  {
    BITCODE_BS refractionmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_source", &refractionmap_source, NULL) &&
        refractionmap_source == material->refractionmap_source)
      pass ("MATERIAL.refractionmap_source [BS] %hu", refractionmap_source);
    else
      {
        fail ("MATERIAL.refractionmap_source [BS] %hu != %hu", material->refractionmap_source, refractionmap_source); error++;
      }
    refractionmap_source++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "refractionmap_source", &refractionmap_source) &&
        refractionmap_source == material->refractionmap_source)
      pass ("MATERIAL.refractionmap_source [BS] set+1 %hu", refractionmap_source);
    else
      {
        fail ("MATERIAL.refractionmap_source [BS] set+1 %hu != %hu", material->refractionmap_source, refractionmap_source); error++;
      }
    material->refractionmap_source--;

  }
  {
    BITCODE_BS refractionmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_tiling", &refractionmap_tiling, NULL) &&
        refractionmap_tiling == material->refractionmap_tiling)
      pass ("MATERIAL.refractionmap_tiling [BS] %hu", refractionmap_tiling);
    else
      {
        fail ("MATERIAL.refractionmap_tiling [BS] %hu != %hu", material->refractionmap_tiling, refractionmap_tiling); error++;
      }
    refractionmap_tiling++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "refractionmap_tiling", &refractionmap_tiling) &&
        refractionmap_tiling == material->refractionmap_tiling)
      pass ("MATERIAL.refractionmap_tiling [BS] set+1 %hu", refractionmap_tiling);
    else
      {
        fail ("MATERIAL.refractionmap_tiling [BS] set+1 %hu != %hu", material->refractionmap_tiling, refractionmap_tiling); error++;
      }
    material->refractionmap_tiling--;

  }
  {
    BITCODE_BD* refractionmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_transmatrix", &refractionmap_transmatrix, NULL)
        && !memcmp(&refractionmap_transmatrix, &material->refractionmap_transmatrix, sizeof(material->refractionmap_transmatrix)))
      pass ("MATERIAL.refractionmap_transmatrix [BD*]");
    else
      {
        fail ("MATERIAL.refractionmap_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BL self_illumination;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "self_illumination", &self_illumination, NULL) &&
        self_illumination == material->self_illumination)
      pass ("MATERIAL.self_illumination [BL] %u", self_illumination);
    else
      {
        fail ("MATERIAL.self_illumination [BL] %u != %u", material->self_illumination, self_illumination); error++;
      }
    self_illumination++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "self_illumination", &self_illumination) &&
        self_illumination == material->self_illumination)
      pass ("MATERIAL.self_illumination [BL] set+1 %u", self_illumination);
    else
      {
        fail ("MATERIAL.self_illumination [BL] set+1 %u != %u", material->self_illumination, self_illumination); error++;
      }
    material->self_illumination--;

  }
  {
    BITCODE_CMC specular_color;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specular_color", &specular_color, NULL)
        && !memcmp(&specular_color, &material->specular_color, sizeof(material->specular_color)))
      pass ("MATERIAL.specular_color [CMC]");
    else
      {
        fail ("MATERIAL.specular_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD specular_color_factor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specular_color_factor", &specular_color_factor, NULL) &&
        specular_color_factor == material->specular_color_factor)
      pass ("MATERIAL.specular_color_factor [BD] %g", specular_color_factor);
    else
      {
        fail ("MATERIAL.specular_color_factor [BD] %g != %g", material->specular_color_factor, specular_color_factor); error++;
      }
    specular_color_factor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "specular_color_factor", &specular_color_factor) &&
        specular_color_factor == material->specular_color_factor)
      pass ("MATERIAL.specular_color_factor [BD] set+1 %g", specular_color_factor);
    else
      {
        fail ("MATERIAL.specular_color_factor [BD] set+1 %g != %g", material->specular_color_factor, specular_color_factor); error++;
      }
    material->specular_color_factor--;

  }
  {
    BITCODE_BS specular_color_flag;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specular_color_flag", &specular_color_flag, NULL) &&
        specular_color_flag == material->specular_color_flag)
      pass ("MATERIAL.specular_color_flag [BS] %hu", specular_color_flag);
    else
      {
        fail ("MATERIAL.specular_color_flag [BS] %hu != %hu", material->specular_color_flag, specular_color_flag); error++;
      }
    specular_color_flag++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "specular_color_flag", &specular_color_flag) &&
        specular_color_flag == material->specular_color_flag)
      pass ("MATERIAL.specular_color_flag [BS] set+1 %hu", specular_color_flag);
    else
      {
        fail ("MATERIAL.specular_color_flag [BS] set+1 %hu != %hu", material->specular_color_flag, specular_color_flag); error++;
      }
    material->specular_color_flag--;

  }
  {
    BITCODE_BD specular_gloss_factor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specular_gloss_factor", &specular_gloss_factor, NULL) &&
        specular_gloss_factor == material->specular_gloss_factor)
      pass ("MATERIAL.specular_gloss_factor [BD] %g", specular_gloss_factor);
    else
      {
        fail ("MATERIAL.specular_gloss_factor [BD] %g != %g", material->specular_gloss_factor, specular_gloss_factor); error++;
      }
    specular_gloss_factor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "specular_gloss_factor", &specular_gloss_factor) &&
        specular_gloss_factor == material->specular_gloss_factor)
      pass ("MATERIAL.specular_gloss_factor [BD] set+1 %g", specular_gloss_factor);
    else
      {
        fail ("MATERIAL.specular_gloss_factor [BD] set+1 %g != %g", material->specular_gloss_factor, specular_gloss_factor); error++;
      }
    material->specular_gloss_factor--;

  }
  {
    BITCODE_BS specularmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_autotransform", &specularmap_autotransform, NULL) &&
        specularmap_autotransform == material->specularmap_autotransform)
      pass ("MATERIAL.specularmap_autotransform [BS] %hu", specularmap_autotransform);
    else
      {
        fail ("MATERIAL.specularmap_autotransform [BS] %hu != %hu", material->specularmap_autotransform, specularmap_autotransform); error++;
      }
    specularmap_autotransform++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "specularmap_autotransform", &specularmap_autotransform) &&
        specularmap_autotransform == material->specularmap_autotransform)
      pass ("MATERIAL.specularmap_autotransform [BS] set+1 %hu", specularmap_autotransform);
    else
      {
        fail ("MATERIAL.specularmap_autotransform [BS] set+1 %hu != %hu", material->specularmap_autotransform, specularmap_autotransform); error++;
      }
    material->specularmap_autotransform--;

  }
  {
    BITCODE_BD specularmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_blendfactor", &specularmap_blendfactor, NULL) &&
        specularmap_blendfactor == material->specularmap_blendfactor)
      pass ("MATERIAL.specularmap_blendfactor [BD] %g", specularmap_blendfactor);
    else
      {
        fail ("MATERIAL.specularmap_blendfactor [BD] %g != %g", material->specularmap_blendfactor, specularmap_blendfactor); error++;
      }
    specularmap_blendfactor++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "specularmap_blendfactor", &specularmap_blendfactor) &&
        specularmap_blendfactor == material->specularmap_blendfactor)
      pass ("MATERIAL.specularmap_blendfactor [BD] set+1 %g", specularmap_blendfactor);
    else
      {
        fail ("MATERIAL.specularmap_blendfactor [BD] set+1 %g != %g", material->specularmap_blendfactor, specularmap_blendfactor); error++;
      }
    material->specularmap_blendfactor--;

  }
  {
    BITCODE_T specularmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_filename", &specularmap_filename, NULL)
        && !memcmp(&specularmap_filename, &material->specularmap_filename, sizeof(material->specularmap_filename)))
      pass ("MATERIAL.specularmap_filename [T]");
    else
      {
        fail ("MATERIAL.specularmap_filename [T]"); error++;
      }
  }
  {
    BITCODE_BS specularmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_projection", &specularmap_projection, NULL) &&
        specularmap_projection == material->specularmap_projection)
      pass ("MATERIAL.specularmap_projection [BS] %hu", specularmap_projection);
    else
      {
        fail ("MATERIAL.specularmap_projection [BS] %hu != %hu", material->specularmap_projection, specularmap_projection); error++;
      }
    specularmap_projection++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "specularmap_projection", &specularmap_projection) &&
        specularmap_projection == material->specularmap_projection)
      pass ("MATERIAL.specularmap_projection [BS] set+1 %hu", specularmap_projection);
    else
      {
        fail ("MATERIAL.specularmap_projection [BS] set+1 %hu != %hu", material->specularmap_projection, specularmap_projection); error++;
      }
    material->specularmap_projection--;

  }
  {
    BITCODE_BS specularmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_source", &specularmap_source, NULL) &&
        specularmap_source == material->specularmap_source)
      pass ("MATERIAL.specularmap_source [BS] %hu", specularmap_source);
    else
      {
        fail ("MATERIAL.specularmap_source [BS] %hu != %hu", material->specularmap_source, specularmap_source); error++;
      }
    specularmap_source++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "specularmap_source", &specularmap_source) &&
        specularmap_source == material->specularmap_source)
      pass ("MATERIAL.specularmap_source [BS] set+1 %hu", specularmap_source);
    else
      {
        fail ("MATERIAL.specularmap_source [BS] set+1 %hu != %hu", material->specularmap_source, specularmap_source); error++;
      }
    material->specularmap_source--;

  }
  {
    BITCODE_BS specularmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_tiling", &specularmap_tiling, NULL) &&
        specularmap_tiling == material->specularmap_tiling)
      pass ("MATERIAL.specularmap_tiling [BS] %hu", specularmap_tiling);
    else
      {
        fail ("MATERIAL.specularmap_tiling [BS] %hu != %hu", material->specularmap_tiling, specularmap_tiling); error++;
      }
    specularmap_tiling++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "specularmap_tiling", &specularmap_tiling) &&
        specularmap_tiling == material->specularmap_tiling)
      pass ("MATERIAL.specularmap_tiling [BS] set+1 %hu", specularmap_tiling);
    else
      {
        fail ("MATERIAL.specularmap_tiling [BS] set+1 %hu != %hu", material->specularmap_tiling, specularmap_tiling); error++;
      }
    material->specularmap_tiling--;

  }
  {
    BITCODE_BD* specularmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_transmatrix", &specularmap_transmatrix, NULL)
        && !memcmp(&specularmap_transmatrix, &material->specularmap_transmatrix, sizeof(material->specularmap_transmatrix)))
      pass ("MATERIAL.specularmap_transmatrix [BD*]");
    else
      {
        fail ("MATERIAL.specularmap_transmatrix [BD*]"); error++;
      }
  }
  {
    BITCODE_BD translucence;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "translucence", &translucence, NULL) &&
        translucence == material->translucence)
      pass ("MATERIAL.translucence [BD] %g", translucence);
    else
      {
        fail ("MATERIAL.translucence [BD] %g != %g", material->translucence, translucence); error++;
      }
    translucence++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "translucence", &translucence) &&
        translucence == material->translucence)
      pass ("MATERIAL.translucence [BD] set+1 %g", translucence);
    else
      {
        fail ("MATERIAL.translucence [BD] set+1 %g != %g", material->translucence, translucence); error++;
      }
    material->translucence--;

  }
  {
    BITCODE_BD transmittance_scale;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "transmittance_scale", &transmittance_scale, NULL) &&
        transmittance_scale == material->transmittance_scale)
      pass ("MATERIAL.transmittance_scale [BD] %g", transmittance_scale);
    else
      {
        fail ("MATERIAL.transmittance_scale [BD] %g != %g", material->transmittance_scale, transmittance_scale); error++;
      }
    transmittance_scale++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "transmittance_scale", &transmittance_scale) &&
        transmittance_scale == material->transmittance_scale)
      pass ("MATERIAL.transmittance_scale [BD] set+1 %g", transmittance_scale);
    else
      {
        fail ("MATERIAL.transmittance_scale [BD] set+1 %g != %g", material->transmittance_scale, transmittance_scale); error++;
      }
    material->transmittance_scale--;

  }
  {
    BITCODE_B two_sided_material;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "two_sided_material", &two_sided_material, NULL) &&
        two_sided_material == material->two_sided_material)
      pass ("MATERIAL.two_sided_material [B] " FORMAT_B "", two_sided_material);
    else
      {
        fail ("MATERIAL.two_sided_material [B] " FORMAT_B " != " FORMAT_B "", material->two_sided_material, two_sided_material); error++;
      }
    two_sided_material++;
    if (dwg_dynapi_entity_set_value(material, "MATERIAL", "two_sided_material", &two_sided_material) &&
        two_sided_material == material->two_sided_material)
      pass ("MATERIAL.two_sided_material [B] set+1 " FORMAT_B "", two_sided_material);
    else
      {
        fail ("MATERIAL.two_sided_material [B] set+1 " FORMAT_B " != " FORMAT_B "", material->two_sided_material, two_sided_material); error++;
      }
    material->two_sided_material--;

  }
  return error;
}
static int test_MLEADERSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_MLEADERSTYLE *mleaderstyle = obj->tio.object->tio.MLEADERSTYLE;
  {
    BITCODE_BD align_space;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "align_space", &align_space, NULL) &&
        align_space == mleaderstyle->align_space)
      pass ("MLEADERSTYLE.align_space [BD] %g", align_space);
    else
      {
        fail ("MLEADERSTYLE.align_space [BD] %g != %g", mleaderstyle->align_space, align_space); error++;
      }
    align_space++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "align_space", &align_space) &&
        align_space == mleaderstyle->align_space)
      pass ("MLEADERSTYLE.align_space [BD] set+1 %g", align_space);
    else
      {
        fail ("MLEADERSTYLE.align_space [BD] set+1 %g != %g", mleaderstyle->align_space, align_space); error++;
      }
    mleaderstyle->align_space--;

  }
  {
    BITCODE_H arrow_head;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "arrow_head", &arrow_head, NULL)
        && !memcmp(&arrow_head, &mleaderstyle->arrow_head, sizeof(mleaderstyle->arrow_head)))
      pass ("MLEADERSTYLE.arrow_head [H]");
    else
      {
        fail ("MLEADERSTYLE.arrow_head [H]"); error++;
      }
  }
  {
    BITCODE_BD arrow_head_size;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "arrow_head_size", &arrow_head_size, NULL) &&
        arrow_head_size == mleaderstyle->arrow_head_size)
      pass ("MLEADERSTYLE.arrow_head_size [BD] %g", arrow_head_size);
    else
      {
        fail ("MLEADERSTYLE.arrow_head_size [BD] %g != %g", mleaderstyle->arrow_head_size, arrow_head_size); error++;
      }
    arrow_head_size++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "arrow_head_size", &arrow_head_size) &&
        arrow_head_size == mleaderstyle->arrow_head_size)
      pass ("MLEADERSTYLE.arrow_head_size [BD] set+1 %g", arrow_head_size);
    else
      {
        fail ("MLEADERSTYLE.arrow_head_size [BD] set+1 %g != %g", mleaderstyle->arrow_head_size, arrow_head_size); error++;
      }
    mleaderstyle->arrow_head_size--;

  }
  {
    BITCODE_BS attach_bottom;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_bottom", &attach_bottom, NULL) &&
        attach_bottom == mleaderstyle->attach_bottom)
      pass ("MLEADERSTYLE.attach_bottom [BS] %hu", attach_bottom);
    else
      {
        fail ("MLEADERSTYLE.attach_bottom [BS] %hu != %hu", mleaderstyle->attach_bottom, attach_bottom); error++;
      }
    attach_bottom++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "attach_bottom", &attach_bottom) &&
        attach_bottom == mleaderstyle->attach_bottom)
      pass ("MLEADERSTYLE.attach_bottom [BS] set+1 %hu", attach_bottom);
    else
      {
        fail ("MLEADERSTYLE.attach_bottom [BS] set+1 %hu != %hu", mleaderstyle->attach_bottom, attach_bottom); error++;
      }
    mleaderstyle->attach_bottom--;

  }
  {
    BITCODE_BS attach_dir;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_dir", &attach_dir, NULL) &&
        attach_dir == mleaderstyle->attach_dir)
      pass ("MLEADERSTYLE.attach_dir [BS] %hu", attach_dir);
    else
      {
        fail ("MLEADERSTYLE.attach_dir [BS] %hu != %hu", mleaderstyle->attach_dir, attach_dir); error++;
      }
    attach_dir++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "attach_dir", &attach_dir) &&
        attach_dir == mleaderstyle->attach_dir)
      pass ("MLEADERSTYLE.attach_dir [BS] set+1 %hu", attach_dir);
    else
      {
        fail ("MLEADERSTYLE.attach_dir [BS] set+1 %hu != %hu", mleaderstyle->attach_dir, attach_dir); error++;
      }
    mleaderstyle->attach_dir--;

  }
  {
    BITCODE_BS attach_left;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_left", &attach_left, NULL) &&
        attach_left == mleaderstyle->attach_left)
      pass ("MLEADERSTYLE.attach_left [BS] %hu", attach_left);
    else
      {
        fail ("MLEADERSTYLE.attach_left [BS] %hu != %hu", mleaderstyle->attach_left, attach_left); error++;
      }
    attach_left++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "attach_left", &attach_left) &&
        attach_left == mleaderstyle->attach_left)
      pass ("MLEADERSTYLE.attach_left [BS] set+1 %hu", attach_left);
    else
      {
        fail ("MLEADERSTYLE.attach_left [BS] set+1 %hu != %hu", mleaderstyle->attach_left, attach_left); error++;
      }
    mleaderstyle->attach_left--;

  }
  {
    BITCODE_BS attach_right;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_right", &attach_right, NULL) &&
        attach_right == mleaderstyle->attach_right)
      pass ("MLEADERSTYLE.attach_right [BS] %hu", attach_right);
    else
      {
        fail ("MLEADERSTYLE.attach_right [BS] %hu != %hu", mleaderstyle->attach_right, attach_right); error++;
      }
    attach_right++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "attach_right", &attach_right) &&
        attach_right == mleaderstyle->attach_right)
      pass ("MLEADERSTYLE.attach_right [BS] set+1 %hu", attach_right);
    else
      {
        fail ("MLEADERSTYLE.attach_right [BS] set+1 %hu != %hu", mleaderstyle->attach_right, attach_right); error++;
      }
    mleaderstyle->attach_right--;

  }
  {
    BITCODE_BS attach_top;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_top", &attach_top, NULL) &&
        attach_top == mleaderstyle->attach_top)
      pass ("MLEADERSTYLE.attach_top [BS] %hu", attach_top);
    else
      {
        fail ("MLEADERSTYLE.attach_top [BS] %hu != %hu", mleaderstyle->attach_top, attach_top); error++;
      }
    attach_top++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "attach_top", &attach_top) &&
        attach_top == mleaderstyle->attach_top)
      pass ("MLEADERSTYLE.attach_top [BS] set+1 %hu", attach_top);
    else
      {
        fail ("MLEADERSTYLE.attach_top [BS] set+1 %hu != %hu", mleaderstyle->attach_top, attach_top); error++;
      }
    mleaderstyle->attach_top--;

  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block", &block, NULL)
        && !memcmp(&block, &mleaderstyle->block, sizeof(mleaderstyle->block)))
      pass ("MLEADERSTYLE.block [H]");
    else
      {
        fail ("MLEADERSTYLE.block [H]"); error++;
      }
  }
  {
    BITCODE_CMC block_color;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block_color", &block_color, NULL)
        && !memcmp(&block_color, &mleaderstyle->block_color, sizeof(mleaderstyle->block_color)))
      pass ("MLEADERSTYLE.block_color [CMC]");
    else
      {
        fail ("MLEADERSTYLE.block_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS block_connection;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block_connection", &block_connection, NULL) &&
        block_connection == mleaderstyle->block_connection)
      pass ("MLEADERSTYLE.block_connection [BS] %hu", block_connection);
    else
      {
        fail ("MLEADERSTYLE.block_connection [BS] %hu != %hu", mleaderstyle->block_connection, block_connection); error++;
      }
    block_connection++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "block_connection", &block_connection) &&
        block_connection == mleaderstyle->block_connection)
      pass ("MLEADERSTYLE.block_connection [BS] set+1 %hu", block_connection);
    else
      {
        fail ("MLEADERSTYLE.block_connection [BS] set+1 %hu != %hu", mleaderstyle->block_connection, block_connection); error++;
      }
    mleaderstyle->block_connection--;

  }
  {
    BITCODE_BD block_rotation;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block_rotation", &block_rotation, NULL) &&
        block_rotation == mleaderstyle->block_rotation)
      pass ("MLEADERSTYLE.block_rotation [BD] %g", block_rotation);
    else
      {
        fail ("MLEADERSTYLE.block_rotation [BD] %g != %g", mleaderstyle->block_rotation, block_rotation); error++;
      }
    block_rotation++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "block_rotation", &block_rotation) &&
        block_rotation == mleaderstyle->block_rotation)
      pass ("MLEADERSTYLE.block_rotation [BD] set+1 %g", block_rotation);
    else
      {
        fail ("MLEADERSTYLE.block_rotation [BD] set+1 %g != %g", mleaderstyle->block_rotation, block_rotation); error++;
      }
    mleaderstyle->block_rotation--;

  }
  {
    BITCODE_3BD block_scale;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block_scale", &block_scale, NULL)
        && !memcmp(&block_scale, &mleaderstyle->block_scale, sizeof(mleaderstyle->block_scale)))
      pass ("MLEADERSTYLE.block_scale [3BD]");
    else
      {
        fail ("MLEADERSTYLE.block_scale [3BD]"); error++;
      }
  }
  {
    BITCODE_BD break_size;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "break_size", &break_size, NULL) &&
        break_size == mleaderstyle->break_size)
      pass ("MLEADERSTYLE.break_size [BD] %g", break_size);
    else
      {
        fail ("MLEADERSTYLE.break_size [BD] %g != %g", mleaderstyle->break_size, break_size); error++;
      }
    break_size++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "break_size", &break_size) &&
        break_size == mleaderstyle->break_size)
      pass ("MLEADERSTYLE.break_size [BD] set+1 %g", break_size);
    else
      {
        fail ("MLEADERSTYLE.break_size [BD] set+1 %g != %g", mleaderstyle->break_size, break_size); error++;
      }
    mleaderstyle->break_size--;

  }
  {
    BITCODE_B changed;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "changed", &changed, NULL) &&
        changed == mleaderstyle->changed)
      pass ("MLEADERSTYLE.changed [B] " FORMAT_B "", changed);
    else
      {
        fail ("MLEADERSTYLE.changed [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->changed, changed); error++;
      }
    changed++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "changed", &changed) &&
        changed == mleaderstyle->changed)
      pass ("MLEADERSTYLE.changed [B] set+1 " FORMAT_B "", changed);
    else
      {
        fail ("MLEADERSTYLE.changed [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->changed, changed); error++;
      }
    mleaderstyle->changed--;

  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "class_version", &class_version, NULL) &&
        class_version == mleaderstyle->class_version)
      pass ("MLEADERSTYLE.class_version [BS] %hu", class_version);
    else
      {
        fail ("MLEADERSTYLE.class_version [BS] %hu != %hu", mleaderstyle->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "class_version", &class_version) &&
        class_version == mleaderstyle->class_version)
      pass ("MLEADERSTYLE.class_version [BS] set+1 %hu", class_version);
    else
      {
        fail ("MLEADERSTYLE.class_version [BS] set+1 %hu != %hu", mleaderstyle->class_version, class_version); error++;
      }
    mleaderstyle->class_version--;

  }
  {
    BITCODE_BS content_type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "content_type", &content_type, NULL) &&
        content_type == mleaderstyle->content_type)
      pass ("MLEADERSTYLE.content_type [BS] %hu", content_type);
    else
      {
        fail ("MLEADERSTYLE.content_type [BS] %hu != %hu", mleaderstyle->content_type, content_type); error++;
      }
    content_type++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "content_type", &content_type) &&
        content_type == mleaderstyle->content_type)
      pass ("MLEADERSTYLE.content_type [BS] set+1 %hu", content_type);
    else
      {
        fail ("MLEADERSTYLE.content_type [BS] set+1 %hu != %hu", mleaderstyle->content_type, content_type); error++;
      }
    mleaderstyle->content_type--;

  }
  {
    BITCODE_TV description;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "description", &description, NULL)
        && !strcmp((char*)&description, (char*)&mleaderstyle->description))
      pass ("MLEADERSTYLE.description [TV]");
    else
      {
        fail ("MLEADERSTYLE.description [TV]"); error++;
      }
  }
  {
    BITCODE_BD first_seg_angle;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "first_seg_angle", &first_seg_angle, NULL) &&
        first_seg_angle == mleaderstyle->first_seg_angle)
      pass ("MLEADERSTYLE.first_seg_angle [BD] %g", first_seg_angle);
    else
      {
        fail ("MLEADERSTYLE.first_seg_angle [BD] %g != %g", mleaderstyle->first_seg_angle, first_seg_angle); error++;
      }
    first_seg_angle++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "first_seg_angle", &first_seg_angle) &&
        first_seg_angle == mleaderstyle->first_seg_angle)
      pass ("MLEADERSTYLE.first_seg_angle [BD] set+1 %g", first_seg_angle);
    else
      {
        fail ("MLEADERSTYLE.first_seg_angle [BD] set+1 %g != %g", mleaderstyle->first_seg_angle, first_seg_angle); error++;
      }
    mleaderstyle->first_seg_angle--;

  }
  {
    BITCODE_B has_dogleg;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "has_dogleg", &has_dogleg, NULL) &&
        has_dogleg == mleaderstyle->has_dogleg)
      pass ("MLEADERSTYLE.has_dogleg [B] " FORMAT_B "", has_dogleg);
    else
      {
        fail ("MLEADERSTYLE.has_dogleg [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_dogleg, has_dogleg); error++;
      }
    has_dogleg++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "has_dogleg", &has_dogleg) &&
        has_dogleg == mleaderstyle->has_dogleg)
      pass ("MLEADERSTYLE.has_dogleg [B] set+1 " FORMAT_B "", has_dogleg);
    else
      {
        fail ("MLEADERSTYLE.has_dogleg [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_dogleg, has_dogleg); error++;
      }
    mleaderstyle->has_dogleg--;

  }
  {
    BITCODE_B has_landing;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "has_landing", &has_landing, NULL) &&
        has_landing == mleaderstyle->has_landing)
      pass ("MLEADERSTYLE.has_landing [B] " FORMAT_B "", has_landing);
    else
      {
        fail ("MLEADERSTYLE.has_landing [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_landing, has_landing); error++;
      }
    has_landing++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "has_landing", &has_landing) &&
        has_landing == mleaderstyle->has_landing)
      pass ("MLEADERSTYLE.has_landing [B] set+1 " FORMAT_B "", has_landing);
    else
      {
        fail ("MLEADERSTYLE.has_landing [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_landing, has_landing); error++;
      }
    mleaderstyle->has_landing--;

  }
  {
    BITCODE_B is_annotative;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "is_annotative", &is_annotative, NULL) &&
        is_annotative == mleaderstyle->is_annotative)
      pass ("MLEADERSTYLE.is_annotative [B] " FORMAT_B "", is_annotative);
    else
      {
        fail ("MLEADERSTYLE.is_annotative [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_annotative, is_annotative); error++;
      }
    is_annotative++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "is_annotative", &is_annotative) &&
        is_annotative == mleaderstyle->is_annotative)
      pass ("MLEADERSTYLE.is_annotative [B] set+1 " FORMAT_B "", is_annotative);
    else
      {
        fail ("MLEADERSTYLE.is_annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_annotative, is_annotative); error++;
      }
    mleaderstyle->is_annotative--;

  }
  {
    BITCODE_B is_new_format;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "is_new_format", &is_new_format, NULL) &&
        is_new_format == mleaderstyle->is_new_format)
      pass ("MLEADERSTYLE.is_new_format [B] " FORMAT_B "", is_new_format);
    else
      {
        fail ("MLEADERSTYLE.is_new_format [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_new_format, is_new_format); error++;
      }
    is_new_format++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "is_new_format", &is_new_format) &&
        is_new_format == mleaderstyle->is_new_format)
      pass ("MLEADERSTYLE.is_new_format [B] set+1 " FORMAT_B "", is_new_format);
    else
      {
        fail ("MLEADERSTYLE.is_new_format [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_new_format, is_new_format); error++;
      }
    mleaderstyle->is_new_format--;

  }
  {
    BITCODE_BD landing_dist;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "landing_dist", &landing_dist, NULL) &&
        landing_dist == mleaderstyle->landing_dist)
      pass ("MLEADERSTYLE.landing_dist [BD] %g", landing_dist);
    else
      {
        fail ("MLEADERSTYLE.landing_dist [BD] %g != %g", mleaderstyle->landing_dist, landing_dist); error++;
      }
    landing_dist++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "landing_dist", &landing_dist) &&
        landing_dist == mleaderstyle->landing_dist)
      pass ("MLEADERSTYLE.landing_dist [BD] set+1 %g", landing_dist);
    else
      {
        fail ("MLEADERSTYLE.landing_dist [BD] set+1 %g != %g", mleaderstyle->landing_dist, landing_dist); error++;
      }
    mleaderstyle->landing_dist--;

  }
  {
    BITCODE_BD landing_gap;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "landing_gap", &landing_gap, NULL) &&
        landing_gap == mleaderstyle->landing_gap)
      pass ("MLEADERSTYLE.landing_gap [BD] %g", landing_gap);
    else
      {
        fail ("MLEADERSTYLE.landing_gap [BD] %g != %g", mleaderstyle->landing_gap, landing_gap); error++;
      }
    landing_gap++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "landing_gap", &landing_gap) &&
        landing_gap == mleaderstyle->landing_gap)
      pass ("MLEADERSTYLE.landing_gap [BD] set+1 %g", landing_gap);
    else
      {
        fail ("MLEADERSTYLE.landing_gap [BD] set+1 %g != %g", mleaderstyle->landing_gap, landing_gap); error++;
      }
    mleaderstyle->landing_gap--;

  }
  {
    BITCODE_BS leader_order;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "leader_order", &leader_order, NULL) &&
        leader_order == mleaderstyle->leader_order)
      pass ("MLEADERSTYLE.leader_order [BS] %hu", leader_order);
    else
      {
        fail ("MLEADERSTYLE.leader_order [BS] %hu != %hu", mleaderstyle->leader_order, leader_order); error++;
      }
    leader_order++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "leader_order", &leader_order) &&
        leader_order == mleaderstyle->leader_order)
      pass ("MLEADERSTYLE.leader_order [BS] set+1 %hu", leader_order);
    else
      {
        fail ("MLEADERSTYLE.leader_order [BS] set+1 %hu != %hu", mleaderstyle->leader_order, leader_order); error++;
      }
    mleaderstyle->leader_order--;

  }
  {
    BITCODE_CMC line_color;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "line_color", &line_color, NULL)
        && !memcmp(&line_color, &mleaderstyle->line_color, sizeof(mleaderstyle->line_color)))
      pass ("MLEADERSTYLE.line_color [CMC]");
    else
      {
        fail ("MLEADERSTYLE.line_color [CMC]"); error++;
      }
  }
  {
    BITCODE_H line_type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "line_type", &line_type, NULL)
        && !memcmp(&line_type, &mleaderstyle->line_type, sizeof(mleaderstyle->line_type)))
      pass ("MLEADERSTYLE.line_type [H]");
    else
      {
        fail ("MLEADERSTYLE.line_type [H]"); error++;
      }
  }
  {
    BITCODE_BL linewt;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "linewt", &linewt, NULL) &&
        linewt == mleaderstyle->linewt)
      pass ("MLEADERSTYLE.linewt [BL] %u", linewt);
    else
      {
        fail ("MLEADERSTYLE.linewt [BL] %u != %u", mleaderstyle->linewt, linewt); error++;
      }
    linewt++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "linewt", &linewt) &&
        linewt == mleaderstyle->linewt)
      pass ("MLEADERSTYLE.linewt [BL] set+1 %u", linewt);
    else
      {
        fail ("MLEADERSTYLE.linewt [BL] set+1 %u != %u", mleaderstyle->linewt, linewt); error++;
      }
    mleaderstyle->linewt--;

  }
  {
    BITCODE_BL max_points;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "max_points", &max_points, NULL) &&
        max_points == mleaderstyle->max_points)
      pass ("MLEADERSTYLE.max_points [BL] %u", max_points);
    else
      {
        fail ("MLEADERSTYLE.max_points [BL] %u != %u", mleaderstyle->max_points, max_points); error++;
      }
    max_points++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "max_points", &max_points) &&
        max_points == mleaderstyle->max_points)
      pass ("MLEADERSTYLE.max_points [BL] set+1 %u", max_points);
    else
      {
        fail ("MLEADERSTYLE.max_points [BL] set+1 %u != %u", mleaderstyle->max_points, max_points); error++;
      }
    mleaderstyle->max_points--;

  }
  {
    BITCODE_BS mleader_order;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "mleader_order", &mleader_order, NULL) &&
        mleader_order == mleaderstyle->mleader_order)
      pass ("MLEADERSTYLE.mleader_order [BS] %hu", mleader_order);
    else
      {
        fail ("MLEADERSTYLE.mleader_order [BS] %hu != %hu", mleaderstyle->mleader_order, mleader_order); error++;
      }
    mleader_order++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "mleader_order", &mleader_order) &&
        mleader_order == mleaderstyle->mleader_order)
      pass ("MLEADERSTYLE.mleader_order [BS] set+1 %hu", mleader_order);
    else
      {
        fail ("MLEADERSTYLE.mleader_order [BS] set+1 %hu != %hu", mleaderstyle->mleader_order, mleader_order); error++;
      }
    mleaderstyle->mleader_order--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &mleaderstyle->parent, sizeof(mleaderstyle->parent)))
      pass ("MLEADERSTYLE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("MLEADERSTYLE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "scale", &scale, NULL) &&
        scale == mleaderstyle->scale)
      pass ("MLEADERSTYLE.scale [BD] %g", scale);
    else
      {
        fail ("MLEADERSTYLE.scale [BD] %g != %g", mleaderstyle->scale, scale); error++;
      }
    scale++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "scale", &scale) &&
        scale == mleaderstyle->scale)
      pass ("MLEADERSTYLE.scale [BD] set+1 %g", scale);
    else
      {
        fail ("MLEADERSTYLE.scale [BD] set+1 %g != %g", mleaderstyle->scale, scale); error++;
      }
    mleaderstyle->scale--;

  }
  {
    BITCODE_BD second_seg_angle;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "second_seg_angle", &second_seg_angle, NULL) &&
        second_seg_angle == mleaderstyle->second_seg_angle)
      pass ("MLEADERSTYLE.second_seg_angle [BD] %g", second_seg_angle);
    else
      {
        fail ("MLEADERSTYLE.second_seg_angle [BD] %g != %g", mleaderstyle->second_seg_angle, second_seg_angle); error++;
      }
    second_seg_angle++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "second_seg_angle", &second_seg_angle) &&
        second_seg_angle == mleaderstyle->second_seg_angle)
      pass ("MLEADERSTYLE.second_seg_angle [BD] set+1 %g", second_seg_angle);
    else
      {
        fail ("MLEADERSTYLE.second_seg_angle [BD] set+1 %g != %g", mleaderstyle->second_seg_angle, second_seg_angle); error++;
      }
    mleaderstyle->second_seg_angle--;

  }
  {
    BITCODE_BS text_align_type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_align_type", &text_align_type, NULL) &&
        text_align_type == mleaderstyle->text_align_type)
      pass ("MLEADERSTYLE.text_align_type [BS] %hu", text_align_type);
    else
      {
        fail ("MLEADERSTYLE.text_align_type [BS] %hu != %hu", mleaderstyle->text_align_type, text_align_type); error++;
      }
    text_align_type++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "text_align_type", &text_align_type) &&
        text_align_type == mleaderstyle->text_align_type)
      pass ("MLEADERSTYLE.text_align_type [BS] set+1 %hu", text_align_type);
    else
      {
        fail ("MLEADERSTYLE.text_align_type [BS] set+1 %hu != %hu", mleaderstyle->text_align_type, text_align_type); error++;
      }
    mleaderstyle->text_align_type--;

  }
  {
    BITCODE_B text_always_left;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_always_left", &text_always_left, NULL) &&
        text_always_left == mleaderstyle->text_always_left)
      pass ("MLEADERSTYLE.text_always_left [B] " FORMAT_B "", text_always_left);
    else
      {
        fail ("MLEADERSTYLE.text_always_left [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_always_left, text_always_left); error++;
      }
    text_always_left++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "text_always_left", &text_always_left) &&
        text_always_left == mleaderstyle->text_always_left)
      pass ("MLEADERSTYLE.text_always_left [B] set+1 " FORMAT_B "", text_always_left);
    else
      {
        fail ("MLEADERSTYLE.text_always_left [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_always_left, text_always_left); error++;
      }
    mleaderstyle->text_always_left--;

  }
  {
    BITCODE_BS text_angle_type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_angle_type", &text_angle_type, NULL) &&
        text_angle_type == mleaderstyle->text_angle_type)
      pass ("MLEADERSTYLE.text_angle_type [BS] %hu", text_angle_type);
    else
      {
        fail ("MLEADERSTYLE.text_angle_type [BS] %hu != %hu", mleaderstyle->text_angle_type, text_angle_type); error++;
      }
    text_angle_type++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "text_angle_type", &text_angle_type) &&
        text_angle_type == mleaderstyle->text_angle_type)
      pass ("MLEADERSTYLE.text_angle_type [BS] set+1 %hu", text_angle_type);
    else
      {
        fail ("MLEADERSTYLE.text_angle_type [BS] set+1 %hu != %hu", mleaderstyle->text_angle_type, text_angle_type); error++;
      }
    mleaderstyle->text_angle_type--;

  }
  {
    BITCODE_CMC text_color;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_color", &text_color, NULL)
        && !memcmp(&text_color, &mleaderstyle->text_color, sizeof(mleaderstyle->text_color)))
      pass ("MLEADERSTYLE.text_color [CMC]");
    else
      {
        fail ("MLEADERSTYLE.text_color [CMC]"); error++;
      }
  }
  {
    BITCODE_TV text_default;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_default", &text_default, NULL)
        && !strcmp((char*)&text_default, (char*)&mleaderstyle->text_default))
      pass ("MLEADERSTYLE.text_default [TV]");
    else
      {
        fail ("MLEADERSTYLE.text_default [TV]"); error++;
      }
  }
  {
    BITCODE_B text_extended;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_extended", &text_extended, NULL) &&
        text_extended == mleaderstyle->text_extended)
      pass ("MLEADERSTYLE.text_extended [B] " FORMAT_B "", text_extended);
    else
      {
        fail ("MLEADERSTYLE.text_extended [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_extended, text_extended); error++;
      }
    text_extended++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "text_extended", &text_extended) &&
        text_extended == mleaderstyle->text_extended)
      pass ("MLEADERSTYLE.text_extended [B] set+1 " FORMAT_B "", text_extended);
    else
      {
        fail ("MLEADERSTYLE.text_extended [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_extended, text_extended); error++;
      }
    mleaderstyle->text_extended--;

  }
  {
    BITCODE_B text_frame;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_frame", &text_frame, NULL) &&
        text_frame == mleaderstyle->text_frame)
      pass ("MLEADERSTYLE.text_frame [B] " FORMAT_B "", text_frame);
    else
      {
        fail ("MLEADERSTYLE.text_frame [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_frame, text_frame); error++;
      }
    text_frame++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "text_frame", &text_frame) &&
        text_frame == mleaderstyle->text_frame)
      pass ("MLEADERSTYLE.text_frame [B] set+1 " FORMAT_B "", text_frame);
    else
      {
        fail ("MLEADERSTYLE.text_frame [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_frame, text_frame); error++;
      }
    mleaderstyle->text_frame--;

  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_height", &text_height, NULL) &&
        text_height == mleaderstyle->text_height)
      pass ("MLEADERSTYLE.text_height [BD] %g", text_height);
    else
      {
        fail ("MLEADERSTYLE.text_height [BD] %g != %g", mleaderstyle->text_height, text_height); error++;
      }
    text_height++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "text_height", &text_height) &&
        text_height == mleaderstyle->text_height)
      pass ("MLEADERSTYLE.text_height [BD] set+1 %g", text_height);
    else
      {
        fail ("MLEADERSTYLE.text_height [BD] set+1 %g != %g", mleaderstyle->text_height, text_height); error++;
      }
    mleaderstyle->text_height--;

  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_style", &text_style, NULL)
        && !memcmp(&text_style, &mleaderstyle->text_style, sizeof(mleaderstyle->text_style)))
      pass ("MLEADERSTYLE.text_style [H]");
    else
      {
        fail ("MLEADERSTYLE.text_style [H]"); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "type", &type, NULL) &&
        type == mleaderstyle->type)
      pass ("MLEADERSTYLE.type [BS] %hu", type);
    else
      {
        fail ("MLEADERSTYLE.type [BS] %hu != %hu", mleaderstyle->type, type); error++;
      }
    type++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "type", &type) &&
        type == mleaderstyle->type)
      pass ("MLEADERSTYLE.type [BS] set+1 %hu", type);
    else
      {
        fail ("MLEADERSTYLE.type [BS] set+1 %hu != %hu", mleaderstyle->type, type); error++;
      }
    mleaderstyle->type--;

  }
  {
    BITCODE_B use_block_rotation;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "use_block_rotation", &use_block_rotation, NULL) &&
        use_block_rotation == mleaderstyle->use_block_rotation)
      pass ("MLEADERSTYLE.use_block_rotation [B] " FORMAT_B "", use_block_rotation);
    else
      {
        fail ("MLEADERSTYLE.use_block_rotation [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_rotation, use_block_rotation); error++;
      }
    use_block_rotation++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "use_block_rotation", &use_block_rotation) &&
        use_block_rotation == mleaderstyle->use_block_rotation)
      pass ("MLEADERSTYLE.use_block_rotation [B] set+1 " FORMAT_B "", use_block_rotation);
    else
      {
        fail ("MLEADERSTYLE.use_block_rotation [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_rotation, use_block_rotation); error++;
      }
    mleaderstyle->use_block_rotation--;

  }
  {
    BITCODE_B use_block_scale;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "use_block_scale", &use_block_scale, NULL) &&
        use_block_scale == mleaderstyle->use_block_scale)
      pass ("MLEADERSTYLE.use_block_scale [B] " FORMAT_B "", use_block_scale);
    else
      {
        fail ("MLEADERSTYLE.use_block_scale [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_scale, use_block_scale); error++;
      }
    use_block_scale++;
    if (dwg_dynapi_entity_set_value(mleaderstyle, "MLEADERSTYLE", "use_block_scale", &use_block_scale) &&
        use_block_scale == mleaderstyle->use_block_scale)
      pass ("MLEADERSTYLE.use_block_scale [B] set+1 " FORMAT_B "", use_block_scale);
    else
      {
        fail ("MLEADERSTYLE.use_block_scale [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_scale, use_block_scale); error++;
      }
    mleaderstyle->use_block_scale--;

  }
  return error;
}
static int test_MLINESTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_MLINESTYLE *mlinestyle = obj->tio.object->tio.MLINESTYLE;
  {
    BITCODE_TV desc;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "desc", &desc, NULL)
        && !strcmp((char*)&desc, (char*)&mlinestyle->desc))
      pass ("MLINESTYLE.desc [TV]");
    else
      {
        fail ("MLINESTYLE.desc [TV]"); error++;
      }
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "end_angle", &end_angle, NULL) &&
        end_angle == mlinestyle->end_angle)
      pass ("MLINESTYLE.end_angle [BD] %g", end_angle);
    else
      {
        fail ("MLINESTYLE.end_angle [BD] %g != %g", mlinestyle->end_angle, end_angle); error++;
      }
    end_angle++;
    if (dwg_dynapi_entity_set_value(mlinestyle, "MLINESTYLE", "end_angle", &end_angle) &&
        end_angle == mlinestyle->end_angle)
      pass ("MLINESTYLE.end_angle [BD] set+1 %g", end_angle);
    else
      {
        fail ("MLINESTYLE.end_angle [BD] set+1 %g != %g", mlinestyle->end_angle, end_angle); error++;
      }
    mlinestyle->end_angle--;

  }
  {
    BITCODE_CMC fill_color;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "fill_color", &fill_color, NULL)
        && !memcmp(&fill_color, &mlinestyle->fill_color, sizeof(mlinestyle->fill_color)))
      pass ("MLINESTYLE.fill_color [CMC]");
    else
      {
        fail ("MLINESTYLE.fill_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "flag", &flag, NULL) &&
        flag == mlinestyle->flag)
      pass ("MLINESTYLE.flag [BS] %hu", flag);
    else
      {
        fail ("MLINESTYLE.flag [BS] %hu != %hu", mlinestyle->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(mlinestyle, "MLINESTYLE", "flag", &flag) &&
        flag == mlinestyle->flag)
      pass ("MLINESTYLE.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("MLINESTYLE.flag [BS] set+1 %hu != %hu", mlinestyle->flag, flag); error++;
      }
    mlinestyle->flag--;

  }
  {
    Dwg_MLINESTYLE_line* lines;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "lines", &lines, NULL)
        && !memcmp(&lines, &mlinestyle->lines, sizeof(mlinestyle->lines)))
      pass ("MLINESTYLE.lines [Dwg_MLINESTYLE_line*]");
    else
      {
        fail ("MLINESTYLE.lines [Dwg_MLINESTYLE_line*]"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&mlinestyle->name))
      pass ("MLINESTYLE.name [TV]");
    else
      {
        fail ("MLINESTYLE.name [TV]"); error++;
      }
  }
  {
    BITCODE_RC num_lines;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "num_lines", &num_lines, NULL) &&
        num_lines == mlinestyle->num_lines)
      pass ("MLINESTYLE.num_lines [RC] %u", num_lines);
    else
      {
        fail ("MLINESTYLE.num_lines [RC] %u != %u", mlinestyle->num_lines, num_lines); error++;
      }
    num_lines++;
    if (dwg_dynapi_entity_set_value(mlinestyle, "MLINESTYLE", "num_lines", &num_lines) &&
        num_lines == mlinestyle->num_lines)
      pass ("MLINESTYLE.num_lines [RC] set+1 %u", num_lines);
    else
      {
        fail ("MLINESTYLE.num_lines [RC] set+1 %u != %u", mlinestyle->num_lines, num_lines); error++;
      }
    mlinestyle->num_lines--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &mlinestyle->ownerhandle, sizeof(mlinestyle->ownerhandle)))
      pass ("MLINESTYLE.ownerhandle [H]");
    else
      {
        fail ("MLINESTYLE.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &mlinestyle->parent, sizeof(mlinestyle->parent)))
      pass ("MLINESTYLE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("MLINESTYLE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "start_angle", &start_angle, NULL) &&
        start_angle == mlinestyle->start_angle)
      pass ("MLINESTYLE.start_angle [BD] %g", start_angle);
    else
      {
        fail ("MLINESTYLE.start_angle [BD] %g != %g", mlinestyle->start_angle, start_angle); error++;
      }
    start_angle++;
    if (dwg_dynapi_entity_set_value(mlinestyle, "MLINESTYLE", "start_angle", &start_angle) &&
        start_angle == mlinestyle->start_angle)
      pass ("MLINESTYLE.start_angle [BD] set+1 %g", start_angle);
    else
      {
        fail ("MLINESTYLE.start_angle [BD] set+1 %g != %g", mlinestyle->start_angle, start_angle); error++;
      }
    mlinestyle->start_angle--;

  }
  return error;
}
static int test_OBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_OBJECTCONTEXTDATA *objectcontextdata = obj->tio.object->tio.OBJECTCONTEXTDATA;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(objectcontextdata, "OBJECTCONTEXTDATA", "class_version", &class_version, NULL) &&
        class_version == objectcontextdata->class_version)
      pass ("OBJECTCONTEXTDATA.class_version [BS] %hu", class_version);
    else
      {
        fail ("OBJECTCONTEXTDATA.class_version [BS] %hu != %hu", objectcontextdata->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(objectcontextdata, "OBJECTCONTEXTDATA", "class_version", &class_version) &&
        class_version == objectcontextdata->class_version)
      pass ("OBJECTCONTEXTDATA.class_version [BS] set+1 %hu", class_version);
    else
      {
        fail ("OBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", objectcontextdata->class_version, class_version); error++;
      }
    objectcontextdata->class_version--;

  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value(objectcontextdata, "OBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL) &&
        defaultflag == objectcontextdata->defaultflag)
      pass ("OBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B "", defaultflag);
    else
      {
        fail ("OBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", objectcontextdata->defaultflag, defaultflag); error++;
      }
    defaultflag++;
    if (dwg_dynapi_entity_set_value(objectcontextdata, "OBJECTCONTEXTDATA", "defaultflag", &defaultflag) &&
        defaultflag == objectcontextdata->defaultflag)
      pass ("OBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B "", defaultflag);
    else
      {
        fail ("OBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", objectcontextdata->defaultflag, defaultflag); error++;
      }
    objectcontextdata->defaultflag--;

  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value(objectcontextdata, "OBJECTCONTEXTDATA", "has_file", &has_file, NULL) &&
        has_file == objectcontextdata->has_file)
      pass ("OBJECTCONTEXTDATA.has_file [B] " FORMAT_B "", has_file);
    else
      {
        fail ("OBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", objectcontextdata->has_file, has_file); error++;
      }
    has_file++;
    if (dwg_dynapi_entity_set_value(objectcontextdata, "OBJECTCONTEXTDATA", "has_file", &has_file) &&
        has_file == objectcontextdata->has_file)
      pass ("OBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B "", has_file);
    else
      {
        fail ("OBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", objectcontextdata->has_file, has_file); error++;
      }
    objectcontextdata->has_file--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(objectcontextdata, "OBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp(&parent, &objectcontextdata->parent, sizeof(objectcontextdata->parent)))
      pass ("OBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
    else
      {
        fail ("OBJECTCONTEXTDATA.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_OBJECT_PTR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_OBJECT_PTR *object_ptr = obj->tio.object->tio.OBJECT_PTR;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(object_ptr, "OBJECT_PTR", "parent", &parent, NULL)
        && !memcmp(&parent, &object_ptr->parent, sizeof(object_ptr->parent)))
      pass ("OBJECT_PTR.parent [struct _dwg_object_object*]");
    else
      {
        fail ("OBJECT_PTR.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_PERSSUBENTMANAGER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_PERSSUBENTMANAGER *perssubentmanager = obj->tio.object->tio.PERSSUBENTMANAGER;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "class_version", &class_version, NULL) &&
        class_version == perssubentmanager->class_version)
      pass ("PERSSUBENTMANAGER.class_version [BL] %u", class_version);
    else
      {
        fail ("PERSSUBENTMANAGER.class_version [BL] %u != %u", perssubentmanager->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(perssubentmanager, "PERSSUBENTMANAGER", "class_version", &class_version) &&
        class_version == perssubentmanager->class_version)
      pass ("PERSSUBENTMANAGER.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("PERSSUBENTMANAGER.class_version [BL] set+1 %u != %u", perssubentmanager->class_version, class_version); error++;
      }
    perssubentmanager->class_version--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &perssubentmanager->ownerhandle, sizeof(perssubentmanager->ownerhandle)))
      pass ("PERSSUBENTMANAGER.ownerhandle [H]");
    else
      {
        fail ("PERSSUBENTMANAGER.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "parent", &parent, NULL)
        && !memcmp(&parent, &perssubentmanager->parent, sizeof(perssubentmanager->parent)))
      pass ("PERSSUBENTMANAGER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("PERSSUBENTMANAGER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1, NULL) &&
        unknown_bl1 == perssubentmanager->unknown_bl1)
      pass ("PERSSUBENTMANAGER.unknown_bl1 [BL] %u", unknown_bl1);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl1 [BL] %u != %u", perssubentmanager->unknown_bl1, unknown_bl1); error++;
      }
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1) &&
        unknown_bl1 == perssubentmanager->unknown_bl1)
      pass ("PERSSUBENTMANAGER.unknown_bl1 [BL] set+1 %u", unknown_bl1);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl1 [BL] set+1 %u != %u", perssubentmanager->unknown_bl1, unknown_bl1); error++;
      }
    perssubentmanager->unknown_bl1--;

  }
  {
    BITCODE_BL unknown_bl2;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2, NULL) &&
        unknown_bl2 == perssubentmanager->unknown_bl2)
      pass ("PERSSUBENTMANAGER.unknown_bl2 [BL] %u", unknown_bl2);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl2 [BL] %u != %u", perssubentmanager->unknown_bl2, unknown_bl2); error++;
      }
    unknown_bl2++;
    if (dwg_dynapi_entity_set_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2) &&
        unknown_bl2 == perssubentmanager->unknown_bl2)
      pass ("PERSSUBENTMANAGER.unknown_bl2 [BL] set+1 %u", unknown_bl2);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl2 [BL] set+1 %u != %u", perssubentmanager->unknown_bl2, unknown_bl2); error++;
      }
    perssubentmanager->unknown_bl2--;

  }
  {
    BITCODE_BL unknown_bl3;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3, NULL) &&
        unknown_bl3 == perssubentmanager->unknown_bl3)
      pass ("PERSSUBENTMANAGER.unknown_bl3 [BL] %u", unknown_bl3);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl3 [BL] %u != %u", perssubentmanager->unknown_bl3, unknown_bl3); error++;
      }
    unknown_bl3++;
    if (dwg_dynapi_entity_set_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3) &&
        unknown_bl3 == perssubentmanager->unknown_bl3)
      pass ("PERSSUBENTMANAGER.unknown_bl3 [BL] set+1 %u", unknown_bl3);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl3 [BL] set+1 %u != %u", perssubentmanager->unknown_bl3, unknown_bl3); error++;
      }
    perssubentmanager->unknown_bl3--;

  }
  {
    BITCODE_BL unknown_bl4;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4, NULL) &&
        unknown_bl4 == perssubentmanager->unknown_bl4)
      pass ("PERSSUBENTMANAGER.unknown_bl4 [BL] %u", unknown_bl4);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl4 [BL] %u != %u", perssubentmanager->unknown_bl4, unknown_bl4); error++;
      }
    unknown_bl4++;
    if (dwg_dynapi_entity_set_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4) &&
        unknown_bl4 == perssubentmanager->unknown_bl4)
      pass ("PERSSUBENTMANAGER.unknown_bl4 [BL] set+1 %u", unknown_bl4);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl4 [BL] set+1 %u != %u", perssubentmanager->unknown_bl4, unknown_bl4); error++;
      }
    perssubentmanager->unknown_bl4--;

  }
  {
    BITCODE_BL unknown_bl5;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5, NULL) &&
        unknown_bl5 == perssubentmanager->unknown_bl5)
      pass ("PERSSUBENTMANAGER.unknown_bl5 [BL] %u", unknown_bl5);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl5 [BL] %u != %u", perssubentmanager->unknown_bl5, unknown_bl5); error++;
      }
    unknown_bl5++;
    if (dwg_dynapi_entity_set_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5) &&
        unknown_bl5 == perssubentmanager->unknown_bl5)
      pass ("PERSSUBENTMANAGER.unknown_bl5 [BL] set+1 %u", unknown_bl5);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl5 [BL] set+1 %u != %u", perssubentmanager->unknown_bl5, unknown_bl5); error++;
      }
    perssubentmanager->unknown_bl5--;

  }
  {
    BITCODE_BL unknown_bl6;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, NULL) &&
        unknown_bl6 == perssubentmanager->unknown_bl6)
      pass ("PERSSUBENTMANAGER.unknown_bl6 [BL] %u", unknown_bl6);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl6 [BL] %u != %u", perssubentmanager->unknown_bl6, unknown_bl6); error++;
      }
    unknown_bl6++;
    if (dwg_dynapi_entity_set_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6) &&
        unknown_bl6 == perssubentmanager->unknown_bl6)
      pass ("PERSSUBENTMANAGER.unknown_bl6 [BL] set+1 %u", unknown_bl6);
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl6 [BL] set+1 %u != %u", perssubentmanager->unknown_bl6, unknown_bl6); error++;
      }
    perssubentmanager->unknown_bl6--;

  }
  return error;
}
static int test_PLACEHOLDER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_PLACEHOLDER *placeholder = obj->tio.object->tio.PLACEHOLDER;
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(placeholder, "PLACEHOLDER", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &placeholder->ownerhandle, sizeof(placeholder->ownerhandle)))
      pass ("PLACEHOLDER.ownerhandle [H]");
    else
      {
        fail ("PLACEHOLDER.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(placeholder, "PLACEHOLDER", "parent", &parent, NULL)
        && !memcmp(&parent, &placeholder->parent, sizeof(placeholder->parent)))
      pass ("PLACEHOLDER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("PLACEHOLDER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_PLOTSETTINGS (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_PLOTSETTINGS *plotsettings = obj->tio.object->tio.PLOTSETTINGS;
  {
    BITCODE_BD bottom_margin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "bottom_margin", &bottom_margin, NULL) &&
        bottom_margin == plotsettings->bottom_margin)
      pass ("PLOTSETTINGS.bottom_margin [BD] %g", bottom_margin);
    else
      {
        fail ("PLOTSETTINGS.bottom_margin [BD] %g != %g", plotsettings->bottom_margin, bottom_margin); error++;
      }
    bottom_margin++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "bottom_margin", &bottom_margin) &&
        bottom_margin == plotsettings->bottom_margin)
      pass ("PLOTSETTINGS.bottom_margin [BD] set+1 %g", bottom_margin);
    else
      {
        fail ("PLOTSETTINGS.bottom_margin [BD] set+1 %g != %g", plotsettings->bottom_margin, bottom_margin); error++;
      }
    plotsettings->bottom_margin--;

  }
  {
    BITCODE_BD den_custom_print_scale;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "den_custom_print_scale", &den_custom_print_scale, NULL) &&
        den_custom_print_scale == plotsettings->den_custom_print_scale)
      pass ("PLOTSETTINGS.den_custom_print_scale [BD] %g", den_custom_print_scale);
    else
      {
        fail ("PLOTSETTINGS.den_custom_print_scale [BD] %g != %g", plotsettings->den_custom_print_scale, den_custom_print_scale); error++;
      }
    den_custom_print_scale++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "den_custom_print_scale", &den_custom_print_scale) &&
        den_custom_print_scale == plotsettings->den_custom_print_scale)
      pass ("PLOTSETTINGS.den_custom_print_scale [BD] set+1 %g", den_custom_print_scale);
    else
      {
        fail ("PLOTSETTINGS.den_custom_print_scale [BD] set+1 %g != %g", plotsettings->den_custom_print_scale, den_custom_print_scale); error++;
      }
    plotsettings->den_custom_print_scale--;

  }
  {
    BITCODE_BD left_margin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "left_margin", &left_margin, NULL) &&
        left_margin == plotsettings->left_margin)
      pass ("PLOTSETTINGS.left_margin [BD] %g", left_margin);
    else
      {
        fail ("PLOTSETTINGS.left_margin [BD] %g != %g", plotsettings->left_margin, left_margin); error++;
      }
    left_margin++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "left_margin", &left_margin) &&
        left_margin == plotsettings->left_margin)
      pass ("PLOTSETTINGS.left_margin [BD] set+1 %g", left_margin);
    else
      {
        fail ("PLOTSETTINGS.left_margin [BD] set+1 %g != %g", plotsettings->left_margin, left_margin); error++;
      }
    plotsettings->left_margin--;

  }
  {
    BITCODE_BD num_custom_print_scale;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "num_custom_print_scale", &num_custom_print_scale, NULL) &&
        num_custom_print_scale == plotsettings->num_custom_print_scale)
      pass ("PLOTSETTINGS.num_custom_print_scale [BD] %g", num_custom_print_scale);
    else
      {
        fail ("PLOTSETTINGS.num_custom_print_scale [BD] %g != %g", plotsettings->num_custom_print_scale, num_custom_print_scale); error++;
      }
    num_custom_print_scale++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "num_custom_print_scale", &num_custom_print_scale) &&
        num_custom_print_scale == plotsettings->num_custom_print_scale)
      pass ("PLOTSETTINGS.num_custom_print_scale [BD] set+1 %g", num_custom_print_scale);
    else
      {
        fail ("PLOTSETTINGS.num_custom_print_scale [BD] set+1 %g != %g", plotsettings->num_custom_print_scale, num_custom_print_scale); error++;
      }
    plotsettings->num_custom_print_scale--;

  }
  {
    BITCODE_T page_setup_name;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "page_setup_name", &page_setup_name, NULL)
        && !memcmp(&page_setup_name, &plotsettings->page_setup_name, sizeof(plotsettings->page_setup_name)))
      pass ("PLOTSETTINGS.page_setup_name [T]");
    else
      {
        fail ("PLOTSETTINGS.page_setup_name [T]"); error++;
      }
  }
  {
    BITCODE_BD paper_height;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "paper_height", &paper_height, NULL) &&
        paper_height == plotsettings->paper_height)
      pass ("PLOTSETTINGS.paper_height [BD] %g", paper_height);
    else
      {
        fail ("PLOTSETTINGS.paper_height [BD] %g != %g", plotsettings->paper_height, paper_height); error++;
      }
    paper_height++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "paper_height", &paper_height) &&
        paper_height == plotsettings->paper_height)
      pass ("PLOTSETTINGS.paper_height [BD] set+1 %g", paper_height);
    else
      {
        fail ("PLOTSETTINGS.paper_height [BD] set+1 %g != %g", plotsettings->paper_height, paper_height); error++;
      }
    plotsettings->paper_height--;

  }
  {
    BITCODE_2BD paper_image_origin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "paper_image_origin", &paper_image_origin, NULL)
        && !memcmp(&paper_image_origin, &plotsettings->paper_image_origin, sizeof(plotsettings->paper_image_origin)))
      pass ("PLOTSETTINGS.paper_image_origin [2BD]");
    else
      {
        fail ("PLOTSETTINGS.paper_image_origin [2BD]"); error++;
      }
  }
  {
    BITCODE_T paper_size;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "paper_size", &paper_size, NULL)
        && !memcmp(&paper_size, &plotsettings->paper_size, sizeof(plotsettings->paper_size)))
      pass ("PLOTSETTINGS.paper_size [T]");
    else
      {
        fail ("PLOTSETTINGS.paper_size [T]"); error++;
      }
  }
  {
    BITCODE_BD paper_width;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "paper_width", &paper_width, NULL) &&
        paper_width == plotsettings->paper_width)
      pass ("PLOTSETTINGS.paper_width [BD] %g", paper_width);
    else
      {
        fail ("PLOTSETTINGS.paper_width [BD] %g != %g", plotsettings->paper_width, paper_width); error++;
      }
    paper_width++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "paper_width", &paper_width) &&
        paper_width == plotsettings->paper_width)
      pass ("PLOTSETTINGS.paper_width [BD] set+1 %g", paper_width);
    else
      {
        fail ("PLOTSETTINGS.paper_width [BD] set+1 %g != %g", plotsettings->paper_width, paper_width); error++;
      }
    plotsettings->paper_width--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "parent", &parent, NULL)
        && !memcmp(&parent, &plotsettings->parent, sizeof(plotsettings->parent)))
      pass ("PLOTSETTINGS.parent [struct _dwg_object_object*]");
    else
      {
        fail ("PLOTSETTINGS.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BS plot_layout;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_layout", &plot_layout, NULL) &&
        plot_layout == plotsettings->plot_layout)
      pass ("PLOTSETTINGS.plot_layout [BS] %hu", plot_layout);
    else
      {
        fail ("PLOTSETTINGS.plot_layout [BS] %hu != %hu", plotsettings->plot_layout, plot_layout); error++;
      }
    plot_layout++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "plot_layout", &plot_layout) &&
        plot_layout == plotsettings->plot_layout)
      pass ("PLOTSETTINGS.plot_layout [BS] set+1 %hu", plot_layout);
    else
      {
        fail ("PLOTSETTINGS.plot_layout [BS] set+1 %hu != %hu", plotsettings->plot_layout, plot_layout); error++;
      }
    plotsettings->plot_layout--;

  }
  {
    BITCODE_2BD plot_origin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_origin", &plot_origin, NULL)
        && !memcmp(&plot_origin, &plotsettings->plot_origin, sizeof(plotsettings->plot_origin)))
      pass ("PLOTSETTINGS.plot_origin [2BD]");
    else
      {
        fail ("PLOTSETTINGS.plot_origin [2BD]"); error++;
      }
  }
  {
    BITCODE_BS plot_paper_units;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_paper_units", &plot_paper_units, NULL) &&
        plot_paper_units == plotsettings->plot_paper_units)
      pass ("PLOTSETTINGS.plot_paper_units [BS] %hu", plot_paper_units);
    else
      {
        fail ("PLOTSETTINGS.plot_paper_units [BS] %hu != %hu", plotsettings->plot_paper_units, plot_paper_units); error++;
      }
    plot_paper_units++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "plot_paper_units", &plot_paper_units) &&
        plot_paper_units == plotsettings->plot_paper_units)
      pass ("PLOTSETTINGS.plot_paper_units [BS] set+1 %hu", plot_paper_units);
    else
      {
        fail ("PLOTSETTINGS.plot_paper_units [BS] set+1 %hu != %hu", plotsettings->plot_paper_units, plot_paper_units); error++;
      }
    plotsettings->plot_paper_units--;

  }
  {
    BITCODE_BS plot_rotation;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_rotation", &plot_rotation, NULL) &&
        plot_rotation == plotsettings->plot_rotation)
      pass ("PLOTSETTINGS.plot_rotation [BS] %hu", plot_rotation);
    else
      {
        fail ("PLOTSETTINGS.plot_rotation [BS] %hu != %hu", plotsettings->plot_rotation, plot_rotation); error++;
      }
    plot_rotation++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "plot_rotation", &plot_rotation) &&
        plot_rotation == plotsettings->plot_rotation)
      pass ("PLOTSETTINGS.plot_rotation [BS] set+1 %hu", plot_rotation);
    else
      {
        fail ("PLOTSETTINGS.plot_rotation [BS] set+1 %hu != %hu", plotsettings->plot_rotation, plot_rotation); error++;
      }
    plotsettings->plot_rotation--;

  }
  {
    BITCODE_BS plot_type;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_type", &plot_type, NULL) &&
        plot_type == plotsettings->plot_type)
      pass ("PLOTSETTINGS.plot_type [BS] %hu", plot_type);
    else
      {
        fail ("PLOTSETTINGS.plot_type [BS] %hu != %hu", plotsettings->plot_type, plot_type); error++;
      }
    plot_type++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "plot_type", &plot_type) &&
        plot_type == plotsettings->plot_type)
      pass ("PLOTSETTINGS.plot_type [BS] set+1 %hu", plot_type);
    else
      {
        fail ("PLOTSETTINGS.plot_type [BS] set+1 %hu != %hu", plotsettings->plot_type, plot_type); error++;
      }
    plotsettings->plot_type--;

  }
  {
    BITCODE_2BD plot_window_ll;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_window_ll", &plot_window_ll, NULL)
        && !memcmp(&plot_window_ll, &plotsettings->plot_window_ll, sizeof(plotsettings->plot_window_ll)))
      pass ("PLOTSETTINGS.plot_window_ll [2BD]");
    else
      {
        fail ("PLOTSETTINGS.plot_window_ll [2BD]"); error++;
      }
  }
  {
    BITCODE_2BD plot_window_ur;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_window_ur", &plot_window_ur, NULL)
        && !memcmp(&plot_window_ur, &plotsettings->plot_window_ur, sizeof(plotsettings->plot_window_ur)))
      pass ("PLOTSETTINGS.plot_window_ur [2BD]");
    else
      {
        fail ("PLOTSETTINGS.plot_window_ur [2BD]"); error++;
      }
  }
  {
    BITCODE_H plotview;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plotview", &plotview, NULL)
        && !memcmp(&plotview, &plotsettings->plotview, sizeof(plotsettings->plotview)))
      pass ("PLOTSETTINGS.plotview [H]");
    else
      {
        fail ("PLOTSETTINGS.plotview [H]"); error++;
      }
  }
  {
    BITCODE_T printer_cfg_file;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "printer_cfg_file", &printer_cfg_file, NULL)
        && !memcmp(&printer_cfg_file, &plotsettings->printer_cfg_file, sizeof(plotsettings->printer_cfg_file)))
      pass ("PLOTSETTINGS.printer_cfg_file [T]");
    else
      {
        fail ("PLOTSETTINGS.printer_cfg_file [T]"); error++;
      }
  }
  {
    BITCODE_BD right_margin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "right_margin", &right_margin, NULL) &&
        right_margin == plotsettings->right_margin)
      pass ("PLOTSETTINGS.right_margin [BD] %g", right_margin);
    else
      {
        fail ("PLOTSETTINGS.right_margin [BD] %g != %g", plotsettings->right_margin, right_margin); error++;
      }
    right_margin++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "right_margin", &right_margin) &&
        right_margin == plotsettings->right_margin)
      pass ("PLOTSETTINGS.right_margin [BD] set+1 %g", right_margin);
    else
      {
        fail ("PLOTSETTINGS.right_margin [BD] set+1 %g != %g", plotsettings->right_margin, right_margin); error++;
      }
    plotsettings->right_margin--;

  }
  {
    BITCODE_BS shade_plot_custom_dpi;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "shade_plot_custom_dpi", &shade_plot_custom_dpi, NULL) &&
        shade_plot_custom_dpi == plotsettings->shade_plot_custom_dpi)
      pass ("PLOTSETTINGS.shade_plot_custom_dpi [BS] %hu", shade_plot_custom_dpi);
    else
      {
        fail ("PLOTSETTINGS.shade_plot_custom_dpi [BS] %hu != %hu", plotsettings->shade_plot_custom_dpi, shade_plot_custom_dpi); error++;
      }
    shade_plot_custom_dpi++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "shade_plot_custom_dpi", &shade_plot_custom_dpi) &&
        shade_plot_custom_dpi == plotsettings->shade_plot_custom_dpi)
      pass ("PLOTSETTINGS.shade_plot_custom_dpi [BS] set+1 %hu", shade_plot_custom_dpi);
    else
      {
        fail ("PLOTSETTINGS.shade_plot_custom_dpi [BS] set+1 %hu != %hu", plotsettings->shade_plot_custom_dpi, shade_plot_custom_dpi); error++;
      }
    plotsettings->shade_plot_custom_dpi--;

  }
  {
    BITCODE_H shade_plot_id;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "shade_plot_id", &shade_plot_id, NULL)
        && !memcmp(&shade_plot_id, &plotsettings->shade_plot_id, sizeof(plotsettings->shade_plot_id)))
      pass ("PLOTSETTINGS.shade_plot_id [H]");
    else
      {
        fail ("PLOTSETTINGS.shade_plot_id [H]"); error++;
      }
  }
  {
    BITCODE_BS shade_plot_mode;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "shade_plot_mode", &shade_plot_mode, NULL) &&
        shade_plot_mode == plotsettings->shade_plot_mode)
      pass ("PLOTSETTINGS.shade_plot_mode [BS] %hu", shade_plot_mode);
    else
      {
        fail ("PLOTSETTINGS.shade_plot_mode [BS] %hu != %hu", plotsettings->shade_plot_mode, shade_plot_mode); error++;
      }
    shade_plot_mode++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "shade_plot_mode", &shade_plot_mode) &&
        shade_plot_mode == plotsettings->shade_plot_mode)
      pass ("PLOTSETTINGS.shade_plot_mode [BS] set+1 %hu", shade_plot_mode);
    else
      {
        fail ("PLOTSETTINGS.shade_plot_mode [BS] set+1 %hu != %hu", plotsettings->shade_plot_mode, shade_plot_mode); error++;
      }
    plotsettings->shade_plot_mode--;

  }
  {
    BITCODE_BS shade_plot_res_level;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "shade_plot_res_level", &shade_plot_res_level, NULL) &&
        shade_plot_res_level == plotsettings->shade_plot_res_level)
      pass ("PLOTSETTINGS.shade_plot_res_level [BS] %hu", shade_plot_res_level);
    else
      {
        fail ("PLOTSETTINGS.shade_plot_res_level [BS] %hu != %hu", plotsettings->shade_plot_res_level, shade_plot_res_level); error++;
      }
    shade_plot_res_level++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "shade_plot_res_level", &shade_plot_res_level) &&
        shade_plot_res_level == plotsettings->shade_plot_res_level)
      pass ("PLOTSETTINGS.shade_plot_res_level [BS] set+1 %hu", shade_plot_res_level);
    else
      {
        fail ("PLOTSETTINGS.shade_plot_res_level [BS] set+1 %hu != %hu", plotsettings->shade_plot_res_level, shade_plot_res_level); error++;
      }
    plotsettings->shade_plot_res_level--;

  }
  {
    BITCODE_BD std_scale_factor;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "std_scale_factor", &std_scale_factor, NULL) &&
        std_scale_factor == plotsettings->std_scale_factor)
      pass ("PLOTSETTINGS.std_scale_factor [BD] %g", std_scale_factor);
    else
      {
        fail ("PLOTSETTINGS.std_scale_factor [BD] %g != %g", plotsettings->std_scale_factor, std_scale_factor); error++;
      }
    std_scale_factor++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "std_scale_factor", &std_scale_factor) &&
        std_scale_factor == plotsettings->std_scale_factor)
      pass ("PLOTSETTINGS.std_scale_factor [BD] set+1 %g", std_scale_factor);
    else
      {
        fail ("PLOTSETTINGS.std_scale_factor [BD] set+1 %g != %g", plotsettings->std_scale_factor, std_scale_factor); error++;
      }
    plotsettings->std_scale_factor--;

  }
  {
    BITCODE_BS std_scale_type;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "std_scale_type", &std_scale_type, NULL) &&
        std_scale_type == plotsettings->std_scale_type)
      pass ("PLOTSETTINGS.std_scale_type [BS] %hu", std_scale_type);
    else
      {
        fail ("PLOTSETTINGS.std_scale_type [BS] %hu != %hu", plotsettings->std_scale_type, std_scale_type); error++;
      }
    std_scale_type++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "std_scale_type", &std_scale_type) &&
        std_scale_type == plotsettings->std_scale_type)
      pass ("PLOTSETTINGS.std_scale_type [BS] set+1 %hu", std_scale_type);
    else
      {
        fail ("PLOTSETTINGS.std_scale_type [BS] set+1 %hu != %hu", plotsettings->std_scale_type, std_scale_type); error++;
      }
    plotsettings->std_scale_type--;

  }
  {
    BITCODE_H stylesheet;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "stylesheet", &stylesheet, NULL)
        && !memcmp(&stylesheet, &plotsettings->stylesheet, sizeof(plotsettings->stylesheet)))
      pass ("PLOTSETTINGS.stylesheet [H]");
    else
      {
        fail ("PLOTSETTINGS.stylesheet [H]"); error++;
      }
  }
  {
    BITCODE_BD top_margin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "top_margin", &top_margin, NULL) &&
        top_margin == plotsettings->top_margin)
      pass ("PLOTSETTINGS.top_margin [BD] %g", top_margin);
    else
      {
        fail ("PLOTSETTINGS.top_margin [BD] %g != %g", plotsettings->top_margin, top_margin); error++;
      }
    top_margin++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "top_margin", &top_margin) &&
        top_margin == plotsettings->top_margin)
      pass ("PLOTSETTINGS.top_margin [BD] set+1 %g", top_margin);
    else
      {
        fail ("PLOTSETTINGS.top_margin [BD] set+1 %g != %g", plotsettings->top_margin, top_margin); error++;
      }
    plotsettings->top_margin--;

  }
  {
    BITCODE_B use_std_scale;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "use_std_scale", &use_std_scale, NULL) &&
        use_std_scale == plotsettings->use_std_scale)
      pass ("PLOTSETTINGS.use_std_scale [B] " FORMAT_B "", use_std_scale);
    else
      {
        fail ("PLOTSETTINGS.use_std_scale [B] " FORMAT_B " != " FORMAT_B "", plotsettings->use_std_scale, use_std_scale); error++;
      }
    use_std_scale++;
    if (dwg_dynapi_entity_set_value(plotsettings, "PLOTSETTINGS", "use_std_scale", &use_std_scale) &&
        use_std_scale == plotsettings->use_std_scale)
      pass ("PLOTSETTINGS.use_std_scale [B] set+1 " FORMAT_B "", use_std_scale);
    else
      {
        fail ("PLOTSETTINGS.use_std_scale [B] set+1 " FORMAT_B " != " FORMAT_B "", plotsettings->use_std_scale, use_std_scale); error++;
      }
    plotsettings->use_std_scale--;

  }
  return error;
}
static int test_PROXY_OBJECT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_PROXY_OBJECT *proxy_object = obj->tio.object->tio.PROXY_OBJECT;
  {
    BITCODE_BL class_id;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "class_id", &class_id, NULL) &&
        class_id == proxy_object->class_id)
      pass ("PROXY_OBJECT.class_id [BL] %u", class_id);
    else
      {
        fail ("PROXY_OBJECT.class_id [BL] %u != %u", proxy_object->class_id, class_id); error++;
      }
    class_id++;
    if (dwg_dynapi_entity_set_value(proxy_object, "PROXY_OBJECT", "class_id", &class_id) &&
        class_id == proxy_object->class_id)
      pass ("PROXY_OBJECT.class_id [BL] set+1 %u", class_id);
    else
      {
        fail ("PROXY_OBJECT.class_id [BL] set+1 %u != %u", proxy_object->class_id, class_id); error++;
      }
    proxy_object->class_id--;

  }
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "data", &data, NULL)
        && !strcmp((char*)&data, (char*)&proxy_object->data))
      pass ("PROXY_OBJECT.data [TV]");
    else
      {
        fail ("PROXY_OBJECT.data [TV]"); error++;
      }
  }
  {
    BITCODE_B from_dxf;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "from_dxf", &from_dxf, NULL) &&
        from_dxf == proxy_object->from_dxf)
      pass ("PROXY_OBJECT.from_dxf [B] " FORMAT_B "", from_dxf);
    else
      {
        fail ("PROXY_OBJECT.from_dxf [B] " FORMAT_B " != " FORMAT_B "", proxy_object->from_dxf, from_dxf); error++;
      }
    from_dxf++;
    if (dwg_dynapi_entity_set_value(proxy_object, "PROXY_OBJECT", "from_dxf", &from_dxf) &&
        from_dxf == proxy_object->from_dxf)
      pass ("PROXY_OBJECT.from_dxf [B] set+1 " FORMAT_B "", from_dxf);
    else
      {
        fail ("PROXY_OBJECT.from_dxf [B] set+1 " FORMAT_B " != " FORMAT_B "", proxy_object->from_dxf, from_dxf); error++;
      }
    proxy_object->from_dxf--;

  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "maint_version", &maint_version, NULL) &&
        maint_version == proxy_object->maint_version)
      pass ("PROXY_OBJECT.maint_version [BL] %u", maint_version);
    else
      {
        fail ("PROXY_OBJECT.maint_version [BL] %u != %u", proxy_object->maint_version, maint_version); error++;
      }
    maint_version++;
    if (dwg_dynapi_entity_set_value(proxy_object, "PROXY_OBJECT", "maint_version", &maint_version) &&
        maint_version == proxy_object->maint_version)
      pass ("PROXY_OBJECT.maint_version [BL] set+1 %u", maint_version);
    else
      {
        fail ("PROXY_OBJECT.maint_version [BL] set+1 %u != %u", proxy_object->maint_version, maint_version); error++;
      }
    proxy_object->maint_version--;

  }
  {
    BITCODE_H* objid_object_handles;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "objid_object_handles", &objid_object_handles, NULL)
        && !memcmp(&objid_object_handles, &proxy_object->objid_object_handles, sizeof(proxy_object->objid_object_handles)))
      pass ("PROXY_OBJECT.objid_object_handles [H*]");
    else
      {
        fail ("PROXY_OBJECT.objid_object_handles [H*]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &proxy_object->ownerhandle, sizeof(proxy_object->ownerhandle)))
      pass ("PROXY_OBJECT.ownerhandle [H]");
    else
      {
        fail ("PROXY_OBJECT.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "parent", &parent, NULL)
        && !memcmp(&parent, &proxy_object->parent, sizeof(proxy_object->parent)))
      pass ("PROXY_OBJECT.parent [struct _dwg_object_object*]");
    else
      {
        fail ("PROXY_OBJECT.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "version", &version, NULL) &&
        version == proxy_object->version)
      pass ("PROXY_OBJECT.version [BL] %u", version);
    else
      {
        fail ("PROXY_OBJECT.version [BL] %u != %u", proxy_object->version, version); error++;
      }
    version++;
    if (dwg_dynapi_entity_set_value(proxy_object, "PROXY_OBJECT", "version", &version) &&
        version == proxy_object->version)
      pass ("PROXY_OBJECT.version [BL] set+1 %u", version);
    else
      {
        fail ("PROXY_OBJECT.version [BL] set+1 %u != %u", proxy_object->version, version); error++;
      }
    proxy_object->version--;

  }
  return error;
}
static int test_RASTERVARIABLES (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_RASTERVARIABLES *rastervariables = obj->tio.object->tio.RASTERVARIABLES;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "class_version", &class_version, NULL) &&
        class_version == rastervariables->class_version)
      pass ("RASTERVARIABLES.class_version [BL] %u", class_version);
    else
      {
        fail ("RASTERVARIABLES.class_version [BL] %u != %u", rastervariables->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(rastervariables, "RASTERVARIABLES", "class_version", &class_version) &&
        class_version == rastervariables->class_version)
      pass ("RASTERVARIABLES.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("RASTERVARIABLES.class_version [BL] set+1 %u != %u", rastervariables->class_version, class_version); error++;
      }
    rastervariables->class_version--;

  }
  {
    BITCODE_BS display_frame;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "display_frame", &display_frame, NULL) &&
        display_frame == rastervariables->display_frame)
      pass ("RASTERVARIABLES.display_frame [BS] %hu", display_frame);
    else
      {
        fail ("RASTERVARIABLES.display_frame [BS] %hu != %hu", rastervariables->display_frame, display_frame); error++;
      }
    display_frame++;
    if (dwg_dynapi_entity_set_value(rastervariables, "RASTERVARIABLES", "display_frame", &display_frame) &&
        display_frame == rastervariables->display_frame)
      pass ("RASTERVARIABLES.display_frame [BS] set+1 %hu", display_frame);
    else
      {
        fail ("RASTERVARIABLES.display_frame [BS] set+1 %hu != %hu", rastervariables->display_frame, display_frame); error++;
      }
    rastervariables->display_frame--;

  }
  {
    BITCODE_BS display_quality;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "display_quality", &display_quality, NULL) &&
        display_quality == rastervariables->display_quality)
      pass ("RASTERVARIABLES.display_quality [BS] %hu", display_quality);
    else
      {
        fail ("RASTERVARIABLES.display_quality [BS] %hu != %hu", rastervariables->display_quality, display_quality); error++;
      }
    display_quality++;
    if (dwg_dynapi_entity_set_value(rastervariables, "RASTERVARIABLES", "display_quality", &display_quality) &&
        display_quality == rastervariables->display_quality)
      pass ("RASTERVARIABLES.display_quality [BS] set+1 %hu", display_quality);
    else
      {
        fail ("RASTERVARIABLES.display_quality [BS] set+1 %hu != %hu", rastervariables->display_quality, display_quality); error++;
      }
    rastervariables->display_quality--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &rastervariables->ownerhandle, sizeof(rastervariables->ownerhandle)))
      pass ("RASTERVARIABLES.ownerhandle [H]");
    else
      {
        fail ("RASTERVARIABLES.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "parent", &parent, NULL)
        && !memcmp(&parent, &rastervariables->parent, sizeof(rastervariables->parent)))
      pass ("RASTERVARIABLES.parent [struct _dwg_object_object*]");
    else
      {
        fail ("RASTERVARIABLES.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BS units;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "units", &units, NULL) &&
        units == rastervariables->units)
      pass ("RASTERVARIABLES.units [BS] %hu", units);
    else
      {
        fail ("RASTERVARIABLES.units [BS] %hu != %hu", rastervariables->units, units); error++;
      }
    units++;
    if (dwg_dynapi_entity_set_value(rastervariables, "RASTERVARIABLES", "units", &units) &&
        units == rastervariables->units)
      pass ("RASTERVARIABLES.units [BS] set+1 %hu", units);
    else
      {
        fail ("RASTERVARIABLES.units [BS] set+1 %hu != %hu", rastervariables->units, units); error++;
      }
    rastervariables->units--;

  }
  return error;
}
static int test_SCALE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SCALE *scale = obj->tio.object->tio.SCALE;
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value(scale, "SCALE", "drawing_units", &drawing_units, NULL) &&
        drawing_units == scale->drawing_units)
      pass ("SCALE.drawing_units [BD] %g", drawing_units);
    else
      {
        fail ("SCALE.drawing_units [BD] %g != %g", scale->drawing_units, drawing_units); error++;
      }
    drawing_units++;
    if (dwg_dynapi_entity_set_value(scale, "SCALE", "drawing_units", &drawing_units) &&
        drawing_units == scale->drawing_units)
      pass ("SCALE.drawing_units [BD] set+1 %g", drawing_units);
    else
      {
        fail ("SCALE.drawing_units [BD] set+1 %g != %g", scale->drawing_units, drawing_units); error++;
      }
    scale->drawing_units--;

  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(scale, "SCALE", "flag", &flag, NULL) &&
        flag == scale->flag)
      pass ("SCALE.flag [BS] %hu", flag);
    else
      {
        fail ("SCALE.flag [BS] %hu != %hu", scale->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(scale, "SCALE", "flag", &flag) &&
        flag == scale->flag)
      pass ("SCALE.flag [BS] set+1 %hu", flag);
    else
      {
        fail ("SCALE.flag [BS] set+1 %hu != %hu", scale->flag, flag); error++;
      }
    scale->flag--;

  }
  {
    BITCODE_B has_unit_scale;
    if (dwg_dynapi_entity_value(scale, "SCALE", "has_unit_scale", &has_unit_scale, NULL) &&
        has_unit_scale == scale->has_unit_scale)
      pass ("SCALE.has_unit_scale [B] " FORMAT_B "", has_unit_scale);
    else
      {
        fail ("SCALE.has_unit_scale [B] " FORMAT_B " != " FORMAT_B "", scale->has_unit_scale, has_unit_scale); error++;
      }
    has_unit_scale++;
    if (dwg_dynapi_entity_set_value(scale, "SCALE", "has_unit_scale", &has_unit_scale) &&
        has_unit_scale == scale->has_unit_scale)
      pass ("SCALE.has_unit_scale [B] set+1 " FORMAT_B "", has_unit_scale);
    else
      {
        fail ("SCALE.has_unit_scale [B] set+1 " FORMAT_B " != " FORMAT_B "", scale->has_unit_scale, has_unit_scale); error++;
      }
    scale->has_unit_scale--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(scale, "SCALE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&scale->name))
      pass ("SCALE.name [TV]");
    else
      {
        fail ("SCALE.name [TV]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(scale, "SCALE", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &scale->ownerhandle, sizeof(scale->ownerhandle)))
      pass ("SCALE.ownerhandle [H]");
    else
      {
        fail ("SCALE.ownerhandle [H]"); error++;
      }
  }
  {
    BITCODE_BD paper_units;
    if (dwg_dynapi_entity_value(scale, "SCALE", "paper_units", &paper_units, NULL) &&
        paper_units == scale->paper_units)
      pass ("SCALE.paper_units [BD] %g", paper_units);
    else
      {
        fail ("SCALE.paper_units [BD] %g != %g", scale->paper_units, paper_units); error++;
      }
    paper_units++;
    if (dwg_dynapi_entity_set_value(scale, "SCALE", "paper_units", &paper_units) &&
        paper_units == scale->paper_units)
      pass ("SCALE.paper_units [BD] set+1 %g", paper_units);
    else
      {
        fail ("SCALE.paper_units [BD] set+1 %g != %g", scale->paper_units, paper_units); error++;
      }
    scale->paper_units--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(scale, "SCALE", "parent", &parent, NULL)
        && !memcmp(&parent, &scale->parent, sizeof(scale->parent)))
      pass ("SCALE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("SCALE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_SORTENTSTABLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SORTENTSTABLE *sortentstable = obj->tio.object->tio.SORTENTSTABLE;
  {
    BITCODE_H* ents;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "ents", &ents, NULL)
        && !memcmp(&ents, &sortentstable->ents, sizeof(sortentstable->ents)))
      pass ("SORTENTSTABLE.ents [H*]");
    else
      {
        fail ("SORTENTSTABLE.ents [H*]"); error++;
      }
  }
  {
    BITCODE_BL num_ents;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "num_ents", &num_ents, NULL) &&
        num_ents == sortentstable->num_ents)
      pass ("SORTENTSTABLE.num_ents [BL] %u", num_ents);
    else
      {
        fail ("SORTENTSTABLE.num_ents [BL] %u != %u", sortentstable->num_ents, num_ents); error++;
      }
    num_ents++;
    if (dwg_dynapi_entity_set_value(sortentstable, "SORTENTSTABLE", "num_ents", &num_ents) &&
        num_ents == sortentstable->num_ents)
      pass ("SORTENTSTABLE.num_ents [BL] set+1 %u", num_ents);
    else
      {
        fail ("SORTENTSTABLE.num_ents [BL] set+1 %u != %u", sortentstable->num_ents, num_ents); error++;
      }
    sortentstable->num_ents--;

  }
  {
    BITCODE_H owner_dict;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "owner_dict", &owner_dict, NULL)
        && !memcmp(&owner_dict, &sortentstable->owner_dict, sizeof(sortentstable->owner_dict)))
      pass ("SORTENTSTABLE.owner_dict [H]");
    else
      {
        fail ("SORTENTSTABLE.owner_dict [H]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &sortentstable->ownerhandle, sizeof(sortentstable->ownerhandle)))
      pass ("SORTENTSTABLE.ownerhandle [H]");
    else
      {
        fail ("SORTENTSTABLE.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "parent", &parent, NULL)
        && !memcmp(&parent, &sortentstable->parent, sizeof(sortentstable->parent)))
      pass ("SORTENTSTABLE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("SORTENTSTABLE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H* sort_handles;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "sort_handles", &sort_handles, NULL)
        && !memcmp(&sort_handles, &sortentstable->sort_handles, sizeof(sortentstable->sort_handles)))
      pass ("SORTENTSTABLE.sort_handles [H*]");
    else
      {
        fail ("SORTENTSTABLE.sort_handles [H*]"); error++;
      }
  }
  return error;
}
static int test_SPATIAL_FILTER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SPATIAL_FILTER *spatial_filter = obj->tio.object->tio.SPATIAL_FILTER;
  {
    BITCODE_BD back_clip_dist;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "back_clip_dist", &back_clip_dist, NULL) &&
        back_clip_dist == spatial_filter->back_clip_dist)
      pass ("SPATIAL_FILTER.back_clip_dist [BD] %g", back_clip_dist);
    else
      {
        fail ("SPATIAL_FILTER.back_clip_dist [BD] %g != %g", spatial_filter->back_clip_dist, back_clip_dist); error++;
      }
    back_clip_dist++;
    if (dwg_dynapi_entity_set_value(spatial_filter, "SPATIAL_FILTER", "back_clip_dist", &back_clip_dist) &&
        back_clip_dist == spatial_filter->back_clip_dist)
      pass ("SPATIAL_FILTER.back_clip_dist [BD] set+1 %g", back_clip_dist);
    else
      {
        fail ("SPATIAL_FILTER.back_clip_dist [BD] set+1 %g != %g", spatial_filter->back_clip_dist, back_clip_dist); error++;
      }
    spatial_filter->back_clip_dist--;

  }
  {
    BITCODE_BS back_clip_on;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "back_clip_on", &back_clip_on, NULL) &&
        back_clip_on == spatial_filter->back_clip_on)
      pass ("SPATIAL_FILTER.back_clip_on [BS] %hu", back_clip_on);
    else
      {
        fail ("SPATIAL_FILTER.back_clip_on [BS] %hu != %hu", spatial_filter->back_clip_on, back_clip_on); error++;
      }
    back_clip_on++;
    if (dwg_dynapi_entity_set_value(spatial_filter, "SPATIAL_FILTER", "back_clip_on", &back_clip_on) &&
        back_clip_on == spatial_filter->back_clip_on)
      pass ("SPATIAL_FILTER.back_clip_on [BS] set+1 %hu", back_clip_on);
    else
      {
        fail ("SPATIAL_FILTER.back_clip_on [BS] set+1 %hu != %hu", spatial_filter->back_clip_on, back_clip_on); error++;
      }
    spatial_filter->back_clip_on--;

  }
  {
    BITCODE_3BD clip_bound_origin;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "clip_bound_origin", &clip_bound_origin, NULL)
        && !memcmp(&clip_bound_origin, &spatial_filter->clip_bound_origin, sizeof(spatial_filter->clip_bound_origin)))
      pass ("SPATIAL_FILTER.clip_bound_origin [3BD]");
    else
      {
        fail ("SPATIAL_FILTER.clip_bound_origin [3BD]"); error++;
      }
  }
  {
    BITCODE_BD* clip_bound_transform;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "clip_bound_transform", &clip_bound_transform, NULL)
        && !memcmp(&clip_bound_transform, &spatial_filter->clip_bound_transform, sizeof(spatial_filter->clip_bound_transform)))
      pass ("SPATIAL_FILTER.clip_bound_transform [BD*]");
    else
      {
        fail ("SPATIAL_FILTER.clip_bound_transform [BD*]"); error++;
      }
  }
  {
    BITCODE_BS display_boundary;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "display_boundary", &display_boundary, NULL) &&
        display_boundary == spatial_filter->display_boundary)
      pass ("SPATIAL_FILTER.display_boundary [BS] %hu", display_boundary);
    else
      {
        fail ("SPATIAL_FILTER.display_boundary [BS] %hu != %hu", spatial_filter->display_boundary, display_boundary); error++;
      }
    display_boundary++;
    if (dwg_dynapi_entity_set_value(spatial_filter, "SPATIAL_FILTER", "display_boundary", &display_boundary) &&
        display_boundary == spatial_filter->display_boundary)
      pass ("SPATIAL_FILTER.display_boundary [BS] set+1 %hu", display_boundary);
    else
      {
        fail ("SPATIAL_FILTER.display_boundary [BS] set+1 %hu != %hu", spatial_filter->display_boundary, display_boundary); error++;
      }
    spatial_filter->display_boundary--;

  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &spatial_filter->extrusion, sizeof(spatial_filter->extrusion)))
      pass ("SPATIAL_FILTER.extrusion [3BD]");
    else
      {
        fail ("SPATIAL_FILTER.extrusion [3BD]"); error++;
      }
  }
  {
    BITCODE_BD front_clip_dist;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "front_clip_dist", &front_clip_dist, NULL) &&
        front_clip_dist == spatial_filter->front_clip_dist)
      pass ("SPATIAL_FILTER.front_clip_dist [BD] %g", front_clip_dist);
    else
      {
        fail ("SPATIAL_FILTER.front_clip_dist [BD] %g != %g", spatial_filter->front_clip_dist, front_clip_dist); error++;
      }
    front_clip_dist++;
    if (dwg_dynapi_entity_set_value(spatial_filter, "SPATIAL_FILTER", "front_clip_dist", &front_clip_dist) &&
        front_clip_dist == spatial_filter->front_clip_dist)
      pass ("SPATIAL_FILTER.front_clip_dist [BD] set+1 %g", front_clip_dist);
    else
      {
        fail ("SPATIAL_FILTER.front_clip_dist [BD] set+1 %g != %g", spatial_filter->front_clip_dist, front_clip_dist); error++;
      }
    spatial_filter->front_clip_dist--;

  }
  {
    BITCODE_BS front_clip_on;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "front_clip_on", &front_clip_on, NULL) &&
        front_clip_on == spatial_filter->front_clip_on)
      pass ("SPATIAL_FILTER.front_clip_on [BS] %hu", front_clip_on);
    else
      {
        fail ("SPATIAL_FILTER.front_clip_on [BS] %hu != %hu", spatial_filter->front_clip_on, front_clip_on); error++;
      }
    front_clip_on++;
    if (dwg_dynapi_entity_set_value(spatial_filter, "SPATIAL_FILTER", "front_clip_on", &front_clip_on) &&
        front_clip_on == spatial_filter->front_clip_on)
      pass ("SPATIAL_FILTER.front_clip_on [BS] set+1 %hu", front_clip_on);
    else
      {
        fail ("SPATIAL_FILTER.front_clip_on [BS] set+1 %hu != %hu", spatial_filter->front_clip_on, front_clip_on); error++;
      }
    spatial_filter->front_clip_on--;

  }
  {
    BITCODE_BD* inverse_block_transform;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "inverse_block_transform", &inverse_block_transform, NULL)
        && !memcmp(&inverse_block_transform, &spatial_filter->inverse_block_transform, sizeof(spatial_filter->inverse_block_transform)))
      pass ("SPATIAL_FILTER.inverse_block_transform [BD*]");
    else
      {
        fail ("SPATIAL_FILTER.inverse_block_transform [BD*]"); error++;
      }
  }
  {
    BITCODE_BS num_points;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "num_points", &num_points, NULL) &&
        num_points == spatial_filter->num_points)
      pass ("SPATIAL_FILTER.num_points [BS] %hu", num_points);
    else
      {
        fail ("SPATIAL_FILTER.num_points [BS] %hu != %hu", spatial_filter->num_points, num_points); error++;
      }
    num_points++;
    if (dwg_dynapi_entity_set_value(spatial_filter, "SPATIAL_FILTER", "num_points", &num_points) &&
        num_points == spatial_filter->num_points)
      pass ("SPATIAL_FILTER.num_points [BS] set+1 %hu", num_points);
    else
      {
        fail ("SPATIAL_FILTER.num_points [BS] set+1 %hu != %hu", spatial_filter->num_points, num_points); error++;
      }
    spatial_filter->num_points--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &spatial_filter->ownerhandle, sizeof(spatial_filter->ownerhandle)))
      pass ("SPATIAL_FILTER.ownerhandle [H]");
    else
      {
        fail ("SPATIAL_FILTER.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "parent", &parent, NULL)
        && !memcmp(&parent, &spatial_filter->parent, sizeof(spatial_filter->parent)))
      pass ("SPATIAL_FILTER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("SPATIAL_FILTER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_2RD* points;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "points", &points, NULL)
        && !memcmp(&points, &spatial_filter->points, sizeof(spatial_filter->points)))
      pass ("SPATIAL_FILTER.points [2RD*]");
    else
      {
        fail ("SPATIAL_FILTER.points [2RD*]"); error++;
      }
  }
  return error;
}
static int test_SPATIAL_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SPATIAL_INDEX *spatial_index = obj->tio.object->tio.SPATIAL_INDEX;
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &spatial_index->ownerhandle, sizeof(spatial_index->ownerhandle)))
      pass ("SPATIAL_INDEX.ownerhandle [H]");
    else
      {
        fail ("SPATIAL_INDEX.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "parent", &parent, NULL)
        && !memcmp(&parent, &spatial_index->parent, sizeof(spatial_index->parent)))
      pass ("SPATIAL_INDEX.parent [struct _dwg_object_object*]");
    else
      {
        fail ("SPATIAL_INDEX.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BL timestamp1;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "timestamp1", &timestamp1, NULL) &&
        timestamp1 == spatial_index->timestamp1)
      pass ("SPATIAL_INDEX.timestamp1 [BL] %u", timestamp1);
    else
      {
        fail ("SPATIAL_INDEX.timestamp1 [BL] %u != %u", spatial_index->timestamp1, timestamp1); error++;
      }
    timestamp1++;
    if (dwg_dynapi_entity_set_value(spatial_index, "SPATIAL_INDEX", "timestamp1", &timestamp1) &&
        timestamp1 == spatial_index->timestamp1)
      pass ("SPATIAL_INDEX.timestamp1 [BL] set+1 %u", timestamp1);
    else
      {
        fail ("SPATIAL_INDEX.timestamp1 [BL] set+1 %u != %u", spatial_index->timestamp1, timestamp1); error++;
      }
    spatial_index->timestamp1--;

  }
  {
    BITCODE_BL timestamp2;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "timestamp2", &timestamp2, NULL) &&
        timestamp2 == spatial_index->timestamp2)
      pass ("SPATIAL_INDEX.timestamp2 [BL] %u", timestamp2);
    else
      {
        fail ("SPATIAL_INDEX.timestamp2 [BL] %u != %u", spatial_index->timestamp2, timestamp2); error++;
      }
    timestamp2++;
    if (dwg_dynapi_entity_set_value(spatial_index, "SPATIAL_INDEX", "timestamp2", &timestamp2) &&
        timestamp2 == spatial_index->timestamp2)
      pass ("SPATIAL_INDEX.timestamp2 [BL] set+1 %u", timestamp2);
    else
      {
        fail ("SPATIAL_INDEX.timestamp2 [BL] set+1 %u != %u", spatial_index->timestamp2, timestamp2); error++;
      }
    spatial_index->timestamp2--;

  }
  {
    BITCODE_TV unknown;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "unknown", &unknown, NULL)
        && !strcmp((char*)&unknown, (char*)&spatial_index->unknown))
      pass ("SPATIAL_INDEX.unknown [TV]");
    else
      {
        fail ("SPATIAL_INDEX.unknown [TV]"); error++;
      }
  }
  return error;
}
static int test_STYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_STYLE *style = obj->tio.object->tio.STYLE;
  {
    BITCODE_TV bigfont_name;
    if (dwg_dynapi_entity_value(style, "STYLE", "bigfont_name", &bigfont_name, NULL)
        && !strcmp((char*)&bigfont_name, (char*)&style->bigfont_name))
      pass ("STYLE.bigfont_name [TV]");
    else
      {
        fail ("STYLE.bigfont_name [TV]"); error++;
      }
  }
  {
    BITCODE_BD fixed_height;
    if (dwg_dynapi_entity_value(style, "STYLE", "fixed_height", &fixed_height, NULL) &&
        fixed_height == style->fixed_height)
      pass ("STYLE.fixed_height [BD] %g", fixed_height);
    else
      {
        fail ("STYLE.fixed_height [BD] %g != %g", style->fixed_height, fixed_height); error++;
      }
    fixed_height++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "fixed_height", &fixed_height) &&
        fixed_height == style->fixed_height)
      pass ("STYLE.fixed_height [BD] set+1 %g", fixed_height);
    else
      {
        fail ("STYLE.fixed_height [BD] set+1 %g != %g", style->fixed_height, fixed_height); error++;
      }
    style->fixed_height--;

  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(style, "STYLE", "flag", &flag, NULL) &&
        flag == style->flag)
      pass ("STYLE.flag [RC] %u", flag);
    else
      {
        fail ("STYLE.flag [RC] %u != %u", style->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "flag", &flag) &&
        flag == style->flag)
      pass ("STYLE.flag [RC] set+1 %u", flag);
    else
      {
        fail ("STYLE.flag [RC] set+1 %u != %u", style->flag, flag); error++;
      }
    style->flag--;

  }
  {
    BITCODE_TV font_name;
    if (dwg_dynapi_entity_value(style, "STYLE", "font_name", &font_name, NULL)
        && !strcmp((char*)&font_name, (char*)&style->font_name))
      pass ("STYLE.font_name [TV]");
    else
      {
        fail ("STYLE.font_name [TV]"); error++;
      }
  }
  {
    BITCODE_RC generation;
    if (dwg_dynapi_entity_value(style, "STYLE", "generation", &generation, NULL) &&
        generation == style->generation)
      pass ("STYLE.generation [RC] %u", generation);
    else
      {
        fail ("STYLE.generation [RC] %u != %u", style->generation, generation); error++;
      }
    generation++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "generation", &generation) &&
        generation == style->generation)
      pass ("STYLE.generation [RC] set+1 %u", generation);
    else
      {
        fail ("STYLE.generation [RC] set+1 %u != %u", style->generation, generation); error++;
      }
    style->generation--;

  }
  {
    BITCODE_BD last_height;
    if (dwg_dynapi_entity_value(style, "STYLE", "last_height", &last_height, NULL) &&
        last_height == style->last_height)
      pass ("STYLE.last_height [BD] %g", last_height);
    else
      {
        fail ("STYLE.last_height [BD] %g != %g", style->last_height, last_height); error++;
      }
    last_height++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "last_height", &last_height) &&
        last_height == style->last_height)
      pass ("STYLE.last_height [BD] set+1 %g", last_height);
    else
      {
        fail ("STYLE.last_height [BD] set+1 %g != %g", style->last_height, last_height); error++;
      }
    style->last_height--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(style, "STYLE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&style->name))
      pass ("STYLE.name [TV]");
    else
      {
        fail ("STYLE.name [TV]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(style, "STYLE", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &style->null_handle, sizeof(style->null_handle)))
      pass ("STYLE.null_handle [H]");
    else
      {
        fail ("STYLE.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BD oblique_ang;
    if (dwg_dynapi_entity_value(style, "STYLE", "oblique_ang", &oblique_ang, NULL) &&
        oblique_ang == style->oblique_ang)
      pass ("STYLE.oblique_ang [BD] %g", oblique_ang);
    else
      {
        fail ("STYLE.oblique_ang [BD] %g != %g", style->oblique_ang, oblique_ang); error++;
      }
    oblique_ang++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "oblique_ang", &oblique_ang) &&
        oblique_ang == style->oblique_ang)
      pass ("STYLE.oblique_ang [BD] set+1 %g", oblique_ang);
    else
      {
        fail ("STYLE.oblique_ang [BD] set+1 %g != %g", style->oblique_ang, oblique_ang); error++;
      }
    style->oblique_ang--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(style, "STYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &style->parent, sizeof(style->parent)))
      pass ("STYLE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("STYLE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_B shape_file;
    if (dwg_dynapi_entity_value(style, "STYLE", "shape_file", &shape_file, NULL) &&
        shape_file == style->shape_file)
      pass ("STYLE.shape_file [B] " FORMAT_B "", shape_file);
    else
      {
        fail ("STYLE.shape_file [B] " FORMAT_B " != " FORMAT_B "", style->shape_file, shape_file); error++;
      }
    shape_file++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "shape_file", &shape_file) &&
        shape_file == style->shape_file)
      pass ("STYLE.shape_file [B] set+1 " FORMAT_B "", shape_file);
    else
      {
        fail ("STYLE.shape_file [B] set+1 " FORMAT_B " != " FORMAT_B "", style->shape_file, shape_file); error++;
      }
    style->shape_file--;

  }
  {
    BITCODE_H style_control;
    if (dwg_dynapi_entity_value(style, "STYLE", "style_control", &style_control, NULL)
        && !memcmp(&style_control, &style->style_control, sizeof(style->style_control)))
      pass ("STYLE.style_control [H]");
    else
      {
        fail ("STYLE.style_control [H]"); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(style, "STYLE", "used", &used, NULL) &&
        used == style->used)
      pass ("STYLE.used [RS] %hu", used);
    else
      {
        fail ("STYLE.used [RS] %hu != %hu", style->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "used", &used) &&
        used == style->used)
      pass ("STYLE.used [RS] set+1 %hu", used);
    else
      {
        fail ("STYLE.used [RS] set+1 %hu != %hu", style->used, used); error++;
      }
    style->used--;

  }
  {
    BITCODE_B vertical;
    if (dwg_dynapi_entity_value(style, "STYLE", "vertical", &vertical, NULL) &&
        vertical == style->vertical)
      pass ("STYLE.vertical [B] " FORMAT_B "", vertical);
    else
      {
        fail ("STYLE.vertical [B] " FORMAT_B " != " FORMAT_B "", style->vertical, vertical); error++;
      }
    vertical++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "vertical", &vertical) &&
        vertical == style->vertical)
      pass ("STYLE.vertical [B] set+1 " FORMAT_B "", vertical);
    else
      {
        fail ("STYLE.vertical [B] set+1 " FORMAT_B " != " FORMAT_B "", style->vertical, vertical); error++;
      }
    style->vertical--;

  }
  {
    BITCODE_BD width_factor;
    if (dwg_dynapi_entity_value(style, "STYLE", "width_factor", &width_factor, NULL) &&
        width_factor == style->width_factor)
      pass ("STYLE.width_factor [BD] %g", width_factor);
    else
      {
        fail ("STYLE.width_factor [BD] %g != %g", style->width_factor, width_factor); error++;
      }
    width_factor++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "width_factor", &width_factor) &&
        width_factor == style->width_factor)
      pass ("STYLE.width_factor [BD] set+1 %g", width_factor);
    else
      {
        fail ("STYLE.width_factor [BD] set+1 %g != %g", style->width_factor, width_factor); error++;
      }
    style->width_factor--;

  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(style, "STYLE", "xrefdep", &xrefdep, NULL) &&
        xrefdep == style->xrefdep)
      pass ("STYLE.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("STYLE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", style->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "xrefdep", &xrefdep) &&
        xrefdep == style->xrefdep)
      pass ("STYLE.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("STYLE.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", style->xrefdep, xrefdep); error++;
      }
    style->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(style, "STYLE", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == style->xrefindex_plus1)
      pass ("STYLE.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("STYLE.xrefindex_plus1 [BS] %hu != %hu", style->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == style->xrefindex_plus1)
      pass ("STYLE.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("STYLE.xrefindex_plus1 [BS] set+1 %hu != %hu", style->xrefindex_plus1, xrefindex_plus1); error++;
      }
    style->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(style, "STYLE", "xrefref", &xrefref, NULL) &&
        xrefref == style->xrefref)
      pass ("STYLE.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("STYLE.xrefref [B] " FORMAT_B " != " FORMAT_B "", style->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(style, "STYLE", "xrefref", &xrefref) &&
        xrefref == style->xrefref)
      pass ("STYLE.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("STYLE.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", style->xrefref, xrefref); error++;
      }
    style->xrefref--;

  }
  return error;
}
static int test_STYLE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_STYLE_CONTROL *style_control = obj->tio.object->tio.STYLE_CONTROL;
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &style_control->null_handle, sizeof(style_control->null_handle)))
      pass ("STYLE_CONTROL.null_handle [H]");
    else
      {
        fail ("STYLE_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == style_control->num_entries)
      pass ("STYLE_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("STYLE_CONTROL.num_entries [BS] %hu != %hu", style_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(style_control, "STYLE_CONTROL", "num_entries", &num_entries) &&
        num_entries == style_control->num_entries)
      pass ("STYLE_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("STYLE_CONTROL.num_entries [BS] set+1 %hu != %hu", style_control->num_entries, num_entries); error++;
      }
    style_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "objid", &objid, NULL) &&
        objid == style_control->objid)
      pass ("STYLE_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("STYLE_CONTROL.objid [BL] %u != %u", style_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(style_control, "STYLE_CONTROL", "objid", &objid) &&
        objid == style_control->objid)
      pass ("STYLE_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("STYLE_CONTROL.objid [BL] set+1 %u != %u", style_control->objid, objid); error++;
      }
    style_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &style_control->parent, sizeof(style_control->parent)))
      pass ("STYLE_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("STYLE_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &style_control->reactors, sizeof(style_control->reactors)))
      pass ("STYLE_CONTROL.reactors [H]");
    else
      {
        fail ("STYLE_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H styles;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "styles", &styles, NULL)
        && !memcmp(&styles, &style_control->styles, sizeof(style_control->styles)))
      pass ("STYLE_CONTROL.styles [H]");
    else
      {
        fail ("STYLE_CONTROL.styles [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &style_control->xdicobjhandle, sizeof(style_control->xdicobjhandle)))
      pass ("STYLE_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("STYLE_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_SUN (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SUN *sun = obj->tio.object->tio.SUN;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(sun, "SUN", "class_version", &class_version, NULL) &&
        class_version == sun->class_version)
      pass ("SUN.class_version [BL] %u", class_version);
    else
      {
        fail ("SUN.class_version [BL] %u != %u", sun->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "class_version", &class_version) &&
        class_version == sun->class_version)
      pass ("SUN.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("SUN.class_version [BL] set+1 %u != %u", sun->class_version, class_version); error++;
      }
    sun->class_version--;

  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(sun, "SUN", "color", &color, NULL)
        && !memcmp(&color, &sun->color, sizeof(sun->color)))
      pass ("SUN.color [CMC]");
    else
      {
        fail ("SUN.color [CMC]"); error++;
      }
  }
  {
    BITCODE_B has_shadow;
    if (dwg_dynapi_entity_value(sun, "SUN", "has_shadow", &has_shadow, NULL) &&
        has_shadow == sun->has_shadow)
      pass ("SUN.has_shadow [B] " FORMAT_B "", has_shadow);
    else
      {
        fail ("SUN.has_shadow [B] " FORMAT_B " != " FORMAT_B "", sun->has_shadow, has_shadow); error++;
      }
    has_shadow++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "has_shadow", &has_shadow) &&
        has_shadow == sun->has_shadow)
      pass ("SUN.has_shadow [B] set+1 " FORMAT_B "", has_shadow);
    else
      {
        fail ("SUN.has_shadow [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->has_shadow, has_shadow); error++;
      }
    sun->has_shadow--;

  }
  {
    BITCODE_BD intensity;
    if (dwg_dynapi_entity_value(sun, "SUN", "intensity", &intensity, NULL) &&
        intensity == sun->intensity)
      pass ("SUN.intensity [BD] %g", intensity);
    else
      {
        fail ("SUN.intensity [BD] %g != %g", sun->intensity, intensity); error++;
      }
    intensity++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "intensity", &intensity) &&
        intensity == sun->intensity)
      pass ("SUN.intensity [BD] set+1 %g", intensity);
    else
      {
        fail ("SUN.intensity [BD] set+1 %g != %g", sun->intensity, intensity); error++;
      }
    sun->intensity--;

  }
  {
    BITCODE_B is_dst;
    if (dwg_dynapi_entity_value(sun, "SUN", "is_dst", &is_dst, NULL) &&
        is_dst == sun->is_dst)
      pass ("SUN.is_dst [B] " FORMAT_B "", is_dst);
    else
      {
        fail ("SUN.is_dst [B] " FORMAT_B " != " FORMAT_B "", sun->is_dst, is_dst); error++;
      }
    is_dst++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "is_dst", &is_dst) &&
        is_dst == sun->is_dst)
      pass ("SUN.is_dst [B] set+1 " FORMAT_B "", is_dst);
    else
      {
        fail ("SUN.is_dst [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->is_dst, is_dst); error++;
      }
    sun->is_dst--;

  }
  {
    BITCODE_B is_on;
    if (dwg_dynapi_entity_value(sun, "SUN", "is_on", &is_on, NULL) &&
        is_on == sun->is_on)
      pass ("SUN.is_on [B] " FORMAT_B "", is_on);
    else
      {
        fail ("SUN.is_on [B] " FORMAT_B " != " FORMAT_B "", sun->is_on, is_on); error++;
      }
    is_on++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "is_on", &is_on) &&
        is_on == sun->is_on)
      pass ("SUN.is_on [B] set+1 " FORMAT_B "", is_on);
    else
      {
        fail ("SUN.is_on [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->is_on, is_on); error++;
      }
    sun->is_on--;

  }
  {
    BITCODE_BL julian_day;
    if (dwg_dynapi_entity_value(sun, "SUN", "julian_day", &julian_day, NULL) &&
        julian_day == sun->julian_day)
      pass ("SUN.julian_day [BL] %u", julian_day);
    else
      {
        fail ("SUN.julian_day [BL] %u != %u", sun->julian_day, julian_day); error++;
      }
    julian_day++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "julian_day", &julian_day) &&
        julian_day == sun->julian_day)
      pass ("SUN.julian_day [BL] set+1 %u", julian_day);
    else
      {
        fail ("SUN.julian_day [BL] set+1 %u != %u", sun->julian_day, julian_day); error++;
      }
    sun->julian_day--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(sun, "SUN", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &sun->ownerhandle, sizeof(sun->ownerhandle)))
      pass ("SUN.ownerhandle [H]");
    else
      {
        fail ("SUN.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(sun, "SUN", "parent", &parent, NULL)
        && !memcmp(&parent, &sun->parent, sizeof(sun->parent)))
      pass ("SUN.parent [struct _dwg_object_object*]");
    else
      {
        fail ("SUN.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BS shadow_mapsize;
    if (dwg_dynapi_entity_value(sun, "SUN", "shadow_mapsize", &shadow_mapsize, NULL) &&
        shadow_mapsize == sun->shadow_mapsize)
      pass ("SUN.shadow_mapsize [BS] %hu", shadow_mapsize);
    else
      {
        fail ("SUN.shadow_mapsize [BS] %hu != %hu", sun->shadow_mapsize, shadow_mapsize); error++;
      }
    shadow_mapsize++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "shadow_mapsize", &shadow_mapsize) &&
        shadow_mapsize == sun->shadow_mapsize)
      pass ("SUN.shadow_mapsize [BS] set+1 %hu", shadow_mapsize);
    else
      {
        fail ("SUN.shadow_mapsize [BS] set+1 %hu != %hu", sun->shadow_mapsize, shadow_mapsize); error++;
      }
    sun->shadow_mapsize--;

  }
  {
    BITCODE_BS shadow_softness;
    if (dwg_dynapi_entity_value(sun, "SUN", "shadow_softness", &shadow_softness, NULL) &&
        shadow_softness == sun->shadow_softness)
      pass ("SUN.shadow_softness [BS] %hu", shadow_softness);
    else
      {
        fail ("SUN.shadow_softness [BS] %hu != %hu", sun->shadow_softness, shadow_softness); error++;
      }
    shadow_softness++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "shadow_softness", &shadow_softness) &&
        shadow_softness == sun->shadow_softness)
      pass ("SUN.shadow_softness [BS] set+1 %hu", shadow_softness);
    else
      {
        fail ("SUN.shadow_softness [BS] set+1 %hu != %hu", sun->shadow_softness, shadow_softness); error++;
      }
    sun->shadow_softness--;

  }
  {
    BITCODE_BS shadow_type;
    if (dwg_dynapi_entity_value(sun, "SUN", "shadow_type", &shadow_type, NULL) &&
        shadow_type == sun->shadow_type)
      pass ("SUN.shadow_type [BS] %hu", shadow_type);
    else
      {
        fail ("SUN.shadow_type [BS] %hu != %hu", sun->shadow_type, shadow_type); error++;
      }
    shadow_type++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "shadow_type", &shadow_type) &&
        shadow_type == sun->shadow_type)
      pass ("SUN.shadow_type [BS] set+1 %hu", shadow_type);
    else
      {
        fail ("SUN.shadow_type [BS] set+1 %hu != %hu", sun->shadow_type, shadow_type); error++;
      }
    sun->shadow_type--;

  }
  {
    BITCODE_H skyparams;
    if (dwg_dynapi_entity_value(sun, "SUN", "skyparams", &skyparams, NULL)
        && !memcmp(&skyparams, &sun->skyparams, sizeof(sun->skyparams)))
      pass ("SUN.skyparams [H]");
    else
      {
        fail ("SUN.skyparams [H]"); error++;
      }
  }
  {
    BITCODE_BL time;
    if (dwg_dynapi_entity_value(sun, "SUN", "time", &time, NULL) &&
        time == sun->time)
      pass ("SUN.time [BL] %u", time);
    else
      {
        fail ("SUN.time [BL] %u != %u", sun->time, time); error++;
      }
    time++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "time", &time) &&
        time == sun->time)
      pass ("SUN.time [BL] set+1 %u", time);
    else
      {
        fail ("SUN.time [BL] set+1 %u != %u", sun->time, time); error++;
      }
    sun->time--;

  }
  {
    BITCODE_BS unknown;
    if (dwg_dynapi_entity_value(sun, "SUN", "unknown", &unknown, NULL) &&
        unknown == sun->unknown)
      pass ("SUN.unknown [BS] %hu", unknown);
    else
      {
        fail ("SUN.unknown [BS] %hu != %hu", sun->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(sun, "SUN", "unknown", &unknown) &&
        unknown == sun->unknown)
      pass ("SUN.unknown [BS] set+1 %hu", unknown);
    else
      {
        fail ("SUN.unknown [BS] set+1 %hu != %hu", sun->unknown, unknown); error++;
      }
    sun->unknown--;

  }
  return error;
}
static int test_SUNSTUDY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SUNSTUDY *sunstudy = obj->tio.object->tio.SUNSTUDY;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "class_version", &class_version, NULL) &&
        class_version == sunstudy->class_version)
      pass ("SUNSTUDY.class_version [BL] %u", class_version);
    else
      {
        fail ("SUNSTUDY.class_version [BL] %u != %u", sunstudy->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "class_version", &class_version) &&
        class_version == sunstudy->class_version)
      pass ("SUNSTUDY.class_version [BL] set+1 %u", class_version);
    else
      {
        fail ("SUNSTUDY.class_version [BL] set+1 %u != %u", sunstudy->class_version, class_version); error++;
      }
    sunstudy->class_version--;

  }
  {
    Dwg_SUNSTUDY_Dates* dates;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "dates", &dates, NULL)
        && !memcmp(&dates, &sunstudy->dates, sizeof(sunstudy->dates)))
      pass ("SUNSTUDY.dates [Dwg_SUNSTUDY_Dates*]");
    else
      {
        fail ("SUNSTUDY.dates [Dwg_SUNSTUDY_Dates*]"); error++;
      }
  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "desc", &desc, NULL)
        && !memcmp(&desc, &sunstudy->desc, sizeof(sunstudy->desc)))
      pass ("SUNSTUDY.desc [T]");
    else
      {
        fail ("SUNSTUDY.desc [T]"); error++;
      }
  }
  {
    BITCODE_BL end_time;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "end_time", &end_time, NULL) &&
        end_time == sunstudy->end_time)
      pass ("SUNSTUDY.end_time [BL] %u", end_time);
    else
      {
        fail ("SUNSTUDY.end_time [BL] %u != %u", sunstudy->end_time, end_time); error++;
      }
    end_time++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "end_time", &end_time) &&
        end_time == sunstudy->end_time)
      pass ("SUNSTUDY.end_time [BL] set+1 %u", end_time);
    else
      {
        fail ("SUNSTUDY.end_time [BL] set+1 %u != %u", sunstudy->end_time, end_time); error++;
      }
    sunstudy->end_time--;

  }
  {
    BITCODE_B* hours;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "hours", &hours, NULL)
        && !memcmp(&hours, &sunstudy->hours, sizeof(sunstudy->hours)))
      pass ("SUNSTUDY.hours [B*]");
    else
      {
        fail ("SUNSTUDY.hours [B*]"); error++;
      }
  }
  {
    BITCODE_BL interval;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "interval", &interval, NULL) &&
        interval == sunstudy->interval)
      pass ("SUNSTUDY.interval [BL] %u", interval);
    else
      {
        fail ("SUNSTUDY.interval [BL] %u != %u", sunstudy->interval, interval); error++;
      }
    interval++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "interval", &interval) &&
        interval == sunstudy->interval)
      pass ("SUNSTUDY.interval [BL] set+1 %u", interval);
    else
      {
        fail ("SUNSTUDY.interval [BL] set+1 %u != %u", sunstudy->interval, interval); error++;
      }
    sunstudy->interval--;

  }
  {
    BITCODE_B label_viewports;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "label_viewports", &label_viewports, NULL) &&
        label_viewports == sunstudy->label_viewports)
      pass ("SUNSTUDY.label_viewports [B] " FORMAT_B "", label_viewports);
    else
      {
        fail ("SUNSTUDY.label_viewports [B] " FORMAT_B " != " FORMAT_B "", sunstudy->label_viewports, label_viewports); error++;
      }
    label_viewports++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "label_viewports", &label_viewports) &&
        label_viewports == sunstudy->label_viewports)
      pass ("SUNSTUDY.label_viewports [B] set+1 " FORMAT_B "", label_viewports);
    else
      {
        fail ("SUNSTUDY.label_viewports [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->label_viewports, label_viewports); error++;
      }
    sunstudy->label_viewports--;

  }
  {
    BITCODE_B lock_viewports;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "lock_viewports", &lock_viewports, NULL) &&
        lock_viewports == sunstudy->lock_viewports)
      pass ("SUNSTUDY.lock_viewports [B] " FORMAT_B "", lock_viewports);
    else
      {
        fail ("SUNSTUDY.lock_viewports [B] " FORMAT_B " != " FORMAT_B "", sunstudy->lock_viewports, lock_viewports); error++;
      }
    lock_viewports++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "lock_viewports", &lock_viewports) &&
        lock_viewports == sunstudy->lock_viewports)
      pass ("SUNSTUDY.lock_viewports [B] set+1 " FORMAT_B "", lock_viewports);
    else
      {
        fail ("SUNSTUDY.lock_viewports [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->lock_viewports, lock_viewports); error++;
      }
    sunstudy->lock_viewports--;

  }
  {
    BITCODE_BL num_dates;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "num_dates", &num_dates, NULL) &&
        num_dates == sunstudy->num_dates)
      pass ("SUNSTUDY.num_dates [BL] %u", num_dates);
    else
      {
        fail ("SUNSTUDY.num_dates [BL] %u != %u", sunstudy->num_dates, num_dates); error++;
      }
    num_dates++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "num_dates", &num_dates) &&
        num_dates == sunstudy->num_dates)
      pass ("SUNSTUDY.num_dates [BL] set+1 %u", num_dates);
    else
      {
        fail ("SUNSTUDY.num_dates [BL] set+1 %u != %u", sunstudy->num_dates, num_dates); error++;
      }
    sunstudy->num_dates--;

  }
  {
    BITCODE_BL num_hours;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "num_hours", &num_hours, NULL) &&
        num_hours == sunstudy->num_hours)
      pass ("SUNSTUDY.num_hours [BL] %u", num_hours);
    else
      {
        fail ("SUNSTUDY.num_hours [BL] %u != %u", sunstudy->num_hours, num_hours); error++;
      }
    num_hours++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "num_hours", &num_hours) &&
        num_hours == sunstudy->num_hours)
      pass ("SUNSTUDY.num_hours [BL] set+1 %u", num_hours);
    else
      {
        fail ("SUNSTUDY.num_hours [BL] set+1 %u != %u", sunstudy->num_hours, num_hours); error++;
      }
    sunstudy->num_hours--;

  }
  {
    BITCODE_BL numcols;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "numcols", &numcols, NULL) &&
        numcols == sunstudy->numcols)
      pass ("SUNSTUDY.numcols [BL] %u", numcols);
    else
      {
        fail ("SUNSTUDY.numcols [BL] %u != %u", sunstudy->numcols, numcols); error++;
      }
    numcols++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "numcols", &numcols) &&
        numcols == sunstudy->numcols)
      pass ("SUNSTUDY.numcols [BL] set+1 %u", numcols);
    else
      {
        fail ("SUNSTUDY.numcols [BL] set+1 %u != %u", sunstudy->numcols, numcols); error++;
      }
    sunstudy->numcols--;

  }
  {
    BITCODE_BL numrows;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "numrows", &numrows, NULL) &&
        numrows == sunstudy->numrows)
      pass ("SUNSTUDY.numrows [BL] %u", numrows);
    else
      {
        fail ("SUNSTUDY.numrows [BL] %u != %u", sunstudy->numrows, numrows); error++;
      }
    numrows++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "numrows", &numrows) &&
        numrows == sunstudy->numrows)
      pass ("SUNSTUDY.numrows [BL] set+1 %u", numrows);
    else
      {
        fail ("SUNSTUDY.numrows [BL] set+1 %u != %u", sunstudy->numrows, numrows); error++;
      }
    sunstudy->numrows--;

  }
  {
    BITCODE_BL numvports;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "numvports", &numvports, NULL) &&
        numvports == sunstudy->numvports)
      pass ("SUNSTUDY.numvports [BL] %u", numvports);
    else
      {
        fail ("SUNSTUDY.numvports [BL] %u != %u", sunstudy->numvports, numvports); error++;
      }
    numvports++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "numvports", &numvports) &&
        numvports == sunstudy->numvports)
      pass ("SUNSTUDY.numvports [BL] set+1 %u", numvports);
    else
      {
        fail ("SUNSTUDY.numvports [BL] set+1 %u != %u", sunstudy->numvports, numvports); error++;
      }
    sunstudy->numvports--;

  }
  {
    BITCODE_BL output_type;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "output_type", &output_type, NULL) &&
        output_type == sunstudy->output_type)
      pass ("SUNSTUDY.output_type [BL] %u", output_type);
    else
      {
        fail ("SUNSTUDY.output_type [BL] %u != %u", sunstudy->output_type, output_type); error++;
      }
    output_type++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "output_type", &output_type) &&
        output_type == sunstudy->output_type)
      pass ("SUNSTUDY.output_type [BL] set+1 %u", output_type);
    else
      {
        fail ("SUNSTUDY.output_type [BL] set+1 %u != %u", sunstudy->output_type, output_type); error++;
      }
    sunstudy->output_type--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &sunstudy->ownerhandle, sizeof(sunstudy->ownerhandle)))
      pass ("SUNSTUDY.ownerhandle [H]");
    else
      {
        fail ("SUNSTUDY.ownerhandle [H]"); error++;
      }
  }
  {
    BITCODE_H page_setup_wizard;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "page_setup_wizard", &page_setup_wizard, NULL)
        && !memcmp(&page_setup_wizard, &sunstudy->page_setup_wizard, sizeof(sunstudy->page_setup_wizard)))
      pass ("SUNSTUDY.page_setup_wizard [H]");
    else
      {
        fail ("SUNSTUDY.page_setup_wizard [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "parent", &parent, NULL)
        && !memcmp(&parent, &sunstudy->parent, sizeof(sunstudy->parent)))
      pass ("SUNSTUDY.parent [struct _dwg_object_object*]");
    else
      {
        fail ("SUNSTUDY.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_B select_dates_from_calendar;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "select_dates_from_calendar", &select_dates_from_calendar, NULL) &&
        select_dates_from_calendar == sunstudy->select_dates_from_calendar)
      pass ("SUNSTUDY.select_dates_from_calendar [B] " FORMAT_B "", select_dates_from_calendar);
    else
      {
        fail ("SUNSTUDY.select_dates_from_calendar [B] " FORMAT_B " != " FORMAT_B "", sunstudy->select_dates_from_calendar, select_dates_from_calendar); error++;
      }
    select_dates_from_calendar++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "select_dates_from_calendar", &select_dates_from_calendar) &&
        select_dates_from_calendar == sunstudy->select_dates_from_calendar)
      pass ("SUNSTUDY.select_dates_from_calendar [B] set+1 " FORMAT_B "", select_dates_from_calendar);
    else
      {
        fail ("SUNSTUDY.select_dates_from_calendar [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->select_dates_from_calendar, select_dates_from_calendar); error++;
      }
    sunstudy->select_dates_from_calendar--;

  }
  {
    BITCODE_B select_range_of_dates;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "select_range_of_dates", &select_range_of_dates, NULL) &&
        select_range_of_dates == sunstudy->select_range_of_dates)
      pass ("SUNSTUDY.select_range_of_dates [B] " FORMAT_B "", select_range_of_dates);
    else
      {
        fail ("SUNSTUDY.select_range_of_dates [B] " FORMAT_B " != " FORMAT_B "", sunstudy->select_range_of_dates, select_range_of_dates); error++;
      }
    select_range_of_dates++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "select_range_of_dates", &select_range_of_dates) &&
        select_range_of_dates == sunstudy->select_range_of_dates)
      pass ("SUNSTUDY.select_range_of_dates [B] set+1 " FORMAT_B "", select_range_of_dates);
    else
      {
        fail ("SUNSTUDY.select_range_of_dates [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->select_range_of_dates, select_range_of_dates); error++;
      }
    sunstudy->select_range_of_dates--;

  }
  {
    BITCODE_T setup_name;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "setup_name", &setup_name, NULL)
        && !memcmp(&setup_name, &sunstudy->setup_name, sizeof(sunstudy->setup_name)))
      pass ("SUNSTUDY.setup_name [T]");
    else
      {
        fail ("SUNSTUDY.setup_name [T]"); error++;
      }
  }
  {
    BITCODE_BL shade_plot_type;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "shade_plot_type", &shade_plot_type, NULL) &&
        shade_plot_type == sunstudy->shade_plot_type)
      pass ("SUNSTUDY.shade_plot_type [BL] %u", shade_plot_type);
    else
      {
        fail ("SUNSTUDY.shade_plot_type [BL] %u != %u", sunstudy->shade_plot_type, shade_plot_type); error++;
      }
    shade_plot_type++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "shade_plot_type", &shade_plot_type) &&
        shade_plot_type == sunstudy->shade_plot_type)
      pass ("SUNSTUDY.shade_plot_type [BL] set+1 %u", shade_plot_type);
    else
      {
        fail ("SUNSTUDY.shade_plot_type [BL] set+1 %u != %u", sunstudy->shade_plot_type, shade_plot_type); error++;
      }
    sunstudy->shade_plot_type--;

  }
  {
    BITCODE_T sheet_set_name;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "sheet_set_name", &sheet_set_name, NULL)
        && !memcmp(&sheet_set_name, &sunstudy->sheet_set_name, sizeof(sunstudy->sheet_set_name)))
      pass ("SUNSTUDY.sheet_set_name [T]");
    else
      {
        fail ("SUNSTUDY.sheet_set_name [T]"); error++;
      }
  }
  {
    BITCODE_T sheet_subset_name;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "sheet_subset_name", &sheet_subset_name, NULL)
        && !memcmp(&sheet_subset_name, &sunstudy->sheet_subset_name, sizeof(sunstudy->sheet_subset_name)))
      pass ("SUNSTUDY.sheet_subset_name [T]");
    else
      {
        fail ("SUNSTUDY.sheet_subset_name [T]"); error++;
      }
  }
  {
    BITCODE_BD spacing;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "spacing", &spacing, NULL) &&
        spacing == sunstudy->spacing)
      pass ("SUNSTUDY.spacing [BD] %g", spacing);
    else
      {
        fail ("SUNSTUDY.spacing [BD] %g != %g", sunstudy->spacing, spacing); error++;
      }
    spacing++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "spacing", &spacing) &&
        spacing == sunstudy->spacing)
      pass ("SUNSTUDY.spacing [BD] set+1 %g", spacing);
    else
      {
        fail ("SUNSTUDY.spacing [BD] set+1 %g != %g", sunstudy->spacing, spacing); error++;
      }
    sunstudy->spacing--;

  }
  {
    BITCODE_BL start_time;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "start_time", &start_time, NULL) &&
        start_time == sunstudy->start_time)
      pass ("SUNSTUDY.start_time [BL] %u", start_time);
    else
      {
        fail ("SUNSTUDY.start_time [BL] %u != %u", sunstudy->start_time, start_time); error++;
      }
    start_time++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "start_time", &start_time) &&
        start_time == sunstudy->start_time)
      pass ("SUNSTUDY.start_time [BL] set+1 %u", start_time);
    else
      {
        fail ("SUNSTUDY.start_time [BL] set+1 %u != %u", sunstudy->start_time, start_time); error++;
      }
    sunstudy->start_time--;

  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "text_style", &text_style, NULL)
        && !memcmp(&text_style, &sunstudy->text_style, sizeof(sunstudy->text_style)))
      pass ("SUNSTUDY.text_style [H]");
    else
      {
        fail ("SUNSTUDY.text_style [H]"); error++;
      }
  }
  {
    BITCODE_B use_subset;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "use_subset", &use_subset, NULL) &&
        use_subset == sunstudy->use_subset)
      pass ("SUNSTUDY.use_subset [B] " FORMAT_B "", use_subset);
    else
      {
        fail ("SUNSTUDY.use_subset [B] " FORMAT_B " != " FORMAT_B "", sunstudy->use_subset, use_subset); error++;
      }
    use_subset++;
    if (dwg_dynapi_entity_set_value(sunstudy, "SUNSTUDY", "use_subset", &use_subset) &&
        use_subset == sunstudy->use_subset)
      pass ("SUNSTUDY.use_subset [B] set+1 " FORMAT_B "", use_subset);
    else
      {
        fail ("SUNSTUDY.use_subset [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->use_subset, use_subset); error++;
      }
    sunstudy->use_subset--;

  }
  {
    BITCODE_H view;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "view", &view, NULL)
        && !memcmp(&view, &sunstudy->view, sizeof(sunstudy->view)))
      pass ("SUNSTUDY.view [H]");
    else
      {
        fail ("SUNSTUDY.view [H]"); error++;
      }
  }
  {
    BITCODE_H visual_style;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "visual_style", &visual_style, NULL)
        && !memcmp(&visual_style, &sunstudy->visual_style, sizeof(sunstudy->visual_style)))
      pass ("SUNSTUDY.visual_style [H]");
    else
      {
        fail ("SUNSTUDY.visual_style [H]"); error++;
      }
  }
  return error;
}
static int test_TABLECONTENT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_TABLECONTENT *tablecontent = obj->tio.object->tio.TABLECONTENT;
  {
    Dwg_FormattedTableData fdata;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "fdata", &fdata, NULL)
        && !memcmp(&fdata, &tablecontent->fdata, sizeof(tablecontent->fdata)))
      pass ("TABLECONTENT.fdata [Dwg_FormattedTableData]");
    else
      {
        fail ("TABLECONTENT.fdata [Dwg_FormattedTableData]"); error++;
      }
  }
  {
    Dwg_LinkedData ldata;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "ldata", &ldata, NULL)
        && !memcmp(&ldata, &tablecontent->ldata, sizeof(tablecontent->ldata)))
      pass ("TABLECONTENT.ldata [Dwg_LinkedData]");
    else
      {
        fail ("TABLECONTENT.ldata [Dwg_LinkedData]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "parent", &parent, NULL)
        && !memcmp(&parent, &tablecontent->parent, sizeof(tablecontent->parent)))
      pass ("TABLECONTENT.parent [struct _dwg_object_object*]");
    else
      {
        fail ("TABLECONTENT.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H table_style;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "table_style", &table_style, NULL)
        && !memcmp(&table_style, &tablecontent->table_style, sizeof(tablecontent->table_style)))
      pass ("TABLECONTENT.table_style [H]");
    else
      {
        fail ("TABLECONTENT.table_style [H]"); error++;
      }
  }
  {
    Dwg_LinkedTableData tdata;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "tdata", &tdata, NULL)
        && !memcmp(&tdata, &tablecontent->tdata, sizeof(tablecontent->tdata)))
      pass ("TABLECONTENT.tdata [Dwg_LinkedTableData]");
    else
      {
        fail ("TABLECONTENT.tdata [Dwg_LinkedTableData]"); error++;
      }
  }
  return error;
}
static int test_TABLEGEOMETRY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_TABLEGEOMETRY *tablegeometry = obj->tio.object->tio.TABLEGEOMETRY;
  {
    Dwg_TABLEGEOMETRY_Cell* cells;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "cells", &cells, NULL)
        && !memcmp(&cells, &tablegeometry->cells, sizeof(tablegeometry->cells)))
      pass ("TABLEGEOMETRY.cells [Dwg_TABLEGEOMETRY_Cell*]");
    else
      {
        fail ("TABLEGEOMETRY.cells [Dwg_TABLEGEOMETRY_Cell*]"); error++;
      }
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "num_cells", &num_cells, NULL) &&
        num_cells == tablegeometry->num_cells)
      pass ("TABLEGEOMETRY.num_cells [BL] %u", num_cells);
    else
      {
        fail ("TABLEGEOMETRY.num_cells [BL] %u != %u", tablegeometry->num_cells, num_cells); error++;
      }
    num_cells++;
    if (dwg_dynapi_entity_set_value(tablegeometry, "TABLEGEOMETRY", "num_cells", &num_cells) &&
        num_cells == tablegeometry->num_cells)
      pass ("TABLEGEOMETRY.num_cells [BL] set+1 %u", num_cells);
    else
      {
        fail ("TABLEGEOMETRY.num_cells [BL] set+1 %u != %u", tablegeometry->num_cells, num_cells); error++;
      }
    tablegeometry->num_cells--;

  }
  {
    BITCODE_BL num_cols;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "num_cols", &num_cols, NULL) &&
        num_cols == tablegeometry->num_cols)
      pass ("TABLEGEOMETRY.num_cols [BL] %u", num_cols);
    else
      {
        fail ("TABLEGEOMETRY.num_cols [BL] %u != %u", tablegeometry->num_cols, num_cols); error++;
      }
    num_cols++;
    if (dwg_dynapi_entity_set_value(tablegeometry, "TABLEGEOMETRY", "num_cols", &num_cols) &&
        num_cols == tablegeometry->num_cols)
      pass ("TABLEGEOMETRY.num_cols [BL] set+1 %u", num_cols);
    else
      {
        fail ("TABLEGEOMETRY.num_cols [BL] set+1 %u != %u", tablegeometry->num_cols, num_cols); error++;
      }
    tablegeometry->num_cols--;

  }
  {
    BITCODE_BL num_rows;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "num_rows", &num_rows, NULL) &&
        num_rows == tablegeometry->num_rows)
      pass ("TABLEGEOMETRY.num_rows [BL] %u", num_rows);
    else
      {
        fail ("TABLEGEOMETRY.num_rows [BL] %u != %u", tablegeometry->num_rows, num_rows); error++;
      }
    num_rows++;
    if (dwg_dynapi_entity_set_value(tablegeometry, "TABLEGEOMETRY", "num_rows", &num_rows) &&
        num_rows == tablegeometry->num_rows)
      pass ("TABLEGEOMETRY.num_rows [BL] set+1 %u", num_rows);
    else
      {
        fail ("TABLEGEOMETRY.num_rows [BL] set+1 %u != %u", tablegeometry->num_rows, num_rows); error++;
      }
    tablegeometry->num_rows--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "parent", &parent, NULL)
        && !memcmp(&parent, &tablegeometry->parent, sizeof(tablegeometry->parent)))
      pass ("TABLEGEOMETRY.parent [struct _dwg_object_object*]");
    else
      {
        fail ("TABLEGEOMETRY.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_TABLESTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_TABLESTYLE *tablestyle = obj->tio.object->tio.TABLESTYLE;
  {
    Dwg_TABLESTYLE_Cell* cells;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "cells", &cells, NULL)
        && !memcmp(&cells, &tablestyle->cells, sizeof(tablestyle->cells)))
      pass ("TABLESTYLE.cells [Dwg_TABLESTYLE_Cell*]");
    else
      {
        fail ("TABLESTYLE.cells [Dwg_TABLESTYLE_Cell*]"); error++;
      }
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "class_version", &class_version, NULL) &&
        class_version == tablestyle->class_version)
      pass ("TABLESTYLE.class_version [BS] %hu", class_version);
    else
      {
        fail ("TABLESTYLE.class_version [BS] %hu != %hu", tablestyle->class_version, class_version); error++;
      }
    class_version++;
    if (dwg_dynapi_entity_set_value(tablestyle, "TABLESTYLE", "class_version", &class_version) &&
        class_version == tablestyle->class_version)
      pass ("TABLESTYLE.class_version [BS] set+1 %hu", class_version);
    else
      {
        fail ("TABLESTYLE.class_version [BS] set+1 %hu != %hu", tablestyle->class_version, class_version); error++;
      }
    tablestyle->class_version--;

  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "flags", &flags, NULL) &&
        flags == tablestyle->flags)
      pass ("TABLESTYLE.flags [BL] %u", flags);
    else
      {
        fail ("TABLESTYLE.flags [BL] %u != %u", tablestyle->flags, flags); error++;
      }
    flags++;
    if (dwg_dynapi_entity_set_value(tablestyle, "TABLESTYLE", "flags", &flags) &&
        flags == tablestyle->flags)
      pass ("TABLESTYLE.flags [BL] set+1 %u", flags);
    else
      {
        fail ("TABLESTYLE.flags [BL] set+1 %u != %u", tablestyle->flags, flags); error++;
      }
    tablestyle->flags--;

  }
  {
    BITCODE_BS flow_direction;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "flow_direction", &flow_direction, NULL) &&
        flow_direction == tablestyle->flow_direction)
      pass ("TABLESTYLE.flow_direction [BS] %hu", flow_direction);
    else
      {
        fail ("TABLESTYLE.flow_direction [BS] %hu != %hu", tablestyle->flow_direction, flow_direction); error++;
      }
    flow_direction++;
    if (dwg_dynapi_entity_set_value(tablestyle, "TABLESTYLE", "flow_direction", &flow_direction) &&
        flow_direction == tablestyle->flow_direction)
      pass ("TABLESTYLE.flow_direction [BS] set+1 %hu", flow_direction);
    else
      {
        fail ("TABLESTYLE.flow_direction [BS] set+1 %hu != %hu", tablestyle->flow_direction, flow_direction); error++;
      }
    tablestyle->flow_direction--;

  }
  {
    BITCODE_B header_suppressed;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "header_suppressed", &header_suppressed, NULL) &&
        header_suppressed == tablestyle->header_suppressed)
      pass ("TABLESTYLE.header_suppressed [B] " FORMAT_B "", header_suppressed);
    else
      {
        fail ("TABLESTYLE.header_suppressed [B] " FORMAT_B " != " FORMAT_B "", tablestyle->header_suppressed, header_suppressed); error++;
      }
    header_suppressed++;
    if (dwg_dynapi_entity_set_value(tablestyle, "TABLESTYLE", "header_suppressed", &header_suppressed) &&
        header_suppressed == tablestyle->header_suppressed)
      pass ("TABLESTYLE.header_suppressed [B] set+1 " FORMAT_B "", header_suppressed);
    else
      {
        fail ("TABLESTYLE.header_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", tablestyle->header_suppressed, header_suppressed); error++;
      }
    tablestyle->header_suppressed--;

  }
  {
    BITCODE_BD horiz_cell_margin;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "horiz_cell_margin", &horiz_cell_margin, NULL) &&
        horiz_cell_margin == tablestyle->horiz_cell_margin)
      pass ("TABLESTYLE.horiz_cell_margin [BD] %g", horiz_cell_margin);
    else
      {
        fail ("TABLESTYLE.horiz_cell_margin [BD] %g != %g", tablestyle->horiz_cell_margin, horiz_cell_margin); error++;
      }
    horiz_cell_margin++;
    if (dwg_dynapi_entity_set_value(tablestyle, "TABLESTYLE", "horiz_cell_margin", &horiz_cell_margin) &&
        horiz_cell_margin == tablestyle->horiz_cell_margin)
      pass ("TABLESTYLE.horiz_cell_margin [BD] set+1 %g", horiz_cell_margin);
    else
      {
        fail ("TABLESTYLE.horiz_cell_margin [BD] set+1 %g != %g", tablestyle->horiz_cell_margin, horiz_cell_margin); error++;
      }
    tablestyle->horiz_cell_margin--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&tablestyle->name))
      pass ("TABLESTYLE.name [TV]");
    else
      {
        fail ("TABLESTYLE.name [TV]"); error++;
      }
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "num_cells", &num_cells, NULL) &&
        num_cells == tablestyle->num_cells)
      pass ("TABLESTYLE.num_cells [BL] %u", num_cells);
    else
      {
        fail ("TABLESTYLE.num_cells [BL] %u != %u", tablestyle->num_cells, num_cells); error++;
      }
    num_cells++;
    if (dwg_dynapi_entity_set_value(tablestyle, "TABLESTYLE", "num_cells", &num_cells) &&
        num_cells == tablestyle->num_cells)
      pass ("TABLESTYLE.num_cells [BL] set+1 %u", num_cells);
    else
      {
        fail ("TABLESTYLE.num_cells [BL] set+1 %u != %u", tablestyle->num_cells, num_cells); error++;
      }
    tablestyle->num_cells--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &tablestyle->parent, sizeof(tablestyle->parent)))
      pass ("TABLESTYLE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("TABLESTYLE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_B title_suppressed;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "title_suppressed", &title_suppressed, NULL) &&
        title_suppressed == tablestyle->title_suppressed)
      pass ("TABLESTYLE.title_suppressed [B] " FORMAT_B "", title_suppressed);
    else
      {
        fail ("TABLESTYLE.title_suppressed [B] " FORMAT_B " != " FORMAT_B "", tablestyle->title_suppressed, title_suppressed); error++;
      }
    title_suppressed++;
    if (dwg_dynapi_entity_set_value(tablestyle, "TABLESTYLE", "title_suppressed", &title_suppressed) &&
        title_suppressed == tablestyle->title_suppressed)
      pass ("TABLESTYLE.title_suppressed [B] set+1 " FORMAT_B "", title_suppressed);
    else
      {
        fail ("TABLESTYLE.title_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", tablestyle->title_suppressed, title_suppressed); error++;
      }
    tablestyle->title_suppressed--;

  }
  {
    BITCODE_BD vert_cell_margin;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "vert_cell_margin", &vert_cell_margin, NULL) &&
        vert_cell_margin == tablestyle->vert_cell_margin)
      pass ("TABLESTYLE.vert_cell_margin [BD] %g", vert_cell_margin);
    else
      {
        fail ("TABLESTYLE.vert_cell_margin [BD] %g != %g", tablestyle->vert_cell_margin, vert_cell_margin); error++;
      }
    vert_cell_margin++;
    if (dwg_dynapi_entity_set_value(tablestyle, "TABLESTYLE", "vert_cell_margin", &vert_cell_margin) &&
        vert_cell_margin == tablestyle->vert_cell_margin)
      pass ("TABLESTYLE.vert_cell_margin [BD] set+1 %g", vert_cell_margin);
    else
      {
        fail ("TABLESTYLE.vert_cell_margin [BD] set+1 %g != %g", tablestyle->vert_cell_margin, vert_cell_margin); error++;
      }
    tablestyle->vert_cell_margin--;

  }
  return error;
}
static int test_UCS (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_UCS *ucs = obj->tio.object->tio.UCS;
  {
    BITCODE_H base_ucs_handle;
    if (dwg_dynapi_entity_value(ucs, "UCS", "base_ucs_handle", &base_ucs_handle, NULL)
        && !memcmp(&base_ucs_handle, &ucs->base_ucs_handle, sizeof(ucs->base_ucs_handle)))
      pass ("UCS.base_ucs_handle [H]");
    else
      {
        fail ("UCS.base_ucs_handle [H]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(ucs, "UCS", "elevation", &elevation, NULL) &&
        elevation == ucs->elevation)
      pass ("UCS.elevation [BD] %g", elevation);
    else
      {
        fail ("UCS.elevation [BD] %g != %g", ucs->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(ucs, "UCS", "elevation", &elevation) &&
        elevation == ucs->elevation)
      pass ("UCS.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("UCS.elevation [BD] set+1 %g != %g", ucs->elevation, elevation); error++;
      }
    ucs->elevation--;

  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(ucs, "UCS", "flag", &flag, NULL) &&
        flag == ucs->flag)
      pass ("UCS.flag [RC] %u", flag);
    else
      {
        fail ("UCS.flag [RC] %u != %u", ucs->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(ucs, "UCS", "flag", &flag) &&
        flag == ucs->flag)
      pass ("UCS.flag [RC] set+1 %u", flag);
    else
      {
        fail ("UCS.flag [RC] set+1 %u != %u", ucs->flag, flag); error++;
      }
    ucs->flag--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(ucs, "UCS", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&ucs->name))
      pass ("UCS.name [TV]");
    else
      {
        fail ("UCS.name [TV]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(ucs, "UCS", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &ucs->null_handle, sizeof(ucs->null_handle)))
      pass ("UCS.null_handle [H]");
    else
      {
        fail ("UCS.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_3BD origin;
    if (dwg_dynapi_entity_value(ucs, "UCS", "origin", &origin, NULL)
        && !memcmp(&origin, &ucs->origin, sizeof(ucs->origin)))
      pass ("UCS.origin [3BD]");
    else
      {
        fail ("UCS.origin [3BD]"); error++;
      }
  }
  {
    BITCODE_BS orthographic_type;
    if (dwg_dynapi_entity_value(ucs, "UCS", "orthographic_type", &orthographic_type, NULL) &&
        orthographic_type == ucs->orthographic_type)
      pass ("UCS.orthographic_type [BS] %hu", orthographic_type);
    else
      {
        fail ("UCS.orthographic_type [BS] %hu != %hu", ucs->orthographic_type, orthographic_type); error++;
      }
    orthographic_type++;
    if (dwg_dynapi_entity_set_value(ucs, "UCS", "orthographic_type", &orthographic_type) &&
        orthographic_type == ucs->orthographic_type)
      pass ("UCS.orthographic_type [BS] set+1 %hu", orthographic_type);
    else
      {
        fail ("UCS.orthographic_type [BS] set+1 %hu != %hu", ucs->orthographic_type, orthographic_type); error++;
      }
    ucs->orthographic_type--;

  }
  {
    BITCODE_BS orthographic_view_type;
    if (dwg_dynapi_entity_value(ucs, "UCS", "orthographic_view_type", &orthographic_view_type, NULL) &&
        orthographic_view_type == ucs->orthographic_view_type)
      pass ("UCS.orthographic_view_type [BS] %hu", orthographic_view_type);
    else
      {
        fail ("UCS.orthographic_view_type [BS] %hu != %hu", ucs->orthographic_view_type, orthographic_view_type); error++;
      }
    orthographic_view_type++;
    if (dwg_dynapi_entity_set_value(ucs, "UCS", "orthographic_view_type", &orthographic_view_type) &&
        orthographic_view_type == ucs->orthographic_view_type)
      pass ("UCS.orthographic_view_type [BS] set+1 %hu", orthographic_view_type);
    else
      {
        fail ("UCS.orthographic_view_type [BS] set+1 %hu != %hu", ucs->orthographic_view_type, orthographic_view_type); error++;
      }
    ucs->orthographic_view_type--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(ucs, "UCS", "parent", &parent, NULL)
        && !memcmp(&parent, &ucs->parent, sizeof(ucs->parent)))
      pass ("UCS.parent [struct _dwg_object_object*]");
    else
      {
        fail ("UCS.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H ucs_control;
    if (dwg_dynapi_entity_value(ucs, "UCS", "ucs_control", &ucs_control, NULL)
        && !memcmp(&ucs_control, &ucs->ucs_control, sizeof(ucs->ucs_control)))
      pass ("UCS.ucs_control [H]");
    else
      {
        fail ("UCS.ucs_control [H]"); error++;
      }
  }
  {
    BITCODE_H unknown;
    if (dwg_dynapi_entity_value(ucs, "UCS", "unknown", &unknown, NULL)
        && !memcmp(&unknown, &ucs->unknown, sizeof(ucs->unknown)))
      pass ("UCS.unknown [H]");
    else
      {
        fail ("UCS.unknown [H]"); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(ucs, "UCS", "used", &used, NULL) &&
        used == ucs->used)
      pass ("UCS.used [RS] %hu", used);
    else
      {
        fail ("UCS.used [RS] %hu != %hu", ucs->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(ucs, "UCS", "used", &used) &&
        used == ucs->used)
      pass ("UCS.used [RS] set+1 %hu", used);
    else
      {
        fail ("UCS.used [RS] set+1 %hu != %hu", ucs->used, used); error++;
      }
    ucs->used--;

  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value(ucs, "UCS", "x_direction", &x_direction, NULL)
        && !memcmp(&x_direction, &ucs->x_direction, sizeof(ucs->x_direction)))
      pass ("UCS.x_direction [3BD]");
    else
      {
        fail ("UCS.x_direction [3BD]"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(ucs, "UCS", "xrefdep", &xrefdep, NULL) &&
        xrefdep == ucs->xrefdep)
      pass ("UCS.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("UCS.xrefdep [B] " FORMAT_B " != " FORMAT_B "", ucs->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(ucs, "UCS", "xrefdep", &xrefdep) &&
        xrefdep == ucs->xrefdep)
      pass ("UCS.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("UCS.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", ucs->xrefdep, xrefdep); error++;
      }
    ucs->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(ucs, "UCS", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == ucs->xrefindex_plus1)
      pass ("UCS.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("UCS.xrefindex_plus1 [BS] %hu != %hu", ucs->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(ucs, "UCS", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == ucs->xrefindex_plus1)
      pass ("UCS.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("UCS.xrefindex_plus1 [BS] set+1 %hu != %hu", ucs->xrefindex_plus1, xrefindex_plus1); error++;
      }
    ucs->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(ucs, "UCS", "xrefref", &xrefref, NULL) &&
        xrefref == ucs->xrefref)
      pass ("UCS.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("UCS.xrefref [B] " FORMAT_B " != " FORMAT_B "", ucs->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(ucs, "UCS", "xrefref", &xrefref) &&
        xrefref == ucs->xrefref)
      pass ("UCS.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("UCS.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", ucs->xrefref, xrefref); error++;
      }
    ucs->xrefref--;

  }
  {
    BITCODE_3BD y_direction;
    if (dwg_dynapi_entity_value(ucs, "UCS", "y_direction", &y_direction, NULL)
        && !memcmp(&y_direction, &ucs->y_direction, sizeof(ucs->y_direction)))
      pass ("UCS.y_direction [3BD]");
    else
      {
        fail ("UCS.y_direction [3BD]"); error++;
      }
  }
  return error;
}
static int test_UCS_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_UCS_CONTROL *ucs_control = obj->tio.object->tio.UCS_CONTROL;
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &ucs_control->null_handle, sizeof(ucs_control->null_handle)))
      pass ("UCS_CONTROL.null_handle [H]");
    else
      {
        fail ("UCS_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == ucs_control->num_entries)
      pass ("UCS_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("UCS_CONTROL.num_entries [BS] %hu != %hu", ucs_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(ucs_control, "UCS_CONTROL", "num_entries", &num_entries) &&
        num_entries == ucs_control->num_entries)
      pass ("UCS_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("UCS_CONTROL.num_entries [BS] set+1 %hu != %hu", ucs_control->num_entries, num_entries); error++;
      }
    ucs_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "objid", &objid, NULL) &&
        objid == ucs_control->objid)
      pass ("UCS_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("UCS_CONTROL.objid [BL] %u != %u", ucs_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(ucs_control, "UCS_CONTROL", "objid", &objid) &&
        objid == ucs_control->objid)
      pass ("UCS_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("UCS_CONTROL.objid [BL] set+1 %u != %u", ucs_control->objid, objid); error++;
      }
    ucs_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &ucs_control->parent, sizeof(ucs_control->parent)))
      pass ("UCS_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("UCS_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &ucs_control->reactors, sizeof(ucs_control->reactors)))
      pass ("UCS_CONTROL.reactors [H]");
    else
      {
        fail ("UCS_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H ucs;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "ucs", &ucs, NULL)
        && !memcmp(&ucs, &ucs_control->ucs, sizeof(ucs_control->ucs)))
      pass ("UCS_CONTROL.ucs [H]");
    else
      {
        fail ("UCS_CONTROL.ucs [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &ucs_control->xdicobjhandle, sizeof(ucs_control->xdicobjhandle)))
      pass ("UCS_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("UCS_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_UNDERLAYDEFINITION (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_UNDERLAYDEFINITION *underlaydefinition = obj->tio.object->tio.UNDERLAYDEFINITION;
  {
    BITCODE_TV filename;
    if (dwg_dynapi_entity_value(underlaydefinition, "UNDERLAYDEFINITION", "filename", &filename, NULL)
        && !strcmp((char*)&filename, (char*)&underlaydefinition->filename))
      pass ("UNDERLAYDEFINITION.filename [TV]");
    else
      {
        fail ("UNDERLAYDEFINITION.filename [TV]"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(underlaydefinition, "UNDERLAYDEFINITION", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&underlaydefinition->name))
      pass ("UNDERLAYDEFINITION.name [TV]");
    else
      {
        fail ("UNDERLAYDEFINITION.name [TV]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(underlaydefinition, "UNDERLAYDEFINITION", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &underlaydefinition->ownerhandle, sizeof(underlaydefinition->ownerhandle)))
      pass ("UNDERLAYDEFINITION.ownerhandle [H]");
    else
      {
        fail ("UNDERLAYDEFINITION.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(underlaydefinition, "UNDERLAYDEFINITION", "parent", &parent, NULL)
        && !memcmp(&parent, &underlaydefinition->parent, sizeof(underlaydefinition->parent)))
      pass ("UNDERLAYDEFINITION.parent [struct _dwg_object_object*]");
    else
      {
        fail ("UNDERLAYDEFINITION.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_UNKNOWN_OBJ (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_UNKNOWN_OBJ *unknown_obj = obj->tio.object->tio.UNKNOWN_OBJ;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(unknown_obj, "UNKNOWN_OBJ", "parent", &parent, NULL)
        && !memcmp(&parent, &unknown_obj->parent, sizeof(unknown_obj->parent)))
      pass ("UNKNOWN_OBJ.parent [struct _dwg_object_object*]");
    else
      {
        fail ("UNKNOWN_OBJ.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_VBA_PROJECT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VBA_PROJECT *vba_project = obj->tio.object->tio.VBA_PROJECT;
  {
    BITCODE_TF bytes;
    if (dwg_dynapi_entity_value(vba_project, "VBA_PROJECT", "bytes", &bytes, NULL)
        && !memcmp(&bytes, &vba_project->bytes, sizeof(vba_project->bytes)))
      pass ("VBA_PROJECT.bytes [TF]");
    else
      {
        fail ("VBA_PROJECT.bytes [TF]"); error++;
      }
  }
  {
    BITCODE_RL num_bytes;
    if (dwg_dynapi_entity_value(vba_project, "VBA_PROJECT", "num_bytes", &num_bytes, NULL) &&
        num_bytes == vba_project->num_bytes)
      pass ("VBA_PROJECT.num_bytes [RL] %u", num_bytes);
    else
      {
        fail ("VBA_PROJECT.num_bytes [RL] %u != %u", vba_project->num_bytes, num_bytes); error++;
      }
    num_bytes++;
    if (dwg_dynapi_entity_set_value(vba_project, "VBA_PROJECT", "num_bytes", &num_bytes) &&
        num_bytes == vba_project->num_bytes)
      pass ("VBA_PROJECT.num_bytes [RL] set+1 %u", num_bytes);
    else
      {
        fail ("VBA_PROJECT.num_bytes [RL] set+1 %u != %u", vba_project->num_bytes, num_bytes); error++;
      }
    vba_project->num_bytes--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(vba_project, "VBA_PROJECT", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &vba_project->ownerhandle, sizeof(vba_project->ownerhandle)))
      pass ("VBA_PROJECT.ownerhandle [H]");
    else
      {
        fail ("VBA_PROJECT.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vba_project, "VBA_PROJECT", "parent", &parent, NULL)
        && !memcmp(&parent, &vba_project->parent, sizeof(vba_project->parent)))
      pass ("VBA_PROJECT.parent [struct _dwg_object_object*]");
    else
      {
        fail ("VBA_PROJECT.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_VIEW (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VIEW *view = obj->tio.object->tio.VIEW;
  {
    BITCODE_4BITS VIEWMODE;
    if (dwg_dynapi_entity_value(view, "VIEW", "VIEWMODE", &VIEWMODE, NULL) &&
        VIEWMODE == view->VIEWMODE)
      pass ("VIEW.VIEWMODE [4BITS] " FORMAT_4BITS "", VIEWMODE);
    else
      {
        fail ("VIEW.VIEWMODE [4BITS] " FORMAT_4BITS " != " FORMAT_4BITS "", view->VIEWMODE, VIEWMODE); error++;
      }
    if (dwg_dynapi_entity_set_value(view, "VIEW", "VIEWMODE", &VIEWMODE) &&
        VIEWMODE == view->VIEWMODE)
      pass ("VIEW.VIEWMODE [4BITS] set+1 " FORMAT_4BITS "", VIEWMODE);
    else
      {
        fail ("VIEW.VIEWMODE [4BITS] set+1 " FORMAT_4BITS " != " FORMAT_4BITS "", view->VIEWMODE, VIEWMODE); error++;
      }
    view->VIEWMODE--;

  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value(view, "VIEW", "ambient_color", &ambient_color, NULL)
        && !memcmp(&ambient_color, &view->ambient_color, sizeof(view->ambient_color)))
      pass ("VIEW.ambient_color [CMC]");
    else
      {
        fail ("VIEW.ambient_color [CMC]"); error++;
      }
  }
  {
    BITCODE_B associated_ucs;
    if (dwg_dynapi_entity_value(view, "VIEW", "associated_ucs", &associated_ucs, NULL) &&
        associated_ucs == view->associated_ucs)
      pass ("VIEW.associated_ucs [B] " FORMAT_B "", associated_ucs);
    else
      {
        fail ("VIEW.associated_ucs [B] " FORMAT_B " != " FORMAT_B "", view->associated_ucs, associated_ucs); error++;
      }
    associated_ucs++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "associated_ucs", &associated_ucs) &&
        associated_ucs == view->associated_ucs)
      pass ("VIEW.associated_ucs [B] set+1 " FORMAT_B "", associated_ucs);
    else
      {
        fail ("VIEW.associated_ucs [B] set+1 " FORMAT_B " != " FORMAT_B "", view->associated_ucs, associated_ucs); error++;
      }
    view->associated_ucs--;

  }
  {
    BITCODE_BD back_clip;
    if (dwg_dynapi_entity_value(view, "VIEW", "back_clip", &back_clip, NULL) &&
        back_clip == view->back_clip)
      pass ("VIEW.back_clip [BD] %g", back_clip);
    else
      {
        fail ("VIEW.back_clip [BD] %g != %g", view->back_clip, back_clip); error++;
      }
    back_clip++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "back_clip", &back_clip) &&
        back_clip == view->back_clip)
      pass ("VIEW.back_clip [BD] set+1 %g", back_clip);
    else
      {
        fail ("VIEW.back_clip [BD] set+1 %g != %g", view->back_clip, back_clip); error++;
      }
    view->back_clip--;

  }
  {
    BITCODE_H background_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "background_handle", &background_handle, NULL)
        && !memcmp(&background_handle, &view->background_handle, sizeof(view->background_handle)))
      pass ("VIEW.background_handle [H]");
    else
      {
        fail ("VIEW.background_handle [H]"); error++;
      }
  }
  {
    BITCODE_H base_ucs_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "base_ucs_handle", &base_ucs_handle, NULL)
        && !memcmp(&base_ucs_handle, &view->base_ucs_handle, sizeof(view->base_ucs_handle)))
      pass ("VIEW.base_ucs_handle [H]");
    else
      {
        fail ("VIEW.base_ucs_handle [H]"); error++;
      }
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value(view, "VIEW", "brightness", &brightness, NULL) &&
        brightness == view->brightness)
      pass ("VIEW.brightness [BD] %g", brightness);
    else
      {
        fail ("VIEW.brightness [BD] %g != %g", view->brightness, brightness); error++;
      }
    brightness++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "brightness", &brightness) &&
        brightness == view->brightness)
      pass ("VIEW.brightness [BD] set+1 %g", brightness);
    else
      {
        fail ("VIEW.brightness [BD] set+1 %g != %g", view->brightness, brightness); error++;
      }
    view->brightness--;

  }
  {
    BITCODE_B camera_plottable;
    if (dwg_dynapi_entity_value(view, "VIEW", "camera_plottable", &camera_plottable, NULL) &&
        camera_plottable == view->camera_plottable)
      pass ("VIEW.camera_plottable [B] " FORMAT_B "", camera_plottable);
    else
      {
        fail ("VIEW.camera_plottable [B] " FORMAT_B " != " FORMAT_B "", view->camera_plottable, camera_plottable); error++;
      }
    camera_plottable++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "camera_plottable", &camera_plottable) &&
        camera_plottable == view->camera_plottable)
      pass ("VIEW.camera_plottable [B] set+1 " FORMAT_B "", camera_plottable);
    else
      {
        fail ("VIEW.camera_plottable [B] set+1 " FORMAT_B " != " FORMAT_B "", view->camera_plottable, camera_plottable); error++;
      }
    view->camera_plottable--;

  }
  {
    BITCODE_2RD center;
    if (dwg_dynapi_entity_value(view, "VIEW", "center", &center, NULL)
        && !memcmp(&center, &view->center, sizeof(view->center)))
      pass ("VIEW.center [2RD]");
    else
      {
        fail ("VIEW.center [2RD]"); error++;
      }
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value(view, "VIEW", "contrast", &contrast, NULL) &&
        contrast == view->contrast)
      pass ("VIEW.contrast [BD] %g", contrast);
    else
      {
        fail ("VIEW.contrast [BD] %g != %g", view->contrast, contrast); error++;
      }
    contrast++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "contrast", &contrast) &&
        contrast == view->contrast)
      pass ("VIEW.contrast [BD] set+1 %g", contrast);
    else
      {
        fail ("VIEW.contrast [BD] set+1 %g != %g", view->contrast, contrast); error++;
      }
    view->contrast--;

  }
  {
    BITCODE_RC default_lightning_type;
    if (dwg_dynapi_entity_value(view, "VIEW", "default_lightning_type", &default_lightning_type, NULL) &&
        default_lightning_type == view->default_lightning_type)
      pass ("VIEW.default_lightning_type [RC] %u", default_lightning_type);
    else
      {
        fail ("VIEW.default_lightning_type [RC] %u != %u", view->default_lightning_type, default_lightning_type); error++;
      }
    default_lightning_type++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "default_lightning_type", &default_lightning_type) &&
        default_lightning_type == view->default_lightning_type)
      pass ("VIEW.default_lightning_type [RC] set+1 %u", default_lightning_type);
    else
      {
        fail ("VIEW.default_lightning_type [RC] set+1 %u != %u", view->default_lightning_type, default_lightning_type); error++;
      }
    view->default_lightning_type--;

  }
  {
    BITCODE_3BD direction;
    if (dwg_dynapi_entity_value(view, "VIEW", "direction", &direction, NULL)
        && !memcmp(&direction, &view->direction, sizeof(view->direction)))
      pass ("VIEW.direction [3BD]");
    else
      {
        fail ("VIEW.direction [3BD]"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(view, "VIEW", "elevation", &elevation, NULL) &&
        elevation == view->elevation)
      pass ("VIEW.elevation [BD] %g", elevation);
    else
      {
        fail ("VIEW.elevation [BD] %g != %g", view->elevation, elevation); error++;
      }
    elevation++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "elevation", &elevation) &&
        elevation == view->elevation)
      pass ("VIEW.elevation [BD] set+1 %g", elevation);
    else
      {
        fail ("VIEW.elevation [BD] set+1 %g != %g", view->elevation, elevation); error++;
      }
    view->elevation--;

  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(view, "VIEW", "flag", &flag, NULL) &&
        flag == view->flag)
      pass ("VIEW.flag [RC] %u", flag);
    else
      {
        fail ("VIEW.flag [RC] %u != %u", view->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "flag", &flag) &&
        flag == view->flag)
      pass ("VIEW.flag [RC] set+1 %u", flag);
    else
      {
        fail ("VIEW.flag [RC] set+1 %u != %u", view->flag, flag); error++;
      }
    view->flag--;

  }
  {
    BITCODE_BD front_clip;
    if (dwg_dynapi_entity_value(view, "VIEW", "front_clip", &front_clip, NULL) &&
        front_clip == view->front_clip)
      pass ("VIEW.front_clip [BD] %g", front_clip);
    else
      {
        fail ("VIEW.front_clip [BD] %g != %g", view->front_clip, front_clip); error++;
      }
    front_clip++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "front_clip", &front_clip) &&
        front_clip == view->front_clip)
      pass ("VIEW.front_clip [BD] set+1 %g", front_clip);
    else
      {
        fail ("VIEW.front_clip [BD] set+1 %g != %g", view->front_clip, front_clip); error++;
      }
    view->front_clip--;

  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value(view, "VIEW", "height", &height, NULL) &&
        height == view->height)
      pass ("VIEW.height [BD] %g", height);
    else
      {
        fail ("VIEW.height [BD] %g != %g", view->height, height); error++;
      }
    height++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "height", &height) &&
        height == view->height)
      pass ("VIEW.height [BD] set+1 %g", height);
    else
      {
        fail ("VIEW.height [BD] set+1 %g != %g", view->height, height); error++;
      }
    view->height--;

  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value(view, "VIEW", "lens_length", &lens_length, NULL) &&
        lens_length == view->lens_length)
      pass ("VIEW.lens_length [BD] %g", lens_length);
    else
      {
        fail ("VIEW.lens_length [BD] %g != %g", view->lens_length, lens_length); error++;
      }
    lens_length++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "lens_length", &lens_length) &&
        lens_length == view->lens_length)
      pass ("VIEW.lens_length [BD] set+1 %g", lens_length);
    else
      {
        fail ("VIEW.lens_length [BD] set+1 %g != %g", view->lens_length, lens_length); error++;
      }
    view->lens_length--;

  }
  {
    BITCODE_H live_section_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "live_section_handle", &live_section_handle, NULL)
        && !memcmp(&live_section_handle, &view->live_section_handle, sizeof(view->live_section_handle)))
      pass ("VIEW.live_section_handle [H]");
    else
      {
        fail ("VIEW.live_section_handle [H]"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(view, "VIEW", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&view->name))
      pass ("VIEW.name [TV]");
    else
      {
        fail ("VIEW.name [TV]"); error++;
      }
  }
  {
    BITCODE_H named_ucs_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "named_ucs_handle", &named_ucs_handle, NULL)
        && !memcmp(&named_ucs_handle, &view->named_ucs_handle, sizeof(view->named_ucs_handle)))
      pass ("VIEW.named_ucs_handle [H]");
    else
      {
        fail ("VIEW.named_ucs_handle [H]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &view->null_handle, sizeof(view->null_handle)))
      pass ("VIEW.null_handle [H]");
    else
      {
        fail ("VIEW.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_3BD origin;
    if (dwg_dynapi_entity_value(view, "VIEW", "origin", &origin, NULL)
        && !memcmp(&origin, &view->origin, sizeof(view->origin)))
      pass ("VIEW.origin [3BD]");
    else
      {
        fail ("VIEW.origin [3BD]"); error++;
      }
  }
  {
    BITCODE_BS orthographic_view_type;
    if (dwg_dynapi_entity_value(view, "VIEW", "orthographic_view_type", &orthographic_view_type, NULL) &&
        orthographic_view_type == view->orthographic_view_type)
      pass ("VIEW.orthographic_view_type [BS] %hu", orthographic_view_type);
    else
      {
        fail ("VIEW.orthographic_view_type [BS] %hu != %hu", view->orthographic_view_type, orthographic_view_type); error++;
      }
    orthographic_view_type++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "orthographic_view_type", &orthographic_view_type) &&
        orthographic_view_type == view->orthographic_view_type)
      pass ("VIEW.orthographic_view_type [BS] set+1 %hu", orthographic_view_type);
    else
      {
        fail ("VIEW.orthographic_view_type [BS] set+1 %hu != %hu", view->orthographic_view_type, orthographic_view_type); error++;
      }
    view->orthographic_view_type--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(view, "VIEW", "parent", &parent, NULL)
        && !memcmp(&parent, &view->parent, sizeof(view->parent)))
      pass ("VIEW.parent [struct _dwg_object_object*]");
    else
      {
        fail ("VIEW.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_B pspace_flag;
    if (dwg_dynapi_entity_value(view, "VIEW", "pspace_flag", &pspace_flag, NULL) &&
        pspace_flag == view->pspace_flag)
      pass ("VIEW.pspace_flag [B] " FORMAT_B "", pspace_flag);
    else
      {
        fail ("VIEW.pspace_flag [B] " FORMAT_B " != " FORMAT_B "", view->pspace_flag, pspace_flag); error++;
      }
    pspace_flag++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "pspace_flag", &pspace_flag) &&
        pspace_flag == view->pspace_flag)
      pass ("VIEW.pspace_flag [B] set+1 " FORMAT_B "", pspace_flag);
    else
      {
        fail ("VIEW.pspace_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", view->pspace_flag, pspace_flag); error++;
      }
    view->pspace_flag--;

  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value(view, "VIEW", "render_mode", &render_mode, NULL) &&
        render_mode == view->render_mode)
      pass ("VIEW.render_mode [RC] %u", render_mode);
    else
      {
        fail ("VIEW.render_mode [RC] %u != %u", view->render_mode, render_mode); error++;
      }
    render_mode++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "render_mode", &render_mode) &&
        render_mode == view->render_mode)
      pass ("VIEW.render_mode [RC] set+1 %u", render_mode);
    else
      {
        fail ("VIEW.render_mode [RC] set+1 %u != %u", view->render_mode, render_mode); error++;
      }
    view->render_mode--;

  }
  {
    BITCODE_H sun_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "sun_handle", &sun_handle, NULL)
        && !memcmp(&sun_handle, &view->sun_handle, sizeof(view->sun_handle)))
      pass ("VIEW.sun_handle [H]");
    else
      {
        fail ("VIEW.sun_handle [H]"); error++;
      }
  }
  {
    BITCODE_3BD target;
    if (dwg_dynapi_entity_value(view, "VIEW", "target", &target, NULL)
        && !memcmp(&target, &view->target, sizeof(view->target)))
      pass ("VIEW.target [3BD]");
    else
      {
        fail ("VIEW.target [3BD]"); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(view, "VIEW", "twist_angle", &twist_angle, NULL) &&
        twist_angle == view->twist_angle)
      pass ("VIEW.twist_angle [BD] %g", twist_angle);
    else
      {
        fail ("VIEW.twist_angle [BD] %g != %g", view->twist_angle, twist_angle); error++;
      }
    twist_angle++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "twist_angle", &twist_angle) &&
        twist_angle == view->twist_angle)
      pass ("VIEW.twist_angle [BD] set+1 %g", twist_angle);
    else
      {
        fail ("VIEW.twist_angle [BD] set+1 %g != %g", view->twist_angle, twist_angle); error++;
      }
    view->twist_angle--;

  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value(view, "VIEW", "use_default_lights", &use_default_lights, NULL) &&
        use_default_lights == view->use_default_lights)
      pass ("VIEW.use_default_lights [B] " FORMAT_B "", use_default_lights);
    else
      {
        fail ("VIEW.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", view->use_default_lights, use_default_lights); error++;
      }
    use_default_lights++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "use_default_lights", &use_default_lights) &&
        use_default_lights == view->use_default_lights)
      pass ("VIEW.use_default_lights [B] set+1 " FORMAT_B "", use_default_lights);
    else
      {
        fail ("VIEW.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", view->use_default_lights, use_default_lights); error++;
      }
    view->use_default_lights--;

  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(view, "VIEW", "used", &used, NULL) &&
        used == view->used)
      pass ("VIEW.used [RS] %hu", used);
    else
      {
        fail ("VIEW.used [RS] %hu != %hu", view->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "used", &used) &&
        used == view->used)
      pass ("VIEW.used [RS] set+1 %hu", used);
    else
      {
        fail ("VIEW.used [RS] set+1 %hu != %hu", view->used, used); error++;
      }
    view->used--;

  }
  {
    BITCODE_H view_control;
    if (dwg_dynapi_entity_value(view, "VIEW", "view_control", &view_control, NULL)
        && !memcmp(&view_control, &view->view_control, sizeof(view->view_control)))
      pass ("VIEW.view_control [H]");
    else
      {
        fail ("VIEW.view_control [H]"); error++;
      }
  }
  {
    BITCODE_H visual_style_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "visual_style_handle", &visual_style_handle, NULL)
        && !memcmp(&visual_style_handle, &view->visual_style_handle, sizeof(view->visual_style_handle)))
      pass ("VIEW.visual_style_handle [H]");
    else
      {
        fail ("VIEW.visual_style_handle [H]"); error++;
      }
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value(view, "VIEW", "width", &width, NULL) &&
        width == view->width)
      pass ("VIEW.width [BD] %g", width);
    else
      {
        fail ("VIEW.width [BD] %g != %g", view->width, width); error++;
      }
    width++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "width", &width) &&
        width == view->width)
      pass ("VIEW.width [BD] set+1 %g", width);
    else
      {
        fail ("VIEW.width [BD] set+1 %g != %g", view->width, width); error++;
      }
    view->width--;

  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value(view, "VIEW", "x_direction", &x_direction, NULL)
        && !memcmp(&x_direction, &view->x_direction, sizeof(view->x_direction)))
      pass ("VIEW.x_direction [3BD]");
    else
      {
        fail ("VIEW.x_direction [3BD]"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(view, "VIEW", "xrefdep", &xrefdep, NULL) &&
        xrefdep == view->xrefdep)
      pass ("VIEW.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("VIEW.xrefdep [B] " FORMAT_B " != " FORMAT_B "", view->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "xrefdep", &xrefdep) &&
        xrefdep == view->xrefdep)
      pass ("VIEW.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("VIEW.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", view->xrefdep, xrefdep); error++;
      }
    view->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(view, "VIEW", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == view->xrefindex_plus1)
      pass ("VIEW.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("VIEW.xrefindex_plus1 [BS] %hu != %hu", view->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == view->xrefindex_plus1)
      pass ("VIEW.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("VIEW.xrefindex_plus1 [BS] set+1 %hu != %hu", view->xrefindex_plus1, xrefindex_plus1); error++;
      }
    view->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(view, "VIEW", "xrefref", &xrefref, NULL) &&
        xrefref == view->xrefref)
      pass ("VIEW.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("VIEW.xrefref [B] " FORMAT_B " != " FORMAT_B "", view->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(view, "VIEW", "xrefref", &xrefref) &&
        xrefref == view->xrefref)
      pass ("VIEW.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("VIEW.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", view->xrefref, xrefref); error++;
      }
    view->xrefref--;

  }
  {
    BITCODE_3BD y_direction;
    if (dwg_dynapi_entity_value(view, "VIEW", "y_direction", &y_direction, NULL)
        && !memcmp(&y_direction, &view->y_direction, sizeof(view->y_direction)))
      pass ("VIEW.y_direction [3BD]");
    else
      {
        fail ("VIEW.y_direction [3BD]"); error++;
      }
  }
  return error;
}
static int test_VIEW_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VIEW_CONTROL *view_control = obj->tio.object->tio.VIEW_CONTROL;
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &view_control->null_handle, sizeof(view_control->null_handle)))
      pass ("VIEW_CONTROL.null_handle [H]");
    else
      {
        fail ("VIEW_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == view_control->num_entries)
      pass ("VIEW_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("VIEW_CONTROL.num_entries [BS] %hu != %hu", view_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(view_control, "VIEW_CONTROL", "num_entries", &num_entries) &&
        num_entries == view_control->num_entries)
      pass ("VIEW_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("VIEW_CONTROL.num_entries [BS] set+1 %hu != %hu", view_control->num_entries, num_entries); error++;
      }
    view_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "objid", &objid, NULL) &&
        objid == view_control->objid)
      pass ("VIEW_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("VIEW_CONTROL.objid [BL] %u != %u", view_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(view_control, "VIEW_CONTROL", "objid", &objid) &&
        objid == view_control->objid)
      pass ("VIEW_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("VIEW_CONTROL.objid [BL] set+1 %u != %u", view_control->objid, objid); error++;
      }
    view_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &view_control->parent, sizeof(view_control->parent)))
      pass ("VIEW_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("VIEW_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &view_control->reactors, sizeof(view_control->reactors)))
      pass ("VIEW_CONTROL.reactors [H]");
    else
      {
        fail ("VIEW_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H views;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "views", &views, NULL)
        && !memcmp(&views, &view_control->views, sizeof(view_control->views)))
      pass ("VIEW_CONTROL.views [H]");
    else
      {
        fail ("VIEW_CONTROL.views [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &view_control->xdicobjhandle, sizeof(view_control->xdicobjhandle)))
      pass ("VIEW_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("VIEW_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_VISUALSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VISUALSTYLE *visualstyle = obj->tio.object->tio.VISUALSTYLE;
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "color", &color, NULL)
        && !memcmp(&color, &visualstyle->color, sizeof(visualstyle->color)))
      pass ("VISUALSTYLE.color [CMC]");
    else
      {
        fail ("VISUALSTYLE.color [CMC]"); error++;
      }
  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "desc", &desc, NULL)
        && !memcmp(&desc, &visualstyle->desc, sizeof(visualstyle->desc)))
      pass ("VISUALSTYLE.desc [T]");
    else
      {
        fail ("VISUALSTYLE.desc [T]"); error++;
      }
  }
  {
    BITCODE_BD display_brightness;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "display_brightness", &display_brightness, NULL) &&
        display_brightness == visualstyle->display_brightness)
      pass ("VISUALSTYLE.display_brightness [BD] %g", display_brightness);
    else
      {
        fail ("VISUALSTYLE.display_brightness [BD] %g != %g", visualstyle->display_brightness, display_brightness); error++;
      }
    display_brightness++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "display_brightness", &display_brightness) &&
        display_brightness == visualstyle->display_brightness)
      pass ("VISUALSTYLE.display_brightness [BD] set+1 %g", display_brightness);
    else
      {
        fail ("VISUALSTYLE.display_brightness [BD] set+1 %g != %g", visualstyle->display_brightness, display_brightness); error++;
      }
    visualstyle->display_brightness--;

  }
  {
    BITCODE_BS display_shadow_type;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "display_shadow_type", &display_shadow_type, NULL) &&
        display_shadow_type == visualstyle->display_shadow_type)
      pass ("VISUALSTYLE.display_shadow_type [BS] %hu", display_shadow_type);
    else
      {
        fail ("VISUALSTYLE.display_shadow_type [BS] %hu != %hu", visualstyle->display_shadow_type, display_shadow_type); error++;
      }
    display_shadow_type++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "display_shadow_type", &display_shadow_type) &&
        display_shadow_type == visualstyle->display_shadow_type)
      pass ("VISUALSTYLE.display_shadow_type [BS] set+1 %hu", display_shadow_type);
    else
      {
        fail ("VISUALSTYLE.display_shadow_type [BS] set+1 %hu != %hu", visualstyle->display_shadow_type, display_shadow_type); error++;
      }
    visualstyle->display_shadow_type--;

  }
  {
    BITCODE_BS display_style;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "display_style", &display_style, NULL) &&
        display_style == visualstyle->display_style)
      pass ("VISUALSTYLE.display_style [BS] %hu", display_style);
    else
      {
        fail ("VISUALSTYLE.display_style [BS] %hu != %hu", visualstyle->display_style, display_style); error++;
      }
    display_style++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "display_style", &display_style) &&
        display_style == visualstyle->display_style)
      pass ("VISUALSTYLE.display_style [BS] set+1 %hu", display_style);
    else
      {
        fail ("VISUALSTYLE.display_style [BS] set+1 %hu != %hu", visualstyle->display_style, display_style); error++;
      }
    visualstyle->display_style--;

  }
  {
    BITCODE_CMC edge_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_color", &edge_color, NULL)
        && !memcmp(&edge_color, &visualstyle->edge_color, sizeof(visualstyle->edge_color)))
      pass ("VISUALSTYLE.edge_color [CMC]");
    else
      {
        fail ("VISUALSTYLE.edge_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD edge_crease_angle;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_crease_angle", &edge_crease_angle, NULL) &&
        edge_crease_angle == visualstyle->edge_crease_angle)
      pass ("VISUALSTYLE.edge_crease_angle [BD] %g", edge_crease_angle);
    else
      {
        fail ("VISUALSTYLE.edge_crease_angle [BD] %g != %g", visualstyle->edge_crease_angle, edge_crease_angle); error++;
      }
    edge_crease_angle++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_crease_angle", &edge_crease_angle) &&
        edge_crease_angle == visualstyle->edge_crease_angle)
      pass ("VISUALSTYLE.edge_crease_angle [BD] set+1 %g", edge_crease_angle);
    else
      {
        fail ("VISUALSTYLE.edge_crease_angle [BD] set+1 %g != %g", visualstyle->edge_crease_angle, edge_crease_angle); error++;
      }
    visualstyle->edge_crease_angle--;

  }
  {
    BITCODE_BS edge_halo_gap;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_halo_gap", &edge_halo_gap, NULL) &&
        edge_halo_gap == visualstyle->edge_halo_gap)
      pass ("VISUALSTYLE.edge_halo_gap [BS] %hu", edge_halo_gap);
    else
      {
        fail ("VISUALSTYLE.edge_halo_gap [BS] %hu != %hu", visualstyle->edge_halo_gap, edge_halo_gap); error++;
      }
    edge_halo_gap++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_halo_gap", &edge_halo_gap) &&
        edge_halo_gap == visualstyle->edge_halo_gap)
      pass ("VISUALSTYLE.edge_halo_gap [BS] set+1 %hu", edge_halo_gap);
    else
      {
        fail ("VISUALSTYLE.edge_halo_gap [BS] set+1 %hu != %hu", visualstyle->edge_halo_gap, edge_halo_gap); error++;
      }
    visualstyle->edge_halo_gap--;

  }
  {
    BITCODE_BS edge_hide_precision_flag;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_hide_precision_flag", &edge_hide_precision_flag, NULL) &&
        edge_hide_precision_flag == visualstyle->edge_hide_precision_flag)
      pass ("VISUALSTYLE.edge_hide_precision_flag [BS] %hu", edge_hide_precision_flag);
    else
      {
        fail ("VISUALSTYLE.edge_hide_precision_flag [BS] %hu != %hu", visualstyle->edge_hide_precision_flag, edge_hide_precision_flag); error++;
      }
    edge_hide_precision_flag++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_hide_precision_flag", &edge_hide_precision_flag) &&
        edge_hide_precision_flag == visualstyle->edge_hide_precision_flag)
      pass ("VISUALSTYLE.edge_hide_precision_flag [BS] set+1 %hu", edge_hide_precision_flag);
    else
      {
        fail ("VISUALSTYLE.edge_hide_precision_flag [BS] set+1 %hu != %hu", visualstyle->edge_hide_precision_flag, edge_hide_precision_flag); error++;
      }
    visualstyle->edge_hide_precision_flag--;

  }
  {
    BITCODE_CMC edge_intersection_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_intersection_color", &edge_intersection_color, NULL)
        && !memcmp(&edge_intersection_color, &visualstyle->edge_intersection_color, sizeof(visualstyle->edge_intersection_color)))
      pass ("VISUALSTYLE.edge_intersection_color [CMC]");
    else
      {
        fail ("VISUALSTYLE.edge_intersection_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS edge_intersection_line_pattern;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_intersection_line_pattern", &edge_intersection_line_pattern, NULL) &&
        edge_intersection_line_pattern == visualstyle->edge_intersection_line_pattern)
      pass ("VISUALSTYLE.edge_intersection_line_pattern [BS] %hu", edge_intersection_line_pattern);
    else
      {
        fail ("VISUALSTYLE.edge_intersection_line_pattern [BS] %hu != %hu", visualstyle->edge_intersection_line_pattern, edge_intersection_line_pattern); error++;
      }
    edge_intersection_line_pattern++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_intersection_line_pattern", &edge_intersection_line_pattern) &&
        edge_intersection_line_pattern == visualstyle->edge_intersection_line_pattern)
      pass ("VISUALSTYLE.edge_intersection_line_pattern [BS] set+1 %hu", edge_intersection_line_pattern);
    else
      {
        fail ("VISUALSTYLE.edge_intersection_line_pattern [BS] set+1 %hu != %hu", visualstyle->edge_intersection_line_pattern, edge_intersection_line_pattern); error++;
      }
    visualstyle->edge_intersection_line_pattern--;

  }
  {
    BITCODE_BS edge_jitter;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_jitter", &edge_jitter, NULL) &&
        edge_jitter == visualstyle->edge_jitter)
      pass ("VISUALSTYLE.edge_jitter [BS] %hu", edge_jitter);
    else
      {
        fail ("VISUALSTYLE.edge_jitter [BS] %hu != %hu", visualstyle->edge_jitter, edge_jitter); error++;
      }
    edge_jitter++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_jitter", &edge_jitter) &&
        edge_jitter == visualstyle->edge_jitter)
      pass ("VISUALSTYLE.edge_jitter [BS] set+1 %hu", edge_jitter);
    else
      {
        fail ("VISUALSTYLE.edge_jitter [BS] set+1 %hu != %hu", visualstyle->edge_jitter, edge_jitter); error++;
      }
    visualstyle->edge_jitter--;

  }
  {
    BITCODE_BS edge_model;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_model", &edge_model, NULL) &&
        edge_model == visualstyle->edge_model)
      pass ("VISUALSTYLE.edge_model [BS] %hu", edge_model);
    else
      {
        fail ("VISUALSTYLE.edge_model [BS] %hu != %hu", visualstyle->edge_model, edge_model); error++;
      }
    edge_model++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_model", &edge_model) &&
        edge_model == visualstyle->edge_model)
      pass ("VISUALSTYLE.edge_model [BS] set+1 %hu", edge_model);
    else
      {
        fail ("VISUALSTYLE.edge_model [BS] set+1 %hu != %hu", visualstyle->edge_model, edge_model); error++;
      }
    visualstyle->edge_model--;

  }
  {
    BITCODE_BS edge_modifier;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_modifier", &edge_modifier, NULL) &&
        edge_modifier == visualstyle->edge_modifier)
      pass ("VISUALSTYLE.edge_modifier [BS] %hu", edge_modifier);
    else
      {
        fail ("VISUALSTYLE.edge_modifier [BS] %hu != %hu", visualstyle->edge_modifier, edge_modifier); error++;
      }
    edge_modifier++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_modifier", &edge_modifier) &&
        edge_modifier == visualstyle->edge_modifier)
      pass ("VISUALSTYLE.edge_modifier [BS] set+1 %hu", edge_modifier);
    else
      {
        fail ("VISUALSTYLE.edge_modifier [BS] set+1 %hu != %hu", visualstyle->edge_modifier, edge_modifier); error++;
      }
    visualstyle->edge_modifier--;

  }
  {
    BITCODE_CMC edge_obscured_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_obscured_color", &edge_obscured_color, NULL)
        && !memcmp(&edge_obscured_color, &visualstyle->edge_obscured_color, sizeof(visualstyle->edge_obscured_color)))
      pass ("VISUALSTYLE.edge_obscured_color [CMC]");
    else
      {
        fail ("VISUALSTYLE.edge_obscured_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS edge_obscured_line_pattern;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_obscured_line_pattern", &edge_obscured_line_pattern, NULL) &&
        edge_obscured_line_pattern == visualstyle->edge_obscured_line_pattern)
      pass ("VISUALSTYLE.edge_obscured_line_pattern [BS] %hu", edge_obscured_line_pattern);
    else
      {
        fail ("VISUALSTYLE.edge_obscured_line_pattern [BS] %hu != %hu", visualstyle->edge_obscured_line_pattern, edge_obscured_line_pattern); error++;
      }
    edge_obscured_line_pattern++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_obscured_line_pattern", &edge_obscured_line_pattern) &&
        edge_obscured_line_pattern == visualstyle->edge_obscured_line_pattern)
      pass ("VISUALSTYLE.edge_obscured_line_pattern [BS] set+1 %hu", edge_obscured_line_pattern);
    else
      {
        fail ("VISUALSTYLE.edge_obscured_line_pattern [BS] set+1 %hu != %hu", visualstyle->edge_obscured_line_pattern, edge_obscured_line_pattern); error++;
      }
    visualstyle->edge_obscured_line_pattern--;

  }
  {
    BITCODE_BD edge_opacity;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_opacity", &edge_opacity, NULL) &&
        edge_opacity == visualstyle->edge_opacity)
      pass ("VISUALSTYLE.edge_opacity [BD] %g", edge_opacity);
    else
      {
        fail ("VISUALSTYLE.edge_opacity [BD] %g != %g", visualstyle->edge_opacity, edge_opacity); error++;
      }
    edge_opacity++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_opacity", &edge_opacity) &&
        edge_opacity == visualstyle->edge_opacity)
      pass ("VISUALSTYLE.edge_opacity [BD] set+1 %g", edge_opacity);
    else
      {
        fail ("VISUALSTYLE.edge_opacity [BD] set+1 %g != %g", visualstyle->edge_opacity, edge_opacity); error++;
      }
    visualstyle->edge_opacity--;

  }
  {
    BITCODE_BS edge_overhang;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_overhang", &edge_overhang, NULL) &&
        edge_overhang == visualstyle->edge_overhang)
      pass ("VISUALSTYLE.edge_overhang [BS] %hu", edge_overhang);
    else
      {
        fail ("VISUALSTYLE.edge_overhang [BS] %hu != %hu", visualstyle->edge_overhang, edge_overhang); error++;
      }
    edge_overhang++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_overhang", &edge_overhang) &&
        edge_overhang == visualstyle->edge_overhang)
      pass ("VISUALSTYLE.edge_overhang [BS] set+1 %hu", edge_overhang);
    else
      {
        fail ("VISUALSTYLE.edge_overhang [BS] set+1 %hu != %hu", visualstyle->edge_overhang, edge_overhang); error++;
      }
    visualstyle->edge_overhang--;

  }
  {
    BITCODE_CMC edge_silhouette_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_silhouette_color", &edge_silhouette_color, NULL)
        && !memcmp(&edge_silhouette_color, &visualstyle->edge_silhouette_color, sizeof(visualstyle->edge_silhouette_color)))
      pass ("VISUALSTYLE.edge_silhouette_color [CMC]");
    else
      {
        fail ("VISUALSTYLE.edge_silhouette_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BS edge_silhouette_width;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_silhouette_width", &edge_silhouette_width, NULL) &&
        edge_silhouette_width == visualstyle->edge_silhouette_width)
      pass ("VISUALSTYLE.edge_silhouette_width [BS] %hu", edge_silhouette_width);
    else
      {
        fail ("VISUALSTYLE.edge_silhouette_width [BS] %hu != %hu", visualstyle->edge_silhouette_width, edge_silhouette_width); error++;
      }
    edge_silhouette_width++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_silhouette_width", &edge_silhouette_width) &&
        edge_silhouette_width == visualstyle->edge_silhouette_width)
      pass ("VISUALSTYLE.edge_silhouette_width [BS] set+1 %hu", edge_silhouette_width);
    else
      {
        fail ("VISUALSTYLE.edge_silhouette_width [BS] set+1 %hu != %hu", visualstyle->edge_silhouette_width, edge_silhouette_width); error++;
      }
    visualstyle->edge_silhouette_width--;

  }
  {
    BITCODE_BL edge_style;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_style", &edge_style, NULL) &&
        edge_style == visualstyle->edge_style)
      pass ("VISUALSTYLE.edge_style [BL] %u", edge_style);
    else
      {
        fail ("VISUALSTYLE.edge_style [BL] %u != %u", visualstyle->edge_style, edge_style); error++;
      }
    edge_style++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_style", &edge_style) &&
        edge_style == visualstyle->edge_style)
      pass ("VISUALSTYLE.edge_style [BL] set+1 %u", edge_style);
    else
      {
        fail ("VISUALSTYLE.edge_style [BL] set+1 %u != %u", visualstyle->edge_style, edge_style); error++;
      }
    visualstyle->edge_style--;

  }
  {
    BITCODE_BS edge_style_apply_flag;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_style_apply_flag", &edge_style_apply_flag, NULL) &&
        edge_style_apply_flag == visualstyle->edge_style_apply_flag)
      pass ("VISUALSTYLE.edge_style_apply_flag [BS] %hu", edge_style_apply_flag);
    else
      {
        fail ("VISUALSTYLE.edge_style_apply_flag [BS] %hu != %hu", visualstyle->edge_style_apply_flag, edge_style_apply_flag); error++;
      }
    edge_style_apply_flag++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_style_apply_flag", &edge_style_apply_flag) &&
        edge_style_apply_flag == visualstyle->edge_style_apply_flag)
      pass ("VISUALSTYLE.edge_style_apply_flag [BS] set+1 %hu", edge_style_apply_flag);
    else
      {
        fail ("VISUALSTYLE.edge_style_apply_flag [BS] set+1 %hu != %hu", visualstyle->edge_style_apply_flag, edge_style_apply_flag); error++;
      }
    visualstyle->edge_style_apply_flag--;

  }
  {
    BITCODE_BS edge_width;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_width", &edge_width, NULL) &&
        edge_width == visualstyle->edge_width)
      pass ("VISUALSTYLE.edge_width [BS] %hu", edge_width);
    else
      {
        fail ("VISUALSTYLE.edge_width [BS] %hu != %hu", visualstyle->edge_width, edge_width); error++;
      }
    edge_width++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "edge_width", &edge_width) &&
        edge_width == visualstyle->edge_width)
      pass ("VISUALSTYLE.edge_width [BS] set+1 %hu", edge_width);
    else
      {
        fail ("VISUALSTYLE.edge_width [BS] set+1 %hu != %hu", visualstyle->edge_width, edge_width); error++;
      }
    visualstyle->edge_width--;

  }
  {
    BITCODE_BS face_color_mode;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_color_mode", &face_color_mode, NULL) &&
        face_color_mode == visualstyle->face_color_mode)
      pass ("VISUALSTYLE.face_color_mode [BS] %hu", face_color_mode);
    else
      {
        fail ("VISUALSTYLE.face_color_mode [BS] %hu != %hu", visualstyle->face_color_mode, face_color_mode); error++;
      }
    face_color_mode++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "face_color_mode", &face_color_mode) &&
        face_color_mode == visualstyle->face_color_mode)
      pass ("VISUALSTYLE.face_color_mode [BS] set+1 %hu", face_color_mode);
    else
      {
        fail ("VISUALSTYLE.face_color_mode [BS] set+1 %hu != %hu", visualstyle->face_color_mode, face_color_mode); error++;
      }
    visualstyle->face_color_mode--;

  }
  {
    BITCODE_BS face_lighting_model;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_lighting_model", &face_lighting_model, NULL) &&
        face_lighting_model == visualstyle->face_lighting_model)
      pass ("VISUALSTYLE.face_lighting_model [BS] %hu", face_lighting_model);
    else
      {
        fail ("VISUALSTYLE.face_lighting_model [BS] %hu != %hu", visualstyle->face_lighting_model, face_lighting_model); error++;
      }
    face_lighting_model++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "face_lighting_model", &face_lighting_model) &&
        face_lighting_model == visualstyle->face_lighting_model)
      pass ("VISUALSTYLE.face_lighting_model [BS] set+1 %hu", face_lighting_model);
    else
      {
        fail ("VISUALSTYLE.face_lighting_model [BS] set+1 %hu != %hu", visualstyle->face_lighting_model, face_lighting_model); error++;
      }
    visualstyle->face_lighting_model--;

  }
  {
    BITCODE_BS face_lighting_quality;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_lighting_quality", &face_lighting_quality, NULL) &&
        face_lighting_quality == visualstyle->face_lighting_quality)
      pass ("VISUALSTYLE.face_lighting_quality [BS] %hu", face_lighting_quality);
    else
      {
        fail ("VISUALSTYLE.face_lighting_quality [BS] %hu != %hu", visualstyle->face_lighting_quality, face_lighting_quality); error++;
      }
    face_lighting_quality++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "face_lighting_quality", &face_lighting_quality) &&
        face_lighting_quality == visualstyle->face_lighting_quality)
      pass ("VISUALSTYLE.face_lighting_quality [BS] set+1 %hu", face_lighting_quality);
    else
      {
        fail ("VISUALSTYLE.face_lighting_quality [BS] set+1 %hu != %hu", visualstyle->face_lighting_quality, face_lighting_quality); error++;
      }
    visualstyle->face_lighting_quality--;

  }
  {
    BITCODE_BS face_modifier;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_modifier", &face_modifier, NULL) &&
        face_modifier == visualstyle->face_modifier)
      pass ("VISUALSTYLE.face_modifier [BS] %hu", face_modifier);
    else
      {
        fail ("VISUALSTYLE.face_modifier [BS] %hu != %hu", visualstyle->face_modifier, face_modifier); error++;
      }
    face_modifier++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "face_modifier", &face_modifier) &&
        face_modifier == visualstyle->face_modifier)
      pass ("VISUALSTYLE.face_modifier [BS] set+1 %hu", face_modifier);
    else
      {
        fail ("VISUALSTYLE.face_modifier [BS] set+1 %hu != %hu", visualstyle->face_modifier, face_modifier); error++;
      }
    visualstyle->face_modifier--;

  }
  {
    BITCODE_CMC face_mono_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_mono_color", &face_mono_color, NULL)
        && !memcmp(&face_mono_color, &visualstyle->face_mono_color, sizeof(visualstyle->face_mono_color)))
      pass ("VISUALSTYLE.face_mono_color [CMC]");
    else
      {
        fail ("VISUALSTYLE.face_mono_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD face_opacity;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_opacity", &face_opacity, NULL) &&
        face_opacity == visualstyle->face_opacity)
      pass ("VISUALSTYLE.face_opacity [BD] %g", face_opacity);
    else
      {
        fail ("VISUALSTYLE.face_opacity [BD] %g != %g", visualstyle->face_opacity, face_opacity); error++;
      }
    face_opacity++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "face_opacity", &face_opacity) &&
        face_opacity == visualstyle->face_opacity)
      pass ("VISUALSTYLE.face_opacity [BD] set+1 %g", face_opacity);
    else
      {
        fail ("VISUALSTYLE.face_opacity [BD] set+1 %g != %g", visualstyle->face_opacity, face_opacity); error++;
      }
    visualstyle->face_opacity--;

  }
  {
    BITCODE_BD face_specular;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_specular", &face_specular, NULL) &&
        face_specular == visualstyle->face_specular)
      pass ("VISUALSTYLE.face_specular [BD] %g", face_specular);
    else
      {
        fail ("VISUALSTYLE.face_specular [BD] %g != %g", visualstyle->face_specular, face_specular); error++;
      }
    face_specular++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "face_specular", &face_specular) &&
        face_specular == visualstyle->face_specular)
      pass ("VISUALSTYLE.face_specular [BD] set+1 %g", face_specular);
    else
      {
        fail ("VISUALSTYLE.face_specular [BD] set+1 %g != %g", visualstyle->face_specular, face_specular); error++;
      }
    visualstyle->face_specular--;

  }
  {
    BITCODE_BS is_internal_use_only;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "is_internal_use_only", &is_internal_use_only, NULL) &&
        is_internal_use_only == visualstyle->is_internal_use_only)
      pass ("VISUALSTYLE.is_internal_use_only [BS] %hu", is_internal_use_only);
    else
      {
        fail ("VISUALSTYLE.is_internal_use_only [BS] %hu != %hu", visualstyle->is_internal_use_only, is_internal_use_only); error++;
      }
    is_internal_use_only++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "is_internal_use_only", &is_internal_use_only) &&
        is_internal_use_only == visualstyle->is_internal_use_only)
      pass ("VISUALSTYLE.is_internal_use_only [BS] set+1 %hu", is_internal_use_only);
    else
      {
        fail ("VISUALSTYLE.is_internal_use_only [BS] set+1 %hu != %hu", visualstyle->is_internal_use_only, is_internal_use_only); error++;
      }
    visualstyle->is_internal_use_only--;

  }
  {
    BITCODE_BS num_edge_isolines;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "num_edge_isolines", &num_edge_isolines, NULL) &&
        num_edge_isolines == visualstyle->num_edge_isolines)
      pass ("VISUALSTYLE.num_edge_isolines [BS] %hu", num_edge_isolines);
    else
      {
        fail ("VISUALSTYLE.num_edge_isolines [BS] %hu != %hu", visualstyle->num_edge_isolines, num_edge_isolines); error++;
      }
    num_edge_isolines++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "num_edge_isolines", &num_edge_isolines) &&
        num_edge_isolines == visualstyle->num_edge_isolines)
      pass ("VISUALSTYLE.num_edge_isolines [BS] set+1 %hu", num_edge_isolines);
    else
      {
        fail ("VISUALSTYLE.num_edge_isolines [BS] set+1 %hu != %hu", visualstyle->num_edge_isolines, num_edge_isolines); error++;
      }
    visualstyle->num_edge_isolines--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &visualstyle->ownerhandle, sizeof(visualstyle->ownerhandle)))
      pass ("VISUALSTYLE.ownerhandle [H]");
    else
      {
        fail ("VISUALSTYLE.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &visualstyle->parent, sizeof(visualstyle->parent)))
      pass ("VISUALSTYLE.parent [struct _dwg_object_object*]");
    else
      {
        fail ("VISUALSTYLE.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "type", &type, NULL) &&
        type == visualstyle->type)
      pass ("VISUALSTYLE.type [BS] %hu", type);
    else
      {
        fail ("VISUALSTYLE.type [BS] %hu != %hu", visualstyle->type, type); error++;
      }
    type++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "type", &type) &&
        type == visualstyle->type)
      pass ("VISUALSTYLE.type [BS] set+1 %hu", type);
    else
      {
        fail ("VISUALSTYLE.type [BS] set+1 %hu != %hu", visualstyle->type, type); error++;
      }
    visualstyle->type--;

  }
  {
    BITCODE_BS unknown_float45;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "unknown_float45", &unknown_float45, NULL) &&
        unknown_float45 == visualstyle->unknown_float45)
      pass ("VISUALSTYLE.unknown_float45 [BS] %hu", unknown_float45);
    else
      {
        fail ("VISUALSTYLE.unknown_float45 [BS] %hu != %hu", visualstyle->unknown_float45, unknown_float45); error++;
      }
    unknown_float45++;
    if (dwg_dynapi_entity_set_value(visualstyle, "VISUALSTYLE", "unknown_float45", &unknown_float45) &&
        unknown_float45 == visualstyle->unknown_float45)
      pass ("VISUALSTYLE.unknown_float45 [BS] set+1 %hu", unknown_float45);
    else
      {
        fail ("VISUALSTYLE.unknown_float45 [BS] set+1 %hu != %hu", visualstyle->unknown_float45, unknown_float45); error++;
      }
    visualstyle->unknown_float45--;

  }
  return error;
}
static int test_VPORT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VPORT *vport = obj->tio.object->tio.VPORT;
  {
    BITCODE_B FASTZOOM;
    if (dwg_dynapi_entity_value(vport, "VPORT", "FASTZOOM", &FASTZOOM, NULL) &&
        FASTZOOM == vport->FASTZOOM)
      pass ("VPORT.FASTZOOM [B] " FORMAT_B "", FASTZOOM);
    else
      {
        fail ("VPORT.FASTZOOM [B] " FORMAT_B " != " FORMAT_B "", vport->FASTZOOM, FASTZOOM); error++;
      }
    FASTZOOM++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "FASTZOOM", &FASTZOOM) &&
        FASTZOOM == vport->FASTZOOM)
      pass ("VPORT.FASTZOOM [B] set+1 " FORMAT_B "", FASTZOOM);
    else
      {
        fail ("VPORT.FASTZOOM [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->FASTZOOM, FASTZOOM); error++;
      }
    vport->FASTZOOM--;

  }
  {
    BITCODE_B GRIDMODE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "GRIDMODE", &GRIDMODE, NULL) &&
        GRIDMODE == vport->GRIDMODE)
      pass ("VPORT.GRIDMODE [B] " FORMAT_B "", GRIDMODE);
    else
      {
        fail ("VPORT.GRIDMODE [B] " FORMAT_B " != " FORMAT_B "", vport->GRIDMODE, GRIDMODE); error++;
      }
    GRIDMODE++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "GRIDMODE", &GRIDMODE) &&
        GRIDMODE == vport->GRIDMODE)
      pass ("VPORT.GRIDMODE [B] set+1 " FORMAT_B "", GRIDMODE);
    else
      {
        fail ("VPORT.GRIDMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->GRIDMODE, GRIDMODE); error++;
      }
    vport->GRIDMODE--;

  }
  {
    BITCODE_2RD GRIDUNIT;
    if (dwg_dynapi_entity_value(vport, "VPORT", "GRIDUNIT", &GRIDUNIT, NULL)
        && !memcmp(&GRIDUNIT, &vport->GRIDUNIT, sizeof(vport->GRIDUNIT)))
      pass ("VPORT.GRIDUNIT [2RD]");
    else
      {
        fail ("VPORT.GRIDUNIT [2RD]"); error++;
      }
  }
  {
    BITCODE_BD SNAPANG;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPANG", &SNAPANG, NULL) &&
        SNAPANG == vport->SNAPANG)
      pass ("VPORT.SNAPANG [BD] %g", SNAPANG);
    else
      {
        fail ("VPORT.SNAPANG [BD] %g != %g", vport->SNAPANG, SNAPANG); error++;
      }
    SNAPANG++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "SNAPANG", &SNAPANG) &&
        SNAPANG == vport->SNAPANG)
      pass ("VPORT.SNAPANG [BD] set+1 %g", SNAPANG);
    else
      {
        fail ("VPORT.SNAPANG [BD] set+1 %g != %g", vport->SNAPANG, SNAPANG); error++;
      }
    vport->SNAPANG--;

  }
  {
    BITCODE_2RD SNAPBASE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPBASE", &SNAPBASE, NULL)
        && !memcmp(&SNAPBASE, &vport->SNAPBASE, sizeof(vport->SNAPBASE)))
      pass ("VPORT.SNAPBASE [2RD]");
    else
      {
        fail ("VPORT.SNAPBASE [2RD]"); error++;
      }
  }
  {
    BITCODE_BS SNAPISOPAIR;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPISOPAIR", &SNAPISOPAIR, NULL) &&
        SNAPISOPAIR == vport->SNAPISOPAIR)
      pass ("VPORT.SNAPISOPAIR [BS] %hu", SNAPISOPAIR);
    else
      {
        fail ("VPORT.SNAPISOPAIR [BS] %hu != %hu", vport->SNAPISOPAIR, SNAPISOPAIR); error++;
      }
    SNAPISOPAIR++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "SNAPISOPAIR", &SNAPISOPAIR) &&
        SNAPISOPAIR == vport->SNAPISOPAIR)
      pass ("VPORT.SNAPISOPAIR [BS] set+1 %hu", SNAPISOPAIR);
    else
      {
        fail ("VPORT.SNAPISOPAIR [BS] set+1 %hu != %hu", vport->SNAPISOPAIR, SNAPISOPAIR); error++;
      }
    vport->SNAPISOPAIR--;

  }
  {
    BITCODE_B SNAPMODE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPMODE", &SNAPMODE, NULL) &&
        SNAPMODE == vport->SNAPMODE)
      pass ("VPORT.SNAPMODE [B] " FORMAT_B "", SNAPMODE);
    else
      {
        fail ("VPORT.SNAPMODE [B] " FORMAT_B " != " FORMAT_B "", vport->SNAPMODE, SNAPMODE); error++;
      }
    SNAPMODE++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "SNAPMODE", &SNAPMODE) &&
        SNAPMODE == vport->SNAPMODE)
      pass ("VPORT.SNAPMODE [B] set+1 " FORMAT_B "", SNAPMODE);
    else
      {
        fail ("VPORT.SNAPMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->SNAPMODE, SNAPMODE); error++;
      }
    vport->SNAPMODE--;

  }
  {
    BITCODE_B SNAPSTYLE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPSTYLE", &SNAPSTYLE, NULL) &&
        SNAPSTYLE == vport->SNAPSTYLE)
      pass ("VPORT.SNAPSTYLE [B] " FORMAT_B "", SNAPSTYLE);
    else
      {
        fail ("VPORT.SNAPSTYLE [B] " FORMAT_B " != " FORMAT_B "", vport->SNAPSTYLE, SNAPSTYLE); error++;
      }
    SNAPSTYLE++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "SNAPSTYLE", &SNAPSTYLE) &&
        SNAPSTYLE == vport->SNAPSTYLE)
      pass ("VPORT.SNAPSTYLE [B] set+1 " FORMAT_B "", SNAPSTYLE);
    else
      {
        fail ("VPORT.SNAPSTYLE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->SNAPSTYLE, SNAPSTYLE); error++;
      }
    vport->SNAPSTYLE--;

  }
  {
    BITCODE_2RD SNAPUNIT;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPUNIT", &SNAPUNIT, NULL)
        && !memcmp(&SNAPUNIT, &vport->SNAPUNIT, sizeof(vport->SNAPUNIT)))
      pass ("VPORT.SNAPUNIT [2RD]");
    else
      {
        fail ("VPORT.SNAPUNIT [2RD]"); error++;
      }
  }
  {
    BITCODE_B UCSFOLLOW;
    if (dwg_dynapi_entity_value(vport, "VPORT", "UCSFOLLOW", &UCSFOLLOW, NULL) &&
        UCSFOLLOW == vport->UCSFOLLOW)
      pass ("VPORT.UCSFOLLOW [B] " FORMAT_B "", UCSFOLLOW);
    else
      {
        fail ("VPORT.UCSFOLLOW [B] " FORMAT_B " != " FORMAT_B "", vport->UCSFOLLOW, UCSFOLLOW); error++;
      }
    UCSFOLLOW++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "UCSFOLLOW", &UCSFOLLOW) &&
        UCSFOLLOW == vport->UCSFOLLOW)
      pass ("VPORT.UCSFOLLOW [B] set+1 " FORMAT_B "", UCSFOLLOW);
    else
      {
        fail ("VPORT.UCSFOLLOW [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->UCSFOLLOW, UCSFOLLOW); error++;
      }
    vport->UCSFOLLOW--;

  }
  {
    BITCODE_RC UCSICON;
    if (dwg_dynapi_entity_value(vport, "VPORT", "UCSICON", &UCSICON, NULL) &&
        UCSICON == vport->UCSICON)
      pass ("VPORT.UCSICON [RC] %u", UCSICON);
    else
      {
        fail ("VPORT.UCSICON [RC] %u != %u", vport->UCSICON, UCSICON); error++;
      }
    UCSICON++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "UCSICON", &UCSICON) &&
        UCSICON == vport->UCSICON)
      pass ("VPORT.UCSICON [RC] set+1 %u", UCSICON);
    else
      {
        fail ("VPORT.UCSICON [RC] set+1 %u != %u", vport->UCSICON, UCSICON); error++;
      }
    vport->UCSICON--;

  }
  {
    BITCODE_2RD VIEWCTR;
    if (dwg_dynapi_entity_value(vport, "VPORT", "VIEWCTR", &VIEWCTR, NULL)
        && !memcmp(&VIEWCTR, &vport->VIEWCTR, sizeof(vport->VIEWCTR)))
      pass ("VPORT.VIEWCTR [2RD]");
    else
      {
        fail ("VPORT.VIEWCTR [2RD]"); error++;
      }
  }
  {
    BITCODE_3BD VIEWDIR;
    if (dwg_dynapi_entity_value(vport, "VPORT", "VIEWDIR", &VIEWDIR, NULL)
        && !memcmp(&VIEWDIR, &vport->VIEWDIR, sizeof(vport->VIEWDIR)))
      pass ("VPORT.VIEWDIR [3BD]");
    else
      {
        fail ("VPORT.VIEWDIR [3BD]"); error++;
      }
  }
  {
    BITCODE_4BITS VIEWMODE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "VIEWMODE", &VIEWMODE, NULL) &&
        VIEWMODE == vport->VIEWMODE)
      pass ("VPORT.VIEWMODE [4BITS] " FORMAT_4BITS "", VIEWMODE);
    else
      {
        fail ("VPORT.VIEWMODE [4BITS] " FORMAT_4BITS " != " FORMAT_4BITS "", vport->VIEWMODE, VIEWMODE); error++;
      }
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "VIEWMODE", &VIEWMODE) &&
        VIEWMODE == vport->VIEWMODE)
      pass ("VPORT.VIEWMODE [4BITS] set+1 " FORMAT_4BITS "", VIEWMODE);
    else
      {
        fail ("VPORT.VIEWMODE [4BITS] set+1 " FORMAT_4BITS " != " FORMAT_4BITS "", vport->VIEWMODE, VIEWMODE); error++;
      }
    vport->VIEWMODE--;

  }
  {
    BITCODE_BD VIEWSIZE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "VIEWSIZE", &VIEWSIZE, NULL) &&
        VIEWSIZE == vport->VIEWSIZE)
      pass ("VPORT.VIEWSIZE [BD] %g", VIEWSIZE);
    else
      {
        fail ("VPORT.VIEWSIZE [BD] %g != %g", vport->VIEWSIZE, VIEWSIZE); error++;
      }
    VIEWSIZE++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "VIEWSIZE", &VIEWSIZE) &&
        VIEWSIZE == vport->VIEWSIZE)
      pass ("VPORT.VIEWSIZE [BD] set+1 %g", VIEWSIZE);
    else
      {
        fail ("VPORT.VIEWSIZE [BD] set+1 %g != %g", vport->VIEWSIZE, VIEWSIZE); error++;
      }
    vport->VIEWSIZE--;

  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ambient_color", &ambient_color, NULL)
        && !memcmp(&ambient_color, &vport->ambient_color, sizeof(vport->ambient_color)))
      pass ("VPORT.ambient_color [CMC]");
    else
      {
        fail ("VPORT.ambient_color [CMC]"); error++;
      }
  }
  {
    BITCODE_BD aspect_ratio;
    if (dwg_dynapi_entity_value(vport, "VPORT", "aspect_ratio", &aspect_ratio, NULL) &&
        aspect_ratio == vport->aspect_ratio)
      pass ("VPORT.aspect_ratio [BD] %g", aspect_ratio);
    else
      {
        fail ("VPORT.aspect_ratio [BD] %g != %g", vport->aspect_ratio, aspect_ratio); error++;
      }
    aspect_ratio++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "aspect_ratio", &aspect_ratio) &&
        aspect_ratio == vport->aspect_ratio)
      pass ("VPORT.aspect_ratio [BD] set+1 %g", aspect_ratio);
    else
      {
        fail ("VPORT.aspect_ratio [BD] set+1 %g != %g", vport->aspect_ratio, aspect_ratio); error++;
      }
    vport->aspect_ratio--;

  }
  {
    BITCODE_BD back_clip;
    if (dwg_dynapi_entity_value(vport, "VPORT", "back_clip", &back_clip, NULL) &&
        back_clip == vport->back_clip)
      pass ("VPORT.back_clip [BD] %g", back_clip);
    else
      {
        fail ("VPORT.back_clip [BD] %g != %g", vport->back_clip, back_clip); error++;
      }
    back_clip++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "back_clip", &back_clip) &&
        back_clip == vport->back_clip)
      pass ("VPORT.back_clip [BD] set+1 %g", back_clip);
    else
      {
        fail ("VPORT.back_clip [BD] set+1 %g != %g", vport->back_clip, back_clip); error++;
      }
    vport->back_clip--;

  }
  {
    BITCODE_H background_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "background_handle", &background_handle, NULL)
        && !memcmp(&background_handle, &vport->background_handle, sizeof(vport->background_handle)))
      pass ("VPORT.background_handle [H]");
    else
      {
        fail ("VPORT.background_handle [H]"); error++;
      }
  }
  {
    BITCODE_H base_ucs_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "base_ucs_handle", &base_ucs_handle, NULL)
        && !memcmp(&base_ucs_handle, &vport->base_ucs_handle, sizeof(vport->base_ucs_handle)))
      pass ("VPORT.base_ucs_handle [H]");
    else
      {
        fail ("VPORT.base_ucs_handle [H]"); error++;
      }
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value(vport, "VPORT", "brightness", &brightness, NULL) &&
        brightness == vport->brightness)
      pass ("VPORT.brightness [BD] %g", brightness);
    else
      {
        fail ("VPORT.brightness [BD] %g != %g", vport->brightness, brightness); error++;
      }
    brightness++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "brightness", &brightness) &&
        brightness == vport->brightness)
      pass ("VPORT.brightness [BD] set+1 %g", brightness);
    else
      {
        fail ("VPORT.brightness [BD] set+1 %g != %g", vport->brightness, brightness); error++;
      }
    vport->brightness--;

  }
  {
    BITCODE_BS circle_zoom;
    if (dwg_dynapi_entity_value(vport, "VPORT", "circle_zoom", &circle_zoom, NULL) &&
        circle_zoom == vport->circle_zoom)
      pass ("VPORT.circle_zoom [BS] %hu", circle_zoom);
    else
      {
        fail ("VPORT.circle_zoom [BS] %hu != %hu", vport->circle_zoom, circle_zoom); error++;
      }
    circle_zoom++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "circle_zoom", &circle_zoom) &&
        circle_zoom == vport->circle_zoom)
      pass ("VPORT.circle_zoom [BS] set+1 %hu", circle_zoom);
    else
      {
        fail ("VPORT.circle_zoom [BS] set+1 %hu != %hu", vport->circle_zoom, circle_zoom); error++;
      }
    vport->circle_zoom--;

  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value(vport, "VPORT", "contrast", &contrast, NULL) &&
        contrast == vport->contrast)
      pass ("VPORT.contrast [BD] %g", contrast);
    else
      {
        fail ("VPORT.contrast [BD] %g != %g", vport->contrast, contrast); error++;
      }
    contrast++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "contrast", &contrast) &&
        contrast == vport->contrast)
      pass ("VPORT.contrast [BD] set+1 %g", contrast);
    else
      {
        fail ("VPORT.contrast [BD] set+1 %g != %g", vport->contrast, contrast); error++;
      }
    vport->contrast--;

  }
  {
    BITCODE_RC default_lightning_type;
    if (dwg_dynapi_entity_value(vport, "VPORT", "default_lightning_type", &default_lightning_type, NULL) &&
        default_lightning_type == vport->default_lightning_type)
      pass ("VPORT.default_lightning_type [RC] %u", default_lightning_type);
    else
      {
        fail ("VPORT.default_lightning_type [RC] %u != %u", vport->default_lightning_type, default_lightning_type); error++;
      }
    default_lightning_type++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "default_lightning_type", &default_lightning_type) &&
        default_lightning_type == vport->default_lightning_type)
      pass ("VPORT.default_lightning_type [RC] set+1 %u", default_lightning_type);
    else
      {
        fail ("VPORT.default_lightning_type [RC] set+1 %u != %u", vport->default_lightning_type, default_lightning_type); error++;
      }
    vport->default_lightning_type--;

  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(vport, "VPORT", "flag", &flag, NULL) &&
        flag == vport->flag)
      pass ("VPORT.flag [RC] %u", flag);
    else
      {
        fail ("VPORT.flag [RC] %u != %u", vport->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "flag", &flag) &&
        flag == vport->flag)
      pass ("VPORT.flag [RC] set+1 %u", flag);
    else
      {
        fail ("VPORT.flag [RC] set+1 %u != %u", vport->flag, flag); error++;
      }
    vport->flag--;

  }
  {
    BITCODE_BD front_clip;
    if (dwg_dynapi_entity_value(vport, "VPORT", "front_clip", &front_clip, NULL) &&
        front_clip == vport->front_clip)
      pass ("VPORT.front_clip [BD] %g", front_clip);
    else
      {
        fail ("VPORT.front_clip [BD] %g != %g", vport->front_clip, front_clip); error++;
      }
    front_clip++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "front_clip", &front_clip) &&
        front_clip == vport->front_clip)
      pass ("VPORT.front_clip [BD] set+1 %g", front_clip);
    else
      {
        fail ("VPORT.front_clip [BD] set+1 %g != %g", vport->front_clip, front_clip); error++;
      }
    vport->front_clip--;

  }
  {
    BITCODE_BS grid_flags;
    if (dwg_dynapi_entity_value(vport, "VPORT", "grid_flags", &grid_flags, NULL) &&
        grid_flags == vport->grid_flags)
      pass ("VPORT.grid_flags [BS] %hu", grid_flags);
    else
      {
        fail ("VPORT.grid_flags [BS] %hu != %hu", vport->grid_flags, grid_flags); error++;
      }
    grid_flags++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "grid_flags", &grid_flags) &&
        grid_flags == vport->grid_flags)
      pass ("VPORT.grid_flags [BS] set+1 %hu", grid_flags);
    else
      {
        fail ("VPORT.grid_flags [BS] set+1 %hu != %hu", vport->grid_flags, grid_flags); error++;
      }
    vport->grid_flags--;

  }
  {
    BITCODE_BS grid_major;
    if (dwg_dynapi_entity_value(vport, "VPORT", "grid_major", &grid_major, NULL) &&
        grid_major == vport->grid_major)
      pass ("VPORT.grid_major [BS] %hu", grid_major);
    else
      {
        fail ("VPORT.grid_major [BS] %hu != %hu", vport->grid_major, grid_major); error++;
      }
    grid_major++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "grid_major", &grid_major) &&
        grid_major == vport->grid_major)
      pass ("VPORT.grid_major [BS] set+1 %hu", grid_major);
    else
      {
        fail ("VPORT.grid_major [BS] set+1 %hu != %hu", vport->grid_major, grid_major); error++;
      }
    vport->grid_major--;

  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value(vport, "VPORT", "lens_length", &lens_length, NULL) &&
        lens_length == vport->lens_length)
      pass ("VPORT.lens_length [BD] %g", lens_length);
    else
      {
        fail ("VPORT.lens_length [BD] %g != %g", vport->lens_length, lens_length); error++;
      }
    lens_length++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "lens_length", &lens_length) &&
        lens_length == vport->lens_length)
      pass ("VPORT.lens_length [BD] set+1 %g", lens_length);
    else
      {
        fail ("VPORT.lens_length [BD] set+1 %g != %g", vport->lens_length, lens_length); error++;
      }
    vport->lens_length--;

  }
  {
    BITCODE_2RD lower_left;
    if (dwg_dynapi_entity_value(vport, "VPORT", "lower_left", &lower_left, NULL)
        && !memcmp(&lower_left, &vport->lower_left, sizeof(vport->lower_left)))
      pass ("VPORT.lower_left [2RD]");
    else
      {
        fail ("VPORT.lower_left [2RD]"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(vport, "VPORT", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&vport->name))
      pass ("VPORT.name [TV]");
    else
      {
        fail ("VPORT.name [TV]"); error++;
      }
  }
  {
    BITCODE_H named_ucs_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "named_ucs_handle", &named_ucs_handle, NULL)
        && !memcmp(&named_ucs_handle, &vport->named_ucs_handle, sizeof(vport->named_ucs_handle)))
      pass ("VPORT.named_ucs_handle [H]");
    else
      {
        fail ("VPORT.named_ucs_handle [H]"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &vport->null_handle, sizeof(vport->null_handle)))
      pass ("VPORT.null_handle [H]");
    else
      {
        fail ("VPORT.null_handle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vport, "VPORT", "parent", &parent, NULL)
        && !memcmp(&parent, &vport->parent, sizeof(vport->parent)))
      pass ("VPORT.parent [struct _dwg_object_object*]");
    else
      {
        fail ("VPORT.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value(vport, "VPORT", "render_mode", &render_mode, NULL) &&
        render_mode == vport->render_mode)
      pass ("VPORT.render_mode [RC] %u", render_mode);
    else
      {
        fail ("VPORT.render_mode [RC] %u != %u", vport->render_mode, render_mode); error++;
      }
    render_mode++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "render_mode", &render_mode) &&
        render_mode == vport->render_mode)
      pass ("VPORT.render_mode [RC] set+1 %u", render_mode);
    else
      {
        fail ("VPORT.render_mode [RC] set+1 %u != %u", vport->render_mode, render_mode); error++;
      }
    vport->render_mode--;

  }
  {
    BITCODE_H sun_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "sun_handle", &sun_handle, NULL)
        && !memcmp(&sun_handle, &vport->sun_handle, sizeof(vport->sun_handle)))
      pass ("VPORT.sun_handle [H]");
    else
      {
        fail ("VPORT.sun_handle [H]"); error++;
      }
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_elevation", &ucs_elevation, NULL) &&
        ucs_elevation == vport->ucs_elevation)
      pass ("VPORT.ucs_elevation [BD] %g", ucs_elevation);
    else
      {
        fail ("VPORT.ucs_elevation [BD] %g != %g", vport->ucs_elevation, ucs_elevation); error++;
      }
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "ucs_elevation", &ucs_elevation) &&
        ucs_elevation == vport->ucs_elevation)
      pass ("VPORT.ucs_elevation [BD] set+1 %g", ucs_elevation);
    else
      {
        fail ("VPORT.ucs_elevation [BD] set+1 %g != %g", vport->ucs_elevation, ucs_elevation); error++;
      }
    vport->ucs_elevation--;

  }
  {
    BITCODE_3BD ucs_origin;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp(&ucs_origin, &vport->ucs_origin, sizeof(vport->ucs_origin)))
      pass ("VPORT.ucs_origin [3BD]");
    else
      {
        fail ("VPORT.ucs_origin [3BD]"); error++;
      }
  }
  {
    BITCODE_BS ucs_orthografic_type;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_orthografic_type", &ucs_orthografic_type, NULL) &&
        ucs_orthografic_type == vport->ucs_orthografic_type)
      pass ("VPORT.ucs_orthografic_type [BS] %hu", ucs_orthografic_type);
    else
      {
        fail ("VPORT.ucs_orthografic_type [BS] %hu != %hu", vport->ucs_orthografic_type, ucs_orthografic_type); error++;
      }
    ucs_orthografic_type++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "ucs_orthografic_type", &ucs_orthografic_type) &&
        ucs_orthografic_type == vport->ucs_orthografic_type)
      pass ("VPORT.ucs_orthografic_type [BS] set+1 %hu", ucs_orthografic_type);
    else
      {
        fail ("VPORT.ucs_orthografic_type [BS] set+1 %hu != %hu", vport->ucs_orthografic_type, ucs_orthografic_type); error++;
      }
    vport->ucs_orthografic_type--;

  }
  {
    BITCODE_B ucs_pre_viewport;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_pre_viewport", &ucs_pre_viewport, NULL) &&
        ucs_pre_viewport == vport->ucs_pre_viewport)
      pass ("VPORT.ucs_pre_viewport [B] " FORMAT_B "", ucs_pre_viewport);
    else
      {
        fail ("VPORT.ucs_pre_viewport [B] " FORMAT_B " != " FORMAT_B "", vport->ucs_pre_viewport, ucs_pre_viewport); error++;
      }
    ucs_pre_viewport++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "ucs_pre_viewport", &ucs_pre_viewport) &&
        ucs_pre_viewport == vport->ucs_pre_viewport)
      pass ("VPORT.ucs_pre_viewport [B] set+1 " FORMAT_B "", ucs_pre_viewport);
    else
      {
        fail ("VPORT.ucs_pre_viewport [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->ucs_pre_viewport, ucs_pre_viewport); error++;
      }
    vport->ucs_pre_viewport--;

  }
  {
    BITCODE_3BD ucs_x_axis;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp(&ucs_x_axis, &vport->ucs_x_axis, sizeof(vport->ucs_x_axis)))
      pass ("VPORT.ucs_x_axis [3BD]");
    else
      {
        fail ("VPORT.ucs_x_axis [3BD]"); error++;
      }
  }
  {
    BITCODE_3BD ucs_y_axis;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp(&ucs_y_axis, &vport->ucs_y_axis, sizeof(vport->ucs_y_axis)))
      pass ("VPORT.ucs_y_axis [3BD]");
    else
      {
        fail ("VPORT.ucs_y_axis [3BD]"); error++;
      }
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value(vport, "VPORT", "unknown", &unknown, NULL) &&
        unknown == vport->unknown)
      pass ("VPORT.unknown [B] " FORMAT_B "", unknown);
    else
      {
        fail ("VPORT.unknown [B] " FORMAT_B " != " FORMAT_B "", vport->unknown, unknown); error++;
      }
    unknown++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "unknown", &unknown) &&
        unknown == vport->unknown)
      pass ("VPORT.unknown [B] set+1 " FORMAT_B "", unknown);
    else
      {
        fail ("VPORT.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->unknown, unknown); error++;
      }
    vport->unknown--;

  }
  {
    BITCODE_2RD upper_right;
    if (dwg_dynapi_entity_value(vport, "VPORT", "upper_right", &upper_right, NULL)
        && !memcmp(&upper_right, &vport->upper_right, sizeof(vport->upper_right)))
      pass ("VPORT.upper_right [2RD]");
    else
      {
        fail ("VPORT.upper_right [2RD]"); error++;
      }
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value(vport, "VPORT", "use_default_lights", &use_default_lights, NULL) &&
        use_default_lights == vport->use_default_lights)
      pass ("VPORT.use_default_lights [B] " FORMAT_B "", use_default_lights);
    else
      {
        fail ("VPORT.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", vport->use_default_lights, use_default_lights); error++;
      }
    use_default_lights++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "use_default_lights", &use_default_lights) &&
        use_default_lights == vport->use_default_lights)
      pass ("VPORT.use_default_lights [B] set+1 " FORMAT_B "", use_default_lights);
    else
      {
        fail ("VPORT.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->use_default_lights, use_default_lights); error++;
      }
    vport->use_default_lights--;

  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(vport, "VPORT", "used", &used, NULL) &&
        used == vport->used)
      pass ("VPORT.used [RS] %hu", used);
    else
      {
        fail ("VPORT.used [RS] %hu != %hu", vport->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "used", &used) &&
        used == vport->used)
      pass ("VPORT.used [RS] set+1 %hu", used);
    else
      {
        fail ("VPORT.used [RS] set+1 %hu != %hu", vport->used, used); error++;
      }
    vport->used--;

  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value(vport, "VPORT", "view_target", &view_target, NULL)
        && !memcmp(&view_target, &vport->view_target, sizeof(vport->view_target)))
      pass ("VPORT.view_target [3BD]");
    else
      {
        fail ("VPORT.view_target [3BD]"); error++;
      }
  }
  {
    BITCODE_BD view_twist;
    if (dwg_dynapi_entity_value(vport, "VPORT", "view_twist", &view_twist, NULL) &&
        view_twist == vport->view_twist)
      pass ("VPORT.view_twist [BD] %g", view_twist);
    else
      {
        fail ("VPORT.view_twist [BD] %g != %g", vport->view_twist, view_twist); error++;
      }
    view_twist++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "view_twist", &view_twist) &&
        view_twist == vport->view_twist)
      pass ("VPORT.view_twist [BD] set+1 %g", view_twist);
    else
      {
        fail ("VPORT.view_twist [BD] set+1 %g != %g", vport->view_twist, view_twist); error++;
      }
    vport->view_twist--;

  }
  {
    BITCODE_H visual_style_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "visual_style_handle", &visual_style_handle, NULL)
        && !memcmp(&visual_style_handle, &vport->visual_style_handle, sizeof(vport->visual_style_handle)))
      pass ("VPORT.visual_style_handle [H]");
    else
      {
        fail ("VPORT.visual_style_handle [H]"); error++;
      }
  }
  {
    BITCODE_H vport_control;
    if (dwg_dynapi_entity_value(vport, "VPORT", "vport_control", &vport_control, NULL)
        && !memcmp(&vport_control, &vport->vport_control, sizeof(vport->vport_control)))
      pass ("VPORT.vport_control [H]");
    else
      {
        fail ("VPORT.vport_control [H]"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(vport, "VPORT", "xrefdep", &xrefdep, NULL) &&
        xrefdep == vport->xrefdep)
      pass ("VPORT.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("VPORT.xrefdep [B] " FORMAT_B " != " FORMAT_B "", vport->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "xrefdep", &xrefdep) &&
        xrefdep == vport->xrefdep)
      pass ("VPORT.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("VPORT.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->xrefdep, xrefdep); error++;
      }
    vport->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(vport, "VPORT", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == vport->xrefindex_plus1)
      pass ("VPORT.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("VPORT.xrefindex_plus1 [BS] %hu != %hu", vport->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == vport->xrefindex_plus1)
      pass ("VPORT.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("VPORT.xrefindex_plus1 [BS] set+1 %hu != %hu", vport->xrefindex_plus1, xrefindex_plus1); error++;
      }
    vport->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(vport, "VPORT", "xrefref", &xrefref, NULL) &&
        xrefref == vport->xrefref)
      pass ("VPORT.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("VPORT.xrefref [B] " FORMAT_B " != " FORMAT_B "", vport->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(vport, "VPORT", "xrefref", &xrefref) &&
        xrefref == vport->xrefref)
      pass ("VPORT.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("VPORT.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->xrefref, xrefref); error++;
      }
    vport->xrefref--;

  }
  return error;
}
static int test_VPORT_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VPORT_CONTROL *vport_control = obj->tio.object->tio.VPORT_CONTROL;
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &vport_control->null_handle, sizeof(vport_control->null_handle)))
      pass ("VPORT_CONTROL.null_handle [H]");
    else
      {
        fail ("VPORT_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == vport_control->num_entries)
      pass ("VPORT_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("VPORT_CONTROL.num_entries [BS] %hu != %hu", vport_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(vport_control, "VPORT_CONTROL", "num_entries", &num_entries) &&
        num_entries == vport_control->num_entries)
      pass ("VPORT_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("VPORT_CONTROL.num_entries [BS] set+1 %hu != %hu", vport_control->num_entries, num_entries); error++;
      }
    vport_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "objid", &objid, NULL) &&
        objid == vport_control->objid)
      pass ("VPORT_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("VPORT_CONTROL.objid [BL] %u != %u", vport_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(vport_control, "VPORT_CONTROL", "objid", &objid) &&
        objid == vport_control->objid)
      pass ("VPORT_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("VPORT_CONTROL.objid [BL] set+1 %u != %u", vport_control->objid, objid); error++;
      }
    vport_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &vport_control->parent, sizeof(vport_control->parent)))
      pass ("VPORT_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("VPORT_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &vport_control->reactors, sizeof(vport_control->reactors)))
      pass ("VPORT_CONTROL.reactors [H]");
    else
      {
        fail ("VPORT_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H vports;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "vports", &vports, NULL)
        && !memcmp(&vports, &vport_control->vports, sizeof(vport_control->vports)))
      pass ("VPORT_CONTROL.vports [H]");
    else
      {
        fail ("VPORT_CONTROL.vports [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &vport_control->xdicobjhandle, sizeof(vport_control->xdicobjhandle)))
      pass ("VPORT_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("VPORT_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_VPORT_ENTITY_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VPORT_ENTITY_CONTROL *vport_entity_control = obj->tio.object->tio.VPORT_ENTITY_CONTROL;
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &vport_entity_control->null_handle, sizeof(vport_entity_control->null_handle)))
      pass ("VPORT_ENTITY_CONTROL.null_handle [H]");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.null_handle [H]"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == vport_entity_control->num_entries)
      pass ("VPORT_ENTITY_CONTROL.num_entries [BS] %hu", num_entries);
    else
      {
        fail ("VPORT_ENTITY_CONTROL.num_entries [BS] %hu != %hu", vport_entity_control->num_entries, num_entries); error++;
      }
    num_entries++;
    if (dwg_dynapi_entity_set_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "num_entries", &num_entries) &&
        num_entries == vport_entity_control->num_entries)
      pass ("VPORT_ENTITY_CONTROL.num_entries [BS] set+1 %hu", num_entries);
    else
      {
        fail ("VPORT_ENTITY_CONTROL.num_entries [BS] set+1 %hu != %hu", vport_entity_control->num_entries, num_entries); error++;
      }
    vport_entity_control->num_entries--;

  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "objid", &objid, NULL) &&
        objid == vport_entity_control->objid)
      pass ("VPORT_ENTITY_CONTROL.objid [BL] %u", objid);
    else
      {
        fail ("VPORT_ENTITY_CONTROL.objid [BL] %u != %u", vport_entity_control->objid, objid); error++;
      }
    objid++;
    if (dwg_dynapi_entity_set_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "objid", &objid) &&
        objid == vport_entity_control->objid)
      pass ("VPORT_ENTITY_CONTROL.objid [BL] set+1 %u", objid);
    else
      {
        fail ("VPORT_ENTITY_CONTROL.objid [BL] set+1 %u != %u", vport_entity_control->objid, objid); error++;
      }
    vport_entity_control->objid--;

  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &vport_entity_control->parent, sizeof(vport_entity_control->parent)))
      pass ("VPORT_ENTITY_CONTROL.parent [struct _dwg_object_object*]");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_H reactors;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &vport_entity_control->reactors, sizeof(vport_entity_control->reactors)))
      pass ("VPORT_ENTITY_CONTROL.reactors [H]");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.reactors [H]"); error++;
      }
  }
  {
    BITCODE_H vport_entity_headers;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "vport_entity_headers", &vport_entity_headers, NULL)
        && !memcmp(&vport_entity_headers, &vport_entity_control->vport_entity_headers, sizeof(vport_entity_control->vport_entity_headers)))
      pass ("VPORT_ENTITY_CONTROL.vport_entity_headers [H]");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.vport_entity_headers [H]"); error++;
      }
  }
  {
    BITCODE_H xdicobjhandle;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &vport_entity_control->xdicobjhandle, sizeof(vport_entity_control->xdicobjhandle)))
      pass ("VPORT_ENTITY_CONTROL.xdicobjhandle [H]");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.xdicobjhandle [H]"); error++;
      }
  }
  return error;
}
static int test_VPORT_ENTITY_HEADER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VPORT_ENTITY_HEADER *vport_entity_header = obj->tio.object->tio.VPORT_ENTITY_HEADER;
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "flag", &flag, NULL) &&
        flag == vport_entity_header->flag)
      pass ("VPORT_ENTITY_HEADER.flag [RC] %u", flag);
    else
      {
        fail ("VPORT_ENTITY_HEADER.flag [RC] %u != %u", vport_entity_header->flag, flag); error++;
      }
    flag++;
    if (dwg_dynapi_entity_set_value(vport_entity_header, "VPORT_ENTITY_HEADER", "flag", &flag) &&
        flag == vport_entity_header->flag)
      pass ("VPORT_ENTITY_HEADER.flag [RC] set+1 %u", flag);
    else
      {
        fail ("VPORT_ENTITY_HEADER.flag [RC] set+1 %u != %u", vport_entity_header->flag, flag); error++;
      }
    vport_entity_header->flag--;

  }
  {
    BITCODE_B flag1;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "flag1", &flag1, NULL) &&
        flag1 == vport_entity_header->flag1)
      pass ("VPORT_ENTITY_HEADER.flag1 [B] " FORMAT_B "", flag1);
    else
      {
        fail ("VPORT_ENTITY_HEADER.flag1 [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->flag1, flag1); error++;
      }
    flag1++;
    if (dwg_dynapi_entity_set_value(vport_entity_header, "VPORT_ENTITY_HEADER", "flag1", &flag1) &&
        flag1 == vport_entity_header->flag1)
      pass ("VPORT_ENTITY_HEADER.flag1 [B] set+1 " FORMAT_B "", flag1);
    else
      {
        fail ("VPORT_ENTITY_HEADER.flag1 [B] set+1 " FORMAT_B " != " FORMAT_B "", vport_entity_header->flag1, flag1); error++;
      }
    vport_entity_header->flag1--;

  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&vport_entity_header->name))
      pass ("VPORT_ENTITY_HEADER.name [TV]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.name [TV]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "parent", &parent, NULL)
        && !memcmp(&parent, &vport_entity_header->parent, sizeof(vport_entity_header->parent)))
      pass ("VPORT_ENTITY_HEADER.parent [struct _dwg_object_object*]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "used", &used, NULL) &&
        used == vport_entity_header->used)
      pass ("VPORT_ENTITY_HEADER.used [RS] %hu", used);
    else
      {
        fail ("VPORT_ENTITY_HEADER.used [RS] %hu != %hu", vport_entity_header->used, used); error++;
      }
    used++;
    if (dwg_dynapi_entity_set_value(vport_entity_header, "VPORT_ENTITY_HEADER", "used", &used) &&
        used == vport_entity_header->used)
      pass ("VPORT_ENTITY_HEADER.used [RS] set+1 %hu", used);
    else
      {
        fail ("VPORT_ENTITY_HEADER.used [RS] set+1 %hu != %hu", vport_entity_header->used, used); error++;
      }
    vport_entity_header->used--;

  }
  {
    BITCODE_H vport_entity;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "vport_entity", &vport_entity, NULL)
        && !memcmp(&vport_entity, &vport_entity_header->vport_entity, sizeof(vport_entity_header->vport_entity)))
      pass ("VPORT_ENTITY_HEADER.vport_entity [H]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.vport_entity [H]"); error++;
      }
  }
  {
    BITCODE_H vport_entity_control;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "vport_entity_control", &vport_entity_control, NULL)
        && !memcmp(&vport_entity_control, &vport_entity_header->vport_entity_control, sizeof(vport_entity_header->vport_entity_control)))
      pass ("VPORT_ENTITY_HEADER.vport_entity_control [H]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.vport_entity_control [H]"); error++;
      }
  }
  {
    BITCODE_H xref_handle;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xref_handle", &xref_handle, NULL)
        && !memcmp(&xref_handle, &vport_entity_header->xref_handle, sizeof(vport_entity_header->xref_handle)))
      pass ("VPORT_ENTITY_HEADER.xref_handle [H]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.xref_handle [H]"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefdep", &xrefdep, NULL) &&
        xrefdep == vport_entity_header->xrefdep)
      pass ("VPORT_ENTITY_HEADER.xrefdep [B] " FORMAT_B "", xrefdep);
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefdep, xrefdep); error++;
      }
    xrefdep++;
    if (dwg_dynapi_entity_set_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefdep", &xrefdep) &&
        xrefdep == vport_entity_header->xrefdep)
      pass ("VPORT_ENTITY_HEADER.xrefdep [B] set+1 " FORMAT_B "", xrefdep);
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefdep, xrefdep); error++;
      }
    vport_entity_header->xrefdep--;

  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == vport_entity_header->xrefindex_plus1)
      pass ("VPORT_ENTITY_HEADER.xrefindex_plus1 [BS] %hu", xrefindex_plus1);
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefindex_plus1 [BS] %hu != %hu", vport_entity_header->xrefindex_plus1, xrefindex_plus1); error++;
      }
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefindex_plus1", &xrefindex_plus1) &&
        xrefindex_plus1 == vport_entity_header->xrefindex_plus1)
      pass ("VPORT_ENTITY_HEADER.xrefindex_plus1 [BS] set+1 %hu", xrefindex_plus1);
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefindex_plus1 [BS] set+1 %hu != %hu", vport_entity_header->xrefindex_plus1, xrefindex_plus1); error++;
      }
    vport_entity_header->xrefindex_plus1--;

  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefref", &xrefref, NULL) &&
        xrefref == vport_entity_header->xrefref)
      pass ("VPORT_ENTITY_HEADER.xrefref [B] " FORMAT_B "", xrefref);
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefref [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefref, xrefref); error++;
      }
    xrefref++;
    if (dwg_dynapi_entity_set_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefref", &xrefref) &&
        xrefref == vport_entity_header->xrefref)
      pass ("VPORT_ENTITY_HEADER.xrefref [B] set+1 " FORMAT_B "", xrefref);
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefref, xrefref); error++;
      }
    vport_entity_header->xrefref--;

  }
  return error;
}
static int test_WIPEOUTVARIABLES (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_WIPEOUTVARIABLES *wipeoutvariables = obj->tio.object->tio.WIPEOUTVARIABLES;
  {
    BITCODE_BS display_frame;
    if (dwg_dynapi_entity_value(wipeoutvariables, "WIPEOUTVARIABLES", "display_frame", &display_frame, NULL) &&
        display_frame == wipeoutvariables->display_frame)
      pass ("WIPEOUTVARIABLES.display_frame [BS] %hu", display_frame);
    else
      {
        fail ("WIPEOUTVARIABLES.display_frame [BS] %hu != %hu", wipeoutvariables->display_frame, display_frame); error++;
      }
    display_frame++;
    if (dwg_dynapi_entity_set_value(wipeoutvariables, "WIPEOUTVARIABLES", "display_frame", &display_frame) &&
        display_frame == wipeoutvariables->display_frame)
      pass ("WIPEOUTVARIABLES.display_frame [BS] set+1 %hu", display_frame);
    else
      {
        fail ("WIPEOUTVARIABLES.display_frame [BS] set+1 %hu != %hu", wipeoutvariables->display_frame, display_frame); error++;
      }
    wipeoutvariables->display_frame--;

  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(wipeoutvariables, "WIPEOUTVARIABLES", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &wipeoutvariables->ownerhandle, sizeof(wipeoutvariables->ownerhandle)))
      pass ("WIPEOUTVARIABLES.ownerhandle [H]");
    else
      {
        fail ("WIPEOUTVARIABLES.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(wipeoutvariables, "WIPEOUTVARIABLES", "parent", &parent, NULL)
        && !memcmp(&parent, &wipeoutvariables->parent, sizeof(wipeoutvariables->parent)))
      pass ("WIPEOUTVARIABLES.parent [struct _dwg_object_object*]");
    else
      {
        fail ("WIPEOUTVARIABLES.parent [struct _dwg_object_object*]"); error++;
      }
  }
  return error;
}
static int test_XRECORD (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_XRECORD *xrecord = obj->tio.object->tio.XRECORD;
  {
    BITCODE_BS cloning_flags;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "cloning_flags", &cloning_flags, NULL) &&
        cloning_flags == xrecord->cloning_flags)
      pass ("XRECORD.cloning_flags [BS] %hu", cloning_flags);
    else
      {
        fail ("XRECORD.cloning_flags [BS] %hu != %hu", xrecord->cloning_flags, cloning_flags); error++;
      }
    cloning_flags++;
    if (dwg_dynapi_entity_set_value(xrecord, "XRECORD", "cloning_flags", &cloning_flags) &&
        cloning_flags == xrecord->cloning_flags)
      pass ("XRECORD.cloning_flags [BS] set+1 %hu", cloning_flags);
    else
      {
        fail ("XRECORD.cloning_flags [BS] set+1 %hu != %hu", xrecord->cloning_flags, cloning_flags); error++;
      }
    xrecord->cloning_flags--;

  }
  {
    BITCODE_BL num_databytes;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "num_databytes", &num_databytes, NULL) &&
        num_databytes == xrecord->num_databytes)
      pass ("XRECORD.num_databytes [BL] %u", num_databytes);
    else
      {
        fail ("XRECORD.num_databytes [BL] %u != %u", xrecord->num_databytes, num_databytes); error++;
      }
    num_databytes++;
    if (dwg_dynapi_entity_set_value(xrecord, "XRECORD", "num_databytes", &num_databytes) &&
        num_databytes == xrecord->num_databytes)
      pass ("XRECORD.num_databytes [BL] set+1 %u", num_databytes);
    else
      {
        fail ("XRECORD.num_databytes [BL] set+1 %u != %u", xrecord->num_databytes, num_databytes); error++;
      }
    xrecord->num_databytes--;

  }
  {
    BITCODE_BL num_eed;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "num_eed", &num_eed, NULL) &&
        num_eed == xrecord->num_eed)
      pass ("XRECORD.num_eed [BL] %u", num_eed);
    else
      {
        fail ("XRECORD.num_eed [BL] %u != %u", xrecord->num_eed, num_eed); error++;
      }
    num_eed++;
    if (dwg_dynapi_entity_set_value(xrecord, "XRECORD", "num_eed", &num_eed) &&
        num_eed == xrecord->num_eed)
      pass ("XRECORD.num_eed [BL] set+1 %u", num_eed);
    else
      {
        fail ("XRECORD.num_eed [BL] set+1 %u != %u", xrecord->num_eed, num_eed); error++;
      }
    xrecord->num_eed--;

  }
  {
    BITCODE_BL num_objid_handles;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "num_objid_handles", &num_objid_handles, NULL) &&
        num_objid_handles == xrecord->num_objid_handles)
      pass ("XRECORD.num_objid_handles [BL] %u", num_objid_handles);
    else
      {
        fail ("XRECORD.num_objid_handles [BL] %u != %u", xrecord->num_objid_handles, num_objid_handles); error++;
      }
    num_objid_handles++;
    if (dwg_dynapi_entity_set_value(xrecord, "XRECORD", "num_objid_handles", &num_objid_handles) &&
        num_objid_handles == xrecord->num_objid_handles)
      pass ("XRECORD.num_objid_handles [BL] set+1 %u", num_objid_handles);
    else
      {
        fail ("XRECORD.num_objid_handles [BL] set+1 %u != %u", xrecord->num_objid_handles, num_objid_handles); error++;
      }
    xrecord->num_objid_handles--;

  }
  {
    BITCODE_H* objid_handles;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "objid_handles", &objid_handles, NULL)
        && !memcmp(&objid_handles, &xrecord->objid_handles, sizeof(xrecord->objid_handles)))
      pass ("XRECORD.objid_handles [H*]");
    else
      {
        fail ("XRECORD.objid_handles [H*]"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "ownerhandle", &ownerhandle, NULL)
        && !memcmp(&ownerhandle, &xrecord->ownerhandle, sizeof(xrecord->ownerhandle)))
      pass ("XRECORD.ownerhandle [H]");
    else
      {
        fail ("XRECORD.ownerhandle [H]"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "parent", &parent, NULL)
        && !memcmp(&parent, &xrecord->parent, sizeof(xrecord->parent)))
      pass ("XRECORD.parent [struct _dwg_object_object*]");
    else
      {
        fail ("XRECORD.parent [struct _dwg_object_object*]"); error++;
      }
  }
  {
    Dwg_Resbuf* xdata;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "xdata", &xdata, NULL)
        && !memcmp(&xdata, &xrecord->xdata, sizeof(xrecord->xdata)))
      pass ("XRECORD.xdata [Dwg_Resbuf*]");
    else
      {
        fail ("XRECORD.xdata [Dwg_Resbuf*]"); error++;
      }
  }
  return error;
}

#line 56 "dynapi_test.c.in"
static int test_object (const Dwg_Data *restrict dwg, const Dwg_Object *restrict obj)
{
  int error = 0;
  if (obj->supertype == DWG_SUPERTYPE_UNKNOWN)
    return 0;
#line 42998 "dynapi_test.c"
  /* @@for if_test_OBJECT@@ */
  if (obj->fixedtype == DWG_TYPE__3DFACE)
    error += test__3DFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE__3DSOLID)
    error += test__3DSOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTDEF)
    error += test_ATTDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTRIB)
    error += test_ATTRIB(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK)
    error += test_BLOCK(obj);
  else  if (obj->fixedtype == DWG_TYPE_CAMERA)
    error += test_CAMERA(obj);
  else  if (obj->fixedtype == DWG_TYPE_CIRCLE)
    error += test_CIRCLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED)
    error += test_DIMENSION_ALIGNED(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
    error += test_DIMENSION_ANG2LN(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG3PT)
    error += test_DIMENSION_ANG3PT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_DIAMETER)
    error += test_DIMENSION_DIAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_LINEAR)
    error += test_DIMENSION_LINEAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ORDINATE)
    error += test_DIMENSION_ORDINATE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_RADIUS)
    error += test_DIMENSION_RADIUS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ELLIPSE)
    error += test_ELLIPSE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDBLK)
    error += test_ENDBLK(obj);
  else  if (obj->fixedtype == DWG_TYPE_EXTRUDEDSURFACE)
    error += test_EXTRUDEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOPOSITIONMARKER)
    error += test_GEOPOSITIONMARKER(obj);
  else  if (obj->fixedtype == DWG_TYPE_HATCH)
    error += test_HATCH(obj);
  else  if (obj->fixedtype == DWG_TYPE_HELIX)
    error += test_HELIX(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE)
    error += test_IMAGE(obj);
  else  if (obj->fixedtype == DWG_TYPE_INSERT)
    error += test_INSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADER)
    error += test_LEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHT)
    error += test_LIGHT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LINE)
    error += test_LINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LOFTEDSURFACE)
    error += test_LOFTEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LWPOLYLINE)
    error += test_LWPOLYLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MINSERT)
    error += test_MINSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINE)
    error += test_MLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXT)
    error += test_MTEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MULTILEADER)
    error += test_MULTILEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLE2FRAME)
    error += test_OLE2FRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLEFRAME)
    error += test_OLEFRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLANESURFACE)
    error += test_PLANESURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINT)
    error += test_POINT(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_2D)
    error += test_POLYLINE_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_3D)
    error += test_POLYLINE_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_MESH)
    error += test_POLYLINE_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_PFACE)
    error += test_POLYLINE_PFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY)
    error += test_PROXY_ENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_RAY)
    error += test_RAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_REVOLVEDSURFACE)
    error += test_REVOLVEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SEQEND)
    error += test_SEQEND(obj);
  else  if (obj->fixedtype == DWG_TYPE_SHAPE)
    error += test_SHAPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID)
    error += test_SOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPLINE)
    error += test_SPLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SWEPTSURFACE)
    error += test_SWEPTSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLE)
    error += test_TABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXT)
    error += test_TEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TOLERANCE)
    error += test_TOLERANCE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TRACE)
    error += test_TRACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAY)
    error += test_UNDERLAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)
    error += test_UNKNOWN_ENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_2D)
    error += test_VERTEX_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_3D)
    error += test_VERTEX_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE_FACE)
    error += test_VERTEX_PFACE_FACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEWPORT)
    error += test_VIEWPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUT)
    error += test_WIPEOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACDBNAVISWORKSMODELDEF)
    error += test_ACDBNAVISWORKSMODELDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SWEEP_CLASS)
    error += test_ACSH_SWEEP_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID)
    error += test_APPID(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID_CONTROL)
    error += test_APPID_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC2DCONSTRAINTGROUP)
    error += test_ASSOC2DCONSTRAINTGROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTION)
    error += test_ASSOCACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY)
    error += test_ASSOCALIGNEDDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDEPENDENCY)
    error += test_ASSOCDEPENDENCY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORK)
    error += test_ASSOCNETWORK(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM)
    error += test_ASSOCOSNAPPOINTREFACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPERSSUBENTMANAGER)
    error += test_ASSOCPERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPLANESURFACEACTIONBODY)
    error += test_ASSOCPLANESURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_CONTROL)
    error += test_BLOCK_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
    error += test_BLOCK_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
    error += test_CELLSTYLEMAP(obj);
  else  if (obj->fixedtype == DWG_TYPE_DATATABLE)
    error += test_DATATABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DBCOLOR)
    error += test_DBCOLOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARY)
    error += test_DICTIONARY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYVAR)
    error += test_DICTIONARYVAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
    error += test_DICTIONARYWDFLT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMASSOC)
    error += test_DIMASSOC(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
    error += test_DIMSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE_CONTROL)
    error += test_DIMSTYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_DUMMY)
    error += test_DUMMY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER)
    error += test_DYNAMICBLOCKPURGEPREVENTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
    error += test_EVALUATION_GRAPH(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELD)
    error += test_FIELD(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELDLIST)
    error += test_FIELDLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEODATA)
    error += test_GEODATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUP)
    error += test_GROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_IDBUFFER)
    error += test_IDBUFFER(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF)
    error += test_IMAGEDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF_REACTOR)
    error += test_IMAGEDEF_REACTOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER)
    error += test_LAYER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_CONTROL)
    error += test_LAYER_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_INDEX)
    error += test_LAYER_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUT)
    error += test_LAYOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHTLIST)
    error += test_LIGHTLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_LONG_TRANSACTION)
    error += test_LONG_TRANSACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE)
    error += test_LTYPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE_CONTROL)
    error += test_LTYPE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MATERIAL)
    error += test_MATERIAL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
    error += test_MLEADERSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINESTYLE)
    error += test_MLINESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECTCONTEXTDATA)
    error += test_OBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECT_PTR)
    error += test_OBJECT_PTR(obj);
  else  if (obj->fixedtype == DWG_TYPE_PERSSUBENTMANAGER)
    error += test_PERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLACEHOLDER)
    error += test_PLACEHOLDER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
    error += test_PLOTSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_OBJECT)
    error += test_PROXY_OBJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_RASTERVARIABLES)
    error += test_RASTERVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_SCALE)
    error += test_SCALE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SORTENTSTABLE)
    error += test_SORTENTSTABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_FILTER)
    error += test_SPATIAL_FILTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_INDEX)
    error += test_SPATIAL_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE)
    error += test_STYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE_CONTROL)
    error += test_STYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUN)
    error += test_SUN(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUNSTUDY)
    error += test_SUNSTUDY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLECONTENT)
    error += test_TABLECONTENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
    error += test_TABLEGEOMETRY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
    error += test_TABLESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS)
    error += test_UCS(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS_CONTROL)
    error += test_UCS_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAYDEFINITION)
    error += test_UNDERLAYDEFINITION(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)
    error += test_UNKNOWN_OBJ(obj);
  else  if (obj->fixedtype == DWG_TYPE_VBA_PROJECT)
    error += test_VBA_PROJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW)
    error += test_VIEW(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW_CONTROL)
    error += test_VIEW_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VISUALSTYLE)
    error += test_VISUALSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT)
    error += test_VPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_CONTROL)
    error += test_VPORT_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_CONTROL)
    error += test_VPORT_ENTITY_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_HEADER)
    error += test_VPORT_ENTITY_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUTVARIABLES)
    error += test_WIPEOUTVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_XRECORD)
    error += test_XRECORD(obj);
  if (obj->fixedtype == DWG_TYPE__3DFACE)
    error += test__3DFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE__3DSOLID)
    error += test__3DSOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTDEF)
    error += test_ATTDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTRIB)
    error += test_ATTRIB(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK)
    error += test_BLOCK(obj);
  else  if (obj->fixedtype == DWG_TYPE_CAMERA)
    error += test_CAMERA(obj);
  else  if (obj->fixedtype == DWG_TYPE_CIRCLE)
    error += test_CIRCLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED)
    error += test_DIMENSION_ALIGNED(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
    error += test_DIMENSION_ANG2LN(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG3PT)
    error += test_DIMENSION_ANG3PT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_DIAMETER)
    error += test_DIMENSION_DIAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_LINEAR)
    error += test_DIMENSION_LINEAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ORDINATE)
    error += test_DIMENSION_ORDINATE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_RADIUS)
    error += test_DIMENSION_RADIUS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ELLIPSE)
    error += test_ELLIPSE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDBLK)
    error += test_ENDBLK(obj);
  else  if (obj->fixedtype == DWG_TYPE_EXTRUDEDSURFACE)
    error += test_EXTRUDEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOPOSITIONMARKER)
    error += test_GEOPOSITIONMARKER(obj);
  else  if (obj->fixedtype == DWG_TYPE_HATCH)
    error += test_HATCH(obj);
  else  if (obj->fixedtype == DWG_TYPE_HELIX)
    error += test_HELIX(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE)
    error += test_IMAGE(obj);
  else  if (obj->fixedtype == DWG_TYPE_INSERT)
    error += test_INSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADER)
    error += test_LEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHT)
    error += test_LIGHT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LINE)
    error += test_LINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LOFTEDSURFACE)
    error += test_LOFTEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LWPOLYLINE)
    error += test_LWPOLYLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MINSERT)
    error += test_MINSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINE)
    error += test_MLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXT)
    error += test_MTEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MULTILEADER)
    error += test_MULTILEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLE2FRAME)
    error += test_OLE2FRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLEFRAME)
    error += test_OLEFRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLANESURFACE)
    error += test_PLANESURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINT)
    error += test_POINT(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_2D)
    error += test_POLYLINE_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_3D)
    error += test_POLYLINE_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_MESH)
    error += test_POLYLINE_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_PFACE)
    error += test_POLYLINE_PFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY)
    error += test_PROXY_ENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_RAY)
    error += test_RAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_REVOLVEDSURFACE)
    error += test_REVOLVEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SEQEND)
    error += test_SEQEND(obj);
  else  if (obj->fixedtype == DWG_TYPE_SHAPE)
    error += test_SHAPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID)
    error += test_SOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPLINE)
    error += test_SPLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SWEPTSURFACE)
    error += test_SWEPTSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLE)
    error += test_TABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXT)
    error += test_TEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TOLERANCE)
    error += test_TOLERANCE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TRACE)
    error += test_TRACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAY)
    error += test_UNDERLAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)
    error += test_UNKNOWN_ENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_2D)
    error += test_VERTEX_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_3D)
    error += test_VERTEX_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE_FACE)
    error += test_VERTEX_PFACE_FACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEWPORT)
    error += test_VIEWPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUT)
    error += test_WIPEOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACDBNAVISWORKSMODELDEF)
    error += test_ACDBNAVISWORKSMODELDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SWEEP_CLASS)
    error += test_ACSH_SWEEP_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID)
    error += test_APPID(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID_CONTROL)
    error += test_APPID_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC2DCONSTRAINTGROUP)
    error += test_ASSOC2DCONSTRAINTGROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTION)
    error += test_ASSOCACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY)
    error += test_ASSOCALIGNEDDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDEPENDENCY)
    error += test_ASSOCDEPENDENCY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORK)
    error += test_ASSOCNETWORK(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM)
    error += test_ASSOCOSNAPPOINTREFACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPERSSUBENTMANAGER)
    error += test_ASSOCPERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPLANESURFACEACTIONBODY)
    error += test_ASSOCPLANESURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_CONTROL)
    error += test_BLOCK_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
    error += test_BLOCK_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
    error += test_CELLSTYLEMAP(obj);
  else  if (obj->fixedtype == DWG_TYPE_DATATABLE)
    error += test_DATATABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DBCOLOR)
    error += test_DBCOLOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARY)
    error += test_DICTIONARY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYVAR)
    error += test_DICTIONARYVAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
    error += test_DICTIONARYWDFLT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMASSOC)
    error += test_DIMASSOC(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
    error += test_DIMSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE_CONTROL)
    error += test_DIMSTYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_DUMMY)
    error += test_DUMMY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER)
    error += test_DYNAMICBLOCKPURGEPREVENTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
    error += test_EVALUATION_GRAPH(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELD)
    error += test_FIELD(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELDLIST)
    error += test_FIELDLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEODATA)
    error += test_GEODATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUP)
    error += test_GROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_IDBUFFER)
    error += test_IDBUFFER(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF)
    error += test_IMAGEDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF_REACTOR)
    error += test_IMAGEDEF_REACTOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER)
    error += test_LAYER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_CONTROL)
    error += test_LAYER_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_INDEX)
    error += test_LAYER_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUT)
    error += test_LAYOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHTLIST)
    error += test_LIGHTLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_LONG_TRANSACTION)
    error += test_LONG_TRANSACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE)
    error += test_LTYPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE_CONTROL)
    error += test_LTYPE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MATERIAL)
    error += test_MATERIAL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
    error += test_MLEADERSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINESTYLE)
    error += test_MLINESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECTCONTEXTDATA)
    error += test_OBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECT_PTR)
    error += test_OBJECT_PTR(obj);
  else  if (obj->fixedtype == DWG_TYPE_PERSSUBENTMANAGER)
    error += test_PERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLACEHOLDER)
    error += test_PLACEHOLDER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
    error += test_PLOTSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_OBJECT)
    error += test_PROXY_OBJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_RASTERVARIABLES)
    error += test_RASTERVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_SCALE)
    error += test_SCALE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SORTENTSTABLE)
    error += test_SORTENTSTABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_FILTER)
    error += test_SPATIAL_FILTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_INDEX)
    error += test_SPATIAL_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE)
    error += test_STYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE_CONTROL)
    error += test_STYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUN)
    error += test_SUN(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUNSTUDY)
    error += test_SUNSTUDY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLECONTENT)
    error += test_TABLECONTENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
    error += test_TABLEGEOMETRY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
    error += test_TABLESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS)
    error += test_UCS(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS_CONTROL)
    error += test_UCS_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAYDEFINITION)
    error += test_UNDERLAYDEFINITION(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)
    error += test_UNKNOWN_OBJ(obj);
  else  if (obj->fixedtype == DWG_TYPE_VBA_PROJECT)
    error += test_VBA_PROJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW)
    error += test_VIEW(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW_CONTROL)
    error += test_VIEW_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VISUALSTYLE)
    error += test_VISUALSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT)
    error += test_VPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_CONTROL)
    error += test_VPORT_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_CONTROL)
    error += test_VPORT_ENTITY_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_HEADER)
    error += test_VPORT_ENTITY_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUTVARIABLES)
    error += test_WIPEOUTVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_XRECORD)
    error += test_XRECORD(obj);
#line 64 "dynapi_test.c.in"
  return error;
}

static int test_dynapi (const char *filename)
{
  int error;
  Dwg_Data dwg;
  BITCODE_BL i;

  dwg.opts = 0;
  if (dwg_read_file (filename, &dwg) >= DWG_ERR_CRITICAL)
    {
      dwg_free (&dwg);
      return 1;
    }
  error = test_header (&dwg);
  for (i=0; i<dwg.num_objects; i++)
    {
      error += test_object(&dwg, &dwg.object[i]);
    }
  dwg_free (&dwg);
  /* This value is the return value for `main',
     so clamp it to either 0 or 1.  */
  return error ? 1 : 0;
}

int
main (int argc, char *argv[])
{
  char *input = getenv ("INPUT");

  if (input == NULL)
    {
      struct stat attrib;
      input = (char*)"example_2000.dwg";
      if (stat(input, &attrib))
        {
          fprintf (stderr, "Env var INPUT not defined, %s not found\n", input);
          return EXIT_FAILURE;
        }
    }
  return test_dynapi (input);
}
