/* ex: set ro ft=c: -*- mode: c; buffer-read-only: t -*- */
/*****************************************************************************/
/*  LibreDWG - free implementation of the DWG file format                    */
/*                                                                           */
/*  Copyright (C) 2019-2020 Free Software Foundation, Inc.                   */
/*                                                                           */
/*  This library is free software, licensed under the terms of the GNU       */
/*  General Public License as published by the Free Software Foundation,     */
/*  either version 3 of the License, or (at your option) any later version.  */
/*  You should have received a copy of the GNU General Public License        */
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
/*****************************************************************************/
/* dynapi coverage tests, generated by gen-dynapi.pl from dynapi_test.c.in
   do not modify */
/* written by: Reini Urban */

#line 16 "dynapi_test.c.in"
#define DYNAPI_TEST_C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <sys/stat.h>

#define DWG_LOGLEVEL DWG_LOGLEVEL_NONE
#include "../../src/config.h"
#include "../../src/common.h"
#include "../../src/classes.h"
#include "dwg.h"
#include "dwg_api.h"
#include "tests_common.h"

/* for all objects/entities/header_vars:
   compare direct api vs dynapi values
*/
static int
test_header (const Dwg_Data *dwg)
{
  int error = 0;
  BITCODE_RL rl;
  BITCODE_RC rc;
  BITCODE_BLL bll;
  BITCODE_BD bd;
  BITCODE_TV tv;

#line 47 "dynapi_test.c"
  /* @@for test_HEADER@@ */
  {
    BITCODE_RL size;
    if (dwg_dynapi_header_value (dwg, "size", &size, NULL)
        && size == dwg->header_vars.size)
      pass ();
    else
      fail ("HEADER.size [RL] %u != %u", dwg->header_vars.size, size);
    size++;
    if (dwg_dynapi_header_set_value (dwg, "size", &size, 0)
        && size == dwg->header_vars.size)
      pass ();
    else
      fail ("HEADER.size [RL] set+1 %u != %u",
            dwg->header_vars.size, size);
    size--;
    dwg_dynapi_header_set_value (dwg, "size", &size, 0);

  }
  {
    BITCODE_RL bitsize_hi;
    if (dwg_dynapi_header_value (dwg, "bitsize_hi", &bitsize_hi, NULL)
        && bitsize_hi == dwg->header_vars.bitsize_hi)
      pass ();
    else
      fail ("HEADER.bitsize_hi [RL] %u != %u", dwg->header_vars.bitsize_hi, bitsize_hi);
    bitsize_hi++;
    if (dwg_dynapi_header_set_value (dwg, "bitsize_hi", &bitsize_hi, 0)
        && bitsize_hi == dwg->header_vars.bitsize_hi)
      pass ();
    else
      fail ("HEADER.bitsize_hi [RL] set+1 %u != %u",
            dwg->header_vars.bitsize_hi, bitsize_hi);
    bitsize_hi--;
    dwg_dynapi_header_set_value (dwg, "bitsize_hi", &bitsize_hi, 0);

  }
  {
    BITCODE_RL bitsize;
    if (dwg_dynapi_header_value (dwg, "bitsize", &bitsize, NULL)
        && bitsize == dwg->header_vars.bitsize)
      pass ();
    else
      fail ("HEADER.bitsize [RL] %u != %u", dwg->header_vars.bitsize, bitsize);
    bitsize++;
    if (dwg_dynapi_header_set_value (dwg, "bitsize", &bitsize, 0)
        && bitsize == dwg->header_vars.bitsize)
      pass ();
    else
      fail ("HEADER.bitsize [RL] set+1 %u != %u",
            dwg->header_vars.bitsize, bitsize);
    bitsize--;
    dwg_dynapi_header_set_value (dwg, "bitsize", &bitsize, 0);

  }
  {
    BITCODE_RC acadmaintver;
    if (dwg_dynapi_header_value (dwg, "ACADMAINTVER", &acadmaintver, NULL)
        && acadmaintver == dwg->header_vars.ACADMAINTVER)
      pass ();
    else
      fail ("HEADER.ACADMAINTVER [RC] %u != %u", dwg->header_vars.ACADMAINTVER, acadmaintver);
    acadmaintver++;
    if (dwg_dynapi_header_set_value (dwg, "ACADMAINTVER", &acadmaintver, 0)
        && acadmaintver == dwg->header_vars.ACADMAINTVER)
      pass ();
    else
      fail ("HEADER.ACADMAINTVER [RC] set+1 %u != %u",
            dwg->header_vars.ACADMAINTVER, acadmaintver);
    acadmaintver--;
    dwg_dynapi_header_set_value (dwg, "ACADMAINTVER", &acadmaintver, 0);

  }
  {
    BITCODE_BLL requiredversions;
    if (dwg_dynapi_header_value (dwg, "REQUIREDVERSIONS", &requiredversions, NULL)
        && requiredversions == dwg->header_vars.REQUIREDVERSIONS)
      pass ();
    else
      fail ("HEADER.REQUIREDVERSIONS [BLL] " FORMAT_BLL " != " FORMAT_BLL "", dwg->header_vars.REQUIREDVERSIONS, requiredversions);
    requiredversions++;
    if (dwg_dynapi_header_set_value (dwg, "REQUIREDVERSIONS", &requiredversions, 0)
        && requiredversions == dwg->header_vars.REQUIREDVERSIONS)
      pass ();
    else
      fail ("HEADER.REQUIREDVERSIONS [BLL] set+1 " FORMAT_BLL " != " FORMAT_BLL "",
            dwg->header_vars.REQUIREDVERSIONS, requiredversions);
    requiredversions--;
    dwg_dynapi_header_set_value (dwg, "REQUIREDVERSIONS", &requiredversions, 0);

  }
  {
    BITCODE_TV dwgcodepage;
    if (dwg_dynapi_header_value (dwg, "DWGCODEPAGE", &dwgcodepage, NULL)
        && !memcmp (&dwgcodepage, &dwg->header_vars.DWGCODEPAGE, sizeof (dwg->header_vars.DWGCODEPAGE))
       )
      pass ();
    else
      fail ("HEADER.DWGCODEPAGE [TV]");
  }
  {
    BITCODE_BD unknown_0;
    if (dwg_dynapi_header_value (dwg, "unknown_0", &unknown_0, NULL)
        && unknown_0 == dwg->header_vars.unknown_0)
      pass ();
    else
      fail ("HEADER.unknown_0 [BD] %g != %g", dwg->header_vars.unknown_0, unknown_0);
    unknown_0++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_0", &unknown_0, 0)
        && unknown_0 == dwg->header_vars.unknown_0)
      pass ();
    else
      fail ("HEADER.unknown_0 [BD] set+1 %g != %g",
            dwg->header_vars.unknown_0, unknown_0);
    unknown_0--;
    dwg_dynapi_header_set_value (dwg, "unknown_0", &unknown_0, 0);

  }
  {
    BITCODE_BD unknown_1;
    if (dwg_dynapi_header_value (dwg, "unknown_1", &unknown_1, NULL)
        && unknown_1 == dwg->header_vars.unknown_1)
      pass ();
    else
      fail ("HEADER.unknown_1 [BD] %g != %g", dwg->header_vars.unknown_1, unknown_1);
    unknown_1++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_1", &unknown_1, 0)
        && unknown_1 == dwg->header_vars.unknown_1)
      pass ();
    else
      fail ("HEADER.unknown_1 [BD] set+1 %g != %g",
            dwg->header_vars.unknown_1, unknown_1);
    unknown_1--;
    dwg_dynapi_header_set_value (dwg, "unknown_1", &unknown_1, 0);

  }
  {
    BITCODE_BD unknown_2;
    if (dwg_dynapi_header_value (dwg, "unknown_2", &unknown_2, NULL)
        && unknown_2 == dwg->header_vars.unknown_2)
      pass ();
    else
      fail ("HEADER.unknown_2 [BD] %g != %g", dwg->header_vars.unknown_2, unknown_2);
    unknown_2++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_2", &unknown_2, 0)
        && unknown_2 == dwg->header_vars.unknown_2)
      pass ();
    else
      fail ("HEADER.unknown_2 [BD] set+1 %g != %g",
            dwg->header_vars.unknown_2, unknown_2);
    unknown_2--;
    dwg_dynapi_header_set_value (dwg, "unknown_2", &unknown_2, 0);

  }
  {
    BITCODE_BD unknown_3;
    if (dwg_dynapi_header_value (dwg, "unknown_3", &unknown_3, NULL)
        && unknown_3 == dwg->header_vars.unknown_3)
      pass ();
    else
      fail ("HEADER.unknown_3 [BD] %g != %g", dwg->header_vars.unknown_3, unknown_3);
    unknown_3++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_3", &unknown_3, 0)
        && unknown_3 == dwg->header_vars.unknown_3)
      pass ();
    else
      fail ("HEADER.unknown_3 [BD] set+1 %g != %g",
            dwg->header_vars.unknown_3, unknown_3);
    unknown_3--;
    dwg_dynapi_header_set_value (dwg, "unknown_3", &unknown_3, 0);

  }
  {
    BITCODE_TV unknown_text1;
    if (dwg_dynapi_header_value (dwg, "unknown_text1", &unknown_text1, NULL)
        && !memcmp (&unknown_text1, &dwg->header_vars.unknown_text1, sizeof (dwg->header_vars.unknown_text1))
       )
      pass ();
    else
      fail ("HEADER.unknown_text1 [TV]");
  }
  {
    BITCODE_TV unknown_text2;
    if (dwg_dynapi_header_value (dwg, "unknown_text2", &unknown_text2, NULL)
        && !memcmp (&unknown_text2, &dwg->header_vars.unknown_text2, sizeof (dwg->header_vars.unknown_text2))
       )
      pass ();
    else
      fail ("HEADER.unknown_text2 [TV]");
  }
  {
    BITCODE_TV unknown_text3;
    if (dwg_dynapi_header_value (dwg, "unknown_text3", &unknown_text3, NULL)
        && !memcmp (&unknown_text3, &dwg->header_vars.unknown_text3, sizeof (dwg->header_vars.unknown_text3))
       )
      pass ();
    else
      fail ("HEADER.unknown_text3 [TV]");
  }
  {
    BITCODE_TV unknown_text4;
    if (dwg_dynapi_header_value (dwg, "unknown_text4", &unknown_text4, NULL)
        && !memcmp (&unknown_text4, &dwg->header_vars.unknown_text4, sizeof (dwg->header_vars.unknown_text4))
       )
      pass ();
    else
      fail ("HEADER.unknown_text4 [TV]");
  }
  {
    BITCODE_BL unknown_8;
    if (dwg_dynapi_header_value (dwg, "unknown_8", &unknown_8, NULL)
        && unknown_8 == dwg->header_vars.unknown_8)
      pass ();
    else
      fail ("HEADER.unknown_8 [BL] %u != %u", dwg->header_vars.unknown_8, unknown_8);
    unknown_8++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_8", &unknown_8, 0)
        && unknown_8 == dwg->header_vars.unknown_8)
      pass ();
    else
      fail ("HEADER.unknown_8 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_8, unknown_8);
    unknown_8--;
    dwg_dynapi_header_set_value (dwg, "unknown_8", &unknown_8, 0);

  }
  {
    BITCODE_BL unknown_9;
    if (dwg_dynapi_header_value (dwg, "unknown_9", &unknown_9, NULL)
        && unknown_9 == dwg->header_vars.unknown_9)
      pass ();
    else
      fail ("HEADER.unknown_9 [BL] %u != %u", dwg->header_vars.unknown_9, unknown_9);
    unknown_9++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_9", &unknown_9, 0)
        && unknown_9 == dwg->header_vars.unknown_9)
      pass ();
    else
      fail ("HEADER.unknown_9 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_9, unknown_9);
    unknown_9--;
    dwg_dynapi_header_set_value (dwg, "unknown_9", &unknown_9, 0);

  }
  {
    BITCODE_BS unknown_10;
    if (dwg_dynapi_header_value (dwg, "unknown_10", &unknown_10, NULL)
        && unknown_10 == dwg->header_vars.unknown_10)
      pass ();
    else
      fail ("HEADER.unknown_10 [BS] %hu != %hu", dwg->header_vars.unknown_10, unknown_10);
    unknown_10++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_10", &unknown_10, 0)
        && unknown_10 == dwg->header_vars.unknown_10)
      pass ();
    else
      fail ("HEADER.unknown_10 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_10, unknown_10);
    unknown_10--;
    dwg_dynapi_header_set_value (dwg, "unknown_10", &unknown_10, 0);

  }
  {
    BITCODE_H vport_entity_header;
    if (dwg_dynapi_header_value (dwg, "VPORT_ENTITY_HEADER", &vport_entity_header, NULL)
        && !memcmp (&vport_entity_header, &dwg->header_vars.VPORT_ENTITY_HEADER, sizeof (dwg->header_vars.VPORT_ENTITY_HEADER))
       )
      pass ();
    else
      fail ("HEADER.VPORT_ENTITY_HEADER [H]");
  }
  {
    BITCODE_B dimaso;
    if (dwg_dynapi_header_value (dwg, "DIMASO", &dimaso, NULL)
        && dimaso == dwg->header_vars.DIMASO)
      pass ();
    else
      fail ("HEADER.DIMASO [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMASO, dimaso);
    dimaso++;
    if (dwg_dynapi_header_set_value (dwg, "DIMASO", &dimaso, 0)
        && dimaso == dwg->header_vars.DIMASO)
      pass ();
    else
      fail ("HEADER.DIMASO [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMASO, dimaso);
    dimaso--;
    dwg_dynapi_header_set_value (dwg, "DIMASO", &dimaso, 0);

  }
  {
    BITCODE_B dimsho;
    if (dwg_dynapi_header_value (dwg, "DIMSHO", &dimsho, NULL)
        && dimsho == dwg->header_vars.DIMSHO)
      pass ();
    else
      fail ("HEADER.DIMSHO [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSHO, dimsho);
    dimsho++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSHO", &dimsho, 0)
        && dimsho == dwg->header_vars.DIMSHO)
      pass ();
    else
      fail ("HEADER.DIMSHO [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSHO, dimsho);
    dimsho--;
    dwg_dynapi_header_set_value (dwg, "DIMSHO", &dimsho, 0);

  }
  {
    BITCODE_B dimsav;
    if (dwg_dynapi_header_value (dwg, "DIMSAV", &dimsav, NULL)
        && dimsav == dwg->header_vars.DIMSAV)
      pass ();
    else
      fail ("HEADER.DIMSAV [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAV, dimsav);
    dimsav++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSAV", &dimsav, 0)
        && dimsav == dwg->header_vars.DIMSAV)
      pass ();
    else
      fail ("HEADER.DIMSAV [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSAV, dimsav);
    dimsav--;
    dwg_dynapi_header_set_value (dwg, "DIMSAV", &dimsav, 0);

  }
  {
    BITCODE_B plinegen;
    if (dwg_dynapi_header_value (dwg, "PLINEGEN", &plinegen, NULL)
        && plinegen == dwg->header_vars.PLINEGEN)
      pass ();
    else
      fail ("HEADER.PLINEGEN [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLINEGEN, plinegen);
    plinegen++;
    if (dwg_dynapi_header_set_value (dwg, "PLINEGEN", &plinegen, 0)
        && plinegen == dwg->header_vars.PLINEGEN)
      pass ();
    else
      fail ("HEADER.PLINEGEN [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PLINEGEN, plinegen);
    plinegen--;
    dwg_dynapi_header_set_value (dwg, "PLINEGEN", &plinegen, 0);

  }
  {
    BITCODE_B orthomode;
    if (dwg_dynapi_header_value (dwg, "ORTHOMODE", &orthomode, NULL)
        && orthomode == dwg->header_vars.ORTHOMODE)
      pass ();
    else
      fail ("HEADER.ORTHOMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ORTHOMODE, orthomode);
    orthomode++;
    if (dwg_dynapi_header_set_value (dwg, "ORTHOMODE", &orthomode, 0)
        && orthomode == dwg->header_vars.ORTHOMODE)
      pass ();
    else
      fail ("HEADER.ORTHOMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ORTHOMODE, orthomode);
    orthomode--;
    dwg_dynapi_header_set_value (dwg, "ORTHOMODE", &orthomode, 0);

  }
  {
    BITCODE_B regenmode;
    if (dwg_dynapi_header_value (dwg, "REGENMODE", &regenmode, NULL)
        && regenmode == dwg->header_vars.REGENMODE)
      pass ();
    else
      fail ("HEADER.REGENMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REGENMODE, regenmode);
    regenmode++;
    if (dwg_dynapi_header_set_value (dwg, "REGENMODE", &regenmode, 0)
        && regenmode == dwg->header_vars.REGENMODE)
      pass ();
    else
      fail ("HEADER.REGENMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.REGENMODE, regenmode);
    regenmode--;
    dwg_dynapi_header_set_value (dwg, "REGENMODE", &regenmode, 0);

  }
  {
    BITCODE_B fillmode;
    if (dwg_dynapi_header_value (dwg, "FILLMODE", &fillmode, NULL)
        && fillmode == dwg->header_vars.FILLMODE)
      pass ();
    else
      fail ("HEADER.FILLMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FILLMODE, fillmode);
    fillmode++;
    if (dwg_dynapi_header_set_value (dwg, "FILLMODE", &fillmode, 0)
        && fillmode == dwg->header_vars.FILLMODE)
      pass ();
    else
      fail ("HEADER.FILLMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.FILLMODE, fillmode);
    fillmode--;
    dwg_dynapi_header_set_value (dwg, "FILLMODE", &fillmode, 0);

  }
  {
    BITCODE_B qtextmode;
    if (dwg_dynapi_header_value (dwg, "QTEXTMODE", &qtextmode, NULL)
        && qtextmode == dwg->header_vars.QTEXTMODE)
      pass ();
    else
      fail ("HEADER.QTEXTMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.QTEXTMODE, qtextmode);
    qtextmode++;
    if (dwg_dynapi_header_set_value (dwg, "QTEXTMODE", &qtextmode, 0)
        && qtextmode == dwg->header_vars.QTEXTMODE)
      pass ();
    else
      fail ("HEADER.QTEXTMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.QTEXTMODE, qtextmode);
    qtextmode--;
    dwg_dynapi_header_set_value (dwg, "QTEXTMODE", &qtextmode, 0);

  }
  {
    BITCODE_B psltscale;
    if (dwg_dynapi_header_value (dwg, "PSLTSCALE", &psltscale, NULL)
        && psltscale == dwg->header_vars.PSLTSCALE)
      pass ();
    else
      fail ("HEADER.PSLTSCALE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSLTSCALE, psltscale);
    psltscale++;
    if (dwg_dynapi_header_set_value (dwg, "PSLTSCALE", &psltscale, 0)
        && psltscale == dwg->header_vars.PSLTSCALE)
      pass ();
    else
      fail ("HEADER.PSLTSCALE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PSLTSCALE, psltscale);
    psltscale--;
    dwg_dynapi_header_set_value (dwg, "PSLTSCALE", &psltscale, 0);

  }
  {
    BITCODE_B limcheck;
    if (dwg_dynapi_header_value (dwg, "LIMCHECK", &limcheck, NULL)
        && limcheck == dwg->header_vars.LIMCHECK)
      pass ();
    else
      fail ("HEADER.LIMCHECK [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LIMCHECK, limcheck);
    limcheck++;
    if (dwg_dynapi_header_set_value (dwg, "LIMCHECK", &limcheck, 0)
        && limcheck == dwg->header_vars.LIMCHECK)
      pass ();
    else
      fail ("HEADER.LIMCHECK [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.LIMCHECK, limcheck);
    limcheck--;
    dwg_dynapi_header_set_value (dwg, "LIMCHECK", &limcheck, 0);

  }
  {
    BITCODE_B blipmode;
    if (dwg_dynapi_header_value (dwg, "BLIPMODE", &blipmode, NULL)
        && blipmode == dwg->header_vars.BLIPMODE)
      pass ();
    else
      fail ("HEADER.BLIPMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.BLIPMODE, blipmode);
    blipmode++;
    if (dwg_dynapi_header_set_value (dwg, "BLIPMODE", &blipmode, 0)
        && blipmode == dwg->header_vars.BLIPMODE)
      pass ();
    else
      fail ("HEADER.BLIPMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.BLIPMODE, blipmode);
    blipmode--;
    dwg_dynapi_header_set_value (dwg, "BLIPMODE", &blipmode, 0);

  }
  {
    BITCODE_B unknown_11;
    if (dwg_dynapi_header_value (dwg, "unknown_11", &unknown_11, NULL)
        && unknown_11 == dwg->header_vars.unknown_11)
      pass ();
    else
      fail ("HEADER.unknown_11 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.unknown_11, unknown_11);
    unknown_11++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_11", &unknown_11, 0)
        && unknown_11 == dwg->header_vars.unknown_11)
      pass ();
    else
      fail ("HEADER.unknown_11 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.unknown_11, unknown_11);
    unknown_11--;
    dwg_dynapi_header_set_value (dwg, "unknown_11", &unknown_11, 0);

  }
  {
    BITCODE_B usrtimer;
    if (dwg_dynapi_header_value (dwg, "USRTIMER", &usrtimer, NULL)
        && usrtimer == dwg->header_vars.USRTIMER)
      pass ();
    else
      fail ("HEADER.USRTIMER [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.USRTIMER, usrtimer);
    usrtimer++;
    if (dwg_dynapi_header_set_value (dwg, "USRTIMER", &usrtimer, 0)
        && usrtimer == dwg->header_vars.USRTIMER)
      pass ();
    else
      fail ("HEADER.USRTIMER [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.USRTIMER, usrtimer);
    usrtimer--;
    dwg_dynapi_header_set_value (dwg, "USRTIMER", &usrtimer, 0);

  }
  {
    BITCODE_B skpoly;
    if (dwg_dynapi_header_value (dwg, "SKPOLY", &skpoly, NULL)
        && skpoly == dwg->header_vars.SKPOLY)
      pass ();
    else
      fail ("HEADER.SKPOLY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SKPOLY, skpoly);
    skpoly++;
    if (dwg_dynapi_header_set_value (dwg, "SKPOLY", &skpoly, 0)
        && skpoly == dwg->header_vars.SKPOLY)
      pass ();
    else
      fail ("HEADER.SKPOLY [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.SKPOLY, skpoly);
    skpoly--;
    dwg_dynapi_header_set_value (dwg, "SKPOLY", &skpoly, 0);

  }
  {
    BITCODE_B angdir;
    if (dwg_dynapi_header_value (dwg, "ANGDIR", &angdir, NULL)
        && angdir == dwg->header_vars.ANGDIR)
      pass ();
    else
      fail ("HEADER.ANGDIR [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ANGDIR, angdir);
    angdir++;
    if (dwg_dynapi_header_set_value (dwg, "ANGDIR", &angdir, 0)
        && angdir == dwg->header_vars.ANGDIR)
      pass ();
    else
      fail ("HEADER.ANGDIR [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ANGDIR, angdir);
    angdir--;
    dwg_dynapi_header_set_value (dwg, "ANGDIR", &angdir, 0);

  }
  {
    BITCODE_B splframe;
    if (dwg_dynapi_header_value (dwg, "SPLFRAME", &splframe, NULL)
        && splframe == dwg->header_vars.SPLFRAME)
      pass ();
    else
      fail ("HEADER.SPLFRAME [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SPLFRAME, splframe);
    splframe++;
    if (dwg_dynapi_header_set_value (dwg, "SPLFRAME", &splframe, 0)
        && splframe == dwg->header_vars.SPLFRAME)
      pass ();
    else
      fail ("HEADER.SPLFRAME [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.SPLFRAME, splframe);
    splframe--;
    dwg_dynapi_header_set_value (dwg, "SPLFRAME", &splframe, 0);

  }
  {
    BITCODE_B attreq;
    if (dwg_dynapi_header_value (dwg, "ATTREQ", &attreq, NULL)
        && attreq == dwg->header_vars.ATTREQ)
      pass ();
    else
      fail ("HEADER.ATTREQ [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTREQ, attreq);
    attreq++;
    if (dwg_dynapi_header_set_value (dwg, "ATTREQ", &attreq, 0)
        && attreq == dwg->header_vars.ATTREQ)
      pass ();
    else
      fail ("HEADER.ATTREQ [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ATTREQ, attreq);
    attreq--;
    dwg_dynapi_header_set_value (dwg, "ATTREQ", &attreq, 0);

  }
  {
    BITCODE_B attdia;
    if (dwg_dynapi_header_value (dwg, "ATTDIA", &attdia, NULL)
        && attdia == dwg->header_vars.ATTDIA)
      pass ();
    else
      fail ("HEADER.ATTDIA [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTDIA, attdia);
    attdia++;
    if (dwg_dynapi_header_set_value (dwg, "ATTDIA", &attdia, 0)
        && attdia == dwg->header_vars.ATTDIA)
      pass ();
    else
      fail ("HEADER.ATTDIA [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ATTDIA, attdia);
    attdia--;
    dwg_dynapi_header_set_value (dwg, "ATTDIA", &attdia, 0);

  }
  {
    BITCODE_B mirrtext;
    if (dwg_dynapi_header_value (dwg, "MIRRTEXT", &mirrtext, NULL)
        && mirrtext == dwg->header_vars.MIRRTEXT)
      pass ();
    else
      fail ("HEADER.MIRRTEXT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.MIRRTEXT, mirrtext);
    mirrtext++;
    if (dwg_dynapi_header_set_value (dwg, "MIRRTEXT", &mirrtext, 0)
        && mirrtext == dwg->header_vars.MIRRTEXT)
      pass ();
    else
      fail ("HEADER.MIRRTEXT [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.MIRRTEXT, mirrtext);
    mirrtext--;
    dwg_dynapi_header_set_value (dwg, "MIRRTEXT", &mirrtext, 0);

  }
  {
    BITCODE_B worldview;
    if (dwg_dynapi_header_value (dwg, "WORLDVIEW", &worldview, NULL)
        && worldview == dwg->header_vars.WORLDVIEW)
      pass ();
    else
      fail ("HEADER.WORLDVIEW [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WORLDVIEW, worldview);
    worldview++;
    if (dwg_dynapi_header_set_value (dwg, "WORLDVIEW", &worldview, 0)
        && worldview == dwg->header_vars.WORLDVIEW)
      pass ();
    else
      fail ("HEADER.WORLDVIEW [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.WORLDVIEW, worldview);
    worldview--;
    dwg_dynapi_header_set_value (dwg, "WORLDVIEW", &worldview, 0);

  }
  {
    BITCODE_B wireframe;
    if (dwg_dynapi_header_value (dwg, "WIREFRAME", &wireframe, NULL)
        && wireframe == dwg->header_vars.WIREFRAME)
      pass ();
    else
      fail ("HEADER.WIREFRAME [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WIREFRAME, wireframe);
    wireframe++;
    if (dwg_dynapi_header_set_value (dwg, "WIREFRAME", &wireframe, 0)
        && wireframe == dwg->header_vars.WIREFRAME)
      pass ();
    else
      fail ("HEADER.WIREFRAME [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.WIREFRAME, wireframe);
    wireframe--;
    dwg_dynapi_header_set_value (dwg, "WIREFRAME", &wireframe, 0);

  }
  {
    BITCODE_B tilemode;
    if (dwg_dynapi_header_value (dwg, "TILEMODE", &tilemode, NULL)
        && tilemode == dwg->header_vars.TILEMODE)
      pass ();
    else
      fail ("HEADER.TILEMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.TILEMODE, tilemode);
    tilemode++;
    if (dwg_dynapi_header_set_value (dwg, "TILEMODE", &tilemode, 0)
        && tilemode == dwg->header_vars.TILEMODE)
      pass ();
    else
      fail ("HEADER.TILEMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.TILEMODE, tilemode);
    tilemode--;
    dwg_dynapi_header_set_value (dwg, "TILEMODE", &tilemode, 0);

  }
  {
    BITCODE_B plimcheck;
    if (dwg_dynapi_header_value (dwg, "PLIMCHECK", &plimcheck, NULL)
        && plimcheck == dwg->header_vars.PLIMCHECK)
      pass ();
    else
      fail ("HEADER.PLIMCHECK [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLIMCHECK, plimcheck);
    plimcheck++;
    if (dwg_dynapi_header_set_value (dwg, "PLIMCHECK", &plimcheck, 0)
        && plimcheck == dwg->header_vars.PLIMCHECK)
      pass ();
    else
      fail ("HEADER.PLIMCHECK [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PLIMCHECK, plimcheck);
    plimcheck--;
    dwg_dynapi_header_set_value (dwg, "PLIMCHECK", &plimcheck, 0);

  }
  {
    BITCODE_B visretain;
    if (dwg_dynapi_header_value (dwg, "VISRETAIN", &visretain, NULL)
        && visretain == dwg->header_vars.VISRETAIN)
      pass ();
    else
      fail ("HEADER.VISRETAIN [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.VISRETAIN, visretain);
    visretain++;
    if (dwg_dynapi_header_set_value (dwg, "VISRETAIN", &visretain, 0)
        && visretain == dwg->header_vars.VISRETAIN)
      pass ();
    else
      fail ("HEADER.VISRETAIN [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.VISRETAIN, visretain);
    visretain--;
    dwg_dynapi_header_set_value (dwg, "VISRETAIN", &visretain, 0);

  }
  {
    BITCODE_B delobj;
    if (dwg_dynapi_header_value (dwg, "DELOBJ", &delobj, NULL)
        && delobj == dwg->header_vars.DELOBJ)
      pass ();
    else
      fail ("HEADER.DELOBJ [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DELOBJ, delobj);
    delobj++;
    if (dwg_dynapi_header_set_value (dwg, "DELOBJ", &delobj, 0)
        && delobj == dwg->header_vars.DELOBJ)
      pass ();
    else
      fail ("HEADER.DELOBJ [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DELOBJ, delobj);
    delobj--;
    dwg_dynapi_header_set_value (dwg, "DELOBJ", &delobj, 0);

  }
  {
    BITCODE_B dispsilh;
    if (dwg_dynapi_header_value (dwg, "DISPSILH", &dispsilh, NULL)
        && dispsilh == dwg->header_vars.DISPSILH)
      pass ();
    else
      fail ("HEADER.DISPSILH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DISPSILH, dispsilh);
    dispsilh++;
    if (dwg_dynapi_header_set_value (dwg, "DISPSILH", &dispsilh, 0)
        && dispsilh == dwg->header_vars.DISPSILH)
      pass ();
    else
      fail ("HEADER.DISPSILH [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DISPSILH, dispsilh);
    dispsilh--;
    dwg_dynapi_header_set_value (dwg, "DISPSILH", &dispsilh, 0);

  }
  {
    BITCODE_B pellipse;
    if (dwg_dynapi_header_value (dwg, "PELLIPSE", &pellipse, NULL)
        && pellipse == dwg->header_vars.PELLIPSE)
      pass ();
    else
      fail ("HEADER.PELLIPSE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PELLIPSE, pellipse);
    pellipse++;
    if (dwg_dynapi_header_set_value (dwg, "PELLIPSE", &pellipse, 0)
        && pellipse == dwg->header_vars.PELLIPSE)
      pass ();
    else
      fail ("HEADER.PELLIPSE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PELLIPSE, pellipse);
    pellipse--;
    dwg_dynapi_header_set_value (dwg, "PELLIPSE", &pellipse, 0);

  }
  {
    BITCODE_BS saveimages;
    if (dwg_dynapi_header_value (dwg, "SAVEIMAGES", &saveimages, NULL)
        && saveimages == dwg->header_vars.SAVEIMAGES)
      pass ();
    else
      fail ("HEADER.SAVEIMAGES [BS] %hu != %hu", dwg->header_vars.SAVEIMAGES, saveimages);
    saveimages++;
    if (dwg_dynapi_header_set_value (dwg, "SAVEIMAGES", &saveimages, 0)
        && saveimages == dwg->header_vars.SAVEIMAGES)
      pass ();
    else
      fail ("HEADER.SAVEIMAGES [BS] set+1 %hu != %hu",
            dwg->header_vars.SAVEIMAGES, saveimages);
    saveimages--;
    dwg_dynapi_header_set_value (dwg, "SAVEIMAGES", &saveimages, 0);

  }
  {
    BITCODE_BS proxygraphics;
    if (dwg_dynapi_header_value (dwg, "PROXYGRAPHICS", &proxygraphics, NULL)
        && proxygraphics == dwg->header_vars.PROXYGRAPHICS)
      pass ();
    else
      fail ("HEADER.PROXYGRAPHICS [BS] %hu != %hu", dwg->header_vars.PROXYGRAPHICS, proxygraphics);
    proxygraphics++;
    if (dwg_dynapi_header_set_value (dwg, "PROXYGRAPHICS", &proxygraphics, 0)
        && proxygraphics == dwg->header_vars.PROXYGRAPHICS)
      pass ();
    else
      fail ("HEADER.PROXYGRAPHICS [BS] set+1 %hu != %hu",
            dwg->header_vars.PROXYGRAPHICS, proxygraphics);
    proxygraphics--;
    dwg_dynapi_header_set_value (dwg, "PROXYGRAPHICS", &proxygraphics, 0);

  }
  {
    BITCODE_BS measurement;
    if (dwg_dynapi_header_value (dwg, "MEASUREMENT", &measurement, NULL)
        && measurement == dwg->header_vars.MEASUREMENT)
      pass ();
    else
      fail ("HEADER.MEASUREMENT [BS] %hu != %hu", dwg->header_vars.MEASUREMENT, measurement);
    measurement++;
    if (dwg_dynapi_header_set_value (dwg, "MEASUREMENT", &measurement, 0)
        && measurement == dwg->header_vars.MEASUREMENT)
      pass ();
    else
      fail ("HEADER.MEASUREMENT [BS] set+1 %hu != %hu",
            dwg->header_vars.MEASUREMENT, measurement);
    measurement--;
    dwg_dynapi_header_set_value (dwg, "MEASUREMENT", &measurement, 0);

  }
  {
    BITCODE_BS dragmode;
    if (dwg_dynapi_header_value (dwg, "DRAGMODE", &dragmode, NULL)
        && dragmode == dwg->header_vars.DRAGMODE)
      pass ();
    else
      fail ("HEADER.DRAGMODE [BS] %hu != %hu", dwg->header_vars.DRAGMODE, dragmode);
    dragmode++;
    if (dwg_dynapi_header_set_value (dwg, "DRAGMODE", &dragmode, 0)
        && dragmode == dwg->header_vars.DRAGMODE)
      pass ();
    else
      fail ("HEADER.DRAGMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.DRAGMODE, dragmode);
    dragmode--;
    dwg_dynapi_header_set_value (dwg, "DRAGMODE", &dragmode, 0);

  }
  {
    BITCODE_BS treedepth;
    if (dwg_dynapi_header_value (dwg, "TREEDEPTH", &treedepth, NULL)
        && treedepth == dwg->header_vars.TREEDEPTH)
      pass ();
    else
      fail ("HEADER.TREEDEPTH [BS] %hu != %hu", dwg->header_vars.TREEDEPTH, treedepth);
    treedepth++;
    if (dwg_dynapi_header_set_value (dwg, "TREEDEPTH", &treedepth, 0)
        && treedepth == dwg->header_vars.TREEDEPTH)
      pass ();
    else
      fail ("HEADER.TREEDEPTH [BS] set+1 %hu != %hu",
            dwg->header_vars.TREEDEPTH, treedepth);
    treedepth--;
    dwg_dynapi_header_set_value (dwg, "TREEDEPTH", &treedepth, 0);

  }
  {
    BITCODE_BS lunits;
    if (dwg_dynapi_header_value (dwg, "LUNITS", &lunits, NULL)
        && lunits == dwg->header_vars.LUNITS)
      pass ();
    else
      fail ("HEADER.LUNITS [BS] %hu != %hu", dwg->header_vars.LUNITS, lunits);
    lunits++;
    if (dwg_dynapi_header_set_value (dwg, "LUNITS", &lunits, 0)
        && lunits == dwg->header_vars.LUNITS)
      pass ();
    else
      fail ("HEADER.LUNITS [BS] set+1 %hu != %hu",
            dwg->header_vars.LUNITS, lunits);
    lunits--;
    dwg_dynapi_header_set_value (dwg, "LUNITS", &lunits, 0);

  }
  {
    BITCODE_BS luprec;
    if (dwg_dynapi_header_value (dwg, "LUPREC", &luprec, NULL)
        && luprec == dwg->header_vars.LUPREC)
      pass ();
    else
      fail ("HEADER.LUPREC [BS] %hu != %hu", dwg->header_vars.LUPREC, luprec);
    luprec++;
    if (dwg_dynapi_header_set_value (dwg, "LUPREC", &luprec, 0)
        && luprec == dwg->header_vars.LUPREC)
      pass ();
    else
      fail ("HEADER.LUPREC [BS] set+1 %hu != %hu",
            dwg->header_vars.LUPREC, luprec);
    luprec--;
    dwg_dynapi_header_set_value (dwg, "LUPREC", &luprec, 0);

  }
  {
    BITCODE_BS aunits;
    if (dwg_dynapi_header_value (dwg, "AUNITS", &aunits, NULL)
        && aunits == dwg->header_vars.AUNITS)
      pass ();
    else
      fail ("HEADER.AUNITS [BS] %hu != %hu", dwg->header_vars.AUNITS, aunits);
    aunits++;
    if (dwg_dynapi_header_set_value (dwg, "AUNITS", &aunits, 0)
        && aunits == dwg->header_vars.AUNITS)
      pass ();
    else
      fail ("HEADER.AUNITS [BS] set+1 %hu != %hu",
            dwg->header_vars.AUNITS, aunits);
    aunits--;
    dwg_dynapi_header_set_value (dwg, "AUNITS", &aunits, 0);

  }
  {
    BITCODE_BS auprec;
    if (dwg_dynapi_header_value (dwg, "AUPREC", &auprec, NULL)
        && auprec == dwg->header_vars.AUPREC)
      pass ();
    else
      fail ("HEADER.AUPREC [BS] %hu != %hu", dwg->header_vars.AUPREC, auprec);
    auprec++;
    if (dwg_dynapi_header_set_value (dwg, "AUPREC", &auprec, 0)
        && auprec == dwg->header_vars.AUPREC)
      pass ();
    else
      fail ("HEADER.AUPREC [BS] set+1 %hu != %hu",
            dwg->header_vars.AUPREC, auprec);
    auprec--;
    dwg_dynapi_header_set_value (dwg, "AUPREC", &auprec, 0);

  }
  {
    BITCODE_BS osmode;
    if (dwg_dynapi_header_value (dwg, "OSMODE", &osmode, NULL)
        && osmode == dwg->header_vars.OSMODE)
      pass ();
    else
      fail ("HEADER.OSMODE [BS] %hu != %hu", dwg->header_vars.OSMODE, osmode);
    osmode++;
    if (dwg_dynapi_header_set_value (dwg, "OSMODE", &osmode, 0)
        && osmode == dwg->header_vars.OSMODE)
      pass ();
    else
      fail ("HEADER.OSMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.OSMODE, osmode);
    osmode--;
    dwg_dynapi_header_set_value (dwg, "OSMODE", &osmode, 0);

  }
  {
    BITCODE_BS attmode;
    if (dwg_dynapi_header_value (dwg, "ATTMODE", &attmode, NULL)
        && attmode == dwg->header_vars.ATTMODE)
      pass ();
    else
      fail ("HEADER.ATTMODE [BS] %hu != %hu", dwg->header_vars.ATTMODE, attmode);
    attmode++;
    if (dwg_dynapi_header_set_value (dwg, "ATTMODE", &attmode, 0)
        && attmode == dwg->header_vars.ATTMODE)
      pass ();
    else
      fail ("HEADER.ATTMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.ATTMODE, attmode);
    attmode--;
    dwg_dynapi_header_set_value (dwg, "ATTMODE", &attmode, 0);

  }
  {
    BITCODE_BS coords;
    if (dwg_dynapi_header_value (dwg, "COORDS", &coords, NULL)
        && coords == dwg->header_vars.COORDS)
      pass ();
    else
      fail ("HEADER.COORDS [BS] %hu != %hu", dwg->header_vars.COORDS, coords);
    coords++;
    if (dwg_dynapi_header_set_value (dwg, "COORDS", &coords, 0)
        && coords == dwg->header_vars.COORDS)
      pass ();
    else
      fail ("HEADER.COORDS [BS] set+1 %hu != %hu",
            dwg->header_vars.COORDS, coords);
    coords--;
    dwg_dynapi_header_set_value (dwg, "COORDS", &coords, 0);

  }
  {
    BITCODE_BS pdmode;
    if (dwg_dynapi_header_value (dwg, "PDMODE", &pdmode, NULL)
        && pdmode == dwg->header_vars.PDMODE)
      pass ();
    else
      fail ("HEADER.PDMODE [BS] %hu != %hu", dwg->header_vars.PDMODE, pdmode);
    pdmode++;
    if (dwg_dynapi_header_set_value (dwg, "PDMODE", &pdmode, 0)
        && pdmode == dwg->header_vars.PDMODE)
      pass ();
    else
      fail ("HEADER.PDMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.PDMODE, pdmode);
    pdmode--;
    dwg_dynapi_header_set_value (dwg, "PDMODE", &pdmode, 0);

  }
  {
    BITCODE_BS pickstyle;
    if (dwg_dynapi_header_value (dwg, "PICKSTYLE", &pickstyle, NULL)
        && pickstyle == dwg->header_vars.PICKSTYLE)
      pass ();
    else
      fail ("HEADER.PICKSTYLE [BS] %hu != %hu", dwg->header_vars.PICKSTYLE, pickstyle);
    pickstyle++;
    if (dwg_dynapi_header_set_value (dwg, "PICKSTYLE", &pickstyle, 0)
        && pickstyle == dwg->header_vars.PICKSTYLE)
      pass ();
    else
      fail ("HEADER.PICKSTYLE [BS] set+1 %hu != %hu",
            dwg->header_vars.PICKSTYLE, pickstyle);
    pickstyle--;
    dwg_dynapi_header_set_value (dwg, "PICKSTYLE", &pickstyle, 0);

  }
  {
    BITCODE_BL unknown_12;
    if (dwg_dynapi_header_value (dwg, "unknown_12", &unknown_12, NULL)
        && unknown_12 == dwg->header_vars.unknown_12)
      pass ();
    else
      fail ("HEADER.unknown_12 [BL] %u != %u", dwg->header_vars.unknown_12, unknown_12);
    unknown_12++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_12", &unknown_12, 0)
        && unknown_12 == dwg->header_vars.unknown_12)
      pass ();
    else
      fail ("HEADER.unknown_12 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_12, unknown_12);
    unknown_12--;
    dwg_dynapi_header_set_value (dwg, "unknown_12", &unknown_12, 0);

  }
  {
    BITCODE_BL unknown_13;
    if (dwg_dynapi_header_value (dwg, "unknown_13", &unknown_13, NULL)
        && unknown_13 == dwg->header_vars.unknown_13)
      pass ();
    else
      fail ("HEADER.unknown_13 [BL] %u != %u", dwg->header_vars.unknown_13, unknown_13);
    unknown_13++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_13", &unknown_13, 0)
        && unknown_13 == dwg->header_vars.unknown_13)
      pass ();
    else
      fail ("HEADER.unknown_13 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_13, unknown_13);
    unknown_13--;
    dwg_dynapi_header_set_value (dwg, "unknown_13", &unknown_13, 0);

  }
  {
    BITCODE_BL unknown_14;
    if (dwg_dynapi_header_value (dwg, "unknown_14", &unknown_14, NULL)
        && unknown_14 == dwg->header_vars.unknown_14)
      pass ();
    else
      fail ("HEADER.unknown_14 [BL] %u != %u", dwg->header_vars.unknown_14, unknown_14);
    unknown_14++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_14", &unknown_14, 0)
        && unknown_14 == dwg->header_vars.unknown_14)
      pass ();
    else
      fail ("HEADER.unknown_14 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_14, unknown_14);
    unknown_14--;
    dwg_dynapi_header_set_value (dwg, "unknown_14", &unknown_14, 0);

  }
  {
    BITCODE_BS useri1;
    if (dwg_dynapi_header_value (dwg, "USERI1", &useri1, NULL)
        && useri1 == dwg->header_vars.USERI1)
      pass ();
    else
      fail ("HEADER.USERI1 [BS] %hu != %hu", dwg->header_vars.USERI1, useri1);
    useri1++;
    if (dwg_dynapi_header_set_value (dwg, "USERI1", &useri1, 0)
        && useri1 == dwg->header_vars.USERI1)
      pass ();
    else
      fail ("HEADER.USERI1 [BS] set+1 %hu != %hu",
            dwg->header_vars.USERI1, useri1);
    useri1--;
    dwg_dynapi_header_set_value (dwg, "USERI1", &useri1, 0);

  }
  {
    BITCODE_BS useri2;
    if (dwg_dynapi_header_value (dwg, "USERI2", &useri2, NULL)
        && useri2 == dwg->header_vars.USERI2)
      pass ();
    else
      fail ("HEADER.USERI2 [BS] %hu != %hu", dwg->header_vars.USERI2, useri2);
    useri2++;
    if (dwg_dynapi_header_set_value (dwg, "USERI2", &useri2, 0)
        && useri2 == dwg->header_vars.USERI2)
      pass ();
    else
      fail ("HEADER.USERI2 [BS] set+1 %hu != %hu",
            dwg->header_vars.USERI2, useri2);
    useri2--;
    dwg_dynapi_header_set_value (dwg, "USERI2", &useri2, 0);

  }
  {
    BITCODE_BS useri3;
    if (dwg_dynapi_header_value (dwg, "USERI3", &useri3, NULL)
        && useri3 == dwg->header_vars.USERI3)
      pass ();
    else
      fail ("HEADER.USERI3 [BS] %hu != %hu", dwg->header_vars.USERI3, useri3);
    useri3++;
    if (dwg_dynapi_header_set_value (dwg, "USERI3", &useri3, 0)
        && useri3 == dwg->header_vars.USERI3)
      pass ();
    else
      fail ("HEADER.USERI3 [BS] set+1 %hu != %hu",
            dwg->header_vars.USERI3, useri3);
    useri3--;
    dwg_dynapi_header_set_value (dwg, "USERI3", &useri3, 0);

  }
  {
    BITCODE_BS useri4;
    if (dwg_dynapi_header_value (dwg, "USERI4", &useri4, NULL)
        && useri4 == dwg->header_vars.USERI4)
      pass ();
    else
      fail ("HEADER.USERI4 [BS] %hu != %hu", dwg->header_vars.USERI4, useri4);
    useri4++;
    if (dwg_dynapi_header_set_value (dwg, "USERI4", &useri4, 0)
        && useri4 == dwg->header_vars.USERI4)
      pass ();
    else
      fail ("HEADER.USERI4 [BS] set+1 %hu != %hu",
            dwg->header_vars.USERI4, useri4);
    useri4--;
    dwg_dynapi_header_set_value (dwg, "USERI4", &useri4, 0);

  }
  {
    BITCODE_BS useri5;
    if (dwg_dynapi_header_value (dwg, "USERI5", &useri5, NULL)
        && useri5 == dwg->header_vars.USERI5)
      pass ();
    else
      fail ("HEADER.USERI5 [BS] %hu != %hu", dwg->header_vars.USERI5, useri5);
    useri5++;
    if (dwg_dynapi_header_set_value (dwg, "USERI5", &useri5, 0)
        && useri5 == dwg->header_vars.USERI5)
      pass ();
    else
      fail ("HEADER.USERI5 [BS] set+1 %hu != %hu",
            dwg->header_vars.USERI5, useri5);
    useri5--;
    dwg_dynapi_header_set_value (dwg, "USERI5", &useri5, 0);

  }
  {
    BITCODE_BS splinesegs;
    if (dwg_dynapi_header_value (dwg, "SPLINESEGS", &splinesegs, NULL)
        && splinesegs == dwg->header_vars.SPLINESEGS)
      pass ();
    else
      fail ("HEADER.SPLINESEGS [BS] %hu != %hu", dwg->header_vars.SPLINESEGS, splinesegs);
    splinesegs++;
    if (dwg_dynapi_header_set_value (dwg, "SPLINESEGS", &splinesegs, 0)
        && splinesegs == dwg->header_vars.SPLINESEGS)
      pass ();
    else
      fail ("HEADER.SPLINESEGS [BS] set+1 %hu != %hu",
            dwg->header_vars.SPLINESEGS, splinesegs);
    splinesegs--;
    dwg_dynapi_header_set_value (dwg, "SPLINESEGS", &splinesegs, 0);

  }
  {
    BITCODE_BS surfu;
    if (dwg_dynapi_header_value (dwg, "SURFU", &surfu, NULL)
        && surfu == dwg->header_vars.SURFU)
      pass ();
    else
      fail ("HEADER.SURFU [BS] %hu != %hu", dwg->header_vars.SURFU, surfu);
    surfu++;
    if (dwg_dynapi_header_set_value (dwg, "SURFU", &surfu, 0)
        && surfu == dwg->header_vars.SURFU)
      pass ();
    else
      fail ("HEADER.SURFU [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFU, surfu);
    surfu--;
    dwg_dynapi_header_set_value (dwg, "SURFU", &surfu, 0);

  }
  {
    BITCODE_BS surfv;
    if (dwg_dynapi_header_value (dwg, "SURFV", &surfv, NULL)
        && surfv == dwg->header_vars.SURFV)
      pass ();
    else
      fail ("HEADER.SURFV [BS] %hu != %hu", dwg->header_vars.SURFV, surfv);
    surfv++;
    if (dwg_dynapi_header_set_value (dwg, "SURFV", &surfv, 0)
        && surfv == dwg->header_vars.SURFV)
      pass ();
    else
      fail ("HEADER.SURFV [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFV, surfv);
    surfv--;
    dwg_dynapi_header_set_value (dwg, "SURFV", &surfv, 0);

  }
  {
    BITCODE_BS surftype;
    if (dwg_dynapi_header_value (dwg, "SURFTYPE", &surftype, NULL)
        && surftype == dwg->header_vars.SURFTYPE)
      pass ();
    else
      fail ("HEADER.SURFTYPE [BS] %hu != %hu", dwg->header_vars.SURFTYPE, surftype);
    surftype++;
    if (dwg_dynapi_header_set_value (dwg, "SURFTYPE", &surftype, 0)
        && surftype == dwg->header_vars.SURFTYPE)
      pass ();
    else
      fail ("HEADER.SURFTYPE [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFTYPE, surftype);
    surftype--;
    dwg_dynapi_header_set_value (dwg, "SURFTYPE", &surftype, 0);

  }
  {
    BITCODE_BS surftab1;
    if (dwg_dynapi_header_value (dwg, "SURFTAB1", &surftab1, NULL)
        && surftab1 == dwg->header_vars.SURFTAB1)
      pass ();
    else
      fail ("HEADER.SURFTAB1 [BS] %hu != %hu", dwg->header_vars.SURFTAB1, surftab1);
    surftab1++;
    if (dwg_dynapi_header_set_value (dwg, "SURFTAB1", &surftab1, 0)
        && surftab1 == dwg->header_vars.SURFTAB1)
      pass ();
    else
      fail ("HEADER.SURFTAB1 [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFTAB1, surftab1);
    surftab1--;
    dwg_dynapi_header_set_value (dwg, "SURFTAB1", &surftab1, 0);

  }
  {
    BITCODE_BS surftab2;
    if (dwg_dynapi_header_value (dwg, "SURFTAB2", &surftab2, NULL)
        && surftab2 == dwg->header_vars.SURFTAB2)
      pass ();
    else
      fail ("HEADER.SURFTAB2 [BS] %hu != %hu", dwg->header_vars.SURFTAB2, surftab2);
    surftab2++;
    if (dwg_dynapi_header_set_value (dwg, "SURFTAB2", &surftab2, 0)
        && surftab2 == dwg->header_vars.SURFTAB2)
      pass ();
    else
      fail ("HEADER.SURFTAB2 [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFTAB2, surftab2);
    surftab2--;
    dwg_dynapi_header_set_value (dwg, "SURFTAB2", &surftab2, 0);

  }
  {
    BITCODE_BS splinetype;
    if (dwg_dynapi_header_value (dwg, "SPLINETYPE", &splinetype, NULL)
        && splinetype == dwg->header_vars.SPLINETYPE)
      pass ();
    else
      fail ("HEADER.SPLINETYPE [BS] %hu != %hu", dwg->header_vars.SPLINETYPE, splinetype);
    splinetype++;
    if (dwg_dynapi_header_set_value (dwg, "SPLINETYPE", &splinetype, 0)
        && splinetype == dwg->header_vars.SPLINETYPE)
      pass ();
    else
      fail ("HEADER.SPLINETYPE [BS] set+1 %hu != %hu",
            dwg->header_vars.SPLINETYPE, splinetype);
    splinetype--;
    dwg_dynapi_header_set_value (dwg, "SPLINETYPE", &splinetype, 0);

  }
  {
    BITCODE_BS shadedge;
    if (dwg_dynapi_header_value (dwg, "SHADEDGE", &shadedge, NULL)
        && shadedge == dwg->header_vars.SHADEDGE)
      pass ();
    else
      fail ("HEADER.SHADEDGE [BS] %hu != %hu", dwg->header_vars.SHADEDGE, shadedge);
    shadedge++;
    if (dwg_dynapi_header_set_value (dwg, "SHADEDGE", &shadedge, 0)
        && shadedge == dwg->header_vars.SHADEDGE)
      pass ();
    else
      fail ("HEADER.SHADEDGE [BS] set+1 %hu != %hu",
            dwg->header_vars.SHADEDGE, shadedge);
    shadedge--;
    dwg_dynapi_header_set_value (dwg, "SHADEDGE", &shadedge, 0);

  }
  {
    BITCODE_BS shadedif;
    if (dwg_dynapi_header_value (dwg, "SHADEDIF", &shadedif, NULL)
        && shadedif == dwg->header_vars.SHADEDIF)
      pass ();
    else
      fail ("HEADER.SHADEDIF [BS] %hu != %hu", dwg->header_vars.SHADEDIF, shadedif);
    shadedif++;
    if (dwg_dynapi_header_set_value (dwg, "SHADEDIF", &shadedif, 0)
        && shadedif == dwg->header_vars.SHADEDIF)
      pass ();
    else
      fail ("HEADER.SHADEDIF [BS] set+1 %hu != %hu",
            dwg->header_vars.SHADEDIF, shadedif);
    shadedif--;
    dwg_dynapi_header_set_value (dwg, "SHADEDIF", &shadedif, 0);

  }
  {
    BITCODE_BS unitmode;
    if (dwg_dynapi_header_value (dwg, "UNITMODE", &unitmode, NULL)
        && unitmode == dwg->header_vars.UNITMODE)
      pass ();
    else
      fail ("HEADER.UNITMODE [BS] %hu != %hu", dwg->header_vars.UNITMODE, unitmode);
    unitmode++;
    if (dwg_dynapi_header_set_value (dwg, "UNITMODE", &unitmode, 0)
        && unitmode == dwg->header_vars.UNITMODE)
      pass ();
    else
      fail ("HEADER.UNITMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.UNITMODE, unitmode);
    unitmode--;
    dwg_dynapi_header_set_value (dwg, "UNITMODE", &unitmode, 0);

  }
  {
    BITCODE_BS maxactvp;
    if (dwg_dynapi_header_value (dwg, "MAXACTVP", &maxactvp, NULL)
        && maxactvp == dwg->header_vars.MAXACTVP)
      pass ();
    else
      fail ("HEADER.MAXACTVP [BS] %hu != %hu", dwg->header_vars.MAXACTVP, maxactvp);
    maxactvp++;
    if (dwg_dynapi_header_set_value (dwg, "MAXACTVP", &maxactvp, 0)
        && maxactvp == dwg->header_vars.MAXACTVP)
      pass ();
    else
      fail ("HEADER.MAXACTVP [BS] set+1 %hu != %hu",
            dwg->header_vars.MAXACTVP, maxactvp);
    maxactvp--;
    dwg_dynapi_header_set_value (dwg, "MAXACTVP", &maxactvp, 0);

  }
  {
    BITCODE_BS isolines;
    if (dwg_dynapi_header_value (dwg, "ISOLINES", &isolines, NULL)
        && isolines == dwg->header_vars.ISOLINES)
      pass ();
    else
      fail ("HEADER.ISOLINES [BS] %hu != %hu", dwg->header_vars.ISOLINES, isolines);
    isolines++;
    if (dwg_dynapi_header_set_value (dwg, "ISOLINES", &isolines, 0)
        && isolines == dwg->header_vars.ISOLINES)
      pass ();
    else
      fail ("HEADER.ISOLINES [BS] set+1 %hu != %hu",
            dwg->header_vars.ISOLINES, isolines);
    isolines--;
    dwg_dynapi_header_set_value (dwg, "ISOLINES", &isolines, 0);

  }
  {
    BITCODE_BS cmljust;
    if (dwg_dynapi_header_value (dwg, "CMLJUST", &cmljust, NULL)
        && cmljust == dwg->header_vars.CMLJUST)
      pass ();
    else
      fail ("HEADER.CMLJUST [BS] %hu != %hu", dwg->header_vars.CMLJUST, cmljust);
    cmljust++;
    if (dwg_dynapi_header_set_value (dwg, "CMLJUST", &cmljust, 0)
        && cmljust == dwg->header_vars.CMLJUST)
      pass ();
    else
      fail ("HEADER.CMLJUST [BS] set+1 %hu != %hu",
            dwg->header_vars.CMLJUST, cmljust);
    cmljust--;
    dwg_dynapi_header_set_value (dwg, "CMLJUST", &cmljust, 0);

  }
  {
    BITCODE_BS textqlty;
    if (dwg_dynapi_header_value (dwg, "TEXTQLTY", &textqlty, NULL)
        && textqlty == dwg->header_vars.TEXTQLTY)
      pass ();
    else
      fail ("HEADER.TEXTQLTY [BS] %hu != %hu", dwg->header_vars.TEXTQLTY, textqlty);
    textqlty++;
    if (dwg_dynapi_header_set_value (dwg, "TEXTQLTY", &textqlty, 0)
        && textqlty == dwg->header_vars.TEXTQLTY)
      pass ();
    else
      fail ("HEADER.TEXTQLTY [BS] set+1 %hu != %hu",
            dwg->header_vars.TEXTQLTY, textqlty);
    textqlty--;
    dwg_dynapi_header_set_value (dwg, "TEXTQLTY", &textqlty, 0);

  }
  {
    BITCODE_BL unknown_14b;
    if (dwg_dynapi_header_value (dwg, "unknown_14b", &unknown_14b, NULL)
        && unknown_14b == dwg->header_vars.unknown_14b)
      pass ();
    else
      fail ("HEADER.unknown_14b [BL] %u != %u", dwg->header_vars.unknown_14b, unknown_14b);
    unknown_14b++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_14b", &unknown_14b, 0)
        && unknown_14b == dwg->header_vars.unknown_14b)
      pass ();
    else
      fail ("HEADER.unknown_14b [BL] set+1 %u != %u",
            dwg->header_vars.unknown_14b, unknown_14b);
    unknown_14b--;
    dwg_dynapi_header_set_value (dwg, "unknown_14b", &unknown_14b, 0);

  }
  {
    BITCODE_BD ltscale;
    if (dwg_dynapi_header_value (dwg, "LTSCALE", &ltscale, NULL)
        && ltscale == dwg->header_vars.LTSCALE)
      pass ();
    else
      fail ("HEADER.LTSCALE [BD] %g != %g", dwg->header_vars.LTSCALE, ltscale);
    ltscale++;
    if (dwg_dynapi_header_set_value (dwg, "LTSCALE", &ltscale, 0)
        && ltscale == dwg->header_vars.LTSCALE)
      pass ();
    else
      fail ("HEADER.LTSCALE [BD] set+1 %g != %g",
            dwg->header_vars.LTSCALE, ltscale);
    ltscale--;
    dwg_dynapi_header_set_value (dwg, "LTSCALE", &ltscale, 0);

  }
  {
    BITCODE_BD textsize;
    if (dwg_dynapi_header_value (dwg, "TEXTSIZE", &textsize, NULL)
        && textsize == dwg->header_vars.TEXTSIZE)
      pass ();
    else
      fail ("HEADER.TEXTSIZE [BD] %g != %g", dwg->header_vars.TEXTSIZE, textsize);
    textsize++;
    if (dwg_dynapi_header_set_value (dwg, "TEXTSIZE", &textsize, 0)
        && textsize == dwg->header_vars.TEXTSIZE)
      pass ();
    else
      fail ("HEADER.TEXTSIZE [BD] set+1 %g != %g",
            dwg->header_vars.TEXTSIZE, textsize);
    textsize--;
    dwg_dynapi_header_set_value (dwg, "TEXTSIZE", &textsize, 0);

  }
  {
    BITCODE_BD tracewid;
    if (dwg_dynapi_header_value (dwg, "TRACEWID", &tracewid, NULL)
        && tracewid == dwg->header_vars.TRACEWID)
      pass ();
    else
      fail ("HEADER.TRACEWID [BD] %g != %g", dwg->header_vars.TRACEWID, tracewid);
    tracewid++;
    if (dwg_dynapi_header_set_value (dwg, "TRACEWID", &tracewid, 0)
        && tracewid == dwg->header_vars.TRACEWID)
      pass ();
    else
      fail ("HEADER.TRACEWID [BD] set+1 %g != %g",
            dwg->header_vars.TRACEWID, tracewid);
    tracewid--;
    dwg_dynapi_header_set_value (dwg, "TRACEWID", &tracewid, 0);

  }
  {
    BITCODE_BD sketchinc;
    if (dwg_dynapi_header_value (dwg, "SKETCHINC", &sketchinc, NULL)
        && sketchinc == dwg->header_vars.SKETCHINC)
      pass ();
    else
      fail ("HEADER.SKETCHINC [BD] %g != %g", dwg->header_vars.SKETCHINC, sketchinc);
    sketchinc++;
    if (dwg_dynapi_header_set_value (dwg, "SKETCHINC", &sketchinc, 0)
        && sketchinc == dwg->header_vars.SKETCHINC)
      pass ();
    else
      fail ("HEADER.SKETCHINC [BD] set+1 %g != %g",
            dwg->header_vars.SKETCHINC, sketchinc);
    sketchinc--;
    dwg_dynapi_header_set_value (dwg, "SKETCHINC", &sketchinc, 0);

  }
  {
    BITCODE_BD filletrad;
    if (dwg_dynapi_header_value (dwg, "FILLETRAD", &filletrad, NULL)
        && filletrad == dwg->header_vars.FILLETRAD)
      pass ();
    else
      fail ("HEADER.FILLETRAD [BD] %g != %g", dwg->header_vars.FILLETRAD, filletrad);
    filletrad++;
    if (dwg_dynapi_header_set_value (dwg, "FILLETRAD", &filletrad, 0)
        && filletrad == dwg->header_vars.FILLETRAD)
      pass ();
    else
      fail ("HEADER.FILLETRAD [BD] set+1 %g != %g",
            dwg->header_vars.FILLETRAD, filletrad);
    filletrad--;
    dwg_dynapi_header_set_value (dwg, "FILLETRAD", &filletrad, 0);

  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_header_value (dwg, "THICKNESS", &thickness, NULL)
        && thickness == dwg->header_vars.THICKNESS)
      pass ();
    else
      fail ("HEADER.THICKNESS [BD] %g != %g", dwg->header_vars.THICKNESS, thickness);
    thickness++;
    if (dwg_dynapi_header_set_value (dwg, "THICKNESS", &thickness, 0)
        && thickness == dwg->header_vars.THICKNESS)
      pass ();
    else
      fail ("HEADER.THICKNESS [BD] set+1 %g != %g",
            dwg->header_vars.THICKNESS, thickness);
    thickness--;
    dwg_dynapi_header_set_value (dwg, "THICKNESS", &thickness, 0);

  }
  {
    BITCODE_BD angbase;
    if (dwg_dynapi_header_value (dwg, "ANGBASE", &angbase, NULL)
        && angbase == dwg->header_vars.ANGBASE)
      pass ();
    else
      fail ("HEADER.ANGBASE [BD] %g != %g", dwg->header_vars.ANGBASE, angbase);
    angbase++;
    if (dwg_dynapi_header_set_value (dwg, "ANGBASE", &angbase, 0)
        && angbase == dwg->header_vars.ANGBASE)
      pass ();
    else
      fail ("HEADER.ANGBASE [BD] set+1 %g != %g",
            dwg->header_vars.ANGBASE, angbase);
    angbase--;
    dwg_dynapi_header_set_value (dwg, "ANGBASE", &angbase, 0);

  }
  {
    BITCODE_BD pdsize;
    if (dwg_dynapi_header_value (dwg, "PDSIZE", &pdsize, NULL)
        && pdsize == dwg->header_vars.PDSIZE)
      pass ();
    else
      fail ("HEADER.PDSIZE [BD] %g != %g", dwg->header_vars.PDSIZE, pdsize);
    pdsize++;
    if (dwg_dynapi_header_set_value (dwg, "PDSIZE", &pdsize, 0)
        && pdsize == dwg->header_vars.PDSIZE)
      pass ();
    else
      fail ("HEADER.PDSIZE [BD] set+1 %g != %g",
            dwg->header_vars.PDSIZE, pdsize);
    pdsize--;
    dwg_dynapi_header_set_value (dwg, "PDSIZE", &pdsize, 0);

  }
  {
    BITCODE_BD plinewid;
    if (dwg_dynapi_header_value (dwg, "PLINEWID", &plinewid, NULL)
        && plinewid == dwg->header_vars.PLINEWID)
      pass ();
    else
      fail ("HEADER.PLINEWID [BD] %g != %g", dwg->header_vars.PLINEWID, plinewid);
    plinewid++;
    if (dwg_dynapi_header_set_value (dwg, "PLINEWID", &plinewid, 0)
        && plinewid == dwg->header_vars.PLINEWID)
      pass ();
    else
      fail ("HEADER.PLINEWID [BD] set+1 %g != %g",
            dwg->header_vars.PLINEWID, plinewid);
    plinewid--;
    dwg_dynapi_header_set_value (dwg, "PLINEWID", &plinewid, 0);

  }
  {
    BITCODE_BD userr1;
    if (dwg_dynapi_header_value (dwg, "USERR1", &userr1, NULL)
        && userr1 == dwg->header_vars.USERR1)
      pass ();
    else
      fail ("HEADER.USERR1 [BD] %g != %g", dwg->header_vars.USERR1, userr1);
    userr1++;
    if (dwg_dynapi_header_set_value (dwg, "USERR1", &userr1, 0)
        && userr1 == dwg->header_vars.USERR1)
      pass ();
    else
      fail ("HEADER.USERR1 [BD] set+1 %g != %g",
            dwg->header_vars.USERR1, userr1);
    userr1--;
    dwg_dynapi_header_set_value (dwg, "USERR1", &userr1, 0);

  }
  {
    BITCODE_BD userr2;
    if (dwg_dynapi_header_value (dwg, "USERR2", &userr2, NULL)
        && userr2 == dwg->header_vars.USERR2)
      pass ();
    else
      fail ("HEADER.USERR2 [BD] %g != %g", dwg->header_vars.USERR2, userr2);
    userr2++;
    if (dwg_dynapi_header_set_value (dwg, "USERR2", &userr2, 0)
        && userr2 == dwg->header_vars.USERR2)
      pass ();
    else
      fail ("HEADER.USERR2 [BD] set+1 %g != %g",
            dwg->header_vars.USERR2, userr2);
    userr2--;
    dwg_dynapi_header_set_value (dwg, "USERR2", &userr2, 0);

  }
  {
    BITCODE_BD userr3;
    if (dwg_dynapi_header_value (dwg, "USERR3", &userr3, NULL)
        && userr3 == dwg->header_vars.USERR3)
      pass ();
    else
      fail ("HEADER.USERR3 [BD] %g != %g", dwg->header_vars.USERR3, userr3);
    userr3++;
    if (dwg_dynapi_header_set_value (dwg, "USERR3", &userr3, 0)
        && userr3 == dwg->header_vars.USERR3)
      pass ();
    else
      fail ("HEADER.USERR3 [BD] set+1 %g != %g",
            dwg->header_vars.USERR3, userr3);
    userr3--;
    dwg_dynapi_header_set_value (dwg, "USERR3", &userr3, 0);

  }
  {
    BITCODE_BD userr4;
    if (dwg_dynapi_header_value (dwg, "USERR4", &userr4, NULL)
        && userr4 == dwg->header_vars.USERR4)
      pass ();
    else
      fail ("HEADER.USERR4 [BD] %g != %g", dwg->header_vars.USERR4, userr4);
    userr4++;
    if (dwg_dynapi_header_set_value (dwg, "USERR4", &userr4, 0)
        && userr4 == dwg->header_vars.USERR4)
      pass ();
    else
      fail ("HEADER.USERR4 [BD] set+1 %g != %g",
            dwg->header_vars.USERR4, userr4);
    userr4--;
    dwg_dynapi_header_set_value (dwg, "USERR4", &userr4, 0);

  }
  {
    BITCODE_BD userr5;
    if (dwg_dynapi_header_value (dwg, "USERR5", &userr5, NULL)
        && userr5 == dwg->header_vars.USERR5)
      pass ();
    else
      fail ("HEADER.USERR5 [BD] %g != %g", dwg->header_vars.USERR5, userr5);
    userr5++;
    if (dwg_dynapi_header_set_value (dwg, "USERR5", &userr5, 0)
        && userr5 == dwg->header_vars.USERR5)
      pass ();
    else
      fail ("HEADER.USERR5 [BD] set+1 %g != %g",
            dwg->header_vars.USERR5, userr5);
    userr5--;
    dwg_dynapi_header_set_value (dwg, "USERR5", &userr5, 0);

  }
  {
    BITCODE_BD chamfera;
    if (dwg_dynapi_header_value (dwg, "CHAMFERA", &chamfera, NULL)
        && chamfera == dwg->header_vars.CHAMFERA)
      pass ();
    else
      fail ("HEADER.CHAMFERA [BD] %g != %g", dwg->header_vars.CHAMFERA, chamfera);
    chamfera++;
    if (dwg_dynapi_header_set_value (dwg, "CHAMFERA", &chamfera, 0)
        && chamfera == dwg->header_vars.CHAMFERA)
      pass ();
    else
      fail ("HEADER.CHAMFERA [BD] set+1 %g != %g",
            dwg->header_vars.CHAMFERA, chamfera);
    chamfera--;
    dwg_dynapi_header_set_value (dwg, "CHAMFERA", &chamfera, 0);

  }
  {
    BITCODE_BD chamferb;
    if (dwg_dynapi_header_value (dwg, "CHAMFERB", &chamferb, NULL)
        && chamferb == dwg->header_vars.CHAMFERB)
      pass ();
    else
      fail ("HEADER.CHAMFERB [BD] %g != %g", dwg->header_vars.CHAMFERB, chamferb);
    chamferb++;
    if (dwg_dynapi_header_set_value (dwg, "CHAMFERB", &chamferb, 0)
        && chamferb == dwg->header_vars.CHAMFERB)
      pass ();
    else
      fail ("HEADER.CHAMFERB [BD] set+1 %g != %g",
            dwg->header_vars.CHAMFERB, chamferb);
    chamferb--;
    dwg_dynapi_header_set_value (dwg, "CHAMFERB", &chamferb, 0);

  }
  {
    BITCODE_BD chamferc;
    if (dwg_dynapi_header_value (dwg, "CHAMFERC", &chamferc, NULL)
        && chamferc == dwg->header_vars.CHAMFERC)
      pass ();
    else
      fail ("HEADER.CHAMFERC [BD] %g != %g", dwg->header_vars.CHAMFERC, chamferc);
    chamferc++;
    if (dwg_dynapi_header_set_value (dwg, "CHAMFERC", &chamferc, 0)
        && chamferc == dwg->header_vars.CHAMFERC)
      pass ();
    else
      fail ("HEADER.CHAMFERC [BD] set+1 %g != %g",
            dwg->header_vars.CHAMFERC, chamferc);
    chamferc--;
    dwg_dynapi_header_set_value (dwg, "CHAMFERC", &chamferc, 0);

  }
  {
    BITCODE_BD chamferd;
    if (dwg_dynapi_header_value (dwg, "CHAMFERD", &chamferd, NULL)
        && chamferd == dwg->header_vars.CHAMFERD)
      pass ();
    else
      fail ("HEADER.CHAMFERD [BD] %g != %g", dwg->header_vars.CHAMFERD, chamferd);
    chamferd++;
    if (dwg_dynapi_header_set_value (dwg, "CHAMFERD", &chamferd, 0)
        && chamferd == dwg->header_vars.CHAMFERD)
      pass ();
    else
      fail ("HEADER.CHAMFERD [BD] set+1 %g != %g",
            dwg->header_vars.CHAMFERD, chamferd);
    chamferd--;
    dwg_dynapi_header_set_value (dwg, "CHAMFERD", &chamferd, 0);

  }
  {
    BITCODE_BD facetres;
    if (dwg_dynapi_header_value (dwg, "FACETRES", &facetres, NULL)
        && facetres == dwg->header_vars.FACETRES)
      pass ();
    else
      fail ("HEADER.FACETRES [BD] %g != %g", dwg->header_vars.FACETRES, facetres);
    facetres++;
    if (dwg_dynapi_header_set_value (dwg, "FACETRES", &facetres, 0)
        && facetres == dwg->header_vars.FACETRES)
      pass ();
    else
      fail ("HEADER.FACETRES [BD] set+1 %g != %g",
            dwg->header_vars.FACETRES, facetres);
    facetres--;
    dwg_dynapi_header_set_value (dwg, "FACETRES", &facetres, 0);

  }
  {
    BITCODE_BD cmlscale;
    if (dwg_dynapi_header_value (dwg, "CMLSCALE", &cmlscale, NULL)
        && cmlscale == dwg->header_vars.CMLSCALE)
      pass ();
    else
      fail ("HEADER.CMLSCALE [BD] %g != %g", dwg->header_vars.CMLSCALE, cmlscale);
    cmlscale++;
    if (dwg_dynapi_header_set_value (dwg, "CMLSCALE", &cmlscale, 0)
        && cmlscale == dwg->header_vars.CMLSCALE)
      pass ();
    else
      fail ("HEADER.CMLSCALE [BD] set+1 %g != %g",
            dwg->header_vars.CMLSCALE, cmlscale);
    cmlscale--;
    dwg_dynapi_header_set_value (dwg, "CMLSCALE", &cmlscale, 0);

  }
  {
    BITCODE_BD celtscale;
    if (dwg_dynapi_header_value (dwg, "CELTSCALE", &celtscale, NULL)
        && celtscale == dwg->header_vars.CELTSCALE)
      pass ();
    else
      fail ("HEADER.CELTSCALE [BD] %g != %g", dwg->header_vars.CELTSCALE, celtscale);
    celtscale++;
    if (dwg_dynapi_header_set_value (dwg, "CELTSCALE", &celtscale, 0)
        && celtscale == dwg->header_vars.CELTSCALE)
      pass ();
    else
      fail ("HEADER.CELTSCALE [BD] set+1 %g != %g",
            dwg->header_vars.CELTSCALE, celtscale);
    celtscale--;
    dwg_dynapi_header_set_value (dwg, "CELTSCALE", &celtscale, 0);

  }
  {
    BITCODE_TV menu;
    if (dwg_dynapi_header_value (dwg, "MENU", &menu, NULL)
        && !memcmp (&menu, &dwg->header_vars.MENU, sizeof (dwg->header_vars.MENU))
       )
      pass ();
    else
      fail ("HEADER.MENU [TV]");
  }
  {
    BITCODE_TIMEBLL tdcreate;
    if (dwg_dynapi_header_value (dwg, "TDCREATE", &tdcreate, NULL)
        && !memcmp (&tdcreate, &dwg->header_vars.TDCREATE, sizeof (dwg->header_vars.TDCREATE))
       )
      pass ();
    else
      fail ("HEADER.TDCREATE [TIMEBLL]");
  }
  {
    BITCODE_TIMEBLL tdupdate;
    if (dwg_dynapi_header_value (dwg, "TDUPDATE", &tdupdate, NULL)
        && !memcmp (&tdupdate, &dwg->header_vars.TDUPDATE, sizeof (dwg->header_vars.TDUPDATE))
       )
      pass ();
    else
      fail ("HEADER.TDUPDATE [TIMEBLL]");
  }
  {
    BITCODE_TIMEBLL tducreate;
    if (dwg_dynapi_header_value (dwg, "TDUCREATE", &tducreate, NULL)
        && !memcmp (&tducreate, &dwg->header_vars.TDUCREATE, sizeof (dwg->header_vars.TDUCREATE))
       )
      pass ();
    else
      fail ("HEADER.TDUCREATE [TIMEBLL]");
  }
  {
    BITCODE_TIMEBLL tduupdate;
    if (dwg_dynapi_header_value (dwg, "TDUUPDATE", &tduupdate, NULL)
        && !memcmp (&tduupdate, &dwg->header_vars.TDUUPDATE, sizeof (dwg->header_vars.TDUUPDATE))
       )
      pass ();
    else
      fail ("HEADER.TDUUPDATE [TIMEBLL]");
  }
  {
    BITCODE_BL unknown_15;
    if (dwg_dynapi_header_value (dwg, "unknown_15", &unknown_15, NULL)
        && unknown_15 == dwg->header_vars.unknown_15)
      pass ();
    else
      fail ("HEADER.unknown_15 [BL] %u != %u", dwg->header_vars.unknown_15, unknown_15);
    unknown_15++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_15", &unknown_15, 0)
        && unknown_15 == dwg->header_vars.unknown_15)
      pass ();
    else
      fail ("HEADER.unknown_15 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_15, unknown_15);
    unknown_15--;
    dwg_dynapi_header_set_value (dwg, "unknown_15", &unknown_15, 0);

  }
  {
    BITCODE_BL unknown_16;
    if (dwg_dynapi_header_value (dwg, "unknown_16", &unknown_16, NULL)
        && unknown_16 == dwg->header_vars.unknown_16)
      pass ();
    else
      fail ("HEADER.unknown_16 [BL] %u != %u", dwg->header_vars.unknown_16, unknown_16);
    unknown_16++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_16", &unknown_16, 0)
        && unknown_16 == dwg->header_vars.unknown_16)
      pass ();
    else
      fail ("HEADER.unknown_16 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_16, unknown_16);
    unknown_16--;
    dwg_dynapi_header_set_value (dwg, "unknown_16", &unknown_16, 0);

  }
  {
    BITCODE_BL unknown_17;
    if (dwg_dynapi_header_value (dwg, "unknown_17", &unknown_17, NULL)
        && unknown_17 == dwg->header_vars.unknown_17)
      pass ();
    else
      fail ("HEADER.unknown_17 [BL] %u != %u", dwg->header_vars.unknown_17, unknown_17);
    unknown_17++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_17", &unknown_17, 0)
        && unknown_17 == dwg->header_vars.unknown_17)
      pass ();
    else
      fail ("HEADER.unknown_17 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_17, unknown_17);
    unknown_17--;
    dwg_dynapi_header_set_value (dwg, "unknown_17", &unknown_17, 0);

  }
  {
    BITCODE_TIMEBLL tdindwg;
    if (dwg_dynapi_header_value (dwg, "TDINDWG", &tdindwg, NULL)
        && !memcmp (&tdindwg, &dwg->header_vars.TDINDWG, sizeof (dwg->header_vars.TDINDWG))
       )
      pass ();
    else
      fail ("HEADER.TDINDWG [TIMEBLL]");
  }
  {
    BITCODE_TIMEBLL tdusrtimer;
    if (dwg_dynapi_header_value (dwg, "TDUSRTIMER", &tdusrtimer, NULL)
        && !memcmp (&tdusrtimer, &dwg->header_vars.TDUSRTIMER, sizeof (dwg->header_vars.TDUSRTIMER))
       )
      pass ();
    else
      fail ("HEADER.TDUSRTIMER [TIMEBLL]");
  }
  {
    BITCODE_CMC cecolor;
    if (dwg_dynapi_header_value (dwg, "CECOLOR", &cecolor, NULL)
        && !memcmp (&cecolor, &dwg->header_vars.CECOLOR, sizeof (dwg->header_vars.CECOLOR))
       )
      pass ();
    else
      fail ("HEADER.CECOLOR [CMC]");
  }
  {
    BITCODE_BS handling;
    if (dwg_dynapi_header_value (dwg, "HANDLING", &handling, NULL)
        && handling == dwg->header_vars.HANDLING)
      pass ();
    else
      fail ("HEADER.HANDLING [BS] %hu != %hu", dwg->header_vars.HANDLING, handling);
    handling++;
    if (dwg_dynapi_header_set_value (dwg, "HANDLING", &handling, 0)
        && handling == dwg->header_vars.HANDLING)
      pass ();
    else
      fail ("HEADER.HANDLING [BS] set+1 %hu != %hu",
            dwg->header_vars.HANDLING, handling);
    handling--;
    dwg_dynapi_header_set_value (dwg, "HANDLING", &handling, 0);

  }
  {
    BITCODE_H handseed;
    if (dwg_dynapi_header_value (dwg, "HANDSEED", &handseed, NULL)
        && !memcmp (&handseed, &dwg->header_vars.HANDSEED, sizeof (dwg->header_vars.HANDSEED))
       )
      pass ();
    else
      fail ("HEADER.HANDSEED [H]");
  }
  {
    BITCODE_H clayer;
    if (dwg_dynapi_header_value (dwg, "CLAYER", &clayer, NULL)
        && !memcmp (&clayer, &dwg->header_vars.CLAYER, sizeof (dwg->header_vars.CLAYER))
       )
      pass ();
    else
      fail ("HEADER.CLAYER [H]");
  }
  {
    BITCODE_H textstyle;
    if (dwg_dynapi_header_value (dwg, "TEXTSTYLE", &textstyle, NULL)
        && !memcmp (&textstyle, &dwg->header_vars.TEXTSTYLE, sizeof (dwg->header_vars.TEXTSTYLE))
       )
      pass ();
    else
      fail ("HEADER.TEXTSTYLE [H]");
  }
  {
    BITCODE_H celtype;
    if (dwg_dynapi_header_value (dwg, "CELTYPE", &celtype, NULL)
        && !memcmp (&celtype, &dwg->header_vars.CELTYPE, sizeof (dwg->header_vars.CELTYPE))
       )
      pass ();
    else
      fail ("HEADER.CELTYPE [H]");
  }
  {
    BITCODE_H cmaterial;
    if (dwg_dynapi_header_value (dwg, "CMATERIAL", &cmaterial, NULL)
        && !memcmp (&cmaterial, &dwg->header_vars.CMATERIAL, sizeof (dwg->header_vars.CMATERIAL))
       )
      pass ();
    else
      fail ("HEADER.CMATERIAL [H]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_header_value (dwg, "DIMSTYLE", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dwg->header_vars.DIMSTYLE, sizeof (dwg->header_vars.DIMSTYLE))
       )
      pass ();
    else
      fail ("HEADER.DIMSTYLE [H]");
  }
  {
    BITCODE_H cmlstyle;
    if (dwg_dynapi_header_value (dwg, "CMLSTYLE", &cmlstyle, NULL)
        && !memcmp (&cmlstyle, &dwg->header_vars.CMLSTYLE, sizeof (dwg->header_vars.CMLSTYLE))
       )
      pass ();
    else
      fail ("HEADER.CMLSTYLE [H]");
  }
  {
    BITCODE_BD psvpscale;
    if (dwg_dynapi_header_value (dwg, "PSVPSCALE", &psvpscale, NULL)
        && psvpscale == dwg->header_vars.PSVPSCALE)
      pass ();
    else
      fail ("HEADER.PSVPSCALE [BD] %g != %g", dwg->header_vars.PSVPSCALE, psvpscale);
    psvpscale++;
    if (dwg_dynapi_header_set_value (dwg, "PSVPSCALE", &psvpscale, 0)
        && psvpscale == dwg->header_vars.PSVPSCALE)
      pass ();
    else
      fail ("HEADER.PSVPSCALE [BD] set+1 %g != %g",
            dwg->header_vars.PSVPSCALE, psvpscale);
    psvpscale--;
    dwg_dynapi_header_set_value (dwg, "PSVPSCALE", &psvpscale, 0);

  }
  {
    BITCODE_3BD pinsbase;
    if (dwg_dynapi_header_value (dwg, "PINSBASE", &pinsbase, NULL)
        && !memcmp (&pinsbase, &dwg->header_vars.PINSBASE, sizeof (dwg->header_vars.PINSBASE))
       )
      pass ();
    else
      fail ("HEADER.PINSBASE [3BD]");
  }
  {
    BITCODE_3BD pextmin;
    if (dwg_dynapi_header_value (dwg, "PEXTMIN", &pextmin, NULL)
        && !memcmp (&pextmin, &dwg->header_vars.PEXTMIN, sizeof (dwg->header_vars.PEXTMIN))
       )
      pass ();
    else
      fail ("HEADER.PEXTMIN [3BD]");
  }
  {
    BITCODE_3BD pextmax;
    if (dwg_dynapi_header_value (dwg, "PEXTMAX", &pextmax, NULL)
        && !memcmp (&pextmax, &dwg->header_vars.PEXTMAX, sizeof (dwg->header_vars.PEXTMAX))
       )
      pass ();
    else
      fail ("HEADER.PEXTMAX [3BD]");
  }
  {
    BITCODE_2RD plimmin;
    if (dwg_dynapi_header_value (dwg, "PLIMMIN", &plimmin, NULL)
        && !memcmp (&plimmin, &dwg->header_vars.PLIMMIN, sizeof (dwg->header_vars.PLIMMIN))
       )
      pass ();
    else
      fail ("HEADER.PLIMMIN [2RD]");
  }
  {
    BITCODE_2RD plimmax;
    if (dwg_dynapi_header_value (dwg, "PLIMMAX", &plimmax, NULL)
        && !memcmp (&plimmax, &dwg->header_vars.PLIMMAX, sizeof (dwg->header_vars.PLIMMAX))
       )
      pass ();
    else
      fail ("HEADER.PLIMMAX [2RD]");
  }
  {
    BITCODE_BD pelevation;
    if (dwg_dynapi_header_value (dwg, "PELEVATION", &pelevation, NULL)
        && pelevation == dwg->header_vars.PELEVATION)
      pass ();
    else
      fail ("HEADER.PELEVATION [BD] %g != %g", dwg->header_vars.PELEVATION, pelevation);
    pelevation++;
    if (dwg_dynapi_header_set_value (dwg, "PELEVATION", &pelevation, 0)
        && pelevation == dwg->header_vars.PELEVATION)
      pass ();
    else
      fail ("HEADER.PELEVATION [BD] set+1 %g != %g",
            dwg->header_vars.PELEVATION, pelevation);
    pelevation--;
    dwg_dynapi_header_set_value (dwg, "PELEVATION", &pelevation, 0);

  }
  {
    BITCODE_3BD pucsorg;
    if (dwg_dynapi_header_value (dwg, "PUCSORG", &pucsorg, NULL)
        && !memcmp (&pucsorg, &dwg->header_vars.PUCSORG, sizeof (dwg->header_vars.PUCSORG))
       )
      pass ();
    else
      fail ("HEADER.PUCSORG [3BD]");
  }
  {
    BITCODE_3BD pucsxdir;
    if (dwg_dynapi_header_value (dwg, "PUCSXDIR", &pucsxdir, NULL)
        && !memcmp (&pucsxdir, &dwg->header_vars.PUCSXDIR, sizeof (dwg->header_vars.PUCSXDIR))
       )
      pass ();
    else
      fail ("HEADER.PUCSXDIR [3BD]");
  }
  {
    BITCODE_3BD pucsydir;
    if (dwg_dynapi_header_value (dwg, "PUCSYDIR", &pucsydir, NULL)
        && !memcmp (&pucsydir, &dwg->header_vars.PUCSYDIR, sizeof (dwg->header_vars.PUCSYDIR))
       )
      pass ();
    else
      fail ("HEADER.PUCSYDIR [3BD]");
  }
  {
    BITCODE_H pucsname;
    if (dwg_dynapi_header_value (dwg, "PUCSNAME", &pucsname, NULL)
        && !memcmp (&pucsname, &dwg->header_vars.PUCSNAME, sizeof (dwg->header_vars.PUCSNAME))
       )
      pass ();
    else
      fail ("HEADER.PUCSNAME [H]");
  }
  {
    BITCODE_H pucsbase;
    if (dwg_dynapi_header_value (dwg, "PUCSBASE", &pucsbase, NULL)
        && !memcmp (&pucsbase, &dwg->header_vars.PUCSBASE, sizeof (dwg->header_vars.PUCSBASE))
       )
      pass ();
    else
      fail ("HEADER.PUCSBASE [H]");
  }
  {
    BITCODE_H pucsorthoref;
    if (dwg_dynapi_header_value (dwg, "PUCSORTHOREF", &pucsorthoref, NULL)
        && !memcmp (&pucsorthoref, &dwg->header_vars.PUCSORTHOREF, sizeof (dwg->header_vars.PUCSORTHOREF))
       )
      pass ();
    else
      fail ("HEADER.PUCSORTHOREF [H]");
  }
  {
    BITCODE_BS pucsorthoview;
    if (dwg_dynapi_header_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, NULL)
        && pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
      pass ();
    else
      fail ("HEADER.PUCSORTHOVIEW [BS] %hu != %hu", dwg->header_vars.PUCSORTHOVIEW, pucsorthoview);
    pucsorthoview++;
    if (dwg_dynapi_header_set_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, 0)
        && pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
      pass ();
    else
      fail ("HEADER.PUCSORTHOVIEW [BS] set+1 %hu != %hu",
            dwg->header_vars.PUCSORTHOVIEW, pucsorthoview);
    pucsorthoview--;
    dwg_dynapi_header_set_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, 0);

  }
  {
    BITCODE_3BD pucsorgtop;
    if (dwg_dynapi_header_value (dwg, "PUCSORGTOP", &pucsorgtop, NULL)
        && !memcmp (&pucsorgtop, &dwg->header_vars.PUCSORGTOP, sizeof (dwg->header_vars.PUCSORGTOP))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGTOP [3BD]");
  }
  {
    BITCODE_3BD pucsorgbottom;
    if (dwg_dynapi_header_value (dwg, "PUCSORGBOTTOM", &pucsorgbottom, NULL)
        && !memcmp (&pucsorgbottom, &dwg->header_vars.PUCSORGBOTTOM, sizeof (dwg->header_vars.PUCSORGBOTTOM))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGBOTTOM [3BD]");
  }
  {
    BITCODE_3BD pucsorgleft;
    if (dwg_dynapi_header_value (dwg, "PUCSORGLEFT", &pucsorgleft, NULL)
        && !memcmp (&pucsorgleft, &dwg->header_vars.PUCSORGLEFT, sizeof (dwg->header_vars.PUCSORGLEFT))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGLEFT [3BD]");
  }
  {
    BITCODE_3BD pucsorgright;
    if (dwg_dynapi_header_value (dwg, "PUCSORGRIGHT", &pucsorgright, NULL)
        && !memcmp (&pucsorgright, &dwg->header_vars.PUCSORGRIGHT, sizeof (dwg->header_vars.PUCSORGRIGHT))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGRIGHT [3BD]");
  }
  {
    BITCODE_3BD pucsorgfront;
    if (dwg_dynapi_header_value (dwg, "PUCSORGFRONT", &pucsorgfront, NULL)
        && !memcmp (&pucsorgfront, &dwg->header_vars.PUCSORGFRONT, sizeof (dwg->header_vars.PUCSORGFRONT))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGFRONT [3BD]");
  }
  {
    BITCODE_3BD pucsorgback;
    if (dwg_dynapi_header_value (dwg, "PUCSORGBACK", &pucsorgback, NULL)
        && !memcmp (&pucsorgback, &dwg->header_vars.PUCSORGBACK, sizeof (dwg->header_vars.PUCSORGBACK))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGBACK [3BD]");
  }
  {
    BITCODE_3BD insbase;
    if (dwg_dynapi_header_value (dwg, "INSBASE", &insbase, NULL)
        && !memcmp (&insbase, &dwg->header_vars.INSBASE, sizeof (dwg->header_vars.INSBASE))
       )
      pass ();
    else
      fail ("HEADER.INSBASE [3BD]");
  }
  {
    BITCODE_3BD extmin;
    if (dwg_dynapi_header_value (dwg, "EXTMIN", &extmin, NULL)
        && !memcmp (&extmin, &dwg->header_vars.EXTMIN, sizeof (dwg->header_vars.EXTMIN))
       )
      pass ();
    else
      fail ("HEADER.EXTMIN [3BD]");
  }
  {
    BITCODE_3BD extmax;
    if (dwg_dynapi_header_value (dwg, "EXTMAX", &extmax, NULL)
        && !memcmp (&extmax, &dwg->header_vars.EXTMAX, sizeof (dwg->header_vars.EXTMAX))
       )
      pass ();
    else
      fail ("HEADER.EXTMAX [3BD]");
  }
  {
    BITCODE_2RD limmin;
    if (dwg_dynapi_header_value (dwg, "LIMMIN", &limmin, NULL)
        && !memcmp (&limmin, &dwg->header_vars.LIMMIN, sizeof (dwg->header_vars.LIMMIN))
       )
      pass ();
    else
      fail ("HEADER.LIMMIN [2RD]");
  }
  {
    BITCODE_2RD limmax;
    if (dwg_dynapi_header_value (dwg, "LIMMAX", &limmax, NULL)
        && !memcmp (&limmax, &dwg->header_vars.LIMMAX, sizeof (dwg->header_vars.LIMMAX))
       )
      pass ();
    else
      fail ("HEADER.LIMMAX [2RD]");
  }
  {
    BITCODE_2RD viewctr;
    if (dwg_dynapi_header_value (dwg, "VIEWCTR", &viewctr, NULL)
        && !memcmp (&viewctr, &dwg->header_vars.VIEWCTR, sizeof (dwg->header_vars.VIEWCTR))
       )
      pass ();
    else
      fail ("HEADER.VIEWCTR [2RD]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_header_value (dwg, "ELEVATION", &elevation, NULL)
        && elevation == dwg->header_vars.ELEVATION)
      pass ();
    else
      fail ("HEADER.ELEVATION [BD] %g != %g", dwg->header_vars.ELEVATION, elevation);
    elevation++;
    if (dwg_dynapi_header_set_value (dwg, "ELEVATION", &elevation, 0)
        && elevation == dwg->header_vars.ELEVATION)
      pass ();
    else
      fail ("HEADER.ELEVATION [BD] set+1 %g != %g",
            dwg->header_vars.ELEVATION, elevation);
    elevation--;
    dwg_dynapi_header_set_value (dwg, "ELEVATION", &elevation, 0);

  }
  {
    BITCODE_RD viewsize;
    if (dwg_dynapi_header_value (dwg, "VIEWSIZE", &viewsize, NULL)
        && viewsize == dwg->header_vars.VIEWSIZE)
      pass ();
    else
      fail ("HEADER.VIEWSIZE [RD] %g != %g", dwg->header_vars.VIEWSIZE, viewsize);
    viewsize++;
    if (dwg_dynapi_header_set_value (dwg, "VIEWSIZE", &viewsize, 0)
        && viewsize == dwg->header_vars.VIEWSIZE)
      pass ();
    else
      fail ("HEADER.VIEWSIZE [RD] set+1 %g != %g",
            dwg->header_vars.VIEWSIZE, viewsize);
    viewsize--;
    dwg_dynapi_header_set_value (dwg, "VIEWSIZE", &viewsize, 0);

  }
  {
    BITCODE_RS snapmode;
    if (dwg_dynapi_header_value (dwg, "SNAPMODE", &snapmode, NULL)
        && snapmode == dwg->header_vars.SNAPMODE)
      pass ();
    else
      fail ("HEADER.SNAPMODE [RS] %hu != %hu", dwg->header_vars.SNAPMODE, snapmode);
    snapmode++;
    if (dwg_dynapi_header_set_value (dwg, "SNAPMODE", &snapmode, 0)
        && snapmode == dwg->header_vars.SNAPMODE)
      pass ();
    else
      fail ("HEADER.SNAPMODE [RS] set+1 %hu != %hu",
            dwg->header_vars.SNAPMODE, snapmode);
    snapmode--;
    dwg_dynapi_header_set_value (dwg, "SNAPMODE", &snapmode, 0);

  }
  {
    BITCODE_2RD snapunit;
    if (dwg_dynapi_header_value (dwg, "SNAPUNIT", &snapunit, NULL)
        && !memcmp (&snapunit, &dwg->header_vars.SNAPUNIT, sizeof (dwg->header_vars.SNAPUNIT))
       )
      pass ();
    else
      fail ("HEADER.SNAPUNIT [2RD]");
  }
  {
    BITCODE_2RD snapbase;
    if (dwg_dynapi_header_value (dwg, "SNAPBASE", &snapbase, NULL)
        && !memcmp (&snapbase, &dwg->header_vars.SNAPBASE, sizeof (dwg->header_vars.SNAPBASE))
       )
      pass ();
    else
      fail ("HEADER.SNAPBASE [2RD]");
  }
  {
    BITCODE_RD snapang;
    if (dwg_dynapi_header_value (dwg, "SNAPANG", &snapang, NULL)
        && snapang == dwg->header_vars.SNAPANG)
      pass ();
    else
      fail ("HEADER.SNAPANG [RD] %g != %g", dwg->header_vars.SNAPANG, snapang);
    snapang++;
    if (dwg_dynapi_header_set_value (dwg, "SNAPANG", &snapang, 0)
        && snapang == dwg->header_vars.SNAPANG)
      pass ();
    else
      fail ("HEADER.SNAPANG [RD] set+1 %g != %g",
            dwg->header_vars.SNAPANG, snapang);
    snapang--;
    dwg_dynapi_header_set_value (dwg, "SNAPANG", &snapang, 0);

  }
  {
    BITCODE_RS snapstyl;
    if (dwg_dynapi_header_value (dwg, "SNAPSTYL", &snapstyl, NULL)
        && snapstyl == dwg->header_vars.SNAPSTYL)
      pass ();
    else
      fail ("HEADER.SNAPSTYL [RS] %hu != %hu", dwg->header_vars.SNAPSTYL, snapstyl);
    snapstyl++;
    if (dwg_dynapi_header_set_value (dwg, "SNAPSTYL", &snapstyl, 0)
        && snapstyl == dwg->header_vars.SNAPSTYL)
      pass ();
    else
      fail ("HEADER.SNAPSTYL [RS] set+1 %hu != %hu",
            dwg->header_vars.SNAPSTYL, snapstyl);
    snapstyl--;
    dwg_dynapi_header_set_value (dwg, "SNAPSTYL", &snapstyl, 0);

  }
  {
    BITCODE_RS snapisopair;
    if (dwg_dynapi_header_value (dwg, "SNAPISOPAIR", &snapisopair, NULL)
        && snapisopair == dwg->header_vars.SNAPISOPAIR)
      pass ();
    else
      fail ("HEADER.SNAPISOPAIR [RS] %hu != %hu", dwg->header_vars.SNAPISOPAIR, snapisopair);
    snapisopair++;
    if (dwg_dynapi_header_set_value (dwg, "SNAPISOPAIR", &snapisopair, 0)
        && snapisopair == dwg->header_vars.SNAPISOPAIR)
      pass ();
    else
      fail ("HEADER.SNAPISOPAIR [RS] set+1 %hu != %hu",
            dwg->header_vars.SNAPISOPAIR, snapisopair);
    snapisopair--;
    dwg_dynapi_header_set_value (dwg, "SNAPISOPAIR", &snapisopair, 0);

  }
  {
    BITCODE_RS gridmode;
    if (dwg_dynapi_header_value (dwg, "GRIDMODE", &gridmode, NULL)
        && gridmode == dwg->header_vars.GRIDMODE)
      pass ();
    else
      fail ("HEADER.GRIDMODE [RS] %hu != %hu", dwg->header_vars.GRIDMODE, gridmode);
    gridmode++;
    if (dwg_dynapi_header_set_value (dwg, "GRIDMODE", &gridmode, 0)
        && gridmode == dwg->header_vars.GRIDMODE)
      pass ();
    else
      fail ("HEADER.GRIDMODE [RS] set+1 %hu != %hu",
            dwg->header_vars.GRIDMODE, gridmode);
    gridmode--;
    dwg_dynapi_header_set_value (dwg, "GRIDMODE", &gridmode, 0);

  }
  {
    BITCODE_2RD gridunit;
    if (dwg_dynapi_header_value (dwg, "GRIDUNIT", &gridunit, NULL)
        && !memcmp (&gridunit, &dwg->header_vars.GRIDUNIT, sizeof (dwg->header_vars.GRIDUNIT))
       )
      pass ();
    else
      fail ("HEADER.GRIDUNIT [2RD]");
  }
  {
    BITCODE_3BD ucsorg;
    if (dwg_dynapi_header_value (dwg, "UCSORG", &ucsorg, NULL)
        && !memcmp (&ucsorg, &dwg->header_vars.UCSORG, sizeof (dwg->header_vars.UCSORG))
       )
      pass ();
    else
      fail ("HEADER.UCSORG [3BD]");
  }
  {
    BITCODE_3BD ucsxdir;
    if (dwg_dynapi_header_value (dwg, "UCSXDIR", &ucsxdir, NULL)
        && !memcmp (&ucsxdir, &dwg->header_vars.UCSXDIR, sizeof (dwg->header_vars.UCSXDIR))
       )
      pass ();
    else
      fail ("HEADER.UCSXDIR [3BD]");
  }
  {
    BITCODE_3BD ucsydir;
    if (dwg_dynapi_header_value (dwg, "UCSYDIR", &ucsydir, NULL)
        && !memcmp (&ucsydir, &dwg->header_vars.UCSYDIR, sizeof (dwg->header_vars.UCSYDIR))
       )
      pass ();
    else
      fail ("HEADER.UCSYDIR [3BD]");
  }
  {
    BITCODE_H ucsname;
    if (dwg_dynapi_header_value (dwg, "UCSNAME", &ucsname, NULL)
        && !memcmp (&ucsname, &dwg->header_vars.UCSNAME, sizeof (dwg->header_vars.UCSNAME))
       )
      pass ();
    else
      fail ("HEADER.UCSNAME [H]");
  }
  {
    BITCODE_H ucsbase;
    if (dwg_dynapi_header_value (dwg, "UCSBASE", &ucsbase, NULL)
        && !memcmp (&ucsbase, &dwg->header_vars.UCSBASE, sizeof (dwg->header_vars.UCSBASE))
       )
      pass ();
    else
      fail ("HEADER.UCSBASE [H]");
  }
  {
    BITCODE_BS ucsorthoview;
    if (dwg_dynapi_header_value (dwg, "UCSORTHOVIEW", &ucsorthoview, NULL)
        && ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
      pass ();
    else
      fail ("HEADER.UCSORTHOVIEW [BS] %hu != %hu", dwg->header_vars.UCSORTHOVIEW, ucsorthoview);
    ucsorthoview++;
    if (dwg_dynapi_header_set_value (dwg, "UCSORTHOVIEW", &ucsorthoview, 0)
        && ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
      pass ();
    else
      fail ("HEADER.UCSORTHOVIEW [BS] set+1 %hu != %hu",
            dwg->header_vars.UCSORTHOVIEW, ucsorthoview);
    ucsorthoview--;
    dwg_dynapi_header_set_value (dwg, "UCSORTHOVIEW", &ucsorthoview, 0);

  }
  {
    BITCODE_H ucsorthoref;
    if (dwg_dynapi_header_value (dwg, "UCSORTHOREF", &ucsorthoref, NULL)
        && !memcmp (&ucsorthoref, &dwg->header_vars.UCSORTHOREF, sizeof (dwg->header_vars.UCSORTHOREF))
       )
      pass ();
    else
      fail ("HEADER.UCSORTHOREF [H]");
  }
  {
    BITCODE_3BD ucsorgtop;
    if (dwg_dynapi_header_value (dwg, "UCSORGTOP", &ucsorgtop, NULL)
        && !memcmp (&ucsorgtop, &dwg->header_vars.UCSORGTOP, sizeof (dwg->header_vars.UCSORGTOP))
       )
      pass ();
    else
      fail ("HEADER.UCSORGTOP [3BD]");
  }
  {
    BITCODE_3BD ucsorgbottom;
    if (dwg_dynapi_header_value (dwg, "UCSORGBOTTOM", &ucsorgbottom, NULL)
        && !memcmp (&ucsorgbottom, &dwg->header_vars.UCSORGBOTTOM, sizeof (dwg->header_vars.UCSORGBOTTOM))
       )
      pass ();
    else
      fail ("HEADER.UCSORGBOTTOM [3BD]");
  }
  {
    BITCODE_3BD ucsorgleft;
    if (dwg_dynapi_header_value (dwg, "UCSORGLEFT", &ucsorgleft, NULL)
        && !memcmp (&ucsorgleft, &dwg->header_vars.UCSORGLEFT, sizeof (dwg->header_vars.UCSORGLEFT))
       )
      pass ();
    else
      fail ("HEADER.UCSORGLEFT [3BD]");
  }
  {
    BITCODE_3BD ucsorgright;
    if (dwg_dynapi_header_value (dwg, "UCSORGRIGHT", &ucsorgright, NULL)
        && !memcmp (&ucsorgright, &dwg->header_vars.UCSORGRIGHT, sizeof (dwg->header_vars.UCSORGRIGHT))
       )
      pass ();
    else
      fail ("HEADER.UCSORGRIGHT [3BD]");
  }
  {
    BITCODE_3BD ucsorgfront;
    if (dwg_dynapi_header_value (dwg, "UCSORGFRONT", &ucsorgfront, NULL)
        && !memcmp (&ucsorgfront, &dwg->header_vars.UCSORGFRONT, sizeof (dwg->header_vars.UCSORGFRONT))
       )
      pass ();
    else
      fail ("HEADER.UCSORGFRONT [3BD]");
  }
  {
    BITCODE_3BD ucsorgback;
    if (dwg_dynapi_header_value (dwg, "UCSORGBACK", &ucsorgback, NULL)
        && !memcmp (&ucsorgback, &dwg->header_vars.UCSORGBACK, sizeof (dwg->header_vars.UCSORGBACK))
       )
      pass ();
    else
      fail ("HEADER.UCSORGBACK [3BD]");
  }
  {
    BITCODE_TV dimpost;
    if (dwg_dynapi_header_value (dwg, "DIMPOST", &dimpost, NULL)
        && !memcmp (&dimpost, &dwg->header_vars.DIMPOST, sizeof (dwg->header_vars.DIMPOST))
       )
      pass ();
    else
      fail ("HEADER.DIMPOST [TV]");
  }
  {
    BITCODE_TV dimapost;
    if (dwg_dynapi_header_value (dwg, "DIMAPOST", &dimapost, NULL)
        && !memcmp (&dimapost, &dwg->header_vars.DIMAPOST, sizeof (dwg->header_vars.DIMAPOST))
       )
      pass ();
    else
      fail ("HEADER.DIMAPOST [TV]");
  }
  {
    BITCODE_B dimtol;
    if (dwg_dynapi_header_value (dwg, "DIMTOL", &dimtol, NULL)
        && dimtol == dwg->header_vars.DIMTOL)
      pass ();
    else
      fail ("HEADER.DIMTOL [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOL, dimtol);
    dimtol++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTOL", &dimtol, 0)
        && dimtol == dwg->header_vars.DIMTOL)
      pass ();
    else
      fail ("HEADER.DIMTOL [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTOL, dimtol);
    dimtol--;
    dwg_dynapi_header_set_value (dwg, "DIMTOL", &dimtol, 0);

  }
  {
    BITCODE_B dimlim;
    if (dwg_dynapi_header_value (dwg, "DIMLIM", &dimlim, NULL)
        && dimlim == dwg->header_vars.DIMLIM)
      pass ();
    else
      fail ("HEADER.DIMLIM [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMLIM, dimlim);
    dimlim++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLIM", &dimlim, 0)
        && dimlim == dwg->header_vars.DIMLIM)
      pass ();
    else
      fail ("HEADER.DIMLIM [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMLIM, dimlim);
    dimlim--;
    dwg_dynapi_header_set_value (dwg, "DIMLIM", &dimlim, 0);

  }
  {
    BITCODE_B dimtih;
    if (dwg_dynapi_header_value (dwg, "DIMTIH", &dimtih, NULL)
        && dimtih == dwg->header_vars.DIMTIH)
      pass ();
    else
      fail ("HEADER.DIMTIH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIH, dimtih);
    dimtih++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTIH", &dimtih, 0)
        && dimtih == dwg->header_vars.DIMTIH)
      pass ();
    else
      fail ("HEADER.DIMTIH [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTIH, dimtih);
    dimtih--;
    dwg_dynapi_header_set_value (dwg, "DIMTIH", &dimtih, 0);

  }
  {
    BITCODE_B dimtoh;
    if (dwg_dynapi_header_value (dwg, "DIMTOH", &dimtoh, NULL)
        && dimtoh == dwg->header_vars.DIMTOH)
      pass ();
    else
      fail ("HEADER.DIMTOH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOH, dimtoh);
    dimtoh++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTOH", &dimtoh, 0)
        && dimtoh == dwg->header_vars.DIMTOH)
      pass ();
    else
      fail ("HEADER.DIMTOH [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTOH, dimtoh);
    dimtoh--;
    dwg_dynapi_header_set_value (dwg, "DIMTOH", &dimtoh, 0);

  }
  {
    BITCODE_B dimse1;
    if (dwg_dynapi_header_value (dwg, "DIMSE1", &dimse1, NULL)
        && dimse1 == dwg->header_vars.DIMSE1)
      pass ();
    else
      fail ("HEADER.DIMSE1 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE1, dimse1);
    dimse1++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSE1", &dimse1, 0)
        && dimse1 == dwg->header_vars.DIMSE1)
      pass ();
    else
      fail ("HEADER.DIMSE1 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSE1, dimse1);
    dimse1--;
    dwg_dynapi_header_set_value (dwg, "DIMSE1", &dimse1, 0);

  }
  {
    BITCODE_B dimse2;
    if (dwg_dynapi_header_value (dwg, "DIMSE2", &dimse2, NULL)
        && dimse2 == dwg->header_vars.DIMSE2)
      pass ();
    else
      fail ("HEADER.DIMSE2 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE2, dimse2);
    dimse2++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSE2", &dimse2, 0)
        && dimse2 == dwg->header_vars.DIMSE2)
      pass ();
    else
      fail ("HEADER.DIMSE2 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSE2, dimse2);
    dimse2--;
    dwg_dynapi_header_set_value (dwg, "DIMSE2", &dimse2, 0);

  }
  {
    BITCODE_B dimalt;
    if (dwg_dynapi_header_value (dwg, "DIMALT", &dimalt, NULL)
        && dimalt == dwg->header_vars.DIMALT)
      pass ();
    else
      fail ("HEADER.DIMALT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMALT, dimalt);
    dimalt++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALT", &dimalt, 0)
        && dimalt == dwg->header_vars.DIMALT)
      pass ();
    else
      fail ("HEADER.DIMALT [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMALT, dimalt);
    dimalt--;
    dwg_dynapi_header_set_value (dwg, "DIMALT", &dimalt, 0);

  }
  {
    BITCODE_B dimtofl;
    if (dwg_dynapi_header_value (dwg, "DIMTOFL", &dimtofl, NULL)
        && dimtofl == dwg->header_vars.DIMTOFL)
      pass ();
    else
      fail ("HEADER.DIMTOFL [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOFL, dimtofl);
    dimtofl++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTOFL", &dimtofl, 0)
        && dimtofl == dwg->header_vars.DIMTOFL)
      pass ();
    else
      fail ("HEADER.DIMTOFL [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTOFL, dimtofl);
    dimtofl--;
    dwg_dynapi_header_set_value (dwg, "DIMTOFL", &dimtofl, 0);

  }
  {
    BITCODE_B dimsah;
    if (dwg_dynapi_header_value (dwg, "DIMSAH", &dimsah, NULL)
        && dimsah == dwg->header_vars.DIMSAH)
      pass ();
    else
      fail ("HEADER.DIMSAH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAH, dimsah);
    dimsah++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSAH", &dimsah, 0)
        && dimsah == dwg->header_vars.DIMSAH)
      pass ();
    else
      fail ("HEADER.DIMSAH [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSAH, dimsah);
    dimsah--;
    dwg_dynapi_header_set_value (dwg, "DIMSAH", &dimsah, 0);

  }
  {
    BITCODE_B dimtix;
    if (dwg_dynapi_header_value (dwg, "DIMTIX", &dimtix, NULL)
        && dimtix == dwg->header_vars.DIMTIX)
      pass ();
    else
      fail ("HEADER.DIMTIX [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIX, dimtix);
    dimtix++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTIX", &dimtix, 0)
        && dimtix == dwg->header_vars.DIMTIX)
      pass ();
    else
      fail ("HEADER.DIMTIX [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTIX, dimtix);
    dimtix--;
    dwg_dynapi_header_set_value (dwg, "DIMTIX", &dimtix, 0);

  }
  {
    BITCODE_B dimsoxd;
    if (dwg_dynapi_header_value (dwg, "DIMSOXD", &dimsoxd, NULL)
        && dimsoxd == dwg->header_vars.DIMSOXD)
      pass ();
    else
      fail ("HEADER.DIMSOXD [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSOXD, dimsoxd);
    dimsoxd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSOXD", &dimsoxd, 0)
        && dimsoxd == dwg->header_vars.DIMSOXD)
      pass ();
    else
      fail ("HEADER.DIMSOXD [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSOXD, dimsoxd);
    dimsoxd--;
    dwg_dynapi_header_set_value (dwg, "DIMSOXD", &dimsoxd, 0);

  }
  {
    BITCODE_BS dimaltd;
    if (dwg_dynapi_header_value (dwg, "DIMALTD", &dimaltd, NULL)
        && dimaltd == dwg->header_vars.DIMALTD)
      pass ();
    else
      fail ("HEADER.DIMALTD [BS] %hu != %hu", dwg->header_vars.DIMALTD, dimaltd);
    dimaltd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTD", &dimaltd, 0)
        && dimaltd == dwg->header_vars.DIMALTD)
      pass ();
    else
      fail ("HEADER.DIMALTD [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTD, dimaltd);
    dimaltd--;
    dwg_dynapi_header_set_value (dwg, "DIMALTD", &dimaltd, 0);

  }
  {
    BITCODE_BS dimzin;
    if (dwg_dynapi_header_value (dwg, "DIMZIN", &dimzin, NULL)
        && dimzin == dwg->header_vars.DIMZIN)
      pass ();
    else
      fail ("HEADER.DIMZIN [BS] %hu != %hu", dwg->header_vars.DIMZIN, dimzin);
    dimzin++;
    if (dwg_dynapi_header_set_value (dwg, "DIMZIN", &dimzin, 0)
        && dimzin == dwg->header_vars.DIMZIN)
      pass ();
    else
      fail ("HEADER.DIMZIN [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMZIN, dimzin);
    dimzin--;
    dwg_dynapi_header_set_value (dwg, "DIMZIN", &dimzin, 0);

  }
  {
    BITCODE_B dimsd1;
    if (dwg_dynapi_header_value (dwg, "DIMSD1", &dimsd1, NULL)
        && dimsd1 == dwg->header_vars.DIMSD1)
      pass ();
    else
      fail ("HEADER.DIMSD1 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD1, dimsd1);
    dimsd1++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSD1", &dimsd1, 0)
        && dimsd1 == dwg->header_vars.DIMSD1)
      pass ();
    else
      fail ("HEADER.DIMSD1 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSD1, dimsd1);
    dimsd1--;
    dwg_dynapi_header_set_value (dwg, "DIMSD1", &dimsd1, 0);

  }
  {
    BITCODE_B dimsd2;
    if (dwg_dynapi_header_value (dwg, "DIMSD2", &dimsd2, NULL)
        && dimsd2 == dwg->header_vars.DIMSD2)
      pass ();
    else
      fail ("HEADER.DIMSD2 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD2, dimsd2);
    dimsd2++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSD2", &dimsd2, 0)
        && dimsd2 == dwg->header_vars.DIMSD2)
      pass ();
    else
      fail ("HEADER.DIMSD2 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSD2, dimsd2);
    dimsd2--;
    dwg_dynapi_header_set_value (dwg, "DIMSD2", &dimsd2, 0);

  }
  {
    BITCODE_BS dimtolj;
    if (dwg_dynapi_header_value (dwg, "DIMTOLJ", &dimtolj, NULL)
        && dimtolj == dwg->header_vars.DIMTOLJ)
      pass ();
    else
      fail ("HEADER.DIMTOLJ [BS] %hu != %hu", dwg->header_vars.DIMTOLJ, dimtolj);
    dimtolj++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTOLJ", &dimtolj, 0)
        && dimtolj == dwg->header_vars.DIMTOLJ)
      pass ();
    else
      fail ("HEADER.DIMTOLJ [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTOLJ, dimtolj);
    dimtolj--;
    dwg_dynapi_header_set_value (dwg, "DIMTOLJ", &dimtolj, 0);

  }
  {
    BITCODE_BS dimjust;
    if (dwg_dynapi_header_value (dwg, "DIMJUST", &dimjust, NULL)
        && dimjust == dwg->header_vars.DIMJUST)
      pass ();
    else
      fail ("HEADER.DIMJUST [BS] %hu != %hu", dwg->header_vars.DIMJUST, dimjust);
    dimjust++;
    if (dwg_dynapi_header_set_value (dwg, "DIMJUST", &dimjust, 0)
        && dimjust == dwg->header_vars.DIMJUST)
      pass ();
    else
      fail ("HEADER.DIMJUST [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMJUST, dimjust);
    dimjust--;
    dwg_dynapi_header_set_value (dwg, "DIMJUST", &dimjust, 0);

  }
  {
    BITCODE_BS dimfit;
    if (dwg_dynapi_header_value (dwg, "DIMFIT", &dimfit, NULL)
        && dimfit == dwg->header_vars.DIMFIT)
      pass ();
    else
      fail ("HEADER.DIMFIT [BS] %hu != %hu", dwg->header_vars.DIMFIT, dimfit);
    dimfit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMFIT", &dimfit, 0)
        && dimfit == dwg->header_vars.DIMFIT)
      pass ();
    else
      fail ("HEADER.DIMFIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMFIT, dimfit);
    dimfit--;
    dwg_dynapi_header_set_value (dwg, "DIMFIT", &dimfit, 0);

  }
  {
    BITCODE_B dimupt;
    if (dwg_dynapi_header_value (dwg, "DIMUPT", &dimupt, NULL)
        && dimupt == dwg->header_vars.DIMUPT)
      pass ();
    else
      fail ("HEADER.DIMUPT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMUPT, dimupt);
    dimupt++;
    if (dwg_dynapi_header_set_value (dwg, "DIMUPT", &dimupt, 0)
        && dimupt == dwg->header_vars.DIMUPT)
      pass ();
    else
      fail ("HEADER.DIMUPT [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMUPT, dimupt);
    dimupt--;
    dwg_dynapi_header_set_value (dwg, "DIMUPT", &dimupt, 0);

  }
  {
    BITCODE_BS dimtzin;
    if (dwg_dynapi_header_value (dwg, "DIMTZIN", &dimtzin, NULL)
        && dimtzin == dwg->header_vars.DIMTZIN)
      pass ();
    else
      fail ("HEADER.DIMTZIN [BS] %hu != %hu", dwg->header_vars.DIMTZIN, dimtzin);
    dimtzin++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTZIN", &dimtzin, 0)
        && dimtzin == dwg->header_vars.DIMTZIN)
      pass ();
    else
      fail ("HEADER.DIMTZIN [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTZIN, dimtzin);
    dimtzin--;
    dwg_dynapi_header_set_value (dwg, "DIMTZIN", &dimtzin, 0);

  }
  {
    BITCODE_BS dimmaltz;
    if (dwg_dynapi_header_value (dwg, "DIMMALTZ", &dimmaltz, NULL)
        && dimmaltz == dwg->header_vars.DIMMALTZ)
      pass ();
    else
      fail ("HEADER.DIMMALTZ [BS] %hu != %hu", dwg->header_vars.DIMMALTZ, dimmaltz);
    dimmaltz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMMALTZ", &dimmaltz, 0)
        && dimmaltz == dwg->header_vars.DIMMALTZ)
      pass ();
    else
      fail ("HEADER.DIMMALTZ [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMMALTZ, dimmaltz);
    dimmaltz--;
    dwg_dynapi_header_set_value (dwg, "DIMMALTZ", &dimmaltz, 0);

  }
  {
    BITCODE_BS dimmalttz;
    if (dwg_dynapi_header_value (dwg, "DIMMALTTZ", &dimmalttz, NULL)
        && dimmalttz == dwg->header_vars.DIMMALTTZ)
      pass ();
    else
      fail ("HEADER.DIMMALTTZ [BS] %hu != %hu", dwg->header_vars.DIMMALTTZ, dimmalttz);
    dimmalttz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMMALTTZ", &dimmalttz, 0)
        && dimmalttz == dwg->header_vars.DIMMALTTZ)
      pass ();
    else
      fail ("HEADER.DIMMALTTZ [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMMALTTZ, dimmalttz);
    dimmalttz--;
    dwg_dynapi_header_set_value (dwg, "DIMMALTTZ", &dimmalttz, 0);

  }
  {
    BITCODE_BS dimtad;
    if (dwg_dynapi_header_value (dwg, "DIMTAD", &dimtad, NULL)
        && dimtad == dwg->header_vars.DIMTAD)
      pass ();
    else
      fail ("HEADER.DIMTAD [BS] %hu != %hu", dwg->header_vars.DIMTAD, dimtad);
    dimtad++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTAD", &dimtad, 0)
        && dimtad == dwg->header_vars.DIMTAD)
      pass ();
    else
      fail ("HEADER.DIMTAD [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTAD, dimtad);
    dimtad--;
    dwg_dynapi_header_set_value (dwg, "DIMTAD", &dimtad, 0);

  }
  {
    BITCODE_BS dimunit;
    if (dwg_dynapi_header_value (dwg, "DIMUNIT", &dimunit, NULL)
        && dimunit == dwg->header_vars.DIMUNIT)
      pass ();
    else
      fail ("HEADER.DIMUNIT [BS] %hu != %hu", dwg->header_vars.DIMUNIT, dimunit);
    dimunit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMUNIT", &dimunit, 0)
        && dimunit == dwg->header_vars.DIMUNIT)
      pass ();
    else
      fail ("HEADER.DIMUNIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMUNIT, dimunit);
    dimunit--;
    dwg_dynapi_header_set_value (dwg, "DIMUNIT", &dimunit, 0);

  }
  {
    BITCODE_BS dimaunit;
    if (dwg_dynapi_header_value (dwg, "DIMAUNIT", &dimaunit, NULL)
        && dimaunit == dwg->header_vars.DIMAUNIT)
      pass ();
    else
      fail ("HEADER.DIMAUNIT [BS] %hu != %hu", dwg->header_vars.DIMAUNIT, dimaunit);
    dimaunit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMAUNIT", &dimaunit, 0)
        && dimaunit == dwg->header_vars.DIMAUNIT)
      pass ();
    else
      fail ("HEADER.DIMAUNIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMAUNIT, dimaunit);
    dimaunit--;
    dwg_dynapi_header_set_value (dwg, "DIMAUNIT", &dimaunit, 0);

  }
  {
    BITCODE_BS dimdec;
    if (dwg_dynapi_header_value (dwg, "DIMDEC", &dimdec, NULL)
        && dimdec == dwg->header_vars.DIMDEC)
      pass ();
    else
      fail ("HEADER.DIMDEC [BS] %hu != %hu", dwg->header_vars.DIMDEC, dimdec);
    dimdec++;
    if (dwg_dynapi_header_set_value (dwg, "DIMDEC", &dimdec, 0)
        && dimdec == dwg->header_vars.DIMDEC)
      pass ();
    else
      fail ("HEADER.DIMDEC [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMDEC, dimdec);
    dimdec--;
    dwg_dynapi_header_set_value (dwg, "DIMDEC", &dimdec, 0);

  }
  {
    BITCODE_BS dimtdec;
    if (dwg_dynapi_header_value (dwg, "DIMTDEC", &dimtdec, NULL)
        && dimtdec == dwg->header_vars.DIMTDEC)
      pass ();
    else
      fail ("HEADER.DIMTDEC [BS] %hu != %hu", dwg->header_vars.DIMTDEC, dimtdec);
    dimtdec++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTDEC", &dimtdec, 0)
        && dimtdec == dwg->header_vars.DIMTDEC)
      pass ();
    else
      fail ("HEADER.DIMTDEC [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTDEC, dimtdec);
    dimtdec--;
    dwg_dynapi_header_set_value (dwg, "DIMTDEC", &dimtdec, 0);

  }
  {
    BITCODE_BS dimaltu;
    if (dwg_dynapi_header_value (dwg, "DIMALTU", &dimaltu, NULL)
        && dimaltu == dwg->header_vars.DIMALTU)
      pass ();
    else
      fail ("HEADER.DIMALTU [BS] %hu != %hu", dwg->header_vars.DIMALTU, dimaltu);
    dimaltu++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTU", &dimaltu, 0)
        && dimaltu == dwg->header_vars.DIMALTU)
      pass ();
    else
      fail ("HEADER.DIMALTU [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTU, dimaltu);
    dimaltu--;
    dwg_dynapi_header_set_value (dwg, "DIMALTU", &dimaltu, 0);

  }
  {
    BITCODE_BS dimalttd;
    if (dwg_dynapi_header_value (dwg, "DIMALTTD", &dimalttd, NULL)
        && dimalttd == dwg->header_vars.DIMALTTD)
      pass ();
    else
      fail ("HEADER.DIMALTTD [BS] %hu != %hu", dwg->header_vars.DIMALTTD, dimalttd);
    dimalttd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTTD", &dimalttd, 0)
        && dimalttd == dwg->header_vars.DIMALTTD)
      pass ();
    else
      fail ("HEADER.DIMALTTD [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTTD, dimalttd);
    dimalttd--;
    dwg_dynapi_header_set_value (dwg, "DIMALTTD", &dimalttd, 0);

  }
  {
    BITCODE_H dimtxsty;
    if (dwg_dynapi_header_value (dwg, "DIMTXSTY", &dimtxsty, NULL)
        && !memcmp (&dimtxsty, &dwg->header_vars.DIMTXSTY, sizeof (dwg->header_vars.DIMTXSTY))
       )
      pass ();
    else
      fail ("HEADER.DIMTXSTY [H]");
  }
  {
    BITCODE_BD dimscale;
    if (dwg_dynapi_header_value (dwg, "DIMSCALE", &dimscale, NULL)
        && dimscale == dwg->header_vars.DIMSCALE)
      pass ();
    else
      fail ("HEADER.DIMSCALE [BD] %g != %g", dwg->header_vars.DIMSCALE, dimscale);
    dimscale++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSCALE", &dimscale, 0)
        && dimscale == dwg->header_vars.DIMSCALE)
      pass ();
    else
      fail ("HEADER.DIMSCALE [BD] set+1 %g != %g",
            dwg->header_vars.DIMSCALE, dimscale);
    dimscale--;
    dwg_dynapi_header_set_value (dwg, "DIMSCALE", &dimscale, 0);

  }
  {
    BITCODE_BD dimasz;
    if (dwg_dynapi_header_value (dwg, "DIMASZ", &dimasz, NULL)
        && dimasz == dwg->header_vars.DIMASZ)
      pass ();
    else
      fail ("HEADER.DIMASZ [BD] %g != %g", dwg->header_vars.DIMASZ, dimasz);
    dimasz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMASZ", &dimasz, 0)
        && dimasz == dwg->header_vars.DIMASZ)
      pass ();
    else
      fail ("HEADER.DIMASZ [BD] set+1 %g != %g",
            dwg->header_vars.DIMASZ, dimasz);
    dimasz--;
    dwg_dynapi_header_set_value (dwg, "DIMASZ", &dimasz, 0);

  }
  {
    BITCODE_BD dimexo;
    if (dwg_dynapi_header_value (dwg, "DIMEXO", &dimexo, NULL)
        && dimexo == dwg->header_vars.DIMEXO)
      pass ();
    else
      fail ("HEADER.DIMEXO [BD] %g != %g", dwg->header_vars.DIMEXO, dimexo);
    dimexo++;
    if (dwg_dynapi_header_set_value (dwg, "DIMEXO", &dimexo, 0)
        && dimexo == dwg->header_vars.DIMEXO)
      pass ();
    else
      fail ("HEADER.DIMEXO [BD] set+1 %g != %g",
            dwg->header_vars.DIMEXO, dimexo);
    dimexo--;
    dwg_dynapi_header_set_value (dwg, "DIMEXO", &dimexo, 0);

  }
  {
    BITCODE_BD dimdli;
    if (dwg_dynapi_header_value (dwg, "DIMDLI", &dimdli, NULL)
        && dimdli == dwg->header_vars.DIMDLI)
      pass ();
    else
      fail ("HEADER.DIMDLI [BD] %g != %g", dwg->header_vars.DIMDLI, dimdli);
    dimdli++;
    if (dwg_dynapi_header_set_value (dwg, "DIMDLI", &dimdli, 0)
        && dimdli == dwg->header_vars.DIMDLI)
      pass ();
    else
      fail ("HEADER.DIMDLI [BD] set+1 %g != %g",
            dwg->header_vars.DIMDLI, dimdli);
    dimdli--;
    dwg_dynapi_header_set_value (dwg, "DIMDLI", &dimdli, 0);

  }
  {
    BITCODE_BD dimexe;
    if (dwg_dynapi_header_value (dwg, "DIMEXE", &dimexe, NULL)
        && dimexe == dwg->header_vars.DIMEXE)
      pass ();
    else
      fail ("HEADER.DIMEXE [BD] %g != %g", dwg->header_vars.DIMEXE, dimexe);
    dimexe++;
    if (dwg_dynapi_header_set_value (dwg, "DIMEXE", &dimexe, 0)
        && dimexe == dwg->header_vars.DIMEXE)
      pass ();
    else
      fail ("HEADER.DIMEXE [BD] set+1 %g != %g",
            dwg->header_vars.DIMEXE, dimexe);
    dimexe--;
    dwg_dynapi_header_set_value (dwg, "DIMEXE", &dimexe, 0);

  }
  {
    BITCODE_BD dimrnd;
    if (dwg_dynapi_header_value (dwg, "DIMRND", &dimrnd, NULL)
        && dimrnd == dwg->header_vars.DIMRND)
      pass ();
    else
      fail ("HEADER.DIMRND [BD] %g != %g", dwg->header_vars.DIMRND, dimrnd);
    dimrnd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMRND", &dimrnd, 0)
        && dimrnd == dwg->header_vars.DIMRND)
      pass ();
    else
      fail ("HEADER.DIMRND [BD] set+1 %g != %g",
            dwg->header_vars.DIMRND, dimrnd);
    dimrnd--;
    dwg_dynapi_header_set_value (dwg, "DIMRND", &dimrnd, 0);

  }
  {
    BITCODE_BD dimdle;
    if (dwg_dynapi_header_value (dwg, "DIMDLE", &dimdle, NULL)
        && dimdle == dwg->header_vars.DIMDLE)
      pass ();
    else
      fail ("HEADER.DIMDLE [BD] %g != %g", dwg->header_vars.DIMDLE, dimdle);
    dimdle++;
    if (dwg_dynapi_header_set_value (dwg, "DIMDLE", &dimdle, 0)
        && dimdle == dwg->header_vars.DIMDLE)
      pass ();
    else
      fail ("HEADER.DIMDLE [BD] set+1 %g != %g",
            dwg->header_vars.DIMDLE, dimdle);
    dimdle--;
    dwg_dynapi_header_set_value (dwg, "DIMDLE", &dimdle, 0);

  }
  {
    BITCODE_BD dimtp;
    if (dwg_dynapi_header_value (dwg, "DIMTP", &dimtp, NULL)
        && dimtp == dwg->header_vars.DIMTP)
      pass ();
    else
      fail ("HEADER.DIMTP [BD] %g != %g", dwg->header_vars.DIMTP, dimtp);
    dimtp++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTP", &dimtp, 0)
        && dimtp == dwg->header_vars.DIMTP)
      pass ();
    else
      fail ("HEADER.DIMTP [BD] set+1 %g != %g",
            dwg->header_vars.DIMTP, dimtp);
    dimtp--;
    dwg_dynapi_header_set_value (dwg, "DIMTP", &dimtp, 0);

  }
  {
    BITCODE_BD dimtm;
    if (dwg_dynapi_header_value (dwg, "DIMTM", &dimtm, NULL)
        && dimtm == dwg->header_vars.DIMTM)
      pass ();
    else
      fail ("HEADER.DIMTM [BD] %g != %g", dwg->header_vars.DIMTM, dimtm);
    dimtm++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTM", &dimtm, 0)
        && dimtm == dwg->header_vars.DIMTM)
      pass ();
    else
      fail ("HEADER.DIMTM [BD] set+1 %g != %g",
            dwg->header_vars.DIMTM, dimtm);
    dimtm--;
    dwg_dynapi_header_set_value (dwg, "DIMTM", &dimtm, 0);

  }
  {
    BITCODE_BD dimfxl;
    if (dwg_dynapi_header_value (dwg, "DIMFXL", &dimfxl, NULL)
        && dimfxl == dwg->header_vars.DIMFXL)
      pass ();
    else
      fail ("HEADER.DIMFXL [BD] %g != %g", dwg->header_vars.DIMFXL, dimfxl);
    dimfxl++;
    if (dwg_dynapi_header_set_value (dwg, "DIMFXL", &dimfxl, 0)
        && dimfxl == dwg->header_vars.DIMFXL)
      pass ();
    else
      fail ("HEADER.DIMFXL [BD] set+1 %g != %g",
            dwg->header_vars.DIMFXL, dimfxl);
    dimfxl--;
    dwg_dynapi_header_set_value (dwg, "DIMFXL", &dimfxl, 0);

  }
  {
    BITCODE_BD dimjogang;
    if (dwg_dynapi_header_value (dwg, "DIMJOGANG", &dimjogang, NULL)
        && dimjogang == dwg->header_vars.DIMJOGANG)
      pass ();
    else
      fail ("HEADER.DIMJOGANG [BD] %g != %g", dwg->header_vars.DIMJOGANG, dimjogang);
    dimjogang++;
    if (dwg_dynapi_header_set_value (dwg, "DIMJOGANG", &dimjogang, 0)
        && dimjogang == dwg->header_vars.DIMJOGANG)
      pass ();
    else
      fail ("HEADER.DIMJOGANG [BD] set+1 %g != %g",
            dwg->header_vars.DIMJOGANG, dimjogang);
    dimjogang--;
    dwg_dynapi_header_set_value (dwg, "DIMJOGANG", &dimjogang, 0);

  }
  {
    BITCODE_BS dimtfill;
    if (dwg_dynapi_header_value (dwg, "DIMTFILL", &dimtfill, NULL)
        && dimtfill == dwg->header_vars.DIMTFILL)
      pass ();
    else
      fail ("HEADER.DIMTFILL [BS] %hu != %hu", dwg->header_vars.DIMTFILL, dimtfill);
    dimtfill++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTFILL", &dimtfill, 0)
        && dimtfill == dwg->header_vars.DIMTFILL)
      pass ();
    else
      fail ("HEADER.DIMTFILL [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTFILL, dimtfill);
    dimtfill--;
    dwg_dynapi_header_set_value (dwg, "DIMTFILL", &dimtfill, 0);

  }
  {
    BITCODE_CMC dimtfillclr;
    if (dwg_dynapi_header_value (dwg, "DIMTFILLCLR", &dimtfillclr, NULL)
        && !memcmp (&dimtfillclr, &dwg->header_vars.DIMTFILLCLR, sizeof (dwg->header_vars.DIMTFILLCLR))
       )
      pass ();
    else
      fail ("HEADER.DIMTFILLCLR [CMC]");
  }
  {
    BITCODE_BS dimazin;
    if (dwg_dynapi_header_value (dwg, "DIMAZIN", &dimazin, NULL)
        && dimazin == dwg->header_vars.DIMAZIN)
      pass ();
    else
      fail ("HEADER.DIMAZIN [BS] %hu != %hu", dwg->header_vars.DIMAZIN, dimazin);
    dimazin++;
    if (dwg_dynapi_header_set_value (dwg, "DIMAZIN", &dimazin, 0)
        && dimazin == dwg->header_vars.DIMAZIN)
      pass ();
    else
      fail ("HEADER.DIMAZIN [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMAZIN, dimazin);
    dimazin--;
    dwg_dynapi_header_set_value (dwg, "DIMAZIN", &dimazin, 0);

  }
  {
    BITCODE_BS dimarcsym;
    if (dwg_dynapi_header_value (dwg, "DIMARCSYM", &dimarcsym, NULL)
        && dimarcsym == dwg->header_vars.DIMARCSYM)
      pass ();
    else
      fail ("HEADER.DIMARCSYM [BS] %hu != %hu", dwg->header_vars.DIMARCSYM, dimarcsym);
    dimarcsym++;
    if (dwg_dynapi_header_set_value (dwg, "DIMARCSYM", &dimarcsym, 0)
        && dimarcsym == dwg->header_vars.DIMARCSYM)
      pass ();
    else
      fail ("HEADER.DIMARCSYM [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMARCSYM, dimarcsym);
    dimarcsym--;
    dwg_dynapi_header_set_value (dwg, "DIMARCSYM", &dimarcsym, 0);

  }
  {
    BITCODE_BD dimtxt;
    if (dwg_dynapi_header_value (dwg, "DIMTXT", &dimtxt, NULL)
        && dimtxt == dwg->header_vars.DIMTXT)
      pass ();
    else
      fail ("HEADER.DIMTXT [BD] %g != %g", dwg->header_vars.DIMTXT, dimtxt);
    dimtxt++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTXT", &dimtxt, 0)
        && dimtxt == dwg->header_vars.DIMTXT)
      pass ();
    else
      fail ("HEADER.DIMTXT [BD] set+1 %g != %g",
            dwg->header_vars.DIMTXT, dimtxt);
    dimtxt--;
    dwg_dynapi_header_set_value (dwg, "DIMTXT", &dimtxt, 0);

  }
  {
    BITCODE_BD dimcen;
    if (dwg_dynapi_header_value (dwg, "DIMCEN", &dimcen, NULL)
        && dimcen == dwg->header_vars.DIMCEN)
      pass ();
    else
      fail ("HEADER.DIMCEN [BD] %g != %g", dwg->header_vars.DIMCEN, dimcen);
    dimcen++;
    if (dwg_dynapi_header_set_value (dwg, "DIMCEN", &dimcen, 0)
        && dimcen == dwg->header_vars.DIMCEN)
      pass ();
    else
      fail ("HEADER.DIMCEN [BD] set+1 %g != %g",
            dwg->header_vars.DIMCEN, dimcen);
    dimcen--;
    dwg_dynapi_header_set_value (dwg, "DIMCEN", &dimcen, 0);

  }
  {
    BITCODE_BD dimtsz;
    if (dwg_dynapi_header_value (dwg, "DIMTSZ", &dimtsz, NULL)
        && dimtsz == dwg->header_vars.DIMTSZ)
      pass ();
    else
      fail ("HEADER.DIMTSZ [BD] %g != %g", dwg->header_vars.DIMTSZ, dimtsz);
    dimtsz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTSZ", &dimtsz, 0)
        && dimtsz == dwg->header_vars.DIMTSZ)
      pass ();
    else
      fail ("HEADER.DIMTSZ [BD] set+1 %g != %g",
            dwg->header_vars.DIMTSZ, dimtsz);
    dimtsz--;
    dwg_dynapi_header_set_value (dwg, "DIMTSZ", &dimtsz, 0);

  }
  {
    BITCODE_BD dimaltf;
    if (dwg_dynapi_header_value (dwg, "DIMALTF", &dimaltf, NULL)
        && dimaltf == dwg->header_vars.DIMALTF)
      pass ();
    else
      fail ("HEADER.DIMALTF [BD] %g != %g", dwg->header_vars.DIMALTF, dimaltf);
    dimaltf++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTF", &dimaltf, 0)
        && dimaltf == dwg->header_vars.DIMALTF)
      pass ();
    else
      fail ("HEADER.DIMALTF [BD] set+1 %g != %g",
            dwg->header_vars.DIMALTF, dimaltf);
    dimaltf--;
    dwg_dynapi_header_set_value (dwg, "DIMALTF", &dimaltf, 0);

  }
  {
    BITCODE_BD dimlfac;
    if (dwg_dynapi_header_value (dwg, "DIMLFAC", &dimlfac, NULL)
        && dimlfac == dwg->header_vars.DIMLFAC)
      pass ();
    else
      fail ("HEADER.DIMLFAC [BD] %g != %g", dwg->header_vars.DIMLFAC, dimlfac);
    dimlfac++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLFAC", &dimlfac, 0)
        && dimlfac == dwg->header_vars.DIMLFAC)
      pass ();
    else
      fail ("HEADER.DIMLFAC [BD] set+1 %g != %g",
            dwg->header_vars.DIMLFAC, dimlfac);
    dimlfac--;
    dwg_dynapi_header_set_value (dwg, "DIMLFAC", &dimlfac, 0);

  }
  {
    BITCODE_BD dimtvp;
    if (dwg_dynapi_header_value (dwg, "DIMTVP", &dimtvp, NULL)
        && dimtvp == dwg->header_vars.DIMTVP)
      pass ();
    else
      fail ("HEADER.DIMTVP [BD] %g != %g", dwg->header_vars.DIMTVP, dimtvp);
    dimtvp++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTVP", &dimtvp, 0)
        && dimtvp == dwg->header_vars.DIMTVP)
      pass ();
    else
      fail ("HEADER.DIMTVP [BD] set+1 %g != %g",
            dwg->header_vars.DIMTVP, dimtvp);
    dimtvp--;
    dwg_dynapi_header_set_value (dwg, "DIMTVP", &dimtvp, 0);

  }
  {
    BITCODE_BD dimtfac;
    if (dwg_dynapi_header_value (dwg, "DIMTFAC", &dimtfac, NULL)
        && dimtfac == dwg->header_vars.DIMTFAC)
      pass ();
    else
      fail ("HEADER.DIMTFAC [BD] %g != %g", dwg->header_vars.DIMTFAC, dimtfac);
    dimtfac++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTFAC", &dimtfac, 0)
        && dimtfac == dwg->header_vars.DIMTFAC)
      pass ();
    else
      fail ("HEADER.DIMTFAC [BD] set+1 %g != %g",
            dwg->header_vars.DIMTFAC, dimtfac);
    dimtfac--;
    dwg_dynapi_header_set_value (dwg, "DIMTFAC", &dimtfac, 0);

  }
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_header_value (dwg, "DIMGAP", &dimgap, NULL)
        && dimgap == dwg->header_vars.DIMGAP)
      pass ();
    else
      fail ("HEADER.DIMGAP [BD] %g != %g", dwg->header_vars.DIMGAP, dimgap);
    dimgap++;
    if (dwg_dynapi_header_set_value (dwg, "DIMGAP", &dimgap, 0)
        && dimgap == dwg->header_vars.DIMGAP)
      pass ();
    else
      fail ("HEADER.DIMGAP [BD] set+1 %g != %g",
            dwg->header_vars.DIMGAP, dimgap);
    dimgap--;
    dwg_dynapi_header_set_value (dwg, "DIMGAP", &dimgap, 0);

  }
  {
    BITCODE_T dimpost_t;
    if (dwg_dynapi_header_value (dwg, "DIMPOST_T", &dimpost_t, NULL)
        && !memcmp (&dimpost_t, &dwg->header_vars.DIMPOST_T, sizeof (dwg->header_vars.DIMPOST_T))
       )
      pass ();
    else
      fail ("HEADER.DIMPOST_T [T]");
  }
  {
    BITCODE_T dimapost_t;
    if (dwg_dynapi_header_value (dwg, "DIMAPOST_T", &dimapost_t, NULL)
        && !memcmp (&dimapost_t, &dwg->header_vars.DIMAPOST_T, sizeof (dwg->header_vars.DIMAPOST_T))
       )
      pass ();
    else
      fail ("HEADER.DIMAPOST_T [T]");
  }
  {
    BITCODE_T dimblk_t;
    if (dwg_dynapi_header_value (dwg, "DIMBLK_T", &dimblk_t, NULL)
        && !memcmp (&dimblk_t, &dwg->header_vars.DIMBLK_T, sizeof (dwg->header_vars.DIMBLK_T))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK_T [T]");
  }
  {
    BITCODE_T dimblk1_t;
    if (dwg_dynapi_header_value (dwg, "DIMBLK1_T", &dimblk1_t, NULL)
        && !memcmp (&dimblk1_t, &dwg->header_vars.DIMBLK1_T, sizeof (dwg->header_vars.DIMBLK1_T))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK1_T [T]");
  }
  {
    BITCODE_T dimblk2_t;
    if (dwg_dynapi_header_value (dwg, "DIMBLK2_T", &dimblk2_t, NULL)
        && !memcmp (&dimblk2_t, &dwg->header_vars.DIMBLK2_T, sizeof (dwg->header_vars.DIMBLK2_T))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK2_T [T]");
  }
  {
    BITCODE_BD dimaltrnd;
    if (dwg_dynapi_header_value (dwg, "DIMALTRND", &dimaltrnd, NULL)
        && dimaltrnd == dwg->header_vars.DIMALTRND)
      pass ();
    else
      fail ("HEADER.DIMALTRND [BD] %g != %g", dwg->header_vars.DIMALTRND, dimaltrnd);
    dimaltrnd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTRND", &dimaltrnd, 0)
        && dimaltrnd == dwg->header_vars.DIMALTRND)
      pass ();
    else
      fail ("HEADER.DIMALTRND [BD] set+1 %g != %g",
            dwg->header_vars.DIMALTRND, dimaltrnd);
    dimaltrnd--;
    dwg_dynapi_header_set_value (dwg, "DIMALTRND", &dimaltrnd, 0);

  }
  {
    BITCODE_RS dimclrd_c;
    if (dwg_dynapi_header_value (dwg, "DIMCLRD_C", &dimclrd_c, NULL)
        && dimclrd_c == dwg->header_vars.DIMCLRD_C)
      pass ();
    else
      fail ("HEADER.DIMCLRD_C [RS] %hu != %hu", dwg->header_vars.DIMCLRD_C, dimclrd_c);
    dimclrd_c++;
    if (dwg_dynapi_header_set_value (dwg, "DIMCLRD_C", &dimclrd_c, 0)
        && dimclrd_c == dwg->header_vars.DIMCLRD_C)
      pass ();
    else
      fail ("HEADER.DIMCLRD_C [RS] set+1 %hu != %hu",
            dwg->header_vars.DIMCLRD_C, dimclrd_c);
    dimclrd_c--;
    dwg_dynapi_header_set_value (dwg, "DIMCLRD_C", &dimclrd_c, 0);

  }
  {
    BITCODE_RS dimclre_c;
    if (dwg_dynapi_header_value (dwg, "DIMCLRE_C", &dimclre_c, NULL)
        && dimclre_c == dwg->header_vars.DIMCLRE_C)
      pass ();
    else
      fail ("HEADER.DIMCLRE_C [RS] %hu != %hu", dwg->header_vars.DIMCLRE_C, dimclre_c);
    dimclre_c++;
    if (dwg_dynapi_header_set_value (dwg, "DIMCLRE_C", &dimclre_c, 0)
        && dimclre_c == dwg->header_vars.DIMCLRE_C)
      pass ();
    else
      fail ("HEADER.DIMCLRE_C [RS] set+1 %hu != %hu",
            dwg->header_vars.DIMCLRE_C, dimclre_c);
    dimclre_c--;
    dwg_dynapi_header_set_value (dwg, "DIMCLRE_C", &dimclre_c, 0);

  }
  {
    BITCODE_RS dimclrt_c;
    if (dwg_dynapi_header_value (dwg, "DIMCLRT_C", &dimclrt_c, NULL)
        && dimclrt_c == dwg->header_vars.DIMCLRT_C)
      pass ();
    else
      fail ("HEADER.DIMCLRT_C [RS] %hu != %hu", dwg->header_vars.DIMCLRT_C, dimclrt_c);
    dimclrt_c++;
    if (dwg_dynapi_header_set_value (dwg, "DIMCLRT_C", &dimclrt_c, 0)
        && dimclrt_c == dwg->header_vars.DIMCLRT_C)
      pass ();
    else
      fail ("HEADER.DIMCLRT_C [RS] set+1 %hu != %hu",
            dwg->header_vars.DIMCLRT_C, dimclrt_c);
    dimclrt_c--;
    dwg_dynapi_header_set_value (dwg, "DIMCLRT_C", &dimclrt_c, 0);

  }
  {
    BITCODE_CMC dimclrd;
    if (dwg_dynapi_header_value (dwg, "DIMCLRD", &dimclrd, NULL)
        && !memcmp (&dimclrd, &dwg->header_vars.DIMCLRD, sizeof (dwg->header_vars.DIMCLRD))
       )
      pass ();
    else
      fail ("HEADER.DIMCLRD [CMC]");
  }
  {
    BITCODE_CMC dimclre;
    if (dwg_dynapi_header_value (dwg, "DIMCLRE", &dimclre, NULL)
        && !memcmp (&dimclre, &dwg->header_vars.DIMCLRE, sizeof (dwg->header_vars.DIMCLRE))
       )
      pass ();
    else
      fail ("HEADER.DIMCLRE [CMC]");
  }
  {
    BITCODE_CMC dimclrt;
    if (dwg_dynapi_header_value (dwg, "DIMCLRT", &dimclrt, NULL)
        && !memcmp (&dimclrt, &dwg->header_vars.DIMCLRT, sizeof (dwg->header_vars.DIMCLRT))
       )
      pass ();
    else
      fail ("HEADER.DIMCLRT [CMC]");
  }
  {
    BITCODE_BS dimadec;
    if (dwg_dynapi_header_value (dwg, "DIMADEC", &dimadec, NULL)
        && dimadec == dwg->header_vars.DIMADEC)
      pass ();
    else
      fail ("HEADER.DIMADEC [BS] %hu != %hu", dwg->header_vars.DIMADEC, dimadec);
    dimadec++;
    if (dwg_dynapi_header_set_value (dwg, "DIMADEC", &dimadec, 0)
        && dimadec == dwg->header_vars.DIMADEC)
      pass ();
    else
      fail ("HEADER.DIMADEC [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMADEC, dimadec);
    dimadec--;
    dwg_dynapi_header_set_value (dwg, "DIMADEC", &dimadec, 0);

  }
  {
    BITCODE_BS dimfrac;
    if (dwg_dynapi_header_value (dwg, "DIMFRAC", &dimfrac, NULL)
        && dimfrac == dwg->header_vars.DIMFRAC)
      pass ();
    else
      fail ("HEADER.DIMFRAC [BS] %hu != %hu", dwg->header_vars.DIMFRAC, dimfrac);
    dimfrac++;
    if (dwg_dynapi_header_set_value (dwg, "DIMFRAC", &dimfrac, 0)
        && dimfrac == dwg->header_vars.DIMFRAC)
      pass ();
    else
      fail ("HEADER.DIMFRAC [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMFRAC, dimfrac);
    dimfrac--;
    dwg_dynapi_header_set_value (dwg, "DIMFRAC", &dimfrac, 0);

  }
  {
    BITCODE_BS dimlunit;
    if (dwg_dynapi_header_value (dwg, "DIMLUNIT", &dimlunit, NULL)
        && dimlunit == dwg->header_vars.DIMLUNIT)
      pass ();
    else
      fail ("HEADER.DIMLUNIT [BS] %hu != %hu", dwg->header_vars.DIMLUNIT, dimlunit);
    dimlunit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLUNIT", &dimlunit, 0)
        && dimlunit == dwg->header_vars.DIMLUNIT)
      pass ();
    else
      fail ("HEADER.DIMLUNIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMLUNIT, dimlunit);
    dimlunit--;
    dwg_dynapi_header_set_value (dwg, "DIMLUNIT", &dimlunit, 0);

  }
  {
    BITCODE_BS dimdsep;
    if (dwg_dynapi_header_value (dwg, "DIMDSEP", &dimdsep, NULL)
        && dimdsep == dwg->header_vars.DIMDSEP)
      pass ();
    else
      fail ("HEADER.DIMDSEP [BS] %hu != %hu", dwg->header_vars.DIMDSEP, dimdsep);
    dimdsep++;
    if (dwg_dynapi_header_set_value (dwg, "DIMDSEP", &dimdsep, 0)
        && dimdsep == dwg->header_vars.DIMDSEP)
      pass ();
    else
      fail ("HEADER.DIMDSEP [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMDSEP, dimdsep);
    dimdsep--;
    dwg_dynapi_header_set_value (dwg, "DIMDSEP", &dimdsep, 0);

  }
  {
    BITCODE_BS dimtmove;
    if (dwg_dynapi_header_value (dwg, "DIMTMOVE", &dimtmove, NULL)
        && dimtmove == dwg->header_vars.DIMTMOVE)
      pass ();
    else
      fail ("HEADER.DIMTMOVE [BS] %hu != %hu", dwg->header_vars.DIMTMOVE, dimtmove);
    dimtmove++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTMOVE", &dimtmove, 0)
        && dimtmove == dwg->header_vars.DIMTMOVE)
      pass ();
    else
      fail ("HEADER.DIMTMOVE [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTMOVE, dimtmove);
    dimtmove--;
    dwg_dynapi_header_set_value (dwg, "DIMTMOVE", &dimtmove, 0);

  }
  {
    BITCODE_BS dimaltz;
    if (dwg_dynapi_header_value (dwg, "DIMALTZ", &dimaltz, NULL)
        && dimaltz == dwg->header_vars.DIMALTZ)
      pass ();
    else
      fail ("HEADER.DIMALTZ [BS] %hu != %hu", dwg->header_vars.DIMALTZ, dimaltz);
    dimaltz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTZ", &dimaltz, 0)
        && dimaltz == dwg->header_vars.DIMALTZ)
      pass ();
    else
      fail ("HEADER.DIMALTZ [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTZ, dimaltz);
    dimaltz--;
    dwg_dynapi_header_set_value (dwg, "DIMALTZ", &dimaltz, 0);

  }
  {
    BITCODE_BS dimalttz;
    if (dwg_dynapi_header_value (dwg, "DIMALTTZ", &dimalttz, NULL)
        && dimalttz == dwg->header_vars.DIMALTTZ)
      pass ();
    else
      fail ("HEADER.DIMALTTZ [BS] %hu != %hu", dwg->header_vars.DIMALTTZ, dimalttz);
    dimalttz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTTZ", &dimalttz, 0)
        && dimalttz == dwg->header_vars.DIMALTTZ)
      pass ();
    else
      fail ("HEADER.DIMALTTZ [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTTZ, dimalttz);
    dimalttz--;
    dwg_dynapi_header_set_value (dwg, "DIMALTTZ", &dimalttz, 0);

  }
  {
    BITCODE_BS dimatfit;
    if (dwg_dynapi_header_value (dwg, "DIMATFIT", &dimatfit, NULL)
        && dimatfit == dwg->header_vars.DIMATFIT)
      pass ();
    else
      fail ("HEADER.DIMATFIT [BS] %hu != %hu", dwg->header_vars.DIMATFIT, dimatfit);
    dimatfit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMATFIT", &dimatfit, 0)
        && dimatfit == dwg->header_vars.DIMATFIT)
      pass ();
    else
      fail ("HEADER.DIMATFIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMATFIT, dimatfit);
    dimatfit--;
    dwg_dynapi_header_set_value (dwg, "DIMATFIT", &dimatfit, 0);

  }
  {
    BITCODE_B dimfxlon;
    if (dwg_dynapi_header_value (dwg, "DIMFXLON", &dimfxlon, NULL)
        && dimfxlon == dwg->header_vars.DIMFXLON)
      pass ();
    else
      fail ("HEADER.DIMFXLON [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMFXLON, dimfxlon);
    dimfxlon++;
    if (dwg_dynapi_header_set_value (dwg, "DIMFXLON", &dimfxlon, 0)
        && dimfxlon == dwg->header_vars.DIMFXLON)
      pass ();
    else
      fail ("HEADER.DIMFXLON [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMFXLON, dimfxlon);
    dimfxlon--;
    dwg_dynapi_header_set_value (dwg, "DIMFXLON", &dimfxlon, 0);

  }
  {
    BITCODE_B dimtxtdirection;
    if (dwg_dynapi_header_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, NULL)
        && dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
      pass ();
    else
      fail ("HEADER.DIMTXTDIRECTION [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection);
    dimtxtdirection++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, 0)
        && dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
      pass ();
    else
      fail ("HEADER.DIMTXTDIRECTION [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection);
    dimtxtdirection--;
    dwg_dynapi_header_set_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, 0);

  }
  {
    BITCODE_BD dimaltmzf;
    if (dwg_dynapi_header_value (dwg, "DIMALTMZF", &dimaltmzf, NULL)
        && dimaltmzf == dwg->header_vars.DIMALTMZF)
      pass ();
    else
      fail ("HEADER.DIMALTMZF [BD] %g != %g", dwg->header_vars.DIMALTMZF, dimaltmzf);
    dimaltmzf++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTMZF", &dimaltmzf, 0)
        && dimaltmzf == dwg->header_vars.DIMALTMZF)
      pass ();
    else
      fail ("HEADER.DIMALTMZF [BD] set+1 %g != %g",
            dwg->header_vars.DIMALTMZF, dimaltmzf);
    dimaltmzf--;
    dwg_dynapi_header_set_value (dwg, "DIMALTMZF", &dimaltmzf, 0);

  }
  {
    BITCODE_T dimaltmzs;
    if (dwg_dynapi_header_value (dwg, "DIMALTMZS", &dimaltmzs, NULL)
        && !memcmp (&dimaltmzs, &dwg->header_vars.DIMALTMZS, sizeof (dwg->header_vars.DIMALTMZS))
       )
      pass ();
    else
      fail ("HEADER.DIMALTMZS [T]");
  }
  {
    BITCODE_BD dimmzf;
    if (dwg_dynapi_header_value (dwg, "DIMMZF", &dimmzf, NULL)
        && dimmzf == dwg->header_vars.DIMMZF)
      pass ();
    else
      fail ("HEADER.DIMMZF [BD] %g != %g", dwg->header_vars.DIMMZF, dimmzf);
    dimmzf++;
    if (dwg_dynapi_header_set_value (dwg, "DIMMZF", &dimmzf, 0)
        && dimmzf == dwg->header_vars.DIMMZF)
      pass ();
    else
      fail ("HEADER.DIMMZF [BD] set+1 %g != %g",
            dwg->header_vars.DIMMZF, dimmzf);
    dimmzf--;
    dwg_dynapi_header_set_value (dwg, "DIMMZF", &dimmzf, 0);

  }
  {
    BITCODE_T dimmzs;
    if (dwg_dynapi_header_value (dwg, "DIMMZS", &dimmzs, NULL)
        && !memcmp (&dimmzs, &dwg->header_vars.DIMMZS, sizeof (dwg->header_vars.DIMMZS))
       )
      pass ();
    else
      fail ("HEADER.DIMMZS [T]");
  }
  {
    BITCODE_H dimldrblk;
    if (dwg_dynapi_header_value (dwg, "DIMLDRBLK", &dimldrblk, NULL)
        && !memcmp (&dimldrblk, &dwg->header_vars.DIMLDRBLK, sizeof (dwg->header_vars.DIMLDRBLK))
       )
      pass ();
    else
      fail ("HEADER.DIMLDRBLK [H]");
  }
  {
    BITCODE_H dimblk;
    if (dwg_dynapi_header_value (dwg, "DIMBLK", &dimblk, NULL)
        && !memcmp (&dimblk, &dwg->header_vars.DIMBLK, sizeof (dwg->header_vars.DIMBLK))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK [H]");
  }
  {
    BITCODE_H dimblk1;
    if (dwg_dynapi_header_value (dwg, "DIMBLK1", &dimblk1, NULL)
        && !memcmp (&dimblk1, &dwg->header_vars.DIMBLK1, sizeof (dwg->header_vars.DIMBLK1))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK1 [H]");
  }
  {
    BITCODE_H dimblk2;
    if (dwg_dynapi_header_value (dwg, "DIMBLK2", &dimblk2, NULL)
        && !memcmp (&dimblk2, &dwg->header_vars.DIMBLK2, sizeof (dwg->header_vars.DIMBLK2))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK2 [H]");
  }
  {
    BITCODE_H dimltype;
    if (dwg_dynapi_header_value (dwg, "DIMLTYPE", &dimltype, NULL)
        && !memcmp (&dimltype, &dwg->header_vars.DIMLTYPE, sizeof (dwg->header_vars.DIMLTYPE))
       )
      pass ();
    else
      fail ("HEADER.DIMLTYPE [H]");
  }
  {
    BITCODE_H dimltex1;
    if (dwg_dynapi_header_value (dwg, "DIMLTEX1", &dimltex1, NULL)
        && !memcmp (&dimltex1, &dwg->header_vars.DIMLTEX1, sizeof (dwg->header_vars.DIMLTEX1))
       )
      pass ();
    else
      fail ("HEADER.DIMLTEX1 [H]");
  }
  {
    BITCODE_H dimltex2;
    if (dwg_dynapi_header_value (dwg, "DIMLTEX2", &dimltex2, NULL)
        && !memcmp (&dimltex2, &dwg->header_vars.DIMLTEX2, sizeof (dwg->header_vars.DIMLTEX2))
       )
      pass ();
    else
      fail ("HEADER.DIMLTEX2 [H]");
  }
  {
    BITCODE_BSd dimlwd;
    if (dwg_dynapi_header_value (dwg, "DIMLWD", &dimlwd, NULL)
        && dimlwd == dwg->header_vars.DIMLWD)
      pass ();
    else
      fail ("HEADER.DIMLWD [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.DIMLWD, dimlwd);
    dimlwd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLWD", &dimlwd, 0)
        && dimlwd == dwg->header_vars.DIMLWD)
      pass ();
    else
      fail ("HEADER.DIMLWD [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.DIMLWD, dimlwd);
    dimlwd--;
    dwg_dynapi_header_set_value (dwg, "DIMLWD", &dimlwd, 0);

  }
  {
    BITCODE_BSd dimlwe;
    if (dwg_dynapi_header_value (dwg, "DIMLWE", &dimlwe, NULL)
        && dimlwe == dwg->header_vars.DIMLWE)
      pass ();
    else
      fail ("HEADER.DIMLWE [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.DIMLWE, dimlwe);
    dimlwe++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLWE", &dimlwe, 0)
        && dimlwe == dwg->header_vars.DIMLWE)
      pass ();
    else
      fail ("HEADER.DIMLWE [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.DIMLWE, dimlwe);
    dimlwe--;
    dwg_dynapi_header_set_value (dwg, "DIMLWE", &dimlwe, 0);

  }
  {
    BITCODE_H block_control_object;
    if (dwg_dynapi_header_value (dwg, "BLOCK_CONTROL_OBJECT", &block_control_object, NULL)
        && !memcmp (&block_control_object, &dwg->header_vars.BLOCK_CONTROL_OBJECT, sizeof (dwg->header_vars.BLOCK_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.BLOCK_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H layer_control_object;
    if (dwg_dynapi_header_value (dwg, "LAYER_CONTROL_OBJECT", &layer_control_object, NULL)
        && !memcmp (&layer_control_object, &dwg->header_vars.LAYER_CONTROL_OBJECT, sizeof (dwg->header_vars.LAYER_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.LAYER_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H style_control_object;
    if (dwg_dynapi_header_value (dwg, "STYLE_CONTROL_OBJECT", &style_control_object, NULL)
        && !memcmp (&style_control_object, &dwg->header_vars.STYLE_CONTROL_OBJECT, sizeof (dwg->header_vars.STYLE_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.STYLE_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H ltype_control_object;
    if (dwg_dynapi_header_value (dwg, "LTYPE_CONTROL_OBJECT", &ltype_control_object, NULL)
        && !memcmp (&ltype_control_object, &dwg->header_vars.LTYPE_CONTROL_OBJECT, sizeof (dwg->header_vars.LTYPE_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.LTYPE_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H view_control_object;
    if (dwg_dynapi_header_value (dwg, "VIEW_CONTROL_OBJECT", &view_control_object, NULL)
        && !memcmp (&view_control_object, &dwg->header_vars.VIEW_CONTROL_OBJECT, sizeof (dwg->header_vars.VIEW_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.VIEW_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H ucs_control_object;
    if (dwg_dynapi_header_value (dwg, "UCS_CONTROL_OBJECT", &ucs_control_object, NULL)
        && !memcmp (&ucs_control_object, &dwg->header_vars.UCS_CONTROL_OBJECT, sizeof (dwg->header_vars.UCS_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.UCS_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H vport_control_object;
    if (dwg_dynapi_header_value (dwg, "VPORT_CONTROL_OBJECT", &vport_control_object, NULL)
        && !memcmp (&vport_control_object, &dwg->header_vars.VPORT_CONTROL_OBJECT, sizeof (dwg->header_vars.VPORT_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.VPORT_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H appid_control_object;
    if (dwg_dynapi_header_value (dwg, "APPID_CONTROL_OBJECT", &appid_control_object, NULL)
        && !memcmp (&appid_control_object, &dwg->header_vars.APPID_CONTROL_OBJECT, sizeof (dwg->header_vars.APPID_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.APPID_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H dimstyle_control_object;
    if (dwg_dynapi_header_value (dwg, "DIMSTYLE_CONTROL_OBJECT", &dimstyle_control_object, NULL)
        && !memcmp (&dimstyle_control_object, &dwg->header_vars.DIMSTYLE_CONTROL_OBJECT, sizeof (dwg->header_vars.DIMSTYLE_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.DIMSTYLE_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H vport_entity_control_object;
    if (dwg_dynapi_header_value (dwg, "VPORT_ENTITY_CONTROL_OBJECT", &vport_entity_control_object, NULL)
        && !memcmp (&vport_entity_control_object, &dwg->header_vars.VPORT_ENTITY_CONTROL_OBJECT, sizeof (dwg->header_vars.VPORT_ENTITY_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.VPORT_ENTITY_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H dictionary_acad_group;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_ACAD_GROUP", &dictionary_acad_group, NULL)
        && !memcmp (&dictionary_acad_group, &dwg->header_vars.DICTIONARY_ACAD_GROUP, sizeof (dwg->header_vars.DICTIONARY_ACAD_GROUP))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_ACAD_GROUP [H]");
  }
  {
    BITCODE_H dictionary_acad_mlinestyle;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_ACAD_MLINESTYLE", &dictionary_acad_mlinestyle, NULL)
        && !memcmp (&dictionary_acad_mlinestyle, &dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE, sizeof (dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_ACAD_MLINESTYLE [H]");
  }
  {
    BITCODE_H dictionary_named_object;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_NAMED_OBJECT", &dictionary_named_object, NULL)
        && !memcmp (&dictionary_named_object, &dwg->header_vars.DICTIONARY_NAMED_OBJECT, sizeof (dwg->header_vars.DICTIONARY_NAMED_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_NAMED_OBJECT [H]");
  }
  {
    BITCODE_BS tstackalign;
    if (dwg_dynapi_header_value (dwg, "TSTACKALIGN", &tstackalign, NULL)
        && tstackalign == dwg->header_vars.TSTACKALIGN)
      pass ();
    else
      fail ("HEADER.TSTACKALIGN [BS] %hu != %hu", dwg->header_vars.TSTACKALIGN, tstackalign);
    tstackalign++;
    if (dwg_dynapi_header_set_value (dwg, "TSTACKALIGN", &tstackalign, 0)
        && tstackalign == dwg->header_vars.TSTACKALIGN)
      pass ();
    else
      fail ("HEADER.TSTACKALIGN [BS] set+1 %hu != %hu",
            dwg->header_vars.TSTACKALIGN, tstackalign);
    tstackalign--;
    dwg_dynapi_header_set_value (dwg, "TSTACKALIGN", &tstackalign, 0);

  }
  {
    BITCODE_BS tstacksize;
    if (dwg_dynapi_header_value (dwg, "TSTACKSIZE", &tstacksize, NULL)
        && tstacksize == dwg->header_vars.TSTACKSIZE)
      pass ();
    else
      fail ("HEADER.TSTACKSIZE [BS] %hu != %hu", dwg->header_vars.TSTACKSIZE, tstacksize);
    tstacksize++;
    if (dwg_dynapi_header_set_value (dwg, "TSTACKSIZE", &tstacksize, 0)
        && tstacksize == dwg->header_vars.TSTACKSIZE)
      pass ();
    else
      fail ("HEADER.TSTACKSIZE [BS] set+1 %hu != %hu",
            dwg->header_vars.TSTACKSIZE, tstacksize);
    tstacksize--;
    dwg_dynapi_header_set_value (dwg, "TSTACKSIZE", &tstacksize, 0);

  }
  {
    BITCODE_TV hyperlinkbase;
    if (dwg_dynapi_header_value (dwg, "HYPERLINKBASE", &hyperlinkbase, NULL)
        && !memcmp (&hyperlinkbase, &dwg->header_vars.HYPERLINKBASE, sizeof (dwg->header_vars.HYPERLINKBASE))
       )
      pass ();
    else
      fail ("HEADER.HYPERLINKBASE [TV]");
  }
  {
    BITCODE_TV stylesheet;
    if (dwg_dynapi_header_value (dwg, "STYLESHEET", &stylesheet, NULL)
        && !memcmp (&stylesheet, &dwg->header_vars.STYLESHEET, sizeof (dwg->header_vars.STYLESHEET))
       )
      pass ();
    else
      fail ("HEADER.STYLESHEET [TV]");
  }
  {
    BITCODE_H dictionary_layout;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_LAYOUT", &dictionary_layout, NULL)
        && !memcmp (&dictionary_layout, &dwg->header_vars.DICTIONARY_LAYOUT, sizeof (dwg->header_vars.DICTIONARY_LAYOUT))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_LAYOUT [H]");
  }
  {
    BITCODE_H dictionary_plotsettings;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_PLOTSETTINGS", &dictionary_plotsettings, NULL)
        && !memcmp (&dictionary_plotsettings, &dwg->header_vars.DICTIONARY_PLOTSETTINGS, sizeof (dwg->header_vars.DICTIONARY_PLOTSETTINGS))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_PLOTSETTINGS [H]");
  }
  {
    BITCODE_H dictionary_plotstylename;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_PLOTSTYLENAME", &dictionary_plotstylename, NULL)
        && !memcmp (&dictionary_plotstylename, &dwg->header_vars.DICTIONARY_PLOTSTYLENAME, sizeof (dwg->header_vars.DICTIONARY_PLOTSTYLENAME))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_PLOTSTYLENAME [H]");
  }
  {
    BITCODE_H dictionary_material;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_MATERIAL", &dictionary_material, NULL)
        && !memcmp (&dictionary_material, &dwg->header_vars.DICTIONARY_MATERIAL, sizeof (dwg->header_vars.DICTIONARY_MATERIAL))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_MATERIAL [H]");
  }
  {
    BITCODE_H dictionary_color;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_COLOR", &dictionary_color, NULL)
        && !memcmp (&dictionary_color, &dwg->header_vars.DICTIONARY_COLOR, sizeof (dwg->header_vars.DICTIONARY_COLOR))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_COLOR [H]");
  }
  {
    BITCODE_H dictionary_visualstyle;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_VISUALSTYLE", &dictionary_visualstyle, NULL)
        && !memcmp (&dictionary_visualstyle, &dwg->header_vars.DICTIONARY_VISUALSTYLE, sizeof (dwg->header_vars.DICTIONARY_VISUALSTYLE))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_VISUALSTYLE [H]");
  }
  {
    BITCODE_H dictionary_lightlist;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_LIGHTLIST", &dictionary_lightlist, NULL)
        && !memcmp (&dictionary_lightlist, &dwg->header_vars.DICTIONARY_LIGHTLIST, sizeof (dwg->header_vars.DICTIONARY_LIGHTLIST))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_LIGHTLIST [H]");
  }
  {
    BITCODE_H unknown_20;
    if (dwg_dynapi_header_value (dwg, "unknown_20", &unknown_20, NULL)
        && !memcmp (&unknown_20, &dwg->header_vars.unknown_20, sizeof (dwg->header_vars.unknown_20))
       )
      pass ();
    else
      fail ("HEADER.unknown_20 [H]");
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_header_value (dwg, "FLAGS", &flags, NULL)
        && flags == dwg->header_vars.FLAGS)
      pass ();
    else
      fail ("HEADER.FLAGS [BL] %u != %u", dwg->header_vars.FLAGS, flags);
    flags++;
    if (dwg_dynapi_header_set_value (dwg, "FLAGS", &flags, 0)
        && flags == dwg->header_vars.FLAGS)
      pass ();
    else
      fail ("HEADER.FLAGS [BL] set+1 %u != %u",
            dwg->header_vars.FLAGS, flags);
    flags--;
    dwg_dynapi_header_set_value (dwg, "FLAGS", &flags, 0);

  }
  {
    BITCODE_BSd celweight;
    if (dwg_dynapi_header_value (dwg, "CELWEIGHT", &celweight, NULL)
        && celweight == dwg->header_vars.CELWEIGHT)
      pass ();
    else
      fail ("HEADER.CELWEIGHT [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.CELWEIGHT, celweight);
    celweight++;
    if (dwg_dynapi_header_set_value (dwg, "CELWEIGHT", &celweight, 0)
        && celweight == dwg->header_vars.CELWEIGHT)
      pass ();
    else
      fail ("HEADER.CELWEIGHT [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.CELWEIGHT, celweight);
    celweight--;
    dwg_dynapi_header_set_value (dwg, "CELWEIGHT", &celweight, 0);

  }
  {
    BITCODE_B endcaps;
    if (dwg_dynapi_header_value (dwg, "ENDCAPS", &endcaps, NULL)
        && endcaps == dwg->header_vars.ENDCAPS)
      pass ();
    else
      fail ("HEADER.ENDCAPS [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ENDCAPS, endcaps);
    endcaps++;
    if (dwg_dynapi_header_set_value (dwg, "ENDCAPS", &endcaps, 0)
        && endcaps == dwg->header_vars.ENDCAPS)
      pass ();
    else
      fail ("HEADER.ENDCAPS [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ENDCAPS, endcaps);
    endcaps--;
    dwg_dynapi_header_set_value (dwg, "ENDCAPS", &endcaps, 0);

  }
  {
    BITCODE_B joinstyle;
    if (dwg_dynapi_header_value (dwg, "JOINSTYLE", &joinstyle, NULL)
        && joinstyle == dwg->header_vars.JOINSTYLE)
      pass ();
    else
      fail ("HEADER.JOINSTYLE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.JOINSTYLE, joinstyle);
    joinstyle++;
    if (dwg_dynapi_header_set_value (dwg, "JOINSTYLE", &joinstyle, 0)
        && joinstyle == dwg->header_vars.JOINSTYLE)
      pass ();
    else
      fail ("HEADER.JOINSTYLE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.JOINSTYLE, joinstyle);
    joinstyle--;
    dwg_dynapi_header_set_value (dwg, "JOINSTYLE", &joinstyle, 0);

  }
  {
    BITCODE_B lwdisplay;
    if (dwg_dynapi_header_value (dwg, "LWDISPLAY", &lwdisplay, NULL)
        && lwdisplay == dwg->header_vars.LWDISPLAY)
      pass ();
    else
      fail ("HEADER.LWDISPLAY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LWDISPLAY, lwdisplay);
    lwdisplay++;
    if (dwg_dynapi_header_set_value (dwg, "LWDISPLAY", &lwdisplay, 0)
        && lwdisplay == dwg->header_vars.LWDISPLAY)
      pass ();
    else
      fail ("HEADER.LWDISPLAY [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.LWDISPLAY, lwdisplay);
    lwdisplay--;
    dwg_dynapi_header_set_value (dwg, "LWDISPLAY", &lwdisplay, 0);

  }
  {
    BITCODE_B xedit;
    if (dwg_dynapi_header_value (dwg, "XEDIT", &xedit, NULL)
        && xedit == dwg->header_vars.XEDIT)
      pass ();
    else
      fail ("HEADER.XEDIT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.XEDIT, xedit);
    xedit++;
    if (dwg_dynapi_header_set_value (dwg, "XEDIT", &xedit, 0)
        && xedit == dwg->header_vars.XEDIT)
      pass ();
    else
      fail ("HEADER.XEDIT [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.XEDIT, xedit);
    xedit--;
    dwg_dynapi_header_set_value (dwg, "XEDIT", &xedit, 0);

  }
  {
    BITCODE_B extnames;
    if (dwg_dynapi_header_value (dwg, "EXTNAMES", &extnames, NULL)
        && extnames == dwg->header_vars.EXTNAMES)
      pass ();
    else
      fail ("HEADER.EXTNAMES [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.EXTNAMES, extnames);
    extnames++;
    if (dwg_dynapi_header_set_value (dwg, "EXTNAMES", &extnames, 0)
        && extnames == dwg->header_vars.EXTNAMES)
      pass ();
    else
      fail ("HEADER.EXTNAMES [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.EXTNAMES, extnames);
    extnames--;
    dwg_dynapi_header_set_value (dwg, "EXTNAMES", &extnames, 0);

  }
  {
    BITCODE_B pstylemode;
    if (dwg_dynapi_header_value (dwg, "PSTYLEMODE", &pstylemode, NULL)
        && pstylemode == dwg->header_vars.PSTYLEMODE)
      pass ();
    else
      fail ("HEADER.PSTYLEMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSTYLEMODE, pstylemode);
    pstylemode++;
    if (dwg_dynapi_header_set_value (dwg, "PSTYLEMODE", &pstylemode, 0)
        && pstylemode == dwg->header_vars.PSTYLEMODE)
      pass ();
    else
      fail ("HEADER.PSTYLEMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PSTYLEMODE, pstylemode);
    pstylemode--;
    dwg_dynapi_header_set_value (dwg, "PSTYLEMODE", &pstylemode, 0);

  }
  {
    BITCODE_B olestartup;
    if (dwg_dynapi_header_value (dwg, "OLESTARTUP", &olestartup, NULL)
        && olestartup == dwg->header_vars.OLESTARTUP)
      pass ();
    else
      fail ("HEADER.OLESTARTUP [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.OLESTARTUP, olestartup);
    olestartup++;
    if (dwg_dynapi_header_set_value (dwg, "OLESTARTUP", &olestartup, 0)
        && olestartup == dwg->header_vars.OLESTARTUP)
      pass ();
    else
      fail ("HEADER.OLESTARTUP [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.OLESTARTUP, olestartup);
    olestartup--;
    dwg_dynapi_header_set_value (dwg, "OLESTARTUP", &olestartup, 0);

  }
  {
    BITCODE_BS insunits;
    if (dwg_dynapi_header_value (dwg, "INSUNITS", &insunits, NULL)
        && insunits == dwg->header_vars.INSUNITS)
      pass ();
    else
      fail ("HEADER.INSUNITS [BS] %hu != %hu", dwg->header_vars.INSUNITS, insunits);
    insunits++;
    if (dwg_dynapi_header_set_value (dwg, "INSUNITS", &insunits, 0)
        && insunits == dwg->header_vars.INSUNITS)
      pass ();
    else
      fail ("HEADER.INSUNITS [BS] set+1 %hu != %hu",
            dwg->header_vars.INSUNITS, insunits);
    insunits--;
    dwg_dynapi_header_set_value (dwg, "INSUNITS", &insunits, 0);

  }
  {
    BITCODE_BS cepsntype;
    if (dwg_dynapi_header_value (dwg, "CEPSNTYPE", &cepsntype, NULL)
        && cepsntype == dwg->header_vars.CEPSNTYPE)
      pass ();
    else
      fail ("HEADER.CEPSNTYPE [BS] %hu != %hu", dwg->header_vars.CEPSNTYPE, cepsntype);
    cepsntype++;
    if (dwg_dynapi_header_set_value (dwg, "CEPSNTYPE", &cepsntype, 0)
        && cepsntype == dwg->header_vars.CEPSNTYPE)
      pass ();
    else
      fail ("HEADER.CEPSNTYPE [BS] set+1 %hu != %hu",
            dwg->header_vars.CEPSNTYPE, cepsntype);
    cepsntype--;
    dwg_dynapi_header_set_value (dwg, "CEPSNTYPE", &cepsntype, 0);

  }
  {
    BITCODE_H cpsnid;
    if (dwg_dynapi_header_value (dwg, "CPSNID", &cpsnid, NULL)
        && !memcmp (&cpsnid, &dwg->header_vars.CPSNID, sizeof (dwg->header_vars.CPSNID))
       )
      pass ();
    else
      fail ("HEADER.CPSNID [H]");
  }
  {
    BITCODE_TV fingerprintguid;
    if (dwg_dynapi_header_value (dwg, "FINGERPRINTGUID", &fingerprintguid, NULL)
        && !memcmp (&fingerprintguid, &dwg->header_vars.FINGERPRINTGUID, sizeof (dwg->header_vars.FINGERPRINTGUID))
       )
      pass ();
    else
      fail ("HEADER.FINGERPRINTGUID [TV]");
  }
  {
    BITCODE_TV versionguid;
    if (dwg_dynapi_header_value (dwg, "VERSIONGUID", &versionguid, NULL)
        && !memcmp (&versionguid, &dwg->header_vars.VERSIONGUID, sizeof (dwg->header_vars.VERSIONGUID))
       )
      pass ();
    else
      fail ("HEADER.VERSIONGUID [TV]");
  }
  {
    BITCODE_RC sortents;
    if (dwg_dynapi_header_value (dwg, "SORTENTS", &sortents, NULL)
        && sortents == dwg->header_vars.SORTENTS)
      pass ();
    else
      fail ("HEADER.SORTENTS [RC] %u != %u", dwg->header_vars.SORTENTS, sortents);
    sortents++;
    if (dwg_dynapi_header_set_value (dwg, "SORTENTS", &sortents, 0)
        && sortents == dwg->header_vars.SORTENTS)
      pass ();
    else
      fail ("HEADER.SORTENTS [RC] set+1 %u != %u",
            dwg->header_vars.SORTENTS, sortents);
    sortents--;
    dwg_dynapi_header_set_value (dwg, "SORTENTS", &sortents, 0);

  }
  {
    BITCODE_RC indexctl;
    if (dwg_dynapi_header_value (dwg, "INDEXCTL", &indexctl, NULL)
        && indexctl == dwg->header_vars.INDEXCTL)
      pass ();
    else
      fail ("HEADER.INDEXCTL [RC] %u != %u", dwg->header_vars.INDEXCTL, indexctl);
    indexctl++;
    if (dwg_dynapi_header_set_value (dwg, "INDEXCTL", &indexctl, 0)
        && indexctl == dwg->header_vars.INDEXCTL)
      pass ();
    else
      fail ("HEADER.INDEXCTL [RC] set+1 %u != %u",
            dwg->header_vars.INDEXCTL, indexctl);
    indexctl--;
    dwg_dynapi_header_set_value (dwg, "INDEXCTL", &indexctl, 0);

  }
  {
    BITCODE_RC hidetext;
    if (dwg_dynapi_header_value (dwg, "HIDETEXT", &hidetext, NULL)
        && hidetext == dwg->header_vars.HIDETEXT)
      pass ();
    else
      fail ("HEADER.HIDETEXT [RC] %u != %u", dwg->header_vars.HIDETEXT, hidetext);
    hidetext++;
    if (dwg_dynapi_header_set_value (dwg, "HIDETEXT", &hidetext, 0)
        && hidetext == dwg->header_vars.HIDETEXT)
      pass ();
    else
      fail ("HEADER.HIDETEXT [RC] set+1 %u != %u",
            dwg->header_vars.HIDETEXT, hidetext);
    hidetext--;
    dwg_dynapi_header_set_value (dwg, "HIDETEXT", &hidetext, 0);

  }
  {
    BITCODE_RC xclipframe;
    if (dwg_dynapi_header_value (dwg, "XCLIPFRAME", &xclipframe, NULL)
        && xclipframe == dwg->header_vars.XCLIPFRAME)
      pass ();
    else
      fail ("HEADER.XCLIPFRAME [RC] %u != %u", dwg->header_vars.XCLIPFRAME, xclipframe);
    xclipframe++;
    if (dwg_dynapi_header_set_value (dwg, "XCLIPFRAME", &xclipframe, 0)
        && xclipframe == dwg->header_vars.XCLIPFRAME)
      pass ();
    else
      fail ("HEADER.XCLIPFRAME [RC] set+1 %u != %u",
            dwg->header_vars.XCLIPFRAME, xclipframe);
    xclipframe--;
    dwg_dynapi_header_set_value (dwg, "XCLIPFRAME", &xclipframe, 0);

  }
  {
    BITCODE_RC dimassoc;
    if (dwg_dynapi_header_value (dwg, "DIMASSOC", &dimassoc, NULL)
        && dimassoc == dwg->header_vars.DIMASSOC)
      pass ();
    else
      fail ("HEADER.DIMASSOC [RC] %u != %u", dwg->header_vars.DIMASSOC, dimassoc);
    dimassoc++;
    if (dwg_dynapi_header_set_value (dwg, "DIMASSOC", &dimassoc, 0)
        && dimassoc == dwg->header_vars.DIMASSOC)
      pass ();
    else
      fail ("HEADER.DIMASSOC [RC] set+1 %u != %u",
            dwg->header_vars.DIMASSOC, dimassoc);
    dimassoc--;
    dwg_dynapi_header_set_value (dwg, "DIMASSOC", &dimassoc, 0);

  }
  {
    BITCODE_RC halogap;
    if (dwg_dynapi_header_value (dwg, "HALOGAP", &halogap, NULL)
        && halogap == dwg->header_vars.HALOGAP)
      pass ();
    else
      fail ("HEADER.HALOGAP [RC] %u != %u", dwg->header_vars.HALOGAP, halogap);
    halogap++;
    if (dwg_dynapi_header_set_value (dwg, "HALOGAP", &halogap, 0)
        && halogap == dwg->header_vars.HALOGAP)
      pass ();
    else
      fail ("HEADER.HALOGAP [RC] set+1 %u != %u",
            dwg->header_vars.HALOGAP, halogap);
    halogap--;
    dwg_dynapi_header_set_value (dwg, "HALOGAP", &halogap, 0);

  }
  {
    BITCODE_BS obscolor;
    if (dwg_dynapi_header_value (dwg, "OBSCOLOR", &obscolor, NULL)
        && obscolor == dwg->header_vars.OBSCOLOR)
      pass ();
    else
      fail ("HEADER.OBSCOLOR [BS] %hu != %hu", dwg->header_vars.OBSCOLOR, obscolor);
    obscolor++;
    if (dwg_dynapi_header_set_value (dwg, "OBSCOLOR", &obscolor, 0)
        && obscolor == dwg->header_vars.OBSCOLOR)
      pass ();
    else
      fail ("HEADER.OBSCOLOR [BS] set+1 %hu != %hu",
            dwg->header_vars.OBSCOLOR, obscolor);
    obscolor--;
    dwg_dynapi_header_set_value (dwg, "OBSCOLOR", &obscolor, 0);

  }
  {
    BITCODE_BS intersectioncolor;
    if (dwg_dynapi_header_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, NULL)
        && intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
      pass ();
    else
      fail ("HEADER.INTERSECTIONCOLOR [BS] %hu != %hu", dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor);
    intersectioncolor++;
    if (dwg_dynapi_header_set_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, 0)
        && intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
      pass ();
    else
      fail ("HEADER.INTERSECTIONCOLOR [BS] set+1 %hu != %hu",
            dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor);
    intersectioncolor--;
    dwg_dynapi_header_set_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, 0);

  }
  {
    BITCODE_RC obsltype;
    if (dwg_dynapi_header_value (dwg, "OBSLTYPE", &obsltype, NULL)
        && obsltype == dwg->header_vars.OBSLTYPE)
      pass ();
    else
      fail ("HEADER.OBSLTYPE [RC] %u != %u", dwg->header_vars.OBSLTYPE, obsltype);
    obsltype++;
    if (dwg_dynapi_header_set_value (dwg, "OBSLTYPE", &obsltype, 0)
        && obsltype == dwg->header_vars.OBSLTYPE)
      pass ();
    else
      fail ("HEADER.OBSLTYPE [RC] set+1 %u != %u",
            dwg->header_vars.OBSLTYPE, obsltype);
    obsltype--;
    dwg_dynapi_header_set_value (dwg, "OBSLTYPE", &obsltype, 0);

  }
  {
    BITCODE_RC intersectiondisplay;
    if (dwg_dynapi_header_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, NULL)
        && intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
      pass ();
    else
      fail ("HEADER.INTERSECTIONDISPLAY [RC] %u != %u", dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay);
    intersectiondisplay++;
    if (dwg_dynapi_header_set_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, 0)
        && intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
      pass ();
    else
      fail ("HEADER.INTERSECTIONDISPLAY [RC] set+1 %u != %u",
            dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay);
    intersectiondisplay--;
    dwg_dynapi_header_set_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, 0);

  }
  {
    BITCODE_TV projectname;
    if (dwg_dynapi_header_value (dwg, "PROJECTNAME", &projectname, NULL)
        && !memcmp (&projectname, &dwg->header_vars.PROJECTNAME, sizeof (dwg->header_vars.PROJECTNAME))
       )
      pass ();
    else
      fail ("HEADER.PROJECTNAME [TV]");
  }
  {
    BITCODE_H block_record_pspace;
    if (dwg_dynapi_header_value (dwg, "BLOCK_RECORD_PSPACE", &block_record_pspace, NULL)
        && !memcmp (&block_record_pspace, &dwg->header_vars.BLOCK_RECORD_PSPACE, sizeof (dwg->header_vars.BLOCK_RECORD_PSPACE))
       )
      pass ();
    else
      fail ("HEADER.BLOCK_RECORD_PSPACE [H]");
  }
  {
    BITCODE_H block_record_mspace;
    if (dwg_dynapi_header_value (dwg, "BLOCK_RECORD_MSPACE", &block_record_mspace, NULL)
        && !memcmp (&block_record_mspace, &dwg->header_vars.BLOCK_RECORD_MSPACE, sizeof (dwg->header_vars.BLOCK_RECORD_MSPACE))
       )
      pass ();
    else
      fail ("HEADER.BLOCK_RECORD_MSPACE [H]");
  }
  {
    BITCODE_H ltype_bylayer;
    if (dwg_dynapi_header_value (dwg, "LTYPE_BYLAYER", &ltype_bylayer, NULL)
        && !memcmp (&ltype_bylayer, &dwg->header_vars.LTYPE_BYLAYER, sizeof (dwg->header_vars.LTYPE_BYLAYER))
       )
      pass ();
    else
      fail ("HEADER.LTYPE_BYLAYER [H]");
  }
  {
    BITCODE_H ltype_byblock;
    if (dwg_dynapi_header_value (dwg, "LTYPE_BYBLOCK", &ltype_byblock, NULL)
        && !memcmp (&ltype_byblock, &dwg->header_vars.LTYPE_BYBLOCK, sizeof (dwg->header_vars.LTYPE_BYBLOCK))
       )
      pass ();
    else
      fail ("HEADER.LTYPE_BYBLOCK [H]");
  }
  {
    BITCODE_H ltype_continuous;
    if (dwg_dynapi_header_value (dwg, "LTYPE_CONTINUOUS", &ltype_continuous, NULL)
        && !memcmp (&ltype_continuous, &dwg->header_vars.LTYPE_CONTINUOUS, sizeof (dwg->header_vars.LTYPE_CONTINUOUS))
       )
      pass ();
    else
      fail ("HEADER.LTYPE_CONTINUOUS [H]");
  }
  {
    BITCODE_B cameradisplay;
    if (dwg_dynapi_header_value (dwg, "CAMERADISPLAY", &cameradisplay, NULL)
        && cameradisplay == dwg->header_vars.CAMERADISPLAY)
      pass ();
    else
      fail ("HEADER.CAMERADISPLAY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.CAMERADISPLAY, cameradisplay);
    cameradisplay++;
    if (dwg_dynapi_header_set_value (dwg, "CAMERADISPLAY", &cameradisplay, 0)
        && cameradisplay == dwg->header_vars.CAMERADISPLAY)
      pass ();
    else
      fail ("HEADER.CAMERADISPLAY [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.CAMERADISPLAY, cameradisplay);
    cameradisplay--;
    dwg_dynapi_header_set_value (dwg, "CAMERADISPLAY", &cameradisplay, 0);

  }
  {
    BITCODE_BL unknown_21;
    if (dwg_dynapi_header_value (dwg, "unknown_21", &unknown_21, NULL)
        && unknown_21 == dwg->header_vars.unknown_21)
      pass ();
    else
      fail ("HEADER.unknown_21 [BL] %u != %u", dwg->header_vars.unknown_21, unknown_21);
    unknown_21++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_21", &unknown_21, 0)
        && unknown_21 == dwg->header_vars.unknown_21)
      pass ();
    else
      fail ("HEADER.unknown_21 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_21, unknown_21);
    unknown_21--;
    dwg_dynapi_header_set_value (dwg, "unknown_21", &unknown_21, 0);

  }
  {
    BITCODE_BL unknown_22;
    if (dwg_dynapi_header_value (dwg, "unknown_22", &unknown_22, NULL)
        && unknown_22 == dwg->header_vars.unknown_22)
      pass ();
    else
      fail ("HEADER.unknown_22 [BL] %u != %u", dwg->header_vars.unknown_22, unknown_22);
    unknown_22++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_22", &unknown_22, 0)
        && unknown_22 == dwg->header_vars.unknown_22)
      pass ();
    else
      fail ("HEADER.unknown_22 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_22, unknown_22);
    unknown_22--;
    dwg_dynapi_header_set_value (dwg, "unknown_22", &unknown_22, 0);

  }
  {
    BITCODE_BD unknown_23;
    if (dwg_dynapi_header_value (dwg, "unknown_23", &unknown_23, NULL)
        && unknown_23 == dwg->header_vars.unknown_23)
      pass ();
    else
      fail ("HEADER.unknown_23 [BD] %g != %g", dwg->header_vars.unknown_23, unknown_23);
    unknown_23++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_23", &unknown_23, 0)
        && unknown_23 == dwg->header_vars.unknown_23)
      pass ();
    else
      fail ("HEADER.unknown_23 [BD] set+1 %g != %g",
            dwg->header_vars.unknown_23, unknown_23);
    unknown_23--;
    dwg_dynapi_header_set_value (dwg, "unknown_23", &unknown_23, 0);

  }
  {
    BITCODE_BD stepspersec;
    if (dwg_dynapi_header_value (dwg, "STEPSPERSEC", &stepspersec, NULL)
        && stepspersec == dwg->header_vars.STEPSPERSEC)
      pass ();
    else
      fail ("HEADER.STEPSPERSEC [BD] %g != %g", dwg->header_vars.STEPSPERSEC, stepspersec);
    stepspersec++;
    if (dwg_dynapi_header_set_value (dwg, "STEPSPERSEC", &stepspersec, 0)
        && stepspersec == dwg->header_vars.STEPSPERSEC)
      pass ();
    else
      fail ("HEADER.STEPSPERSEC [BD] set+1 %g != %g",
            dwg->header_vars.STEPSPERSEC, stepspersec);
    stepspersec--;
    dwg_dynapi_header_set_value (dwg, "STEPSPERSEC", &stepspersec, 0);

  }
  {
    BITCODE_BD stepsize;
    if (dwg_dynapi_header_value (dwg, "STEPSIZE", &stepsize, NULL)
        && stepsize == dwg->header_vars.STEPSIZE)
      pass ();
    else
      fail ("HEADER.STEPSIZE [BD] %g != %g", dwg->header_vars.STEPSIZE, stepsize);
    stepsize++;
    if (dwg_dynapi_header_set_value (dwg, "STEPSIZE", &stepsize, 0)
        && stepsize == dwg->header_vars.STEPSIZE)
      pass ();
    else
      fail ("HEADER.STEPSIZE [BD] set+1 %g != %g",
            dwg->header_vars.STEPSIZE, stepsize);
    stepsize--;
    dwg_dynapi_header_set_value (dwg, "STEPSIZE", &stepsize, 0);

  }
  {
    BITCODE_BD _3ddwfprec;
    if (dwg_dynapi_header_value (dwg, "_3DDWFPREC", &_3ddwfprec, NULL)
        && _3ddwfprec == dwg->header_vars._3DDWFPREC)
      pass ();
    else
      fail ("HEADER._3DDWFPREC [BD] %g != %g", dwg->header_vars._3DDWFPREC, _3ddwfprec);
    _3ddwfprec++;
    if (dwg_dynapi_header_set_value (dwg, "_3DDWFPREC", &_3ddwfprec, 0)
        && _3ddwfprec == dwg->header_vars._3DDWFPREC)
      pass ();
    else
      fail ("HEADER._3DDWFPREC [BD] set+1 %g != %g",
            dwg->header_vars._3DDWFPREC, _3ddwfprec);
    _3ddwfprec--;
    dwg_dynapi_header_set_value (dwg, "_3DDWFPREC", &_3ddwfprec, 0);

  }
  {
    BITCODE_BD lenslength;
    if (dwg_dynapi_header_value (dwg, "LENSLENGTH", &lenslength, NULL)
        && lenslength == dwg->header_vars.LENSLENGTH)
      pass ();
    else
      fail ("HEADER.LENSLENGTH [BD] %g != %g", dwg->header_vars.LENSLENGTH, lenslength);
    lenslength++;
    if (dwg_dynapi_header_set_value (dwg, "LENSLENGTH", &lenslength, 0)
        && lenslength == dwg->header_vars.LENSLENGTH)
      pass ();
    else
      fail ("HEADER.LENSLENGTH [BD] set+1 %g != %g",
            dwg->header_vars.LENSLENGTH, lenslength);
    lenslength--;
    dwg_dynapi_header_set_value (dwg, "LENSLENGTH", &lenslength, 0);

  }
  {
    BITCODE_BD cameraheight;
    if (dwg_dynapi_header_value (dwg, "CAMERAHEIGHT", &cameraheight, NULL)
        && cameraheight == dwg->header_vars.CAMERAHEIGHT)
      pass ();
    else
      fail ("HEADER.CAMERAHEIGHT [BD] %g != %g", dwg->header_vars.CAMERAHEIGHT, cameraheight);
    cameraheight++;
    if (dwg_dynapi_header_set_value (dwg, "CAMERAHEIGHT", &cameraheight, 0)
        && cameraheight == dwg->header_vars.CAMERAHEIGHT)
      pass ();
    else
      fail ("HEADER.CAMERAHEIGHT [BD] set+1 %g != %g",
            dwg->header_vars.CAMERAHEIGHT, cameraheight);
    cameraheight--;
    dwg_dynapi_header_set_value (dwg, "CAMERAHEIGHT", &cameraheight, 0);

  }
  {
    BITCODE_RC solidhist;
    if (dwg_dynapi_header_value (dwg, "SOLIDHIST", &solidhist, NULL)
        && solidhist == dwg->header_vars.SOLIDHIST)
      pass ();
    else
      fail ("HEADER.SOLIDHIST [RC] %u != %u", dwg->header_vars.SOLIDHIST, solidhist);
    solidhist++;
    if (dwg_dynapi_header_set_value (dwg, "SOLIDHIST", &solidhist, 0)
        && solidhist == dwg->header_vars.SOLIDHIST)
      pass ();
    else
      fail ("HEADER.SOLIDHIST [RC] set+1 %u != %u",
            dwg->header_vars.SOLIDHIST, solidhist);
    solidhist--;
    dwg_dynapi_header_set_value (dwg, "SOLIDHIST", &solidhist, 0);

  }
  {
    BITCODE_RC showhist;
    if (dwg_dynapi_header_value (dwg, "SHOWHIST", &showhist, NULL)
        && showhist == dwg->header_vars.SHOWHIST)
      pass ();
    else
      fail ("HEADER.SHOWHIST [RC] %u != %u", dwg->header_vars.SHOWHIST, showhist);
    showhist++;
    if (dwg_dynapi_header_set_value (dwg, "SHOWHIST", &showhist, 0)
        && showhist == dwg->header_vars.SHOWHIST)
      pass ();
    else
      fail ("HEADER.SHOWHIST [RC] set+1 %u != %u",
            dwg->header_vars.SHOWHIST, showhist);
    showhist--;
    dwg_dynapi_header_set_value (dwg, "SHOWHIST", &showhist, 0);

  }
  {
    BITCODE_BD psolwidth;
    if (dwg_dynapi_header_value (dwg, "PSOLWIDTH", &psolwidth, NULL)
        && psolwidth == dwg->header_vars.PSOLWIDTH)
      pass ();
    else
      fail ("HEADER.PSOLWIDTH [BD] %g != %g", dwg->header_vars.PSOLWIDTH, psolwidth);
    psolwidth++;
    if (dwg_dynapi_header_set_value (dwg, "PSOLWIDTH", &psolwidth, 0)
        && psolwidth == dwg->header_vars.PSOLWIDTH)
      pass ();
    else
      fail ("HEADER.PSOLWIDTH [BD] set+1 %g != %g",
            dwg->header_vars.PSOLWIDTH, psolwidth);
    psolwidth--;
    dwg_dynapi_header_set_value (dwg, "PSOLWIDTH", &psolwidth, 0);

  }
  {
    BITCODE_BD psolheight;
    if (dwg_dynapi_header_value (dwg, "PSOLHEIGHT", &psolheight, NULL)
        && psolheight == dwg->header_vars.PSOLHEIGHT)
      pass ();
    else
      fail ("HEADER.PSOLHEIGHT [BD] %g != %g", dwg->header_vars.PSOLHEIGHT, psolheight);
    psolheight++;
    if (dwg_dynapi_header_set_value (dwg, "PSOLHEIGHT", &psolheight, 0)
        && psolheight == dwg->header_vars.PSOLHEIGHT)
      pass ();
    else
      fail ("HEADER.PSOLHEIGHT [BD] set+1 %g != %g",
            dwg->header_vars.PSOLHEIGHT, psolheight);
    psolheight--;
    dwg_dynapi_header_set_value (dwg, "PSOLHEIGHT", &psolheight, 0);

  }
  {
    BITCODE_BD loftang1;
    if (dwg_dynapi_header_value (dwg, "LOFTANG1", &loftang1, NULL)
        && loftang1 == dwg->header_vars.LOFTANG1)
      pass ();
    else
      fail ("HEADER.LOFTANG1 [BD] %g != %g", dwg->header_vars.LOFTANG1, loftang1);
    loftang1++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTANG1", &loftang1, 0)
        && loftang1 == dwg->header_vars.LOFTANG1)
      pass ();
    else
      fail ("HEADER.LOFTANG1 [BD] set+1 %g != %g",
            dwg->header_vars.LOFTANG1, loftang1);
    loftang1--;
    dwg_dynapi_header_set_value (dwg, "LOFTANG1", &loftang1, 0);

  }
  {
    BITCODE_BD loftang2;
    if (dwg_dynapi_header_value (dwg, "LOFTANG2", &loftang2, NULL)
        && loftang2 == dwg->header_vars.LOFTANG2)
      pass ();
    else
      fail ("HEADER.LOFTANG2 [BD] %g != %g", dwg->header_vars.LOFTANG2, loftang2);
    loftang2++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTANG2", &loftang2, 0)
        && loftang2 == dwg->header_vars.LOFTANG2)
      pass ();
    else
      fail ("HEADER.LOFTANG2 [BD] set+1 %g != %g",
            dwg->header_vars.LOFTANG2, loftang2);
    loftang2--;
    dwg_dynapi_header_set_value (dwg, "LOFTANG2", &loftang2, 0);

  }
  {
    BITCODE_BD loftmag1;
    if (dwg_dynapi_header_value (dwg, "LOFTMAG1", &loftmag1, NULL)
        && loftmag1 == dwg->header_vars.LOFTMAG1)
      pass ();
    else
      fail ("HEADER.LOFTMAG1 [BD] %g != %g", dwg->header_vars.LOFTMAG1, loftmag1);
    loftmag1++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTMAG1", &loftmag1, 0)
        && loftmag1 == dwg->header_vars.LOFTMAG1)
      pass ();
    else
      fail ("HEADER.LOFTMAG1 [BD] set+1 %g != %g",
            dwg->header_vars.LOFTMAG1, loftmag1);
    loftmag1--;
    dwg_dynapi_header_set_value (dwg, "LOFTMAG1", &loftmag1, 0);

  }
  {
    BITCODE_BD loftmag2;
    if (dwg_dynapi_header_value (dwg, "LOFTMAG2", &loftmag2, NULL)
        && loftmag2 == dwg->header_vars.LOFTMAG2)
      pass ();
    else
      fail ("HEADER.LOFTMAG2 [BD] %g != %g", dwg->header_vars.LOFTMAG2, loftmag2);
    loftmag2++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTMAG2", &loftmag2, 0)
        && loftmag2 == dwg->header_vars.LOFTMAG2)
      pass ();
    else
      fail ("HEADER.LOFTMAG2 [BD] set+1 %g != %g",
            dwg->header_vars.LOFTMAG2, loftmag2);
    loftmag2--;
    dwg_dynapi_header_set_value (dwg, "LOFTMAG2", &loftmag2, 0);

  }
  {
    BITCODE_BS loftparam;
    if (dwg_dynapi_header_value (dwg, "LOFTPARAM", &loftparam, NULL)
        && loftparam == dwg->header_vars.LOFTPARAM)
      pass ();
    else
      fail ("HEADER.LOFTPARAM [BS] %hu != %hu", dwg->header_vars.LOFTPARAM, loftparam);
    loftparam++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTPARAM", &loftparam, 0)
        && loftparam == dwg->header_vars.LOFTPARAM)
      pass ();
    else
      fail ("HEADER.LOFTPARAM [BS] set+1 %hu != %hu",
            dwg->header_vars.LOFTPARAM, loftparam);
    loftparam--;
    dwg_dynapi_header_set_value (dwg, "LOFTPARAM", &loftparam, 0);

  }
  {
    BITCODE_RC loftnormals;
    if (dwg_dynapi_header_value (dwg, "LOFTNORMALS", &loftnormals, NULL)
        && loftnormals == dwg->header_vars.LOFTNORMALS)
      pass ();
    else
      fail ("HEADER.LOFTNORMALS [RC] %u != %u", dwg->header_vars.LOFTNORMALS, loftnormals);
    loftnormals++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTNORMALS", &loftnormals, 0)
        && loftnormals == dwg->header_vars.LOFTNORMALS)
      pass ();
    else
      fail ("HEADER.LOFTNORMALS [RC] set+1 %u != %u",
            dwg->header_vars.LOFTNORMALS, loftnormals);
    loftnormals--;
    dwg_dynapi_header_set_value (dwg, "LOFTNORMALS", &loftnormals, 0);

  }
  {
    BITCODE_BD latitude;
    if (dwg_dynapi_header_value (dwg, "LATITUDE", &latitude, NULL)
        && latitude == dwg->header_vars.LATITUDE)
      pass ();
    else
      fail ("HEADER.LATITUDE [BD] %g != %g", dwg->header_vars.LATITUDE, latitude);
    latitude++;
    if (dwg_dynapi_header_set_value (dwg, "LATITUDE", &latitude, 0)
        && latitude == dwg->header_vars.LATITUDE)
      pass ();
    else
      fail ("HEADER.LATITUDE [BD] set+1 %g != %g",
            dwg->header_vars.LATITUDE, latitude);
    latitude--;
    dwg_dynapi_header_set_value (dwg, "LATITUDE", &latitude, 0);

  }
  {
    BITCODE_BD longitude;
    if (dwg_dynapi_header_value (dwg, "LONGITUDE", &longitude, NULL)
        && longitude == dwg->header_vars.LONGITUDE)
      pass ();
    else
      fail ("HEADER.LONGITUDE [BD] %g != %g", dwg->header_vars.LONGITUDE, longitude);
    longitude++;
    if (dwg_dynapi_header_set_value (dwg, "LONGITUDE", &longitude, 0)
        && longitude == dwg->header_vars.LONGITUDE)
      pass ();
    else
      fail ("HEADER.LONGITUDE [BD] set+1 %g != %g",
            dwg->header_vars.LONGITUDE, longitude);
    longitude--;
    dwg_dynapi_header_set_value (dwg, "LONGITUDE", &longitude, 0);

  }
  {
    BITCODE_BD northdirection;
    if (dwg_dynapi_header_value (dwg, "NORTHDIRECTION", &northdirection, NULL)
        && northdirection == dwg->header_vars.NORTHDIRECTION)
      pass ();
    else
      fail ("HEADER.NORTHDIRECTION [BD] %g != %g", dwg->header_vars.NORTHDIRECTION, northdirection);
    northdirection++;
    if (dwg_dynapi_header_set_value (dwg, "NORTHDIRECTION", &northdirection, 0)
        && northdirection == dwg->header_vars.NORTHDIRECTION)
      pass ();
    else
      fail ("HEADER.NORTHDIRECTION [BD] set+1 %g != %g",
            dwg->header_vars.NORTHDIRECTION, northdirection);
    northdirection--;
    dwg_dynapi_header_set_value (dwg, "NORTHDIRECTION", &northdirection, 0);

  }
  {
    BITCODE_BL timezone;
    if (dwg_dynapi_header_value (dwg, "TIMEZONE", &timezone, NULL)
        && timezone == dwg->header_vars.TIMEZONE)
      pass ();
    else
      fail ("HEADER.TIMEZONE [BL] %u != %u", dwg->header_vars.TIMEZONE, timezone);
    timezone++;
    if (dwg_dynapi_header_set_value (dwg, "TIMEZONE", &timezone, 0)
        && timezone == dwg->header_vars.TIMEZONE)
      pass ();
    else
      fail ("HEADER.TIMEZONE [BL] set+1 %u != %u",
            dwg->header_vars.TIMEZONE, timezone);
    timezone--;
    dwg_dynapi_header_set_value (dwg, "TIMEZONE", &timezone, 0);

  }
  {
    BITCODE_RC lightglyphdisplay;
    if (dwg_dynapi_header_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, NULL)
        && lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
      pass ();
    else
      fail ("HEADER.LIGHTGLYPHDISPLAY [RC] %u != %u", dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay);
    lightglyphdisplay++;
    if (dwg_dynapi_header_set_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, 0)
        && lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
      pass ();
    else
      fail ("HEADER.LIGHTGLYPHDISPLAY [RC] set+1 %u != %u",
            dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay);
    lightglyphdisplay--;
    dwg_dynapi_header_set_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, 0);

  }
  {
    BITCODE_RC tilemodelightsynch;
    if (dwg_dynapi_header_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, NULL)
        && tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
      pass ();
    else
      fail ("HEADER.TILEMODELIGHTSYNCH [RC] %u != %u", dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch);
    tilemodelightsynch++;
    if (dwg_dynapi_header_set_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, 0)
        && tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
      pass ();
    else
      fail ("HEADER.TILEMODELIGHTSYNCH [RC] set+1 %u != %u",
            dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch);
    tilemodelightsynch--;
    dwg_dynapi_header_set_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, 0);

  }
  {
    BITCODE_RC dwfframe;
    if (dwg_dynapi_header_value (dwg, "DWFFRAME", &dwfframe, NULL)
        && dwfframe == dwg->header_vars.DWFFRAME)
      pass ();
    else
      fail ("HEADER.DWFFRAME [RC] %u != %u", dwg->header_vars.DWFFRAME, dwfframe);
    dwfframe++;
    if (dwg_dynapi_header_set_value (dwg, "DWFFRAME", &dwfframe, 0)
        && dwfframe == dwg->header_vars.DWFFRAME)
      pass ();
    else
      fail ("HEADER.DWFFRAME [RC] set+1 %u != %u",
            dwg->header_vars.DWFFRAME, dwfframe);
    dwfframe--;
    dwg_dynapi_header_set_value (dwg, "DWFFRAME", &dwfframe, 0);

  }
  {
    BITCODE_RC dgnframe;
    if (dwg_dynapi_header_value (dwg, "DGNFRAME", &dgnframe, NULL)
        && dgnframe == dwg->header_vars.DGNFRAME)
      pass ();
    else
      fail ("HEADER.DGNFRAME [RC] %u != %u", dwg->header_vars.DGNFRAME, dgnframe);
    dgnframe++;
    if (dwg_dynapi_header_set_value (dwg, "DGNFRAME", &dgnframe, 0)
        && dgnframe == dwg->header_vars.DGNFRAME)
      pass ();
    else
      fail ("HEADER.DGNFRAME [RC] set+1 %u != %u",
            dwg->header_vars.DGNFRAME, dgnframe);
    dgnframe--;
    dwg_dynapi_header_set_value (dwg, "DGNFRAME", &dgnframe, 0);

  }
  {
    BITCODE_B realworldscale;
    if (dwg_dynapi_header_value (dwg, "REALWORLDSCALE", &realworldscale, NULL)
        && realworldscale == dwg->header_vars.REALWORLDSCALE)
      pass ();
    else
      fail ("HEADER.REALWORLDSCALE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REALWORLDSCALE, realworldscale);
    realworldscale++;
    if (dwg_dynapi_header_set_value (dwg, "REALWORLDSCALE", &realworldscale, 0)
        && realworldscale == dwg->header_vars.REALWORLDSCALE)
      pass ();
    else
      fail ("HEADER.REALWORLDSCALE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.REALWORLDSCALE, realworldscale);
    realworldscale--;
    dwg_dynapi_header_set_value (dwg, "REALWORLDSCALE", &realworldscale, 0);

  }
  {
    BITCODE_CMC interferecolor;
    if (dwg_dynapi_header_value (dwg, "INTERFERECOLOR", &interferecolor, NULL)
        && !memcmp (&interferecolor, &dwg->header_vars.INTERFERECOLOR, sizeof (dwg->header_vars.INTERFERECOLOR))
       )
      pass ();
    else
      fail ("HEADER.INTERFERECOLOR [CMC]");
  }
  {
    BITCODE_H interfereobjvs;
    if (dwg_dynapi_header_value (dwg, "INTERFEREOBJVS", &interfereobjvs, NULL)
        && !memcmp (&interfereobjvs, &dwg->header_vars.INTERFEREOBJVS, sizeof (dwg->header_vars.INTERFEREOBJVS))
       )
      pass ();
    else
      fail ("HEADER.INTERFEREOBJVS [H]");
  }
  {
    BITCODE_H interferevpvs;
    if (dwg_dynapi_header_value (dwg, "INTERFEREVPVS", &interferevpvs, NULL)
        && !memcmp (&interferevpvs, &dwg->header_vars.INTERFEREVPVS, sizeof (dwg->header_vars.INTERFEREVPVS))
       )
      pass ();
    else
      fail ("HEADER.INTERFEREVPVS [H]");
  }
  {
    BITCODE_H dragvs;
    if (dwg_dynapi_header_value (dwg, "DRAGVS", &dragvs, NULL)
        && !memcmp (&dragvs, &dwg->header_vars.DRAGVS, sizeof (dwg->header_vars.DRAGVS))
       )
      pass ();
    else
      fail ("HEADER.DRAGVS [H]");
  }
  {
    BITCODE_RC cshadow;
    if (dwg_dynapi_header_value (dwg, "CSHADOW", &cshadow, NULL)
        && cshadow == dwg->header_vars.CSHADOW)
      pass ();
    else
      fail ("HEADER.CSHADOW [RC] %u != %u", dwg->header_vars.CSHADOW, cshadow);
    cshadow++;
    if (dwg_dynapi_header_set_value (dwg, "CSHADOW", &cshadow, 0)
        && cshadow == dwg->header_vars.CSHADOW)
      pass ();
    else
      fail ("HEADER.CSHADOW [RC] set+1 %u != %u",
            dwg->header_vars.CSHADOW, cshadow);
    cshadow--;
    dwg_dynapi_header_set_value (dwg, "CSHADOW", &cshadow, 0);

  }
  {
    BITCODE_BD shadowplanelocation;
    if (dwg_dynapi_header_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, NULL)
        && shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
      pass ();
    else
      fail ("HEADER.SHADOWPLANELOCATION [BD] %g != %g", dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation);
    shadowplanelocation++;
    if (dwg_dynapi_header_set_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, 0)
        && shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
      pass ();
    else
      fail ("HEADER.SHADOWPLANELOCATION [BD] set+1 %g != %g",
            dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation);
    shadowplanelocation--;
    dwg_dynapi_header_set_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, 0);

  }
  {
    BITCODE_BS unknown_54;
    if (dwg_dynapi_header_value (dwg, "unknown_54", &unknown_54, NULL)
        && unknown_54 == dwg->header_vars.unknown_54)
      pass ();
    else
      fail ("HEADER.unknown_54 [BS] %hu != %hu", dwg->header_vars.unknown_54, unknown_54);
    unknown_54++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_54", &unknown_54, 0)
        && unknown_54 == dwg->header_vars.unknown_54)
      pass ();
    else
      fail ("HEADER.unknown_54 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_54, unknown_54);
    unknown_54--;
    dwg_dynapi_header_set_value (dwg, "unknown_54", &unknown_54, 0);

  }
  {
    BITCODE_BS unknown_55;
    if (dwg_dynapi_header_value (dwg, "unknown_55", &unknown_55, NULL)
        && unknown_55 == dwg->header_vars.unknown_55)
      pass ();
    else
      fail ("HEADER.unknown_55 [BS] %hu != %hu", dwg->header_vars.unknown_55, unknown_55);
    unknown_55++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_55", &unknown_55, 0)
        && unknown_55 == dwg->header_vars.unknown_55)
      pass ();
    else
      fail ("HEADER.unknown_55 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_55, unknown_55);
    unknown_55--;
    dwg_dynapi_header_set_value (dwg, "unknown_55", &unknown_55, 0);

  }
  {
    BITCODE_BS unknown_56;
    if (dwg_dynapi_header_value (dwg, "unknown_56", &unknown_56, NULL)
        && unknown_56 == dwg->header_vars.unknown_56)
      pass ();
    else
      fail ("HEADER.unknown_56 [BS] %hu != %hu", dwg->header_vars.unknown_56, unknown_56);
    unknown_56++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_56", &unknown_56, 0)
        && unknown_56 == dwg->header_vars.unknown_56)
      pass ();
    else
      fail ("HEADER.unknown_56 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_56, unknown_56);
    unknown_56--;
    dwg_dynapi_header_set_value (dwg, "unknown_56", &unknown_56, 0);

  }
  {
    BITCODE_BS unknown_57;
    if (dwg_dynapi_header_value (dwg, "unknown_57", &unknown_57, NULL)
        && unknown_57 == dwg->header_vars.unknown_57)
      pass ();
    else
      fail ("HEADER.unknown_57 [BS] %hu != %hu", dwg->header_vars.unknown_57, unknown_57);
    unknown_57++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_57", &unknown_57, 0)
        && unknown_57 == dwg->header_vars.unknown_57)
      pass ();
    else
      fail ("HEADER.unknown_57 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_57, unknown_57);
    unknown_57--;
    dwg_dynapi_header_set_value (dwg, "unknown_57", &unknown_57, 0);

  }
#line 48 "dynapi_test.c.in"
  return error;
}
#line 5380 "dynapi_test.c"
/* @@for test_OBJECT@@ */
static int test__3DFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity__3DFACE *restrict _3dface = obj->tio.entity->tio._3DFACE;
  failed = 0;
  {
    BITCODE_3BD corner1;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "corner1", &corner1, NULL)
        && !memcmp (&corner1, &_3dface->corner1, sizeof (_3dface->corner1)))
        pass ();
    else
        fail ("3DFACE.corner1 [3BD]");
  }
  {
    BITCODE_3BD corner2;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "corner2", &corner2, NULL)
        && !memcmp (&corner2, &_3dface->corner2, sizeof (_3dface->corner2)))
        pass ();
    else
        fail ("3DFACE.corner2 [3BD]");
  }
  {
    BITCODE_3BD corner3;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "corner3", &corner3, NULL)
        && !memcmp (&corner3, &_3dface->corner3, sizeof (_3dface->corner3)))
        pass ();
    else
        fail ("3DFACE.corner3 [3BD]");
  }
  {
    BITCODE_3BD corner4;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "corner4", &corner4, NULL)
        && !memcmp (&corner4, &_3dface->corner4, sizeof (_3dface->corner4)))
        pass ();
    else
        fail ("3DFACE.corner4 [3BD]");
  }
  {
    BITCODE_B has_no_flags;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "has_no_flags", &has_no_flags, NULL)
        && has_no_flags == _3dface->has_no_flags)
      pass ();
    else
      fail ("3DFACE.has_no_flags [B] " FORMAT_B " != " FORMAT_B "", _3dface->has_no_flags, has_no_flags);
    has_no_flags++;
    if (dwg_dynapi_entity_set_value (_3dface, "3DFACE", "has_no_flags", &has_no_flags, 0)
        && has_no_flags == _3dface->has_no_flags)
      pass ();
    else
      fail ("3DFACE.has_no_flags [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dface->has_no_flags, has_no_flags);
    _3dface->has_no_flags--;
  }
  {
    BITCODE_BS invis_flags;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "invis_flags", &invis_flags, NULL)
        && invis_flags == _3dface->invis_flags)
      pass ();
    else
      fail ("3DFACE.invis_flags [BS] %hu != %hu", _3dface->invis_flags, invis_flags);
    invis_flags++;
    if (dwg_dynapi_entity_set_value (_3dface, "3DFACE", "invis_flags", &invis_flags, 0)
        && invis_flags == _3dface->invis_flags)
      pass ();
    else
      fail ("3DFACE.invis_flags [BS] set+1 %hu != %hu", _3dface->invis_flags, invis_flags);
    _3dface->invis_flags--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &_3dface->parent, sizeof (_3dface->parent)))
        pass ();
    else
        fail ("3DFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_B z_is_zero;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "z_is_zero", &z_is_zero, NULL)
        && z_is_zero == _3dface->z_is_zero)
      pass ();
    else
      fail ("3DFACE.z_is_zero [B] " FORMAT_B " != " FORMAT_B "", _3dface->z_is_zero, z_is_zero);
    z_is_zero++;
    if (dwg_dynapi_entity_set_value (_3dface, "3DFACE", "z_is_zero", &z_is_zero, 0)
        && z_is_zero == _3dface->z_is_zero)
      pass ();
    else
      fail ("3DFACE.z_is_zero [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dface->z_is_zero, z_is_zero);
    _3dface->z_is_zero--;
  }
  if (failed && (is_class_unstable ("3DFACE") || is_class_debugging ("3DFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "3DFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test__3DSOLID (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity__3DSOLID *restrict _3dsolid = obj->tio.entity->tio._3DSOLID;
  failed = 0;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)_3dsolid->acis_data)
           : !_3dsolid->acis_data)
      pass ();
    else
      fail ("3DSOLID.acis_data [RC*] '%s' <> '%s'", acis_data, _3dsolid->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty", &acis_empty, NULL)
        && acis_empty == _3dsolid->acis_empty)
      pass ();
    else
      fail ("3DSOLID.acis_empty [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty", &acis_empty, 0)
        && acis_empty == _3dsolid->acis_empty)
      pass ();
    else
      fail ("3DSOLID.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty);
    _3dsolid->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == _3dsolid->acis_empty2)
      pass ();
    else
      fail ("3DSOLID.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == _3dsolid->acis_empty2)
      pass ();
    else
      fail ("3DSOLID.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2);
    _3dsolid->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == _3dsolid->acis_empty_bit)
      pass ();
    else
      fail ("3DSOLID.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == _3dsolid->acis_empty_bit)
      pass ();
    else
      fail ("3DSOLID.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit);
    _3dsolid->acis_empty_bit--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &_3dsolid->block_size, sizeof (_3dsolid->block_size)))
        pass ();
    else
        fail ("3DSOLID.block_size [BL*]");
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &_3dsolid->encr_sat_data, sizeof (_3dsolid->encr_sat_data)))
      pass ();
    else
      fail ("3DSOLID.encr_sat_data [char **]");
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &_3dsolid->extra_acis_data, sizeof (_3dsolid->extra_acis_data)))
        pass ();
    else
        fail ("3DSOLID.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &_3dsolid->history_id, sizeof (_3dsolid->history_id)))
        pass ();
    else
        fail ("3DSOLID.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "isoline_present", &isoline_present, NULL)
        && isoline_present == _3dsolid->isoline_present)
      pass ();
    else
      fail ("3DSOLID.isoline_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "isoline_present", &isoline_present, 0)
        && isoline_present == _3dsolid->isoline_present)
      pass ();
    else
      fail ("3DSOLID.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present);
    _3dsolid->isoline_present--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_blocks", &num_blocks, NULL)
        && num_blocks == _3dsolid->num_blocks)
      pass ();
    else
      fail ("3DSOLID.num_blocks [BL] %u != %u", _3dsolid->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_blocks", &num_blocks, 0)
        && num_blocks == _3dsolid->num_blocks)
      pass ();
    else
      fail ("3DSOLID.num_blocks [BL] set+1 %u != %u", _3dsolid->num_blocks, num_blocks);
    _3dsolid->num_blocks--;
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_isolines", &num_isolines, NULL)
        && num_isolines == _3dsolid->num_isolines)
      pass ();
    else
      fail ("3DSOLID.num_isolines [BL] %u != %u", _3dsolid->num_isolines, num_isolines);
    num_isolines++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_isolines", &num_isolines, 0)
        && num_isolines == _3dsolid->num_isolines)
      pass ();
    else
      fail ("3DSOLID.num_isolines [BL] set+1 %u != %u", _3dsolid->num_isolines, num_isolines);
    _3dsolid->num_isolines--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == _3dsolid->num_silhouettes)
      pass ();
    else
      fail ("3DSOLID.num_silhouettes [BL] %u != %u", _3dsolid->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == _3dsolid->num_silhouettes)
      pass ();
    else
      fail ("3DSOLID.num_silhouettes [BL] set+1 %u != %u", _3dsolid->num_silhouettes, num_silhouettes);
    _3dsolid->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_wires", &num_wires, NULL)
        && num_wires == _3dsolid->num_wires)
      pass ();
    else
      fail ("3DSOLID.num_wires [BL] %u != %u", _3dsolid->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_wires", &num_wires, 0)
        && num_wires == _3dsolid->num_wires)
      pass ();
    else
      fail ("3DSOLID.num_wires [BL] set+1 %u != %u", _3dsolid->num_wires, num_wires);
    _3dsolid->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "parent", &parent, NULL)
        && !memcmp (&parent, &_3dsolid->parent, sizeof (_3dsolid->parent)))
        pass ();
    else
        fail ("3DSOLID.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "point", &point, NULL)
        && !memcmp (&point, &_3dsolid->point, sizeof (_3dsolid->point)))
        pass ();
    else
        fail ("3DSOLID.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "point_present", &point_present, NULL)
        && point_present == _3dsolid->point_present)
      pass ();
    else
      fail ("3DSOLID.point_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "point_present", &point_present, 0)
        && point_present == _3dsolid->point_present)
      pass ();
    else
      fail ("3DSOLID.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present);
    _3dsolid->point_present--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "silhouettes", &silhouettes, NULL)
        && silhouettes == _3dsolid->silhouettes)
      pass ();
    else
      fail ("3DSOLID.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "unknown", &unknown, NULL)
        && unknown == _3dsolid->unknown)
      pass ();
    else
      fail ("3DSOLID.unknown [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "unknown", &unknown, 0)
        && unknown == _3dsolid->unknown)
      pass ();
    else
      fail ("3DSOLID.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown);
    _3dsolid->unknown--;
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "unknown_2007", &unknown_2007, NULL)
        && unknown_2007 == _3dsolid->unknown_2007)
      pass ();
    else
      fail ("3DSOLID.unknown_2007 [BL] %u != %u", _3dsolid->unknown_2007, unknown_2007);
    unknown_2007++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "unknown_2007", &unknown_2007, 0)
        && unknown_2007 == _3dsolid->unknown_2007)
      pass ();
    else
      fail ("3DSOLID.unknown_2007 [BL] set+1 %u != %u", _3dsolid->unknown_2007, unknown_2007);
    _3dsolid->unknown_2007--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "version", &version, NULL)
        && version == _3dsolid->version)
      pass ();
    else
      fail ("3DSOLID.version [BS] %hu != %hu", _3dsolid->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "version", &version, 0)
        && version == _3dsolid->version)
      pass ();
    else
      fail ("3DSOLID.version [BS] set+1 %hu != %hu", _3dsolid->version, version);
    _3dsolid->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == _3dsolid->wireframe_data_present)
      pass ();
    else
      fail ("3DSOLID.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == _3dsolid->wireframe_data_present)
      pass ();
    else
      fail ("3DSOLID.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present);
    _3dsolid->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "wires", &wires, NULL)
        && wires == _3dsolid->wires)
      pass ();
    else
      fail ("3DSOLID.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("3DSOLID") || is_class_debugging ("3DSOLID")))
    {
      ok ("%s failed %d tests (TODO unstable)", "3DSOLID", failed);
      failed = 0;
    }
  return failed;
}
static int test_ARC (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ARC *restrict arc = obj->tio.entity->tio.ARC;
  failed = 0;
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (arc, "ARC", "center", &center, NULL)
        && !memcmp (&center, &arc->center, sizeof (arc->center)))
        pass ();
    else
        fail ("ARC.center [3BD]");
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value (arc, "ARC", "end_angle", &end_angle, NULL)
        && end_angle == arc->end_angle)
      pass ();
    else
      fail ("ARC.end_angle [BD] %g != %g", arc->end_angle, end_angle);
    end_angle++;
    if (dwg_dynapi_entity_set_value (arc, "ARC", "end_angle", &end_angle, 0)
        && end_angle == arc->end_angle)
      pass ();
    else
      fail ("ARC.end_angle [BD] set+1 %g != %g", arc->end_angle, end_angle);
    arc->end_angle--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (arc, "ARC", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &arc->extrusion, sizeof (arc->extrusion)))
        pass ();
    else
        fail ("ARC.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (arc, "ARC", "parent", &parent, NULL)
        && !memcmp (&parent, &arc->parent, sizeof (arc->parent)))
        pass ();
    else
        fail ("ARC.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (arc, "ARC", "radius", &radius, NULL)
        && radius == arc->radius)
      pass ();
    else
      fail ("ARC.radius [BD] %g != %g", arc->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (arc, "ARC", "radius", &radius, 0)
        && radius == arc->radius)
      pass ();
    else
      fail ("ARC.radius [BD] set+1 %g != %g", arc->radius, radius);
    arc->radius--;
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (arc, "ARC", "start_angle", &start_angle, NULL)
        && start_angle == arc->start_angle)
      pass ();
    else
      fail ("ARC.start_angle [BD] %g != %g", arc->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (arc, "ARC", "start_angle", &start_angle, 0)
        && start_angle == arc->start_angle)
      pass ();
    else
      fail ("ARC.start_angle [BD] set+1 %g != %g", arc->start_angle, start_angle);
    arc->start_angle--;
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (arc, "ARC", "thickness", &thickness, NULL)
        && thickness == arc->thickness)
      pass ();
    else
      fail ("ARC.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", arc->thickness, thickness);
    if (dwg_dynapi_entity_set_value (arc, "ARC", "thickness", &thickness, 0)
        && thickness == arc->thickness)
      pass ();
    else
      fail ("ARC.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", arc->thickness, thickness);
    arc->thickness--;
  }
  if (failed && (is_class_unstable ("ARC") || is_class_debugging ("ARC")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ARC", failed);
      failed = 0;
    }
  return failed;
}
static int test_ARC_DIMENSION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ARC_DIMENSION *restrict arc_dimension = obj->tio.entity->tio.ARC_DIMENSION;
  failed = 0;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "_13_pt", &_13_pt, NULL)
        && !memcmp (&_13_pt, &arc_dimension->_13_pt, sizeof (arc_dimension->_13_pt)))
        pass ();
    else
        fail ("ARC_DIMENSION._13_pt [3BD]");
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "_14_pt", &_14_pt, NULL)
        && !memcmp (&_14_pt, &arc_dimension->_14_pt, sizeof (arc_dimension->_14_pt)))
        pass ();
    else
        fail ("ARC_DIMENSION._14_pt [3BD]");
  }
  {
    BITCODE_3BD _15_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "_15_pt", &_15_pt, NULL)
        && !memcmp (&_15_pt, &arc_dimension->_15_pt, sizeof (arc_dimension->_15_pt)))
        pass ();
    else
        fail ("ARC_DIMENSION._15_pt [3BD]");
  }
  {
    BITCODE_3BD _16_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "_16_pt", &_16_pt, NULL)
        && !memcmp (&_16_pt, &arc_dimension->_16_pt, sizeof (arc_dimension->_16_pt)))
        pass ();
    else
        fail ("ARC_DIMENSION._16_pt [3BD]");
  }
  {
    BITCODE_3BD _17_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "_17_pt", &_17_pt, NULL)
        && !memcmp (&_17_pt, &arc_dimension->_17_pt, sizeof (arc_dimension->_17_pt)))
        pass ();
    else
        fail ("ARC_DIMENSION._17_pt [3BD]");
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "act_measurement", &act_measurement, NULL)
        && act_measurement == arc_dimension->act_measurement)
      pass ();
    else
      fail ("ARC_DIMENSION.act_measurement [BD] %g != %g", arc_dimension->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "act_measurement", &act_measurement, 0)
        && act_measurement == arc_dimension->act_measurement)
      pass ();
    else
      fail ("ARC_DIMENSION.act_measurement [BD] set+1 %g != %g", arc_dimension->act_measurement, act_measurement);
    arc_dimension->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "attachment", &attachment, NULL)
        && attachment == arc_dimension->attachment)
      pass ();
    else
      fail ("ARC_DIMENSION.attachment [BS] %hu != %hu", arc_dimension->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "attachment", &attachment, 0)
        && attachment == arc_dimension->attachment)
      pass ();
    else
      fail ("ARC_DIMENSION.attachment [BS] set+1 %hu != %hu", arc_dimension->attachment, attachment);
    arc_dimension->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "block", &block, NULL)
        && !memcmp (&block, &arc_dimension->block, sizeof (arc_dimension->block)))
        pass ();
    else
        fail ("ARC_DIMENSION.block [H]");
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "blockname", &blockname, NULL)
        && blockname
           ? strEQ ((char *)blockname, (char *)arc_dimension->blockname)
           : !arc_dimension->blockname)
      pass ();
    else
      fail ("ARC_DIMENSION.blockname [TV] '%s' <> '%s'", blockname, arc_dimension->blockname);
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "class_version", &class_version, NULL)
        && class_version == arc_dimension->class_version)
      pass ();
    else
      fail ("ARC_DIMENSION.class_version [RC] %u != %u", arc_dimension->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "class_version", &class_version, 0)
        && class_version == arc_dimension->class_version)
      pass ();
    else
      fail ("ARC_DIMENSION.class_version [RC] set+1 %u != %u", arc_dimension->class_version, class_version);
    arc_dimension->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &arc_dimension->clone_ins_pt, sizeof (arc_dimension->clone_ins_pt)))
        pass ();
    else
        fail ("ARC_DIMENSION.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &arc_dimension->def_pt, sizeof (arc_dimension->def_pt)))
        pass ();
    else
        fail ("ARC_DIMENSION.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &arc_dimension->dimstyle, sizeof (arc_dimension->dimstyle)))
        pass ();
    else
        fail ("ARC_DIMENSION.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "elevation", &elevation, NULL)
        && elevation == arc_dimension->elevation)
      pass ();
    else
      fail ("ARC_DIMENSION.elevation [BD] %g != %g", arc_dimension->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "elevation", &elevation, 0)
        && elevation == arc_dimension->elevation)
      pass ();
    else
      fail ("ARC_DIMENSION.elevation [BD] set+1 %g != %g", arc_dimension->elevation, elevation);
    arc_dimension->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &arc_dimension->extrusion, sizeof (arc_dimension->extrusion)))
        pass ();
    else
        fail ("ARC_DIMENSION.extrusion [BE]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flag", &flag, NULL)
        && flag == arc_dimension->flag)
      pass ();
    else
      fail ("ARC_DIMENSION.flag [RC] %u != %u", arc_dimension->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flag", &flag, 0)
        && flag == arc_dimension->flag)
      pass ();
    else
      fail ("ARC_DIMENSION.flag [RC] set+1 %u != %u", arc_dimension->flag, flag);
    arc_dimension->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flag1", &flag1, NULL)
        && flag1 == arc_dimension->flag1)
      pass ();
    else
      fail ("ARC_DIMENSION.flag1 [RC] %u != %u", arc_dimension->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flag1", &flag1, 0)
        && flag1 == arc_dimension->flag1)
      pass ();
    else
      fail ("ARC_DIMENSION.flag1 [RC] set+1 %u != %u", arc_dimension->flag1, flag1);
    arc_dimension->flag1--;
  }
  {
    BITCODE_RC flag2;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flag2", &flag2, NULL)
        && flag2 == arc_dimension->flag2)
      pass ();
    else
      fail ("ARC_DIMENSION.flag2 [RC] %u != %u", arc_dimension->flag2, flag2);
    flag2++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flag2", &flag2, 0)
        && flag2 == arc_dimension->flag2)
      pass ();
    else
      fail ("ARC_DIMENSION.flag2 [RC] set+1 %u != %u", arc_dimension->flag2, flag2);
    arc_dimension->flag2--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == arc_dimension->flip_arrow1)
      pass ();
    else
      fail ("ARC_DIMENSION.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", arc_dimension->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == arc_dimension->flip_arrow1)
      pass ();
    else
      fail ("ARC_DIMENSION.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", arc_dimension->flip_arrow1, flip_arrow1);
    arc_dimension->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == arc_dimension->flip_arrow2)
      pass ();
    else
      fail ("ARC_DIMENSION.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", arc_dimension->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == arc_dimension->flip_arrow2)
      pass ();
    else
      fail ("ARC_DIMENSION.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", arc_dimension->flip_arrow2, flip_arrow2);
    arc_dimension->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == arc_dimension->horiz_dir)
      pass ();
    else
      fail ("ARC_DIMENSION.horiz_dir [BD] %g != %g", arc_dimension->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == arc_dimension->horiz_dir)
      pass ();
    else
      fail ("ARC_DIMENSION.horiz_dir [BD] set+1 %g != %g", arc_dimension->horiz_dir, horiz_dir);
    arc_dimension->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == arc_dimension->ins_rotation)
      pass ();
    else
      fail ("ARC_DIMENSION.ins_rotation [BD] %g != %g", arc_dimension->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == arc_dimension->ins_rotation)
      pass ();
    else
      fail ("ARC_DIMENSION.ins_rotation [BD] set+1 %g != %g", arc_dimension->ins_rotation, ins_rotation);
    arc_dimension->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &arc_dimension->ins_scale, sizeof (arc_dimension->ins_scale)))
        pass ();
    else
        fail ("ARC_DIMENSION.ins_scale [3BD]");
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "leader_len", &leader_len, NULL)
        && leader_len == arc_dimension->leader_len)
      pass ();
    else
      fail ("ARC_DIMENSION.leader_len [BD] %g != %g", arc_dimension->leader_len, leader_len);
    leader_len++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "leader_len", &leader_len, 0)
        && leader_len == arc_dimension->leader_len)
      pass ();
    else
      fail ("ARC_DIMENSION.leader_len [BD] set+1 %g != %g", arc_dimension->leader_len, leader_len);
    arc_dimension->leader_len--;
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == arc_dimension->lspace_factor)
      pass ();
    else
      fail ("ARC_DIMENSION.lspace_factor [BD] %g != %g", arc_dimension->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == arc_dimension->lspace_factor)
      pass ();
    else
      fail ("ARC_DIMENSION.lspace_factor [BD] set+1 %g != %g", arc_dimension->lspace_factor, lspace_factor);
    arc_dimension->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "lspace_style", &lspace_style, NULL)
        && lspace_style == arc_dimension->lspace_style)
      pass ();
    else
      fail ("ARC_DIMENSION.lspace_style [BS] %hu != %hu", arc_dimension->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "lspace_style", &lspace_style, 0)
        && lspace_style == arc_dimension->lspace_style)
      pass ();
    else
      fail ("ARC_DIMENSION.lspace_style [BS] set+1 %hu != %hu", arc_dimension->lspace_style, lspace_style);
    arc_dimension->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "parent", &parent, NULL)
        && !memcmp (&parent, &arc_dimension->parent, sizeof (arc_dimension->parent)))
        pass ();
    else
        fail ("ARC_DIMENSION.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &arc_dimension->text_midpt, sizeof (arc_dimension->text_midpt)))
        pass ();
    else
        fail ("ARC_DIMENSION.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "text_rotation", &text_rotation, NULL)
        && text_rotation == arc_dimension->text_rotation)
      pass ();
    else
      fail ("ARC_DIMENSION.text_rotation [BD] %g != %g", arc_dimension->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "text_rotation", &text_rotation, 0)
        && text_rotation == arc_dimension->text_rotation)
      pass ();
    else
      fail ("ARC_DIMENSION.text_rotation [BD] set+1 %g != %g", arc_dimension->text_rotation, text_rotation);
    arc_dimension->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "unknown", &unknown, NULL)
        && unknown == arc_dimension->unknown)
      pass ();
    else
      fail ("ARC_DIMENSION.unknown [B] " FORMAT_B " != " FORMAT_B "", arc_dimension->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "unknown", &unknown, 0)
        && unknown == arc_dimension->unknown)
      pass ();
    else
      fail ("ARC_DIMENSION.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", arc_dimension->unknown, unknown);
    arc_dimension->unknown--;
  }
  {
    BITCODE_3BD unknown_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "unknown_pt", &unknown_pt, NULL)
        && !memcmp (&unknown_pt, &arc_dimension->unknown_pt, sizeof (arc_dimension->unknown_pt)))
        pass ();
    else
        fail ("ARC_DIMENSION.unknown_pt [3BD]");
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)arc_dimension->user_text)
           : !arc_dimension->user_text)
      pass ();
    else
      fail ("ARC_DIMENSION.user_text [TV] '%s' <> '%s'", user_text, arc_dimension->user_text);
  }
  if (failed && (is_class_unstable ("ARC_DIMENSION") || is_class_debugging ("ARC_DIMENSION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ARC_DIMENSION", failed);
      failed = 0;
    }
  return failed;
}
static int test_ATTDEF (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ATTDEF *restrict attdef = obj->tio.entity->tio.ATTDEF;
  failed = 0;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &attdef->alignment_pt, sizeof (attdef->alignment_pt)))
        pass ();
    else
        fail ("ATTDEF.alignment_pt [2DPOINT]");
  }
  {
    BITCODE_H annotative_app;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "annotative_app", &annotative_app, NULL)
        && !memcmp (&annotative_app, &attdef->annotative_app, sizeof (attdef->annotative_app)))
        pass ();
    else
        fail ("ATTDEF.annotative_app [H]");
  }
  {
    BITCODE_RC annotative_data_bytes;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "annotative_data_bytes", &annotative_data_bytes, NULL)
        && annotative_data_bytes == attdef->annotative_data_bytes)
      pass ();
    else
      fail ("ATTDEF.annotative_data_bytes [RC] %u != %u", attdef->annotative_data_bytes, annotative_data_bytes);
    annotative_data_bytes++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "annotative_data_bytes", &annotative_data_bytes, 0)
        && annotative_data_bytes == attdef->annotative_data_bytes)
      pass ();
    else
      fail ("ATTDEF.annotative_data_bytes [RC] set+1 %u != %u", attdef->annotative_data_bytes, annotative_data_bytes);
    attdef->annotative_data_bytes--;
  }
  {
    BITCODE_BS annotative_data_size;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "annotative_data_size", &annotative_data_size, NULL)
        && annotative_data_size == attdef->annotative_data_size)
      pass ();
    else
      fail ("ATTDEF.annotative_data_size [BS] %hu != %hu", attdef->annotative_data_size, annotative_data_size);
    annotative_data_size++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "annotative_data_size", &annotative_data_size, 0)
        && annotative_data_size == attdef->annotative_data_size)
      pass ();
    else
      fail ("ATTDEF.annotative_data_size [BS] set+1 %hu != %hu", attdef->annotative_data_size, annotative_data_size);
    attdef->annotative_data_size--;
  }
  {
    BITCODE_BS annotative_short;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "annotative_short", &annotative_short, NULL)
        && annotative_short == attdef->annotative_short)
      pass ();
    else
      fail ("ATTDEF.annotative_short [BS] %hu != %hu", attdef->annotative_short, annotative_short);
    annotative_short++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "annotative_short", &annotative_short, 0)
        && annotative_short == attdef->annotative_short)
      pass ();
    else
      fail ("ATTDEF.annotative_short [BS] set+1 %hu != %hu", attdef->annotative_short, annotative_short);
    attdef->annotative_short--;
  }
  {
    BITCODE_RC attdef_class_version;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "attdef_class_version", &attdef_class_version, NULL)
        && attdef_class_version == attdef->attdef_class_version)
      pass ();
    else
      fail ("ATTDEF.attdef_class_version [RC] %u != %u", attdef->attdef_class_version, attdef_class_version);
    attdef_class_version++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "attdef_class_version", &attdef_class_version, 0)
        && attdef_class_version == attdef->attdef_class_version)
      pass ();
    else
      fail ("ATTDEF.attdef_class_version [RC] set+1 %u != %u", attdef->attdef_class_version, attdef_class_version);
    attdef->attdef_class_version--;
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "class_version", &class_version, NULL)
        && class_version == attdef->class_version)
      pass ();
    else
      fail ("ATTDEF.class_version [RC] %u != %u", attdef->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "class_version", &class_version, 0)
        && class_version == attdef->class_version)
      pass ();
    else
      fail ("ATTDEF.class_version [RC] set+1 %u != %u", attdef->class_version, class_version);
    attdef->class_version--;
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "dataflags", &dataflags, NULL)
        && dataflags == attdef->dataflags)
      pass ();
    else
      fail ("ATTDEF.dataflags [RC] %u != %u", attdef->dataflags, dataflags);
    dataflags++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "dataflags", &dataflags, 0)
        && dataflags == attdef->dataflags)
      pass ();
    else
      fail ("ATTDEF.dataflags [RC] set+1 %u != %u", attdef->dataflags, dataflags);
    attdef->dataflags--;
  }
  {
    BITCODE_T default_value;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "default_value", &default_value, NULL)
        && default_value
           ? strEQ ((char *)default_value, (char *)attdef->default_value)
           : !attdef->default_value)
      pass ();
    else
      fail ("ATTDEF.default_value [T] '%s' <> '%s'", default_value, attdef->default_value);
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "elevation", &elevation, NULL)
        && elevation == attdef->elevation)
      pass ();
    else
      fail ("ATTDEF.elevation [BD] %g != %g", attdef->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "elevation", &elevation, 0)
        && elevation == attdef->elevation)
      pass ();
    else
      fail ("ATTDEF.elevation [BD] set+1 %g != %g", attdef->elevation, elevation);
    attdef->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &attdef->extrusion, sizeof (attdef->extrusion)))
        pass ();
    else
        fail ("ATTDEF.extrusion [BE]");
  }
  {
    BITCODE_BS field_length;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "field_length", &field_length, NULL)
        && field_length == attdef->field_length)
      pass ();
    else
      fail ("ATTDEF.field_length [BS] %hu != %hu", attdef->field_length, field_length);
    field_length++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "field_length", &field_length, 0)
        && field_length == attdef->field_length)
      pass ();
    else
      fail ("ATTDEF.field_length [BS] set+1 %hu != %hu", attdef->field_length, field_length);
    attdef->field_length--;
  }
  {
    BITCODE_RC flags;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "flags", &flags, NULL)
        && flags == attdef->flags)
      pass ();
    else
      fail ("ATTDEF.flags [RC] %u != %u", attdef->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "flags", &flags, 0)
        && flags == attdef->flags)
      pass ();
    else
      fail ("ATTDEF.flags [RC] set+1 %u != %u", attdef->flags, flags);
    attdef->flags--;
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "generation", &generation, NULL)
        && generation == attdef->generation)
      pass ();
    else
      fail ("ATTDEF.generation [BS] %hu != %hu", attdef->generation, generation);
    generation++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "generation", &generation, 0)
        && generation == attdef->generation)
      pass ();
    else
      fail ("ATTDEF.generation [BS] set+1 %hu != %hu", attdef->generation, generation);
    attdef->generation--;
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "height", &height, NULL)
        && height == attdef->height)
      pass ();
    else
      fail ("ATTDEF.height [RD] %g != %g", attdef->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "height", &height, 0)
        && height == attdef->height)
      pass ();
    else
      fail ("ATTDEF.height [RD] set+1 %g != %g", attdef->height, height);
    attdef->height--;
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "horiz_alignment", &horiz_alignment, NULL)
        && horiz_alignment == attdef->horiz_alignment)
      pass ();
    else
      fail ("ATTDEF.horiz_alignment [BS] %hu != %hu", attdef->horiz_alignment, horiz_alignment);
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "horiz_alignment", &horiz_alignment, 0)
        && horiz_alignment == attdef->horiz_alignment)
      pass ();
    else
      fail ("ATTDEF.horiz_alignment [BS] set+1 %hu != %hu", attdef->horiz_alignment, horiz_alignment);
    attdef->horiz_alignment--;
  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "insertion_pt", &insertion_pt, NULL)
        && !memcmp (&insertion_pt, &attdef->insertion_pt, sizeof (attdef->insertion_pt)))
        pass ();
    else
        fail ("ATTDEF.insertion_pt [2DPOINT]");
  }
  {
    BITCODE_B lock_position_flag;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "lock_position_flag", &lock_position_flag, NULL)
        && lock_position_flag == attdef->lock_position_flag)
      pass ();
    else
      fail ("ATTDEF.lock_position_flag [B] " FORMAT_B " != " FORMAT_B "", attdef->lock_position_flag, lock_position_flag);
    lock_position_flag++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "lock_position_flag", &lock_position_flag, 0)
        && lock_position_flag == attdef->lock_position_flag)
      pass ();
    else
      fail ("ATTDEF.lock_position_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", attdef->lock_position_flag, lock_position_flag);
    attdef->lock_position_flag--;
  }
  {
    BITCODE_H mtext_handles;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "mtext_handles", &mtext_handles, NULL)
        && !memcmp (&mtext_handles, &attdef->mtext_handles, sizeof (attdef->mtext_handles)))
        pass ();
    else
        fail ("ATTDEF.mtext_handles [H]");
  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "oblique_ang", &oblique_ang, NULL)
        && oblique_ang == attdef->oblique_ang)
      pass ();
    else
      fail ("ATTDEF.oblique_ang [RD] %g != %g", attdef->oblique_ang, oblique_ang);
    oblique_ang++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "oblique_ang", &oblique_ang, 0)
        && oblique_ang == attdef->oblique_ang)
      pass ();
    else
      fail ("ATTDEF.oblique_ang [RD] set+1 %g != %g", attdef->oblique_ang, oblique_ang);
    attdef->oblique_ang--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "parent", &parent, NULL)
        && !memcmp (&parent, &attdef->parent, sizeof (attdef->parent)))
        pass ();
    else
        fail ("ATTDEF.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_T prompt;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "prompt", &prompt, NULL)
        && prompt
           ? strEQ ((char *)prompt, (char *)attdef->prompt)
           : !attdef->prompt)
      pass ();
    else
      fail ("ATTDEF.prompt [T] '%s' <> '%s'", prompt, attdef->prompt);
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "rotation", &rotation, NULL)
        && rotation == attdef->rotation)
      pass ();
    else
      fail ("ATTDEF.rotation [RD] %g != %g", attdef->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "rotation", &rotation, 0)
        && rotation == attdef->rotation)
      pass ();
    else
      fail ("ATTDEF.rotation [RD] set+1 %g != %g", attdef->rotation, rotation);
    attdef->rotation--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "style", &style, NULL)
        && !memcmp (&style, &attdef->style, sizeof (attdef->style)))
        pass ();
    else
        fail ("ATTDEF.style [H]");
  }
  {
    BITCODE_T tag;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "tag", &tag, NULL)
        && tag
           ? strEQ ((char *)tag, (char *)attdef->tag)
           : !attdef->tag)
      pass ();
    else
      fail ("ATTDEF.tag [T] '%s' <> '%s'", tag, attdef->tag);
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "thickness", &thickness, NULL)
        && thickness == attdef->thickness)
      pass ();
    else
      fail ("ATTDEF.thickness [RD] %g != %g", attdef->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "thickness", &thickness, 0)
        && thickness == attdef->thickness)
      pass ();
    else
      fail ("ATTDEF.thickness [RD] set+1 %g != %g", attdef->thickness, thickness);
    attdef->thickness--;
  }
  {
    BITCODE_RC type;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "type", &type, NULL)
        && type == attdef->type)
      pass ();
    else
      fail ("ATTDEF.type [RC] %u != %u", attdef->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "type", &type, 0)
        && type == attdef->type)
      pass ();
    else
      fail ("ATTDEF.type [RC] set+1 %u != %u", attdef->type, type);
    attdef->type--;
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "vert_alignment", &vert_alignment, NULL)
        && vert_alignment == attdef->vert_alignment)
      pass ();
    else
      fail ("ATTDEF.vert_alignment [BS] %hu != %hu", attdef->vert_alignment, vert_alignment);
    vert_alignment++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "vert_alignment", &vert_alignment, 0)
        && vert_alignment == attdef->vert_alignment)
      pass ();
    else
      fail ("ATTDEF.vert_alignment [BS] set+1 %hu != %hu", attdef->vert_alignment, vert_alignment);
    attdef->vert_alignment--;
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "width_factor", &width_factor, NULL)
        && width_factor == attdef->width_factor)
      pass ();
    else
      fail ("ATTDEF.width_factor [RD] %g != %g", attdef->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "width_factor", &width_factor, 0)
        && width_factor == attdef->width_factor)
      pass ();
    else
      fail ("ATTDEF.width_factor [RD] set+1 %g != %g", attdef->width_factor, width_factor);
    attdef->width_factor--;
  }
  if (failed && (is_class_unstable ("ATTDEF") || is_class_debugging ("ATTDEF")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ATTDEF", failed);
      failed = 0;
    }
  return failed;
}
static int test_ATTRIB (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ATTRIB *restrict attrib = obj->tio.entity->tio.ATTRIB;
  failed = 0;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &attrib->alignment_pt, sizeof (attrib->alignment_pt)))
        pass ();
    else
        fail ("ATTRIB.alignment_pt [2DPOINT]");
  }
  {
    BITCODE_H annotative_app;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "annotative_app", &annotative_app, NULL)
        && !memcmp (&annotative_app, &attrib->annotative_app, sizeof (attrib->annotative_app)))
        pass ();
    else
        fail ("ATTRIB.annotative_app [H]");
  }
  {
    BITCODE_RC annotative_data_bytes;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "annotative_data_bytes", &annotative_data_bytes, NULL)
        && annotative_data_bytes == attrib->annotative_data_bytes)
      pass ();
    else
      fail ("ATTRIB.annotative_data_bytes [RC] %u != %u", attrib->annotative_data_bytes, annotative_data_bytes);
    annotative_data_bytes++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "annotative_data_bytes", &annotative_data_bytes, 0)
        && annotative_data_bytes == attrib->annotative_data_bytes)
      pass ();
    else
      fail ("ATTRIB.annotative_data_bytes [RC] set+1 %u != %u", attrib->annotative_data_bytes, annotative_data_bytes);
    attrib->annotative_data_bytes--;
  }
  {
    BITCODE_BS annotative_data_size;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "annotative_data_size", &annotative_data_size, NULL)
        && annotative_data_size == attrib->annotative_data_size)
      pass ();
    else
      fail ("ATTRIB.annotative_data_size [BS] %hu != %hu", attrib->annotative_data_size, annotative_data_size);
    annotative_data_size++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "annotative_data_size", &annotative_data_size, 0)
        && annotative_data_size == attrib->annotative_data_size)
      pass ();
    else
      fail ("ATTRIB.annotative_data_size [BS] set+1 %hu != %hu", attrib->annotative_data_size, annotative_data_size);
    attrib->annotative_data_size--;
  }
  {
    BITCODE_BS annotative_short;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "annotative_short", &annotative_short, NULL)
        && annotative_short == attrib->annotative_short)
      pass ();
    else
      fail ("ATTRIB.annotative_short [BS] %hu != %hu", attrib->annotative_short, annotative_short);
    annotative_short++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "annotative_short", &annotative_short, 0)
        && annotative_short == attrib->annotative_short)
      pass ();
    else
      fail ("ATTRIB.annotative_short [BS] set+1 %hu != %hu", attrib->annotative_short, annotative_short);
    attrib->annotative_short--;
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "class_version", &class_version, NULL)
        && class_version == attrib->class_version)
      pass ();
    else
      fail ("ATTRIB.class_version [RC] %u != %u", attrib->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "class_version", &class_version, 0)
        && class_version == attrib->class_version)
      pass ();
    else
      fail ("ATTRIB.class_version [RC] set+1 %u != %u", attrib->class_version, class_version);
    attrib->class_version--;
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "dataflags", &dataflags, NULL)
        && dataflags == attrib->dataflags)
      pass ();
    else
      fail ("ATTRIB.dataflags [RC] %u != %u", attrib->dataflags, dataflags);
    dataflags++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "dataflags", &dataflags, 0)
        && dataflags == attrib->dataflags)
      pass ();
    else
      fail ("ATTRIB.dataflags [RC] set+1 %u != %u", attrib->dataflags, dataflags);
    attrib->dataflags--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "elevation", &elevation, NULL)
        && elevation == attrib->elevation)
      pass ();
    else
      fail ("ATTRIB.elevation [BD] %g != %g", attrib->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "elevation", &elevation, 0)
        && elevation == attrib->elevation)
      pass ();
    else
      fail ("ATTRIB.elevation [BD] set+1 %g != %g", attrib->elevation, elevation);
    attrib->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &attrib->extrusion, sizeof (attrib->extrusion)))
        pass ();
    else
        fail ("ATTRIB.extrusion [BE]");
  }
  {
    BITCODE_BS field_length;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "field_length", &field_length, NULL)
        && field_length == attrib->field_length)
      pass ();
    else
      fail ("ATTRIB.field_length [BS] %hu != %hu", attrib->field_length, field_length);
    field_length++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "field_length", &field_length, 0)
        && field_length == attrib->field_length)
      pass ();
    else
      fail ("ATTRIB.field_length [BS] set+1 %hu != %hu", attrib->field_length, field_length);
    attrib->field_length--;
  }
  {
    BITCODE_RC flags;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "flags", &flags, NULL)
        && flags == attrib->flags)
      pass ();
    else
      fail ("ATTRIB.flags [RC] %u != %u", attrib->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "flags", &flags, 0)
        && flags == attrib->flags)
      pass ();
    else
      fail ("ATTRIB.flags [RC] set+1 %u != %u", attrib->flags, flags);
    attrib->flags--;
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "generation", &generation, NULL)
        && generation == attrib->generation)
      pass ();
    else
      fail ("ATTRIB.generation [BS] %hu != %hu", attrib->generation, generation);
    generation++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "generation", &generation, 0)
        && generation == attrib->generation)
      pass ();
    else
      fail ("ATTRIB.generation [BS] set+1 %hu != %hu", attrib->generation, generation);
    attrib->generation--;
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "height", &height, NULL)
        && height == attrib->height)
      pass ();
    else
      fail ("ATTRIB.height [RD] %g != %g", attrib->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "height", &height, 0)
        && height == attrib->height)
      pass ();
    else
      fail ("ATTRIB.height [RD] set+1 %g != %g", attrib->height, height);
    attrib->height--;
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "horiz_alignment", &horiz_alignment, NULL)
        && horiz_alignment == attrib->horiz_alignment)
      pass ();
    else
      fail ("ATTRIB.horiz_alignment [BS] %hu != %hu", attrib->horiz_alignment, horiz_alignment);
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "horiz_alignment", &horiz_alignment, 0)
        && horiz_alignment == attrib->horiz_alignment)
      pass ();
    else
      fail ("ATTRIB.horiz_alignment [BS] set+1 %hu != %hu", attrib->horiz_alignment, horiz_alignment);
    attrib->horiz_alignment--;
  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "insertion_pt", &insertion_pt, NULL)
        && !memcmp (&insertion_pt, &attrib->insertion_pt, sizeof (attrib->insertion_pt)))
        pass ();
    else
        fail ("ATTRIB.insertion_pt [2DPOINT]");
  }
  {
    BITCODE_B lock_position_flag;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "lock_position_flag", &lock_position_flag, NULL)
        && lock_position_flag == attrib->lock_position_flag)
      pass ();
    else
      fail ("ATTRIB.lock_position_flag [B] " FORMAT_B " != " FORMAT_B "", attrib->lock_position_flag, lock_position_flag);
    lock_position_flag++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "lock_position_flag", &lock_position_flag, 0)
        && lock_position_flag == attrib->lock_position_flag)
      pass ();
    else
      fail ("ATTRIB.lock_position_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", attrib->lock_position_flag, lock_position_flag);
    attrib->lock_position_flag--;
  }
  {
    BITCODE_H mtext_handles;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "mtext_handles", &mtext_handles, NULL)
        && !memcmp (&mtext_handles, &attrib->mtext_handles, sizeof (attrib->mtext_handles)))
        pass ();
    else
        fail ("ATTRIB.mtext_handles [H]");
  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "oblique_ang", &oblique_ang, NULL)
        && oblique_ang == attrib->oblique_ang)
      pass ();
    else
      fail ("ATTRIB.oblique_ang [RD] %g != %g", attrib->oblique_ang, oblique_ang);
    oblique_ang++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "oblique_ang", &oblique_ang, 0)
        && oblique_ang == attrib->oblique_ang)
      pass ();
    else
      fail ("ATTRIB.oblique_ang [RD] set+1 %g != %g", attrib->oblique_ang, oblique_ang);
    attrib->oblique_ang--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "parent", &parent, NULL)
        && !memcmp (&parent, &attrib->parent, sizeof (attrib->parent)))
        pass ();
    else
        fail ("ATTRIB.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "rotation", &rotation, NULL)
        && rotation == attrib->rotation)
      pass ();
    else
      fail ("ATTRIB.rotation [RD] %g != %g", attrib->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "rotation", &rotation, 0)
        && rotation == attrib->rotation)
      pass ();
    else
      fail ("ATTRIB.rotation [RD] set+1 %g != %g", attrib->rotation, rotation);
    attrib->rotation--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "style", &style, NULL)
        && !memcmp (&style, &attrib->style, sizeof (attrib->style)))
        pass ();
    else
        fail ("ATTRIB.style [H]");
  }
  {
    BITCODE_T tag;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "tag", &tag, NULL)
        && tag
           ? strEQ ((char *)tag, (char *)attrib->tag)
           : !attrib->tag)
      pass ();
    else
      fail ("ATTRIB.tag [T] '%s' <> '%s'", tag, attrib->tag);
  }
  {
    BITCODE_T text_value;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "text_value", &text_value, NULL)
        && text_value
           ? strEQ ((char *)text_value, (char *)attrib->text_value)
           : !attrib->text_value)
      pass ();
    else
      fail ("ATTRIB.text_value [T] '%s' <> '%s'", text_value, attrib->text_value);
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "thickness", &thickness, NULL)
        && thickness == attrib->thickness)
      pass ();
    else
      fail ("ATTRIB.thickness [RD] %g != %g", attrib->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "thickness", &thickness, 0)
        && thickness == attrib->thickness)
      pass ();
    else
      fail ("ATTRIB.thickness [RD] set+1 %g != %g", attrib->thickness, thickness);
    attrib->thickness--;
  }
  {
    BITCODE_RC type;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "type", &type, NULL)
        && type == attrib->type)
      pass ();
    else
      fail ("ATTRIB.type [RC] %u != %u", attrib->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "type", &type, 0)
        && type == attrib->type)
      pass ();
    else
      fail ("ATTRIB.type [RC] set+1 %u != %u", attrib->type, type);
    attrib->type--;
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "vert_alignment", &vert_alignment, NULL)
        && vert_alignment == attrib->vert_alignment)
      pass ();
    else
      fail ("ATTRIB.vert_alignment [BS] %hu != %hu", attrib->vert_alignment, vert_alignment);
    vert_alignment++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "vert_alignment", &vert_alignment, 0)
        && vert_alignment == attrib->vert_alignment)
      pass ();
    else
      fail ("ATTRIB.vert_alignment [BS] set+1 %hu != %hu", attrib->vert_alignment, vert_alignment);
    attrib->vert_alignment--;
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "width_factor", &width_factor, NULL)
        && width_factor == attrib->width_factor)
      pass ();
    else
      fail ("ATTRIB.width_factor [RD] %g != %g", attrib->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "width_factor", &width_factor, 0)
        && width_factor == attrib->width_factor)
      pass ();
    else
      fail ("ATTRIB.width_factor [RD] set+1 %g != %g", attrib->width_factor, width_factor);
    attrib->width_factor--;
  }
  if (failed && (is_class_unstable ("ATTRIB") || is_class_debugging ("ATTRIB")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ATTRIB", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCK (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_BLOCK *restrict block = obj->tio.entity->tio.BLOCK;
  failed = 0;
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (block, "BLOCK", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)block->name)
           : !block->name)
      pass ();
    else
      fail ("BLOCK.name [TV] '%s' <> '%s'", name, block->name);
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (block, "BLOCK", "parent", &parent, NULL)
        && !memcmp (&parent, &block->parent, sizeof (block->parent)))
        pass ();
    else
        fail ("BLOCK.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("BLOCK") || is_class_debugging ("BLOCK")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCK", failed);
      failed = 0;
    }
  return failed;
}
static int test_BODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_BODY *restrict body = obj->tio.entity->tio.BODY;
  failed = 0;
  if (failed && (is_class_unstable ("BODY") || is_class_debugging ("BODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_CAMERA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_CAMERA *restrict camera = obj->tio.entity->tio.CAMERA;
  failed = 0;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (camera, "CAMERA", "parent", &parent, NULL)
        && !memcmp (&parent, &camera->parent, sizeof (camera->parent)))
        pass ();
    else
        fail ("CAMERA.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H view;
    if (dwg_dynapi_entity_value (camera, "CAMERA", "view", &view, NULL)
        && !memcmp (&view, &camera->view, sizeof (camera->view)))
        pass ();
    else
        fail ("CAMERA.view [H]");
  }
  if (failed && (is_class_unstable ("CAMERA") || is_class_debugging ("CAMERA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CAMERA", failed);
      failed = 0;
    }
  return failed;
}
static int test_CIRCLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_CIRCLE *restrict circle = obj->tio.entity->tio.CIRCLE;
  failed = 0;
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "center", &center, NULL)
        && !memcmp (&center, &circle->center, sizeof (circle->center)))
        pass ();
    else
        fail ("CIRCLE.center [3BD]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &circle->extrusion, sizeof (circle->extrusion)))
        pass ();
    else
        fail ("CIRCLE.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "parent", &parent, NULL)
        && !memcmp (&parent, &circle->parent, sizeof (circle->parent)))
        pass ();
    else
        fail ("CIRCLE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "radius", &radius, NULL)
        && radius == circle->radius)
      pass ();
    else
      fail ("CIRCLE.radius [BD] %g != %g", circle->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (circle, "CIRCLE", "radius", &radius, 0)
        && radius == circle->radius)
      pass ();
    else
      fail ("CIRCLE.radius [BD] set+1 %g != %g", circle->radius, radius);
    circle->radius--;
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "thickness", &thickness, NULL)
        && thickness == circle->thickness)
      pass ();
    else
      fail ("CIRCLE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", circle->thickness, thickness);
    if (dwg_dynapi_entity_set_value (circle, "CIRCLE", "thickness", &thickness, 0)
        && thickness == circle->thickness)
      pass ();
    else
      fail ("CIRCLE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", circle->thickness, thickness);
    circle->thickness--;
  }
  if (failed && (is_class_unstable ("CIRCLE") || is_class_debugging ("CIRCLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CIRCLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_ALIGNED (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_ALIGNED *restrict dimension_aligned = obj->tio.entity->tio.DIMENSION_ALIGNED;
  failed = 0;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "_13_pt", &_13_pt, NULL)
        && !memcmp (&_13_pt, &dimension_aligned->_13_pt, sizeof (dimension_aligned->_13_pt)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED._13_pt [3BD]");
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "_14_pt", &_14_pt, NULL)
        && !memcmp (&_14_pt, &dimension_aligned->_14_pt, sizeof (dimension_aligned->_14_pt)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED._14_pt [3BD]");
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_aligned->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.act_measurement [BD] %g != %g", dimension_aligned->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_aligned->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.act_measurement [BD] set+1 %g != %g", dimension_aligned->act_measurement, act_measurement);
    dimension_aligned->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "attachment", &attachment, NULL)
        && attachment == dimension_aligned->attachment)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.attachment [BS] %hu != %hu", dimension_aligned->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "attachment", &attachment, 0)
        && attachment == dimension_aligned->attachment)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.attachment [BS] set+1 %hu != %hu", dimension_aligned->attachment, attachment);
    dimension_aligned->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "block", &block, NULL)
        && !memcmp (&block, &dimension_aligned->block, sizeof (dimension_aligned->block)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.block [H]");
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "blockname", &blockname, NULL)
        && blockname
           ? strEQ ((char *)blockname, (char *)dimension_aligned->blockname)
           : !dimension_aligned->blockname)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.blockname [TV] '%s' <> '%s'", blockname, dimension_aligned->blockname);
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "class_version", &class_version, NULL)
        && class_version == dimension_aligned->class_version)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.class_version [RC] %u != %u", dimension_aligned->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "class_version", &class_version, 0)
        && class_version == dimension_aligned->class_version)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.class_version [RC] set+1 %u != %u", dimension_aligned->class_version, class_version);
    dimension_aligned->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_aligned->clone_ins_pt, sizeof (dimension_aligned->clone_ins_pt)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_aligned->def_pt, sizeof (dimension_aligned->def_pt)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_aligned->dimstyle, sizeof (dimension_aligned->dimstyle)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "elevation", &elevation, NULL)
        && elevation == dimension_aligned->elevation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.elevation [BD] %g != %g", dimension_aligned->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "elevation", &elevation, 0)
        && elevation == dimension_aligned->elevation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.elevation [BD] set+1 %g != %g", dimension_aligned->elevation, elevation);
    dimension_aligned->elevation--;
  }
  {
    BITCODE_BD ext_line_rotation;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "ext_line_rotation", &ext_line_rotation, NULL)
        && ext_line_rotation == dimension_aligned->ext_line_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.ext_line_rotation [BD] %g != %g", dimension_aligned->ext_line_rotation, ext_line_rotation);
    ext_line_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "ext_line_rotation", &ext_line_rotation, 0)
        && ext_line_rotation == dimension_aligned->ext_line_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.ext_line_rotation [BD] set+1 %g != %g", dimension_aligned->ext_line_rotation, ext_line_rotation);
    dimension_aligned->ext_line_rotation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_aligned->extrusion, sizeof (dimension_aligned->extrusion)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.extrusion [BE]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "flag", &flag, NULL)
        && flag == dimension_aligned->flag)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flag [RC] %u != %u", dimension_aligned->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "flag", &flag, 0)
        && flag == dimension_aligned->flag)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flag [RC] set+1 %u != %u", dimension_aligned->flag, flag);
    dimension_aligned->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "flag1", &flag1, NULL)
        && flag1 == dimension_aligned->flag1)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flag1 [RC] %u != %u", dimension_aligned->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "flag1", &flag1, 0)
        && flag1 == dimension_aligned->flag1)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flag1 [RC] set+1 %u != %u", dimension_aligned->flag1, flag1);
    dimension_aligned->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_aligned->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_aligned->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_aligned->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_aligned->flip_arrow1, flip_arrow1);
    dimension_aligned->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_aligned->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_aligned->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_aligned->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_aligned->flip_arrow2, flip_arrow2);
    dimension_aligned->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_aligned->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.horiz_dir [BD] %g != %g", dimension_aligned->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_aligned->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.horiz_dir [BD] set+1 %g != %g", dimension_aligned->horiz_dir, horiz_dir);
    dimension_aligned->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_aligned->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.ins_rotation [BD] %g != %g", dimension_aligned->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_aligned->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.ins_rotation [BD] set+1 %g != %g", dimension_aligned->ins_rotation, ins_rotation);
    dimension_aligned->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_aligned->ins_scale, sizeof (dimension_aligned->ins_scale)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.ins_scale [3BD]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_aligned->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.lspace_factor [BD] %g != %g", dimension_aligned->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_aligned->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.lspace_factor [BD] set+1 %g != %g", dimension_aligned->lspace_factor, lspace_factor);
    dimension_aligned->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_aligned->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.lspace_style [BS] %hu != %hu", dimension_aligned->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_aligned->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.lspace_style [BS] set+1 %hu != %hu", dimension_aligned->lspace_style, lspace_style);
    dimension_aligned->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_aligned->parent, sizeof (dimension_aligned->parent)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_aligned->text_midpt, sizeof (dimension_aligned->text_midpt)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_aligned->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.text_rotation [BD] %g != %g", dimension_aligned->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_aligned->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.text_rotation [BD] set+1 %g != %g", dimension_aligned->text_rotation, text_rotation);
    dimension_aligned->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "unknown", &unknown, NULL)
        && unknown == dimension_aligned->unknown)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_aligned->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "unknown", &unknown, 0)
        && unknown == dimension_aligned->unknown)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_aligned->unknown, unknown);
    dimension_aligned->unknown--;
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_aligned->user_text)
           : !dimension_aligned->user_text)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.user_text [TV] '%s' <> '%s'", user_text, dimension_aligned->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_ALIGNED") || is_class_debugging ("DIMENSION_ALIGNED")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_ALIGNED", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_ANG2LN (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_ANG2LN *restrict dimension_ang2ln = obj->tio.entity->tio.DIMENSION_ANG2LN;
  failed = 0;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "_13_pt", &_13_pt, NULL)
        && !memcmp (&_13_pt, &dimension_ang2ln->_13_pt, sizeof (dimension_ang2ln->_13_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN._13_pt [3BD]");
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "_14_pt", &_14_pt, NULL)
        && !memcmp (&_14_pt, &dimension_ang2ln->_14_pt, sizeof (dimension_ang2ln->_14_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN._14_pt [3BD]");
  }
  {
    BITCODE_2RD _16_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "_16_pt", &_16_pt, NULL)
        && !memcmp (&_16_pt, &dimension_ang2ln->_16_pt, sizeof (dimension_ang2ln->_16_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN._16_pt [2RD]");
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_ang2ln->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.act_measurement [BD] %g != %g", dimension_ang2ln->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_ang2ln->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.act_measurement [BD] set+1 %g != %g", dimension_ang2ln->act_measurement, act_measurement);
    dimension_ang2ln->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "attachment", &attachment, NULL)
        && attachment == dimension_ang2ln->attachment)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.attachment [BS] %hu != %hu", dimension_ang2ln->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "attachment", &attachment, 0)
        && attachment == dimension_ang2ln->attachment)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.attachment [BS] set+1 %hu != %hu", dimension_ang2ln->attachment, attachment);
    dimension_ang2ln->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "block", &block, NULL)
        && !memcmp (&block, &dimension_ang2ln->block, sizeof (dimension_ang2ln->block)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.block [H]");
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "blockname", &blockname, NULL)
        && blockname
           ? strEQ ((char *)blockname, (char *)dimension_ang2ln->blockname)
           : !dimension_ang2ln->blockname)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.blockname [TV] '%s' <> '%s'", blockname, dimension_ang2ln->blockname);
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "class_version", &class_version, NULL)
        && class_version == dimension_ang2ln->class_version)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.class_version [RC] %u != %u", dimension_ang2ln->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "class_version", &class_version, 0)
        && class_version == dimension_ang2ln->class_version)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.class_version [RC] set+1 %u != %u", dimension_ang2ln->class_version, class_version);
    dimension_ang2ln->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_ang2ln->clone_ins_pt, sizeof (dimension_ang2ln->clone_ins_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_ang2ln->def_pt, sizeof (dimension_ang2ln->def_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_ang2ln->dimstyle, sizeof (dimension_ang2ln->dimstyle)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "elevation", &elevation, NULL)
        && elevation == dimension_ang2ln->elevation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.elevation [BD] %g != %g", dimension_ang2ln->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "elevation", &elevation, 0)
        && elevation == dimension_ang2ln->elevation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.elevation [BD] set+1 %g != %g", dimension_ang2ln->elevation, elevation);
    dimension_ang2ln->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_ang2ln->extrusion, sizeof (dimension_ang2ln->extrusion)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.extrusion [BE]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &dimension_ang2ln->first_arc_pt, sizeof (dimension_ang2ln->first_arc_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.first_arc_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flag", &flag, NULL)
        && flag == dimension_ang2ln->flag)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flag [RC] %u != %u", dimension_ang2ln->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flag", &flag, 0)
        && flag == dimension_ang2ln->flag)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flag [RC] set+1 %u != %u", dimension_ang2ln->flag, flag);
    dimension_ang2ln->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flag1", &flag1, NULL)
        && flag1 == dimension_ang2ln->flag1)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flag1 [RC] %u != %u", dimension_ang2ln->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flag1", &flag1, 0)
        && flag1 == dimension_ang2ln->flag1)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flag1 [RC] set+1 %u != %u", dimension_ang2ln->flag1, flag1);
    dimension_ang2ln->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_ang2ln->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_ang2ln->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->flip_arrow1, flip_arrow1);
    dimension_ang2ln->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_ang2ln->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_ang2ln->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->flip_arrow2, flip_arrow2);
    dimension_ang2ln->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_ang2ln->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.horiz_dir [BD] %g != %g", dimension_ang2ln->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_ang2ln->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.horiz_dir [BD] set+1 %g != %g", dimension_ang2ln->horiz_dir, horiz_dir);
    dimension_ang2ln->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_ang2ln->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.ins_rotation [BD] %g != %g", dimension_ang2ln->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_ang2ln->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.ins_rotation [BD] set+1 %g != %g", dimension_ang2ln->ins_rotation, ins_rotation);
    dimension_ang2ln->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_ang2ln->ins_scale, sizeof (dimension_ang2ln->ins_scale)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.ins_scale [3BD]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_ang2ln->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.lspace_factor [BD] %g != %g", dimension_ang2ln->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_ang2ln->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.lspace_factor [BD] set+1 %g != %g", dimension_ang2ln->lspace_factor, lspace_factor);
    dimension_ang2ln->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_ang2ln->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.lspace_style [BS] %hu != %hu", dimension_ang2ln->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_ang2ln->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.lspace_style [BS] set+1 %hu != %hu", dimension_ang2ln->lspace_style, lspace_style);
    dimension_ang2ln->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_ang2ln->parent, sizeof (dimension_ang2ln->parent)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_ang2ln->text_midpt, sizeof (dimension_ang2ln->text_midpt)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_ang2ln->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.text_rotation [BD] %g != %g", dimension_ang2ln->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_ang2ln->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.text_rotation [BD] set+1 %g != %g", dimension_ang2ln->text_rotation, text_rotation);
    dimension_ang2ln->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "unknown", &unknown, NULL)
        && unknown == dimension_ang2ln->unknown)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "unknown", &unknown, 0)
        && unknown == dimension_ang2ln->unknown)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->unknown, unknown);
    dimension_ang2ln->unknown--;
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_ang2ln->user_text)
           : !dimension_ang2ln->user_text)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.user_text [TV] '%s' <> '%s'", user_text, dimension_ang2ln->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_ANG2LN") || is_class_debugging ("DIMENSION_ANG2LN")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_ANG2LN", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_ANG3PT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_ANG3PT *restrict dimension_ang3pt = obj->tio.entity->tio.DIMENSION_ANG3PT;
  failed = 0;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "_13_pt", &_13_pt, NULL)
        && !memcmp (&_13_pt, &dimension_ang3pt->_13_pt, sizeof (dimension_ang3pt->_13_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT._13_pt [3BD]");
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "_14_pt", &_14_pt, NULL)
        && !memcmp (&_14_pt, &dimension_ang3pt->_14_pt, sizeof (dimension_ang3pt->_14_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT._14_pt [3BD]");
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_ang3pt->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.act_measurement [BD] %g != %g", dimension_ang3pt->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_ang3pt->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.act_measurement [BD] set+1 %g != %g", dimension_ang3pt->act_measurement, act_measurement);
    dimension_ang3pt->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "attachment", &attachment, NULL)
        && attachment == dimension_ang3pt->attachment)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.attachment [BS] %hu != %hu", dimension_ang3pt->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "attachment", &attachment, 0)
        && attachment == dimension_ang3pt->attachment)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.attachment [BS] set+1 %hu != %hu", dimension_ang3pt->attachment, attachment);
    dimension_ang3pt->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "block", &block, NULL)
        && !memcmp (&block, &dimension_ang3pt->block, sizeof (dimension_ang3pt->block)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.block [H]");
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "blockname", &blockname, NULL)
        && blockname
           ? strEQ ((char *)blockname, (char *)dimension_ang3pt->blockname)
           : !dimension_ang3pt->blockname)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.blockname [TV] '%s' <> '%s'", blockname, dimension_ang3pt->blockname);
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "class_version", &class_version, NULL)
        && class_version == dimension_ang3pt->class_version)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.class_version [RC] %u != %u", dimension_ang3pt->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "class_version", &class_version, 0)
        && class_version == dimension_ang3pt->class_version)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.class_version [RC] set+1 %u != %u", dimension_ang3pt->class_version, class_version);
    dimension_ang3pt->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_ang3pt->clone_ins_pt, sizeof (dimension_ang3pt->clone_ins_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_ang3pt->def_pt, sizeof (dimension_ang3pt->def_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_ang3pt->dimstyle, sizeof (dimension_ang3pt->dimstyle)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "elevation", &elevation, NULL)
        && elevation == dimension_ang3pt->elevation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.elevation [BD] %g != %g", dimension_ang3pt->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "elevation", &elevation, 0)
        && elevation == dimension_ang3pt->elevation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.elevation [BD] set+1 %g != %g", dimension_ang3pt->elevation, elevation);
    dimension_ang3pt->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_ang3pt->extrusion, sizeof (dimension_ang3pt->extrusion)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.extrusion [BE]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &dimension_ang3pt->first_arc_pt, sizeof (dimension_ang3pt->first_arc_pt)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.first_arc_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flag", &flag, NULL)
        && flag == dimension_ang3pt->flag)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flag [RC] %u != %u", dimension_ang3pt->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flag", &flag, 0)
        && flag == dimension_ang3pt->flag)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flag [RC] set+1 %u != %u", dimension_ang3pt->flag, flag);
    dimension_ang3pt->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flag1", &flag1, NULL)
        && flag1 == dimension_ang3pt->flag1)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flag1 [RC] %u != %u", dimension_ang3pt->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flag1", &flag1, 0)
        && flag1 == dimension_ang3pt->flag1)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flag1 [RC] set+1 %u != %u", dimension_ang3pt->flag1, flag1);
    dimension_ang3pt->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_ang3pt->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_ang3pt->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->flip_arrow1, flip_arrow1);
    dimension_ang3pt->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_ang3pt->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_ang3pt->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->flip_arrow2, flip_arrow2);
    dimension_ang3pt->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_ang3pt->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.horiz_dir [BD] %g != %g", dimension_ang3pt->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_ang3pt->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.horiz_dir [BD] set+1 %g != %g", dimension_ang3pt->horiz_dir, horiz_dir);
    dimension_ang3pt->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_ang3pt->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.ins_rotation [BD] %g != %g", dimension_ang3pt->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_ang3pt->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.ins_rotation [BD] set+1 %g != %g", dimension_ang3pt->ins_rotation, ins_rotation);
    dimension_ang3pt->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_ang3pt->ins_scale, sizeof (dimension_ang3pt->ins_scale)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.ins_scale [3BD]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_ang3pt->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.lspace_factor [BD] %g != %g", dimension_ang3pt->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_ang3pt->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.lspace_factor [BD] set+1 %g != %g", dimension_ang3pt->lspace_factor, lspace_factor);
    dimension_ang3pt->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_ang3pt->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.lspace_style [BS] %hu != %hu", dimension_ang3pt->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_ang3pt->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.lspace_style [BS] set+1 %hu != %hu", dimension_ang3pt->lspace_style, lspace_style);
    dimension_ang3pt->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_ang3pt->parent, sizeof (dimension_ang3pt->parent)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_ang3pt->text_midpt, sizeof (dimension_ang3pt->text_midpt)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_ang3pt->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.text_rotation [BD] %g != %g", dimension_ang3pt->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_ang3pt->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.text_rotation [BD] set+1 %g != %g", dimension_ang3pt->text_rotation, text_rotation);
    dimension_ang3pt->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "unknown", &unknown, NULL)
        && unknown == dimension_ang3pt->unknown)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "unknown", &unknown, 0)
        && unknown == dimension_ang3pt->unknown)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->unknown, unknown);
    dimension_ang3pt->unknown--;
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_ang3pt->user_text)
           : !dimension_ang3pt->user_text)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.user_text [TV] '%s' <> '%s'", user_text, dimension_ang3pt->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_ANG3PT") || is_class_debugging ("DIMENSION_ANG3PT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_ANG3PT", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_DIAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_DIAMETER *restrict dimension_diameter = obj->tio.entity->tio.DIMENSION_DIAMETER;
  failed = 0;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_diameter->act_measurement)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.act_measurement [BD] %g != %g", dimension_diameter->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_diameter->act_measurement)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.act_measurement [BD] set+1 %g != %g", dimension_diameter->act_measurement, act_measurement);
    dimension_diameter->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "attachment", &attachment, NULL)
        && attachment == dimension_diameter->attachment)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.attachment [BS] %hu != %hu", dimension_diameter->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "attachment", &attachment, 0)
        && attachment == dimension_diameter->attachment)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.attachment [BS] set+1 %hu != %hu", dimension_diameter->attachment, attachment);
    dimension_diameter->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "block", &block, NULL)
        && !memcmp (&block, &dimension_diameter->block, sizeof (dimension_diameter->block)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.block [H]");
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "blockname", &blockname, NULL)
        && blockname
           ? strEQ ((char *)blockname, (char *)dimension_diameter->blockname)
           : !dimension_diameter->blockname)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.blockname [TV] '%s' <> '%s'", blockname, dimension_diameter->blockname);
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "class_version", &class_version, NULL)
        && class_version == dimension_diameter->class_version)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.class_version [RC] %u != %u", dimension_diameter->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "class_version", &class_version, 0)
        && class_version == dimension_diameter->class_version)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.class_version [RC] set+1 %u != %u", dimension_diameter->class_version, class_version);
    dimension_diameter->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_diameter->clone_ins_pt, sizeof (dimension_diameter->clone_ins_pt)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_diameter->def_pt, sizeof (dimension_diameter->def_pt)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_diameter->dimstyle, sizeof (dimension_diameter->dimstyle)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "elevation", &elevation, NULL)
        && elevation == dimension_diameter->elevation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.elevation [BD] %g != %g", dimension_diameter->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "elevation", &elevation, 0)
        && elevation == dimension_diameter->elevation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.elevation [BD] set+1 %g != %g", dimension_diameter->elevation, elevation);
    dimension_diameter->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_diameter->extrusion, sizeof (dimension_diameter->extrusion)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.extrusion [BE]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &dimension_diameter->first_arc_pt, sizeof (dimension_diameter->first_arc_pt)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.first_arc_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "flag", &flag, NULL)
        && flag == dimension_diameter->flag)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flag [RC] %u != %u", dimension_diameter->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "flag", &flag, 0)
        && flag == dimension_diameter->flag)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flag [RC] set+1 %u != %u", dimension_diameter->flag, flag);
    dimension_diameter->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "flag1", &flag1, NULL)
        && flag1 == dimension_diameter->flag1)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flag1 [RC] %u != %u", dimension_diameter->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "flag1", &flag1, 0)
        && flag1 == dimension_diameter->flag1)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flag1 [RC] set+1 %u != %u", dimension_diameter->flag1, flag1);
    dimension_diameter->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_diameter->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_diameter->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_diameter->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_diameter->flip_arrow1, flip_arrow1);
    dimension_diameter->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_diameter->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_diameter->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_diameter->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_diameter->flip_arrow2, flip_arrow2);
    dimension_diameter->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_diameter->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.horiz_dir [BD] %g != %g", dimension_diameter->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_diameter->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.horiz_dir [BD] set+1 %g != %g", dimension_diameter->horiz_dir, horiz_dir);
    dimension_diameter->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_diameter->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.ins_rotation [BD] %g != %g", dimension_diameter->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_diameter->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.ins_rotation [BD] set+1 %g != %g", dimension_diameter->ins_rotation, ins_rotation);
    dimension_diameter->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_diameter->ins_scale, sizeof (dimension_diameter->ins_scale)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.ins_scale [3BD]");
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "leader_len", &leader_len, NULL)
        && leader_len == dimension_diameter->leader_len)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.leader_len [BD] %g != %g", dimension_diameter->leader_len, leader_len);
    leader_len++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "leader_len", &leader_len, 0)
        && leader_len == dimension_diameter->leader_len)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.leader_len [BD] set+1 %g != %g", dimension_diameter->leader_len, leader_len);
    dimension_diameter->leader_len--;
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_diameter->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.lspace_factor [BD] %g != %g", dimension_diameter->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_diameter->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.lspace_factor [BD] set+1 %g != %g", dimension_diameter->lspace_factor, lspace_factor);
    dimension_diameter->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_diameter->lspace_style)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.lspace_style [BS] %hu != %hu", dimension_diameter->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_diameter->lspace_style)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.lspace_style [BS] set+1 %hu != %hu", dimension_diameter->lspace_style, lspace_style);
    dimension_diameter->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_diameter->parent, sizeof (dimension_diameter->parent)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_diameter->text_midpt, sizeof (dimension_diameter->text_midpt)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_diameter->text_rotation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.text_rotation [BD] %g != %g", dimension_diameter->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_diameter->text_rotation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.text_rotation [BD] set+1 %g != %g", dimension_diameter->text_rotation, text_rotation);
    dimension_diameter->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "unknown", &unknown, NULL)
        && unknown == dimension_diameter->unknown)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_diameter->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "unknown", &unknown, 0)
        && unknown == dimension_diameter->unknown)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_diameter->unknown, unknown);
    dimension_diameter->unknown--;
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_diameter->user_text)
           : !dimension_diameter->user_text)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.user_text [TV] '%s' <> '%s'", user_text, dimension_diameter->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_DIAMETER") || is_class_debugging ("DIMENSION_DIAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_DIAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_LINEAR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_LINEAR *restrict dimension_linear = obj->tio.entity->tio.DIMENSION_LINEAR;
  failed = 0;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "_13_pt", &_13_pt, NULL)
        && !memcmp (&_13_pt, &dimension_linear->_13_pt, sizeof (dimension_linear->_13_pt)))
        pass ();
    else
        fail ("DIMENSION_LINEAR._13_pt [3BD]");
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "_14_pt", &_14_pt, NULL)
        && !memcmp (&_14_pt, &dimension_linear->_14_pt, sizeof (dimension_linear->_14_pt)))
        pass ();
    else
        fail ("DIMENSION_LINEAR._14_pt [3BD]");
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_linear->act_measurement)
      pass ();
    else
      fail ("DIMENSION_LINEAR.act_measurement [BD] %g != %g", dimension_linear->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_linear->act_measurement)
      pass ();
    else
      fail ("DIMENSION_LINEAR.act_measurement [BD] set+1 %g != %g", dimension_linear->act_measurement, act_measurement);
    dimension_linear->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "attachment", &attachment, NULL)
        && attachment == dimension_linear->attachment)
      pass ();
    else
      fail ("DIMENSION_LINEAR.attachment [BS] %hu != %hu", dimension_linear->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "attachment", &attachment, 0)
        && attachment == dimension_linear->attachment)
      pass ();
    else
      fail ("DIMENSION_LINEAR.attachment [BS] set+1 %hu != %hu", dimension_linear->attachment, attachment);
    dimension_linear->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "block", &block, NULL)
        && !memcmp (&block, &dimension_linear->block, sizeof (dimension_linear->block)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.block [H]");
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "blockname", &blockname, NULL)
        && blockname
           ? strEQ ((char *)blockname, (char *)dimension_linear->blockname)
           : !dimension_linear->blockname)
      pass ();
    else
      fail ("DIMENSION_LINEAR.blockname [TV] '%s' <> '%s'", blockname, dimension_linear->blockname);
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "class_version", &class_version, NULL)
        && class_version == dimension_linear->class_version)
      pass ();
    else
      fail ("DIMENSION_LINEAR.class_version [RC] %u != %u", dimension_linear->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "class_version", &class_version, 0)
        && class_version == dimension_linear->class_version)
      pass ();
    else
      fail ("DIMENSION_LINEAR.class_version [RC] set+1 %u != %u", dimension_linear->class_version, class_version);
    dimension_linear->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_linear->clone_ins_pt, sizeof (dimension_linear->clone_ins_pt)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_linear->def_pt, sizeof (dimension_linear->def_pt)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.def_pt [3BD]");
  }
  {
    BITCODE_BD dim_rotation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "dim_rotation", &dim_rotation, NULL)
        && dim_rotation == dimension_linear->dim_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.dim_rotation [BD] %g != %g", dimension_linear->dim_rotation, dim_rotation);
    dim_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "dim_rotation", &dim_rotation, 0)
        && dim_rotation == dimension_linear->dim_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.dim_rotation [BD] set+1 %g != %g", dimension_linear->dim_rotation, dim_rotation);
    dimension_linear->dim_rotation--;
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_linear->dimstyle, sizeof (dimension_linear->dimstyle)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "elevation", &elevation, NULL)
        && elevation == dimension_linear->elevation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.elevation [BD] %g != %g", dimension_linear->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "elevation", &elevation, 0)
        && elevation == dimension_linear->elevation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.elevation [BD] set+1 %g != %g", dimension_linear->elevation, elevation);
    dimension_linear->elevation--;
  }
  {
    BITCODE_BD ext_line_rotation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "ext_line_rotation", &ext_line_rotation, NULL)
        && ext_line_rotation == dimension_linear->ext_line_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.ext_line_rotation [BD] %g != %g", dimension_linear->ext_line_rotation, ext_line_rotation);
    ext_line_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "ext_line_rotation", &ext_line_rotation, 0)
        && ext_line_rotation == dimension_linear->ext_line_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.ext_line_rotation [BD] set+1 %g != %g", dimension_linear->ext_line_rotation, ext_line_rotation);
    dimension_linear->ext_line_rotation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_linear->extrusion, sizeof (dimension_linear->extrusion)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.extrusion [BE]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "flag", &flag, NULL)
        && flag == dimension_linear->flag)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flag [RC] %u != %u", dimension_linear->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "flag", &flag, 0)
        && flag == dimension_linear->flag)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flag [RC] set+1 %u != %u", dimension_linear->flag, flag);
    dimension_linear->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "flag1", &flag1, NULL)
        && flag1 == dimension_linear->flag1)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flag1 [RC] %u != %u", dimension_linear->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "flag1", &flag1, 0)
        && flag1 == dimension_linear->flag1)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flag1 [RC] set+1 %u != %u", dimension_linear->flag1, flag1);
    dimension_linear->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_linear->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_linear->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_linear->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_linear->flip_arrow1, flip_arrow1);
    dimension_linear->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_linear->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_linear->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_linear->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_linear->flip_arrow2, flip_arrow2);
    dimension_linear->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_linear->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_LINEAR.horiz_dir [BD] %g != %g", dimension_linear->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_linear->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_LINEAR.horiz_dir [BD] set+1 %g != %g", dimension_linear->horiz_dir, horiz_dir);
    dimension_linear->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_linear->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.ins_rotation [BD] %g != %g", dimension_linear->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_linear->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.ins_rotation [BD] set+1 %g != %g", dimension_linear->ins_rotation, ins_rotation);
    dimension_linear->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_linear->ins_scale, sizeof (dimension_linear->ins_scale)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.ins_scale [3BD]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_linear->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_LINEAR.lspace_factor [BD] %g != %g", dimension_linear->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_linear->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_LINEAR.lspace_factor [BD] set+1 %g != %g", dimension_linear->lspace_factor, lspace_factor);
    dimension_linear->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_linear->lspace_style)
      pass ();
    else
      fail ("DIMENSION_LINEAR.lspace_style [BS] %hu != %hu", dimension_linear->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_linear->lspace_style)
      pass ();
    else
      fail ("DIMENSION_LINEAR.lspace_style [BS] set+1 %hu != %hu", dimension_linear->lspace_style, lspace_style);
    dimension_linear->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_linear->parent, sizeof (dimension_linear->parent)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_linear->text_midpt, sizeof (dimension_linear->text_midpt)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_linear->text_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.text_rotation [BD] %g != %g", dimension_linear->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_linear->text_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.text_rotation [BD] set+1 %g != %g", dimension_linear->text_rotation, text_rotation);
    dimension_linear->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "unknown", &unknown, NULL)
        && unknown == dimension_linear->unknown)
      pass ();
    else
      fail ("DIMENSION_LINEAR.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_linear->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "unknown", &unknown, 0)
        && unknown == dimension_linear->unknown)
      pass ();
    else
      fail ("DIMENSION_LINEAR.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_linear->unknown, unknown);
    dimension_linear->unknown--;
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_linear->user_text)
           : !dimension_linear->user_text)
      pass ();
    else
      fail ("DIMENSION_LINEAR.user_text [TV] '%s' <> '%s'", user_text, dimension_linear->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_LINEAR") || is_class_debugging ("DIMENSION_LINEAR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_LINEAR", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_ORDINATE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_ORDINATE *restrict dimension_ordinate = obj->tio.entity->tio.DIMENSION_ORDINATE;
  failed = 0;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_ordinate->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.act_measurement [BD] %g != %g", dimension_ordinate->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_ordinate->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.act_measurement [BD] set+1 %g != %g", dimension_ordinate->act_measurement, act_measurement);
    dimension_ordinate->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "attachment", &attachment, NULL)
        && attachment == dimension_ordinate->attachment)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.attachment [BS] %hu != %hu", dimension_ordinate->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "attachment", &attachment, 0)
        && attachment == dimension_ordinate->attachment)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.attachment [BS] set+1 %hu != %hu", dimension_ordinate->attachment, attachment);
    dimension_ordinate->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "block", &block, NULL)
        && !memcmp (&block, &dimension_ordinate->block, sizeof (dimension_ordinate->block)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.block [H]");
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "blockname", &blockname, NULL)
        && blockname
           ? strEQ ((char *)blockname, (char *)dimension_ordinate->blockname)
           : !dimension_ordinate->blockname)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.blockname [TV] '%s' <> '%s'", blockname, dimension_ordinate->blockname);
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "class_version", &class_version, NULL)
        && class_version == dimension_ordinate->class_version)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.class_version [RC] %u != %u", dimension_ordinate->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "class_version", &class_version, 0)
        && class_version == dimension_ordinate->class_version)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.class_version [RC] set+1 %u != %u", dimension_ordinate->class_version, class_version);
    dimension_ordinate->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_ordinate->clone_ins_pt, sizeof (dimension_ordinate->clone_ins_pt)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_ordinate->def_pt, sizeof (dimension_ordinate->def_pt)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_ordinate->dimstyle, sizeof (dimension_ordinate->dimstyle)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "elevation", &elevation, NULL)
        && elevation == dimension_ordinate->elevation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.elevation [BD] %g != %g", dimension_ordinate->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "elevation", &elevation, 0)
        && elevation == dimension_ordinate->elevation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.elevation [BD] set+1 %g != %g", dimension_ordinate->elevation, elevation);
    dimension_ordinate->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_ordinate->extrusion, sizeof (dimension_ordinate->extrusion)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.extrusion [BE]");
  }
  {
    BITCODE_3BD feature_location_pt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "feature_location_pt", &feature_location_pt, NULL)
        && !memcmp (&feature_location_pt, &dimension_ordinate->feature_location_pt, sizeof (dimension_ordinate->feature_location_pt)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.feature_location_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag", &flag, NULL)
        && flag == dimension_ordinate->flag)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag [RC] %u != %u", dimension_ordinate->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag", &flag, 0)
        && flag == dimension_ordinate->flag)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag [RC] set+1 %u != %u", dimension_ordinate->flag, flag);
    dimension_ordinate->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag1", &flag1, NULL)
        && flag1 == dimension_ordinate->flag1)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag1 [RC] %u != %u", dimension_ordinate->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag1", &flag1, 0)
        && flag1 == dimension_ordinate->flag1)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag1 [RC] set+1 %u != %u", dimension_ordinate->flag1, flag1);
    dimension_ordinate->flag1--;
  }
  {
    BITCODE_RC flag2;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag2", &flag2, NULL)
        && flag2 == dimension_ordinate->flag2)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag2 [RC] %u != %u", dimension_ordinate->flag2, flag2);
    flag2++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag2", &flag2, 0)
        && flag2 == dimension_ordinate->flag2)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag2 [RC] set+1 %u != %u", dimension_ordinate->flag2, flag2);
    dimension_ordinate->flag2--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_ordinate->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_ordinate->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_ordinate->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ordinate->flip_arrow1, flip_arrow1);
    dimension_ordinate->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_ordinate->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_ordinate->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_ordinate->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ordinate->flip_arrow2, flip_arrow2);
    dimension_ordinate->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_ordinate->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.horiz_dir [BD] %g != %g", dimension_ordinate->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_ordinate->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.horiz_dir [BD] set+1 %g != %g", dimension_ordinate->horiz_dir, horiz_dir);
    dimension_ordinate->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_ordinate->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.ins_rotation [BD] %g != %g", dimension_ordinate->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_ordinate->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.ins_rotation [BD] set+1 %g != %g", dimension_ordinate->ins_rotation, ins_rotation);
    dimension_ordinate->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_ordinate->ins_scale, sizeof (dimension_ordinate->ins_scale)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.ins_scale [3BD]");
  }
  {
    BITCODE_3BD leader_endpt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "leader_endpt", &leader_endpt, NULL)
        && !memcmp (&leader_endpt, &dimension_ordinate->leader_endpt, sizeof (dimension_ordinate->leader_endpt)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.leader_endpt [3BD]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_ordinate->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.lspace_factor [BD] %g != %g", dimension_ordinate->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_ordinate->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.lspace_factor [BD] set+1 %g != %g", dimension_ordinate->lspace_factor, lspace_factor);
    dimension_ordinate->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_ordinate->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.lspace_style [BS] %hu != %hu", dimension_ordinate->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_ordinate->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.lspace_style [BS] set+1 %hu != %hu", dimension_ordinate->lspace_style, lspace_style);
    dimension_ordinate->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_ordinate->parent, sizeof (dimension_ordinate->parent)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_ordinate->text_midpt, sizeof (dimension_ordinate->text_midpt)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_ordinate->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.text_rotation [BD] %g != %g", dimension_ordinate->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_ordinate->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.text_rotation [BD] set+1 %g != %g", dimension_ordinate->text_rotation, text_rotation);
    dimension_ordinate->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "unknown", &unknown, NULL)
        && unknown == dimension_ordinate->unknown)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_ordinate->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "unknown", &unknown, 0)
        && unknown == dimension_ordinate->unknown)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ordinate->unknown, unknown);
    dimension_ordinate->unknown--;
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_ordinate->user_text)
           : !dimension_ordinate->user_text)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.user_text [TV] '%s' <> '%s'", user_text, dimension_ordinate->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_ORDINATE") || is_class_debugging ("DIMENSION_ORDINATE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_ORDINATE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_RADIUS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_RADIUS *restrict dimension_radius = obj->tio.entity->tio.DIMENSION_RADIUS;
  failed = 0;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_radius->act_measurement)
      pass ();
    else
      fail ("DIMENSION_RADIUS.act_measurement [BD] %g != %g", dimension_radius->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_radius->act_measurement)
      pass ();
    else
      fail ("DIMENSION_RADIUS.act_measurement [BD] set+1 %g != %g", dimension_radius->act_measurement, act_measurement);
    dimension_radius->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "attachment", &attachment, NULL)
        && attachment == dimension_radius->attachment)
      pass ();
    else
      fail ("DIMENSION_RADIUS.attachment [BS] %hu != %hu", dimension_radius->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "attachment", &attachment, 0)
        && attachment == dimension_radius->attachment)
      pass ();
    else
      fail ("DIMENSION_RADIUS.attachment [BS] set+1 %hu != %hu", dimension_radius->attachment, attachment);
    dimension_radius->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "block", &block, NULL)
        && !memcmp (&block, &dimension_radius->block, sizeof (dimension_radius->block)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.block [H]");
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "blockname", &blockname, NULL)
        && blockname
           ? strEQ ((char *)blockname, (char *)dimension_radius->blockname)
           : !dimension_radius->blockname)
      pass ();
    else
      fail ("DIMENSION_RADIUS.blockname [TV] '%s' <> '%s'", blockname, dimension_radius->blockname);
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "class_version", &class_version, NULL)
        && class_version == dimension_radius->class_version)
      pass ();
    else
      fail ("DIMENSION_RADIUS.class_version [RC] %u != %u", dimension_radius->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "class_version", &class_version, 0)
        && class_version == dimension_radius->class_version)
      pass ();
    else
      fail ("DIMENSION_RADIUS.class_version [RC] set+1 %u != %u", dimension_radius->class_version, class_version);
    dimension_radius->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_radius->clone_ins_pt, sizeof (dimension_radius->clone_ins_pt)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_radius->def_pt, sizeof (dimension_radius->def_pt)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_radius->dimstyle, sizeof (dimension_radius->dimstyle)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "elevation", &elevation, NULL)
        && elevation == dimension_radius->elevation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.elevation [BD] %g != %g", dimension_radius->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "elevation", &elevation, 0)
        && elevation == dimension_radius->elevation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.elevation [BD] set+1 %g != %g", dimension_radius->elevation, elevation);
    dimension_radius->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_radius->extrusion, sizeof (dimension_radius->extrusion)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.extrusion [BE]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &dimension_radius->first_arc_pt, sizeof (dimension_radius->first_arc_pt)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.first_arc_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "flag", &flag, NULL)
        && flag == dimension_radius->flag)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flag [RC] %u != %u", dimension_radius->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "flag", &flag, 0)
        && flag == dimension_radius->flag)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flag [RC] set+1 %u != %u", dimension_radius->flag, flag);
    dimension_radius->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "flag1", &flag1, NULL)
        && flag1 == dimension_radius->flag1)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flag1 [RC] %u != %u", dimension_radius->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "flag1", &flag1, 0)
        && flag1 == dimension_radius->flag1)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flag1 [RC] set+1 %u != %u", dimension_radius->flag1, flag1);
    dimension_radius->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_radius->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_radius->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_radius->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_radius->flip_arrow1, flip_arrow1);
    dimension_radius->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_radius->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_radius->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_radius->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_radius->flip_arrow2, flip_arrow2);
    dimension_radius->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_radius->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_RADIUS.horiz_dir [BD] %g != %g", dimension_radius->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_radius->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_RADIUS.horiz_dir [BD] set+1 %g != %g", dimension_radius->horiz_dir, horiz_dir);
    dimension_radius->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_radius->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.ins_rotation [BD] %g != %g", dimension_radius->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_radius->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.ins_rotation [BD] set+1 %g != %g", dimension_radius->ins_rotation, ins_rotation);
    dimension_radius->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_radius->ins_scale, sizeof (dimension_radius->ins_scale)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.ins_scale [3BD]");
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "leader_len", &leader_len, NULL)
        && leader_len == dimension_radius->leader_len)
      pass ();
    else
      fail ("DIMENSION_RADIUS.leader_len [BD] %g != %g", dimension_radius->leader_len, leader_len);
    leader_len++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "leader_len", &leader_len, 0)
        && leader_len == dimension_radius->leader_len)
      pass ();
    else
      fail ("DIMENSION_RADIUS.leader_len [BD] set+1 %g != %g", dimension_radius->leader_len, leader_len);
    dimension_radius->leader_len--;
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_radius->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_RADIUS.lspace_factor [BD] %g != %g", dimension_radius->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_radius->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_RADIUS.lspace_factor [BD] set+1 %g != %g", dimension_radius->lspace_factor, lspace_factor);
    dimension_radius->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_radius->lspace_style)
      pass ();
    else
      fail ("DIMENSION_RADIUS.lspace_style [BS] %hu != %hu", dimension_radius->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_radius->lspace_style)
      pass ();
    else
      fail ("DIMENSION_RADIUS.lspace_style [BS] set+1 %hu != %hu", dimension_radius->lspace_style, lspace_style);
    dimension_radius->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_radius->parent, sizeof (dimension_radius->parent)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_radius->text_midpt, sizeof (dimension_radius->text_midpt)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_radius->text_rotation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.text_rotation [BD] %g != %g", dimension_radius->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_radius->text_rotation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.text_rotation [BD] set+1 %g != %g", dimension_radius->text_rotation, text_rotation);
    dimension_radius->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "unknown", &unknown, NULL)
        && unknown == dimension_radius->unknown)
      pass ();
    else
      fail ("DIMENSION_RADIUS.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_radius->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "unknown", &unknown, 0)
        && unknown == dimension_radius->unknown)
      pass ();
    else
      fail ("DIMENSION_RADIUS.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_radius->unknown, unknown);
    dimension_radius->unknown--;
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_radius->user_text)
           : !dimension_radius->user_text)
      pass ();
    else
      fail ("DIMENSION_RADIUS.user_text [TV] '%s' <> '%s'", user_text, dimension_radius->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_RADIUS") || is_class_debugging ("DIMENSION_RADIUS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_RADIUS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ELLIPSE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ELLIPSE *restrict ellipse = obj->tio.entity->tio.ELLIPSE;
  failed = 0;
  {
    BITCODE_BD axis_ratio;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "axis_ratio", &axis_ratio, NULL)
        && axis_ratio == ellipse->axis_ratio)
      pass ();
    else
      fail ("ELLIPSE.axis_ratio [BD] %g != %g", ellipse->axis_ratio, axis_ratio);
    axis_ratio++;
    if (dwg_dynapi_entity_set_value (ellipse, "ELLIPSE", "axis_ratio", &axis_ratio, 0)
        && axis_ratio == ellipse->axis_ratio)
      pass ();
    else
      fail ("ELLIPSE.axis_ratio [BD] set+1 %g != %g", ellipse->axis_ratio, axis_ratio);
    ellipse->axis_ratio--;
  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "center", &center, NULL)
        && !memcmp (&center, &ellipse->center, sizeof (ellipse->center)))
        pass ();
    else
        fail ("ELLIPSE.center [3BD]");
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "end_angle", &end_angle, NULL)
        && end_angle == ellipse->end_angle)
      pass ();
    else
      fail ("ELLIPSE.end_angle [BD] %g != %g", ellipse->end_angle, end_angle);
    end_angle++;
    if (dwg_dynapi_entity_set_value (ellipse, "ELLIPSE", "end_angle", &end_angle, 0)
        && end_angle == ellipse->end_angle)
      pass ();
    else
      fail ("ELLIPSE.end_angle [BD] set+1 %g != %g", ellipse->end_angle, end_angle);
    ellipse->end_angle--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &ellipse->extrusion, sizeof (ellipse->extrusion)))
        pass ();
    else
        fail ("ELLIPSE.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "parent", &parent, NULL)
        && !memcmp (&parent, &ellipse->parent, sizeof (ellipse->parent)))
        pass ();
    else
        fail ("ELLIPSE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD sm_axis;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "sm_axis", &sm_axis, NULL)
        && !memcmp (&sm_axis, &ellipse->sm_axis, sizeof (ellipse->sm_axis)))
        pass ();
    else
        fail ("ELLIPSE.sm_axis [3BD]");
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "start_angle", &start_angle, NULL)
        && start_angle == ellipse->start_angle)
      pass ();
    else
      fail ("ELLIPSE.start_angle [BD] %g != %g", ellipse->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (ellipse, "ELLIPSE", "start_angle", &start_angle, 0)
        && start_angle == ellipse->start_angle)
      pass ();
    else
      fail ("ELLIPSE.start_angle [BD] set+1 %g != %g", ellipse->start_angle, start_angle);
    ellipse->start_angle--;
  }
  if (failed && (is_class_unstable ("ELLIPSE") || is_class_debugging ("ELLIPSE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ELLIPSE", failed);
      failed = 0;
    }
  return failed;
}
static int test_ENDBLK (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ENDBLK *restrict endblk = obj->tio.entity->tio.ENDBLK;
  failed = 0;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (endblk, "ENDBLK", "parent", &parent, NULL)
        && !memcmp (&parent, &endblk->parent, sizeof (endblk->parent)))
        pass ();
    else
        fail ("ENDBLK.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("ENDBLK") || is_class_debugging ("ENDBLK")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ENDBLK", failed);
      failed = 0;
    }
  return failed;
}
static int test_EXTRUDEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_EXTRUDEDSURFACE *restrict extrudedsurface = obj->tio.entity->tio.EXTRUDEDSURFACE;
  failed = 0;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)extrudedsurface->acis_data)
           : !extrudedsurface->acis_data)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, extrudedsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == extrudedsurface->acis_empty)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == extrudedsurface->acis_empty)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty, acis_empty);
    extrudedsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == extrudedsurface->acis_empty2)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == extrudedsurface->acis_empty2)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty2, acis_empty2);
    extrudedsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == extrudedsurface->acis_empty_bit)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == extrudedsurface->acis_empty_bit)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty_bit, acis_empty_bit);
    extrudedsurface->acis_empty_bit--;
  }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle, NULL)
        && align_angle == extrudedsurface->align_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.align_angle [BD] %g != %g", extrudedsurface->align_angle, align_angle);
    align_angle++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle, 0)
        && align_angle == extrudedsurface->align_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.align_angle [BD] set+1 %g != %g", extrudedsurface->align_angle, align_angle);
    extrudedsurface->align_angle--;
  }
  {
    BITCODE_B align_start;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start, NULL)
        && align_start == extrudedsurface->align_start)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start);
    align_start++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start, 0)
        && align_start == extrudedsurface->align_start)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start);
    extrudedsurface->align_start--;
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank, NULL)
        && bank == extrudedsurface->bank)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank);
    bank++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank, 0)
        && bank == extrudedsurface->bank)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank);
    extrudedsurface->bank--;
  }
  {
    BITCODE_B base_point_set;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set, NULL)
        && base_point_set == extrudedsurface->base_point_set)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set);
    base_point_set++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set, 0)
        && base_point_set == extrudedsurface->base_point_set)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.base_point_set [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set);
    extrudedsurface->base_point_set--;
  }
  {
    BITCODE_TF bindata;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata", &bindata, NULL)
        && !memcmp (&bindata, &extrudedsurface->bindata, sizeof (extrudedsurface->bindata)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.bindata [TF]");
  }
  {
    BITCODE_BL bindata_size;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata_size", &bindata_size, NULL)
        && bindata_size == extrudedsurface->bindata_size)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.bindata_size [BL] %u != %u", extrudedsurface->bindata_size, bindata_size);
    bindata_size++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata_size", &bindata_size, 0)
        && bindata_size == extrudedsurface->bindata_size)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.bindata_size [BL] set+1 %u != %u", extrudedsurface->bindata_size, bindata_size);
    extrudedsurface->bindata_size--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &extrudedsurface->block_size, sizeof (extrudedsurface->block_size)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version, NULL)
        && class_version == extrudedsurface->class_version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.class_version [BL] %u != %u", extrudedsurface->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version, 0)
        && class_version == extrudedsurface->class_version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.class_version [BL] set+1 %u != %u", extrudedsurface->class_version, class_version);
    extrudedsurface->class_version--;
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle, NULL)
        && draft_angle == extrudedsurface->draft_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_angle [BD] %g != %g", extrudedsurface->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle, 0)
        && draft_angle == extrudedsurface->draft_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_angle [BD] set+1 %g != %g", extrudedsurface->draft_angle, draft_angle);
    extrudedsurface->draft_angle--;
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance, NULL)
        && draft_end_distance == extrudedsurface->draft_end_distance)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_end_distance [BD] %g != %g", extrudedsurface->draft_end_distance, draft_end_distance);
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance, 0)
        && draft_end_distance == extrudedsurface->draft_end_distance)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_end_distance [BD] set+1 %g != %g", extrudedsurface->draft_end_distance, draft_end_distance);
    extrudedsurface->draft_end_distance--;
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance, NULL)
        && draft_start_distance == extrudedsurface->draft_start_distance)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_start_distance [BD] %g != %g", extrudedsurface->draft_start_distance, draft_start_distance);
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance, 0)
        && draft_start_distance == extrudedsurface->draft_start_distance)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_start_distance [BD] set+1 %g != %g", extrudedsurface->draft_start_distance, draft_start_distance);
    extrudedsurface->draft_start_distance--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &extrudedsurface->encr_sat_data, sizeof (extrudedsurface->encr_sat_data)))
      pass ();
    else
      fail ("EXTRUDEDSURFACE.encr_sat_data [char **]");
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &extrudedsurface->extra_acis_data, sizeof (extrudedsurface->extra_acis_data)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "height", &height, NULL)
        && height == extrudedsurface->height)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.height [BD] %g != %g", extrudedsurface->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "height", &height, 0)
        && height == extrudedsurface->height)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.height [BD] set+1 %g != %g", extrudedsurface->height, height);
    extrudedsurface->height--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &extrudedsurface->history_id, sizeof (extrudedsurface->history_id)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == extrudedsurface->isoline_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == extrudedsurface->isoline_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->isoline_present, isoline_present);
    extrudedsurface->isoline_present--;
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == extrudedsurface->modeler_format_version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.modeler_format_version [BS] %hu != %hu", extrudedsurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == extrudedsurface->modeler_format_version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", extrudedsurface->modeler_format_version, modeler_format_version);
    extrudedsurface->modeler_format_version--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == extrudedsurface->num_blocks)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_blocks [BL] %u != %u", extrudedsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == extrudedsurface->num_blocks)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_blocks [BL] set+1 %u != %u", extrudedsurface->num_blocks, num_blocks);
    extrudedsurface->num_blocks--;
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_isolines", &num_isolines, NULL)
        && num_isolines == extrudedsurface->num_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_isolines [BL] %u != %u", extrudedsurface->num_isolines, num_isolines);
    num_isolines++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_isolines", &num_isolines, 0)
        && num_isolines == extrudedsurface->num_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_isolines [BL] set+1 %u != %u", extrudedsurface->num_isolines, num_isolines);
    extrudedsurface->num_isolines--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == extrudedsurface->num_silhouettes)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_silhouettes [BL] %u != %u", extrudedsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == extrudedsurface->num_silhouettes)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_silhouettes [BL] set+1 %u != %u", extrudedsurface->num_silhouettes, num_silhouettes);
    extrudedsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == extrudedsurface->num_wires)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_wires [BL] %u != %u", extrudedsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires, 0)
        && num_wires == extrudedsurface->num_wires)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_wires [BL] set+1 %u != %u", extrudedsurface->num_wires, num_wires);
    extrudedsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &extrudedsurface->parent, sizeof (extrudedsurface->parent)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H path_entity;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity", &path_entity, NULL)
        && !memcmp (&path_entity, &extrudedsurface->path_entity, sizeof (extrudedsurface->path_entity)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.path_entity [H]");
  }
  {
    BITCODE_B path_entity_transform_computed;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL)
        && path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed);
    path_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, 0)
        && path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed);
    extrudedsurface->path_entity_transform_computed--;
  }
  {
    BITCODE_BD* path_entity_transmatrix;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
        && !memcmp (&path_entity_transmatrix, &extrudedsurface->path_entity_transmatrix, sizeof (extrudedsurface->path_entity_transmatrix)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.path_entity_transmatrix [BD*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "point", &point, NULL)
        && !memcmp (&point, &extrudedsurface->point, sizeof (extrudedsurface->point)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present, NULL)
        && point_present == extrudedsurface->point_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present, 0)
        && point_present == extrudedsurface->point_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->point_present, point_present);
    extrudedsurface->point_present--;
  }
  {
    BITCODE_3BD reference_vector_for_controlling_twist;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
        && !memcmp (&reference_vector_for_controlling_twist, &extrudedsurface->reference_vector_for_controlling_twist, sizeof (extrudedsurface->reference_vector_for_controlling_twist)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.reference_vector_for_controlling_twist [3BD]");
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor, NULL)
        && scale_factor == extrudedsurface->scale_factor)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.scale_factor [BD] %g != %g", extrudedsurface->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor, 0)
        && scale_factor == extrudedsurface->scale_factor)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.scale_factor [BD] set+1 %g != %g", extrudedsurface->scale_factor, scale_factor);
    extrudedsurface->scale_factor--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == extrudedsurface->silhouettes)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "solid", &solid, NULL)
        && solid == extrudedsurface->solid)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->solid, solid);
    solid++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "solid", &solid, 0)
        && solid == extrudedsurface->solid)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->solid, solid);
    extrudedsurface->solid--;
  }
  {
    BITCODE_BS sweep_alignment_flags;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, NULL)
        && sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] %hu != %hu", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags);
    sweep_alignment_flags++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, 0)
        && sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] set+1 %hu != %hu", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags);
    extrudedsurface->sweep_alignment_flags--;
  }
  {
    BITCODE_H sweep_entity;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity", &sweep_entity, NULL)
        && !memcmp (&sweep_entity, &extrudedsurface->sweep_entity, sizeof (extrudedsurface->sweep_entity)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.sweep_entity [H]");
  }
  {
    BITCODE_B sweep_entity_transform_computed;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL)
        && sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
    sweep_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, 0)
        && sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
    extrudedsurface->sweep_entity_transform_computed--;
  }
  {
    BITCODE_BD* sweep_entity_transmatrix;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
        && !memcmp (&sweep_entity_transmatrix, &extrudedsurface->sweep_entity_transmatrix, sizeof (extrudedsurface->sweep_entity_transmatrix)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.sweep_entity_transmatrix [BD*]");
  }
  {
    BITCODE_BD* sweep_transmatrix;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_transmatrix", &sweep_transmatrix, NULL)
        && !memcmp (&sweep_transmatrix, &extrudedsurface->sweep_transmatrix, sizeof (extrudedsurface->sweep_transmatrix)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.sweep_transmatrix [BD*]");
  }
  {
    BITCODE_3BD sweep_vector;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_vector", &sweep_vector, NULL)
        && !memcmp (&sweep_vector, &extrudedsurface->sweep_vector, sizeof (extrudedsurface->sweep_vector)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.sweep_vector [3BD]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle, NULL)
        && twist_angle == extrudedsurface->twist_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.twist_angle [BD] %g != %g", extrudedsurface->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle, 0)
        && twist_angle == extrudedsurface->twist_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.twist_angle [BD] set+1 %g != %g", extrudedsurface->twist_angle, twist_angle);
    extrudedsurface->twist_angle--;
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == extrudedsurface->u_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.u_isolines [BS] %hu != %hu", extrudedsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == extrudedsurface->u_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.u_isolines [BS] set+1 %hu != %hu", extrudedsurface->u_isolines, u_isolines);
    extrudedsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown, NULL)
        && unknown == extrudedsurface->unknown)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown, 0)
        && unknown == extrudedsurface->unknown)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->unknown, unknown);
    extrudedsurface->unknown--;
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "unknown_2007", &unknown_2007, NULL)
        && unknown_2007 == extrudedsurface->unknown_2007)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.unknown_2007 [BL] %u != %u", extrudedsurface->unknown_2007, unknown_2007);
    unknown_2007++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "unknown_2007", &unknown_2007, 0)
        && unknown_2007 == extrudedsurface->unknown_2007)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.unknown_2007 [BL] set+1 %u != %u", extrudedsurface->unknown_2007, unknown_2007);
    extrudedsurface->unknown_2007--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == extrudedsurface->v_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.v_isolines [BS] %hu != %hu", extrudedsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == extrudedsurface->v_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.v_isolines [BS] set+1 %hu != %hu", extrudedsurface->v_isolines, v_isolines);
    extrudedsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "version", &version, NULL)
        && version == extrudedsurface->version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.version [BS] %hu != %hu", extrudedsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "version", &version, 0)
        && version == extrudedsurface->version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.version [BS] set+1 %hu != %hu", extrudedsurface->version, version);
    extrudedsurface->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == extrudedsurface->wireframe_data_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == extrudedsurface->wireframe_data_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->wireframe_data_present, wireframe_data_present);
    extrudedsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "wires", &wires, NULL)
        && wires == extrudedsurface->wires)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("EXTRUDEDSURFACE") || is_class_debugging ("EXTRUDEDSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "EXTRUDEDSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_GEOPOSITIONMARKER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_GEOPOSITIONMARKER *restrict geopositionmarker = obj->tio.entity->tio.GEOPOSITIONMARKER;
  failed = 0;
  {
    BITCODE_B enable_frame_text;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "enable_frame_text", &enable_frame_text, NULL)
        && enable_frame_text == geopositionmarker->enable_frame_text)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.enable_frame_text [B] " FORMAT_B " != " FORMAT_B "", geopositionmarker->enable_frame_text, enable_frame_text);
    enable_frame_text++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "enable_frame_text", &enable_frame_text, 0)
        && enable_frame_text == geopositionmarker->enable_frame_text)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.enable_frame_text [B] set+1 " FORMAT_B " != " FORMAT_B "", geopositionmarker->enable_frame_text, enable_frame_text);
    geopositionmarker->enable_frame_text--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &geopositionmarker->extrusion, sizeof (geopositionmarker->extrusion)))
        pass ();
    else
        fail ("GEOPOSITIONMARKER.extrusion [BE]");
  }
  {
    BITCODE_BD landing_gap;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "landing_gap", &landing_gap, NULL)
        && landing_gap == geopositionmarker->landing_gap)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.landing_gap [BD] %g != %g", geopositionmarker->landing_gap, landing_gap);
    landing_gap++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "landing_gap", &landing_gap, 0)
        && landing_gap == geopositionmarker->landing_gap)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.landing_gap [BD] set+1 %g != %g", geopositionmarker->landing_gap, landing_gap);
    geopositionmarker->landing_gap--;
  }
  {
    BITCODE_H mtext_handle;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "mtext_handle", &mtext_handle, NULL)
        && !memcmp (&mtext_handle, &geopositionmarker->mtext_handle, sizeof (geopositionmarker->mtext_handle)))
        pass ();
    else
        fail ("GEOPOSITIONMARKER.mtext_handle [H]");
  }
  {
    BITCODE_B mtext_visible;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "mtext_visible", &mtext_visible, NULL)
        && mtext_visible == geopositionmarker->mtext_visible)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.mtext_visible [B] " FORMAT_B " != " FORMAT_B "", geopositionmarker->mtext_visible, mtext_visible);
    mtext_visible++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "mtext_visible", &mtext_visible, 0)
        && mtext_visible == geopositionmarker->mtext_visible)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.mtext_visible [B] set+1 " FORMAT_B " != " FORMAT_B "", geopositionmarker->mtext_visible, mtext_visible);
    geopositionmarker->mtext_visible--;
  }
  {
    BITCODE_T notes;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "notes", &notes, NULL)
        && notes
           ? strEQ ((char *)notes, (char *)geopositionmarker->notes)
           : !geopositionmarker->notes)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.notes [T] '%s' <> '%s'", notes, geopositionmarker->notes);
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "parent", &parent, NULL)
        && !memcmp (&parent, &geopositionmarker->parent, sizeof (geopositionmarker->parent)))
        pass ();
    else
        fail ("GEOPOSITIONMARKER.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD position;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "position", &position, NULL)
        && !memcmp (&position, &geopositionmarker->position, sizeof (geopositionmarker->position)))
        pass ();
    else
        fail ("GEOPOSITIONMARKER.position [3BD]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "radius", &radius, NULL)
        && radius == geopositionmarker->radius)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.radius [BD] %g != %g", geopositionmarker->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "radius", &radius, 0)
        && radius == geopositionmarker->radius)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.radius [BD] set+1 %g != %g", geopositionmarker->radius, radius);
    geopositionmarker->radius--;
  }
  {
    BITCODE_T text;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "text", &text, NULL)
        && text
           ? strEQ ((char *)text, (char *)geopositionmarker->text)
           : !geopositionmarker->text)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.text [T] '%s' <> '%s'", text, geopositionmarker->text);
  }
  {
    BITCODE_BS text_alignment;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "text_alignment", &text_alignment, NULL)
        && text_alignment == geopositionmarker->text_alignment)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.text_alignment [BS] %hu != %hu", geopositionmarker->text_alignment, text_alignment);
    text_alignment++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "text_alignment", &text_alignment, 0)
        && text_alignment == geopositionmarker->text_alignment)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.text_alignment [BS] set+1 %hu != %hu", geopositionmarker->text_alignment, text_alignment);
    geopositionmarker->text_alignment--;
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "text_style", &text_style, NULL)
        && !memcmp (&text_style, &geopositionmarker->text_style, sizeof (geopositionmarker->text_style)))
        pass ();
    else
        fail ("GEOPOSITIONMARKER.text_style [H]");
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "type", &type, NULL)
        && type == geopositionmarker->type)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.type [BS] %hu != %hu", geopositionmarker->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "type", &type, 0)
        && type == geopositionmarker->type)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.type [BS] set+1 %hu != %hu", geopositionmarker->type, type);
    geopositionmarker->type--;
  }
  if (failed && (is_class_unstable ("GEOPOSITIONMARKER") || is_class_debugging ("GEOPOSITIONMARKER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GEOPOSITIONMARKER", failed);
      failed = 0;
    }
  return failed;
}
static int test_HATCH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_HATCH *restrict hatch = obj->tio.entity->tio.HATCH;
  failed = 0;
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "angle", &angle, NULL)
        && angle == hatch->angle)
      pass ();
    else
      fail ("HATCH.angle [BD] %g != %g", hatch->angle, angle);
    angle++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "angle", &angle, 0)
        && angle == hatch->angle)
      pass ();
    else
      fail ("HATCH.angle [BD] set+1 %g != %g", hatch->angle, angle);
    hatch->angle--;
  }
  {
    BITCODE_B associative;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "associative", &associative, NULL)
        && associative == hatch->associative)
      pass ();
    else
      fail ("HATCH.associative [B] " FORMAT_B " != " FORMAT_B "", hatch->associative, associative);
    associative++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "associative", &associative, 0)
        && associative == hatch->associative)
      pass ();
    else
      fail ("HATCH.associative [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->associative, associative);
    hatch->associative--;
  }
  {
    BITCODE_H* boundary_handles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_boundary_handles", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "boundary_handles", &boundary_handles, NULL)
        && boundary_handles == hatch->boundary_handles)
      pass ();
    else
      fail ("HATCH.boundary_handles [H*] * %u num_boundary_handles", count);
  }
  {
    Dwg_HATCH_Color* colors;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_colors", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "colors", &colors, NULL)
        && colors == hatch->colors)
      pass ();
    else
      fail ("HATCH.colors [Dwg_HATCH_Color*] * %u num_colors", count);
  }
  {
    Dwg_HATCH_DefLine* deflines;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_deflines", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "deflines", &deflines, NULL)
        && deflines == hatch->deflines)
      pass ();
    else
      fail ("HATCH.deflines [Dwg_HATCH_DefLine*] * %u num_deflines", count);
  }
  {
    BITCODE_B double_flag;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "double_flag", &double_flag, NULL)
        && double_flag == hatch->double_flag)
      pass ();
    else
      fail ("HATCH.double_flag [B] " FORMAT_B " != " FORMAT_B "", hatch->double_flag, double_flag);
    double_flag++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "double_flag", &double_flag, 0)
        && double_flag == hatch->double_flag)
      pass ();
    else
      fail ("HATCH.double_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->double_flag, double_flag);
    hatch->double_flag--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "elevation", &elevation, NULL)
        && elevation == hatch->elevation)
      pass ();
    else
      fail ("HATCH.elevation [BD] %g != %g", hatch->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "elevation", &elevation, 0)
        && elevation == hatch->elevation)
      pass ();
    else
      fail ("HATCH.elevation [BD] set+1 %g != %g", hatch->elevation, elevation);
    hatch->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &hatch->extrusion, sizeof (hatch->extrusion)))
        pass ();
    else
        fail ("HATCH.extrusion [BE]");
  }
  {
    BITCODE_BD gradient_angle;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "gradient_angle", &gradient_angle, NULL)
        && gradient_angle == hatch->gradient_angle)
      pass ();
    else
      fail ("HATCH.gradient_angle [BD] %g != %g", hatch->gradient_angle, gradient_angle);
    gradient_angle++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "gradient_angle", &gradient_angle, 0)
        && gradient_angle == hatch->gradient_angle)
      pass ();
    else
      fail ("HATCH.gradient_angle [BD] set+1 %g != %g", hatch->gradient_angle, gradient_angle);
    hatch->gradient_angle--;
  }
  {
    BITCODE_T gradient_name;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "gradient_name", &gradient_name, NULL)
        && gradient_name
           ? strEQ ((char *)gradient_name, (char *)hatch->gradient_name)
           : !hatch->gradient_name)
      pass ();
    else
      fail ("HATCH.gradient_name [T] '%s' <> '%s'", gradient_name, hatch->gradient_name);
  }
  {
    BITCODE_BD gradient_shift;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "gradient_shift", &gradient_shift, NULL)
        && gradient_shift == hatch->gradient_shift)
      pass ();
    else
      fail ("HATCH.gradient_shift [BD] %g != %g", hatch->gradient_shift, gradient_shift);
    gradient_shift++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "gradient_shift", &gradient_shift, 0)
        && gradient_shift == hatch->gradient_shift)
      pass ();
    else
      fail ("HATCH.gradient_shift [BD] set+1 %g != %g", hatch->gradient_shift, gradient_shift);
    hatch->gradient_shift--;
  }
  {
    BITCODE_BD gradient_tint;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "gradient_tint", &gradient_tint, NULL)
        && gradient_tint == hatch->gradient_tint)
      pass ();
    else
      fail ("HATCH.gradient_tint [BD] %g != %g", hatch->gradient_tint, gradient_tint);
    gradient_tint++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "gradient_tint", &gradient_tint, 0)
        && gradient_tint == hatch->gradient_tint)
      pass ();
    else
      fail ("HATCH.gradient_tint [BD] set+1 %g != %g", hatch->gradient_tint, gradient_tint);
    hatch->gradient_tint--;
  }
  {
    BITCODE_B has_derived;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "has_derived", &has_derived, NULL)
        && has_derived == hatch->has_derived)
      pass ();
    else
      fail ("HATCH.has_derived [B] " FORMAT_B " != " FORMAT_B "", hatch->has_derived, has_derived);
    has_derived++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "has_derived", &has_derived, 0)
        && has_derived == hatch->has_derived)
      pass ();
    else
      fail ("HATCH.has_derived [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->has_derived, has_derived);
    hatch->has_derived--;
  }
  {
    BITCODE_BL is_gradient_fill;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "is_gradient_fill", &is_gradient_fill, NULL)
        && is_gradient_fill == hatch->is_gradient_fill)
      pass ();
    else
      fail ("HATCH.is_gradient_fill [BL] %u != %u", hatch->is_gradient_fill, is_gradient_fill);
    is_gradient_fill++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "is_gradient_fill", &is_gradient_fill, 0)
        && is_gradient_fill == hatch->is_gradient_fill)
      pass ();
    else
      fail ("HATCH.is_gradient_fill [BL] set+1 %u != %u", hatch->is_gradient_fill, is_gradient_fill);
    hatch->is_gradient_fill--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)hatch->name)
           : !hatch->name)
      pass ();
    else
      fail ("HATCH.name [T] '%s' <> '%s'", name, hatch->name);
  }
  {
    BITCODE_BL num_boundary_handles;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_boundary_handles", &num_boundary_handles, NULL)
        && num_boundary_handles == hatch->num_boundary_handles)
      pass ();
    else
      fail ("HATCH.num_boundary_handles [BL] %u != %u", hatch->num_boundary_handles, num_boundary_handles);
    num_boundary_handles++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_boundary_handles", &num_boundary_handles, 0)
        && num_boundary_handles == hatch->num_boundary_handles)
      pass ();
    else
      fail ("HATCH.num_boundary_handles [BL] set+1 %u != %u", hatch->num_boundary_handles, num_boundary_handles);
    hatch->num_boundary_handles--;
  }
  {
    BITCODE_BL num_colors;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_colors", &num_colors, NULL)
        && num_colors == hatch->num_colors)
      pass ();
    else
      fail ("HATCH.num_colors [BL] %u != %u", hatch->num_colors, num_colors);
    num_colors++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_colors", &num_colors, 0)
        && num_colors == hatch->num_colors)
      pass ();
    else
      fail ("HATCH.num_colors [BL] set+1 %u != %u", hatch->num_colors, num_colors);
    hatch->num_colors--;
  }
  {
    BITCODE_BS num_deflines;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_deflines", &num_deflines, NULL)
        && num_deflines == hatch->num_deflines)
      pass ();
    else
      fail ("HATCH.num_deflines [BS] %hu != %hu", hatch->num_deflines, num_deflines);
    num_deflines++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_deflines", &num_deflines, 0)
        && num_deflines == hatch->num_deflines)
      pass ();
    else
      fail ("HATCH.num_deflines [BS] set+1 %hu != %hu", hatch->num_deflines, num_deflines);
    hatch->num_deflines--;
  }
  {
    BITCODE_BL num_paths;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_paths", &num_paths, NULL)
        && num_paths == hatch->num_paths)
      pass ();
    else
      fail ("HATCH.num_paths [BL] %u != %u", hatch->num_paths, num_paths);
    num_paths++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_paths", &num_paths, 0)
        && num_paths == hatch->num_paths)
      pass ();
    else
      fail ("HATCH.num_paths [BL] set+1 %u != %u", hatch->num_paths, num_paths);
    hatch->num_paths--;
  }
  {
    BITCODE_BL num_seeds;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_seeds", &num_seeds, NULL)
        && num_seeds == hatch->num_seeds)
      pass ();
    else
      fail ("HATCH.num_seeds [BL] %u != %u", hatch->num_seeds, num_seeds);
    num_seeds++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_seeds", &num_seeds, 0)
        && num_seeds == hatch->num_seeds)
      pass ();
    else
      fail ("HATCH.num_seeds [BL] set+1 %u != %u", hatch->num_seeds, num_seeds);
    hatch->num_seeds--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "parent", &parent, NULL)
        && !memcmp (&parent, &hatch->parent, sizeof (hatch->parent)))
        pass ();
    else
        fail ("HATCH.parent [struct _dwg_object_entity*]");
  }
  {
    Dwg_HATCH_Path* paths;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_paths", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "paths", &paths, NULL)
        && paths == hatch->paths)
      pass ();
    else
      fail ("HATCH.paths [Dwg_HATCH_Path*] * %u num_paths", count);
  }
  {
    BITCODE_BS pattern_type;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "pattern_type", &pattern_type, NULL)
        && pattern_type == hatch->pattern_type)
      pass ();
    else
      fail ("HATCH.pattern_type [BS] %hu != %hu", hatch->pattern_type, pattern_type);
    pattern_type++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "pattern_type", &pattern_type, 0)
        && pattern_type == hatch->pattern_type)
      pass ();
    else
      fail ("HATCH.pattern_type [BS] set+1 %hu != %hu", hatch->pattern_type, pattern_type);
    hatch->pattern_type--;
  }
  {
    BITCODE_BD pixel_size;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "pixel_size", &pixel_size, NULL)
        && pixel_size == hatch->pixel_size)
      pass ();
    else
      fail ("HATCH.pixel_size [BD] %g != %g", hatch->pixel_size, pixel_size);
    pixel_size++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "pixel_size", &pixel_size, 0)
        && pixel_size == hatch->pixel_size)
      pass ();
    else
      fail ("HATCH.pixel_size [BD] set+1 %g != %g", hatch->pixel_size, pixel_size);
    hatch->pixel_size--;
  }
  {
    BITCODE_BL reserved;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "reserved", &reserved, NULL)
        && reserved == hatch->reserved)
      pass ();
    else
      fail ("HATCH.reserved [BL] %u != %u", hatch->reserved, reserved);
    reserved++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "reserved", &reserved, 0)
        && reserved == hatch->reserved)
      pass ();
    else
      fail ("HATCH.reserved [BL] set+1 %u != %u", hatch->reserved, reserved);
    hatch->reserved--;
  }
  {
    BITCODE_BD scale_spacing;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "scale_spacing", &scale_spacing, NULL)
        && scale_spacing == hatch->scale_spacing)
      pass ();
    else
      fail ("HATCH.scale_spacing [BD] %g != %g", hatch->scale_spacing, scale_spacing);
    scale_spacing++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "scale_spacing", &scale_spacing, 0)
        && scale_spacing == hatch->scale_spacing)
      pass ();
    else
      fail ("HATCH.scale_spacing [BD] set+1 %g != %g", hatch->scale_spacing, scale_spacing);
    hatch->scale_spacing--;
  }
  {
    BITCODE_2RD* seeds;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_seeds", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "seeds", &seeds, NULL)
        && seeds == hatch->seeds)
      pass ();
    else
      fail ("HATCH.seeds [2RD*] * %u num_seeds", count);
  }
  {
    BITCODE_BL single_color_gradient;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "single_color_gradient", &single_color_gradient, NULL)
        && single_color_gradient == hatch->single_color_gradient)
      pass ();
    else
      fail ("HATCH.single_color_gradient [BL] %u != %u", hatch->single_color_gradient, single_color_gradient);
    single_color_gradient++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "single_color_gradient", &single_color_gradient, 0)
        && single_color_gradient == hatch->single_color_gradient)
      pass ();
    else
      fail ("HATCH.single_color_gradient [BL] set+1 %u != %u", hatch->single_color_gradient, single_color_gradient);
    hatch->single_color_gradient--;
  }
  {
    BITCODE_B solid_fill;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "solid_fill", &solid_fill, NULL)
        && solid_fill == hatch->solid_fill)
      pass ();
    else
      fail ("HATCH.solid_fill [B] " FORMAT_B " != " FORMAT_B "", hatch->solid_fill, solid_fill);
    solid_fill++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "solid_fill", &solid_fill, 0)
        && solid_fill == hatch->solid_fill)
      pass ();
    else
      fail ("HATCH.solid_fill [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->solid_fill, solid_fill);
    hatch->solid_fill--;
  }
  {
    BITCODE_BS style;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "style", &style, NULL)
        && style == hatch->style)
      pass ();
    else
      fail ("HATCH.style [BS] %hu != %hu", hatch->style, style);
    style++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "style", &style, 0)
        && style == hatch->style)
      pass ();
    else
      fail ("HATCH.style [BS] set+1 %hu != %hu", hatch->style, style);
    hatch->style--;
  }
  if (failed && (is_class_unstable ("HATCH") || is_class_debugging ("HATCH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "HATCH", failed);
      failed = 0;
    }
  return failed;
}
static int test_HELIX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_HELIX *restrict helix = obj->tio.entity->tio.HELIX;
  failed = 0;
  {
    BITCODE_3BD axis_base_pt;
    if (dwg_dynapi_entity_value (helix, "HELIX", "axis_base_pt", &axis_base_pt, NULL)
        && !memcmp (&axis_base_pt, &helix->axis_base_pt, sizeof (helix->axis_base_pt)))
        pass ();
    else
        fail ("HELIX.axis_base_pt [3BD]");
  }
  {
    BITCODE_3BD axis_vector;
    if (dwg_dynapi_entity_value (helix, "HELIX", "axis_vector", &axis_vector, NULL)
        && !memcmp (&axis_vector, &helix->axis_vector, sizeof (helix->axis_vector)))
        pass ();
    else
        fail ("HELIX.axis_vector [3BD_1]");
  }
  {
    BITCODE_3BD beg_tan_vec;
    if (dwg_dynapi_entity_value (helix, "HELIX", "beg_tan_vec", &beg_tan_vec, NULL)
        && !memcmp (&beg_tan_vec, &helix->beg_tan_vec, sizeof (helix->beg_tan_vec)))
        pass ();
    else
        fail ("HELIX.beg_tan_vec [3BD]");
  }
  {
    BITCODE_B closed_b;
    if (dwg_dynapi_entity_value (helix, "HELIX", "closed_b", &closed_b, NULL)
        && closed_b == helix->closed_b)
      pass ();
    else
      fail ("HELIX.closed_b [B] " FORMAT_B " != " FORMAT_B "", helix->closed_b, closed_b);
    closed_b++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "closed_b", &closed_b, 0)
        && closed_b == helix->closed_b)
      pass ();
    else
      fail ("HELIX.closed_b [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->closed_b, closed_b);
    helix->closed_b--;
  }
  {
    BITCODE_BS constraint_type;
    if (dwg_dynapi_entity_value (helix, "HELIX", "constraint_type", &constraint_type, NULL)
        && constraint_type == helix->constraint_type)
      pass ();
    else
      fail ("HELIX.constraint_type [BS] %hu != %hu", helix->constraint_type, constraint_type);
    constraint_type++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "constraint_type", &constraint_type, 0)
        && constraint_type == helix->constraint_type)
      pass ();
    else
      fail ("HELIX.constraint_type [BS] set+1 %hu != %hu", helix->constraint_type, constraint_type);
    helix->constraint_type--;
  }
  {
    Dwg_SPLINE_control_point* ctrl_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_ctrl_pts", &count, NULL)
        && dwg_dynapi_entity_value (helix, "HELIX", "ctrl_pts", &ctrl_pts, NULL)
        && ctrl_pts == helix->ctrl_pts)
      pass ();
    else
      fail ("HELIX.ctrl_pts [Dwg_SPLINE_control_point*] * %u num_ctrl_pts", count);
  }
  {
    BITCODE_BD ctrl_tol;
    if (dwg_dynapi_entity_value (helix, "HELIX", "ctrl_tol", &ctrl_tol, NULL)
        && ctrl_tol == helix->ctrl_tol)
      pass ();
    else
      fail ("HELIX.ctrl_tol [BD] %g != %g", helix->ctrl_tol, ctrl_tol);
    ctrl_tol++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "ctrl_tol", &ctrl_tol, 0)
        && ctrl_tol == helix->ctrl_tol)
      pass ();
    else
      fail ("HELIX.ctrl_tol [BD] set+1 %g != %g", helix->ctrl_tol, ctrl_tol);
    helix->ctrl_tol--;
  }
  {
    BITCODE_BS degree;
    if (dwg_dynapi_entity_value (helix, "HELIX", "degree", &degree, NULL)
        && degree == helix->degree)
      pass ();
    else
      fail ("HELIX.degree [BS] %hu != %hu", helix->degree, degree);
    degree++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "degree", &degree, 0)
        && degree == helix->degree)
      pass ();
    else
      fail ("HELIX.degree [BS] set+1 %hu != %hu", helix->degree, degree);
    helix->degree--;
  }
  {
    BITCODE_3BD end_tan_vec;
    if (dwg_dynapi_entity_value (helix, "HELIX", "end_tan_vec", &end_tan_vec, NULL)
        && !memcmp (&end_tan_vec, &helix->end_tan_vec, sizeof (helix->end_tan_vec)))
        pass ();
    else
        fail ("HELIX.end_tan_vec [3BD]");
  }
  {
    BITCODE_3DPOINT* fit_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_fit_pts", &count, NULL)
        && dwg_dynapi_entity_value (helix, "HELIX", "fit_pts", &fit_pts, NULL)
        && fit_pts == helix->fit_pts)
      pass ();
    else
      fail ("HELIX.fit_pts [3DPOINT*] * %u num_fit_pts", count);
  }
  {
    BITCODE_BD fit_tol;
    if (dwg_dynapi_entity_value (helix, "HELIX", "fit_tol", &fit_tol, NULL)
        && fit_tol == helix->fit_tol)
      pass ();
    else
      fail ("HELIX.fit_tol [BD] %g != %g", helix->fit_tol, fit_tol);
    fit_tol++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "fit_tol", &fit_tol, 0)
        && fit_tol == helix->fit_tol)
      pass ();
    else
      fail ("HELIX.fit_tol [BD] set+1 %g != %g", helix->fit_tol, fit_tol);
    helix->fit_tol--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (helix, "HELIX", "flag", &flag, NULL)
        && flag == helix->flag)
      pass ();
    else
      fail ("HELIX.flag [BS] %hu != %hu", helix->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "flag", &flag, 0)
        && flag == helix->flag)
      pass ();
    else
      fail ("HELIX.flag [BS] set+1 %hu != %hu", helix->flag, flag);
    helix->flag--;
  }
  {
    BITCODE_B handedness;
    if (dwg_dynapi_entity_value (helix, "HELIX", "handedness", &handedness, NULL)
        && handedness == helix->handedness)
      pass ();
    else
      fail ("HELIX.handedness [B] " FORMAT_B " != " FORMAT_B "", helix->handedness, handedness);
    handedness++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "handedness", &handedness, 0)
        && handedness == helix->handedness)
      pass ();
    else
      fail ("HELIX.handedness [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->handedness, handedness);
    helix->handedness--;
  }
  {
    BITCODE_BD knot_tol;
    if (dwg_dynapi_entity_value (helix, "HELIX", "knot_tol", &knot_tol, NULL)
        && knot_tol == helix->knot_tol)
      pass ();
    else
      fail ("HELIX.knot_tol [BD] %g != %g", helix->knot_tol, knot_tol);
    knot_tol++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "knot_tol", &knot_tol, 0)
        && knot_tol == helix->knot_tol)
      pass ();
    else
      fail ("HELIX.knot_tol [BD] set+1 %g != %g", helix->knot_tol, knot_tol);
    helix->knot_tol--;
  }
  {
    BITCODE_BL knotparam;
    if (dwg_dynapi_entity_value (helix, "HELIX", "knotparam", &knotparam, NULL)
        && knotparam == helix->knotparam)
      pass ();
    else
      fail ("HELIX.knotparam [BL] %u != %u", helix->knotparam, knotparam);
    knotparam++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "knotparam", &knotparam, 0)
        && knotparam == helix->knotparam)
      pass ();
    else
      fail ("HELIX.knotparam [BL] set+1 %u != %u", helix->knotparam, knotparam);
    helix->knotparam--;
  }
  {
    BITCODE_BD* knots;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_knots", &count, NULL)
        && dwg_dynapi_entity_value (helix, "HELIX", "knots", &knots, NULL)
        && knots == helix->knots)
      pass ();
    else
      fail ("HELIX.knots [BD*] * %u num_knots", count);
  }
  {
    BITCODE_BS maint_version;
    if (dwg_dynapi_entity_value (helix, "HELIX", "maint_version", &maint_version, NULL)
        && maint_version == helix->maint_version)
      pass ();
    else
      fail ("HELIX.maint_version [BS] %hu != %hu", helix->maint_version, maint_version);
    maint_version++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "maint_version", &maint_version, 0)
        && maint_version == helix->maint_version)
      pass ();
    else
      fail ("HELIX.maint_version [BS] set+1 %hu != %hu", helix->maint_version, maint_version);
    helix->maint_version--;
  }
  {
    BITCODE_BS major_version;
    if (dwg_dynapi_entity_value (helix, "HELIX", "major_version", &major_version, NULL)
        && major_version == helix->major_version)
      pass ();
    else
      fail ("HELIX.major_version [BS] %hu != %hu", helix->major_version, major_version);
    major_version++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "major_version", &major_version, 0)
        && major_version == helix->major_version)
      pass ();
    else
      fail ("HELIX.major_version [BS] set+1 %hu != %hu", helix->major_version, major_version);
    helix->major_version--;
  }
  {
    BITCODE_BL num_ctrl_pts;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_ctrl_pts", &num_ctrl_pts, NULL)
        && num_ctrl_pts == helix->num_ctrl_pts)
      pass ();
    else
      fail ("HELIX.num_ctrl_pts [BL] %u != %u", helix->num_ctrl_pts, num_ctrl_pts);
    num_ctrl_pts++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "num_ctrl_pts", &num_ctrl_pts, 0)
        && num_ctrl_pts == helix->num_ctrl_pts)
      pass ();
    else
      fail ("HELIX.num_ctrl_pts [BL] set+1 %u != %u", helix->num_ctrl_pts, num_ctrl_pts);
    helix->num_ctrl_pts--;
  }
  {
    BITCODE_BS num_fit_pts;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_fit_pts", &num_fit_pts, NULL)
        && num_fit_pts == helix->num_fit_pts)
      pass ();
    else
      fail ("HELIX.num_fit_pts [BS] %hu != %hu", helix->num_fit_pts, num_fit_pts);
    num_fit_pts++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "num_fit_pts", &num_fit_pts, 0)
        && num_fit_pts == helix->num_fit_pts)
      pass ();
    else
      fail ("HELIX.num_fit_pts [BS] set+1 %hu != %hu", helix->num_fit_pts, num_fit_pts);
    helix->num_fit_pts--;
  }
  {
    BITCODE_BL num_knots;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_knots", &num_knots, NULL)
        && num_knots == helix->num_knots)
      pass ();
    else
      fail ("HELIX.num_knots [BL] %u != %u", helix->num_knots, num_knots);
    num_knots++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "num_knots", &num_knots, 0)
        && num_knots == helix->num_knots)
      pass ();
    else
      fail ("HELIX.num_knots [BL] set+1 %u != %u", helix->num_knots, num_knots);
    helix->num_knots--;
  }
  {
    BITCODE_BD num_turns;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_turns", &num_turns, NULL)
        && num_turns == helix->num_turns)
      pass ();
    else
      fail ("HELIX.num_turns [BD] %g != %g", helix->num_turns, num_turns);
    num_turns++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "num_turns", &num_turns, 0)
        && num_turns == helix->num_turns)
      pass ();
    else
      fail ("HELIX.num_turns [BD] set+1 %g != %g", helix->num_turns, num_turns);
    helix->num_turns--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (helix, "HELIX", "parent", &parent, NULL)
        && !memcmp (&parent, &helix->parent, sizeof (helix->parent)))
        pass ();
    else
        fail ("HELIX.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_B periodic;
    if (dwg_dynapi_entity_value (helix, "HELIX", "periodic", &periodic, NULL)
        && periodic == helix->periodic)
      pass ();
    else
      fail ("HELIX.periodic [B] " FORMAT_B " != " FORMAT_B "", helix->periodic, periodic);
    periodic++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "periodic", &periodic, 0)
        && periodic == helix->periodic)
      pass ();
    else
      fail ("HELIX.periodic [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->periodic, periodic);
    helix->periodic--;
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (helix, "HELIX", "radius", &radius, NULL)
        && radius == helix->radius)
      pass ();
    else
      fail ("HELIX.radius [BD] %g != %g", helix->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "radius", &radius, 0)
        && radius == helix->radius)
      pass ();
    else
      fail ("HELIX.radius [BD] set+1 %g != %g", helix->radius, radius);
    helix->radius--;
  }
  {
    BITCODE_B rational;
    if (dwg_dynapi_entity_value (helix, "HELIX", "rational", &rational, NULL)
        && rational == helix->rational)
      pass ();
    else
      fail ("HELIX.rational [B] " FORMAT_B " != " FORMAT_B "", helix->rational, rational);
    rational++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "rational", &rational, 0)
        && rational == helix->rational)
      pass ();
    else
      fail ("HELIX.rational [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->rational, rational);
    helix->rational--;
  }
  {
    BITCODE_BS scenario;
    if (dwg_dynapi_entity_value (helix, "HELIX", "scenario", &scenario, NULL)
        && scenario == helix->scenario)
      pass ();
    else
      fail ("HELIX.scenario [BS] %hu != %hu", helix->scenario, scenario);
    scenario++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "scenario", &scenario, 0)
        && scenario == helix->scenario)
      pass ();
    else
      fail ("HELIX.scenario [BS] set+1 %hu != %hu", helix->scenario, scenario);
    helix->scenario--;
  }
  {
    BITCODE_BL splineflags1;
    if (dwg_dynapi_entity_value (helix, "HELIX", "splineflags1", &splineflags1, NULL)
        && splineflags1 == helix->splineflags1)
      pass ();
    else
      fail ("HELIX.splineflags1 [BL] %u != %u", helix->splineflags1, splineflags1);
    splineflags1++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "splineflags1", &splineflags1, 0)
        && splineflags1 == helix->splineflags1)
      pass ();
    else
      fail ("HELIX.splineflags1 [BL] set+1 %u != %u", helix->splineflags1, splineflags1);
    helix->splineflags1--;
  }
  {
    BITCODE_3BD start_pt;
    if (dwg_dynapi_entity_value (helix, "HELIX", "start_pt", &start_pt, NULL)
        && !memcmp (&start_pt, &helix->start_pt, sizeof (helix->start_pt)))
        pass ();
    else
        fail ("HELIX.start_pt [3BD_1]");
  }
  {
    BITCODE_BD turn_height;
    if (dwg_dynapi_entity_value (helix, "HELIX", "turn_height", &turn_height, NULL)
        && turn_height == helix->turn_height)
      pass ();
    else
      fail ("HELIX.turn_height [BD] %g != %g", helix->turn_height, turn_height);
    turn_height++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "turn_height", &turn_height, 0)
        && turn_height == helix->turn_height)
      pass ();
    else
      fail ("HELIX.turn_height [BD] set+1 %g != %g", helix->turn_height, turn_height);
    helix->turn_height--;
  }
  {
    BITCODE_B weighted;
    if (dwg_dynapi_entity_value (helix, "HELIX", "weighted", &weighted, NULL)
        && weighted == helix->weighted)
      pass ();
    else
      fail ("HELIX.weighted [B] " FORMAT_B " != " FORMAT_B "", helix->weighted, weighted);
    weighted++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "weighted", &weighted, 0)
        && weighted == helix->weighted)
      pass ();
    else
      fail ("HELIX.weighted [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->weighted, weighted);
    helix->weighted--;
  }
  if (failed && (is_class_unstable ("HELIX") || is_class_debugging ("HELIX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "HELIX", failed);
      failed = 0;
    }
  return failed;
}
static int test_IMAGE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_IMAGE *restrict image = obj->tio.entity->tio.IMAGE;
  failed = 0;
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value (image, "IMAGE", "brightness", &brightness, NULL)
        && brightness == image->brightness)
      pass ();
    else
      fail ("IMAGE.brightness [RC] %u != %u", image->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "brightness", &brightness, 0)
        && brightness == image->brightness)
      pass ();
    else
      fail ("IMAGE.brightness [RC] set+1 %u != %u", image->brightness, brightness);
    image->brightness--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (image, "IMAGE", "class_version", &class_version, NULL)
        && class_version == image->class_version)
      pass ();
    else
      fail ("IMAGE.class_version [BL] %u != %u", image->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "class_version", &class_version, 0)
        && class_version == image->class_version)
      pass ();
    else
      fail ("IMAGE.class_version [BL] set+1 %u != %u", image->class_version, class_version);
    image->class_version--;
  }
  {
    BITCODE_BS clip_boundary_type;
    if (dwg_dynapi_entity_value (image, "IMAGE", "clip_boundary_type", &clip_boundary_type, NULL)
        && clip_boundary_type == image->clip_boundary_type)
      pass ();
    else
      fail ("IMAGE.clip_boundary_type [BS] %hu != %hu", image->clip_boundary_type, clip_boundary_type);
    clip_boundary_type++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "clip_boundary_type", &clip_boundary_type, 0)
        && clip_boundary_type == image->clip_boundary_type)
      pass ();
    else
      fail ("IMAGE.clip_boundary_type [BS] set+1 %hu != %hu", image->clip_boundary_type, clip_boundary_type);
    image->clip_boundary_type--;
  }
  {
    BITCODE_B clip_mode;
    if (dwg_dynapi_entity_value (image, "IMAGE", "clip_mode", &clip_mode, NULL)
        && clip_mode == image->clip_mode)
      pass ();
    else
      fail ("IMAGE.clip_mode [B] " FORMAT_B " != " FORMAT_B "", image->clip_mode, clip_mode);
    clip_mode++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "clip_mode", &clip_mode, 0)
        && clip_mode == image->clip_mode)
      pass ();
    else
      fail ("IMAGE.clip_mode [B] set+1 " FORMAT_B " != " FORMAT_B "", image->clip_mode, clip_mode);
    image->clip_mode--;
  }
  {
    BITCODE_2RD* clip_verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (image, "IMAGE", "num_clip_verts", &count, NULL)
        && dwg_dynapi_entity_value (image, "IMAGE", "clip_verts", &clip_verts, NULL)
        && clip_verts == image->clip_verts)
      pass ();
    else
      fail ("IMAGE.clip_verts [2RD*] * %u num_clip_verts", count);
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value (image, "IMAGE", "clipping", &clipping, NULL)
        && clipping == image->clipping)
      pass ();
    else
      fail ("IMAGE.clipping [B] " FORMAT_B " != " FORMAT_B "", image->clipping, clipping);
    clipping++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "clipping", &clipping, 0)
        && clipping == image->clipping)
      pass ();
    else
      fail ("IMAGE.clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", image->clipping, clipping);
    image->clipping--;
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value (image, "IMAGE", "contrast", &contrast, NULL)
        && contrast == image->contrast)
      pass ();
    else
      fail ("IMAGE.contrast [RC] %u != %u", image->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "contrast", &contrast, 0)
        && contrast == image->contrast)
      pass ();
    else
      fail ("IMAGE.contrast [RC] set+1 %u != %u", image->contrast, contrast);
    image->contrast--;
  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value (image, "IMAGE", "display_props", &display_props, NULL)
        && display_props == image->display_props)
      pass ();
    else
      fail ("IMAGE.display_props [BS] %hu != %hu", image->display_props, display_props);
    display_props++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "display_props", &display_props, 0)
        && display_props == image->display_props)
      pass ();
    else
      fail ("IMAGE.display_props [BS] set+1 %hu != %hu", image->display_props, display_props);
    image->display_props--;
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value (image, "IMAGE", "fade", &fade, NULL)
        && fade == image->fade)
      pass ();
    else
      fail ("IMAGE.fade [RC] %u != %u", image->fade, fade);
    fade++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "fade", &fade, 0)
        && fade == image->fade)
      pass ();
    else
      fail ("IMAGE.fade [RC] set+1 %u != %u", image->fade, fade);
    image->fade--;
  }
  {
    BITCODE_H imagedef;
    if (dwg_dynapi_entity_value (image, "IMAGE", "imagedef", &imagedef, NULL)
        && !memcmp (&imagedef, &image->imagedef, sizeof (image->imagedef)))
        pass ();
    else
        fail ("IMAGE.imagedef [H]");
  }
  {
    BITCODE_H imagedefreactor;
    if (dwg_dynapi_entity_value (image, "IMAGE", "imagedefreactor", &imagedefreactor, NULL)
        && !memcmp (&imagedefreactor, &image->imagedefreactor, sizeof (image->imagedefreactor)))
        pass ();
    else
        fail ("IMAGE.imagedefreactor [H]");
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value (image, "IMAGE", "num_clip_verts", &num_clip_verts, NULL)
        && num_clip_verts == image->num_clip_verts)
      pass ();
    else
      fail ("IMAGE.num_clip_verts [BL] %u != %u", image->num_clip_verts, num_clip_verts);
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "num_clip_verts", &num_clip_verts, 0)
        && num_clip_verts == image->num_clip_verts)
      pass ();
    else
      fail ("IMAGE.num_clip_verts [BL] set+1 %u != %u", image->num_clip_verts, num_clip_verts);
    image->num_clip_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (image, "IMAGE", "parent", &parent, NULL)
        && !memcmp (&parent, &image->parent, sizeof (image->parent)))
        pass ();
    else
        fail ("IMAGE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value (image, "IMAGE", "pt0", &pt0, NULL)
        && !memcmp (&pt0, &image->pt0, sizeof (image->pt0)))
        pass ();
    else
        fail ("IMAGE.pt0 [3BD]");
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value (image, "IMAGE", "size", &size, NULL)
        && !memcmp (&size, &image->size, sizeof (image->size)))
        pass ();
    else
        fail ("IMAGE.size [2RD]");
  }
  {
    BITCODE_3BD uvec;
    if (dwg_dynapi_entity_value (image, "IMAGE", "uvec", &uvec, NULL)
        && !memcmp (&uvec, &image->uvec, sizeof (image->uvec)))
        pass ();
    else
        fail ("IMAGE.uvec [3BD]");
  }
  {
    BITCODE_3BD vvec;
    if (dwg_dynapi_entity_value (image, "IMAGE", "vvec", &vvec, NULL)
        && !memcmp (&vvec, &image->vvec, sizeof (image->vvec)))
        pass ();
    else
        fail ("IMAGE.vvec [3BD]");
  }
  if (failed && (is_class_unstable ("IMAGE") || is_class_debugging ("IMAGE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IMAGE", failed);
      failed = 0;
    }
  return failed;
}
static int test_INSERT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_INSERT *restrict insert = obj->tio.entity->tio.INSERT;
  failed = 0;
  {
    BITCODE_H* attrib_handles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (insert, "INSERT", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (insert, "INSERT", "attrib_handles", &attrib_handles, NULL)
        && attrib_handles == insert->attrib_handles)
      pass ();
    else
      fail ("INSERT.attrib_handles [H*] * %u num_owned", count);
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value (insert, "INSERT", "block_header", &block_header, NULL)
        && !memcmp (&block_header, &insert->block_header, sizeof (insert->block_header)))
        pass ();
    else
        fail ("INSERT.block_header [H]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (insert, "INSERT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &insert->extrusion, sizeof (insert->extrusion)))
        pass ();
    else
        fail ("INSERT.extrusion [BE]");
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value (insert, "INSERT", "first_attrib", &first_attrib, NULL)
        && !memcmp (&first_attrib, &insert->first_attrib, sizeof (insert->first_attrib)))
        pass ();
    else
        fail ("INSERT.first_attrib [H]");
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value (insert, "INSERT", "has_attribs", &has_attribs, NULL)
        && has_attribs == insert->has_attribs)
      pass ();
    else
      fail ("INSERT.has_attribs [B] " FORMAT_B " != " FORMAT_B "", insert->has_attribs, has_attribs);
    has_attribs++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "has_attribs", &has_attribs, 0)
        && has_attribs == insert->has_attribs)
      pass ();
    else
      fail ("INSERT.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", insert->has_attribs, has_attribs);
    insert->has_attribs--;
  }
  {
    BITCODE_3DPOINT ins_pt;
    if (dwg_dynapi_entity_value (insert, "INSERT", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &insert->ins_pt, sizeof (insert->ins_pt)))
        pass ();
    else
        fail ("INSERT.ins_pt [3DPOINT]");
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value (insert, "INSERT", "last_attrib", &last_attrib, NULL)
        && !memcmp (&last_attrib, &insert->last_attrib, sizeof (insert->last_attrib)))
        pass ();
    else
        fail ("INSERT.last_attrib [H]");
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (insert, "INSERT", "num_owned", &num_owned, NULL)
        && num_owned == insert->num_owned)
      pass ();
    else
      fail ("INSERT.num_owned [BL] %u != %u", insert->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "num_owned", &num_owned, 0)
        && num_owned == insert->num_owned)
      pass ();
    else
      fail ("INSERT.num_owned [BL] set+1 %u != %u", insert->num_owned, num_owned);
    insert->num_owned--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (insert, "INSERT", "parent", &parent, NULL)
        && !memcmp (&parent, &insert->parent, sizeof (insert->parent)))
        pass ();
    else
        fail ("INSERT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (insert, "INSERT", "rotation", &rotation, NULL)
        && rotation == insert->rotation)
      pass ();
    else
      fail ("INSERT.rotation [BD] %g != %g", insert->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "rotation", &rotation, 0)
        && rotation == insert->rotation)
      pass ();
    else
      fail ("INSERT.rotation [BD] set+1 %g != %g", insert->rotation, rotation);
    insert->rotation--;
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value (insert, "INSERT", "scale", &scale, NULL)
        && !memcmp (&scale, &insert->scale, sizeof (insert->scale)))
        pass ();
    else
        fail ("INSERT.scale [3BD_1]");
  }
  {
    BITCODE_BB scale_flag;
    if (dwg_dynapi_entity_value (insert, "INSERT", "scale_flag", &scale_flag, NULL)
        && scale_flag == insert->scale_flag)
      pass ();
    else
      fail ("INSERT.scale_flag [BB] " FORMAT_BB " != " FORMAT_BB "", insert->scale_flag, scale_flag);
    scale_flag++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "scale_flag", &scale_flag, 0)
        && scale_flag == insert->scale_flag)
      pass ();
    else
      fail ("INSERT.scale_flag [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", insert->scale_flag, scale_flag);
    insert->scale_flag--;
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (insert, "INSERT", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &insert->seqend, sizeof (insert->seqend)))
        pass ();
    else
        fail ("INSERT.seqend [H]");
  }
  if (failed && (is_class_unstable ("INSERT") || is_class_debugging ("INSERT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "INSERT", failed);
      failed = 0;
    }
  return failed;
}
static int test_LEADER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LEADER *restrict leader = obj->tio.entity->tio.LEADER;
  failed = 0;
  {
    BITCODE_BS annot_type;
    if (dwg_dynapi_entity_value (leader, "LEADER", "annot_type", &annot_type, NULL)
        && annot_type == leader->annot_type)
      pass ();
    else
      fail ("LEADER.annot_type [BS] %hu != %hu", leader->annot_type, annot_type);
    annot_type++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "annot_type", &annot_type, 0)
        && annot_type == leader->annot_type)
      pass ();
    else
      fail ("LEADER.annot_type [BS] set+1 %hu != %hu", leader->annot_type, annot_type);
    leader->annot_type--;
  }
  {
    BITCODE_B arrowhead_on;
    if (dwg_dynapi_entity_value (leader, "LEADER", "arrowhead_on", &arrowhead_on, NULL)
        && arrowhead_on == leader->arrowhead_on)
      pass ();
    else
      fail ("LEADER.arrowhead_on [B] " FORMAT_B " != " FORMAT_B "", leader->arrowhead_on, arrowhead_on);
    arrowhead_on++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "arrowhead_on", &arrowhead_on, 0)
        && arrowhead_on == leader->arrowhead_on)
      pass ();
    else
      fail ("LEADER.arrowhead_on [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->arrowhead_on, arrowhead_on);
    leader->arrowhead_on--;
  }
  {
    BITCODE_BS arrowhead_type;
    if (dwg_dynapi_entity_value (leader, "LEADER", "arrowhead_type", &arrowhead_type, NULL)
        && arrowhead_type == leader->arrowhead_type)
      pass ();
    else
      fail ("LEADER.arrowhead_type [BS] %hu != %hu", leader->arrowhead_type, arrowhead_type);
    arrowhead_type++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "arrowhead_type", &arrowhead_type, 0)
        && arrowhead_type == leader->arrowhead_type)
      pass ();
    else
      fail ("LEADER.arrowhead_type [BS] set+1 %hu != %hu", leader->arrowhead_type, arrowhead_type);
    leader->arrowhead_type--;
  }
  {
    BITCODE_H associated_annotation;
    if (dwg_dynapi_entity_value (leader, "LEADER", "associated_annotation", &associated_annotation, NULL)
        && !memcmp (&associated_annotation, &leader->associated_annotation, sizeof (leader->associated_annotation)))
        pass ();
    else
        fail ("LEADER.associated_annotation [H]");
  }
  {
    BITCODE_BD box_height;
    if (dwg_dynapi_entity_value (leader, "LEADER", "box_height", &box_height, NULL)
        && box_height == leader->box_height)
      pass ();
    else
      fail ("LEADER.box_height [BD] %g != %g", leader->box_height, box_height);
    box_height++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "box_height", &box_height, 0)
        && box_height == leader->box_height)
      pass ();
    else
      fail ("LEADER.box_height [BD] set+1 %g != %g", leader->box_height, box_height);
    leader->box_height--;
  }
  {
    BITCODE_BD box_width;
    if (dwg_dynapi_entity_value (leader, "LEADER", "box_width", &box_width, NULL)
        && box_width == leader->box_width)
      pass ();
    else
      fail ("LEADER.box_width [BD] %g != %g", leader->box_width, box_width);
    box_width++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "box_width", &box_width, 0)
        && box_width == leader->box_width)
      pass ();
    else
      fail ("LEADER.box_width [BD] set+1 %g != %g", leader->box_width, box_width);
    leader->box_width--;
  }
  {
    BITCODE_BS byblock_color;
    if (dwg_dynapi_entity_value (leader, "LEADER", "byblock_color", &byblock_color, NULL)
        && byblock_color == leader->byblock_color)
      pass ();
    else
      fail ("LEADER.byblock_color [BS] %hu != %hu", leader->byblock_color, byblock_color);
    byblock_color++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "byblock_color", &byblock_color, 0)
        && byblock_color == leader->byblock_color)
      pass ();
    else
      fail ("LEADER.byblock_color [BS] set+1 %hu != %hu", leader->byblock_color, byblock_color);
    leader->byblock_color--;
  }
  {
    BITCODE_BD dimasz;
    if (dwg_dynapi_entity_value (leader, "LEADER", "dimasz", &dimasz, NULL)
        && dimasz == leader->dimasz)
      pass ();
    else
      fail ("LEADER.dimasz [BD] %g != %g", leader->dimasz, dimasz);
    dimasz++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "dimasz", &dimasz, 0)
        && dimasz == leader->dimasz)
      pass ();
    else
      fail ("LEADER.dimasz [BD] set+1 %g != %g", leader->dimasz, dimasz);
    leader->dimasz--;
  }
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_entity_value (leader, "LEADER", "dimgap", &dimgap, NULL)
        && dimgap == leader->dimgap)
      pass ();
    else
      fail ("LEADER.dimgap [BD] %g != %g", leader->dimgap, dimgap);
    dimgap++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "dimgap", &dimgap, 0)
        && dimgap == leader->dimgap)
      pass ();
    else
      fail ("LEADER.dimgap [BD] set+1 %g != %g", leader->dimgap, dimgap);
    leader->dimgap--;
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (leader, "LEADER", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &leader->dimstyle, sizeof (leader->dimstyle)))
        pass ();
    else
        fail ("LEADER.dimstyle [H]");
  }
  {
    BITCODE_3DPOINT endptproj;
    if (dwg_dynapi_entity_value (leader, "LEADER", "endptproj", &endptproj, NULL)
        && !memcmp (&endptproj, &leader->endptproj, sizeof (leader->endptproj)))
        pass ();
    else
        fail ("LEADER.endptproj [3DPOINT]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (leader, "LEADER", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &leader->extrusion, sizeof (leader->extrusion)))
        pass ();
    else
        fail ("LEADER.extrusion [BE]");
  }
  {
    BITCODE_B hookline_dir;
    if (dwg_dynapi_entity_value (leader, "LEADER", "hookline_dir", &hookline_dir, NULL)
        && hookline_dir == leader->hookline_dir)
      pass ();
    else
      fail ("LEADER.hookline_dir [B] " FORMAT_B " != " FORMAT_B "", leader->hookline_dir, hookline_dir);
    hookline_dir++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "hookline_dir", &hookline_dir, 0)
        && hookline_dir == leader->hookline_dir)
      pass ();
    else
      fail ("LEADER.hookline_dir [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->hookline_dir, hookline_dir);
    leader->hookline_dir--;
  }
  {
    BITCODE_B hookline_on;
    if (dwg_dynapi_entity_value (leader, "LEADER", "hookline_on", &hookline_on, NULL)
        && hookline_on == leader->hookline_on)
      pass ();
    else
      fail ("LEADER.hookline_on [B] " FORMAT_B " != " FORMAT_B "", leader->hookline_on, hookline_on);
    hookline_on++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "hookline_on", &hookline_on, 0)
        && hookline_on == leader->hookline_on)
      pass ();
    else
      fail ("LEADER.hookline_on [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->hookline_on, hookline_on);
    leader->hookline_on--;
  }
  {
    BITCODE_BL num_points;
    if (dwg_dynapi_entity_value (leader, "LEADER", "num_points", &num_points, NULL)
        && num_points == leader->num_points)
      pass ();
    else
      fail ("LEADER.num_points [BL] %u != %u", leader->num_points, num_points);
    num_points++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "num_points", &num_points, 0)
        && num_points == leader->num_points)
      pass ();
    else
      fail ("LEADER.num_points [BL] set+1 %u != %u", leader->num_points, num_points);
    leader->num_points--;
  }
  {
    BITCODE_3DPOINT offset_to_block_ins_pt;
    if (dwg_dynapi_entity_value (leader, "LEADER", "offset_to_block_ins_pt", &offset_to_block_ins_pt, NULL)
        && !memcmp (&offset_to_block_ins_pt, &leader->offset_to_block_ins_pt, sizeof (leader->offset_to_block_ins_pt)))
        pass ();
    else
        fail ("LEADER.offset_to_block_ins_pt [3DPOINT]");
  }
  {
    BITCODE_3DPOINT origin;
    if (dwg_dynapi_entity_value (leader, "LEADER", "origin", &origin, NULL)
        && !memcmp (&origin, &leader->origin, sizeof (leader->origin)))
        pass ();
    else
        fail ("LEADER.origin [3DPOINT]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (leader, "LEADER", "parent", &parent, NULL)
        && !memcmp (&parent, &leader->parent, sizeof (leader->parent)))
        pass ();
    else
        fail ("LEADER.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BS path_type;
    if (dwg_dynapi_entity_value (leader, "LEADER", "path_type", &path_type, NULL)
        && path_type == leader->path_type)
      pass ();
    else
      fail ("LEADER.path_type [BS] %hu != %hu", leader->path_type, path_type);
    path_type++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "path_type", &path_type, 0)
        && path_type == leader->path_type)
      pass ();
    else
      fail ("LEADER.path_type [BS] set+1 %hu != %hu", leader->path_type, path_type);
    leader->path_type--;
  }
  {
    BITCODE_3DPOINT* points;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (leader, "LEADER", "num_points", &count, NULL)
        && dwg_dynapi_entity_value (leader, "LEADER", "points", &points, NULL)
        && points == leader->points)
      pass ();
    else
      fail ("LEADER.points [3DPOINT*] * %u num_points", count);
  }
  {
    BITCODE_B unknown_bit_1;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_1", &unknown_bit_1, NULL)
        && unknown_bit_1 == leader->unknown_bit_1)
      pass ();
    else
      fail ("LEADER.unknown_bit_1 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_1, unknown_bit_1);
    unknown_bit_1++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_1", &unknown_bit_1, 0)
        && unknown_bit_1 == leader->unknown_bit_1)
      pass ();
    else
      fail ("LEADER.unknown_bit_1 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_1, unknown_bit_1);
    leader->unknown_bit_1--;
  }
  {
    BITCODE_B unknown_bit_2;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_2", &unknown_bit_2, NULL)
        && unknown_bit_2 == leader->unknown_bit_2)
      pass ();
    else
      fail ("LEADER.unknown_bit_2 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_2, unknown_bit_2);
    unknown_bit_2++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_2", &unknown_bit_2, 0)
        && unknown_bit_2 == leader->unknown_bit_2)
      pass ();
    else
      fail ("LEADER.unknown_bit_2 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_2, unknown_bit_2);
    leader->unknown_bit_2--;
  }
  {
    BITCODE_B unknown_bit_3;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_3", &unknown_bit_3, NULL)
        && unknown_bit_3 == leader->unknown_bit_3)
      pass ();
    else
      fail ("LEADER.unknown_bit_3 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_3, unknown_bit_3);
    unknown_bit_3++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_3", &unknown_bit_3, 0)
        && unknown_bit_3 == leader->unknown_bit_3)
      pass ();
    else
      fail ("LEADER.unknown_bit_3 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_3, unknown_bit_3);
    leader->unknown_bit_3--;
  }
  {
    BITCODE_B unknown_bit_5;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_5", &unknown_bit_5, NULL)
        && unknown_bit_5 == leader->unknown_bit_5)
      pass ();
    else
      fail ("LEADER.unknown_bit_5 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_5, unknown_bit_5);
    unknown_bit_5++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_5", &unknown_bit_5, 0)
        && unknown_bit_5 == leader->unknown_bit_5)
      pass ();
    else
      fail ("LEADER.unknown_bit_5 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_5, unknown_bit_5);
    leader->unknown_bit_5--;
  }
  {
    BITCODE_BS unknown_short_1;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_short_1", &unknown_short_1, NULL)
        && unknown_short_1 == leader->unknown_short_1)
      pass ();
    else
      fail ("LEADER.unknown_short_1 [BS] %hu != %hu", leader->unknown_short_1, unknown_short_1);
    unknown_short_1++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_short_1", &unknown_short_1, 0)
        && unknown_short_1 == leader->unknown_short_1)
      pass ();
    else
      fail ("LEADER.unknown_short_1 [BS] set+1 %hu != %hu", leader->unknown_short_1, unknown_short_1);
    leader->unknown_short_1--;
  }
  {
    BITCODE_3DPOINT x_direction;
    if (dwg_dynapi_entity_value (leader, "LEADER", "x_direction", &x_direction, NULL)
        && !memcmp (&x_direction, &leader->x_direction, sizeof (leader->x_direction)))
        pass ();
    else
        fail ("LEADER.x_direction [3DPOINT]");
  }
  if (failed && (is_class_unstable ("LEADER") || is_class_debugging ("LEADER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LEADER", failed);
      failed = 0;
    }
  return failed;
}
static int test_LIGHT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LIGHT *restrict light = obj->tio.entity->tio.LIGHT;
  failed = 0;
  {
    BITCODE_BD attenuation_end_limit;
    if (dwg_dynapi_entity_value (light, "LIGHT", "attenuation_end_limit", &attenuation_end_limit, NULL)
        && attenuation_end_limit == light->attenuation_end_limit)
      pass ();
    else
      fail ("LIGHT.attenuation_end_limit [BD] %g != %g", light->attenuation_end_limit, attenuation_end_limit);
    attenuation_end_limit++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "attenuation_end_limit", &attenuation_end_limit, 0)
        && attenuation_end_limit == light->attenuation_end_limit)
      pass ();
    else
      fail ("LIGHT.attenuation_end_limit [BD] set+1 %g != %g", light->attenuation_end_limit, attenuation_end_limit);
    light->attenuation_end_limit--;
  }
  {
    BITCODE_BD attenuation_start_limit;
    if (dwg_dynapi_entity_value (light, "LIGHT", "attenuation_start_limit", &attenuation_start_limit, NULL)
        && attenuation_start_limit == light->attenuation_start_limit)
      pass ();
    else
      fail ("LIGHT.attenuation_start_limit [BD] %g != %g", light->attenuation_start_limit, attenuation_start_limit);
    attenuation_start_limit++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "attenuation_start_limit", &attenuation_start_limit, 0)
        && attenuation_start_limit == light->attenuation_start_limit)
      pass ();
    else
      fail ("LIGHT.attenuation_start_limit [BD] set+1 %g != %g", light->attenuation_start_limit, attenuation_start_limit);
    light->attenuation_start_limit--;
  }
  {
    BITCODE_BS attenuation_type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "attenuation_type", &attenuation_type, NULL)
        && attenuation_type == light->attenuation_type)
      pass ();
    else
      fail ("LIGHT.attenuation_type [BS] %hu != %hu", light->attenuation_type, attenuation_type);
    attenuation_type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "attenuation_type", &attenuation_type, 0)
        && attenuation_type == light->attenuation_type)
      pass ();
    else
      fail ("LIGHT.attenuation_type [BS] set+1 %hu != %hu", light->attenuation_type, attenuation_type);
    light->attenuation_type--;
  }
  {
    BITCODE_B cast_shadows;
    if (dwg_dynapi_entity_value (light, "LIGHT", "cast_shadows", &cast_shadows, NULL)
        && cast_shadows == light->cast_shadows)
      pass ();
    else
      fail ("LIGHT.cast_shadows [B] " FORMAT_B " != " FORMAT_B "", light->cast_shadows, cast_shadows);
    cast_shadows++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "cast_shadows", &cast_shadows, 0)
        && cast_shadows == light->cast_shadows)
      pass ();
    else
      fail ("LIGHT.cast_shadows [B] set+1 " FORMAT_B " != " FORMAT_B "", light->cast_shadows, cast_shadows);
    light->cast_shadows--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (light, "LIGHT", "class_version", &class_version, NULL)
        && class_version == light->class_version)
      pass ();
    else
      fail ("LIGHT.class_version [BL] %u != %u", light->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "class_version", &class_version, 0)
        && class_version == light->class_version)
      pass ();
    else
      fail ("LIGHT.class_version [BL] set+1 %u != %u", light->class_version, class_version);
    light->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (light, "LIGHT", "color", &color, NULL)
        && !memcmp (&color, &light->color, sizeof (light->color)))
        pass ();
    else
        fail ("LIGHT.color [CMC]");
  }
  {
    BITCODE_BD falloff_angle;
    if (dwg_dynapi_entity_value (light, "LIGHT", "falloff_angle", &falloff_angle, NULL)
        && falloff_angle == light->falloff_angle)
      pass ();
    else
      fail ("LIGHT.falloff_angle [BD] %g != %g", light->falloff_angle, falloff_angle);
    falloff_angle++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "falloff_angle", &falloff_angle, 0)
        && falloff_angle == light->falloff_angle)
      pass ();
    else
      fail ("LIGHT.falloff_angle [BD] set+1 %g != %g", light->falloff_angle, falloff_angle);
    light->falloff_angle--;
  }
  {
    BITCODE_BD hotspot_angle;
    if (dwg_dynapi_entity_value (light, "LIGHT", "hotspot_angle", &hotspot_angle, NULL)
        && hotspot_angle == light->hotspot_angle)
      pass ();
    else
      fail ("LIGHT.hotspot_angle [BD] %g != %g", light->hotspot_angle, hotspot_angle);
    hotspot_angle++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "hotspot_angle", &hotspot_angle, 0)
        && hotspot_angle == light->hotspot_angle)
      pass ();
    else
      fail ("LIGHT.hotspot_angle [BD] set+1 %g != %g", light->hotspot_angle, hotspot_angle);
    light->hotspot_angle--;
  }
  {
    BITCODE_BD intensity;
    if (dwg_dynapi_entity_value (light, "LIGHT", "intensity", &intensity, NULL)
        && intensity == light->intensity)
      pass ();
    else
      fail ("LIGHT.intensity [BD] %g != %g", light->intensity, intensity);
    intensity++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "intensity", &intensity, 0)
        && intensity == light->intensity)
      pass ();
    else
      fail ("LIGHT.intensity [BD] set+1 %g != %g", light->intensity, intensity);
    light->intensity--;
  }
  {
    BITCODE_H lights_layer;
    if (dwg_dynapi_entity_value (light, "LIGHT", "lights_layer", &lights_layer, NULL)
        && !memcmp (&lights_layer, &light->lights_layer, sizeof (light->lights_layer)))
        pass ();
    else
        fail ("LIGHT.lights_layer [H]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (light, "LIGHT", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)light->name)
           : !light->name)
      pass ();
    else
      fail ("LIGHT.name [T] '%s' <> '%s'", name, light->name);
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (light, "LIGHT", "parent", &parent, NULL)
        && !memcmp (&parent, &light->parent, sizeof (light->parent)))
        pass ();
    else
        fail ("LIGHT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_B plot_glyph;
    if (dwg_dynapi_entity_value (light, "LIGHT", "plot_glyph", &plot_glyph, NULL)
        && plot_glyph == light->plot_glyph)
      pass ();
    else
      fail ("LIGHT.plot_glyph [B] " FORMAT_B " != " FORMAT_B "", light->plot_glyph, plot_glyph);
    plot_glyph++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "plot_glyph", &plot_glyph, 0)
        && plot_glyph == light->plot_glyph)
      pass ();
    else
      fail ("LIGHT.plot_glyph [B] set+1 " FORMAT_B " != " FORMAT_B "", light->plot_glyph, plot_glyph);
    light->plot_glyph--;
  }
  {
    BITCODE_3BD position;
    if (dwg_dynapi_entity_value (light, "LIGHT", "position", &position, NULL)
        && !memcmp (&position, &light->position, sizeof (light->position)))
        pass ();
    else
        fail ("LIGHT.position [3BD]");
  }
  {
    BITCODE_BS shadow_map_size;
    if (dwg_dynapi_entity_value (light, "LIGHT", "shadow_map_size", &shadow_map_size, NULL)
        && shadow_map_size == light->shadow_map_size)
      pass ();
    else
      fail ("LIGHT.shadow_map_size [BS] %hu != %hu", light->shadow_map_size, shadow_map_size);
    shadow_map_size++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "shadow_map_size", &shadow_map_size, 0)
        && shadow_map_size == light->shadow_map_size)
      pass ();
    else
      fail ("LIGHT.shadow_map_size [BS] set+1 %hu != %hu", light->shadow_map_size, shadow_map_size);
    light->shadow_map_size--;
  }
  {
    BITCODE_RC shadow_map_softness;
    if (dwg_dynapi_entity_value (light, "LIGHT", "shadow_map_softness", &shadow_map_softness, NULL)
        && shadow_map_softness == light->shadow_map_softness)
      pass ();
    else
      fail ("LIGHT.shadow_map_softness [RC] %u != %u", light->shadow_map_softness, shadow_map_softness);
    shadow_map_softness++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "shadow_map_softness", &shadow_map_softness, 0)
        && shadow_map_softness == light->shadow_map_softness)
      pass ();
    else
      fail ("LIGHT.shadow_map_softness [RC] set+1 %u != %u", light->shadow_map_softness, shadow_map_softness);
    light->shadow_map_softness--;
  }
  {
    BITCODE_BS shadow_type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "shadow_type", &shadow_type, NULL)
        && shadow_type == light->shadow_type)
      pass ();
    else
      fail ("LIGHT.shadow_type [BS] %hu != %hu", light->shadow_type, shadow_type);
    shadow_type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "shadow_type", &shadow_type, 0)
        && shadow_type == light->shadow_type)
      pass ();
    else
      fail ("LIGHT.shadow_type [BS] set+1 %hu != %hu", light->shadow_type, shadow_type);
    light->shadow_type--;
  }
  {
    BITCODE_B status;
    if (dwg_dynapi_entity_value (light, "LIGHT", "status", &status, NULL)
        && status == light->status)
      pass ();
    else
      fail ("LIGHT.status [B] " FORMAT_B " != " FORMAT_B "", light->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "status", &status, 0)
        && status == light->status)
      pass ();
    else
      fail ("LIGHT.status [B] set+1 " FORMAT_B " != " FORMAT_B "", light->status, status);
    light->status--;
  }
  {
    BITCODE_3BD target;
    if (dwg_dynapi_entity_value (light, "LIGHT", "target", &target, NULL)
        && !memcmp (&target, &light->target, sizeof (light->target)))
        pass ();
    else
        fail ("LIGHT.target [3BD]");
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "type", &type, NULL)
        && type == light->type)
      pass ();
    else
      fail ("LIGHT.type [BS] %hu != %hu", light->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "type", &type, 0)
        && type == light->type)
      pass ();
    else
      fail ("LIGHT.type [BS] set+1 %hu != %hu", light->type, type);
    light->type--;
  }
  {
    BITCODE_B use_attenuation_limits;
    if (dwg_dynapi_entity_value (light, "LIGHT", "use_attenuation_limits", &use_attenuation_limits, NULL)
        && use_attenuation_limits == light->use_attenuation_limits)
      pass ();
    else
      fail ("LIGHT.use_attenuation_limits [B] " FORMAT_B " != " FORMAT_B "", light->use_attenuation_limits, use_attenuation_limits);
    use_attenuation_limits++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "use_attenuation_limits", &use_attenuation_limits, 0)
        && use_attenuation_limits == light->use_attenuation_limits)
      pass ();
    else
      fail ("LIGHT.use_attenuation_limits [B] set+1 " FORMAT_B " != " FORMAT_B "", light->use_attenuation_limits, use_attenuation_limits);
    light->use_attenuation_limits--;
  }
  if (failed && (is_class_unstable ("LIGHT") || is_class_debugging ("LIGHT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LIGHT", failed);
      failed = 0;
    }
  return failed;
}
static int test_LINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LINE *restrict line = obj->tio.entity->tio.LINE;
  failed = 0;
  {
    BITCODE_3BD end;
    if (dwg_dynapi_entity_value (line, "LINE", "end", &end, NULL)
        && !memcmp (&end, &line->end, sizeof (line->end)))
        pass ();
    else
        fail ("LINE.end [3BD]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (line, "LINE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &line->extrusion, sizeof (line->extrusion)))
        pass ();
    else
        fail ("LINE.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (line, "LINE", "parent", &parent, NULL)
        && !memcmp (&parent, &line->parent, sizeof (line->parent)))
        pass ();
    else
        fail ("LINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD start;
    if (dwg_dynapi_entity_value (line, "LINE", "start", &start, NULL)
        && !memcmp (&start, &line->start, sizeof (line->start)))
        pass ();
    else
        fail ("LINE.start [3BD]");
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (line, "LINE", "thickness", &thickness, NULL)
        && thickness == line->thickness)
      pass ();
    else
      fail ("LINE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", line->thickness, thickness);
    if (dwg_dynapi_entity_set_value (line, "LINE", "thickness", &thickness, 0)
        && thickness == line->thickness)
      pass ();
    else
      fail ("LINE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", line->thickness, thickness);
    line->thickness--;
  }
  {
    BITCODE_RC z_is_zero;
    if (dwg_dynapi_entity_value (line, "LINE", "z_is_zero", &z_is_zero, NULL)
        && z_is_zero == line->z_is_zero)
      pass ();
    else
      fail ("LINE.z_is_zero [RC] %u != %u", line->z_is_zero, z_is_zero);
    z_is_zero++;
    if (dwg_dynapi_entity_set_value (line, "LINE", "z_is_zero", &z_is_zero, 0)
        && z_is_zero == line->z_is_zero)
      pass ();
    else
      fail ("LINE.z_is_zero [RC] set+1 %u != %u", line->z_is_zero, z_is_zero);
    line->z_is_zero--;
  }
  if (failed && (is_class_unstable ("LINE") || is_class_debugging ("LINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_LOFTEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LOFTEDSURFACE *restrict loftedsurface = obj->tio.entity->tio.LOFTEDSURFACE;
  failed = 0;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)loftedsurface->acis_data)
           : !loftedsurface->acis_data)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, loftedsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == loftedsurface->acis_empty)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == loftedsurface->acis_empty)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty, acis_empty);
    loftedsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == loftedsurface->acis_empty2)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == loftedsurface->acis_empty2)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty2, acis_empty2);
    loftedsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == loftedsurface->acis_empty_bit)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == loftedsurface->acis_empty_bit)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty_bit, acis_empty_bit);
    loftedsurface->acis_empty_bit--;
  }
  {
    BITCODE_B align_direction;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction, NULL)
        && align_direction == loftedsurface->align_direction)
      pass ();
    else
      fail ("LOFTEDSURFACE.align_direction [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction);
    align_direction++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction, 0)
        && align_direction == loftedsurface->align_direction)
      pass ();
    else
      fail ("LOFTEDSURFACE.align_direction [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction);
    loftedsurface->align_direction--;
  }
  {
    BITCODE_B arc_length_parameterization;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization, NULL)
        && arc_length_parameterization == loftedsurface->arc_length_parameterization)
      pass ();
    else
      fail ("LOFTEDSURFACE.arc_length_parameterization [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization);
    arc_length_parameterization++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization, 0)
        && arc_length_parameterization == loftedsurface->arc_length_parameterization)
      pass ();
    else
      fail ("LOFTEDSURFACE.arc_length_parameterization [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization);
    loftedsurface->arc_length_parameterization--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &loftedsurface->block_size, sizeof (loftedsurface->block_size)))
        pass ();
    else
        fail ("LOFTEDSURFACE.block_size [BL*]");
  }
  {
    BITCODE_B closed_surfaces;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces, NULL)
        && closed_surfaces == loftedsurface->closed_surfaces)
      pass ();
    else
      fail ("LOFTEDSURFACE.closed_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces);
    closed_surfaces++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces, 0)
        && closed_surfaces == loftedsurface->closed_surfaces)
      pass ();
    else
      fail ("LOFTEDSURFACE.closed_surfaces [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces);
    loftedsurface->closed_surfaces--;
  }
  {
    BITCODE_H* cross_sections;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "cross_sections", &cross_sections, NULL)
        && cross_sections == loftedsurface->cross_sections)
      pass ();
    else
      fail ("LOFTEDSURFACE.cross_sections [H*] * %u num_cross_sections", count);
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &loftedsurface->encr_sat_data, sizeof (loftedsurface->encr_sat_data)))
      pass ();
    else
      fail ("LOFTEDSURFACE.encr_sat_data [char **]");
  }
  {
    BITCODE_BD end_draft_angle;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle, NULL)
        && end_draft_angle == loftedsurface->end_draft_angle)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_draft_angle [BD] %g != %g", loftedsurface->end_draft_angle, end_draft_angle);
    end_draft_angle++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle, 0)
        && end_draft_angle == loftedsurface->end_draft_angle)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_draft_angle [BD] set+1 %g != %g", loftedsurface->end_draft_angle, end_draft_angle);
    loftedsurface->end_draft_angle--;
  }
  {
    BITCODE_BD end_draft_magnitude;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude, NULL)
        && end_draft_magnitude == loftedsurface->end_draft_magnitude)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_draft_magnitude [BD] %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude);
    end_draft_magnitude++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude, 0)
        && end_draft_magnitude == loftedsurface->end_draft_magnitude)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_draft_magnitude [BD] set+1 %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude);
    loftedsurface->end_draft_magnitude--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &loftedsurface->extra_acis_data, sizeof (loftedsurface->extra_acis_data)))
        pass ();
    else
        fail ("LOFTEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_H* guide_curves;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "guide_curves", &guide_curves, NULL)
        && guide_curves == loftedsurface->guide_curves)
      pass ();
    else
      fail ("LOFTEDSURFACE.guide_curves [H*] * %u num_guide_curves", count);
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &loftedsurface->history_id, sizeof (loftedsurface->history_id)))
        pass ();
    else
        fail ("LOFTEDSURFACE.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == loftedsurface->isoline_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == loftedsurface->isoline_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->isoline_present, isoline_present);
    loftedsurface->isoline_present--;
  }
  {
    BITCODE_BD* loft_entity_transmatrix;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "loft_entity_transmatrix", &loft_entity_transmatrix, NULL)
        && !memcmp (&loft_entity_transmatrix, &loftedsurface->loft_entity_transmatrix, sizeof (loftedsurface->loft_entity_transmatrix)))
        pass ();
    else
        fail ("LOFTEDSURFACE.loft_entity_transmatrix [BD*]");
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == loftedsurface->modeler_format_version)
      pass ();
    else
      fail ("LOFTEDSURFACE.modeler_format_version [BS] %hu != %hu", loftedsurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == loftedsurface->modeler_format_version)
      pass ();
    else
      fail ("LOFTEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", loftedsurface->modeler_format_version, modeler_format_version);
    loftedsurface->modeler_format_version--;
  }
  {
    BITCODE_B no_twist;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist, NULL)
        && no_twist == loftedsurface->no_twist)
      pass ();
    else
      fail ("LOFTEDSURFACE.no_twist [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist);
    no_twist++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist, 0)
        && no_twist == loftedsurface->no_twist)
      pass ();
    else
      fail ("LOFTEDSURFACE.no_twist [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist);
    loftedsurface->no_twist--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == loftedsurface->num_blocks)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_blocks [BL] %u != %u", loftedsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == loftedsurface->num_blocks)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_blocks [BL] set+1 %u != %u", loftedsurface->num_blocks, num_blocks);
    loftedsurface->num_blocks--;
  }
  {
    BITCODE_BS num_cross_sections;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections, NULL)
        && num_cross_sections == loftedsurface->num_cross_sections)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_cross_sections [BS] %hu != %hu", loftedsurface->num_cross_sections, num_cross_sections);
    num_cross_sections++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections, 0)
        && num_cross_sections == loftedsurface->num_cross_sections)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_cross_sections [BS] set+1 %hu != %hu", loftedsurface->num_cross_sections, num_cross_sections);
    loftedsurface->num_cross_sections--;
  }
  {
    BITCODE_BS num_guide_curves;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves, NULL)
        && num_guide_curves == loftedsurface->num_guide_curves)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_guide_curves [BS] %hu != %hu", loftedsurface->num_guide_curves, num_guide_curves);
    num_guide_curves++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves, 0)
        && num_guide_curves == loftedsurface->num_guide_curves)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_guide_curves [BS] set+1 %hu != %hu", loftedsurface->num_guide_curves, num_guide_curves);
    loftedsurface->num_guide_curves--;
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_isolines", &num_isolines, NULL)
        && num_isolines == loftedsurface->num_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_isolines [BL] %u != %u", loftedsurface->num_isolines, num_isolines);
    num_isolines++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_isolines", &num_isolines, 0)
        && num_isolines == loftedsurface->num_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_isolines [BL] set+1 %u != %u", loftedsurface->num_isolines, num_isolines);
    loftedsurface->num_isolines--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == loftedsurface->num_silhouettes)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_silhouettes [BL] %u != %u", loftedsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == loftedsurface->num_silhouettes)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_silhouettes [BL] set+1 %u != %u", loftedsurface->num_silhouettes, num_silhouettes);
    loftedsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == loftedsurface->num_wires)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_wires [BL] %u != %u", loftedsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires, 0)
        && num_wires == loftedsurface->num_wires)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_wires [BL] set+1 %u != %u", loftedsurface->num_wires, num_wires);
    loftedsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &loftedsurface->parent, sizeof (loftedsurface->parent)))
        pass ();
    else
        fail ("LOFTEDSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H path_curve;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "path_curve", &path_curve, NULL)
        && !memcmp (&path_curve, &loftedsurface->path_curve, sizeof (loftedsurface->path_curve)))
        pass ();
    else
        fail ("LOFTEDSURFACE.path_curve [H]");
  }
  {
    BITCODE_BL plane_normal_lofting_type;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type, NULL)
        && plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
      pass ();
    else
      fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type);
    plane_normal_lofting_type++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type, 0)
        && plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
      pass ();
    else
      fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] set+1 %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type);
    loftedsurface->plane_normal_lofting_type--;
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "point", &point, NULL)
        && !memcmp (&point, &loftedsurface->point, sizeof (loftedsurface->point)))
        pass ();
    else
        fail ("LOFTEDSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "point_present", &point_present, NULL)
        && point_present == loftedsurface->point_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "point_present", &point_present, 0)
        && point_present == loftedsurface->point_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->point_present, point_present);
    loftedsurface->point_present--;
  }
  {
    BITCODE_B ruled_surface;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface, NULL)
        && ruled_surface == loftedsurface->ruled_surface)
      pass ();
    else
      fail ("LOFTEDSURFACE.ruled_surface [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface);
    ruled_surface++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface, 0)
        && ruled_surface == loftedsurface->ruled_surface)
      pass ();
    else
      fail ("LOFTEDSURFACE.ruled_surface [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface);
    loftedsurface->ruled_surface--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == loftedsurface->silhouettes)
      pass ();
    else
      fail ("LOFTEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B simple_surfaces;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces, NULL)
        && simple_surfaces == loftedsurface->simple_surfaces)
      pass ();
    else
      fail ("LOFTEDSURFACE.simple_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces);
    simple_surfaces++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces, 0)
        && simple_surfaces == loftedsurface->simple_surfaces)
      pass ();
    else
      fail ("LOFTEDSURFACE.simple_surfaces [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces);
    loftedsurface->simple_surfaces--;
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "solid", &solid, NULL)
        && solid == loftedsurface->solid)
      pass ();
    else
      fail ("LOFTEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid);
    solid++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "solid", &solid, 0)
        && solid == loftedsurface->solid)
      pass ();
    else
      fail ("LOFTEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid);
    loftedsurface->solid--;
  }
  {
    BITCODE_BD start_draft_angle;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle, NULL)
        && start_draft_angle == loftedsurface->start_draft_angle)
      pass ();
    else
      fail ("LOFTEDSURFACE.start_draft_angle [BD] %g != %g", loftedsurface->start_draft_angle, start_draft_angle);
    start_draft_angle++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle, 0)
        && start_draft_angle == loftedsurface->start_draft_angle)
      pass ();
    else
      fail ("LOFTEDSURFACE.start_draft_angle [BD] set+1 %g != %g", loftedsurface->start_draft_angle, start_draft_angle);
    loftedsurface->start_draft_angle--;
  }
  {
    BITCODE_BD start_draft_magnitude;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude, NULL)
        && start_draft_magnitude == loftedsurface->start_draft_magnitude)
      pass ();
    else
      fail ("LOFTEDSURFACE.start_draft_magnitude [BD] %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude);
    start_draft_magnitude++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude, 0)
        && start_draft_magnitude == loftedsurface->start_draft_magnitude)
      pass ();
    else
      fail ("LOFTEDSURFACE.start_draft_magnitude [BD] set+1 %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude);
    loftedsurface->start_draft_magnitude--;
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == loftedsurface->u_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.u_isolines [BS] %hu != %hu", loftedsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == loftedsurface->u_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.u_isolines [BS] set+1 %hu != %hu", loftedsurface->u_isolines, u_isolines);
    loftedsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "unknown", &unknown, NULL)
        && unknown == loftedsurface->unknown)
      pass ();
    else
      fail ("LOFTEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "unknown", &unknown, 0)
        && unknown == loftedsurface->unknown)
      pass ();
    else
      fail ("LOFTEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->unknown, unknown);
    loftedsurface->unknown--;
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "unknown_2007", &unknown_2007, NULL)
        && unknown_2007 == loftedsurface->unknown_2007)
      pass ();
    else
      fail ("LOFTEDSURFACE.unknown_2007 [BL] %u != %u", loftedsurface->unknown_2007, unknown_2007);
    unknown_2007++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "unknown_2007", &unknown_2007, 0)
        && unknown_2007 == loftedsurface->unknown_2007)
      pass ();
    else
      fail ("LOFTEDSURFACE.unknown_2007 [BL] set+1 %u != %u", loftedsurface->unknown_2007, unknown_2007);
    loftedsurface->unknown_2007--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == loftedsurface->v_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.v_isolines [BS] %hu != %hu", loftedsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == loftedsurface->v_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.v_isolines [BS] set+1 %hu != %hu", loftedsurface->v_isolines, v_isolines);
    loftedsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "version", &version, NULL)
        && version == loftedsurface->version)
      pass ();
    else
      fail ("LOFTEDSURFACE.version [BS] %hu != %hu", loftedsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "version", &version, 0)
        && version == loftedsurface->version)
      pass ();
    else
      fail ("LOFTEDSURFACE.version [BS] set+1 %hu != %hu", loftedsurface->version, version);
    loftedsurface->version--;
  }
  {
    BITCODE_B virtual_guide;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide, NULL)
        && virtual_guide == loftedsurface->virtual_guide)
      pass ();
    else
      fail ("LOFTEDSURFACE.virtual_guide [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide);
    virtual_guide++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide, 0)
        && virtual_guide == loftedsurface->virtual_guide)
      pass ();
    else
      fail ("LOFTEDSURFACE.virtual_guide [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide);
    loftedsurface->virtual_guide--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == loftedsurface->wireframe_data_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == loftedsurface->wireframe_data_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->wireframe_data_present, wireframe_data_present);
    loftedsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "wires", &wires, NULL)
        && wires == loftedsurface->wires)
      pass ();
    else
      fail ("LOFTEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("LOFTEDSURFACE") || is_class_debugging ("LOFTEDSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LOFTEDSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_LWPOLYLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LWPOLYLINE *restrict lwpolyline = obj->tio.entity->tio.LWPOLYLINE;
  failed = 0;
  {
    BITCODE_BD* bulges;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_bulges", &count, NULL)
        && dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "bulges", &bulges, NULL)
        && bulges == lwpolyline->bulges)
      pass ();
    else
      fail ("LWPOLYLINE.bulges [BD*] * %u num_bulges", count);
  }
  {
    BITCODE_BD const_width;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "const_width", &const_width, NULL)
        && const_width == lwpolyline->const_width)
      pass ();
    else
      fail ("LWPOLYLINE.const_width [BD] %g != %g", lwpolyline->const_width, const_width);
    const_width++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "const_width", &const_width, 0)
        && const_width == lwpolyline->const_width)
      pass ();
    else
      fail ("LWPOLYLINE.const_width [BD] set+1 %g != %g", lwpolyline->const_width, const_width);
    lwpolyline->const_width--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "elevation", &elevation, NULL)
        && elevation == lwpolyline->elevation)
      pass ();
    else
      fail ("LWPOLYLINE.elevation [BD] %g != %g", lwpolyline->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "elevation", &elevation, 0)
        && elevation == lwpolyline->elevation)
      pass ();
    else
      fail ("LWPOLYLINE.elevation [BD] set+1 %g != %g", lwpolyline->elevation, elevation);
    lwpolyline->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &lwpolyline->extrusion, sizeof (lwpolyline->extrusion)))
        pass ();
    else
        fail ("LWPOLYLINE.extrusion [BE]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "flag", &flag, NULL)
        && flag == lwpolyline->flag)
      pass ();
    else
      fail ("LWPOLYLINE.flag [BS] %hu != %hu", lwpolyline->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "flag", &flag, 0)
        && flag == lwpolyline->flag)
      pass ();
    else
      fail ("LWPOLYLINE.flag [BS] set+1 %hu != %hu", lwpolyline->flag, flag);
    lwpolyline->flag--;
  }
  {
    BITCODE_BL num_bulges;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_bulges", &num_bulges, NULL)
        && num_bulges == lwpolyline->num_bulges)
      pass ();
    else
      fail ("LWPOLYLINE.num_bulges [BL] %u != %u", lwpolyline->num_bulges, num_bulges);
    num_bulges++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "num_bulges", &num_bulges, 0)
        && num_bulges == lwpolyline->num_bulges)
      pass ();
    else
      fail ("LWPOLYLINE.num_bulges [BL] set+1 %u != %u", lwpolyline->num_bulges, num_bulges);
    lwpolyline->num_bulges--;
  }
  {
    BITCODE_BL num_points;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_points", &num_points, NULL)
        && num_points == lwpolyline->num_points)
      pass ();
    else
      fail ("LWPOLYLINE.num_points [BL] %u != %u", lwpolyline->num_points, num_points);
    num_points++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "num_points", &num_points, 0)
        && num_points == lwpolyline->num_points)
      pass ();
    else
      fail ("LWPOLYLINE.num_points [BL] set+1 %u != %u", lwpolyline->num_points, num_points);
    lwpolyline->num_points--;
  }
  {
    BITCODE_BL num_vertexids;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_vertexids", &num_vertexids, NULL)
        && num_vertexids == lwpolyline->num_vertexids)
      pass ();
    else
      fail ("LWPOLYLINE.num_vertexids [BL] %u != %u", lwpolyline->num_vertexids, num_vertexids);
    num_vertexids++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "num_vertexids", &num_vertexids, 0)
        && num_vertexids == lwpolyline->num_vertexids)
      pass ();
    else
      fail ("LWPOLYLINE.num_vertexids [BL] set+1 %u != %u", lwpolyline->num_vertexids, num_vertexids);
    lwpolyline->num_vertexids--;
  }
  {
    BITCODE_BL num_widths;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_widths", &num_widths, NULL)
        && num_widths == lwpolyline->num_widths)
      pass ();
    else
      fail ("LWPOLYLINE.num_widths [BL] %u != %u", lwpolyline->num_widths, num_widths);
    num_widths++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "num_widths", &num_widths, 0)
        && num_widths == lwpolyline->num_widths)
      pass ();
    else
      fail ("LWPOLYLINE.num_widths [BL] set+1 %u != %u", lwpolyline->num_widths, num_widths);
    lwpolyline->num_widths--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "parent", &parent, NULL)
        && !memcmp (&parent, &lwpolyline->parent, sizeof (lwpolyline->parent)))
        pass ();
    else
        fail ("LWPOLYLINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD* points;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_points", &count, NULL)
        && dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "points", &points, NULL)
        && points == lwpolyline->points)
      pass ();
    else
      fail ("LWPOLYLINE.points [2RD*] * %u num_points", count);
  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "thickness", &thickness, NULL)
        && thickness == lwpolyline->thickness)
      pass ();
    else
      fail ("LWPOLYLINE.thickness [BD] %g != %g", lwpolyline->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "thickness", &thickness, 0)
        && thickness == lwpolyline->thickness)
      pass ();
    else
      fail ("LWPOLYLINE.thickness [BD] set+1 %g != %g", lwpolyline->thickness, thickness);
    lwpolyline->thickness--;
  }
  {
    BITCODE_BL* vertexids;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_vertexids", &count, NULL)
        && dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "vertexids", &vertexids, NULL)
        && vertexids == lwpolyline->vertexids)
      pass ();
    else
      fail ("LWPOLYLINE.vertexids [BL*] * %u num_vertexids", count);
  }
  {
    Dwg_LWPOLYLINE_width* widths;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_widths", &count, NULL)
        && dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "widths", &widths, NULL)
        && widths == lwpolyline->widths)
      pass ();
    else
      fail ("LWPOLYLINE.widths [Dwg_LWPOLYLINE_width*] * %u num_widths", count);
  }
  if (failed && (is_class_unstable ("LWPOLYLINE") || is_class_debugging ("LWPOLYLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LWPOLYLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_MESH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MESH *restrict mesh = obj->tio.entity->tio.MESH;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (mesh, "MESH", "class_version", &class_version, NULL)
        && class_version == mesh->class_version)
      pass ();
    else
      fail ("MESH.class_version [BL] %u != %u", mesh->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "class_version", &class_version, 0)
        && class_version == mesh->class_version)
      pass ();
    else
      fail ("MESH.class_version [BL] set+1 %u != %u", mesh->class_version, class_version);
    mesh->class_version--;
  }
  {
    BITCODE_BD* crease;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_crease", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "crease", &crease, NULL)
        && crease == mesh->crease)
      pass ();
    else
      fail ("MESH.crease [BD*] * %u num_crease", count);
  }
  {
    BITCODE_RC dlevel;
    if (dwg_dynapi_entity_value (mesh, "MESH", "dlevel", &dlevel, NULL)
        && dlevel == mesh->dlevel)
      pass ();
    else
      fail ("MESH.dlevel [RC] %u != %u", mesh->dlevel, dlevel);
    dlevel++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "dlevel", &dlevel, 0)
        && dlevel == mesh->dlevel)
      pass ();
    else
      fail ("MESH.dlevel [RC] set+1 %u != %u", mesh->dlevel, dlevel);
    mesh->dlevel--;
  }
  {
    Dwg_MESH_edge* edges;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_edges", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "edges", &edges, NULL)
        && edges == mesh->edges)
      pass ();
    else
      fail ("MESH.edges [Dwg_MESH_edge*] * %u num_edges", count);
  }
  {
    BITCODE_BL* faces;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_faces", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "faces", &faces, NULL)
        && faces == mesh->faces)
      pass ();
    else
      fail ("MESH.faces [BL*] * %u num_faces", count);
  }
  {
    BITCODE_RC is_watertight;
    if (dwg_dynapi_entity_value (mesh, "MESH", "is_watertight", &is_watertight, NULL)
        && is_watertight == mesh->is_watertight)
      pass ();
    else
      fail ("MESH.is_watertight [RC] %u != %u", mesh->is_watertight, is_watertight);
    is_watertight++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "is_watertight", &is_watertight, 0)
        && is_watertight == mesh->is_watertight)
      pass ();
    else
      fail ("MESH.is_watertight [RC] set+1 %u != %u", mesh->is_watertight, is_watertight);
    mesh->is_watertight--;
  }
  {
    BITCODE_BL num_crease;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_crease", &num_crease, NULL)
        && num_crease == mesh->num_crease)
      pass ();
    else
      fail ("MESH.num_crease [BL] %u != %u", mesh->num_crease, num_crease);
    num_crease++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_crease", &num_crease, 0)
        && num_crease == mesh->num_crease)
      pass ();
    else
      fail ("MESH.num_crease [BL] set+1 %u != %u", mesh->num_crease, num_crease);
    mesh->num_crease--;
  }
  {
    BITCODE_BL num_edges;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_edges", &num_edges, NULL)
        && num_edges == mesh->num_edges)
      pass ();
    else
      fail ("MESH.num_edges [BL] %u != %u", mesh->num_edges, num_edges);
    num_edges++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_edges", &num_edges, 0)
        && num_edges == mesh->num_edges)
      pass ();
    else
      fail ("MESH.num_edges [BL] set+1 %u != %u", mesh->num_edges, num_edges);
    mesh->num_edges--;
  }
  {
    BITCODE_BL num_faces;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_faces", &num_faces, NULL)
        && num_faces == mesh->num_faces)
      pass ();
    else
      fail ("MESH.num_faces [BL] %u != %u", mesh->num_faces, num_faces);
    num_faces++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_faces", &num_faces, 0)
        && num_faces == mesh->num_faces)
      pass ();
    else
      fail ("MESH.num_faces [BL] set+1 %u != %u", mesh->num_faces, num_faces);
    mesh->num_faces--;
  }
  {
    BITCODE_BL num_subdiv_vertex;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_subdiv_vertex", &num_subdiv_vertex, NULL)
        && num_subdiv_vertex == mesh->num_subdiv_vertex)
      pass ();
    else
      fail ("MESH.num_subdiv_vertex [BL] %u != %u", mesh->num_subdiv_vertex, num_subdiv_vertex);
    num_subdiv_vertex++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_subdiv_vertex", &num_subdiv_vertex, 0)
        && num_subdiv_vertex == mesh->num_subdiv_vertex)
      pass ();
    else
      fail ("MESH.num_subdiv_vertex [BL] set+1 %u != %u", mesh->num_subdiv_vertex, num_subdiv_vertex);
    mesh->num_subdiv_vertex--;
  }
  {
    BITCODE_BL num_vertex;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_vertex", &num_vertex, NULL)
        && num_vertex == mesh->num_vertex)
      pass ();
    else
      fail ("MESH.num_vertex [BL] %u != %u", mesh->num_vertex, num_vertex);
    num_vertex++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_vertex", &num_vertex, 0)
        && num_vertex == mesh->num_vertex)
      pass ();
    else
      fail ("MESH.num_vertex [BL] set+1 %u != %u", mesh->num_vertex, num_vertex);
    mesh->num_vertex--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (mesh, "MESH", "parent", &parent, NULL)
        && !memcmp (&parent, &mesh->parent, sizeof (mesh->parent)))
        pass ();
    else
        fail ("MESH.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD* subdiv_vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_subdiv_vertex", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "subdiv_vertex", &subdiv_vertex, NULL)
        && subdiv_vertex == mesh->subdiv_vertex)
      pass ();
    else
      fail ("MESH.subdiv_vertex [3BD*] * %u num_subdiv_vertex", count);
  }
  {
    BITCODE_3BD* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "vertex", &vertex, NULL)
        && vertex == mesh->vertex)
      pass ();
    else
      fail ("MESH.vertex [3BD*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("MESH") || is_class_debugging ("MESH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MESH", failed);
      failed = 0;
    }
  return failed;
}
static int test_MINSERT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MINSERT *restrict minsert = obj->tio.entity->tio.MINSERT;
  failed = 0;
  {
    BITCODE_H* attrib_handles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (minsert, "MINSERT", "attrib_handles", &attrib_handles, NULL)
        && attrib_handles == minsert->attrib_handles)
      pass ();
    else
      fail ("MINSERT.attrib_handles [H*] * %u num_owned", count);
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "block_header", &block_header, NULL)
        && !memcmp (&block_header, &minsert->block_header, sizeof (minsert->block_header)))
        pass ();
    else
        fail ("MINSERT.block_header [H]");
  }
  {
    BITCODE_BD col_spacing;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "col_spacing", &col_spacing, NULL)
        && col_spacing == minsert->col_spacing)
      pass ();
    else
      fail ("MINSERT.col_spacing [BD] %g != %g", minsert->col_spacing, col_spacing);
    col_spacing++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "col_spacing", &col_spacing, 0)
        && col_spacing == minsert->col_spacing)
      pass ();
    else
      fail ("MINSERT.col_spacing [BD] set+1 %g != %g", minsert->col_spacing, col_spacing);
    minsert->col_spacing--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &minsert->extrusion, sizeof (minsert->extrusion)))
        pass ();
    else
        fail ("MINSERT.extrusion [BE]");
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "first_attrib", &first_attrib, NULL)
        && !memcmp (&first_attrib, &minsert->first_attrib, sizeof (minsert->first_attrib)))
        pass ();
    else
        fail ("MINSERT.first_attrib [H]");
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "has_attribs", &has_attribs, NULL)
        && has_attribs == minsert->has_attribs)
      pass ();
    else
      fail ("MINSERT.has_attribs [B] " FORMAT_B " != " FORMAT_B "", minsert->has_attribs, has_attribs);
    has_attribs++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "has_attribs", &has_attribs, 0)
        && has_attribs == minsert->has_attribs)
      pass ();
    else
      fail ("MINSERT.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", minsert->has_attribs, has_attribs);
    minsert->has_attribs--;
  }
  {
    BITCODE_3DPOINT ins_pt;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &minsert->ins_pt, sizeof (minsert->ins_pt)))
        pass ();
    else
        fail ("MINSERT.ins_pt [3DPOINT]");
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "last_attrib", &last_attrib, NULL)
        && !memcmp (&last_attrib, &minsert->last_attrib, sizeof (minsert->last_attrib)))
        pass ();
    else
        fail ("MINSERT.last_attrib [H]");
  }
  {
    BITCODE_BS num_cols;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "num_cols", &num_cols, NULL)
        && num_cols == minsert->num_cols)
      pass ();
    else
      fail ("MINSERT.num_cols [BS] %hu != %hu", minsert->num_cols, num_cols);
    num_cols++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "num_cols", &num_cols, 0)
        && num_cols == minsert->num_cols)
      pass ();
    else
      fail ("MINSERT.num_cols [BS] set+1 %hu != %hu", minsert->num_cols, num_cols);
    minsert->num_cols--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "num_owned", &num_owned, NULL)
        && num_owned == minsert->num_owned)
      pass ();
    else
      fail ("MINSERT.num_owned [BL] %u != %u", minsert->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "num_owned", &num_owned, 0)
        && num_owned == minsert->num_owned)
      pass ();
    else
      fail ("MINSERT.num_owned [BL] set+1 %u != %u", minsert->num_owned, num_owned);
    minsert->num_owned--;
  }
  {
    BITCODE_BS num_rows;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "num_rows", &num_rows, NULL)
        && num_rows == minsert->num_rows)
      pass ();
    else
      fail ("MINSERT.num_rows [BS] %hu != %hu", minsert->num_rows, num_rows);
    num_rows++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "num_rows", &num_rows, 0)
        && num_rows == minsert->num_rows)
      pass ();
    else
      fail ("MINSERT.num_rows [BS] set+1 %hu != %hu", minsert->num_rows, num_rows);
    minsert->num_rows--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "parent", &parent, NULL)
        && !memcmp (&parent, &minsert->parent, sizeof (minsert->parent)))
        pass ();
    else
        fail ("MINSERT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "rotation", &rotation, NULL)
        && rotation == minsert->rotation)
      pass ();
    else
      fail ("MINSERT.rotation [BD] %g != %g", minsert->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "rotation", &rotation, 0)
        && rotation == minsert->rotation)
      pass ();
    else
      fail ("MINSERT.rotation [BD] set+1 %g != %g", minsert->rotation, rotation);
    minsert->rotation--;
  }
  {
    BITCODE_BD row_spacing;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "row_spacing", &row_spacing, NULL)
        && row_spacing == minsert->row_spacing)
      pass ();
    else
      fail ("MINSERT.row_spacing [BD] %g != %g", minsert->row_spacing, row_spacing);
    row_spacing++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "row_spacing", &row_spacing, 0)
        && row_spacing == minsert->row_spacing)
      pass ();
    else
      fail ("MINSERT.row_spacing [BD] set+1 %g != %g", minsert->row_spacing, row_spacing);
    minsert->row_spacing--;
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "scale", &scale, NULL)
        && !memcmp (&scale, &minsert->scale, sizeof (minsert->scale)))
        pass ();
    else
        fail ("MINSERT.scale [3BD_1]");
  }
  {
    BITCODE_BB scale_flag;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "scale_flag", &scale_flag, NULL)
        && scale_flag == minsert->scale_flag)
      pass ();
    else
      fail ("MINSERT.scale_flag [BB] " FORMAT_BB " != " FORMAT_BB "", minsert->scale_flag, scale_flag);
    scale_flag++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "scale_flag", &scale_flag, 0)
        && scale_flag == minsert->scale_flag)
      pass ();
    else
      fail ("MINSERT.scale_flag [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", minsert->scale_flag, scale_flag);
    minsert->scale_flag--;
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &minsert->seqend, sizeof (minsert->seqend)))
        pass ();
    else
        fail ("MINSERT.seqend [H]");
  }
  if (failed && (is_class_unstable ("MINSERT") || is_class_debugging ("MINSERT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MINSERT", failed);
      failed = 0;
    }
  return failed;
}
static int test_MLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MLINE *restrict mline = obj->tio.entity->tio.MLINE;
  failed = 0;
  {
    BITCODE_3BD base_point;
    if (dwg_dynapi_entity_value (mline, "MLINE", "base_point", &base_point, NULL)
        && !memcmp (&base_point, &mline->base_point, sizeof (mline->base_point)))
        pass ();
    else
        fail ("MLINE.base_point [3BD]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (mline, "MLINE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &mline->extrusion, sizeof (mline->extrusion)))
        pass ();
    else
        fail ("MLINE.extrusion [BE]");
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value (mline, "MLINE", "flags", &flags, NULL)
        && flags == mline->flags)
      pass ();
    else
      fail ("MLINE.flags [BS] %hu != %hu", mline->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "flags", &flags, 0)
        && flags == mline->flags)
      pass ();
    else
      fail ("MLINE.flags [BS] set+1 %hu != %hu", mline->flags, flags);
    mline->flags--;
  }
  {
    BITCODE_RC justification;
    if (dwg_dynapi_entity_value (mline, "MLINE", "justification", &justification, NULL)
        && justification == mline->justification)
      pass ();
    else
      fail ("MLINE.justification [RC] %u != %u", mline->justification, justification);
    justification++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "justification", &justification, 0)
        && justification == mline->justification)
      pass ();
    else
      fail ("MLINE.justification [RC] set+1 %u != %u", mline->justification, justification);
    mline->justification--;
  }
  {
    BITCODE_H mlinestyle;
    if (dwg_dynapi_entity_value (mline, "MLINE", "mlinestyle", &mlinestyle, NULL)
        && !memcmp (&mlinestyle, &mline->mlinestyle, sizeof (mline->mlinestyle)))
        pass ();
    else
        fail ("MLINE.mlinestyle [H]");
  }
  {
    BITCODE_RC num_lines;
    if (dwg_dynapi_entity_value (mline, "MLINE", "num_lines", &num_lines, NULL)
        && num_lines == mline->num_lines)
      pass ();
    else
      fail ("MLINE.num_lines [RC] %u != %u", mline->num_lines, num_lines);
    num_lines++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "num_lines", &num_lines, 0)
        && num_lines == mline->num_lines)
      pass ();
    else
      fail ("MLINE.num_lines [RC] set+1 %u != %u", mline->num_lines, num_lines);
    mline->num_lines--;
  }
  {
    BITCODE_BS num_verts;
    if (dwg_dynapi_entity_value (mline, "MLINE", "num_verts", &num_verts, NULL)
        && num_verts == mline->num_verts)
      pass ();
    else
      fail ("MLINE.num_verts [BS] %hu != %hu", mline->num_verts, num_verts);
    num_verts++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "num_verts", &num_verts, 0)
        && num_verts == mline->num_verts)
      pass ();
    else
      fail ("MLINE.num_verts [BS] set+1 %hu != %hu", mline->num_verts, num_verts);
    mline->num_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (mline, "MLINE", "parent", &parent, NULL)
        && !memcmp (&parent, &mline->parent, sizeof (mline->parent)))
        pass ();
    else
        fail ("MLINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value (mline, "MLINE", "scale", &scale, NULL)
        && scale == mline->scale)
      pass ();
    else
      fail ("MLINE.scale [BD] %g != %g", mline->scale, scale);
    scale++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "scale", &scale, 0)
        && scale == mline->scale)
      pass ();
    else
      fail ("MLINE.scale [BD] set+1 %g != %g", mline->scale, scale);
    mline->scale--;
  }
  {
    Dwg_MLINE_vertex* verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mline, "MLINE", "num_verts", &count, NULL)
        && dwg_dynapi_entity_value (mline, "MLINE", "verts", &verts, NULL)
        && verts == mline->verts)
      pass ();
    else
      fail ("MLINE.verts [Dwg_MLINE_vertex*] * %u num_verts", count);
  }
  if (failed && (is_class_unstable ("MLINE") || is_class_debugging ("MLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_MTEXT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MTEXT *restrict mtext = obj->tio.entity->tio.MTEXT;
  failed = 0;
  {
    BITCODE_B annotative;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "annotative", &annotative, NULL)
        && annotative == mtext->annotative)
      pass ();
    else
      fail ("MTEXT.annotative [B] " FORMAT_B " != " FORMAT_B "", mtext->annotative, annotative);
    annotative++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "annotative", &annotative, 0)
        && annotative == mtext->annotative)
      pass ();
    else
      fail ("MTEXT.annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->annotative, annotative);
    mtext->annotative--;
  }
  {
    BITCODE_H appid;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "appid", &appid, NULL)
        && !memcmp (&appid, &mtext->appid, sizeof (mtext->appid)))
        pass ();
    else
        fail ("MTEXT.appid [H]");
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "attachment", &attachment, NULL)
        && attachment == mtext->attachment)
      pass ();
    else
      fail ("MTEXT.attachment [BS] %hu != %hu", mtext->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "attachment", &attachment, 0)
        && attachment == mtext->attachment)
      pass ();
    else
      fail ("MTEXT.attachment [BS] set+1 %hu != %hu", mtext->attachment, attachment);
    mtext->attachment--;
  }
  {
    BITCODE_B auto_height;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "auto_height", &auto_height, NULL)
        && auto_height == mtext->auto_height)
      pass ();
    else
      fail ("MTEXT.auto_height [B] " FORMAT_B " != " FORMAT_B "", mtext->auto_height, auto_height);
    auto_height++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "auto_height", &auto_height, 0)
        && auto_height == mtext->auto_height)
      pass ();
    else
      fail ("MTEXT.auto_height [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->auto_height, auto_height);
    mtext->auto_height--;
  }
  {
    BITCODE_CMC bg_fill_color;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "bg_fill_color", &bg_fill_color, NULL)
        && !memcmp (&bg_fill_color, &mtext->bg_fill_color, sizeof (mtext->bg_fill_color)))
        pass ();
    else
        fail ("MTEXT.bg_fill_color [CMC]");
  }
  {
    BITCODE_BL bg_fill_flag;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "bg_fill_flag", &bg_fill_flag, NULL)
        && bg_fill_flag == mtext->bg_fill_flag)
      pass ();
    else
      fail ("MTEXT.bg_fill_flag [BL] %u != %u", mtext->bg_fill_flag, bg_fill_flag);
    bg_fill_flag++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "bg_fill_flag", &bg_fill_flag, 0)
        && bg_fill_flag == mtext->bg_fill_flag)
      pass ();
    else
      fail ("MTEXT.bg_fill_flag [BL] set+1 %u != %u", mtext->bg_fill_flag, bg_fill_flag);
    mtext->bg_fill_flag--;
  }
  {
    BITCODE_BL bg_fill_scale;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "bg_fill_scale", &bg_fill_scale, NULL)
        && bg_fill_scale == mtext->bg_fill_scale)
      pass ();
    else
      fail ("MTEXT.bg_fill_scale [BL] %u != %u", mtext->bg_fill_scale, bg_fill_scale);
    bg_fill_scale++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "bg_fill_scale", &bg_fill_scale, 0)
        && bg_fill_scale == mtext->bg_fill_scale)
      pass ();
    else
      fail ("MTEXT.bg_fill_scale [BL] set+1 %u != %u", mtext->bg_fill_scale, bg_fill_scale);
    mtext->bg_fill_scale--;
  }
  {
    BITCODE_BL bg_fill_trans;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "bg_fill_trans", &bg_fill_trans, NULL)
        && bg_fill_trans == mtext->bg_fill_trans)
      pass ();
    else
      fail ("MTEXT.bg_fill_trans [BL] %u != %u", mtext->bg_fill_trans, bg_fill_trans);
    bg_fill_trans++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "bg_fill_trans", &bg_fill_trans, 0)
        && bg_fill_trans == mtext->bg_fill_trans)
      pass ();
    else
      fail ("MTEXT.bg_fill_trans [BL] set+1 %u != %u", mtext->bg_fill_trans, bg_fill_trans);
    mtext->bg_fill_trans--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "class_version", &class_version, NULL)
        && class_version == mtext->class_version)
      pass ();
    else
      fail ("MTEXT.class_version [BS] %hu != %hu", mtext->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "class_version", &class_version, 0)
        && class_version == mtext->class_version)
      pass ();
    else
      fail ("MTEXT.class_version [BS] set+1 %hu != %hu", mtext->class_version, class_version);
    mtext->class_version--;
  }
  {
    BITCODE_BD* column_heights;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "num_column_heights", &count, NULL)
        && dwg_dynapi_entity_value (mtext, "MTEXT", "column_heights", &column_heights, NULL)
        && column_heights == mtext->column_heights)
      pass ();
    else
      fail ("MTEXT.column_heights [BD*] * %u num_column_heights", count);
  }
  {
    BITCODE_BL column_type;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "column_type", &column_type, NULL)
        && column_type == mtext->column_type)
      pass ();
    else
      fail ("MTEXT.column_type [BL] %u != %u", mtext->column_type, column_type);
    column_type++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "column_type", &column_type, 0)
        && column_type == mtext->column_type)
      pass ();
    else
      fail ("MTEXT.column_type [BL] set+1 %u != %u", mtext->column_type, column_type);
    mtext->column_type--;
  }
  {
    BITCODE_BD column_width;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "column_width", &column_width, NULL)
        && column_width == mtext->column_width)
      pass ();
    else
      fail ("MTEXT.column_width [BD] %g != %g", mtext->column_width, column_width);
    column_width++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "column_width", &column_width, 0)
        && column_width == mtext->column_width)
      pass ();
    else
      fail ("MTEXT.column_width [BD] set+1 %g != %g", mtext->column_width, column_width);
    mtext->column_width--;
  }
  {
    BITCODE_B default_flag;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "default_flag", &default_flag, NULL)
        && default_flag == mtext->default_flag)
      pass ();
    else
      fail ("MTEXT.default_flag [B] " FORMAT_B " != " FORMAT_B "", mtext->default_flag, default_flag);
    default_flag++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "default_flag", &default_flag, 0)
        && default_flag == mtext->default_flag)
      pass ();
    else
      fail ("MTEXT.default_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->default_flag, default_flag);
    mtext->default_flag--;
  }
  {
    BITCODE_BS drawing_dir;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "drawing_dir", &drawing_dir, NULL)
        && drawing_dir == mtext->drawing_dir)
      pass ();
    else
      fail ("MTEXT.drawing_dir [BS] %hu != %hu", mtext->drawing_dir, drawing_dir);
    drawing_dir++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "drawing_dir", &drawing_dir, 0)
        && drawing_dir == mtext->drawing_dir)
      pass ();
    else
      fail ("MTEXT.drawing_dir [BS] set+1 %hu != %hu", mtext->drawing_dir, drawing_dir);
    mtext->drawing_dir--;
  }
  {
    BITCODE_BD extents_height;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "extents_height", &extents_height, NULL)
        && extents_height == mtext->extents_height)
      pass ();
    else
      fail ("MTEXT.extents_height [BD] %g != %g", mtext->extents_height, extents_height);
    extents_height++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "extents_height", &extents_height, 0)
        && extents_height == mtext->extents_height)
      pass ();
    else
      fail ("MTEXT.extents_height [BD] set+1 %g != %g", mtext->extents_height, extents_height);
    mtext->extents_height--;
  }
  {
    BITCODE_BD extents_width;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "extents_width", &extents_width, NULL)
        && extents_width == mtext->extents_width)
      pass ();
    else
      fail ("MTEXT.extents_width [BD] %g != %g", mtext->extents_width, extents_width);
    extents_width++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "extents_width", &extents_width, 0)
        && extents_width == mtext->extents_width)
      pass ();
    else
      fail ("MTEXT.extents_width [BD] set+1 %g != %g", mtext->extents_width, extents_width);
    mtext->extents_width--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &mtext->extrusion, sizeof (mtext->extrusion)))
        pass ();
    else
        fail ("MTEXT.extrusion [BE]");
  }
  {
    BITCODE_B flow_reversed;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "flow_reversed", &flow_reversed, NULL)
        && flow_reversed == mtext->flow_reversed)
      pass ();
    else
      fail ("MTEXT.flow_reversed [B] " FORMAT_B " != " FORMAT_B "", mtext->flow_reversed, flow_reversed);
    flow_reversed++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "flow_reversed", &flow_reversed, 0)
        && flow_reversed == mtext->flow_reversed)
      pass ();
    else
      fail ("MTEXT.flow_reversed [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->flow_reversed, flow_reversed);
    mtext->flow_reversed--;
  }
  {
    BITCODE_BD gutter;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "gutter", &gutter, NULL)
        && gutter == mtext->gutter)
      pass ();
    else
      fail ("MTEXT.gutter [BD] %g != %g", mtext->gutter, gutter);
    gutter++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "gutter", &gutter, 0)
        && gutter == mtext->gutter)
      pass ();
    else
      fail ("MTEXT.gutter [BD] set+1 %g != %g", mtext->gutter, gutter);
    mtext->gutter--;
  }
  {
    BITCODE_3BD insertion_pt;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "insertion_pt", &insertion_pt, NULL)
        && !memcmp (&insertion_pt, &mtext->insertion_pt, sizeof (mtext->insertion_pt)))
        pass ();
    else
        fail ("MTEXT.insertion_pt [3BD]");
  }
  {
    BITCODE_BD linespace_factor;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "linespace_factor", &linespace_factor, NULL)
        && linespace_factor == mtext->linespace_factor)
      pass ();
    else
      fail ("MTEXT.linespace_factor [BD] %g != %g", mtext->linespace_factor, linespace_factor);
    linespace_factor++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "linespace_factor", &linespace_factor, 0)
        && linespace_factor == mtext->linespace_factor)
      pass ();
    else
      fail ("MTEXT.linespace_factor [BD] set+1 %g != %g", mtext->linespace_factor, linespace_factor);
    mtext->linespace_factor--;
  }
  {
    BITCODE_BS linespace_style;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "linespace_style", &linespace_style, NULL)
        && linespace_style == mtext->linespace_style)
      pass ();
    else
      fail ("MTEXT.linespace_style [BS] %hu != %hu", mtext->linespace_style, linespace_style);
    linespace_style++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "linespace_style", &linespace_style, 0)
        && linespace_style == mtext->linespace_style)
      pass ();
    else
      fail ("MTEXT.linespace_style [BS] set+1 %hu != %hu", mtext->linespace_style, linespace_style);
    mtext->linespace_style--;
  }
  {
    BITCODE_BL num_column_heights;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "num_column_heights", &num_column_heights, NULL)
        && num_column_heights == mtext->num_column_heights)
      pass ();
    else
      fail ("MTEXT.num_column_heights [BL] %u != %u", mtext->num_column_heights, num_column_heights);
    num_column_heights++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "num_column_heights", &num_column_heights, 0)
        && num_column_heights == mtext->num_column_heights)
      pass ();
    else
      fail ("MTEXT.num_column_heights [BL] set+1 %u != %u", mtext->num_column_heights, num_column_heights);
    mtext->num_column_heights--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "parent", &parent, NULL)
        && !memcmp (&parent, &mtext->parent, sizeof (mtext->parent)))
        pass ();
    else
        fail ("MTEXT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rect_height;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "rect_height", &rect_height, NULL)
        && rect_height == mtext->rect_height)
      pass ();
    else
      fail ("MTEXT.rect_height [BD] %g != %g", mtext->rect_height, rect_height);
    rect_height++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "rect_height", &rect_height, 0)
        && rect_height == mtext->rect_height)
      pass ();
    else
      fail ("MTEXT.rect_height [BD] set+1 %g != %g", mtext->rect_height, rect_height);
    mtext->rect_height--;
  }
  {
    BITCODE_BD rect_width;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "rect_width", &rect_width, NULL)
        && rect_width == mtext->rect_width)
      pass ();
    else
      fail ("MTEXT.rect_width [BD] %g != %g", mtext->rect_width, rect_width);
    rect_width++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "rect_width", &rect_width, 0)
        && rect_width == mtext->rect_width)
      pass ();
    else
      fail ("MTEXT.rect_width [BD] set+1 %g != %g", mtext->rect_width, rect_width);
    mtext->rect_width--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "style", &style, NULL)
        && !memcmp (&style, &mtext->style, sizeof (mtext->style)))
        pass ();
    else
        fail ("MTEXT.style [H]");
  }
  {
    BITCODE_T text;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "text", &text, NULL)
        && text
           ? strEQ ((char *)text, (char *)mtext->text)
           : !mtext->text)
      pass ();
    else
      fail ("MTEXT.text [T] '%s' <> '%s'", text, mtext->text);
  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "text_height", &text_height, NULL)
        && text_height == mtext->text_height)
      pass ();
    else
      fail ("MTEXT.text_height [BD] %g != %g", mtext->text_height, text_height);
    text_height++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "text_height", &text_height, 0)
        && text_height == mtext->text_height)
      pass ();
    else
      fail ("MTEXT.text_height [BD] set+1 %g != %g", mtext->text_height, text_height);
    mtext->text_height--;
  }
  {
    BITCODE_B unknown_bit;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "unknown_bit", &unknown_bit, NULL)
        && unknown_bit == mtext->unknown_bit)
      pass ();
    else
      fail ("MTEXT.unknown_bit [B] " FORMAT_B " != " FORMAT_B "", mtext->unknown_bit, unknown_bit);
    unknown_bit++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "unknown_bit", &unknown_bit, 0)
        && unknown_bit == mtext->unknown_bit)
      pass ();
    else
      fail ("MTEXT.unknown_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->unknown_bit, unknown_bit);
    mtext->unknown_bit--;
  }
  {
    BITCODE_3BD x_axis_dir;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "x_axis_dir", &x_axis_dir, NULL)
        && !memcmp (&x_axis_dir, &mtext->x_axis_dir, sizeof (mtext->x_axis_dir)))
        pass ();
    else
        fail ("MTEXT.x_axis_dir [3BD]");
  }
  if (failed && (is_class_unstable ("MTEXT") || is_class_debugging ("MTEXT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MTEXT", failed);
      failed = 0;
    }
  return failed;
}
static int test_MULTILEADER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MULTILEADER *restrict multileader = obj->tio.entity->tio.MULTILEADER;
  failed = 0;
  {
    BITCODE_H arrow_handle;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "arrow_handle", &arrow_handle, NULL)
        && !memcmp (&arrow_handle, &multileader->arrow_handle, sizeof (multileader->arrow_handle)))
        pass ();
    else
        fail ("MULTILEADER.arrow_handle [H]");
  }
  {
    BITCODE_BD arrow_size;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "arrow_size", &arrow_size, NULL)
        && arrow_size == multileader->arrow_size)
      pass ();
    else
      fail ("MULTILEADER.arrow_size [BD] %g != %g", multileader->arrow_size, arrow_size);
    arrow_size++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "arrow_size", &arrow_size, 0)
        && arrow_size == multileader->arrow_size)
      pass ();
    else
      fail ("MULTILEADER.arrow_size [BD] set+1 %g != %g", multileader->arrow_size, arrow_size);
    multileader->arrow_size--;
  }
  {
    Dwg_LEADER_ArrowHead* arrowheads;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "num_arrowheads", &count, NULL)
        && dwg_dynapi_entity_value (multileader, "MULTILEADER", "arrowheads", &arrowheads, NULL)
        && arrowheads == multileader->arrowheads)
      pass ();
    else
      fail ("MULTILEADER.arrowheads [Dwg_LEADER_ArrowHead*] * %u num_arrowheads", count);
  }
  {
    BITCODE_BS attach_bottom;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "attach_bottom", &attach_bottom, NULL)
        && attach_bottom == multileader->attach_bottom)
      pass ();
    else
      fail ("MULTILEADER.attach_bottom [BS] %hu != %hu", multileader->attach_bottom, attach_bottom);
    attach_bottom++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "attach_bottom", &attach_bottom, 0)
        && attach_bottom == multileader->attach_bottom)
      pass ();
    else
      fail ("MULTILEADER.attach_bottom [BS] set+1 %hu != %hu", multileader->attach_bottom, attach_bottom);
    multileader->attach_bottom--;
  }
  {
    BITCODE_BS attach_dir;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "attach_dir", &attach_dir, NULL)
        && attach_dir == multileader->attach_dir)
      pass ();
    else
      fail ("MULTILEADER.attach_dir [BS] %hu != %hu", multileader->attach_dir, attach_dir);
    attach_dir++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "attach_dir", &attach_dir, 0)
        && attach_dir == multileader->attach_dir)
      pass ();
    else
      fail ("MULTILEADER.attach_dir [BS] set+1 %hu != %hu", multileader->attach_dir, attach_dir);
    multileader->attach_dir--;
  }
  {
    BITCODE_BS attach_top;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "attach_top", &attach_top, NULL)
        && attach_top == multileader->attach_top)
      pass ();
    else
      fail ("MULTILEADER.attach_top [BS] %hu != %hu", multileader->attach_top, attach_top);
    attach_top++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "attach_top", &attach_top, 0)
        && attach_top == multileader->attach_top)
      pass ();
    else
      fail ("MULTILEADER.attach_top [BS] set+1 %hu != %hu", multileader->attach_top, attach_top);
    multileader->attach_top--;
  }
  {
    BITCODE_BS attach_type;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "attach_type", &attach_type, NULL)
        && attach_type == multileader->attach_type)
      pass ();
    else
      fail ("MULTILEADER.attach_type [BS] %hu != %hu", multileader->attach_type, attach_type);
    attach_type++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "attach_type", &attach_type, 0)
        && attach_type == multileader->attach_type)
      pass ();
    else
      fail ("MULTILEADER.attach_type [BS] set+1 %hu != %hu", multileader->attach_type, attach_type);
    multileader->attach_type--;
  }
  {
    BITCODE_CMC block_color;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "block_color", &block_color, NULL)
        && !memcmp (&block_color, &multileader->block_color, sizeof (multileader->block_color)))
        pass ();
    else
        fail ("MULTILEADER.block_color [CMC]");
  }
  {
    BITCODE_BD block_rotation;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "block_rotation", &block_rotation, NULL)
        && block_rotation == multileader->block_rotation)
      pass ();
    else
      fail ("MULTILEADER.block_rotation [BD] %g != %g", multileader->block_rotation, block_rotation);
    block_rotation++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "block_rotation", &block_rotation, 0)
        && block_rotation == multileader->block_rotation)
      pass ();
    else
      fail ("MULTILEADER.block_rotation [BD] set+1 %g != %g", multileader->block_rotation, block_rotation);
    multileader->block_rotation--;
  }
  {
    BITCODE_3BD block_scale;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "block_scale", &block_scale, NULL)
        && !memcmp (&block_scale, &multileader->block_scale, sizeof (multileader->block_scale)))
        pass ();
    else
        fail ("MULTILEADER.block_scale [3BD]");
  }
  {
    BITCODE_H block_style;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "block_style", &block_style, NULL)
        && !memcmp (&block_style, &multileader->block_style, sizeof (multileader->block_style)))
        pass ();
    else
        fail ("MULTILEADER.block_style [H]");
  }
  {
    Dwg_LEADER_BlockLabel* blocklabels;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "num_blocklabels", &count, NULL)
        && dwg_dynapi_entity_value (multileader, "MULTILEADER", "blocklabels", &blocklabels, NULL)
        && blocklabels == multileader->blocklabels)
      pass ();
    else
      fail ("MULTILEADER.blocklabels [Dwg_LEADER_BlockLabel*] * %u num_blocklabels", count);
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "class_version", &class_version, NULL)
        && class_version == multileader->class_version)
      pass ();
    else
      fail ("MULTILEADER.class_version [BS] %hu != %hu", multileader->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "class_version", &class_version, 0)
        && class_version == multileader->class_version)
      pass ();
    else
      fail ("MULTILEADER.class_version [BS] set+1 %hu != %hu", multileader->class_version, class_version);
    multileader->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "color", &color, NULL)
        && !memcmp (&color, &multileader->color, sizeof (multileader->color)))
        pass ();
    else
        fail ("MULTILEADER.color [CMC]");
  }
  {
    Dwg_MLEADER_AnnotContext ctx;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "ctx", &ctx, NULL)
        && !memcmp (&ctx, &multileader->ctx, sizeof (multileader->ctx)))
        pass ();
    else
        fail ("MULTILEADER.ctx [Dwg_MLEADER_AnnotContext]");
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "flags", &flags, NULL)
        && flags == multileader->flags)
      pass ();
    else
      fail ("MULTILEADER.flags [BL] %u != %u", multileader->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "flags", &flags, 0)
        && flags == multileader->flags)
      pass ();
    else
      fail ("MULTILEADER.flags [BL] set+1 %u != %u", multileader->flags, flags);
    multileader->flags--;
  }
  {
    BITCODE_B has_dogleg;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "has_dogleg", &has_dogleg, NULL)
        && has_dogleg == multileader->has_dogleg)
      pass ();
    else
      fail ("MULTILEADER.has_dogleg [B] " FORMAT_B " != " FORMAT_B "", multileader->has_dogleg, has_dogleg);
    has_dogleg++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "has_dogleg", &has_dogleg, 0)
        && has_dogleg == multileader->has_dogleg)
      pass ();
    else
      fail ("MULTILEADER.has_dogleg [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_dogleg, has_dogleg);
    multileader->has_dogleg--;
  }
  {
    BITCODE_B has_landing;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "has_landing", &has_landing, NULL)
        && has_landing == multileader->has_landing)
      pass ();
    else
      fail ("MULTILEADER.has_landing [B] " FORMAT_B " != " FORMAT_B "", multileader->has_landing, has_landing);
    has_landing++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "has_landing", &has_landing, 0)
        && has_landing == multileader->has_landing)
      pass ();
    else
      fail ("MULTILEADER.has_landing [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_landing, has_landing);
    multileader->has_landing--;
  }
  {
    BITCODE_B has_text_frame;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "has_text_frame", &has_text_frame, NULL)
        && has_text_frame == multileader->has_text_frame)
      pass ();
    else
      fail ("MULTILEADER.has_text_frame [B] " FORMAT_B " != " FORMAT_B "", multileader->has_text_frame, has_text_frame);
    has_text_frame++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "has_text_frame", &has_text_frame, 0)
        && has_text_frame == multileader->has_text_frame)
      pass ();
    else
      fail ("MULTILEADER.has_text_frame [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_text_frame, has_text_frame);
    multileader->has_text_frame--;
  }
  {
    BITCODE_BS ipe_alignment;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "ipe_alignment", &ipe_alignment, NULL)
        && ipe_alignment == multileader->ipe_alignment)
      pass ();
    else
      fail ("MULTILEADER.ipe_alignment [BS] %hu != %hu", multileader->ipe_alignment, ipe_alignment);
    ipe_alignment++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "ipe_alignment", &ipe_alignment, 0)
        && ipe_alignment == multileader->ipe_alignment)
      pass ();
    else
      fail ("MULTILEADER.ipe_alignment [BS] set+1 %hu != %hu", multileader->ipe_alignment, ipe_alignment);
    multileader->ipe_alignment--;
  }
  {
    BITCODE_B is_annotative;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "is_annotative", &is_annotative, NULL)
        && is_annotative == multileader->is_annotative)
      pass ();
    else
      fail ("MULTILEADER.is_annotative [B] " FORMAT_B " != " FORMAT_B "", multileader->is_annotative, is_annotative);
    is_annotative++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "is_annotative", &is_annotative, 0)
        && is_annotative == multileader->is_annotative)
      pass ();
    else
      fail ("MULTILEADER.is_annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->is_annotative, is_annotative);
    multileader->is_annotative--;
  }
  {
    BITCODE_BS justification;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "justification", &justification, NULL)
        && justification == multileader->justification)
      pass ();
    else
      fail ("MULTILEADER.justification [BS] %hu != %hu", multileader->justification, justification);
    justification++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "justification", &justification, 0)
        && justification == multileader->justification)
      pass ();
    else
      fail ("MULTILEADER.justification [BS] set+1 %hu != %hu", multileader->justification, justification);
    multileader->justification--;
  }
  {
    BITCODE_BD landing_dist;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "landing_dist", &landing_dist, NULL)
        && landing_dist == multileader->landing_dist)
      pass ();
    else
      fail ("MULTILEADER.landing_dist [BD] %g != %g", multileader->landing_dist, landing_dist);
    landing_dist++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "landing_dist", &landing_dist, 0)
        && landing_dist == multileader->landing_dist)
      pass ();
    else
      fail ("MULTILEADER.landing_dist [BD] set+1 %g != %g", multileader->landing_dist, landing_dist);
    multileader->landing_dist--;
  }
  {
    BITCODE_BLd linewt;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "linewt", &linewt, NULL)
        && linewt == multileader->linewt)
      pass ();
    else
      fail ("MULTILEADER.linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", multileader->linewt, linewt);
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "linewt", &linewt, 0)
        && linewt == multileader->linewt)
      pass ();
    else
      fail ("MULTILEADER.linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", multileader->linewt, linewt);
    multileader->linewt--;
  }
  {
    BITCODE_H ltype;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "ltype", &ltype, NULL)
        && !memcmp (&ltype, &multileader->ltype, sizeof (multileader->ltype)))
        pass ();
    else
        fail ("MULTILEADER.ltype [H]");
  }
  {
    BITCODE_H mleaderstyle;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "mleaderstyle", &mleaderstyle, NULL)
        && !memcmp (&mleaderstyle, &multileader->mleaderstyle, sizeof (multileader->mleaderstyle)))
        pass ();
    else
        fail ("MULTILEADER.mleaderstyle [H]");
  }
  {
    BITCODE_B neg_textdir;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "neg_textdir", &neg_textdir, NULL)
        && neg_textdir == multileader->neg_textdir)
      pass ();
    else
      fail ("MULTILEADER.neg_textdir [B] " FORMAT_B " != " FORMAT_B "", multileader->neg_textdir, neg_textdir);
    neg_textdir++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "neg_textdir", &neg_textdir, 0)
        && neg_textdir == multileader->neg_textdir)
      pass ();
    else
      fail ("MULTILEADER.neg_textdir [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->neg_textdir, neg_textdir);
    multileader->neg_textdir--;
  }
  {
    BITCODE_BL num_arrowheads;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "num_arrowheads", &num_arrowheads, NULL)
        && num_arrowheads == multileader->num_arrowheads)
      pass ();
    else
      fail ("MULTILEADER.num_arrowheads [BL] %u != %u", multileader->num_arrowheads, num_arrowheads);
    num_arrowheads++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "num_arrowheads", &num_arrowheads, 0)
        && num_arrowheads == multileader->num_arrowheads)
      pass ();
    else
      fail ("MULTILEADER.num_arrowheads [BL] set+1 %u != %u", multileader->num_arrowheads, num_arrowheads);
    multileader->num_arrowheads--;
  }
  {
    BITCODE_BL num_blocklabels;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "num_blocklabels", &num_blocklabels, NULL)
        && num_blocklabels == multileader->num_blocklabels)
      pass ();
    else
      fail ("MULTILEADER.num_blocklabels [BL] %u != %u", multileader->num_blocklabels, num_blocklabels);
    num_blocklabels++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "num_blocklabels", &num_blocklabels, 0)
        && num_blocklabels == multileader->num_blocklabels)
      pass ();
    else
      fail ("MULTILEADER.num_blocklabels [BL] set+1 %u != %u", multileader->num_blocklabels, num_blocklabels);
    multileader->num_blocklabels--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "parent", &parent, NULL)
        && !memcmp (&parent, &multileader->parent, sizeof (multileader->parent)))
        pass ();
    else
        fail ("MULTILEADER.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "scale_factor", &scale_factor, NULL)
        && scale_factor == multileader->scale_factor)
      pass ();
    else
      fail ("MULTILEADER.scale_factor [BD] %g != %g", multileader->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "scale_factor", &scale_factor, 0)
        && scale_factor == multileader->scale_factor)
      pass ();
    else
      fail ("MULTILEADER.scale_factor [BD] set+1 %g != %g", multileader->scale_factor, scale_factor);
    multileader->scale_factor--;
  }
  {
    BITCODE_BS style_attachment;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "style_attachment", &style_attachment, NULL)
        && style_attachment == multileader->style_attachment)
      pass ();
    else
      fail ("MULTILEADER.style_attachment [BS] %hu != %hu", multileader->style_attachment, style_attachment);
    style_attachment++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "style_attachment", &style_attachment, 0)
        && style_attachment == multileader->style_attachment)
      pass ();
    else
      fail ("MULTILEADER.style_attachment [BS] set+1 %hu != %hu", multileader->style_attachment, style_attachment);
    multileader->style_attachment--;
  }
  {
    BITCODE_BS style_content;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "style_content", &style_content, NULL)
        && style_content == multileader->style_content)
      pass ();
    else
      fail ("MULTILEADER.style_content [BS] %hu != %hu", multileader->style_content, style_content);
    style_content++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "style_content", &style_content, 0)
        && style_content == multileader->style_content)
      pass ();
    else
      fail ("MULTILEADER.style_content [BS] set+1 %hu != %hu", multileader->style_content, style_content);
    multileader->style_content--;
  }
  {
    BITCODE_BS text_angletype;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_angletype", &text_angletype, NULL)
        && text_angletype == multileader->text_angletype)
      pass ();
    else
      fail ("MULTILEADER.text_angletype [BS] %hu != %hu", multileader->text_angletype, text_angletype);
    text_angletype++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "text_angletype", &text_angletype, 0)
        && text_angletype == multileader->text_angletype)
      pass ();
    else
      fail ("MULTILEADER.text_angletype [BS] set+1 %hu != %hu", multileader->text_angletype, text_angletype);
    multileader->text_angletype--;
  }
  {
    BITCODE_CMC text_color;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_color", &text_color, NULL)
        && !memcmp (&text_color, &multileader->text_color, sizeof (multileader->text_color)))
        pass ();
    else
        fail ("MULTILEADER.text_color [CMC]");
  }
  {
    BITCODE_B text_extended;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_extended", &text_extended, NULL)
        && text_extended == multileader->text_extended)
      pass ();
    else
      fail ("MULTILEADER.text_extended [B] " FORMAT_B " != " FORMAT_B "", multileader->text_extended, text_extended);
    text_extended++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "text_extended", &text_extended, 0)
        && text_extended == multileader->text_extended)
      pass ();
    else
      fail ("MULTILEADER.text_extended [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->text_extended, text_extended);
    multileader->text_extended--;
  }
  {
    BITCODE_BS text_left;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_left", &text_left, NULL)
        && text_left == multileader->text_left)
      pass ();
    else
      fail ("MULTILEADER.text_left [BS] %hu != %hu", multileader->text_left, text_left);
    text_left++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "text_left", &text_left, 0)
        && text_left == multileader->text_left)
      pass ();
    else
      fail ("MULTILEADER.text_left [BS] set+1 %hu != %hu", multileader->text_left, text_left);
    multileader->text_left--;
  }
  {
    BITCODE_BS text_right;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_right", &text_right, NULL)
        && text_right == multileader->text_right)
      pass ();
    else
      fail ("MULTILEADER.text_right [BS] %hu != %hu", multileader->text_right, text_right);
    text_right++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "text_right", &text_right, 0)
        && text_right == multileader->text_right)
      pass ();
    else
      fail ("MULTILEADER.text_right [BS] set+1 %hu != %hu", multileader->text_right, text_right);
    multileader->text_right--;
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_style", &text_style, NULL)
        && !memcmp (&text_style, &multileader->text_style, sizeof (multileader->text_style)))
        pass ();
    else
        fail ("MULTILEADER.text_style [H]");
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "type", &type, NULL)
        && type == multileader->type)
      pass ();
    else
      fail ("MULTILEADER.type [BS] %hu != %hu", multileader->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "type", &type, 0)
        && type == multileader->type)
      pass ();
    else
      fail ("MULTILEADER.type [BS] set+1 %hu != %hu", multileader->type, type);
    multileader->type--;
  }
  if (failed && (is_class_unstable ("MULTILEADER") || is_class_debugging ("MULTILEADER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MULTILEADER", failed);
      failed = 0;
    }
  return failed;
}
static int test_OLE2FRAME (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_OLE2FRAME *restrict ole2frame = obj->tio.entity->tio.OLE2FRAME;
  failed = 0;
  {
    BITCODE_TF data;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "data", &data, NULL)
        && !memcmp (&data, &ole2frame->data, sizeof (ole2frame->data)))
        pass ();
    else
        fail ("OLE2FRAME.data [TF]");
  }
  {
    BITCODE_BL data_size;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "data_size", &data_size, NULL)
        && data_size == ole2frame->data_size)
      pass ();
    else
      fail ("OLE2FRAME.data_size [BL] %u != %u", ole2frame->data_size, data_size);
    data_size++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "data_size", &data_size, 0)
        && data_size == ole2frame->data_size)
      pass ();
    else
      fail ("OLE2FRAME.data_size [BL] set+1 %u != %u", ole2frame->data_size, data_size);
    ole2frame->data_size--;
  }
  {
    BITCODE_RC lock_aspect;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "lock_aspect", &lock_aspect, NULL)
        && lock_aspect == ole2frame->lock_aspect)
      pass ();
    else
      fail ("OLE2FRAME.lock_aspect [RC] %u != %u", ole2frame->lock_aspect, lock_aspect);
    lock_aspect++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "lock_aspect", &lock_aspect, 0)
        && lock_aspect == ole2frame->lock_aspect)
      pass ();
    else
      fail ("OLE2FRAME.lock_aspect [RC] set+1 %u != %u", ole2frame->lock_aspect, lock_aspect);
    ole2frame->lock_aspect--;
  }
  {
    BITCODE_BS mode;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "mode", &mode, NULL)
        && mode == ole2frame->mode)
      pass ();
    else
      fail ("OLE2FRAME.mode [BS] %hu != %hu", ole2frame->mode, mode);
    mode++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "mode", &mode, 0)
        && mode == ole2frame->mode)
      pass ();
    else
      fail ("OLE2FRAME.mode [BS] set+1 %hu != %hu", ole2frame->mode, mode);
    ole2frame->mode--;
  }
  {
    BITCODE_TF oleclient;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "oleclient", &oleclient, NULL)
        && !memcmp (&oleclient, &ole2frame->oleclient, sizeof (ole2frame->oleclient)))
        pass ();
    else
        fail ("OLE2FRAME.oleclient [TF]");
  }
  {
    BITCODE_BS oleversion;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "oleversion", &oleversion, NULL)
        && oleversion == ole2frame->oleversion)
      pass ();
    else
      fail ("OLE2FRAME.oleversion [BS] %hu != %hu", ole2frame->oleversion, oleversion);
    oleversion++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "oleversion", &oleversion, 0)
        && oleversion == ole2frame->oleversion)
      pass ();
    else
      fail ("OLE2FRAME.oleversion [BS] set+1 %hu != %hu", ole2frame->oleversion, oleversion);
    ole2frame->oleversion--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "parent", &parent, NULL)
        && !memcmp (&parent, &ole2frame->parent, sizeof (ole2frame->parent)))
        pass ();
    else
        fail ("OLE2FRAME.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD pt1;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "pt1", &pt1, NULL)
        && !memcmp (&pt1, &ole2frame->pt1, sizeof (ole2frame->pt1)))
        pass ();
    else
        fail ("OLE2FRAME.pt1 [3BD]");
  }
  {
    BITCODE_3BD pt2;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "pt2", &pt2, NULL)
        && !memcmp (&pt2, &ole2frame->pt2, sizeof (ole2frame->pt2)))
        pass ();
    else
        fail ("OLE2FRAME.pt2 [3BD]");
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "type", &type, NULL)
        && type == ole2frame->type)
      pass ();
    else
      fail ("OLE2FRAME.type [BS] %hu != %hu", ole2frame->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "type", &type, 0)
        && type == ole2frame->type)
      pass ();
    else
      fail ("OLE2FRAME.type [BS] set+1 %hu != %hu", ole2frame->type, type);
    ole2frame->type--;
  }
  if (failed && (is_class_unstable ("OLE2FRAME") || is_class_debugging ("OLE2FRAME")))
    {
      ok ("%s failed %d tests (TODO unstable)", "OLE2FRAME", failed);
      failed = 0;
    }
  return failed;
}
static int test_OLEFRAME (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_OLEFRAME *restrict oleframe = obj->tio.entity->tio.OLEFRAME;
  failed = 0;
  {
    BITCODE_TF data;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "data", &data, NULL)
        && !memcmp (&data, &oleframe->data, sizeof (oleframe->data)))
        pass ();
    else
        fail ("OLEFRAME.data [TF]");
  }
  {
    BITCODE_BL data_size;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "data_size", &data_size, NULL)
        && data_size == oleframe->data_size)
      pass ();
    else
      fail ("OLEFRAME.data_size [BL] %u != %u", oleframe->data_size, data_size);
    data_size++;
    if (dwg_dynapi_entity_set_value (oleframe, "OLEFRAME", "data_size", &data_size, 0)
        && data_size == oleframe->data_size)
      pass ();
    else
      fail ("OLEFRAME.data_size [BL] set+1 %u != %u", oleframe->data_size, data_size);
    oleframe->data_size--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "flag", &flag, NULL)
        && flag == oleframe->flag)
      pass ();
    else
      fail ("OLEFRAME.flag [BS] %hu != %hu", oleframe->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (oleframe, "OLEFRAME", "flag", &flag, 0)
        && flag == oleframe->flag)
      pass ();
    else
      fail ("OLEFRAME.flag [BS] set+1 %hu != %hu", oleframe->flag, flag);
    oleframe->flag--;
  }
  {
    BITCODE_BS mode;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "mode", &mode, NULL)
        && mode == oleframe->mode)
      pass ();
    else
      fail ("OLEFRAME.mode [BS] %hu != %hu", oleframe->mode, mode);
    mode++;
    if (dwg_dynapi_entity_set_value (oleframe, "OLEFRAME", "mode", &mode, 0)
        && mode == oleframe->mode)
      pass ();
    else
      fail ("OLEFRAME.mode [BS] set+1 %hu != %hu", oleframe->mode, mode);
    oleframe->mode--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "parent", &parent, NULL)
        && !memcmp (&parent, &oleframe->parent, sizeof (oleframe->parent)))
        pass ();
    else
        fail ("OLEFRAME.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("OLEFRAME") || is_class_debugging ("OLEFRAME")))
    {
      ok ("%s failed %d tests (TODO unstable)", "OLEFRAME", failed);
      failed = 0;
    }
  return failed;
}
static int test_PLANESURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_PLANESURFACE *restrict planesurface = obj->tio.entity->tio.PLANESURFACE;
  failed = 0;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)planesurface->acis_data)
           : !planesurface->acis_data)
      pass ();
    else
      fail ("PLANESURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, planesurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == planesurface->acis_empty)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == planesurface->acis_empty)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty, acis_empty);
    planesurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == planesurface->acis_empty2)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == planesurface->acis_empty2)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty2, acis_empty2);
    planesurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == planesurface->acis_empty_bit)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == planesurface->acis_empty_bit)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty_bit, acis_empty_bit);
    planesurface->acis_empty_bit--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &planesurface->block_size, sizeof (planesurface->block_size)))
        pass ();
    else
        fail ("PLANESURFACE.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "class_version", &class_version, NULL)
        && class_version == planesurface->class_version)
      pass ();
    else
      fail ("PLANESURFACE.class_version [BL] %u != %u", planesurface->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "class_version", &class_version, 0)
        && class_version == planesurface->class_version)
      pass ();
    else
      fail ("PLANESURFACE.class_version [BL] set+1 %u != %u", planesurface->class_version, class_version);
    planesurface->class_version--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &planesurface->encr_sat_data, sizeof (planesurface->encr_sat_data)))
      pass ();
    else
      fail ("PLANESURFACE.encr_sat_data [char **]");
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &planesurface->extra_acis_data, sizeof (planesurface->extra_acis_data)))
        pass ();
    else
        fail ("PLANESURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &planesurface->history_id, sizeof (planesurface->history_id)))
        pass ();
    else
        fail ("PLANESURFACE.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == planesurface->isoline_present)
      pass ();
    else
      fail ("PLANESURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == planesurface->isoline_present)
      pass ();
    else
      fail ("PLANESURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->isoline_present, isoline_present);
    planesurface->isoline_present--;
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == planesurface->modeler_format_version)
      pass ();
    else
      fail ("PLANESURFACE.modeler_format_version [BS] %hu != %hu", planesurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == planesurface->modeler_format_version)
      pass ();
    else
      fail ("PLANESURFACE.modeler_format_version [BS] set+1 %hu != %hu", planesurface->modeler_format_version, modeler_format_version);
    planesurface->modeler_format_version--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == planesurface->num_blocks)
      pass ();
    else
      fail ("PLANESURFACE.num_blocks [BL] %u != %u", planesurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == planesurface->num_blocks)
      pass ();
    else
      fail ("PLANESURFACE.num_blocks [BL] set+1 %u != %u", planesurface->num_blocks, num_blocks);
    planesurface->num_blocks--;
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_isolines", &num_isolines, NULL)
        && num_isolines == planesurface->num_isolines)
      pass ();
    else
      fail ("PLANESURFACE.num_isolines [BL] %u != %u", planesurface->num_isolines, num_isolines);
    num_isolines++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_isolines", &num_isolines, 0)
        && num_isolines == planesurface->num_isolines)
      pass ();
    else
      fail ("PLANESURFACE.num_isolines [BL] set+1 %u != %u", planesurface->num_isolines, num_isolines);
    planesurface->num_isolines--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == planesurface->num_silhouettes)
      pass ();
    else
      fail ("PLANESURFACE.num_silhouettes [BL] %u != %u", planesurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == planesurface->num_silhouettes)
      pass ();
    else
      fail ("PLANESURFACE.num_silhouettes [BL] set+1 %u != %u", planesurface->num_silhouettes, num_silhouettes);
    planesurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_wires", &num_wires, NULL)
        && num_wires == planesurface->num_wires)
      pass ();
    else
      fail ("PLANESURFACE.num_wires [BL] %u != %u", planesurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_wires", &num_wires, 0)
        && num_wires == planesurface->num_wires)
      pass ();
    else
      fail ("PLANESURFACE.num_wires [BL] set+1 %u != %u", planesurface->num_wires, num_wires);
    planesurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &planesurface->parent, sizeof (planesurface->parent)))
        pass ();
    else
        fail ("PLANESURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "point", &point, NULL)
        && !memcmp (&point, &planesurface->point, sizeof (planesurface->point)))
        pass ();
    else
        fail ("PLANESURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "point_present", &point_present, NULL)
        && point_present == planesurface->point_present)
      pass ();
    else
      fail ("PLANESURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "point_present", &point_present, 0)
        && point_present == planesurface->point_present)
      pass ();
    else
      fail ("PLANESURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->point_present, point_present);
    planesurface->point_present--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == planesurface->silhouettes)
      pass ();
    else
      fail ("PLANESURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == planesurface->u_isolines)
      pass ();
    else
      fail ("PLANESURFACE.u_isolines [BS] %hu != %hu", planesurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == planesurface->u_isolines)
      pass ();
    else
      fail ("PLANESURFACE.u_isolines [BS] set+1 %hu != %hu", planesurface->u_isolines, u_isolines);
    planesurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "unknown", &unknown, NULL)
        && unknown == planesurface->unknown)
      pass ();
    else
      fail ("PLANESURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", planesurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "unknown", &unknown, 0)
        && unknown == planesurface->unknown)
      pass ();
    else
      fail ("PLANESURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->unknown, unknown);
    planesurface->unknown--;
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "unknown_2007", &unknown_2007, NULL)
        && unknown_2007 == planesurface->unknown_2007)
      pass ();
    else
      fail ("PLANESURFACE.unknown_2007 [BL] %u != %u", planesurface->unknown_2007, unknown_2007);
    unknown_2007++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "unknown_2007", &unknown_2007, 0)
        && unknown_2007 == planesurface->unknown_2007)
      pass ();
    else
      fail ("PLANESURFACE.unknown_2007 [BL] set+1 %u != %u", planesurface->unknown_2007, unknown_2007);
    planesurface->unknown_2007--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == planesurface->v_isolines)
      pass ();
    else
      fail ("PLANESURFACE.v_isolines [BS] %hu != %hu", planesurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == planesurface->v_isolines)
      pass ();
    else
      fail ("PLANESURFACE.v_isolines [BS] set+1 %hu != %hu", planesurface->v_isolines, v_isolines);
    planesurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "version", &version, NULL)
        && version == planesurface->version)
      pass ();
    else
      fail ("PLANESURFACE.version [BS] %hu != %hu", planesurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "version", &version, 0)
        && version == planesurface->version)
      pass ();
    else
      fail ("PLANESURFACE.version [BS] set+1 %hu != %hu", planesurface->version, version);
    planesurface->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == planesurface->wireframe_data_present)
      pass ();
    else
      fail ("PLANESURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == planesurface->wireframe_data_present)
      pass ();
    else
      fail ("PLANESURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->wireframe_data_present, wireframe_data_present);
    planesurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "wires", &wires, NULL)
        && wires == planesurface->wires)
      pass ();
    else
      fail ("PLANESURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("PLANESURFACE") || is_class_debugging ("PLANESURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PLANESURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POINT *restrict point = obj->tio.entity->tio.POINT;
  failed = 0;
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (point, "POINT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &point->extrusion, sizeof (point->extrusion)))
        pass ();
    else
        fail ("POINT.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (point, "POINT", "parent", &parent, NULL)
        && !memcmp (&parent, &point->parent, sizeof (point->parent)))
        pass ();
    else
        fail ("POINT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (point, "POINT", "thickness", &thickness, NULL)
        && thickness == point->thickness)
      pass ();
    else
      fail ("POINT.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", point->thickness, thickness);
    if (dwg_dynapi_entity_set_value (point, "POINT", "thickness", &thickness, 0)
        && thickness == point->thickness)
      pass ();
    else
      fail ("POINT.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", point->thickness, thickness);
    point->thickness--;
  }
  {
    BITCODE_BD x;
    if (dwg_dynapi_entity_value (point, "POINT", "x", &x, NULL)
        && x == point->x)
      pass ();
    else
      fail ("POINT.x [BD] %g != %g", point->x, x);
    x++;
    if (dwg_dynapi_entity_set_value (point, "POINT", "x", &x, 0)
        && x == point->x)
      pass ();
    else
      fail ("POINT.x [BD] set+1 %g != %g", point->x, x);
    point->x--;
  }
  {
    BITCODE_BD x_ang;
    if (dwg_dynapi_entity_value (point, "POINT", "x_ang", &x_ang, NULL)
        && x_ang == point->x_ang)
      pass ();
    else
      fail ("POINT.x_ang [BD] %g != %g", point->x_ang, x_ang);
    x_ang++;
    if (dwg_dynapi_entity_set_value (point, "POINT", "x_ang", &x_ang, 0)
        && x_ang == point->x_ang)
      pass ();
    else
      fail ("POINT.x_ang [BD] set+1 %g != %g", point->x_ang, x_ang);
    point->x_ang--;
  }
  {
    BITCODE_BD y;
    if (dwg_dynapi_entity_value (point, "POINT", "y", &y, NULL)
        && y == point->y)
      pass ();
    else
      fail ("POINT.y [BD] %g != %g", point->y, y);
    y++;
    if (dwg_dynapi_entity_set_value (point, "POINT", "y", &y, 0)
        && y == point->y)
      pass ();
    else
      fail ("POINT.y [BD] set+1 %g != %g", point->y, y);
    point->y--;
  }
  {
    BITCODE_BD z;
    if (dwg_dynapi_entity_value (point, "POINT", "z", &z, NULL)
        && z == point->z)
      pass ();
    else
      fail ("POINT.z [BD] %g != %g", point->z, z);
    z++;
    if (dwg_dynapi_entity_set_value (point, "POINT", "z", &z, 0)
        && z == point->z)
      pass ();
    else
      fail ("POINT.z [BD] set+1 %g != %g", point->z, z);
    point->z--;
  }
  if (failed && (is_class_unstable ("POINT") || is_class_debugging ("POINT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINT", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_2D (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_2D *restrict polyline_2d = obj->tio.entity->tio.POLYLINE_2D;
  failed = 0;
  {
    BITCODE_BS curve_type;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "curve_type", &curve_type, NULL)
        && curve_type == polyline_2d->curve_type)
      pass ();
    else
      fail ("POLYLINE_2D.curve_type [BS] %hu != %hu", polyline_2d->curve_type, curve_type);
    curve_type++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "curve_type", &curve_type, 0)
        && curve_type == polyline_2d->curve_type)
      pass ();
    else
      fail ("POLYLINE_2D.curve_type [BS] set+1 %hu != %hu", polyline_2d->curve_type, curve_type);
    polyline_2d->curve_type--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "elevation", &elevation, NULL)
        && elevation == polyline_2d->elevation)
      pass ();
    else
      fail ("POLYLINE_2D.elevation [BD] %g != %g", polyline_2d->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "elevation", &elevation, 0)
        && elevation == polyline_2d->elevation)
      pass ();
    else
      fail ("POLYLINE_2D.elevation [BD] set+1 %g != %g", polyline_2d->elevation, elevation);
    polyline_2d->elevation--;
  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "end_width", &end_width, NULL)
        && end_width == polyline_2d->end_width)
      pass ();
    else
      fail ("POLYLINE_2D.end_width [BD] %g != %g", polyline_2d->end_width, end_width);
    end_width++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "end_width", &end_width, 0)
        && end_width == polyline_2d->end_width)
      pass ();
    else
      fail ("POLYLINE_2D.end_width [BD] set+1 %g != %g", polyline_2d->end_width, end_width);
    polyline_2d->end_width--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &polyline_2d->extrusion, sizeof (polyline_2d->extrusion)))
        pass ();
    else
        fail ("POLYLINE_2D.extrusion [BE]");
  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "first_vertex", &first_vertex, NULL)
        && !memcmp (&first_vertex, &polyline_2d->first_vertex, sizeof (polyline_2d->first_vertex)))
        pass ();
    else
        fail ("POLYLINE_2D.first_vertex [H]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "flag", &flag, NULL)
        && flag == polyline_2d->flag)
      pass ();
    else
      fail ("POLYLINE_2D.flag [BS] %hu != %hu", polyline_2d->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "flag", &flag, 0)
        && flag == polyline_2d->flag)
      pass ();
    else
      fail ("POLYLINE_2D.flag [BS] set+1 %hu != %hu", polyline_2d->flag, flag);
    polyline_2d->flag--;
  }
  {
    BITCODE_B has_vertex;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "has_vertex", &has_vertex, NULL)
        && has_vertex == polyline_2d->has_vertex)
      pass ();
    else
      fail ("POLYLINE_2D.has_vertex [B] " FORMAT_B " != " FORMAT_B "", polyline_2d->has_vertex, has_vertex);
    has_vertex++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "has_vertex", &has_vertex, 0)
        && has_vertex == polyline_2d->has_vertex)
      pass ();
    else
      fail ("POLYLINE_2D.has_vertex [B] set+1 " FORMAT_B " != " FORMAT_B "", polyline_2d->has_vertex, has_vertex);
    polyline_2d->has_vertex--;
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "last_vertex", &last_vertex, NULL)
        && !memcmp (&last_vertex, &polyline_2d->last_vertex, sizeof (polyline_2d->last_vertex)))
        pass ();
    else
        fail ("POLYLINE_2D.last_vertex [H]");
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "num_owned", &num_owned, NULL)
        && num_owned == polyline_2d->num_owned)
      pass ();
    else
      fail ("POLYLINE_2D.num_owned [BL] %u != %u", polyline_2d->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "num_owned", &num_owned, 0)
        && num_owned == polyline_2d->num_owned)
      pass ();
    else
      fail ("POLYLINE_2D.num_owned [BL] set+1 %u != %u", polyline_2d->num_owned, num_owned);
    polyline_2d->num_owned--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_2d->parent, sizeof (polyline_2d->parent)))
        pass ();
    else
        fail ("POLYLINE_2D.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &polyline_2d->seqend, sizeof (polyline_2d->seqend)))
        pass ();
    else
        fail ("POLYLINE_2D.seqend [H]");
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "start_width", &start_width, NULL)
        && start_width == polyline_2d->start_width)
      pass ();
    else
      fail ("POLYLINE_2D.start_width [BD] %g != %g", polyline_2d->start_width, start_width);
    start_width++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "start_width", &start_width, 0)
        && start_width == polyline_2d->start_width)
      pass ();
    else
      fail ("POLYLINE_2D.start_width [BD] set+1 %g != %g", polyline_2d->start_width, start_width);
    polyline_2d->start_width--;
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "thickness", &thickness, NULL)
        && thickness == polyline_2d->thickness)
      pass ();
    else
      fail ("POLYLINE_2D.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", polyline_2d->thickness, thickness);
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "thickness", &thickness, 0)
        && thickness == polyline_2d->thickness)
      pass ();
    else
      fail ("POLYLINE_2D.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", polyline_2d->thickness, thickness);
    polyline_2d->thickness--;
  }
  {
    BITCODE_H* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "vertex", &vertex, NULL)
        && vertex == polyline_2d->vertex)
      pass ();
    else
      fail ("POLYLINE_2D.vertex [H*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("POLYLINE_2D") || is_class_debugging ("POLYLINE_2D")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_2D", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_3D (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_3D *restrict polyline_3d = obj->tio.entity->tio.POLYLINE_3D;
  failed = 0;
  {
    BITCODE_RC curve_type;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "curve_type", &curve_type, NULL)
        && curve_type == polyline_3d->curve_type)
      pass ();
    else
      fail ("POLYLINE_3D.curve_type [RC] %u != %u", polyline_3d->curve_type, curve_type);
    curve_type++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "curve_type", &curve_type, 0)
        && curve_type == polyline_3d->curve_type)
      pass ();
    else
      fail ("POLYLINE_3D.curve_type [RC] set+1 %u != %u", polyline_3d->curve_type, curve_type);
    polyline_3d->curve_type--;
  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "first_vertex", &first_vertex, NULL)
        && !memcmp (&first_vertex, &polyline_3d->first_vertex, sizeof (polyline_3d->first_vertex)))
        pass ();
    else
        fail ("POLYLINE_3D.first_vertex [H]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "flag", &flag, NULL)
        && flag == polyline_3d->flag)
      pass ();
    else
      fail ("POLYLINE_3D.flag [RC] %u != %u", polyline_3d->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "flag", &flag, 0)
        && flag == polyline_3d->flag)
      pass ();
    else
      fail ("POLYLINE_3D.flag [RC] set+1 %u != %u", polyline_3d->flag, flag);
    polyline_3d->flag--;
  }
  {
    BITCODE_B has_vertex;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "has_vertex", &has_vertex, NULL)
        && has_vertex == polyline_3d->has_vertex)
      pass ();
    else
      fail ("POLYLINE_3D.has_vertex [B] " FORMAT_B " != " FORMAT_B "", polyline_3d->has_vertex, has_vertex);
    has_vertex++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "has_vertex", &has_vertex, 0)
        && has_vertex == polyline_3d->has_vertex)
      pass ();
    else
      fail ("POLYLINE_3D.has_vertex [B] set+1 " FORMAT_B " != " FORMAT_B "", polyline_3d->has_vertex, has_vertex);
    polyline_3d->has_vertex--;
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "last_vertex", &last_vertex, NULL)
        && !memcmp (&last_vertex, &polyline_3d->last_vertex, sizeof (polyline_3d->last_vertex)))
        pass ();
    else
        fail ("POLYLINE_3D.last_vertex [H]");
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "num_owned", &num_owned, NULL)
        && num_owned == polyline_3d->num_owned)
      pass ();
    else
      fail ("POLYLINE_3D.num_owned [BL] %u != %u", polyline_3d->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "num_owned", &num_owned, 0)
        && num_owned == polyline_3d->num_owned)
      pass ();
    else
      fail ("POLYLINE_3D.num_owned [BL] set+1 %u != %u", polyline_3d->num_owned, num_owned);
    polyline_3d->num_owned--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_3d->parent, sizeof (polyline_3d->parent)))
        pass ();
    else
        fail ("POLYLINE_3D.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &polyline_3d->seqend, sizeof (polyline_3d->seqend)))
        pass ();
    else
        fail ("POLYLINE_3D.seqend [H]");
  }
  {
    BITCODE_H* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "vertex", &vertex, NULL)
        && vertex == polyline_3d->vertex)
      pass ();
    else
      fail ("POLYLINE_3D.vertex [H*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("POLYLINE_3D") || is_class_debugging ("POLYLINE_3D")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_3D", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_MESH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_MESH *restrict polyline_mesh = obj->tio.entity->tio.POLYLINE_MESH;
  failed = 0;
  {
    BITCODE_BS curve_type;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "curve_type", &curve_type, NULL)
        && curve_type == polyline_mesh->curve_type)
      pass ();
    else
      fail ("POLYLINE_MESH.curve_type [BS] %hu != %hu", polyline_mesh->curve_type, curve_type);
    curve_type++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "curve_type", &curve_type, 0)
        && curve_type == polyline_mesh->curve_type)
      pass ();
    else
      fail ("POLYLINE_MESH.curve_type [BS] set+1 %hu != %hu", polyline_mesh->curve_type, curve_type);
    polyline_mesh->curve_type--;
  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "first_vertex", &first_vertex, NULL)
        && !memcmp (&first_vertex, &polyline_mesh->first_vertex, sizeof (polyline_mesh->first_vertex)))
        pass ();
    else
        fail ("POLYLINE_MESH.first_vertex [H]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "flag", &flag, NULL)
        && flag == polyline_mesh->flag)
      pass ();
    else
      fail ("POLYLINE_MESH.flag [BS] %hu != %hu", polyline_mesh->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "flag", &flag, 0)
        && flag == polyline_mesh->flag)
      pass ();
    else
      fail ("POLYLINE_MESH.flag [BS] set+1 %hu != %hu", polyline_mesh->flag, flag);
    polyline_mesh->flag--;
  }
  {
    BITCODE_B has_vertex;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "has_vertex", &has_vertex, NULL)
        && has_vertex == polyline_mesh->has_vertex)
      pass ();
    else
      fail ("POLYLINE_MESH.has_vertex [B] " FORMAT_B " != " FORMAT_B "", polyline_mesh->has_vertex, has_vertex);
    has_vertex++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "has_vertex", &has_vertex, 0)
        && has_vertex == polyline_mesh->has_vertex)
      pass ();
    else
      fail ("POLYLINE_MESH.has_vertex [B] set+1 " FORMAT_B " != " FORMAT_B "", polyline_mesh->has_vertex, has_vertex);
    polyline_mesh->has_vertex--;
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "last_vertex", &last_vertex, NULL)
        && !memcmp (&last_vertex, &polyline_mesh->last_vertex, sizeof (polyline_mesh->last_vertex)))
        pass ();
    else
        fail ("POLYLINE_MESH.last_vertex [H]");
  }
  {
    BITCODE_BS m_density;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "m_density", &m_density, NULL)
        && m_density == polyline_mesh->m_density)
      pass ();
    else
      fail ("POLYLINE_MESH.m_density [BS] %hu != %hu", polyline_mesh->m_density, m_density);
    m_density++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "m_density", &m_density, 0)
        && m_density == polyline_mesh->m_density)
      pass ();
    else
      fail ("POLYLINE_MESH.m_density [BS] set+1 %hu != %hu", polyline_mesh->m_density, m_density);
    polyline_mesh->m_density--;
  }
  {
    BITCODE_BS n_density;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "n_density", &n_density, NULL)
        && n_density == polyline_mesh->n_density)
      pass ();
    else
      fail ("POLYLINE_MESH.n_density [BS] %hu != %hu", polyline_mesh->n_density, n_density);
    n_density++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "n_density", &n_density, 0)
        && n_density == polyline_mesh->n_density)
      pass ();
    else
      fail ("POLYLINE_MESH.n_density [BS] set+1 %hu != %hu", polyline_mesh->n_density, n_density);
    polyline_mesh->n_density--;
  }
  {
    BITCODE_BS num_m_verts;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "num_m_verts", &num_m_verts, NULL)
        && num_m_verts == polyline_mesh->num_m_verts)
      pass ();
    else
      fail ("POLYLINE_MESH.num_m_verts [BS] %hu != %hu", polyline_mesh->num_m_verts, num_m_verts);
    num_m_verts++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "num_m_verts", &num_m_verts, 0)
        && num_m_verts == polyline_mesh->num_m_verts)
      pass ();
    else
      fail ("POLYLINE_MESH.num_m_verts [BS] set+1 %hu != %hu", polyline_mesh->num_m_verts, num_m_verts);
    polyline_mesh->num_m_verts--;
  }
  {
    BITCODE_BS num_n_verts;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "num_n_verts", &num_n_verts, NULL)
        && num_n_verts == polyline_mesh->num_n_verts)
      pass ();
    else
      fail ("POLYLINE_MESH.num_n_verts [BS] %hu != %hu", polyline_mesh->num_n_verts, num_n_verts);
    num_n_verts++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "num_n_verts", &num_n_verts, 0)
        && num_n_verts == polyline_mesh->num_n_verts)
      pass ();
    else
      fail ("POLYLINE_MESH.num_n_verts [BS] set+1 %hu != %hu", polyline_mesh->num_n_verts, num_n_verts);
    polyline_mesh->num_n_verts--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "num_owned", &num_owned, NULL)
        && num_owned == polyline_mesh->num_owned)
      pass ();
    else
      fail ("POLYLINE_MESH.num_owned [BL] %u != %u", polyline_mesh->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "num_owned", &num_owned, 0)
        && num_owned == polyline_mesh->num_owned)
      pass ();
    else
      fail ("POLYLINE_MESH.num_owned [BL] set+1 %u != %u", polyline_mesh->num_owned, num_owned);
    polyline_mesh->num_owned--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_mesh->parent, sizeof (polyline_mesh->parent)))
        pass ();
    else
        fail ("POLYLINE_MESH.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &polyline_mesh->seqend, sizeof (polyline_mesh->seqend)))
        pass ();
    else
        fail ("POLYLINE_MESH.seqend [H]");
  }
  {
    BITCODE_H* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "vertex", &vertex, NULL)
        && vertex == polyline_mesh->vertex)
      pass ();
    else
      fail ("POLYLINE_MESH.vertex [H*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("POLYLINE_MESH") || is_class_debugging ("POLYLINE_MESH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_MESH", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_PFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_PFACE *restrict polyline_pface = obj->tio.entity->tio.POLYLINE_PFACE;
  failed = 0;
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "first_vertex", &first_vertex, NULL)
        && !memcmp (&first_vertex, &polyline_pface->first_vertex, sizeof (polyline_pface->first_vertex)))
        pass ();
    else
        fail ("POLYLINE_PFACE.first_vertex [H]");
  }
  {
    BITCODE_B has_vertex;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "has_vertex", &has_vertex, NULL)
        && has_vertex == polyline_pface->has_vertex)
      pass ();
    else
      fail ("POLYLINE_PFACE.has_vertex [B] " FORMAT_B " != " FORMAT_B "", polyline_pface->has_vertex, has_vertex);
    has_vertex++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "has_vertex", &has_vertex, 0)
        && has_vertex == polyline_pface->has_vertex)
      pass ();
    else
      fail ("POLYLINE_PFACE.has_vertex [B] set+1 " FORMAT_B " != " FORMAT_B "", polyline_pface->has_vertex, has_vertex);
    polyline_pface->has_vertex--;
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "last_vertex", &last_vertex, NULL)
        && !memcmp (&last_vertex, &polyline_pface->last_vertex, sizeof (polyline_pface->last_vertex)))
        pass ();
    else
        fail ("POLYLINE_PFACE.last_vertex [H]");
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "num_owned", &num_owned, NULL)
        && num_owned == polyline_pface->num_owned)
      pass ();
    else
      fail ("POLYLINE_PFACE.num_owned [BL] %u != %u", polyline_pface->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "num_owned", &num_owned, 0)
        && num_owned == polyline_pface->num_owned)
      pass ();
    else
      fail ("POLYLINE_PFACE.num_owned [BL] set+1 %u != %u", polyline_pface->num_owned, num_owned);
    polyline_pface->num_owned--;
  }
  {
    BITCODE_BS numfaces;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "numfaces", &numfaces, NULL)
        && numfaces == polyline_pface->numfaces)
      pass ();
    else
      fail ("POLYLINE_PFACE.numfaces [BS] %hu != %hu", polyline_pface->numfaces, numfaces);
    numfaces++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "numfaces", &numfaces, 0)
        && numfaces == polyline_pface->numfaces)
      pass ();
    else
      fail ("POLYLINE_PFACE.numfaces [BS] set+1 %hu != %hu", polyline_pface->numfaces, numfaces);
    polyline_pface->numfaces--;
  }
  {
    BITCODE_BS numverts;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "numverts", &numverts, NULL)
        && numverts == polyline_pface->numverts)
      pass ();
    else
      fail ("POLYLINE_PFACE.numverts [BS] %hu != %hu", polyline_pface->numverts, numverts);
    numverts++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "numverts", &numverts, 0)
        && numverts == polyline_pface->numverts)
      pass ();
    else
      fail ("POLYLINE_PFACE.numverts [BS] set+1 %hu != %hu", polyline_pface->numverts, numverts);
    polyline_pface->numverts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_pface->parent, sizeof (polyline_pface->parent)))
        pass ();
    else
        fail ("POLYLINE_PFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &polyline_pface->seqend, sizeof (polyline_pface->seqend)))
        pass ();
    else
        fail ("POLYLINE_PFACE.seqend [H]");
  }
  {
    BITCODE_H* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "vertex", &vertex, NULL)
        && vertex == polyline_pface->vertex)
      pass ();
    else
      fail ("POLYLINE_PFACE.vertex [H*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("POLYLINE_PFACE") || is_class_debugging ("POLYLINE_PFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_PFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_PROXY_ENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_PROXY_ENTITY *restrict proxy_entity = obj->tio.entity->tio.PROXY_ENTITY;
  failed = 0;
  {
    BITCODE_BL class_id;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "class_id", &class_id, NULL)
        && class_id == proxy_entity->class_id)
      pass ();
    else
      fail ("PROXY_ENTITY.class_id [BL] %u != %u", proxy_entity->class_id, class_id);
    class_id++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "class_id", &class_id, 0)
        && class_id == proxy_entity->class_id)
      pass ();
    else
      fail ("PROXY_ENTITY.class_id [BL] set+1 %u != %u", proxy_entity->class_id, class_id);
    proxy_entity->class_id--;
  }
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "data", &data, NULL)
        && data
           ? strEQ ((char *)data, (char *)proxy_entity->data)
           : !proxy_entity->data)
      pass ();
    else
      fail ("PROXY_ENTITY.data [TV] '%s' <> '%s'", data, proxy_entity->data);
  }
  {
    BITCODE_B from_dxf;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "from_dxf", &from_dxf, NULL)
        && from_dxf == proxy_entity->from_dxf)
      pass ();
    else
      fail ("PROXY_ENTITY.from_dxf [B] " FORMAT_B " != " FORMAT_B "", proxy_entity->from_dxf, from_dxf);
    from_dxf++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "from_dxf", &from_dxf, 0)
        && from_dxf == proxy_entity->from_dxf)
      pass ();
    else
      fail ("PROXY_ENTITY.from_dxf [B] set+1 " FORMAT_B " != " FORMAT_B "", proxy_entity->from_dxf, from_dxf);
    proxy_entity->from_dxf--;
  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "maint_version", &maint_version, NULL)
        && maint_version == proxy_entity->maint_version)
      pass ();
    else
      fail ("PROXY_ENTITY.maint_version [BL] %u != %u", proxy_entity->maint_version, maint_version);
    maint_version++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "maint_version", &maint_version, 0)
        && maint_version == proxy_entity->maint_version)
      pass ();
    else
      fail ("PROXY_ENTITY.maint_version [BL] set+1 %u != %u", proxy_entity->maint_version, maint_version);
    proxy_entity->maint_version--;
  }
  {
    BITCODE_H* objid_object_handles;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "objid_object_handles", &objid_object_handles, NULL)
        && !memcmp (&objid_object_handles, &proxy_entity->objid_object_handles, sizeof (proxy_entity->objid_object_handles)))
        pass ();
    else
        fail ("PROXY_ENTITY.objid_object_handles [H*]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &proxy_entity->parent, sizeof (proxy_entity->parent)))
        pass ();
    else
        fail ("PROXY_ENTITY.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_MS size;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "size", &size, NULL)
        && size == proxy_entity->size)
      pass ();
    else
      fail ("PROXY_ENTITY.size [MS] " FORMAT_MS " != " FORMAT_MS "", proxy_entity->size, size);
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "size", &size, 0)
        && size == proxy_entity->size)
      pass ();
    else
      fail ("PROXY_ENTITY.size [MS] set+1 " FORMAT_MS " != " FORMAT_MS "", proxy_entity->size, size);
    proxy_entity->size--;
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "version", &version, NULL)
        && version == proxy_entity->version)
      pass ();
    else
      fail ("PROXY_ENTITY.version [BL] %u != %u", proxy_entity->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "version", &version, 0)
        && version == proxy_entity->version)
      pass ();
    else
      fail ("PROXY_ENTITY.version [BL] set+1 %u != %u", proxy_entity->version, version);
    proxy_entity->version--;
  }
  if (failed && (is_class_unstable ("PROXY_ENTITY") || is_class_debugging ("PROXY_ENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PROXY_ENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_RAY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_RAY *restrict ray = obj->tio.entity->tio.RAY;
  failed = 0;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (ray, "RAY", "parent", &parent, NULL)
        && !memcmp (&parent, &ray->parent, sizeof (ray->parent)))
        pass ();
    else
        fail ("RAY.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (ray, "RAY", "point", &point, NULL)
        && !memcmp (&point, &ray->point, sizeof (ray->point)))
        pass ();
    else
        fail ("RAY.point [3BD]");
  }
  {
    BITCODE_3BD vector;
    if (dwg_dynapi_entity_value (ray, "RAY", "vector", &vector, NULL)
        && !memcmp (&vector, &ray->vector, sizeof (ray->vector)))
        pass ();
    else
        fail ("RAY.vector [3BD]");
  }
  if (failed && (is_class_unstable ("RAY") || is_class_debugging ("RAY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RAY", failed);
      failed = 0;
    }
  return failed;
}
static int test_REGION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_REGION *restrict region = obj->tio.entity->tio.REGION;
  failed = 0;
  if (failed && (is_class_unstable ("REGION") || is_class_debugging ("REGION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "REGION", failed);
      failed = 0;
    }
  return failed;
}
static int test_REVOLVEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_REVOLVEDSURFACE *restrict revolvedsurface = obj->tio.entity->tio.REVOLVEDSURFACE;
  failed = 0;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)revolvedsurface->acis_data)
           : !revolvedsurface->acis_data)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, revolvedsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == revolvedsurface->acis_empty)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == revolvedsurface->acis_empty)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty, acis_empty);
    revolvedsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == revolvedsurface->acis_empty2)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == revolvedsurface->acis_empty2)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty2, acis_empty2);
    revolvedsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == revolvedsurface->acis_empty_bit)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == revolvedsurface->acis_empty_bit)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty_bit, acis_empty_bit);
    revolvedsurface->acis_empty_bit--;
  }
  {
    BITCODE_3BD axis_point;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "axis_point", &axis_point, NULL)
        && !memcmp (&axis_point, &revolvedsurface->axis_point, sizeof (revolvedsurface->axis_point)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.axis_point [3BD]");
  }
  {
    BITCODE_3BD axis_vector;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "axis_vector", &axis_vector, NULL)
        && !memcmp (&axis_vector, &revolvedsurface->axis_vector, sizeof (revolvedsurface->axis_vector)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.axis_vector [3BD]");
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &revolvedsurface->block_size, sizeof (revolvedsurface->block_size)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version, NULL)
        && class_version == revolvedsurface->class_version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.class_version [BL] %u != %u", revolvedsurface->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version, 0)
        && class_version == revolvedsurface->class_version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.class_version [BL] set+1 %u != %u", revolvedsurface->class_version, class_version);
    revolvedsurface->class_version--;
  }
  {
    BITCODE_B close_to_axis;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis, NULL)
        && close_to_axis == revolvedsurface->close_to_axis)
      pass ();
    else
      fail ("REVOLVEDSURFACE.close_to_axis [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis);
    close_to_axis++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis, 0)
        && close_to_axis == revolvedsurface->close_to_axis)
      pass ();
    else
      fail ("REVOLVEDSURFACE.close_to_axis [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis);
    revolvedsurface->close_to_axis--;
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle, NULL)
        && draft_angle == revolvedsurface->draft_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_angle [BD] %g != %g", revolvedsurface->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle, 0)
        && draft_angle == revolvedsurface->draft_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_angle [BD] set+1 %g != %g", revolvedsurface->draft_angle, draft_angle);
    revolvedsurface->draft_angle--;
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance, NULL)
        && draft_end_distance == revolvedsurface->draft_end_distance)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_end_distance [BD] %g != %g", revolvedsurface->draft_end_distance, draft_end_distance);
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance, 0)
        && draft_end_distance == revolvedsurface->draft_end_distance)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_end_distance [BD] set+1 %g != %g", revolvedsurface->draft_end_distance, draft_end_distance);
    revolvedsurface->draft_end_distance--;
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance, NULL)
        && draft_start_distance == revolvedsurface->draft_start_distance)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_start_distance [BD] %g != %g", revolvedsurface->draft_start_distance, draft_start_distance);
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance, 0)
        && draft_start_distance == revolvedsurface->draft_start_distance)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_start_distance [BD] set+1 %g != %g", revolvedsurface->draft_start_distance, draft_start_distance);
    revolvedsurface->draft_start_distance--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &revolvedsurface->encr_sat_data, sizeof (revolvedsurface->encr_sat_data)))
      pass ();
    else
      fail ("REVOLVEDSURFACE.encr_sat_data [char **]");
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &revolvedsurface->extra_acis_data, sizeof (revolvedsurface->extra_acis_data)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &revolvedsurface->history_id, sizeof (revolvedsurface->history_id)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.history_id [H]");
  }
  {
    BITCODE_BL id;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "id", &id, NULL)
        && id == revolvedsurface->id)
      pass ();
    else
      fail ("REVOLVEDSURFACE.id [BL] %u != %u", revolvedsurface->id, id);
    id++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "id", &id, 0)
        && id == revolvedsurface->id)
      pass ();
    else
      fail ("REVOLVEDSURFACE.id [BL] set+1 %u != %u", revolvedsurface->id, id);
    revolvedsurface->id--;
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == revolvedsurface->isoline_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == revolvedsurface->isoline_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->isoline_present, isoline_present);
    revolvedsurface->isoline_present--;
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == revolvedsurface->modeler_format_version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.modeler_format_version [BS] %hu != %hu", revolvedsurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == revolvedsurface->modeler_format_version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", revolvedsurface->modeler_format_version, modeler_format_version);
    revolvedsurface->modeler_format_version--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == revolvedsurface->num_blocks)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_blocks [BL] %u != %u", revolvedsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == revolvedsurface->num_blocks)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_blocks [BL] set+1 %u != %u", revolvedsurface->num_blocks, num_blocks);
    revolvedsurface->num_blocks--;
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_isolines", &num_isolines, NULL)
        && num_isolines == revolvedsurface->num_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_isolines [BL] %u != %u", revolvedsurface->num_isolines, num_isolines);
    num_isolines++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_isolines", &num_isolines, 0)
        && num_isolines == revolvedsurface->num_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_isolines [BL] set+1 %u != %u", revolvedsurface->num_isolines, num_isolines);
    revolvedsurface->num_isolines--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == revolvedsurface->num_silhouettes)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_silhouettes [BL] %u != %u", revolvedsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == revolvedsurface->num_silhouettes)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_silhouettes [BL] set+1 %u != %u", revolvedsurface->num_silhouettes, num_silhouettes);
    revolvedsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == revolvedsurface->num_wires)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_wires [BL] %u != %u", revolvedsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires, 0)
        && num_wires == revolvedsurface->num_wires)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_wires [BL] set+1 %u != %u", revolvedsurface->num_wires, num_wires);
    revolvedsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &revolvedsurface->parent, sizeof (revolvedsurface->parent)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "point", &point, NULL)
        && !memcmp (&point, &revolvedsurface->point, sizeof (revolvedsurface->point)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present, NULL)
        && point_present == revolvedsurface->point_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present, 0)
        && point_present == revolvedsurface->point_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->point_present, point_present);
    revolvedsurface->point_present--;
  }
  {
    BITCODE_BD revolve_angle;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle, NULL)
        && revolve_angle == revolvedsurface->revolve_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revolve_angle [BD] %g != %g", revolvedsurface->revolve_angle, revolve_angle);
    revolve_angle++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle, 0)
        && revolve_angle == revolvedsurface->revolve_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revolve_angle [BD] set+1 %g != %g", revolvedsurface->revolve_angle, revolve_angle);
    revolvedsurface->revolve_angle--;
  }
  {
    BITCODE_BD* revolved_entity_transmatrix;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revolved_entity_transmatrix", &revolved_entity_transmatrix, NULL)
        && !memcmp (&revolved_entity_transmatrix, &revolvedsurface->revolved_entity_transmatrix, sizeof (revolvedsurface->revolved_entity_transmatrix)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.revolved_entity_transmatrix [BD*]");
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == revolvedsurface->silhouettes)
      pass ();
    else
      fail ("REVOLVEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "solid", &solid, NULL)
        && solid == revolvedsurface->solid)
      pass ();
    else
      fail ("REVOLVEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid);
    solid++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "solid", &solid, 0)
        && solid == revolvedsurface->solid)
      pass ();
    else
      fail ("REVOLVEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid);
    revolvedsurface->solid--;
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle, NULL)
        && start_angle == revolvedsurface->start_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.start_angle [BD] %g != %g", revolvedsurface->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle, 0)
        && start_angle == revolvedsurface->start_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.start_angle [BD] set+1 %g != %g", revolvedsurface->start_angle, start_angle);
    revolvedsurface->start_angle--;
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle, NULL)
        && twist_angle == revolvedsurface->twist_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.twist_angle [BD] %g != %g", revolvedsurface->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle, 0)
        && twist_angle == revolvedsurface->twist_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.twist_angle [BD] set+1 %g != %g", revolvedsurface->twist_angle, twist_angle);
    revolvedsurface->twist_angle--;
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == revolvedsurface->u_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.u_isolines [BS] %hu != %hu", revolvedsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == revolvedsurface->u_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.u_isolines [BS] set+1 %hu != %hu", revolvedsurface->u_isolines, u_isolines);
    revolvedsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown, NULL)
        && unknown == revolvedsurface->unknown)
      pass ();
    else
      fail ("REVOLVEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown, 0)
        && unknown == revolvedsurface->unknown)
      pass ();
    else
      fail ("REVOLVEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->unknown, unknown);
    revolvedsurface->unknown--;
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "unknown_2007", &unknown_2007, NULL)
        && unknown_2007 == revolvedsurface->unknown_2007)
      pass ();
    else
      fail ("REVOLVEDSURFACE.unknown_2007 [BL] %u != %u", revolvedsurface->unknown_2007, unknown_2007);
    unknown_2007++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "unknown_2007", &unknown_2007, 0)
        && unknown_2007 == revolvedsurface->unknown_2007)
      pass ();
    else
      fail ("REVOLVEDSURFACE.unknown_2007 [BL] set+1 %u != %u", revolvedsurface->unknown_2007, unknown_2007);
    revolvedsurface->unknown_2007--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == revolvedsurface->v_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.v_isolines [BS] %hu != %hu", revolvedsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == revolvedsurface->v_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.v_isolines [BS] set+1 %hu != %hu", revolvedsurface->v_isolines, v_isolines);
    revolvedsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "version", &version, NULL)
        && version == revolvedsurface->version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.version [BS] %hu != %hu", revolvedsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "version", &version, 0)
        && version == revolvedsurface->version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.version [BS] set+1 %hu != %hu", revolvedsurface->version, version);
    revolvedsurface->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == revolvedsurface->wireframe_data_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == revolvedsurface->wireframe_data_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->wireframe_data_present, wireframe_data_present);
    revolvedsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "wires", &wires, NULL)
        && wires == revolvedsurface->wires)
      pass ();
    else
      fail ("REVOLVEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("REVOLVEDSURFACE") || is_class_debugging ("REVOLVEDSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "REVOLVEDSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SEQEND (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SEQEND *restrict seqend = obj->tio.entity->tio.SEQEND;
  failed = 0;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (seqend, "SEQEND", "parent", &parent, NULL)
        && !memcmp (&parent, &seqend->parent, sizeof (seqend->parent)))
        pass ();
    else
        fail ("SEQEND.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("SEQEND") || is_class_debugging ("SEQEND")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SEQEND", failed);
      failed = 0;
    }
  return failed;
}
static int test_SHAPE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SHAPE *restrict shape = obj->tio.entity->tio.SHAPE;
  failed = 0;
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &shape->extrusion, sizeof (shape->extrusion)))
        pass ();
    else
        fail ("SHAPE.extrusion [BE]");
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &shape->ins_pt, sizeof (shape->ins_pt)))
        pass ();
    else
        fail ("SHAPE.ins_pt [3BD]");
  }
  {
    BITCODE_BD oblique;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "oblique", &oblique, NULL)
        && oblique == shape->oblique)
      pass ();
    else
      fail ("SHAPE.oblique [BD] %g != %g", shape->oblique, oblique);
    oblique++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "oblique", &oblique, 0)
        && oblique == shape->oblique)
      pass ();
    else
      fail ("SHAPE.oblique [BD] set+1 %g != %g", shape->oblique, oblique);
    shape->oblique--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "parent", &parent, NULL)
        && !memcmp (&parent, &shape->parent, sizeof (shape->parent)))
        pass ();
    else
        fail ("SHAPE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "rotation", &rotation, NULL)
        && rotation == shape->rotation)
      pass ();
    else
      fail ("SHAPE.rotation [BD] %g != %g", shape->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "rotation", &rotation, 0)
        && rotation == shape->rotation)
      pass ();
    else
      fail ("SHAPE.rotation [BD] set+1 %g != %g", shape->rotation, rotation);
    shape->rotation--;
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "scale", &scale, NULL)
        && scale == shape->scale)
      pass ();
    else
      fail ("SHAPE.scale [BD] %g != %g", shape->scale, scale);
    scale++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "scale", &scale, 0)
        && scale == shape->scale)
      pass ();
    else
      fail ("SHAPE.scale [BD] set+1 %g != %g", shape->scale, scale);
    shape->scale--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "style", &style, NULL)
        && !memcmp (&style, &shape->style, sizeof (shape->style)))
        pass ();
    else
        fail ("SHAPE.style [H]");
  }
  {
    BITCODE_BS style_id;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "style_id", &style_id, NULL)
        && style_id == shape->style_id)
      pass ();
    else
      fail ("SHAPE.style_id [BS] %hu != %hu", shape->style_id, style_id);
    style_id++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "style_id", &style_id, 0)
        && style_id == shape->style_id)
      pass ();
    else
      fail ("SHAPE.style_id [BS] set+1 %hu != %hu", shape->style_id, style_id);
    shape->style_id--;
  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "thickness", &thickness, NULL)
        && thickness == shape->thickness)
      pass ();
    else
      fail ("SHAPE.thickness [BD] %g != %g", shape->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "thickness", &thickness, 0)
        && thickness == shape->thickness)
      pass ();
    else
      fail ("SHAPE.thickness [BD] set+1 %g != %g", shape->thickness, thickness);
    shape->thickness--;
  }
  {
    BITCODE_BD width_factor;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "width_factor", &width_factor, NULL)
        && width_factor == shape->width_factor)
      pass ();
    else
      fail ("SHAPE.width_factor [BD] %g != %g", shape->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "width_factor", &width_factor, 0)
        && width_factor == shape->width_factor)
      pass ();
    else
      fail ("SHAPE.width_factor [BD] set+1 %g != %g", shape->width_factor, width_factor);
    shape->width_factor--;
  }
  if (failed && (is_class_unstable ("SHAPE") || is_class_debugging ("SHAPE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SHAPE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SOLID (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SOLID *restrict solid = obj->tio.entity->tio.SOLID;
  failed = 0;
  {
    BITCODE_2RD corner1;
    if (dwg_dynapi_entity_value (solid, "SOLID", "corner1", &corner1, NULL)
        && !memcmp (&corner1, &solid->corner1, sizeof (solid->corner1)))
        pass ();
    else
        fail ("SOLID.corner1 [2RD]");
  }
  {
    BITCODE_2RD corner2;
    if (dwg_dynapi_entity_value (solid, "SOLID", "corner2", &corner2, NULL)
        && !memcmp (&corner2, &solid->corner2, sizeof (solid->corner2)))
        pass ();
    else
        fail ("SOLID.corner2 [2RD]");
  }
  {
    BITCODE_2RD corner3;
    if (dwg_dynapi_entity_value (solid, "SOLID", "corner3", &corner3, NULL)
        && !memcmp (&corner3, &solid->corner3, sizeof (solid->corner3)))
        pass ();
    else
        fail ("SOLID.corner3 [2RD]");
  }
  {
    BITCODE_2RD corner4;
    if (dwg_dynapi_entity_value (solid, "SOLID", "corner4", &corner4, NULL)
        && !memcmp (&corner4, &solid->corner4, sizeof (solid->corner4)))
        pass ();
    else
        fail ("SOLID.corner4 [2RD]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (solid, "SOLID", "elevation", &elevation, NULL)
        && elevation == solid->elevation)
      pass ();
    else
      fail ("SOLID.elevation [BD] %g != %g", solid->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (solid, "SOLID", "elevation", &elevation, 0)
        && elevation == solid->elevation)
      pass ();
    else
      fail ("SOLID.elevation [BD] set+1 %g != %g", solid->elevation, elevation);
    solid->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (solid, "SOLID", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &solid->extrusion, sizeof (solid->extrusion)))
        pass ();
    else
        fail ("SOLID.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (solid, "SOLID", "parent", &parent, NULL)
        && !memcmp (&parent, &solid->parent, sizeof (solid->parent)))
        pass ();
    else
        fail ("SOLID.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (solid, "SOLID", "thickness", &thickness, NULL)
        && thickness == solid->thickness)
      pass ();
    else
      fail ("SOLID.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", solid->thickness, thickness);
    if (dwg_dynapi_entity_set_value (solid, "SOLID", "thickness", &thickness, 0)
        && thickness == solid->thickness)
      pass ();
    else
      fail ("SOLID.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", solid->thickness, thickness);
    solid->thickness--;
  }
  if (failed && (is_class_unstable ("SOLID") || is_class_debugging ("SOLID")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SOLID", failed);
      failed = 0;
    }
  return failed;
}
static int test_SPLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SPLINE *restrict spline = obj->tio.entity->tio.SPLINE;
  failed = 0;
  {
    BITCODE_3BD beg_tan_vec;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "beg_tan_vec", &beg_tan_vec, NULL)
        && !memcmp (&beg_tan_vec, &spline->beg_tan_vec, sizeof (spline->beg_tan_vec)))
        pass ();
    else
        fail ("SPLINE.beg_tan_vec [3BD]");
  }
  {
    BITCODE_B closed_b;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "closed_b", &closed_b, NULL)
        && closed_b == spline->closed_b)
      pass ();
    else
      fail ("SPLINE.closed_b [B] " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b);
    closed_b++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "closed_b", &closed_b, 0)
        && closed_b == spline->closed_b)
      pass ();
    else
      fail ("SPLINE.closed_b [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b);
    spline->closed_b--;
  }
  {
    Dwg_SPLINE_control_point* ctrl_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_ctrl_pts", &count, NULL)
        && dwg_dynapi_entity_value (spline, "SPLINE", "ctrl_pts", &ctrl_pts, NULL)
        && ctrl_pts == spline->ctrl_pts)
      pass ();
    else
      fail ("SPLINE.ctrl_pts [Dwg_SPLINE_control_point*] * %u num_ctrl_pts", count);
  }
  {
    BITCODE_BD ctrl_tol;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "ctrl_tol", &ctrl_tol, NULL)
        && ctrl_tol == spline->ctrl_tol)
      pass ();
    else
      fail ("SPLINE.ctrl_tol [BD] %g != %g", spline->ctrl_tol, ctrl_tol);
    ctrl_tol++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "ctrl_tol", &ctrl_tol, 0)
        && ctrl_tol == spline->ctrl_tol)
      pass ();
    else
      fail ("SPLINE.ctrl_tol [BD] set+1 %g != %g", spline->ctrl_tol, ctrl_tol);
    spline->ctrl_tol--;
  }
  {
    BITCODE_BS degree;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "degree", &degree, NULL)
        && degree == spline->degree)
      pass ();
    else
      fail ("SPLINE.degree [BS] %hu != %hu", spline->degree, degree);
    degree++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "degree", &degree, 0)
        && degree == spline->degree)
      pass ();
    else
      fail ("SPLINE.degree [BS] set+1 %hu != %hu", spline->degree, degree);
    spline->degree--;
  }
  {
    BITCODE_3BD end_tan_vec;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "end_tan_vec", &end_tan_vec, NULL)
        && !memcmp (&end_tan_vec, &spline->end_tan_vec, sizeof (spline->end_tan_vec)))
        pass ();
    else
        fail ("SPLINE.end_tan_vec [3BD]");
  }
  {
    BITCODE_3DPOINT* fit_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_fit_pts", &count, NULL)
        && dwg_dynapi_entity_value (spline, "SPLINE", "fit_pts", &fit_pts, NULL)
        && fit_pts == spline->fit_pts)
      pass ();
    else
      fail ("SPLINE.fit_pts [3DPOINT*] * %u num_fit_pts", count);
  }
  {
    BITCODE_BD fit_tol;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "fit_tol", &fit_tol, NULL)
        && fit_tol == spline->fit_tol)
      pass ();
    else
      fail ("SPLINE.fit_tol [BD] %g != %g", spline->fit_tol, fit_tol);
    fit_tol++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "fit_tol", &fit_tol, 0)
        && fit_tol == spline->fit_tol)
      pass ();
    else
      fail ("SPLINE.fit_tol [BD] set+1 %g != %g", spline->fit_tol, fit_tol);
    spline->fit_tol--;
  }
  {
    BITCODE_RS flag;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "flag", &flag, NULL)
        && flag == spline->flag)
      pass ();
    else
      fail ("SPLINE.flag [RS] %hu != %hu", spline->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "flag", &flag, 0)
        && flag == spline->flag)
      pass ();
    else
      fail ("SPLINE.flag [RS] set+1 %hu != %hu", spline->flag, flag);
    spline->flag--;
  }
  {
    BITCODE_BD knot_tol;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "knot_tol", &knot_tol, NULL)
        && knot_tol == spline->knot_tol)
      pass ();
    else
      fail ("SPLINE.knot_tol [BD] %g != %g", spline->knot_tol, knot_tol);
    knot_tol++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "knot_tol", &knot_tol, 0)
        && knot_tol == spline->knot_tol)
      pass ();
    else
      fail ("SPLINE.knot_tol [BD] set+1 %g != %g", spline->knot_tol, knot_tol);
    spline->knot_tol--;
  }
  {
    BITCODE_BL knotparam;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "knotparam", &knotparam, NULL)
        && knotparam == spline->knotparam)
      pass ();
    else
      fail ("SPLINE.knotparam [BL] %u != %u", spline->knotparam, knotparam);
    knotparam++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "knotparam", &knotparam, 0)
        && knotparam == spline->knotparam)
      pass ();
    else
      fail ("SPLINE.knotparam [BL] set+1 %u != %u", spline->knotparam, knotparam);
    spline->knotparam--;
  }
  {
    BITCODE_BD* knots;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_knots", &count, NULL)
        && dwg_dynapi_entity_value (spline, "SPLINE", "knots", &knots, NULL)
        && knots == spline->knots)
      pass ();
    else
      fail ("SPLINE.knots [BD*] * %u num_knots", count);
  }
  {
    BITCODE_BL num_ctrl_pts;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts, NULL)
        && num_ctrl_pts == spline->num_ctrl_pts)
      pass ();
    else
      fail ("SPLINE.num_ctrl_pts [BL] %u != %u", spline->num_ctrl_pts, num_ctrl_pts);
    num_ctrl_pts++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts, 0)
        && num_ctrl_pts == spline->num_ctrl_pts)
      pass ();
    else
      fail ("SPLINE.num_ctrl_pts [BL] set+1 %u != %u", spline->num_ctrl_pts, num_ctrl_pts);
    spline->num_ctrl_pts--;
  }
  {
    BITCODE_BS num_fit_pts;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_fit_pts", &num_fit_pts, NULL)
        && num_fit_pts == spline->num_fit_pts)
      pass ();
    else
      fail ("SPLINE.num_fit_pts [BS] %hu != %hu", spline->num_fit_pts, num_fit_pts);
    num_fit_pts++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_fit_pts", &num_fit_pts, 0)
        && num_fit_pts == spline->num_fit_pts)
      pass ();
    else
      fail ("SPLINE.num_fit_pts [BS] set+1 %hu != %hu", spline->num_fit_pts, num_fit_pts);
    spline->num_fit_pts--;
  }
  {
    BITCODE_BL num_knots;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_knots", &num_knots, NULL)
        && num_knots == spline->num_knots)
      pass ();
    else
      fail ("SPLINE.num_knots [BL] %u != %u", spline->num_knots, num_knots);
    num_knots++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_knots", &num_knots, 0)
        && num_knots == spline->num_knots)
      pass ();
    else
      fail ("SPLINE.num_knots [BL] set+1 %u != %u", spline->num_knots, num_knots);
    spline->num_knots--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "parent", &parent, NULL)
        && !memcmp (&parent, &spline->parent, sizeof (spline->parent)))
        pass ();
    else
        fail ("SPLINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_B periodic;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "periodic", &periodic, NULL)
        && periodic == spline->periodic)
      pass ();
    else
      fail ("SPLINE.periodic [B] " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic);
    periodic++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "periodic", &periodic, 0)
        && periodic == spline->periodic)
      pass ();
    else
      fail ("SPLINE.periodic [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic);
    spline->periodic--;
  }
  {
    BITCODE_B rational;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "rational", &rational, NULL)
        && rational == spline->rational)
      pass ();
    else
      fail ("SPLINE.rational [B] " FORMAT_B " != " FORMAT_B "", spline->rational, rational);
    rational++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "rational", &rational, 0)
        && rational == spline->rational)
      pass ();
    else
      fail ("SPLINE.rational [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->rational, rational);
    spline->rational--;
  }
  {
    BITCODE_BS scenario;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "scenario", &scenario, NULL)
        && scenario == spline->scenario)
      pass ();
    else
      fail ("SPLINE.scenario [BS] %hu != %hu", spline->scenario, scenario);
    scenario++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "scenario", &scenario, 0)
        && scenario == spline->scenario)
      pass ();
    else
      fail ("SPLINE.scenario [BS] set+1 %hu != %hu", spline->scenario, scenario);
    spline->scenario--;
  }
  {
    BITCODE_BL splineflags1;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "splineflags1", &splineflags1, NULL)
        && splineflags1 == spline->splineflags1)
      pass ();
    else
      fail ("SPLINE.splineflags1 [BL] %u != %u", spline->splineflags1, splineflags1);
    splineflags1++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "splineflags1", &splineflags1, 0)
        && splineflags1 == spline->splineflags1)
      pass ();
    else
      fail ("SPLINE.splineflags1 [BL] set+1 %u != %u", spline->splineflags1, splineflags1);
    spline->splineflags1--;
  }
  {
    BITCODE_B weighted;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "weighted", &weighted, NULL)
        && weighted == spline->weighted)
      pass ();
    else
      fail ("SPLINE.weighted [B] " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted);
    weighted++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "weighted", &weighted, 0)
        && weighted == spline->weighted)
      pass ();
    else
      fail ("SPLINE.weighted [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted);
    spline->weighted--;
  }
  if (failed && (is_class_unstable ("SPLINE") || is_class_debugging ("SPLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SPLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SWEPTSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SWEPTSURFACE *restrict sweptsurface = obj->tio.entity->tio.SWEPTSURFACE;
  failed = 0;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)sweptsurface->acis_data)
           : !sweptsurface->acis_data)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, sweptsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == sweptsurface->acis_empty)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == sweptsurface->acis_empty)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty, acis_empty);
    sweptsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == sweptsurface->acis_empty2)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == sweptsurface->acis_empty2)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty2, acis_empty2);
    sweptsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == sweptsurface->acis_empty_bit)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == sweptsurface->acis_empty_bit)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty_bit, acis_empty_bit);
    sweptsurface->acis_empty_bit--;
  }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle, NULL)
        && align_angle == sweptsurface->align_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.align_angle [BD] %g != %g", sweptsurface->align_angle, align_angle);
    align_angle++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle, 0)
        && align_angle == sweptsurface->align_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.align_angle [BD] set+1 %g != %g", sweptsurface->align_angle, align_angle);
    sweptsurface->align_angle--;
  }
  {
    BITCODE_B align_start;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "align_start", &align_start, NULL)
        && align_start == sweptsurface->align_start)
      pass ();
    else
      fail ("SWEPTSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start);
    align_start++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "align_start", &align_start, 0)
        && align_start == sweptsurface->align_start)
      pass ();
    else
      fail ("SWEPTSURFACE.align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start);
    sweptsurface->align_start--;
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "bank", &bank, NULL)
        && bank == sweptsurface->bank)
      pass ();
    else
      fail ("SWEPTSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank);
    bank++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "bank", &bank, 0)
        && bank == sweptsurface->bank)
      pass ();
    else
      fail ("SWEPTSURFACE.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank);
    sweptsurface->bank--;
  }
  {
    BITCODE_B base_point_set;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set, NULL)
        && base_point_set == sweptsurface->base_point_set)
      pass ();
    else
      fail ("SWEPTSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set);
    base_point_set++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set, 0)
        && base_point_set == sweptsurface->base_point_set)
      pass ();
    else
      fail ("SWEPTSURFACE.base_point_set [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set);
    sweptsurface->base_point_set--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &sweptsurface->block_size, sizeof (sweptsurface->block_size)))
        pass ();
    else
        fail ("SWEPTSURFACE.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "class_version", &class_version, NULL)
        && class_version == sweptsurface->class_version)
      pass ();
    else
      fail ("SWEPTSURFACE.class_version [BL] %u != %u", sweptsurface->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "class_version", &class_version, 0)
        && class_version == sweptsurface->class_version)
      pass ();
    else
      fail ("SWEPTSURFACE.class_version [BL] set+1 %u != %u", sweptsurface->class_version, class_version);
    sweptsurface->class_version--;
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle, NULL)
        && draft_angle == sweptsurface->draft_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_angle [BD] %g != %g", sweptsurface->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle, 0)
        && draft_angle == sweptsurface->draft_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_angle [BD] set+1 %g != %g", sweptsurface->draft_angle, draft_angle);
    sweptsurface->draft_angle--;
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance, NULL)
        && draft_end_distance == sweptsurface->draft_end_distance)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_end_distance [BD] %g != %g", sweptsurface->draft_end_distance, draft_end_distance);
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance, 0)
        && draft_end_distance == sweptsurface->draft_end_distance)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_end_distance [BD] set+1 %g != %g", sweptsurface->draft_end_distance, draft_end_distance);
    sweptsurface->draft_end_distance--;
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance, NULL)
        && draft_start_distance == sweptsurface->draft_start_distance)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_start_distance [BD] %g != %g", sweptsurface->draft_start_distance, draft_start_distance);
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance, 0)
        && draft_start_distance == sweptsurface->draft_start_distance)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_start_distance [BD] set+1 %g != %g", sweptsurface->draft_start_distance, draft_start_distance);
    sweptsurface->draft_start_distance--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &sweptsurface->encr_sat_data, sizeof (sweptsurface->encr_sat_data)))
      pass ();
    else
      fail ("SWEPTSURFACE.encr_sat_data [char **]");
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &sweptsurface->extra_acis_data, sizeof (sweptsurface->extra_acis_data)))
        pass ();
    else
        fail ("SWEPTSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &sweptsurface->history_id, sizeof (sweptsurface->history_id)))
        pass ();
    else
        fail ("SWEPTSURFACE.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == sweptsurface->isoline_present)
      pass ();
    else
      fail ("SWEPTSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == sweptsurface->isoline_present)
      pass ();
    else
      fail ("SWEPTSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->isoline_present, isoline_present);
    sweptsurface->isoline_present--;
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == sweptsurface->modeler_format_version)
      pass ();
    else
      fail ("SWEPTSURFACE.modeler_format_version [BS] %hu != %hu", sweptsurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == sweptsurface->modeler_format_version)
      pass ();
    else
      fail ("SWEPTSURFACE.modeler_format_version [BS] set+1 %hu != %hu", sweptsurface->modeler_format_version, modeler_format_version);
    sweptsurface->modeler_format_version--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == sweptsurface->num_blocks)
      pass ();
    else
      fail ("SWEPTSURFACE.num_blocks [BL] %u != %u", sweptsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == sweptsurface->num_blocks)
      pass ();
    else
      fail ("SWEPTSURFACE.num_blocks [BL] set+1 %u != %u", sweptsurface->num_blocks, num_blocks);
    sweptsurface->num_blocks--;
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_isolines", &num_isolines, NULL)
        && num_isolines == sweptsurface->num_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.num_isolines [BL] %u != %u", sweptsurface->num_isolines, num_isolines);
    num_isolines++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_isolines", &num_isolines, 0)
        && num_isolines == sweptsurface->num_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.num_isolines [BL] set+1 %u != %u", sweptsurface->num_isolines, num_isolines);
    sweptsurface->num_isolines--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == sweptsurface->num_silhouettes)
      pass ();
    else
      fail ("SWEPTSURFACE.num_silhouettes [BL] %u != %u", sweptsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == sweptsurface->num_silhouettes)
      pass ();
    else
      fail ("SWEPTSURFACE.num_silhouettes [BL] set+1 %u != %u", sweptsurface->num_silhouettes, num_silhouettes);
    sweptsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == sweptsurface->num_wires)
      pass ();
    else
      fail ("SWEPTSURFACE.num_wires [BL] %u != %u", sweptsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires, 0)
        && num_wires == sweptsurface->num_wires)
      pass ();
    else
      fail ("SWEPTSURFACE.num_wires [BL] set+1 %u != %u", sweptsurface->num_wires, num_wires);
    sweptsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &sweptsurface->parent, sizeof (sweptsurface->parent)))
        pass ();
    else
        fail ("SWEPTSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BL path_entity_id;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id, NULL)
        && path_entity_id == sweptsurface->path_entity_id)
      pass ();
    else
      fail ("SWEPTSURFACE.path_entity_id [BL] %u != %u", sweptsurface->path_entity_id, path_entity_id);
    path_entity_id++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id, 0)
        && path_entity_id == sweptsurface->path_entity_id)
      pass ();
    else
      fail ("SWEPTSURFACE.path_entity_id [BL] set+1 %u != %u", sweptsurface->path_entity_id, path_entity_id);
    sweptsurface->path_entity_id--;
  }
  {
    BITCODE_B path_entity_transform_computed;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL)
        && path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
      pass ();
    else
      fail ("SWEPTSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed);
    path_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, 0)
        && path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
      pass ();
    else
      fail ("SWEPTSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed);
    sweptsurface->path_entity_transform_computed--;
  }
  {
    BITCODE_BD* path_entity_transmatrix;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
        && !memcmp (&path_entity_transmatrix, &sweptsurface->path_entity_transmatrix, sizeof (sweptsurface->path_entity_transmatrix)))
        pass ();
    else
        fail ("SWEPTSURFACE.path_entity_transmatrix [BD*]");
  }
  {
    BITCODE_BD* path_entity_transmatrix1;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_transmatrix1", &path_entity_transmatrix1, NULL)
        && !memcmp (&path_entity_transmatrix1, &sweptsurface->path_entity_transmatrix1, sizeof (sweptsurface->path_entity_transmatrix1)))
        pass ();
    else
        fail ("SWEPTSURFACE.path_entity_transmatrix1 [BD*]");
  }
  {
    BITCODE_TF pathdata;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "pathdata", &pathdata, NULL)
        && !memcmp (&pathdata, &sweptsurface->pathdata, sizeof (sweptsurface->pathdata)))
        pass ();
    else
        fail ("SWEPTSURFACE.pathdata [TF]");
  }
  {
    BITCODE_BL pathdata_size;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "pathdata_size", &pathdata_size, NULL)
        && pathdata_size == sweptsurface->pathdata_size)
      pass ();
    else
      fail ("SWEPTSURFACE.pathdata_size [BL] %u != %u", sweptsurface->pathdata_size, pathdata_size);
    pathdata_size++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "pathdata_size", &pathdata_size, 0)
        && pathdata_size == sweptsurface->pathdata_size)
      pass ();
    else
      fail ("SWEPTSURFACE.pathdata_size [BL] set+1 %u != %u", sweptsurface->pathdata_size, pathdata_size);
    sweptsurface->pathdata_size--;
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "point", &point, NULL)
        && !memcmp (&point, &sweptsurface->point, sizeof (sweptsurface->point)))
        pass ();
    else
        fail ("SWEPTSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "point_present", &point_present, NULL)
        && point_present == sweptsurface->point_present)
      pass ();
    else
      fail ("SWEPTSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "point_present", &point_present, 0)
        && point_present == sweptsurface->point_present)
      pass ();
    else
      fail ("SWEPTSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->point_present, point_present);
    sweptsurface->point_present--;
  }
  {
    BITCODE_3BD reference_vector_for_controlling_twist;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
        && !memcmp (&reference_vector_for_controlling_twist, &sweptsurface->reference_vector_for_controlling_twist, sizeof (sweptsurface->reference_vector_for_controlling_twist)))
        pass ();
    else
        fail ("SWEPTSURFACE.reference_vector_for_controlling_twist [3BD]");
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor, NULL)
        && scale_factor == sweptsurface->scale_factor)
      pass ();
    else
      fail ("SWEPTSURFACE.scale_factor [BD] %g != %g", sweptsurface->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor, 0)
        && scale_factor == sweptsurface->scale_factor)
      pass ();
    else
      fail ("SWEPTSURFACE.scale_factor [BD] set+1 %g != %g", sweptsurface->scale_factor, scale_factor);
    sweptsurface->scale_factor--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == sweptsurface->silhouettes)
      pass ();
    else
      fail ("SWEPTSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "solid", &solid, NULL)
        && solid == sweptsurface->solid)
      pass ();
    else
      fail ("SWEPTSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->solid, solid);
    solid++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "solid", &solid, 0)
        && solid == sweptsurface->solid)
      pass ();
    else
      fail ("SWEPTSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->solid, solid);
    sweptsurface->solid--;
  }
  {
    BITCODE_RC sweep_alignment;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_alignment", &sweep_alignment, NULL)
        && sweep_alignment == sweptsurface->sweep_alignment)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_alignment [RC] %u != %u", sweptsurface->sweep_alignment, sweep_alignment);
    sweep_alignment++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_alignment", &sweep_alignment, 0)
        && sweep_alignment == sweptsurface->sweep_alignment)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_alignment [RC] set+1 %u != %u", sweptsurface->sweep_alignment, sweep_alignment);
    sweptsurface->sweep_alignment--;
  }
  {
    BITCODE_BL sweep_entity_id;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id, NULL)
        && sweep_entity_id == sweptsurface->sweep_entity_id)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_entity_id [BL] %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id);
    sweep_entity_id++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id, 0)
        && sweep_entity_id == sweptsurface->sweep_entity_id)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_entity_id [BL] set+1 %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id);
    sweptsurface->sweep_entity_id--;
  }
  {
    BITCODE_B sweep_entity_transform_computed;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL)
        && sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
    sweep_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, 0)
        && sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
    sweptsurface->sweep_entity_transform_computed--;
  }
  {
    BITCODE_BD* sweep_entity_transmatrix;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
        && !memcmp (&sweep_entity_transmatrix, &sweptsurface->sweep_entity_transmatrix, sizeof (sweptsurface->sweep_entity_transmatrix)))
        pass ();
    else
        fail ("SWEPTSURFACE.sweep_entity_transmatrix [BD*]");
  }
  {
    BITCODE_BD* sweep_entity_transmatrix1;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transmatrix1", &sweep_entity_transmatrix1, NULL)
        && !memcmp (&sweep_entity_transmatrix1, &sweptsurface->sweep_entity_transmatrix1, sizeof (sweptsurface->sweep_entity_transmatrix1)))
        pass ();
    else
        fail ("SWEPTSURFACE.sweep_entity_transmatrix1 [BD*]");
  }
  {
    BITCODE_TF sweepdata;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweepdata", &sweepdata, NULL)
        && !memcmp (&sweepdata, &sweptsurface->sweepdata, sizeof (sweptsurface->sweepdata)))
        pass ();
    else
        fail ("SWEPTSURFACE.sweepdata [TF]");
  }
  {
    BITCODE_BL sweepdata_size;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweepdata_size", &sweepdata_size, NULL)
        && sweepdata_size == sweptsurface->sweepdata_size)
      pass ();
    else
      fail ("SWEPTSURFACE.sweepdata_size [BL] %u != %u", sweptsurface->sweepdata_size, sweepdata_size);
    sweepdata_size++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweepdata_size", &sweepdata_size, 0)
        && sweepdata_size == sweptsurface->sweepdata_size)
      pass ();
    else
      fail ("SWEPTSURFACE.sweepdata_size [BL] set+1 %u != %u", sweptsurface->sweepdata_size, sweepdata_size);
    sweptsurface->sweepdata_size--;
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle, NULL)
        && twist_angle == sweptsurface->twist_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.twist_angle [BD] %g != %g", sweptsurface->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle, 0)
        && twist_angle == sweptsurface->twist_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.twist_angle [BD] set+1 %g != %g", sweptsurface->twist_angle, twist_angle);
    sweptsurface->twist_angle--;
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == sweptsurface->u_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.u_isolines [BS] %hu != %hu", sweptsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == sweptsurface->u_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.u_isolines [BS] set+1 %hu != %hu", sweptsurface->u_isolines, u_isolines);
    sweptsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "unknown", &unknown, NULL)
        && unknown == sweptsurface->unknown)
      pass ();
    else
      fail ("SWEPTSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "unknown", &unknown, 0)
        && unknown == sweptsurface->unknown)
      pass ();
    else
      fail ("SWEPTSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->unknown, unknown);
    sweptsurface->unknown--;
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "unknown_2007", &unknown_2007, NULL)
        && unknown_2007 == sweptsurface->unknown_2007)
      pass ();
    else
      fail ("SWEPTSURFACE.unknown_2007 [BL] %u != %u", sweptsurface->unknown_2007, unknown_2007);
    unknown_2007++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "unknown_2007", &unknown_2007, 0)
        && unknown_2007 == sweptsurface->unknown_2007)
      pass ();
    else
      fail ("SWEPTSURFACE.unknown_2007 [BL] set+1 %u != %u", sweptsurface->unknown_2007, unknown_2007);
    sweptsurface->unknown_2007--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == sweptsurface->v_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.v_isolines [BS] %hu != %hu", sweptsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == sweptsurface->v_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.v_isolines [BS] set+1 %hu != %hu", sweptsurface->v_isolines, v_isolines);
    sweptsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "version", &version, NULL)
        && version == sweptsurface->version)
      pass ();
    else
      fail ("SWEPTSURFACE.version [BS] %hu != %hu", sweptsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "version", &version, 0)
        && version == sweptsurface->version)
      pass ();
    else
      fail ("SWEPTSURFACE.version [BS] set+1 %hu != %hu", sweptsurface->version, version);
    sweptsurface->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == sweptsurface->wireframe_data_present)
      pass ();
    else
      fail ("SWEPTSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == sweptsurface->wireframe_data_present)
      pass ();
    else
      fail ("SWEPTSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->wireframe_data_present, wireframe_data_present);
    sweptsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "wires", &wires, NULL)
        && wires == sweptsurface->wires)
      pass ();
    else
      fail ("SWEPTSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("SWEPTSURFACE") || is_class_debugging ("SWEPTSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SWEPTSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_TABLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_TABLE *restrict table = obj->tio.entity->tio.TABLE;
  failed = 0;
  {
    BITCODE_H* attrib_handles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "attrib_handles", &attrib_handles, NULL)
        && attrib_handles == table->attrib_handles)
      pass ();
    else
      fail ("TABLE.attrib_handles [H*] * %u num_owned", count);
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value (table, "TABLE", "block_header", &block_header, NULL)
        && !memcmp (&block_header, &table->block_header, sizeof (table->block_header)))
        pass ();
    else
        fail ("TABLE.block_header [H]");
  }
  {
    BITCODE_BL border_color_overrides_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "border_color_overrides_flag", &border_color_overrides_flag, NULL)
        && border_color_overrides_flag == table->border_color_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_color_overrides_flag [BL] %u != %u", table->border_color_overrides_flag, border_color_overrides_flag);
    border_color_overrides_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "border_color_overrides_flag", &border_color_overrides_flag, 0)
        && border_color_overrides_flag == table->border_color_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_color_overrides_flag [BL] set+1 %u != %u", table->border_color_overrides_flag, border_color_overrides_flag);
    table->border_color_overrides_flag--;
  }
  {
    BITCODE_BL border_lineweight_overrides_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "border_lineweight_overrides_flag", &border_lineweight_overrides_flag, NULL)
        && border_lineweight_overrides_flag == table->border_lineweight_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_lineweight_overrides_flag [BL] %u != %u", table->border_lineweight_overrides_flag, border_lineweight_overrides_flag);
    border_lineweight_overrides_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "border_lineweight_overrides_flag", &border_lineweight_overrides_flag, 0)
        && border_lineweight_overrides_flag == table->border_lineweight_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_lineweight_overrides_flag [BL] set+1 %u != %u", table->border_lineweight_overrides_flag, border_lineweight_overrides_flag);
    table->border_lineweight_overrides_flag--;
  }
  {
    BITCODE_BL border_visibility_overrides_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "border_visibility_overrides_flag", &border_visibility_overrides_flag, NULL)
        && border_visibility_overrides_flag == table->border_visibility_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_visibility_overrides_flag [BL] %u != %u", table->border_visibility_overrides_flag, border_visibility_overrides_flag);
    border_visibility_overrides_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "border_visibility_overrides_flag", &border_visibility_overrides_flag, 0)
        && border_visibility_overrides_flag == table->border_visibility_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_visibility_overrides_flag [BL] set+1 %u != %u", table->border_visibility_overrides_flag, border_visibility_overrides_flag);
    table->border_visibility_overrides_flag--;
  }
  {
    BITCODE_BL break_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_flag", &break_flag, NULL)
        && break_flag == table->break_flag)
      pass ();
    else
      fail ("TABLE.break_flag [BL] %u != %u", table->break_flag, break_flag);
    break_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_flag", &break_flag, 0)
        && break_flag == table->break_flag)
      pass ();
    else
      fail ("TABLE.break_flag [BL] set+1 %u != %u", table->break_flag, break_flag);
    table->break_flag--;
  }
  {
    BITCODE_BL break_flow_direction;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_flow_direction", &break_flow_direction, NULL)
        && break_flow_direction == table->break_flow_direction)
      pass ();
    else
      fail ("TABLE.break_flow_direction [BL] %u != %u", table->break_flow_direction, break_flow_direction);
    break_flow_direction++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_flow_direction", &break_flow_direction, 0)
        && break_flow_direction == table->break_flow_direction)
      pass ();
    else
      fail ("TABLE.break_flow_direction [BL] set+1 %u != %u", table->break_flow_direction, break_flow_direction);
    table->break_flow_direction--;
  }
  {
    Dwg_TABLE_BreakHeight* break_heights;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_break_heights", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "break_heights", &break_heights, NULL)
        && break_heights == table->break_heights)
      pass ();
    else
      fail ("TABLE.break_heights [Dwg_TABLE_BreakHeight*] * %u num_break_heights", count);
  }
  {
    Dwg_TABLE_BreakRow* break_rows;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_break_rows", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "break_rows", &break_rows, NULL)
        && break_rows == table->break_rows)
      pass ();
    else
      fail ("TABLE.break_rows [Dwg_TABLE_BreakRow*] * %u num_break_rows", count);
  }
  {
    BITCODE_BD break_spacing;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_spacing", &break_spacing, NULL)
        && break_spacing == table->break_spacing)
      pass ();
    else
      fail ("TABLE.break_spacing [BD] %g != %g", table->break_spacing, break_spacing);
    break_spacing++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_spacing", &break_spacing, 0)
        && break_spacing == table->break_spacing)
      pass ();
    else
      fail ("TABLE.break_spacing [BD] set+1 %g != %g", table->break_spacing, break_spacing);
    table->break_spacing--;
  }
  {
    BITCODE_BL break_unknown1;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_unknown1", &break_unknown1, NULL)
        && break_unknown1 == table->break_unknown1)
      pass ();
    else
      fail ("TABLE.break_unknown1 [BL] %u != %u", table->break_unknown1, break_unknown1);
    break_unknown1++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_unknown1", &break_unknown1, 0)
        && break_unknown1 == table->break_unknown1)
      pass ();
    else
      fail ("TABLE.break_unknown1 [BL] set+1 %u != %u", table->break_unknown1, break_unknown1);
    table->break_unknown1--;
  }
  {
    BITCODE_BL break_unknown2;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_unknown2", &break_unknown2, NULL)
        && break_unknown2 == table->break_unknown2)
      pass ();
    else
      fail ("TABLE.break_unknown2 [BL] %u != %u", table->break_unknown2, break_unknown2);
    break_unknown2++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_unknown2", &break_unknown2, 0)
        && break_unknown2 == table->break_unknown2)
      pass ();
    else
      fail ("TABLE.break_unknown2 [BL] set+1 %u != %u", table->break_unknown2, break_unknown2);
    table->break_unknown2--;
  }
  {
    Dwg_TABLE_Cell* cells;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_cells", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "cells", &cells, NULL)
        && cells == table->cells)
      pass ();
    else
      fail ("TABLE.cells [Dwg_TABLE_Cell*] * %u num_cells", count);
  }
  {
    BITCODE_BD* col_widths;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_col_widths", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "col_widths", &col_widths, NULL)
        && col_widths == table->col_widths)
      pass ();
    else
      fail ("TABLE.col_widths [BD*] * %u num_col_widths", count);
  }
  {
    BITCODE_BB data_flags;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_flags", &data_flags, NULL)
        && data_flags == table->data_flags)
      pass ();
    else
      fail ("TABLE.data_flags [BB] " FORMAT_BB " != " FORMAT_BB "", table->data_flags, data_flags);
    data_flags++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_flags", &data_flags, 0)
        && data_flags == table->data_flags)
      pass ();
    else
      fail ("TABLE.data_flags [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", table->data_flags, data_flags);
    table->data_flags--;
  }
  {
    BITCODE_CMC data_horiz_bottom_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_bottom_color", &data_horiz_bottom_color, NULL)
        && !memcmp (&data_horiz_bottom_color, &table->data_horiz_bottom_color, sizeof (table->data_horiz_bottom_color)))
        pass ();
    else
        fail ("TABLE.data_horiz_bottom_color [CMC]");
  }
  {
    BITCODE_BS data_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_bottom_linewt", &data_horiz_bottom_linewt, NULL)
        && data_horiz_bottom_linewt == table->data_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_bottom_linewt [BS] %hu != %hu", table->data_horiz_bottom_linewt, data_horiz_bottom_linewt);
    data_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_bottom_linewt", &data_horiz_bottom_linewt, 0)
        && data_horiz_bottom_linewt == table->data_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->data_horiz_bottom_linewt, data_horiz_bottom_linewt);
    table->data_horiz_bottom_linewt--;
  }
  {
    BITCODE_BS data_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_bottom_visibility", &data_horiz_bottom_visibility, NULL)
        && data_horiz_bottom_visibility == table->data_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_bottom_visibility [BS] %hu != %hu", table->data_horiz_bottom_visibility, data_horiz_bottom_visibility);
    data_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_bottom_visibility", &data_horiz_bottom_visibility, 0)
        && data_horiz_bottom_visibility == table->data_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->data_horiz_bottom_visibility, data_horiz_bottom_visibility);
    table->data_horiz_bottom_visibility--;
  }
  {
    BITCODE_CMC data_horiz_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_ins_color", &data_horiz_ins_color, NULL)
        && !memcmp (&data_horiz_ins_color, &table->data_horiz_ins_color, sizeof (table->data_horiz_ins_color)))
        pass ();
    else
        fail ("TABLE.data_horiz_ins_color [CMC]");
  }
  {
    BITCODE_BS data_horiz_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_ins_linewt", &data_horiz_ins_linewt, NULL)
        && data_horiz_ins_linewt == table->data_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_ins_linewt [BS] %hu != %hu", table->data_horiz_ins_linewt, data_horiz_ins_linewt);
    data_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_ins_linewt", &data_horiz_ins_linewt, 0)
        && data_horiz_ins_linewt == table->data_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_ins_linewt [BS] set+1 %hu != %hu", table->data_horiz_ins_linewt, data_horiz_ins_linewt);
    table->data_horiz_ins_linewt--;
  }
  {
    BITCODE_BS data_horiz_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_ins_visibility", &data_horiz_ins_visibility, NULL)
        && data_horiz_ins_visibility == table->data_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_ins_visibility [BS] %hu != %hu", table->data_horiz_ins_visibility, data_horiz_ins_visibility);
    data_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_ins_visibility", &data_horiz_ins_visibility, 0)
        && data_horiz_ins_visibility == table->data_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_ins_visibility [BS] set+1 %hu != %hu", table->data_horiz_ins_visibility, data_horiz_ins_visibility);
    table->data_horiz_ins_visibility--;
  }
  {
    BITCODE_CMC data_horiz_top_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_top_color", &data_horiz_top_color, NULL)
        && !memcmp (&data_horiz_top_color, &table->data_horiz_top_color, sizeof (table->data_horiz_top_color)))
        pass ();
    else
        fail ("TABLE.data_horiz_top_color [CMC]");
  }
  {
    BITCODE_BS data_horiz_top_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_top_linewt", &data_horiz_top_linewt, NULL)
        && data_horiz_top_linewt == table->data_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_top_linewt [BS] %hu != %hu", table->data_horiz_top_linewt, data_horiz_top_linewt);
    data_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_top_linewt", &data_horiz_top_linewt, 0)
        && data_horiz_top_linewt == table->data_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_top_linewt [BS] set+1 %hu != %hu", table->data_horiz_top_linewt, data_horiz_top_linewt);
    table->data_horiz_top_linewt--;
  }
  {
    BITCODE_BS data_horiz_top_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_top_visibility", &data_horiz_top_visibility, NULL)
        && data_horiz_top_visibility == table->data_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_top_visibility [BS] %hu != %hu", table->data_horiz_top_visibility, data_horiz_top_visibility);
    data_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_top_visibility", &data_horiz_top_visibility, 0)
        && data_horiz_top_visibility == table->data_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_top_visibility [BS] set+1 %hu != %hu", table->data_horiz_top_visibility, data_horiz_top_visibility);
    table->data_horiz_top_visibility--;
  }
  {
    BITCODE_BS data_row_alignment;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_alignment", &data_row_alignment, NULL)
        && data_row_alignment == table->data_row_alignment)
      pass ();
    else
      fail ("TABLE.data_row_alignment [BS] %hu != %hu", table->data_row_alignment, data_row_alignment);
    data_row_alignment++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_row_alignment", &data_row_alignment, 0)
        && data_row_alignment == table->data_row_alignment)
      pass ();
    else
      fail ("TABLE.data_row_alignment [BS] set+1 %hu != %hu", table->data_row_alignment, data_row_alignment);
    table->data_row_alignment--;
  }
  {
    BITCODE_CMC data_row_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_color", &data_row_color, NULL)
        && !memcmp (&data_row_color, &table->data_row_color, sizeof (table->data_row_color)))
        pass ();
    else
        fail ("TABLE.data_row_color [CMC]");
  }
  {
    BITCODE_CMC data_row_fill_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_fill_color", &data_row_fill_color, NULL)
        && !memcmp (&data_row_fill_color, &table->data_row_fill_color, sizeof (table->data_row_fill_color)))
        pass ();
    else
        fail ("TABLE.data_row_fill_color [CMC]");
  }
  {
    BITCODE_B data_row_fill_none;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_fill_none", &data_row_fill_none, NULL)
        && data_row_fill_none == table->data_row_fill_none)
      pass ();
    else
      fail ("TABLE.data_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->data_row_fill_none, data_row_fill_none);
    data_row_fill_none++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_row_fill_none", &data_row_fill_none, 0)
        && data_row_fill_none == table->data_row_fill_none)
      pass ();
    else
      fail ("TABLE.data_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->data_row_fill_none, data_row_fill_none);
    table->data_row_fill_none--;
  }
  {
    BITCODE_BD data_row_height;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_height", &data_row_height, NULL)
        && data_row_height == table->data_row_height)
      pass ();
    else
      fail ("TABLE.data_row_height [BD] %g != %g", table->data_row_height, data_row_height);
    data_row_height++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_row_height", &data_row_height, 0)
        && data_row_height == table->data_row_height)
      pass ();
    else
      fail ("TABLE.data_row_height [BD] set+1 %g != %g", table->data_row_height, data_row_height);
    table->data_row_height--;
  }
  {
    BITCODE_H data_row_style_override;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_style_override", &data_row_style_override, NULL)
        && !memcmp (&data_row_style_override, &table->data_row_style_override, sizeof (table->data_row_style_override)))
        pass ();
    else
        fail ("TABLE.data_row_style_override [H]");
  }
  {
    BITCODE_H data_text_style;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_text_style", &data_text_style, NULL)
        && !memcmp (&data_text_style, &table->data_text_style, sizeof (table->data_text_style)))
        pass ();
    else
        fail ("TABLE.data_text_style [H]");
  }
  {
    BITCODE_CMC data_vert_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_ins_color", &data_vert_ins_color, NULL)
        && !memcmp (&data_vert_ins_color, &table->data_vert_ins_color, sizeof (table->data_vert_ins_color)))
        pass ();
    else
        fail ("TABLE.data_vert_ins_color [CMC]");
  }
  {
    BITCODE_BS data_vert_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_ins_linewt", &data_vert_ins_linewt, NULL)
        && data_vert_ins_linewt == table->data_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_ins_linewt [BS] %hu != %hu", table->data_vert_ins_linewt, data_vert_ins_linewt);
    data_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_ins_linewt", &data_vert_ins_linewt, 0)
        && data_vert_ins_linewt == table->data_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_ins_linewt [BS] set+1 %hu != %hu", table->data_vert_ins_linewt, data_vert_ins_linewt);
    table->data_vert_ins_linewt--;
  }
  {
    BITCODE_BS data_vert_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_ins_visibility", &data_vert_ins_visibility, NULL)
        && data_vert_ins_visibility == table->data_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_ins_visibility [BS] %hu != %hu", table->data_vert_ins_visibility, data_vert_ins_visibility);
    data_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_ins_visibility", &data_vert_ins_visibility, 0)
        && data_vert_ins_visibility == table->data_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_ins_visibility [BS] set+1 %hu != %hu", table->data_vert_ins_visibility, data_vert_ins_visibility);
    table->data_vert_ins_visibility--;
  }
  {
    BITCODE_CMC data_vert_left_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_left_color", &data_vert_left_color, NULL)
        && !memcmp (&data_vert_left_color, &table->data_vert_left_color, sizeof (table->data_vert_left_color)))
        pass ();
    else
        fail ("TABLE.data_vert_left_color [CMC]");
  }
  {
    BITCODE_BS data_vert_left_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_left_linewt", &data_vert_left_linewt, NULL)
        && data_vert_left_linewt == table->data_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_left_linewt [BS] %hu != %hu", table->data_vert_left_linewt, data_vert_left_linewt);
    data_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_left_linewt", &data_vert_left_linewt, 0)
        && data_vert_left_linewt == table->data_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_left_linewt [BS] set+1 %hu != %hu", table->data_vert_left_linewt, data_vert_left_linewt);
    table->data_vert_left_linewt--;
  }
  {
    BITCODE_BS data_vert_left_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_left_visibility", &data_vert_left_visibility, NULL)
        && data_vert_left_visibility == table->data_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_left_visibility [BS] %hu != %hu", table->data_vert_left_visibility, data_vert_left_visibility);
    data_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_left_visibility", &data_vert_left_visibility, 0)
        && data_vert_left_visibility == table->data_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_left_visibility [BS] set+1 %hu != %hu", table->data_vert_left_visibility, data_vert_left_visibility);
    table->data_vert_left_visibility--;
  }
  {
    BITCODE_CMC data_vert_right_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_right_color", &data_vert_right_color, NULL)
        && !memcmp (&data_vert_right_color, &table->data_vert_right_color, sizeof (table->data_vert_right_color)))
        pass ();
    else
        fail ("TABLE.data_vert_right_color [CMC]");
  }
  {
    BITCODE_BS data_vert_right_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_right_linewt", &data_vert_right_linewt, NULL)
        && data_vert_right_linewt == table->data_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_right_linewt [BS] %hu != %hu", table->data_vert_right_linewt, data_vert_right_linewt);
    data_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_right_linewt", &data_vert_right_linewt, 0)
        && data_vert_right_linewt == table->data_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_right_linewt [BS] set+1 %hu != %hu", table->data_vert_right_linewt, data_vert_right_linewt);
    table->data_vert_right_linewt--;
  }
  {
    BITCODE_BS data_vert_right_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_right_visibility", &data_vert_right_visibility, NULL)
        && data_vert_right_visibility == table->data_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_right_visibility [BS] %hu != %hu", table->data_vert_right_visibility, data_vert_right_visibility);
    data_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_right_visibility", &data_vert_right_visibility, 0)
        && data_vert_right_visibility == table->data_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_right_visibility [BS] set+1 %hu != %hu", table->data_vert_right_visibility, data_vert_right_visibility);
    table->data_vert_right_visibility--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (table, "TABLE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &table->extrusion, sizeof (table->extrusion)))
        pass ();
    else
        fail ("TABLE.extrusion [BE]");
  }
  {
    Dwg_FormattedTableData fdata;
    if (dwg_dynapi_entity_value (table, "TABLE", "fdata", &fdata, NULL)
        && !memcmp (&fdata, &table->fdata, sizeof (table->fdata)))
        pass ();
    else
        fail ("TABLE.fdata [Dwg_FormattedTableData]");
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value (table, "TABLE", "first_attrib", &first_attrib, NULL)
        && !memcmp (&first_attrib, &table->first_attrib, sizeof (table->first_attrib)))
        pass ();
    else
        fail ("TABLE.first_attrib [H]");
  }
  {
    BITCODE_BS flag_for_table_value;
    if (dwg_dynapi_entity_value (table, "TABLE", "flag_for_table_value", &flag_for_table_value, NULL)
        && flag_for_table_value == table->flag_for_table_value)
      pass ();
    else
      fail ("TABLE.flag_for_table_value [BS] %hu != %hu", table->flag_for_table_value, flag_for_table_value);
    flag_for_table_value++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "flag_for_table_value", &flag_for_table_value, 0)
        && flag_for_table_value == table->flag_for_table_value)
      pass ();
    else
      fail ("TABLE.flag_for_table_value [BS] set+1 %hu != %hu", table->flag_for_table_value, flag_for_table_value);
    table->flag_for_table_value--;
  }
  {
    BITCODE_BS flow_direction;
    if (dwg_dynapi_entity_value (table, "TABLE", "flow_direction", &flow_direction, NULL)
        && flow_direction == table->flow_direction)
      pass ();
    else
      fail ("TABLE.flow_direction [BS] %hu != %hu", table->flow_direction, flow_direction);
    flow_direction++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "flow_direction", &flow_direction, 0)
        && flow_direction == table->flow_direction)
      pass ();
    else
      fail ("TABLE.flow_direction [BS] set+1 %hu != %hu", table->flow_direction, flow_direction);
    table->flow_direction--;
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_attribs", &has_attribs, NULL)
        && has_attribs == table->has_attribs)
      pass ();
    else
      fail ("TABLE.has_attribs [B] " FORMAT_B " != " FORMAT_B "", table->has_attribs, has_attribs);
    has_attribs++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_attribs", &has_attribs, 0)
        && has_attribs == table->has_attribs)
      pass ();
    else
      fail ("TABLE.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_attribs, has_attribs);
    table->has_attribs--;
  }
  {
    BITCODE_B has_border_color_overrides;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_border_color_overrides", &has_border_color_overrides, NULL)
        && has_border_color_overrides == table->has_border_color_overrides)
      pass ();
    else
      fail ("TABLE.has_border_color_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_color_overrides, has_border_color_overrides);
    has_border_color_overrides++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_border_color_overrides", &has_border_color_overrides, 0)
        && has_border_color_overrides == table->has_border_color_overrides)
      pass ();
    else
      fail ("TABLE.has_border_color_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_color_overrides, has_border_color_overrides);
    table->has_border_color_overrides--;
  }
  {
    BITCODE_B has_border_lineweight_overrides;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_border_lineweight_overrides", &has_border_lineweight_overrides, NULL)
        && has_border_lineweight_overrides == table->has_border_lineweight_overrides)
      pass ();
    else
      fail ("TABLE.has_border_lineweight_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_lineweight_overrides, has_border_lineweight_overrides);
    has_border_lineweight_overrides++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_border_lineweight_overrides", &has_border_lineweight_overrides, 0)
        && has_border_lineweight_overrides == table->has_border_lineweight_overrides)
      pass ();
    else
      fail ("TABLE.has_border_lineweight_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_lineweight_overrides, has_border_lineweight_overrides);
    table->has_border_lineweight_overrides--;
  }
  {
    BITCODE_B has_border_visibility_overrides;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_border_visibility_overrides", &has_border_visibility_overrides, NULL)
        && has_border_visibility_overrides == table->has_border_visibility_overrides)
      pass ();
    else
      fail ("TABLE.has_border_visibility_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_visibility_overrides, has_border_visibility_overrides);
    has_border_visibility_overrides++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_border_visibility_overrides", &has_border_visibility_overrides, 0)
        && has_border_visibility_overrides == table->has_border_visibility_overrides)
      pass ();
    else
      fail ("TABLE.has_border_visibility_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_visibility_overrides, has_border_visibility_overrides);
    table->has_border_visibility_overrides--;
  }
  {
    BITCODE_BL has_break_data;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_break_data", &has_break_data, NULL)
        && has_break_data == table->has_break_data)
      pass ();
    else
      fail ("TABLE.has_break_data [BL] %u != %u", table->has_break_data, has_break_data);
    has_break_data++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_break_data", &has_break_data, 0)
        && has_break_data == table->has_break_data)
      pass ();
    else
      fail ("TABLE.has_break_data [BL] set+1 %u != %u", table->has_break_data, has_break_data);
    table->has_break_data--;
  }
  {
    BITCODE_B has_table_overrides;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_table_overrides", &has_table_overrides, NULL)
        && has_table_overrides == table->has_table_overrides)
      pass ();
    else
      fail ("TABLE.has_table_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_table_overrides, has_table_overrides);
    has_table_overrides++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_table_overrides", &has_table_overrides, 0)
        && has_table_overrides == table->has_table_overrides)
      pass ();
    else
      fail ("TABLE.has_table_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_table_overrides, has_table_overrides);
    table->has_table_overrides--;
  }
  {
    BITCODE_CMC header_horiz_bottom_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_bottom_color", &header_horiz_bottom_color, NULL)
        && !memcmp (&header_horiz_bottom_color, &table->header_horiz_bottom_color, sizeof (table->header_horiz_bottom_color)))
        pass ();
    else
        fail ("TABLE.header_horiz_bottom_color [CMC]");
  }
  {
    BITCODE_BS header_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_bottom_linewt", &header_horiz_bottom_linewt, NULL)
        && header_horiz_bottom_linewt == table->header_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_bottom_linewt [BS] %hu != %hu", table->header_horiz_bottom_linewt, header_horiz_bottom_linewt);
    header_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_bottom_linewt", &header_horiz_bottom_linewt, 0)
        && header_horiz_bottom_linewt == table->header_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->header_horiz_bottom_linewt, header_horiz_bottom_linewt);
    table->header_horiz_bottom_linewt--;
  }
  {
    BITCODE_BS header_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_bottom_visibility", &header_horiz_bottom_visibility, NULL)
        && header_horiz_bottom_visibility == table->header_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_bottom_visibility [BS] %hu != %hu", table->header_horiz_bottom_visibility, header_horiz_bottom_visibility);
    header_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_bottom_visibility", &header_horiz_bottom_visibility, 0)
        && header_horiz_bottom_visibility == table->header_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->header_horiz_bottom_visibility, header_horiz_bottom_visibility);
    table->header_horiz_bottom_visibility--;
  }
  {
    BITCODE_CMC header_horiz_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_ins_color", &header_horiz_ins_color, NULL)
        && !memcmp (&header_horiz_ins_color, &table->header_horiz_ins_color, sizeof (table->header_horiz_ins_color)))
        pass ();
    else
        fail ("TABLE.header_horiz_ins_color [CMC]");
  }
  {
    BITCODE_BS header_horiz_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_ins_linewt", &header_horiz_ins_linewt, NULL)
        && header_horiz_ins_linewt == table->header_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_ins_linewt [BS] %hu != %hu", table->header_horiz_ins_linewt, header_horiz_ins_linewt);
    header_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_ins_linewt", &header_horiz_ins_linewt, 0)
        && header_horiz_ins_linewt == table->header_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_ins_linewt [BS] set+1 %hu != %hu", table->header_horiz_ins_linewt, header_horiz_ins_linewt);
    table->header_horiz_ins_linewt--;
  }
  {
    BITCODE_BS header_horiz_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_ins_visibility", &header_horiz_ins_visibility, NULL)
        && header_horiz_ins_visibility == table->header_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_ins_visibility [BS] %hu != %hu", table->header_horiz_ins_visibility, header_horiz_ins_visibility);
    header_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_ins_visibility", &header_horiz_ins_visibility, 0)
        && header_horiz_ins_visibility == table->header_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_ins_visibility [BS] set+1 %hu != %hu", table->header_horiz_ins_visibility, header_horiz_ins_visibility);
    table->header_horiz_ins_visibility--;
  }
  {
    BITCODE_CMC header_horiz_top_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_top_color", &header_horiz_top_color, NULL)
        && !memcmp (&header_horiz_top_color, &table->header_horiz_top_color, sizeof (table->header_horiz_top_color)))
        pass ();
    else
        fail ("TABLE.header_horiz_top_color [CMC]");
  }
  {
    BITCODE_BS header_horiz_top_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_top_linewt", &header_horiz_top_linewt, NULL)
        && header_horiz_top_linewt == table->header_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_top_linewt [BS] %hu != %hu", table->header_horiz_top_linewt, header_horiz_top_linewt);
    header_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_top_linewt", &header_horiz_top_linewt, 0)
        && header_horiz_top_linewt == table->header_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_top_linewt [BS] set+1 %hu != %hu", table->header_horiz_top_linewt, header_horiz_top_linewt);
    table->header_horiz_top_linewt--;
  }
  {
    BITCODE_BS header_horiz_top_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_top_visibility", &header_horiz_top_visibility, NULL)
        && header_horiz_top_visibility == table->header_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_top_visibility [BS] %hu != %hu", table->header_horiz_top_visibility, header_horiz_top_visibility);
    header_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_top_visibility", &header_horiz_top_visibility, 0)
        && header_horiz_top_visibility == table->header_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_top_visibility [BS] set+1 %hu != %hu", table->header_horiz_top_visibility, header_horiz_top_visibility);
    table->header_horiz_top_visibility--;
  }
  {
    BITCODE_BS header_row_alignment;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_alignment", &header_row_alignment, NULL)
        && header_row_alignment == table->header_row_alignment)
      pass ();
    else
      fail ("TABLE.header_row_alignment [BS] %hu != %hu", table->header_row_alignment, header_row_alignment);
    header_row_alignment++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_row_alignment", &header_row_alignment, 0)
        && header_row_alignment == table->header_row_alignment)
      pass ();
    else
      fail ("TABLE.header_row_alignment [BS] set+1 %hu != %hu", table->header_row_alignment, header_row_alignment);
    table->header_row_alignment--;
  }
  {
    BITCODE_CMC header_row_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_color", &header_row_color, NULL)
        && !memcmp (&header_row_color, &table->header_row_color, sizeof (table->header_row_color)))
        pass ();
    else
        fail ("TABLE.header_row_color [CMC]");
  }
  {
    BITCODE_CMC header_row_fill_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_fill_color", &header_row_fill_color, NULL)
        && !memcmp (&header_row_fill_color, &table->header_row_fill_color, sizeof (table->header_row_fill_color)))
        pass ();
    else
        fail ("TABLE.header_row_fill_color [CMC]");
  }
  {
    BITCODE_B header_row_fill_none;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_fill_none", &header_row_fill_none, NULL)
        && header_row_fill_none == table->header_row_fill_none)
      pass ();
    else
      fail ("TABLE.header_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->header_row_fill_none, header_row_fill_none);
    header_row_fill_none++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_row_fill_none", &header_row_fill_none, 0)
        && header_row_fill_none == table->header_row_fill_none)
      pass ();
    else
      fail ("TABLE.header_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->header_row_fill_none, header_row_fill_none);
    table->header_row_fill_none--;
  }
  {
    BITCODE_BD header_row_height;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_height", &header_row_height, NULL)
        && header_row_height == table->header_row_height)
      pass ();
    else
      fail ("TABLE.header_row_height [BD] %g != %g", table->header_row_height, header_row_height);
    header_row_height++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_row_height", &header_row_height, 0)
        && header_row_height == table->header_row_height)
      pass ();
    else
      fail ("TABLE.header_row_height [BD] set+1 %g != %g", table->header_row_height, header_row_height);
    table->header_row_height--;
  }
  {
    BITCODE_H header_row_style_override;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_style_override", &header_row_style_override, NULL)
        && !memcmp (&header_row_style_override, &table->header_row_style_override, sizeof (table->header_row_style_override)))
        pass ();
    else
        fail ("TABLE.header_row_style_override [H]");
  }
  {
    BITCODE_B header_suppressed;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_suppressed", &header_suppressed, NULL)
        && header_suppressed == table->header_suppressed)
      pass ();
    else
      fail ("TABLE.header_suppressed [B] " FORMAT_B " != " FORMAT_B "", table->header_suppressed, header_suppressed);
    header_suppressed++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_suppressed", &header_suppressed, 0)
        && header_suppressed == table->header_suppressed)
      pass ();
    else
      fail ("TABLE.header_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", table->header_suppressed, header_suppressed);
    table->header_suppressed--;
  }
  {
    BITCODE_H header_text_style;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_text_style", &header_text_style, NULL)
        && !memcmp (&header_text_style, &table->header_text_style, sizeof (table->header_text_style)))
        pass ();
    else
        fail ("TABLE.header_text_style [H]");
  }
  {
    BITCODE_CMC header_vert_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_ins_color", &header_vert_ins_color, NULL)
        && !memcmp (&header_vert_ins_color, &table->header_vert_ins_color, sizeof (table->header_vert_ins_color)))
        pass ();
    else
        fail ("TABLE.header_vert_ins_color [CMC]");
  }
  {
    BITCODE_BS header_vert_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_ins_linewt", &header_vert_ins_linewt, NULL)
        && header_vert_ins_linewt == table->header_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_ins_linewt [BS] %hu != %hu", table->header_vert_ins_linewt, header_vert_ins_linewt);
    header_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_ins_linewt", &header_vert_ins_linewt, 0)
        && header_vert_ins_linewt == table->header_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_ins_linewt [BS] set+1 %hu != %hu", table->header_vert_ins_linewt, header_vert_ins_linewt);
    table->header_vert_ins_linewt--;
  }
  {
    BITCODE_BS header_vert_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_ins_visibility", &header_vert_ins_visibility, NULL)
        && header_vert_ins_visibility == table->header_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_ins_visibility [BS] %hu != %hu", table->header_vert_ins_visibility, header_vert_ins_visibility);
    header_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_ins_visibility", &header_vert_ins_visibility, 0)
        && header_vert_ins_visibility == table->header_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_ins_visibility [BS] set+1 %hu != %hu", table->header_vert_ins_visibility, header_vert_ins_visibility);
    table->header_vert_ins_visibility--;
  }
  {
    BITCODE_CMC header_vert_left_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_left_color", &header_vert_left_color, NULL)
        && !memcmp (&header_vert_left_color, &table->header_vert_left_color, sizeof (table->header_vert_left_color)))
        pass ();
    else
        fail ("TABLE.header_vert_left_color [CMC]");
  }
  {
    BITCODE_BS header_vert_left_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_left_linewt", &header_vert_left_linewt, NULL)
        && header_vert_left_linewt == table->header_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_left_linewt [BS] %hu != %hu", table->header_vert_left_linewt, header_vert_left_linewt);
    header_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_left_linewt", &header_vert_left_linewt, 0)
        && header_vert_left_linewt == table->header_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_left_linewt [BS] set+1 %hu != %hu", table->header_vert_left_linewt, header_vert_left_linewt);
    table->header_vert_left_linewt--;
  }
  {
    BITCODE_BS header_vert_left_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_left_visibility", &header_vert_left_visibility, NULL)
        && header_vert_left_visibility == table->header_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_left_visibility [BS] %hu != %hu", table->header_vert_left_visibility, header_vert_left_visibility);
    header_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_left_visibility", &header_vert_left_visibility, 0)
        && header_vert_left_visibility == table->header_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_left_visibility [BS] set+1 %hu != %hu", table->header_vert_left_visibility, header_vert_left_visibility);
    table->header_vert_left_visibility--;
  }
  {
    BITCODE_CMC header_vert_right_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_right_color", &header_vert_right_color, NULL)
        && !memcmp (&header_vert_right_color, &table->header_vert_right_color, sizeof (table->header_vert_right_color)))
        pass ();
    else
        fail ("TABLE.header_vert_right_color [CMC]");
  }
  {
    BITCODE_BS header_vert_right_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_right_linewt", &header_vert_right_linewt, NULL)
        && header_vert_right_linewt == table->header_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_right_linewt [BS] %hu != %hu", table->header_vert_right_linewt, header_vert_right_linewt);
    header_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_right_linewt", &header_vert_right_linewt, 0)
        && header_vert_right_linewt == table->header_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_right_linewt [BS] set+1 %hu != %hu", table->header_vert_right_linewt, header_vert_right_linewt);
    table->header_vert_right_linewt--;
  }
  {
    BITCODE_BS header_vert_right_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_right_visibility", &header_vert_right_visibility, NULL)
        && header_vert_right_visibility == table->header_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_right_visibility [BS] %hu != %hu", table->header_vert_right_visibility, header_vert_right_visibility);
    header_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_right_visibility", &header_vert_right_visibility, 0)
        && header_vert_right_visibility == table->header_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_right_visibility [BS] set+1 %hu != %hu", table->header_vert_right_visibility, header_vert_right_visibility);
    table->header_vert_right_visibility--;
  }
  {
    BITCODE_3BD hor_dir;
    if (dwg_dynapi_entity_value (table, "TABLE", "hor_dir", &hor_dir, NULL)
        && !memcmp (&hor_dir, &table->hor_dir, sizeof (table->hor_dir)))
        pass ();
    else
        fail ("TABLE.hor_dir [3BD]");
  }
  {
    BITCODE_BD horiz_cell_margin;
    if (dwg_dynapi_entity_value (table, "TABLE", "horiz_cell_margin", &horiz_cell_margin, NULL)
        && horiz_cell_margin == table->horiz_cell_margin)
      pass ();
    else
      fail ("TABLE.horiz_cell_margin [BD] %g != %g", table->horiz_cell_margin, horiz_cell_margin);
    horiz_cell_margin++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "horiz_cell_margin", &horiz_cell_margin, 0)
        && horiz_cell_margin == table->horiz_cell_margin)
      pass ();
    else
      fail ("TABLE.horiz_cell_margin [BD] set+1 %g != %g", table->horiz_cell_margin, horiz_cell_margin);
    table->horiz_cell_margin--;
  }
  {
    BITCODE_3BD horiz_direction;
    if (dwg_dynapi_entity_value (table, "TABLE", "horiz_direction", &horiz_direction, NULL)
        && !memcmp (&horiz_direction, &table->horiz_direction, sizeof (table->horiz_direction)))
        pass ();
    else
        fail ("TABLE.horiz_direction [3BD]");
  }
  {
    BITCODE_3BD insertion_point;
    if (dwg_dynapi_entity_value (table, "TABLE", "insertion_point", &insertion_point, NULL)
        && !memcmp (&insertion_point, &table->insertion_point, sizeof (table->insertion_point)))
        pass ();
    else
        fail ("TABLE.insertion_point [3BD]");
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value (table, "TABLE", "last_attrib", &last_attrib, NULL)
        && !memcmp (&last_attrib, &table->last_attrib, sizeof (table->last_attrib)))
        pass ();
    else
        fail ("TABLE.last_attrib [H]");
  }
  {
    Dwg_LinkedData ldata;
    if (dwg_dynapi_entity_value (table, "TABLE", "ldata", &ldata, NULL)
        && !memcmp (&ldata, &table->ldata, sizeof (table->ldata)))
        pass ();
    else
        fail ("TABLE.ldata [Dwg_LinkedData]");
  }
  {
    BITCODE_BL num_break_heights;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_break_heights", &num_break_heights, NULL)
        && num_break_heights == table->num_break_heights)
      pass ();
    else
      fail ("TABLE.num_break_heights [BL] %u != %u", table->num_break_heights, num_break_heights);
    num_break_heights++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_break_heights", &num_break_heights, 0)
        && num_break_heights == table->num_break_heights)
      pass ();
    else
      fail ("TABLE.num_break_heights [BL] set+1 %u != %u", table->num_break_heights, num_break_heights);
    table->num_break_heights--;
  }
  {
    BITCODE_BL num_break_rows;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_break_rows", &num_break_rows, NULL)
        && num_break_rows == table->num_break_rows)
      pass ();
    else
      fail ("TABLE.num_break_rows [BL] %u != %u", table->num_break_rows, num_break_rows);
    num_break_rows++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_break_rows", &num_break_rows, 0)
        && num_break_rows == table->num_break_rows)
      pass ();
    else
      fail ("TABLE.num_break_rows [BL] set+1 %u != %u", table->num_break_rows, num_break_rows);
    table->num_break_rows--;
  }
  {
    unsigned long num_cells;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_cells", &num_cells, NULL)
        && num_cells == table->num_cells)
      pass ();
    else
      fail ("TABLE.num_cells [unsigned long] %lu != %lu", table->num_cells, num_cells);
    num_cells++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_cells", &num_cells, 0)
        && num_cells == table->num_cells)
      pass ();
    else
      fail ("TABLE.num_cells [unsigned long] set+1 %lu != %lu", table->num_cells, num_cells);
    table->num_cells--;
  }
  {
    BITCODE_BL num_cols;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_cols", &num_cols, NULL)
        && num_cols == table->num_cols)
      pass ();
    else
      fail ("TABLE.num_cols [BL] %u != %u", table->num_cols, num_cols);
    num_cols++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_cols", &num_cols, 0)
        && num_cols == table->num_cols)
      pass ();
    else
      fail ("TABLE.num_cols [BL] set+1 %u != %u", table->num_cols, num_cols);
    table->num_cols--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_owned", &num_owned, NULL)
        && num_owned == table->num_owned)
      pass ();
    else
      fail ("TABLE.num_owned [BL] %u != %u", table->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_owned", &num_owned, 0)
        && num_owned == table->num_owned)
      pass ();
    else
      fail ("TABLE.num_owned [BL] set+1 %u != %u", table->num_owned, num_owned);
    table->num_owned--;
  }
  {
    BITCODE_BL num_rows;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_rows", &num_rows, NULL)
        && num_rows == table->num_rows)
      pass ();
    else
      fail ("TABLE.num_rows [BL] %u != %u", table->num_rows, num_rows);
    num_rows++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_rows", &num_rows, 0)
        && num_rows == table->num_rows)
      pass ();
    else
      fail ("TABLE.num_rows [BL] set+1 %u != %u", table->num_rows, num_rows);
    table->num_rows--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (table, "TABLE", "parent", &parent, NULL)
        && !memcmp (&parent, &table->parent, sizeof (table->parent)))
        pass ();
    else
        fail ("TABLE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (table, "TABLE", "rotation", &rotation, NULL)
        && rotation == table->rotation)
      pass ();
    else
      fail ("TABLE.rotation [BD] %g != %g", table->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "rotation", &rotation, 0)
        && rotation == table->rotation)
      pass ();
    else
      fail ("TABLE.rotation [BD] set+1 %g != %g", table->rotation, rotation);
    table->rotation--;
  }
  {
    BITCODE_BD* row_heights;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_row_heights", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "row_heights", &row_heights, NULL)
        && row_heights == table->row_heights)
      pass ();
    else
      fail ("TABLE.row_heights [BD*] * %u num_row_heights", count);
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value (table, "TABLE", "scale", &scale, NULL)
        && !memcmp (&scale, &table->scale, sizeof (table->scale)))
        pass ();
    else
        fail ("TABLE.scale [3BD_1]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (table, "TABLE", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &table->seqend, sizeof (table->seqend)))
        pass ();
    else
        fail ("TABLE.seqend [H]");
  }
  {
    BITCODE_BL table_flag_override;
    if (dwg_dynapi_entity_value (table, "TABLE", "table_flag_override", &table_flag_override, NULL)
        && table_flag_override == table->table_flag_override)
      pass ();
    else
      fail ("TABLE.table_flag_override [BL] %u != %u", table->table_flag_override, table_flag_override);
    table_flag_override++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "table_flag_override", &table_flag_override, 0)
        && table_flag_override == table->table_flag_override)
      pass ();
    else
      fail ("TABLE.table_flag_override [BL] set+1 %u != %u", table->table_flag_override, table_flag_override);
    table->table_flag_override--;
  }
  {
    BITCODE_H table_style;
    if (dwg_dynapi_entity_value (table, "TABLE", "table_style", &table_style, NULL)
        && !memcmp (&table_style, &table->table_style, sizeof (table->table_style)))
        pass ();
    else
        fail ("TABLE.table_style [H]");
  }
  {
    Dwg_LinkedTableData tdata;
    if (dwg_dynapi_entity_value (table, "TABLE", "tdata", &tdata, NULL)
        && !memcmp (&tdata, &table->tdata, sizeof (table->tdata)))
        pass ();
    else
        fail ("TABLE.tdata [Dwg_LinkedTableData]");
  }
  {
    BITCODE_CMC title_horiz_bottom_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_bottom_color", &title_horiz_bottom_color, NULL)
        && !memcmp (&title_horiz_bottom_color, &table->title_horiz_bottom_color, sizeof (table->title_horiz_bottom_color)))
        pass ();
    else
        fail ("TABLE.title_horiz_bottom_color [CMC]");
  }
  {
    BITCODE_BS title_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_bottom_linewt", &title_horiz_bottom_linewt, NULL)
        && title_horiz_bottom_linewt == table->title_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_bottom_linewt [BS] %hu != %hu", table->title_horiz_bottom_linewt, title_horiz_bottom_linewt);
    title_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_bottom_linewt", &title_horiz_bottom_linewt, 0)
        && title_horiz_bottom_linewt == table->title_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->title_horiz_bottom_linewt, title_horiz_bottom_linewt);
    table->title_horiz_bottom_linewt--;
  }
  {
    BITCODE_BS title_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_bottom_visibility", &title_horiz_bottom_visibility, NULL)
        && title_horiz_bottom_visibility == table->title_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_bottom_visibility [BS] %hu != %hu", table->title_horiz_bottom_visibility, title_horiz_bottom_visibility);
    title_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_bottom_visibility", &title_horiz_bottom_visibility, 0)
        && title_horiz_bottom_visibility == table->title_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->title_horiz_bottom_visibility, title_horiz_bottom_visibility);
    table->title_horiz_bottom_visibility--;
  }
  {
    BITCODE_CMC title_horiz_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_ins_color", &title_horiz_ins_color, NULL)
        && !memcmp (&title_horiz_ins_color, &table->title_horiz_ins_color, sizeof (table->title_horiz_ins_color)))
        pass ();
    else
        fail ("TABLE.title_horiz_ins_color [CMC]");
  }
  {
    BITCODE_BS title_horiz_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_ins_linewt", &title_horiz_ins_linewt, NULL)
        && title_horiz_ins_linewt == table->title_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_ins_linewt [BS] %hu != %hu", table->title_horiz_ins_linewt, title_horiz_ins_linewt);
    title_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_ins_linewt", &title_horiz_ins_linewt, 0)
        && title_horiz_ins_linewt == table->title_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_ins_linewt [BS] set+1 %hu != %hu", table->title_horiz_ins_linewt, title_horiz_ins_linewt);
    table->title_horiz_ins_linewt--;
  }
  {
    BITCODE_BS title_horiz_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_ins_visibility", &title_horiz_ins_visibility, NULL)
        && title_horiz_ins_visibility == table->title_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_ins_visibility [BS] %hu != %hu", table->title_horiz_ins_visibility, title_horiz_ins_visibility);
    title_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_ins_visibility", &title_horiz_ins_visibility, 0)
        && title_horiz_ins_visibility == table->title_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_ins_visibility [BS] set+1 %hu != %hu", table->title_horiz_ins_visibility, title_horiz_ins_visibility);
    table->title_horiz_ins_visibility--;
  }
  {
    BITCODE_CMC title_horiz_top_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_top_color", &title_horiz_top_color, NULL)
        && !memcmp (&title_horiz_top_color, &table->title_horiz_top_color, sizeof (table->title_horiz_top_color)))
        pass ();
    else
        fail ("TABLE.title_horiz_top_color [CMC]");
  }
  {
    BITCODE_BS title_horiz_top_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_top_linewt", &title_horiz_top_linewt, NULL)
        && title_horiz_top_linewt == table->title_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_top_linewt [BS] %hu != %hu", table->title_horiz_top_linewt, title_horiz_top_linewt);
    title_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_top_linewt", &title_horiz_top_linewt, 0)
        && title_horiz_top_linewt == table->title_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_top_linewt [BS] set+1 %hu != %hu", table->title_horiz_top_linewt, title_horiz_top_linewt);
    table->title_horiz_top_linewt--;
  }
  {
    BITCODE_BS title_horiz_top_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_top_visibility", &title_horiz_top_visibility, NULL)
        && title_horiz_top_visibility == table->title_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_top_visibility [BS] %hu != %hu", table->title_horiz_top_visibility, title_horiz_top_visibility);
    title_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_top_visibility", &title_horiz_top_visibility, 0)
        && title_horiz_top_visibility == table->title_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_top_visibility [BS] set+1 %hu != %hu", table->title_horiz_top_visibility, title_horiz_top_visibility);
    table->title_horiz_top_visibility--;
  }
  {
    BITCODE_BS title_row_alignment;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_alignment", &title_row_alignment, NULL)
        && title_row_alignment == table->title_row_alignment)
      pass ();
    else
      fail ("TABLE.title_row_alignment [BS] %hu != %hu", table->title_row_alignment, title_row_alignment);
    title_row_alignment++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_row_alignment", &title_row_alignment, 0)
        && title_row_alignment == table->title_row_alignment)
      pass ();
    else
      fail ("TABLE.title_row_alignment [BS] set+1 %hu != %hu", table->title_row_alignment, title_row_alignment);
    table->title_row_alignment--;
  }
  {
    BITCODE_CMC title_row_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_color", &title_row_color, NULL)
        && !memcmp (&title_row_color, &table->title_row_color, sizeof (table->title_row_color)))
        pass ();
    else
        fail ("TABLE.title_row_color [CMC]");
  }
  {
    BITCODE_CMC title_row_fill_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_fill_color", &title_row_fill_color, NULL)
        && !memcmp (&title_row_fill_color, &table->title_row_fill_color, sizeof (table->title_row_fill_color)))
        pass ();
    else
        fail ("TABLE.title_row_fill_color [CMC]");
  }
  {
    BITCODE_B title_row_fill_none;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_fill_none", &title_row_fill_none, NULL)
        && title_row_fill_none == table->title_row_fill_none)
      pass ();
    else
      fail ("TABLE.title_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->title_row_fill_none, title_row_fill_none);
    title_row_fill_none++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_row_fill_none", &title_row_fill_none, 0)
        && title_row_fill_none == table->title_row_fill_none)
      pass ();
    else
      fail ("TABLE.title_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->title_row_fill_none, title_row_fill_none);
    table->title_row_fill_none--;
  }
  {
    BITCODE_BD title_row_height;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_height", &title_row_height, NULL)
        && title_row_height == table->title_row_height)
      pass ();
    else
      fail ("TABLE.title_row_height [BD] %g != %g", table->title_row_height, title_row_height);
    title_row_height++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_row_height", &title_row_height, 0)
        && title_row_height == table->title_row_height)
      pass ();
    else
      fail ("TABLE.title_row_height [BD] set+1 %g != %g", table->title_row_height, title_row_height);
    table->title_row_height--;
  }
  {
    BITCODE_H title_row_style_override;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_style_override", &title_row_style_override, NULL)
        && !memcmp (&title_row_style_override, &table->title_row_style_override, sizeof (table->title_row_style_override)))
        pass ();
    else
        fail ("TABLE.title_row_style_override [H]");
  }
  {
    BITCODE_B title_suppressed;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_suppressed", &title_suppressed, NULL)
        && title_suppressed == table->title_suppressed)
      pass ();
    else
      fail ("TABLE.title_suppressed [B] " FORMAT_B " != " FORMAT_B "", table->title_suppressed, title_suppressed);
    title_suppressed++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_suppressed", &title_suppressed, 0)
        && title_suppressed == table->title_suppressed)
      pass ();
    else
      fail ("TABLE.title_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", table->title_suppressed, title_suppressed);
    table->title_suppressed--;
  }
  {
    BITCODE_H title_text_style;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_text_style", &title_text_style, NULL)
        && !memcmp (&title_text_style, &table->title_text_style, sizeof (table->title_text_style)))
        pass ();
    else
        fail ("TABLE.title_text_style [H]");
  }
  {
    BITCODE_CMC title_vert_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_ins_color", &title_vert_ins_color, NULL)
        && !memcmp (&title_vert_ins_color, &table->title_vert_ins_color, sizeof (table->title_vert_ins_color)))
        pass ();
    else
        fail ("TABLE.title_vert_ins_color [CMC]");
  }
  {
    BITCODE_BS title_vert_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_ins_linewt", &title_vert_ins_linewt, NULL)
        && title_vert_ins_linewt == table->title_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_ins_linewt [BS] %hu != %hu", table->title_vert_ins_linewt, title_vert_ins_linewt);
    title_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_ins_linewt", &title_vert_ins_linewt, 0)
        && title_vert_ins_linewt == table->title_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_ins_linewt [BS] set+1 %hu != %hu", table->title_vert_ins_linewt, title_vert_ins_linewt);
    table->title_vert_ins_linewt--;
  }
  {
    BITCODE_BS title_vert_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_ins_visibility", &title_vert_ins_visibility, NULL)
        && title_vert_ins_visibility == table->title_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_ins_visibility [BS] %hu != %hu", table->title_vert_ins_visibility, title_vert_ins_visibility);
    title_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_ins_visibility", &title_vert_ins_visibility, 0)
        && title_vert_ins_visibility == table->title_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_ins_visibility [BS] set+1 %hu != %hu", table->title_vert_ins_visibility, title_vert_ins_visibility);
    table->title_vert_ins_visibility--;
  }
  {
    BITCODE_CMC title_vert_left_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_left_color", &title_vert_left_color, NULL)
        && !memcmp (&title_vert_left_color, &table->title_vert_left_color, sizeof (table->title_vert_left_color)))
        pass ();
    else
        fail ("TABLE.title_vert_left_color [CMC]");
  }
  {
    BITCODE_BS title_vert_left_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_left_linewt", &title_vert_left_linewt, NULL)
        && title_vert_left_linewt == table->title_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_left_linewt [BS] %hu != %hu", table->title_vert_left_linewt, title_vert_left_linewt);
    title_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_left_linewt", &title_vert_left_linewt, 0)
        && title_vert_left_linewt == table->title_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_left_linewt [BS] set+1 %hu != %hu", table->title_vert_left_linewt, title_vert_left_linewt);
    table->title_vert_left_linewt--;
  }
  {
    BITCODE_BS title_vert_left_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_left_visibility", &title_vert_left_visibility, NULL)
        && title_vert_left_visibility == table->title_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_left_visibility [BS] %hu != %hu", table->title_vert_left_visibility, title_vert_left_visibility);
    title_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_left_visibility", &title_vert_left_visibility, 0)
        && title_vert_left_visibility == table->title_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_left_visibility [BS] set+1 %hu != %hu", table->title_vert_left_visibility, title_vert_left_visibility);
    table->title_vert_left_visibility--;
  }
  {
    BITCODE_CMC title_vert_right_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_right_color", &title_vert_right_color, NULL)
        && !memcmp (&title_vert_right_color, &table->title_vert_right_color, sizeof (table->title_vert_right_color)))
        pass ();
    else
        fail ("TABLE.title_vert_right_color [CMC]");
  }
  {
    BITCODE_BS title_vert_right_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_right_linewt", &title_vert_right_linewt, NULL)
        && title_vert_right_linewt == table->title_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_right_linewt [BS] %hu != %hu", table->title_vert_right_linewt, title_vert_right_linewt);
    title_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_right_linewt", &title_vert_right_linewt, 0)
        && title_vert_right_linewt == table->title_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_right_linewt [BS] set+1 %hu != %hu", table->title_vert_right_linewt, title_vert_right_linewt);
    table->title_vert_right_linewt--;
  }
  {
    BITCODE_BS title_vert_right_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_right_visibility", &title_vert_right_visibility, NULL)
        && title_vert_right_visibility == table->title_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_right_visibility [BS] %hu != %hu", table->title_vert_right_visibility, title_vert_right_visibility);
    title_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_right_visibility", &title_vert_right_visibility, 0)
        && title_vert_right_visibility == table->title_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_right_visibility [BS] set+1 %hu != %hu", table->title_vert_right_visibility, title_vert_right_visibility);
    table->title_vert_right_visibility--;
  }
  {
    BITCODE_B unknown_b;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_b", &unknown_b, NULL)
        && unknown_b == table->unknown_b)
      pass ();
    else
      fail ("TABLE.unknown_b [B] " FORMAT_B " != " FORMAT_B "", table->unknown_b, unknown_b);
    unknown_b++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_b", &unknown_b, 0)
        && unknown_b == table->unknown_b)
      pass ();
    else
      fail ("TABLE.unknown_b [B] set+1 " FORMAT_B " != " FORMAT_B "", table->unknown_b, unknown_b);
    table->unknown_b--;
  }
  {
    BITCODE_BL unknown_bl;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_bl", &unknown_bl, NULL)
        && unknown_bl == table->unknown_bl)
      pass ();
    else
      fail ("TABLE.unknown_bl [BL] %u != %u", table->unknown_bl, unknown_bl);
    unknown_bl++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_bl", &unknown_bl, 0)
        && unknown_bl == table->unknown_bl)
      pass ();
    else
      fail ("TABLE.unknown_bl [BL] set+1 %u != %u", table->unknown_bl, unknown_bl);
    table->unknown_bl--;
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_bl1", &unknown_bl1, NULL)
        && unknown_bl1 == table->unknown_bl1)
      pass ();
    else
      fail ("TABLE.unknown_bl1 [BL] %u != %u", table->unknown_bl1, unknown_bl1);
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_bl1", &unknown_bl1, 0)
        && unknown_bl1 == table->unknown_bl1)
      pass ();
    else
      fail ("TABLE.unknown_bl1 [BL] set+1 %u != %u", table->unknown_bl1, unknown_bl1);
    table->unknown_bl1--;
  }
  {
    BITCODE_BS unknown_bs;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_bs", &unknown_bs, NULL)
        && unknown_bs == table->unknown_bs)
      pass ();
    else
      fail ("TABLE.unknown_bs [BS] %hu != %hu", table->unknown_bs, unknown_bs);
    unknown_bs++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_bs", &unknown_bs, 0)
        && unknown_bs == table->unknown_bs)
      pass ();
    else
      fail ("TABLE.unknown_bs [BS] set+1 %hu != %hu", table->unknown_bs, unknown_bs);
    table->unknown_bs--;
  }
  {
    BITCODE_H unknown_h;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_h", &unknown_h, NULL)
        && !memcmp (&unknown_h, &table->unknown_h, sizeof (table->unknown_h)))
        pass ();
    else
        fail ("TABLE.unknown_h [H]");
  }
  {
    BITCODE_RC unknown_rc;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_rc", &unknown_rc, NULL)
        && unknown_rc == table->unknown_rc)
      pass ();
    else
      fail ("TABLE.unknown_rc [RC] %u != %u", table->unknown_rc, unknown_rc);
    unknown_rc++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_rc", &unknown_rc, 0)
        && unknown_rc == table->unknown_rc)
      pass ();
    else
      fail ("TABLE.unknown_rc [RC] set+1 %u != %u", table->unknown_rc, unknown_rc);
    table->unknown_rc--;
  }
  {
    BITCODE_BD vert_cell_margin;
    if (dwg_dynapi_entity_value (table, "TABLE", "vert_cell_margin", &vert_cell_margin, NULL)
        && vert_cell_margin == table->vert_cell_margin)
      pass ();
    else
      fail ("TABLE.vert_cell_margin [BD] %g != %g", table->vert_cell_margin, vert_cell_margin);
    vert_cell_margin++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "vert_cell_margin", &vert_cell_margin, 0)
        && vert_cell_margin == table->vert_cell_margin)
      pass ();
    else
      fail ("TABLE.vert_cell_margin [BD] set+1 %g != %g", table->vert_cell_margin, vert_cell_margin);
    table->vert_cell_margin--;
  }
  if (failed && (is_class_unstable ("TABLE") || is_class_debugging ("TABLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TABLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_TEXT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_TEXT *restrict text = obj->tio.entity->tio.TEXT;
  failed = 0;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value (text, "TEXT", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &text->alignment_pt, sizeof (text->alignment_pt)))
        pass ();
    else
        fail ("TEXT.alignment_pt [2DPOINT]");
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value (text, "TEXT", "dataflags", &dataflags, NULL)
        && dataflags == text->dataflags)
      pass ();
    else
      fail ("TEXT.dataflags [RC] %u != %u", text->dataflags, dataflags);
    dataflags++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "dataflags", &dataflags, 0)
        && dataflags == text->dataflags)
      pass ();
    else
      fail ("TEXT.dataflags [RC] set+1 %u != %u", text->dataflags, dataflags);
    text->dataflags--;
  }
  {
    BITCODE_RD elevation;
    if (dwg_dynapi_entity_value (text, "TEXT", "elevation", &elevation, NULL)
        && elevation == text->elevation)
      pass ();
    else
      fail ("TEXT.elevation [RD] %g != %g", text->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "elevation", &elevation, 0)
        && elevation == text->elevation)
      pass ();
    else
      fail ("TEXT.elevation [RD] set+1 %g != %g", text->elevation, elevation);
    text->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (text, "TEXT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &text->extrusion, sizeof (text->extrusion)))
        pass ();
    else
        fail ("TEXT.extrusion [BE]");
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value (text, "TEXT", "generation", &generation, NULL)
        && generation == text->generation)
      pass ();
    else
      fail ("TEXT.generation [BS] %hu != %hu", text->generation, generation);
    generation++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "generation", &generation, 0)
        && generation == text->generation)
      pass ();
    else
      fail ("TEXT.generation [BS] set+1 %hu != %hu", text->generation, generation);
    text->generation--;
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value (text, "TEXT", "height", &height, NULL)
        && height == text->height)
      pass ();
    else
      fail ("TEXT.height [RD] %g != %g", text->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "height", &height, 0)
        && height == text->height)
      pass ();
    else
      fail ("TEXT.height [RD] set+1 %g != %g", text->height, height);
    text->height--;
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value (text, "TEXT", "horiz_alignment", &horiz_alignment, NULL)
        && horiz_alignment == text->horiz_alignment)
      pass ();
    else
      fail ("TEXT.horiz_alignment [BS] %hu != %hu", text->horiz_alignment, horiz_alignment);
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "horiz_alignment", &horiz_alignment, 0)
        && horiz_alignment == text->horiz_alignment)
      pass ();
    else
      fail ("TEXT.horiz_alignment [BS] set+1 %hu != %hu", text->horiz_alignment, horiz_alignment);
    text->horiz_alignment--;
  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value (text, "TEXT", "insertion_pt", &insertion_pt, NULL)
        && !memcmp (&insertion_pt, &text->insertion_pt, sizeof (text->insertion_pt)))
        pass ();
    else
        fail ("TEXT.insertion_pt [2DPOINT]");
  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value (text, "TEXT", "oblique_ang", &oblique_ang, NULL)
        && oblique_ang == text->oblique_ang)
      pass ();
    else
      fail ("TEXT.oblique_ang [RD] %g != %g", text->oblique_ang, oblique_ang);
    oblique_ang++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "oblique_ang", &oblique_ang, 0)
        && oblique_ang == text->oblique_ang)
      pass ();
    else
      fail ("TEXT.oblique_ang [RD] set+1 %g != %g", text->oblique_ang, oblique_ang);
    text->oblique_ang--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (text, "TEXT", "parent", &parent, NULL)
        && !memcmp (&parent, &text->parent, sizeof (text->parent)))
        pass ();
    else
        fail ("TEXT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value (text, "TEXT", "rotation", &rotation, NULL)
        && rotation == text->rotation)
      pass ();
    else
      fail ("TEXT.rotation [RD] %g != %g", text->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "rotation", &rotation, 0)
        && rotation == text->rotation)
      pass ();
    else
      fail ("TEXT.rotation [RD] set+1 %g != %g", text->rotation, rotation);
    text->rotation--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (text, "TEXT", "style", &style, NULL)
        && !memcmp (&style, &text->style, sizeof (text->style)))
        pass ();
    else
        fail ("TEXT.style [H]");
  }
  {
    BITCODE_T text_value;
    if (dwg_dynapi_entity_value (text, "TEXT", "text_value", &text_value, NULL)
        && text_value
           ? strEQ ((char *)text_value, (char *)text->text_value)
           : !text->text_value)
      pass ();
    else
      fail ("TEXT.text_value [T] '%s' <> '%s'", text_value, text->text_value);
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value (text, "TEXT", "thickness", &thickness, NULL)
        && thickness == text->thickness)
      pass ();
    else
      fail ("TEXT.thickness [RD] %g != %g", text->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "thickness", &thickness, 0)
        && thickness == text->thickness)
      pass ();
    else
      fail ("TEXT.thickness [RD] set+1 %g != %g", text->thickness, thickness);
    text->thickness--;
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value (text, "TEXT", "vert_alignment", &vert_alignment, NULL)
        && vert_alignment == text->vert_alignment)
      pass ();
    else
      fail ("TEXT.vert_alignment [BS] %hu != %hu", text->vert_alignment, vert_alignment);
    vert_alignment++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "vert_alignment", &vert_alignment, 0)
        && vert_alignment == text->vert_alignment)
      pass ();
    else
      fail ("TEXT.vert_alignment [BS] set+1 %hu != %hu", text->vert_alignment, vert_alignment);
    text->vert_alignment--;
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value (text, "TEXT", "width_factor", &width_factor, NULL)
        && width_factor == text->width_factor)
      pass ();
    else
      fail ("TEXT.width_factor [RD] %g != %g", text->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "width_factor", &width_factor, 0)
        && width_factor == text->width_factor)
      pass ();
    else
      fail ("TEXT.width_factor [RD] set+1 %g != %g", text->width_factor, width_factor);
    text->width_factor--;
  }
  if (failed && (is_class_unstable ("TEXT") || is_class_debugging ("TEXT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TEXT", failed);
      failed = 0;
    }
  return failed;
}
static int test_TOLERANCE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_TOLERANCE *restrict tolerance = obj->tio.entity->tio.TOLERANCE;
  failed = 0;
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "dimgap", &dimgap, NULL)
        && dimgap == tolerance->dimgap)
      pass ();
    else
      fail ("TOLERANCE.dimgap [BD] %g != %g", tolerance->dimgap, dimgap);
    dimgap++;
    if (dwg_dynapi_entity_set_value (tolerance, "TOLERANCE", "dimgap", &dimgap, 0)
        && dimgap == tolerance->dimgap)
      pass ();
    else
      fail ("TOLERANCE.dimgap [BD] set+1 %g != %g", tolerance->dimgap, dimgap);
    tolerance->dimgap--;
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &tolerance->dimstyle, sizeof (tolerance->dimstyle)))
        pass ();
    else
        fail ("TOLERANCE.dimstyle [H]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &tolerance->extrusion, sizeof (tolerance->extrusion)))
        pass ();
    else
        fail ("TOLERANCE.extrusion [BE]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "height", &height, NULL)
        && height == tolerance->height)
      pass ();
    else
      fail ("TOLERANCE.height [BD] %g != %g", tolerance->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (tolerance, "TOLERANCE", "height", &height, 0)
        && height == tolerance->height)
      pass ();
    else
      fail ("TOLERANCE.height [BD] set+1 %g != %g", tolerance->height, height);
    tolerance->height--;
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &tolerance->ins_pt, sizeof (tolerance->ins_pt)))
        pass ();
    else
        fail ("TOLERANCE.ins_pt [3BD]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "parent", &parent, NULL)
        && !memcmp (&parent, &tolerance->parent, sizeof (tolerance->parent)))
        pass ();
    else
        fail ("TOLERANCE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_T text_string;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "text_string", &text_string, NULL)
        && text_string
           ? strEQ ((char *)text_string, (char *)tolerance->text_string)
           : !tolerance->text_string)
      pass ();
    else
      fail ("TOLERANCE.text_string [T] '%s' <> '%s'", text_string, tolerance->text_string);
  }
  {
    BITCODE_BS unknown_short;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "unknown_short", &unknown_short, NULL)
        && unknown_short == tolerance->unknown_short)
      pass ();
    else
      fail ("TOLERANCE.unknown_short [BS] %hu != %hu", tolerance->unknown_short, unknown_short);
    unknown_short++;
    if (dwg_dynapi_entity_set_value (tolerance, "TOLERANCE", "unknown_short", &unknown_short, 0)
        && unknown_short == tolerance->unknown_short)
      pass ();
    else
      fail ("TOLERANCE.unknown_short [BS] set+1 %hu != %hu", tolerance->unknown_short, unknown_short);
    tolerance->unknown_short--;
  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "x_direction", &x_direction, NULL)
        && !memcmp (&x_direction, &tolerance->x_direction, sizeof (tolerance->x_direction)))
        pass ();
    else
        fail ("TOLERANCE.x_direction [3BD]");
  }
  if (failed && (is_class_unstable ("TOLERANCE") || is_class_debugging ("TOLERANCE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TOLERANCE", failed);
      failed = 0;
    }
  return failed;
}
static int test_TRACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_TRACE *restrict trace = obj->tio.entity->tio.TRACE;
  failed = 0;
  {
    BITCODE_2RD corner1;
    if (dwg_dynapi_entity_value (trace, "TRACE", "corner1", &corner1, NULL)
        && !memcmp (&corner1, &trace->corner1, sizeof (trace->corner1)))
        pass ();
    else
        fail ("TRACE.corner1 [2RD]");
  }
  {
    BITCODE_2RD corner2;
    if (dwg_dynapi_entity_value (trace, "TRACE", "corner2", &corner2, NULL)
        && !memcmp (&corner2, &trace->corner2, sizeof (trace->corner2)))
        pass ();
    else
        fail ("TRACE.corner2 [2RD]");
  }
  {
    BITCODE_2RD corner3;
    if (dwg_dynapi_entity_value (trace, "TRACE", "corner3", &corner3, NULL)
        && !memcmp (&corner3, &trace->corner3, sizeof (trace->corner3)))
        pass ();
    else
        fail ("TRACE.corner3 [2RD]");
  }
  {
    BITCODE_2RD corner4;
    if (dwg_dynapi_entity_value (trace, "TRACE", "corner4", &corner4, NULL)
        && !memcmp (&corner4, &trace->corner4, sizeof (trace->corner4)))
        pass ();
    else
        fail ("TRACE.corner4 [2RD]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (trace, "TRACE", "elevation", &elevation, NULL)
        && elevation == trace->elevation)
      pass ();
    else
      fail ("TRACE.elevation [BD] %g != %g", trace->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (trace, "TRACE", "elevation", &elevation, 0)
        && elevation == trace->elevation)
      pass ();
    else
      fail ("TRACE.elevation [BD] set+1 %g != %g", trace->elevation, elevation);
    trace->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (trace, "TRACE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &trace->extrusion, sizeof (trace->extrusion)))
        pass ();
    else
        fail ("TRACE.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (trace, "TRACE", "parent", &parent, NULL)
        && !memcmp (&parent, &trace->parent, sizeof (trace->parent)))
        pass ();
    else
        fail ("TRACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (trace, "TRACE", "thickness", &thickness, NULL)
        && thickness == trace->thickness)
      pass ();
    else
      fail ("TRACE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", trace->thickness, thickness);
    if (dwg_dynapi_entity_set_value (trace, "TRACE", "thickness", &thickness, 0)
        && thickness == trace->thickness)
      pass ();
    else
      fail ("TRACE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", trace->thickness, thickness);
    trace->thickness--;
  }
  if (failed && (is_class_unstable ("TRACE") || is_class_debugging ("TRACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TRACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_UNDERLAY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_UNDERLAY *restrict underlay = obj->tio.entity->tio.UNDERLAY;
  failed = 0;
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "angle", &angle, NULL)
        && angle == underlay->angle)
      pass ();
    else
      fail ("UNDERLAY.angle [BD] %g != %g", underlay->angle, angle);
    angle++;
    if (dwg_dynapi_entity_set_value (underlay, "UNDERLAY", "angle", &angle, 0)
        && angle == underlay->angle)
      pass ();
    else
      fail ("UNDERLAY.angle [BD] set+1 %g != %g", underlay->angle, angle);
    underlay->angle--;
  }
  {
    BITCODE_2RD* clip_verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "num_clip_verts", &count, NULL)
        && dwg_dynapi_entity_value (underlay, "UNDERLAY", "clip_verts", &clip_verts, NULL)
        && clip_verts == underlay->clip_verts)
      pass ();
    else
      fail ("UNDERLAY.clip_verts [2RD*] * %u num_clip_verts", count);
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "contrast", &contrast, NULL)
        && contrast == underlay->contrast)
      pass ();
    else
      fail ("UNDERLAY.contrast [RC] %u != %u", underlay->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (underlay, "UNDERLAY", "contrast", &contrast, 0)
        && contrast == underlay->contrast)
      pass ();
    else
      fail ("UNDERLAY.contrast [RC] set+1 %u != %u", underlay->contrast, contrast);
    underlay->contrast--;
  }
  {
    BITCODE_H definition_id;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "definition_id", &definition_id, NULL)
        && !memcmp (&definition_id, &underlay->definition_id, sizeof (underlay->definition_id)))
        pass ();
    else
        fail ("UNDERLAY.definition_id [H]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &underlay->extrusion, sizeof (underlay->extrusion)))
        pass ();
    else
        fail ("UNDERLAY.extrusion [BE]");
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "fade", &fade, NULL)
        && fade == underlay->fade)
      pass ();
    else
      fail ("UNDERLAY.fade [RC] %u != %u", underlay->fade, fade);
    fade++;
    if (dwg_dynapi_entity_set_value (underlay, "UNDERLAY", "fade", &fade, 0)
        && fade == underlay->fade)
      pass ();
    else
      fail ("UNDERLAY.fade [RC] set+1 %u != %u", underlay->fade, fade);
    underlay->fade--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "flag", &flag, NULL)
        && flag == underlay->flag)
      pass ();
    else
      fail ("UNDERLAY.flag [RC] %u != %u", underlay->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (underlay, "UNDERLAY", "flag", &flag, 0)
        && flag == underlay->flag)
      pass ();
    else
      fail ("UNDERLAY.flag [RC] set+1 %u != %u", underlay->flag, flag);
    underlay->flag--;
  }
  {
    BITCODE_3BD insertion_pt;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "insertion_pt", &insertion_pt, NULL)
        && !memcmp (&insertion_pt, &underlay->insertion_pt, sizeof (underlay->insertion_pt)))
        pass ();
    else
        fail ("UNDERLAY.insertion_pt [3BD]");
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "num_clip_verts", &num_clip_verts, NULL)
        && num_clip_verts == underlay->num_clip_verts)
      pass ();
    else
      fail ("UNDERLAY.num_clip_verts [BL] %u != %u", underlay->num_clip_verts, num_clip_verts);
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value (underlay, "UNDERLAY", "num_clip_verts", &num_clip_verts, 0)
        && num_clip_verts == underlay->num_clip_verts)
      pass ();
    else
      fail ("UNDERLAY.num_clip_verts [BL] set+1 %u != %u", underlay->num_clip_verts, num_clip_verts);
    underlay->num_clip_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "parent", &parent, NULL)
        && !memcmp (&parent, &underlay->parent, sizeof (underlay->parent)))
        pass ();
    else
        fail ("UNDERLAY.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "scale", &scale, NULL)
        && !memcmp (&scale, &underlay->scale, sizeof (underlay->scale)))
        pass ();
    else
        fail ("UNDERLAY.scale [3BD_1]");
  }
  {
    BITCODE_H underlay_layer;
    if (dwg_dynapi_entity_value (underlay, "UNDERLAY", "underlay_layer", &underlay_layer, NULL)
        && !memcmp (&underlay_layer, &underlay->underlay_layer, sizeof (underlay->underlay_layer)))
        pass ();
    else
        fail ("UNDERLAY.underlay_layer [H]");
  }
  if (failed && (is_class_unstable ("UNDERLAY") || is_class_debugging ("UNDERLAY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "UNDERLAY", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_2D (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_2D *restrict vertex_2d = obj->tio.entity->tio.VERTEX_2D;
  failed = 0;
  {
    BITCODE_BD bulge;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "bulge", &bulge, NULL)
        && bulge == vertex_2d->bulge)
      pass ();
    else
      fail ("VERTEX_2D.bulge [BD] %g != %g", vertex_2d->bulge, bulge);
    bulge++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "bulge", &bulge, 0)
        && bulge == vertex_2d->bulge)
      pass ();
    else
      fail ("VERTEX_2D.bulge [BD] set+1 %g != %g", vertex_2d->bulge, bulge);
    vertex_2d->bulge--;
  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "end_width", &end_width, NULL)
        && end_width == vertex_2d->end_width)
      pass ();
    else
      fail ("VERTEX_2D.end_width [BD] %g != %g", vertex_2d->end_width, end_width);
    end_width++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "end_width", &end_width, 0)
        && end_width == vertex_2d->end_width)
      pass ();
    else
      fail ("VERTEX_2D.end_width [BD] set+1 %g != %g", vertex_2d->end_width, end_width);
    vertex_2d->end_width--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "flag", &flag, NULL)
        && flag == vertex_2d->flag)
      pass ();
    else
      fail ("VERTEX_2D.flag [RC] %u != %u", vertex_2d->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "flag", &flag, 0)
        && flag == vertex_2d->flag)
      pass ();
    else
      fail ("VERTEX_2D.flag [RC] set+1 %u != %u", vertex_2d->flag, flag);
    vertex_2d->flag--;
  }
  {
    BITCODE_BL id;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "id", &id, NULL)
        && id == vertex_2d->id)
      pass ();
    else
      fail ("VERTEX_2D.id [BL] %u != %u", vertex_2d->id, id);
    id++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "id", &id, 0)
        && id == vertex_2d->id)
      pass ();
    else
      fail ("VERTEX_2D.id [BL] set+1 %u != %u", vertex_2d->id, id);
    vertex_2d->id--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "parent", &parent, NULL)
        && !memcmp (&parent, &vertex_2d->parent, sizeof (vertex_2d->parent)))
        pass ();
    else
        fail ("VERTEX_2D.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "point", &point, NULL)
        && !memcmp (&point, &vertex_2d->point, sizeof (vertex_2d->point)))
        pass ();
    else
        fail ("VERTEX_2D.point [3BD]");
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "start_width", &start_width, NULL)
        && start_width == vertex_2d->start_width)
      pass ();
    else
      fail ("VERTEX_2D.start_width [BD] %g != %g", vertex_2d->start_width, start_width);
    start_width++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "start_width", &start_width, 0)
        && start_width == vertex_2d->start_width)
      pass ();
    else
      fail ("VERTEX_2D.start_width [BD] set+1 %g != %g", vertex_2d->start_width, start_width);
    vertex_2d->start_width--;
  }
  {
    BITCODE_BD tangent_dir;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "tangent_dir", &tangent_dir, NULL)
        && tangent_dir == vertex_2d->tangent_dir)
      pass ();
    else
      fail ("VERTEX_2D.tangent_dir [BD] %g != %g", vertex_2d->tangent_dir, tangent_dir);
    tangent_dir++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "tangent_dir", &tangent_dir, 0)
        && tangent_dir == vertex_2d->tangent_dir)
      pass ();
    else
      fail ("VERTEX_2D.tangent_dir [BD] set+1 %g != %g", vertex_2d->tangent_dir, tangent_dir);
    vertex_2d->tangent_dir--;
  }
  if (failed && (is_class_unstable ("VERTEX_2D") || is_class_debugging ("VERTEX_2D")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_2D", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_3D (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_3D *restrict vertex_3d = obj->tio.entity->tio.VERTEX_3D;
  failed = 0;
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vertex_3d, "VERTEX_3D", "flag", &flag, NULL)
        && flag == vertex_3d->flag)
      pass ();
    else
      fail ("VERTEX_3D.flag [RC] %u != %u", vertex_3d->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vertex_3d, "VERTEX_3D", "flag", &flag, 0)
        && flag == vertex_3d->flag)
      pass ();
    else
      fail ("VERTEX_3D.flag [RC] set+1 %u != %u", vertex_3d->flag, flag);
    vertex_3d->flag--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (vertex_3d, "VERTEX_3D", "parent", &parent, NULL)
        && !memcmp (&parent, &vertex_3d->parent, sizeof (vertex_3d->parent)))
        pass ();
    else
        fail ("VERTEX_3D.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (vertex_3d, "VERTEX_3D", "point", &point, NULL)
        && !memcmp (&point, &vertex_3d->point, sizeof (vertex_3d->point)))
        pass ();
    else
        fail ("VERTEX_3D.point [3BD]");
  }
  if (failed && (is_class_unstable ("VERTEX_3D") || is_class_debugging ("VERTEX_3D")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_3D", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_MESH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_MESH *restrict vertex_mesh = obj->tio.entity->tio.VERTEX_MESH;
  failed = 0;
  if (failed && (is_class_unstable ("VERTEX_MESH") || is_class_debugging ("VERTEX_MESH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_MESH", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_PFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_PFACE *restrict vertex_pface = obj->tio.entity->tio.VERTEX_PFACE;
  failed = 0;
  if (failed && (is_class_unstable ("VERTEX_PFACE") || is_class_debugging ("VERTEX_PFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_PFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_PFACE_FACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_PFACE_FACE *restrict vertex_pface_face = obj->tio.entity->tio.VERTEX_PFACE_FACE;
  failed = 0;
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "flag", &flag, NULL)
        && flag == vertex_pface_face->flag)
      pass ();
    else
      fail ("VERTEX_PFACE_FACE.flag [RC] %u != %u", vertex_pface_face->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vertex_pface_face, "VERTEX_PFACE_FACE", "flag", &flag, 0)
        && flag == vertex_pface_face->flag)
      pass ();
    else
      fail ("VERTEX_PFACE_FACE.flag [RC] set+1 %u != %u", vertex_pface_face->flag, flag);
    vertex_pface_face->flag--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "parent", &parent, NULL)
        && !memcmp (&parent, &vertex_pface_face->parent, sizeof (vertex_pface_face->parent)))
        pass ();
    else
        fail ("VERTEX_PFACE_FACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BS vertind[4];
    if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "vertind[4]", &vertind, NULL)
        && !memcmp (&vertind, &vertex_pface_face->vertind, sizeof (vertex_pface_face->vertind)))
        pass ();
    else
        fail ("VERTEX_PFACE_FACE.vertind[4] [BS]");
  }
  if (failed && (is_class_unstable ("VERTEX_PFACE_FACE") || is_class_debugging ("VERTEX_PFACE_FACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_PFACE_FACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_VIEWPORT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VIEWPORT *restrict viewport = obj->tio.entity->tio.VIEWPORT;
  failed = 0;
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ambient_color", &ambient_color, NULL)
        && !memcmp (&ambient_color, &viewport->ambient_color, sizeof (viewport->ambient_color)))
        pass ();
    else
        fail ("VIEWPORT.ambient_color [CMC]");
  }
  {
    BITCODE_BD back_clip_z;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "back_clip_z", &back_clip_z, NULL)
        && back_clip_z == viewport->back_clip_z)
      pass ();
    else
      fail ("VIEWPORT.back_clip_z [BD] %g != %g", viewport->back_clip_z, back_clip_z);
    back_clip_z++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "back_clip_z", &back_clip_z, 0)
        && back_clip_z == viewport->back_clip_z)
      pass ();
    else
      fail ("VIEWPORT.back_clip_z [BD] set+1 %g != %g", viewport->back_clip_z, back_clip_z);
    viewport->back_clip_z--;
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "brightness", &brightness, NULL)
        && brightness == viewport->brightness)
      pass ();
    else
      fail ("VIEWPORT.brightness [BD] %g != %g", viewport->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "brightness", &brightness, 0)
        && brightness == viewport->brightness)
      pass ();
    else
      fail ("VIEWPORT.brightness [BD] set+1 %g != %g", viewport->brightness, brightness);
    viewport->brightness--;
  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "center", &center, NULL)
        && !memcmp (&center, &viewport->center, sizeof (viewport->center)))
        pass ();
    else
        fail ("VIEWPORT.center [3BD]");
  }
  {
    BITCODE_BS circle_zoom;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "circle_zoom", &circle_zoom, NULL)
        && circle_zoom == viewport->circle_zoom)
      pass ();
    else
      fail ("VIEWPORT.circle_zoom [BS] %hu != %hu", viewport->circle_zoom, circle_zoom);
    circle_zoom++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "circle_zoom", &circle_zoom, 0)
        && circle_zoom == viewport->circle_zoom)
      pass ();
    else
      fail ("VIEWPORT.circle_zoom [BS] set+1 %hu != %hu", viewport->circle_zoom, circle_zoom);
    viewport->circle_zoom--;
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "contrast", &contrast, NULL)
        && contrast == viewport->contrast)
      pass ();
    else
      fail ("VIEWPORT.contrast [BD] %g != %g", viewport->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "contrast", &contrast, 0)
        && contrast == viewport->contrast)
      pass ();
    else
      fail ("VIEWPORT.contrast [BD] set+1 %g != %g", viewport->contrast, contrast);
    viewport->contrast--;
  }
  {
    BITCODE_RC default_lighting_type;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "default_lighting_type", &default_lighting_type, NULL)
        && default_lighting_type == viewport->default_lighting_type)
      pass ();
    else
      fail ("VIEWPORT.default_lighting_type [RC] %u != %u", viewport->default_lighting_type, default_lighting_type);
    default_lighting_type++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "default_lighting_type", &default_lighting_type, 0)
        && default_lighting_type == viewport->default_lighting_type)
      pass ();
    else
      fail ("VIEWPORT.default_lighting_type [RC] set+1 %u != %u", viewport->default_lighting_type, default_lighting_type);
    viewport->default_lighting_type--;
  }
  {
    BITCODE_BD front_clip_z;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "front_clip_z", &front_clip_z, NULL)
        && front_clip_z == viewport->front_clip_z)
      pass ();
    else
      fail ("VIEWPORT.front_clip_z [BD] %g != %g", viewport->front_clip_z, front_clip_z);
    front_clip_z++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "front_clip_z", &front_clip_z, 0)
        && front_clip_z == viewport->front_clip_z)
      pass ();
    else
      fail ("VIEWPORT.front_clip_z [BD] set+1 %g != %g", viewport->front_clip_z, front_clip_z);
    viewport->front_clip_z--;
  }
  {
    BITCODE_BS grid_major;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "grid_major", &grid_major, NULL)
        && grid_major == viewport->grid_major)
      pass ();
    else
      fail ("VIEWPORT.grid_major [BS] %hu != %hu", viewport->grid_major, grid_major);
    grid_major++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "grid_major", &grid_major, 0)
        && grid_major == viewport->grid_major)
      pass ();
    else
      fail ("VIEWPORT.grid_major [BS] set+1 %hu != %hu", viewport->grid_major, grid_major);
    viewport->grid_major--;
  }
  {
    BITCODE_2RD grid_spacing;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "grid_spacing", &grid_spacing, NULL)
        && !memcmp (&grid_spacing, &viewport->grid_spacing, sizeof (viewport->grid_spacing)))
        pass ();
    else
        fail ("VIEWPORT.grid_spacing [2RD]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "height", &height, NULL)
        && height == viewport->height)
      pass ();
    else
      fail ("VIEWPORT.height [BD] %g != %g", viewport->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "height", &height, 0)
        && height == viewport->height)
      pass ();
    else
      fail ("VIEWPORT.height [BD] set+1 %g != %g", viewport->height, height);
    viewport->height--;
  }
  {
    BITCODE_RS id;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "id", &id, NULL)
        && id == viewport->id)
      pass ();
    else
      fail ("VIEWPORT.id [RS] %hu != %hu", viewport->id, id);
    id++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "id", &id, 0)
        && id == viewport->id)
      pass ();
    else
      fail ("VIEWPORT.id [RS] set+1 %hu != %hu", viewport->id, id);
    viewport->id--;
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "lens_length", &lens_length, NULL)
        && lens_length == viewport->lens_length)
      pass ();
    else
      fail ("VIEWPORT.lens_length [BD] %g != %g", viewport->lens_length, lens_length);
    lens_length++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "lens_length", &lens_length, 0)
        && lens_length == viewport->lens_length)
      pass ();
    else
      fail ("VIEWPORT.lens_length [BD] set+1 %g != %g", viewport->lens_length, lens_length);
    viewport->lens_length--;
  }
  {
    BITCODE_BL num_frozen_layers;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "num_frozen_layers", &num_frozen_layers, NULL)
        && num_frozen_layers == viewport->num_frozen_layers)
      pass ();
    else
      fail ("VIEWPORT.num_frozen_layers [BL] %u != %u", viewport->num_frozen_layers, num_frozen_layers);
    num_frozen_layers++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "num_frozen_layers", &num_frozen_layers, 0)
        && num_frozen_layers == viewport->num_frozen_layers)
      pass ();
    else
      fail ("VIEWPORT.num_frozen_layers [BL] set+1 %u != %u", viewport->num_frozen_layers, num_frozen_layers);
    viewport->num_frozen_layers--;
  }
  {
    BITCODE_RS on_off;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "on_off", &on_off, NULL)
        && on_off == viewport->on_off)
      pass ();
    else
      fail ("VIEWPORT.on_off [RS] %hu != %hu", viewport->on_off, on_off);
    on_off++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "on_off", &on_off, 0)
        && on_off == viewport->on_off)
      pass ();
    else
      fail ("VIEWPORT.on_off [RS] set+1 %hu != %hu", viewport->on_off, on_off);
    viewport->on_off--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "parent", &parent, NULL)
        && !memcmp (&parent, &viewport->parent, sizeof (viewport->parent)))
        pass ();
    else
        fail ("VIEWPORT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "render_mode", &render_mode, NULL)
        && render_mode == viewport->render_mode)
      pass ();
    else
      fail ("VIEWPORT.render_mode [RC] %u != %u", viewport->render_mode, render_mode);
    render_mode++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "render_mode", &render_mode, 0)
        && render_mode == viewport->render_mode)
      pass ();
    else
      fail ("VIEWPORT.render_mode [RC] set+1 %u != %u", viewport->render_mode, render_mode);
    viewport->render_mode--;
  }
  {
    BITCODE_BS shadeplot_mode;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "shadeplot_mode", &shadeplot_mode, NULL)
        && shadeplot_mode == viewport->shadeplot_mode)
      pass ();
    else
      fail ("VIEWPORT.shadeplot_mode [BS] %hu != %hu", viewport->shadeplot_mode, shadeplot_mode);
    shadeplot_mode++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "shadeplot_mode", &shadeplot_mode, 0)
        && shadeplot_mode == viewport->shadeplot_mode)
      pass ();
    else
      fail ("VIEWPORT.shadeplot_mode [BS] set+1 %hu != %hu", viewport->shadeplot_mode, shadeplot_mode);
    viewport->shadeplot_mode--;
  }
  {
    BITCODE_BD snap_angle;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "snap_angle", &snap_angle, NULL)
        && snap_angle == viewport->snap_angle)
      pass ();
    else
      fail ("VIEWPORT.snap_angle [BD] %g != %g", viewport->snap_angle, snap_angle);
    snap_angle++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "snap_angle", &snap_angle, 0)
        && snap_angle == viewport->snap_angle)
      pass ();
    else
      fail ("VIEWPORT.snap_angle [BD] set+1 %g != %g", viewport->snap_angle, snap_angle);
    viewport->snap_angle--;
  }
  {
    BITCODE_2RD snap_base;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "snap_base", &snap_base, NULL)
        && !memcmp (&snap_base, &viewport->snap_base, sizeof (viewport->snap_base)))
        pass ();
    else
        fail ("VIEWPORT.snap_base [2RD]");
  }
  {
    BITCODE_2RD snap_spacing;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "snap_spacing", &snap_spacing, NULL)
        && !memcmp (&snap_spacing, &viewport->snap_spacing, sizeof (viewport->snap_spacing)))
        pass ();
    else
        fail ("VIEWPORT.snap_spacing [2RD]");
  }
  {
    BITCODE_BL status_flag;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "status_flag", &status_flag, NULL)
        && status_flag == viewport->status_flag)
      pass ();
    else
      fail ("VIEWPORT.status_flag [BL] %u != %u", viewport->status_flag, status_flag);
    status_flag++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "status_flag", &status_flag, 0)
        && status_flag == viewport->status_flag)
      pass ();
    else
      fail ("VIEWPORT.status_flag [BL] set+1 %u != %u", viewport->status_flag, status_flag);
    viewport->status_flag--;
  }
  {
    BITCODE_T style_sheet;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "style_sheet", &style_sheet, NULL)
        && style_sheet
           ? strEQ ((char *)style_sheet, (char *)viewport->style_sheet)
           : !viewport->style_sheet)
      pass ();
    else
      fail ("VIEWPORT.style_sheet [T] '%s' <> '%s'", style_sheet, viewport->style_sheet);
  }
  {
    BITCODE_B ucs_at_origin;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_at_origin", &ucs_at_origin, NULL)
        && ucs_at_origin == viewport->ucs_at_origin)
      pass ();
    else
      fail ("VIEWPORT.ucs_at_origin [B] " FORMAT_B " != " FORMAT_B "", viewport->ucs_at_origin, ucs_at_origin);
    ucs_at_origin++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "ucs_at_origin", &ucs_at_origin, 0)
        && ucs_at_origin == viewport->ucs_at_origin)
      pass ();
    else
      fail ("VIEWPORT.ucs_at_origin [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->ucs_at_origin, ucs_at_origin);
    viewport->ucs_at_origin--;
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_elevation", &ucs_elevation, NULL)
        && ucs_elevation == viewport->ucs_elevation)
      pass ();
    else
      fail ("VIEWPORT.ucs_elevation [BD] %g != %g", viewport->ucs_elevation, ucs_elevation);
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "ucs_elevation", &ucs_elevation, 0)
        && ucs_elevation == viewport->ucs_elevation)
      pass ();
    else
      fail ("VIEWPORT.ucs_elevation [BD] set+1 %g != %g", viewport->ucs_elevation, ucs_elevation);
    viewport->ucs_elevation--;
  }
  {
    BITCODE_3BD ucs_origin;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp (&ucs_origin, &viewport->ucs_origin, sizeof (viewport->ucs_origin)))
        pass ();
    else
        fail ("VIEWPORT.ucs_origin [3BD]");
  }
  {
    BITCODE_BS ucs_ortho_view_type;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_ortho_view_type", &ucs_ortho_view_type, NULL)
        && ucs_ortho_view_type == viewport->ucs_ortho_view_type)
      pass ();
    else
      fail ("VIEWPORT.ucs_ortho_view_type [BS] %hu != %hu", viewport->ucs_ortho_view_type, ucs_ortho_view_type);
    ucs_ortho_view_type++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "ucs_ortho_view_type", &ucs_ortho_view_type, 0)
        && ucs_ortho_view_type == viewport->ucs_ortho_view_type)
      pass ();
    else
      fail ("VIEWPORT.ucs_ortho_view_type [BS] set+1 %hu != %hu", viewport->ucs_ortho_view_type, ucs_ortho_view_type);
    viewport->ucs_ortho_view_type--;
  }
  {
    BITCODE_B ucs_per_viewport;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_per_viewport", &ucs_per_viewport, NULL)
        && ucs_per_viewport == viewport->ucs_per_viewport)
      pass ();
    else
      fail ("VIEWPORT.ucs_per_viewport [B] " FORMAT_B " != " FORMAT_B "", viewport->ucs_per_viewport, ucs_per_viewport);
    ucs_per_viewport++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "ucs_per_viewport", &ucs_per_viewport, 0)
        && ucs_per_viewport == viewport->ucs_per_viewport)
      pass ();
    else
      fail ("VIEWPORT.ucs_per_viewport [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->ucs_per_viewport, ucs_per_viewport);
    viewport->ucs_per_viewport--;
  }
  {
    BITCODE_3BD ucs_x_axis;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp (&ucs_x_axis, &viewport->ucs_x_axis, sizeof (viewport->ucs_x_axis)))
        pass ();
    else
        fail ("VIEWPORT.ucs_x_axis [3BD]");
  }
  {
    BITCODE_3BD ucs_y_axis;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp (&ucs_y_axis, &viewport->ucs_y_axis, sizeof (viewport->ucs_y_axis)))
        pass ();
    else
        fail ("VIEWPORT.ucs_y_axis [3BD]");
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "use_default_lights", &use_default_lights, NULL)
        && use_default_lights == viewport->use_default_lights)
      pass ();
    else
      fail ("VIEWPORT.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", viewport->use_default_lights, use_default_lights);
    use_default_lights++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "use_default_lights", &use_default_lights, 0)
        && use_default_lights == viewport->use_default_lights)
      pass ();
    else
      fail ("VIEWPORT.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->use_default_lights, use_default_lights);
    viewport->use_default_lights--;
  }
  {
    BITCODE_2RD view_center;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "view_center", &view_center, NULL)
        && !memcmp (&view_center, &viewport->view_center, sizeof (viewport->view_center)))
        pass ();
    else
        fail ("VIEWPORT.view_center [2RD]");
  }
  {
    BITCODE_3BD view_direction;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "view_direction", &view_direction, NULL)
        && !memcmp (&view_direction, &viewport->view_direction, sizeof (viewport->view_direction)))
        pass ();
    else
        fail ("VIEWPORT.view_direction [3BD]");
  }
  {
    BITCODE_BD view_height;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "view_height", &view_height, NULL)
        && view_height == viewport->view_height)
      pass ();
    else
      fail ("VIEWPORT.view_height [BD] %g != %g", viewport->view_height, view_height);
    view_height++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "view_height", &view_height, 0)
        && view_height == viewport->view_height)
      pass ();
    else
      fail ("VIEWPORT.view_height [BD] set+1 %g != %g", viewport->view_height, view_height);
    viewport->view_height--;
  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "view_target", &view_target, NULL)
        && !memcmp (&view_target, &viewport->view_target, sizeof (viewport->view_target)))
        pass ();
    else
        fail ("VIEWPORT.view_target [3BD]");
  }
  {
    BITCODE_BD view_twist;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "view_twist", &view_twist, NULL)
        && view_twist == viewport->view_twist)
      pass ();
    else
      fail ("VIEWPORT.view_twist [BD] %g != %g", viewport->view_twist, view_twist);
    view_twist++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "view_twist", &view_twist, 0)
        && view_twist == viewport->view_twist)
      pass ();
    else
      fail ("VIEWPORT.view_twist [BD] set+1 %g != %g", viewport->view_twist, view_twist);
    viewport->view_twist--;
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "width", &width, NULL)
        && width == viewport->width)
      pass ();
    else
      fail ("VIEWPORT.width [BD] %g != %g", viewport->width, width);
    width++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "width", &width, 0)
        && width == viewport->width)
      pass ();
    else
      fail ("VIEWPORT.width [BD] set+1 %g != %g", viewport->width, width);
    viewport->width--;
  }
  if (failed && (is_class_unstable ("VIEWPORT") || is_class_debugging ("VIEWPORT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VIEWPORT", failed);
      failed = 0;
    }
  return failed;
}
static int test_WIPEOUT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_WIPEOUT *restrict wipeout = obj->tio.entity->tio.WIPEOUT;
  failed = 0;
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "brightness", &brightness, NULL)
        && brightness == wipeout->brightness)
      pass ();
    else
      fail ("WIPEOUT.brightness [RC] %u != %u", wipeout->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "brightness", &brightness, 0)
        && brightness == wipeout->brightness)
      pass ();
    else
      fail ("WIPEOUT.brightness [RC] set+1 %u != %u", wipeout->brightness, brightness);
    wipeout->brightness--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "class_version", &class_version, NULL)
        && class_version == wipeout->class_version)
      pass ();
    else
      fail ("WIPEOUT.class_version [BL] %u != %u", wipeout->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "class_version", &class_version, 0)
        && class_version == wipeout->class_version)
      pass ();
    else
      fail ("WIPEOUT.class_version [BL] set+1 %u != %u", wipeout->class_version, class_version);
    wipeout->class_version--;
  }
  {
    BITCODE_BS clip_boundary_type;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "clip_boundary_type", &clip_boundary_type, NULL)
        && clip_boundary_type == wipeout->clip_boundary_type)
      pass ();
    else
      fail ("WIPEOUT.clip_boundary_type [BS] %hu != %hu", wipeout->clip_boundary_type, clip_boundary_type);
    clip_boundary_type++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "clip_boundary_type", &clip_boundary_type, 0)
        && clip_boundary_type == wipeout->clip_boundary_type)
      pass ();
    else
      fail ("WIPEOUT.clip_boundary_type [BS] set+1 %hu != %hu", wipeout->clip_boundary_type, clip_boundary_type);
    wipeout->clip_boundary_type--;
  }
  {
    BITCODE_B clip_mode;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "clip_mode", &clip_mode, NULL)
        && clip_mode == wipeout->clip_mode)
      pass ();
    else
      fail ("WIPEOUT.clip_mode [B] " FORMAT_B " != " FORMAT_B "", wipeout->clip_mode, clip_mode);
    clip_mode++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "clip_mode", &clip_mode, 0)
        && clip_mode == wipeout->clip_mode)
      pass ();
    else
      fail ("WIPEOUT.clip_mode [B] set+1 " FORMAT_B " != " FORMAT_B "", wipeout->clip_mode, clip_mode);
    wipeout->clip_mode--;
  }
  {
    BITCODE_2RD* clip_verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "num_clip_verts", &count, NULL)
        && dwg_dynapi_entity_value (wipeout, "WIPEOUT", "clip_verts", &clip_verts, NULL)
        && clip_verts == wipeout->clip_verts)
      pass ();
    else
      fail ("WIPEOUT.clip_verts [2RD*] * %u num_clip_verts", count);
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "clipping", &clipping, NULL)
        && clipping == wipeout->clipping)
      pass ();
    else
      fail ("WIPEOUT.clipping [B] " FORMAT_B " != " FORMAT_B "", wipeout->clipping, clipping);
    clipping++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "clipping", &clipping, 0)
        && clipping == wipeout->clipping)
      pass ();
    else
      fail ("WIPEOUT.clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", wipeout->clipping, clipping);
    wipeout->clipping--;
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "contrast", &contrast, NULL)
        && contrast == wipeout->contrast)
      pass ();
    else
      fail ("WIPEOUT.contrast [RC] %u != %u", wipeout->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "contrast", &contrast, 0)
        && contrast == wipeout->contrast)
      pass ();
    else
      fail ("WIPEOUT.contrast [RC] set+1 %u != %u", wipeout->contrast, contrast);
    wipeout->contrast--;
  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "display_props", &display_props, NULL)
        && display_props == wipeout->display_props)
      pass ();
    else
      fail ("WIPEOUT.display_props [BS] %hu != %hu", wipeout->display_props, display_props);
    display_props++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "display_props", &display_props, 0)
        && display_props == wipeout->display_props)
      pass ();
    else
      fail ("WIPEOUT.display_props [BS] set+1 %hu != %hu", wipeout->display_props, display_props);
    wipeout->display_props--;
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "fade", &fade, NULL)
        && fade == wipeout->fade)
      pass ();
    else
      fail ("WIPEOUT.fade [RC] %u != %u", wipeout->fade, fade);
    fade++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "fade", &fade, 0)
        && fade == wipeout->fade)
      pass ();
    else
      fail ("WIPEOUT.fade [RC] set+1 %u != %u", wipeout->fade, fade);
    wipeout->fade--;
  }
  {
    BITCODE_H imagedef;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "imagedef", &imagedef, NULL)
        && !memcmp (&imagedef, &wipeout->imagedef, sizeof (wipeout->imagedef)))
        pass ();
    else
        fail ("WIPEOUT.imagedef [H]");
  }
  {
    BITCODE_H imagedefreactor;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "imagedefreactor", &imagedefreactor, NULL)
        && !memcmp (&imagedefreactor, &wipeout->imagedefreactor, sizeof (wipeout->imagedefreactor)))
        pass ();
    else
        fail ("WIPEOUT.imagedefreactor [H]");
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "num_clip_verts", &num_clip_verts, NULL)
        && num_clip_verts == wipeout->num_clip_verts)
      pass ();
    else
      fail ("WIPEOUT.num_clip_verts [BL] %u != %u", wipeout->num_clip_verts, num_clip_verts);
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "num_clip_verts", &num_clip_verts, 0)
        && num_clip_verts == wipeout->num_clip_verts)
      pass ();
    else
      fail ("WIPEOUT.num_clip_verts [BL] set+1 %u != %u", wipeout->num_clip_verts, num_clip_verts);
    wipeout->num_clip_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "parent", &parent, NULL)
        && !memcmp (&parent, &wipeout->parent, sizeof (wipeout->parent)))
        pass ();
    else
        fail ("WIPEOUT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "pt0", &pt0, NULL)
        && !memcmp (&pt0, &wipeout->pt0, sizeof (wipeout->pt0)))
        pass ();
    else
        fail ("WIPEOUT.pt0 [3BD]");
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "size", &size, NULL)
        && !memcmp (&size, &wipeout->size, sizeof (wipeout->size)))
        pass ();
    else
        fail ("WIPEOUT.size [2RD]");
  }
  {
    BITCODE_3BD uvec;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "uvec", &uvec, NULL)
        && !memcmp (&uvec, &wipeout->uvec, sizeof (wipeout->uvec)))
        pass ();
    else
        fail ("WIPEOUT.uvec [3BD]");
  }
  {
    BITCODE_3BD vvec;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "vvec", &vvec, NULL)
        && !memcmp (&vvec, &wipeout->vvec, sizeof (wipeout->vvec)))
        pass ();
    else
        fail ("WIPEOUT.vvec [3BD]");
  }
  if (failed && (is_class_unstable ("WIPEOUT") || is_class_debugging ("WIPEOUT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "WIPEOUT", failed);
      failed = 0;
    }
  return failed;
}
static int test_XLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_XLINE *restrict xline = obj->tio.entity->tio.XLINE;
  failed = 0;
  if (failed && (is_class_unstable ("XLINE") || is_class_debugging ("XLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "XLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_BOX_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_BOX_CLASS *restrict acsh_box_class = obj->tio.object->tio.ACSH_BOX_CLASS;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "class_version", &class_version, NULL)
        && class_version == acsh_box_class->class_version)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.class_version [BL] %u != %u", acsh_box_class->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "class_version", &class_version, 0)
        && class_version == acsh_box_class->class_version)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.class_version [BL] set+1 %u != %u", acsh_box_class->class_version, class_version);
    acsh_box_class->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "color", &color, NULL)
        && !memcmp (&color, &acsh_box_class->color, sizeof (acsh_box_class->color)))
        pass ();
    else
        fail ("ACSH_BOX_CLASS.color [CMC]");
  }
  {
    BITCODE_BL ee_bl98;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "ee_bl98", &ee_bl98, NULL)
        && ee_bl98 == acsh_box_class->ee_bl98)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.ee_bl98 [BL] %u != %u", acsh_box_class->ee_bl98, ee_bl98);
    ee_bl98++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "ee_bl98", &ee_bl98, 0)
        && ee_bl98 == acsh_box_class->ee_bl98)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.ee_bl98 [BL] set+1 %u != %u", acsh_box_class->ee_bl98, ee_bl98);
    acsh_box_class->ee_bl98--;
  }
  {
    BITCODE_BL ee_bl99;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "ee_bl99", &ee_bl99, NULL)
        && ee_bl99 == acsh_box_class->ee_bl99)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.ee_bl99 [BL] %u != %u", acsh_box_class->ee_bl99, ee_bl99);
    ee_bl99++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "ee_bl99", &ee_bl99, 0)
        && ee_bl99 == acsh_box_class->ee_bl99)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.ee_bl99 [BL] set+1 %u != %u", acsh_box_class->ee_bl99, ee_bl99);
    acsh_box_class->ee_bl99--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_box_class->parent, sizeof (acsh_box_class->parent)))
        pass ();
    else
        fail ("ACSH_BOX_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD shb_bd40;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bd40", &shb_bd40, NULL)
        && shb_bd40 == acsh_box_class->shb_bd40)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bd40 [BD] %g != %g", acsh_box_class->shb_bd40, shb_bd40);
    shb_bd40++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bd40", &shb_bd40, 0)
        && shb_bd40 == acsh_box_class->shb_bd40)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bd40 [BD] set+1 %g != %g", acsh_box_class->shb_bd40, shb_bd40);
    acsh_box_class->shb_bd40--;
  }
  {
    BITCODE_BD shb_bd41;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bd41", &shb_bd41, NULL)
        && shb_bd41 == acsh_box_class->shb_bd41)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bd41 [BD] %g != %g", acsh_box_class->shb_bd41, shb_bd41);
    shb_bd41++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bd41", &shb_bd41, 0)
        && shb_bd41 == acsh_box_class->shb_bd41)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bd41 [BD] set+1 %g != %g", acsh_box_class->shb_bd41, shb_bd41);
    acsh_box_class->shb_bd41--;
  }
  {
    BITCODE_BD shb_bd42;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bd42", &shb_bd42, NULL)
        && shb_bd42 == acsh_box_class->shb_bd42)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bd42 [BD] %g != %g", acsh_box_class->shb_bd42, shb_bd42);
    shb_bd42++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bd42", &shb_bd42, 0)
        && shb_bd42 == acsh_box_class->shb_bd42)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bd42 [BD] set+1 %g != %g", acsh_box_class->shb_bd42, shb_bd42);
    acsh_box_class->shb_bd42--;
  }
  {
    BITCODE_BL shb_bl90;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bl90", &shb_bl90, NULL)
        && shb_bl90 == acsh_box_class->shb_bl90)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bl90 [BL] %u != %u", acsh_box_class->shb_bl90, shb_bl90);
    shb_bl90++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bl90", &shb_bl90, 0)
        && shb_bl90 == acsh_box_class->shb_bl90)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bl90 [BL] set+1 %u != %u", acsh_box_class->shb_bl90, shb_bl90);
    acsh_box_class->shb_bl90--;
  }
  {
    BITCODE_BL shb_bl91;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bl91", &shb_bl91, NULL)
        && shb_bl91 == acsh_box_class->shb_bl91)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bl91 [BL] %u != %u", acsh_box_class->shb_bl91, shb_bl91);
    shb_bl91++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shb_bl91", &shb_bl91, 0)
        && shb_bl91 == acsh_box_class->shb_bl91)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shb_bl91 [BL] set+1 %u != %u", acsh_box_class->shb_bl91, shb_bl91);
    acsh_box_class->shb_bl91--;
  }
  {
    BITCODE_B shhn_b92;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_b92", &shhn_b92, NULL)
        && shhn_b92 == acsh_box_class->shhn_b92)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shhn_b92 [B] " FORMAT_B " != " FORMAT_B "", acsh_box_class->shhn_b92, shhn_b92);
    shhn_b92++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_b92", &shhn_b92, 0)
        && shhn_b92 == acsh_box_class->shhn_b92)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shhn_b92 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_box_class->shhn_b92, shhn_b92);
    acsh_box_class->shhn_b92--;
  }
  {
    BITCODE_BL shhn_bl347;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_bl347", &shhn_bl347, NULL)
        && shhn_bl347 == acsh_box_class->shhn_bl347)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shhn_bl347 [BL] %u != %u", acsh_box_class->shhn_bl347, shhn_bl347);
    shhn_bl347++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_bl347", &shhn_bl347, 0)
        && shhn_bl347 == acsh_box_class->shhn_bl347)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shhn_bl347 [BL] set+1 %u != %u", acsh_box_class->shhn_bl347, shhn_bl347);
    acsh_box_class->shhn_bl347--;
  }
  {
    BITCODE_BL shhn_bl90;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_bl90", &shhn_bl90, NULL)
        && shhn_bl90 == acsh_box_class->shhn_bl90)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shhn_bl90 [BL] %u != %u", acsh_box_class->shhn_bl90, shhn_bl90);
    shhn_bl90++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_bl90", &shhn_bl90, 0)
        && shhn_bl90 == acsh_box_class->shhn_bl90)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shhn_bl90 [BL] set+1 %u != %u", acsh_box_class->shhn_bl90, shhn_bl90);
    acsh_box_class->shhn_bl90--;
  }
  {
    BITCODE_BL shhn_bl91;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_bl91", &shhn_bl91, NULL)
        && shhn_bl91 == acsh_box_class->shhn_bl91)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shhn_bl91 [BL] %u != %u", acsh_box_class->shhn_bl91, shhn_bl91);
    shhn_bl91++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_bl91", &shhn_bl91, 0)
        && shhn_bl91 == acsh_box_class->shhn_bl91)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.shhn_bl91 [BL] set+1 %u != %u", acsh_box_class->shhn_bl91, shhn_bl91);
    acsh_box_class->shhn_bl91--;
  }
  {
    BITCODE_BD* shhn_pts;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "shhn_pts", &shhn_pts, NULL)
        && !memcmp (&shhn_pts, &acsh_box_class->shhn_pts, sizeof (acsh_box_class->shhn_pts)))
        pass ();
    else
        fail ("ACSH_BOX_CLASS.shhn_pts [BD*]");
  }
  if (failed && (is_class_unstable ("ACSH_BOX_CLASS") || is_class_debugging ("ACSH_BOX_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_BOX_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_EXTRUSION_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_EXTRUSION_CLASS *restrict acsh_extrusion_class = obj->tio.object->tio.ACSH_EXTRUSION_CLASS;
  failed = 0;
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "align_angle", &align_angle, NULL)
        && align_angle == acsh_extrusion_class->align_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.align_angle [BD] %g != %g", acsh_extrusion_class->align_angle, align_angle);
    align_angle++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "align_angle", &align_angle, 0)
        && align_angle == acsh_extrusion_class->align_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.align_angle [BD] set+1 %g != %g", acsh_extrusion_class->align_angle, align_angle);
    acsh_extrusion_class->align_angle--;
  }
  {
    BITCODE_RC align_option;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "align_option", &align_option, NULL)
        && align_option == acsh_extrusion_class->align_option)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.align_option [RC] %u != %u", acsh_extrusion_class->align_option, align_option);
    align_option++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "align_option", &align_option, 0)
        && align_option == acsh_extrusion_class->align_option)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.align_option [RC] set+1 %u != %u", acsh_extrusion_class->align_option, align_option);
    acsh_extrusion_class->align_option--;
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "bank", &bank, NULL)
        && bank == acsh_extrusion_class->bank)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.bank [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->bank, bank);
    bank++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "bank", &bank, 0)
        && bank == acsh_extrusion_class->bank)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->bank, bank);
    acsh_extrusion_class->bank--;
  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "basept", &basept, NULL)
        && !memcmp (&basept, &acsh_extrusion_class->basept, sizeof (acsh_extrusion_class->basept)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.basept [3BD]");
  }
  {
    BITCODE_B check_intersections;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "check_intersections", &check_intersections, NULL)
        && check_intersections == acsh_extrusion_class->check_intersections)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.check_intersections [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->check_intersections, check_intersections);
    check_intersections++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "check_intersections", &check_intersections, 0)
        && check_intersections == acsh_extrusion_class->check_intersections)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.check_intersections [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->check_intersections, check_intersections);
    acsh_extrusion_class->check_intersections--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "class_version", &class_version, NULL)
        && class_version == acsh_extrusion_class->class_version)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.class_version [BL] %u != %u", acsh_extrusion_class->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "class_version", &class_version, 0)
        && class_version == acsh_extrusion_class->class_version)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.class_version [BL] set+1 %u != %u", acsh_extrusion_class->class_version, class_version);
    acsh_extrusion_class->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "color", &color, NULL)
        && !memcmp (&color, &acsh_extrusion_class->color, sizeof (acsh_extrusion_class->color)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.color [CMC]");
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "draft_angle", &draft_angle, NULL)
        && draft_angle == acsh_extrusion_class->draft_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.draft_angle [BD] %g != %g", acsh_extrusion_class->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "draft_angle", &draft_angle, 0)
        && draft_angle == acsh_extrusion_class->draft_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.draft_angle [BD] set+1 %g != %g", acsh_extrusion_class->draft_angle, draft_angle);
    acsh_extrusion_class->draft_angle--;
  }
  {
    BITCODE_BL ee_bl98;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "ee_bl98", &ee_bl98, NULL)
        && ee_bl98 == acsh_extrusion_class->ee_bl98)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.ee_bl98 [BL] %u != %u", acsh_extrusion_class->ee_bl98, ee_bl98);
    ee_bl98++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "ee_bl98", &ee_bl98, 0)
        && ee_bl98 == acsh_extrusion_class->ee_bl98)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.ee_bl98 [BL] set+1 %u != %u", acsh_extrusion_class->ee_bl98, ee_bl98);
    acsh_extrusion_class->ee_bl98--;
  }
  {
    BITCODE_BL ee_bl99;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "ee_bl99", &ee_bl99, NULL)
        && ee_bl99 == acsh_extrusion_class->ee_bl99)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.ee_bl99 [BL] %u != %u", acsh_extrusion_class->ee_bl99, ee_bl99);
    ee_bl99++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "ee_bl99", &ee_bl99, 0)
        && ee_bl99 == acsh_extrusion_class->ee_bl99)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.ee_bl99 [BL] set+1 %u != %u", acsh_extrusion_class->ee_bl99, ee_bl99);
    acsh_extrusion_class->ee_bl99--;
  }
  {
    BITCODE_BD end_draft_dist;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "end_draft_dist", &end_draft_dist, NULL)
        && end_draft_dist == acsh_extrusion_class->end_draft_dist)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.end_draft_dist [BD] %g != %g", acsh_extrusion_class->end_draft_dist, end_draft_dist);
    end_draft_dist++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "end_draft_dist", &end_draft_dist, 0)
        && end_draft_dist == acsh_extrusion_class->end_draft_dist)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.end_draft_dist [BD] set+1 %g != %g", acsh_extrusion_class->end_draft_dist, end_draft_dist);
    acsh_extrusion_class->end_draft_dist--;
  }
  {
    BITCODE_B has_align_start;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "has_align_start", &has_align_start, NULL)
        && has_align_start == acsh_extrusion_class->has_align_start)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.has_align_start [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->has_align_start, has_align_start);
    has_align_start++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "has_align_start", &has_align_start, 0)
        && has_align_start == acsh_extrusion_class->has_align_start)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.has_align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->has_align_start, has_align_start);
    acsh_extrusion_class->has_align_start--;
  }
  {
    BITCODE_RC miter_option;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "miter_option", &miter_option, NULL)
        && miter_option == acsh_extrusion_class->miter_option)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.miter_option [RC] %u != %u", acsh_extrusion_class->miter_option, miter_option);
    miter_option++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "miter_option", &miter_option, 0)
        && miter_option == acsh_extrusion_class->miter_option)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.miter_option [RC] set+1 %u != %u", acsh_extrusion_class->miter_option, miter_option);
    acsh_extrusion_class->miter_option--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_extrusion_class->parent, sizeof (acsh_extrusion_class->parent)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD* pathentity_transform;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "pathentity_transform", &pathentity_transform, NULL)
        && !memcmp (&pathentity_transform, &acsh_extrusion_class->pathentity_transform, sizeof (acsh_extrusion_class->pathentity_transform)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.pathentity_transform [BD*]");
  }
  {
    BITCODE_3BD pt2;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "pt2", &pt2, NULL)
        && !memcmp (&pt2, &acsh_extrusion_class->pt2, sizeof (acsh_extrusion_class->pt2)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.pt2 [3BD]");
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "scale_factor", &scale_factor, NULL)
        && scale_factor == acsh_extrusion_class->scale_factor)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.scale_factor [BD] %g != %g", acsh_extrusion_class->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "scale_factor", &scale_factor, 0)
        && scale_factor == acsh_extrusion_class->scale_factor)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.scale_factor [BD] set+1 %g != %g", acsh_extrusion_class->scale_factor, scale_factor);
    acsh_extrusion_class->scale_factor--;
  }
  {
    BITCODE_B shhn_b92;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_b92", &shhn_b92, NULL)
        && shhn_b92 == acsh_extrusion_class->shhn_b92)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shhn_b92 [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shhn_b92, shhn_b92);
    shhn_b92++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_b92", &shhn_b92, 0)
        && shhn_b92 == acsh_extrusion_class->shhn_b92)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shhn_b92 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shhn_b92, shhn_b92);
    acsh_extrusion_class->shhn_b92--;
  }
  {
    BITCODE_BL shhn_bl347;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_bl347", &shhn_bl347, NULL)
        && shhn_bl347 == acsh_extrusion_class->shhn_bl347)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shhn_bl347 [BL] %u != %u", acsh_extrusion_class->shhn_bl347, shhn_bl347);
    shhn_bl347++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_bl347", &shhn_bl347, 0)
        && shhn_bl347 == acsh_extrusion_class->shhn_bl347)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shhn_bl347 [BL] set+1 %u != %u", acsh_extrusion_class->shhn_bl347, shhn_bl347);
    acsh_extrusion_class->shhn_bl347--;
  }
  {
    BITCODE_BL shhn_bl90;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_bl90", &shhn_bl90, NULL)
        && shhn_bl90 == acsh_extrusion_class->shhn_bl90)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shhn_bl90 [BL] %u != %u", acsh_extrusion_class->shhn_bl90, shhn_bl90);
    shhn_bl90++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_bl90", &shhn_bl90, 0)
        && shhn_bl90 == acsh_extrusion_class->shhn_bl90)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shhn_bl90 [BL] set+1 %u != %u", acsh_extrusion_class->shhn_bl90, shhn_bl90);
    acsh_extrusion_class->shhn_bl90--;
  }
  {
    BITCODE_BL shhn_bl91;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_bl91", &shhn_bl91, NULL)
        && shhn_bl91 == acsh_extrusion_class->shhn_bl91)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shhn_bl91 [BL] %u != %u", acsh_extrusion_class->shhn_bl91, shhn_bl91);
    shhn_bl91++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_bl91", &shhn_bl91, 0)
        && shhn_bl91 == acsh_extrusion_class->shhn_bl91)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shhn_bl91 [BL] set+1 %u != %u", acsh_extrusion_class->shhn_bl91, shhn_bl91);
    acsh_extrusion_class->shhn_bl91--;
  }
  {
    BITCODE_BD* shhn_pts;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shhn_pts", &shhn_pts, NULL)
        && !memcmp (&shhn_pts, &acsh_extrusion_class->shhn_pts, sizeof (acsh_extrusion_class->shhn_pts)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.shhn_pts [BD*]");
  }
  {
    BITCODE_B shsw_b294;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b294", &shsw_b294, NULL)
        && shsw_b294 == acsh_extrusion_class->shsw_b294)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b294 [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b294, shsw_b294);
    shsw_b294++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b294", &shsw_b294, 0)
        && shsw_b294 == acsh_extrusion_class->shsw_b294)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b294 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b294, shsw_b294);
    acsh_extrusion_class->shsw_b294--;
  }
  {
    BITCODE_B shsw_b295;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b295", &shsw_b295, NULL)
        && shsw_b295 == acsh_extrusion_class->shsw_b295)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b295 [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b295, shsw_b295);
    shsw_b295++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b295", &shsw_b295, 0)
        && shsw_b295 == acsh_extrusion_class->shsw_b295)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b295 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b295, shsw_b295);
    acsh_extrusion_class->shsw_b295--;
  }
  {
    BITCODE_B shsw_b296;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b296", &shsw_b296, NULL)
        && shsw_b296 == acsh_extrusion_class->shsw_b296)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b296 [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b296, shsw_b296);
    shsw_b296++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b296", &shsw_b296, 0)
        && shsw_b296 == acsh_extrusion_class->shsw_b296)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b296 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b296, shsw_b296);
    acsh_extrusion_class->shsw_b296--;
  }
  {
    BITCODE_BL shsw_bl90;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl90", &shsw_bl90, NULL)
        && shsw_bl90 == acsh_extrusion_class->shsw_bl90)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl90 [BL] %u != %u", acsh_extrusion_class->shsw_bl90, shsw_bl90);
    shsw_bl90++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl90", &shsw_bl90, 0)
        && shsw_bl90 == acsh_extrusion_class->shsw_bl90)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl90 [BL] set+1 %u != %u", acsh_extrusion_class->shsw_bl90, shsw_bl90);
    acsh_extrusion_class->shsw_bl90--;
  }
  {
    BITCODE_BL shsw_bl91;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl91", &shsw_bl91, NULL)
        && shsw_bl91 == acsh_extrusion_class->shsw_bl91)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl91 [BL] %u != %u", acsh_extrusion_class->shsw_bl91, shsw_bl91);
    shsw_bl91++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl91", &shsw_bl91, 0)
        && shsw_bl91 == acsh_extrusion_class->shsw_bl91)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl91 [BL] set+1 %u != %u", acsh_extrusion_class->shsw_bl91, shsw_bl91);
    acsh_extrusion_class->shsw_bl91--;
  }
  {
    BITCODE_BL shsw_bl92;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl92", &shsw_bl92, NULL)
        && shsw_bl92 == acsh_extrusion_class->shsw_bl92)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl92 [BL] %u != %u", acsh_extrusion_class->shsw_bl92, shsw_bl92);
    shsw_bl92++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl92", &shsw_bl92, 0)
        && shsw_bl92 == acsh_extrusion_class->shsw_bl92)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl92 [BL] set+1 %u != %u", acsh_extrusion_class->shsw_bl92, shsw_bl92);
    acsh_extrusion_class->shsw_bl92--;
  }
  {
    BITCODE_BL shsw_bl93;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl93", &shsw_bl93, NULL)
        && shsw_bl93 == acsh_extrusion_class->shsw_bl93)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl93 [BL] %u != %u", acsh_extrusion_class->shsw_bl93, shsw_bl93);
    shsw_bl93++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl93", &shsw_bl93, 0)
        && shsw_bl93 == acsh_extrusion_class->shsw_bl93)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl93 [BL] set+1 %u != %u", acsh_extrusion_class->shsw_bl93, shsw_bl93);
    acsh_extrusion_class->shsw_bl93--;
  }
  {
    BITCODE_TF shsw_text;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text", &shsw_text, NULL)
        && !memcmp (&shsw_text, &acsh_extrusion_class->shsw_text, sizeof (acsh_extrusion_class->shsw_text)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.shsw_text [TF]");
  }
  {
    BITCODE_TF shsw_text2;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text2", &shsw_text2, NULL)
        && !memcmp (&shsw_text2, &acsh_extrusion_class->shsw_text2, sizeof (acsh_extrusion_class->shsw_text2)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.shsw_text2 [TF]");
  }
  {
    BITCODE_BL shsw_text2_size;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text2_size", &shsw_text2_size, NULL)
        && shsw_text2_size == acsh_extrusion_class->shsw_text2_size)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_text2_size [BL] %u != %u", acsh_extrusion_class->shsw_text2_size, shsw_text2_size);
    shsw_text2_size++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text2_size", &shsw_text2_size, 0)
        && shsw_text2_size == acsh_extrusion_class->shsw_text2_size)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_text2_size [BL] set+1 %u != %u", acsh_extrusion_class->shsw_text2_size, shsw_text2_size);
    acsh_extrusion_class->shsw_text2_size--;
  }
  {
    BITCODE_BL shsw_text_size;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text_size", &shsw_text_size, NULL)
        && shsw_text_size == acsh_extrusion_class->shsw_text_size)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_text_size [BL] %u != %u", acsh_extrusion_class->shsw_text_size, shsw_text_size);
    shsw_text_size++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text_size", &shsw_text_size, 0)
        && shsw_text_size == acsh_extrusion_class->shsw_text_size)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_text_size [BL] set+1 %u != %u", acsh_extrusion_class->shsw_text_size, shsw_text_size);
    acsh_extrusion_class->shsw_text_size--;
  }
  {
    BITCODE_BD start_draft_dist;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "start_draft_dist", &start_draft_dist, NULL)
        && start_draft_dist == acsh_extrusion_class->start_draft_dist)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.start_draft_dist [BD] %g != %g", acsh_extrusion_class->start_draft_dist, start_draft_dist);
    start_draft_dist++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "start_draft_dist", &start_draft_dist, 0)
        && start_draft_dist == acsh_extrusion_class->start_draft_dist)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.start_draft_dist [BD] set+1 %g != %g", acsh_extrusion_class->start_draft_dist, start_draft_dist);
    acsh_extrusion_class->start_draft_dist--;
  }
  {
    BITCODE_BD* sweepentity_transform;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "sweepentity_transform", &sweepentity_transform, NULL)
        && !memcmp (&sweepentity_transform, &acsh_extrusion_class->sweepentity_transform, sizeof (acsh_extrusion_class->sweepentity_transform)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.sweepentity_transform [BD*]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "twist_angle", &twist_angle, NULL)
        && twist_angle == acsh_extrusion_class->twist_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.twist_angle [BD] %g != %g", acsh_extrusion_class->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "twist_angle", &twist_angle, 0)
        && twist_angle == acsh_extrusion_class->twist_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.twist_angle [BD] set+1 %g != %g", acsh_extrusion_class->twist_angle, twist_angle);
    acsh_extrusion_class->twist_angle--;
  }
  if (failed && (is_class_unstable ("ACSH_EXTRUSION_CLASS") || is_class_debugging ("ACSH_EXTRUSION_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_EXTRUSION_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_SWEEP_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_SWEEP_CLASS *restrict acsh_sweep_class = obj->tio.object->tio.ACSH_SWEEP_CLASS;
  failed = 0;
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_angle", &align_angle, NULL)
        && align_angle == acsh_sweep_class->align_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.align_angle [BD] %g != %g", acsh_sweep_class->align_angle, align_angle);
    align_angle++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_angle", &align_angle, 0)
        && align_angle == acsh_sweep_class->align_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.align_angle [BD] set+1 %g != %g", acsh_sweep_class->align_angle, align_angle);
    acsh_sweep_class->align_angle--;
  }
  {
    BITCODE_RC align_option;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_option", &align_option, NULL)
        && align_option == acsh_sweep_class->align_option)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.align_option [RC] %u != %u", acsh_sweep_class->align_option, align_option);
    align_option++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_option", &align_option, 0)
        && align_option == acsh_sweep_class->align_option)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.align_option [RC] set+1 %u != %u", acsh_sweep_class->align_option, align_option);
    acsh_sweep_class->align_option--;
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "bank", &bank, NULL)
        && bank == acsh_sweep_class->bank)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.bank [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->bank, bank);
    bank++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "bank", &bank, 0)
        && bank == acsh_sweep_class->bank)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->bank, bank);
    acsh_sweep_class->bank--;
  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "basept", &basept, NULL)
        && !memcmp (&basept, &acsh_sweep_class->basept, sizeof (acsh_sweep_class->basept)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.basept [3BD]");
  }
  {
    BITCODE_B check_intersections;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "check_intersections", &check_intersections, NULL)
        && check_intersections == acsh_sweep_class->check_intersections)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.check_intersections [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->check_intersections, check_intersections);
    check_intersections++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "check_intersections", &check_intersections, 0)
        && check_intersections == acsh_sweep_class->check_intersections)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.check_intersections [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->check_intersections, check_intersections);
    acsh_sweep_class->check_intersections--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "class_version", &class_version, NULL)
        && class_version == acsh_sweep_class->class_version)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.class_version [BL] %u != %u", acsh_sweep_class->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "class_version", &class_version, 0)
        && class_version == acsh_sweep_class->class_version)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.class_version [BL] set+1 %u != %u", acsh_sweep_class->class_version, class_version);
    acsh_sweep_class->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "color", &color, NULL)
        && !memcmp (&color, &acsh_sweep_class->color, sizeof (acsh_sweep_class->color)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.color [CMC]");
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "draft_angle", &draft_angle, NULL)
        && draft_angle == acsh_sweep_class->draft_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.draft_angle [BD] %g != %g", acsh_sweep_class->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "draft_angle", &draft_angle, 0)
        && draft_angle == acsh_sweep_class->draft_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.draft_angle [BD] set+1 %g != %g", acsh_sweep_class->draft_angle, draft_angle);
    acsh_sweep_class->draft_angle--;
  }
  {
    BITCODE_BL ee_bl98;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl98", &ee_bl98, NULL)
        && ee_bl98 == acsh_sweep_class->ee_bl98)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.ee_bl98 [BL] %u != %u", acsh_sweep_class->ee_bl98, ee_bl98);
    ee_bl98++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl98", &ee_bl98, 0)
        && ee_bl98 == acsh_sweep_class->ee_bl98)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.ee_bl98 [BL] set+1 %u != %u", acsh_sweep_class->ee_bl98, ee_bl98);
    acsh_sweep_class->ee_bl98--;
  }
  {
    BITCODE_BL ee_bl99;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl99", &ee_bl99, NULL)
        && ee_bl99 == acsh_sweep_class->ee_bl99)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.ee_bl99 [BL] %u != %u", acsh_sweep_class->ee_bl99, ee_bl99);
    ee_bl99++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl99", &ee_bl99, 0)
        && ee_bl99 == acsh_sweep_class->ee_bl99)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.ee_bl99 [BL] set+1 %u != %u", acsh_sweep_class->ee_bl99, ee_bl99);
    acsh_sweep_class->ee_bl99--;
  }
  {
    BITCODE_BD end_draft_dist;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "end_draft_dist", &end_draft_dist, NULL)
        && end_draft_dist == acsh_sweep_class->end_draft_dist)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.end_draft_dist [BD] %g != %g", acsh_sweep_class->end_draft_dist, end_draft_dist);
    end_draft_dist++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "end_draft_dist", &end_draft_dist, 0)
        && end_draft_dist == acsh_sweep_class->end_draft_dist)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.end_draft_dist [BD] set+1 %g != %g", acsh_sweep_class->end_draft_dist, end_draft_dist);
    acsh_sweep_class->end_draft_dist--;
  }
  {
    BITCODE_B has_align_start;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "has_align_start", &has_align_start, NULL)
        && has_align_start == acsh_sweep_class->has_align_start)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.has_align_start [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->has_align_start, has_align_start);
    has_align_start++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "has_align_start", &has_align_start, 0)
        && has_align_start == acsh_sweep_class->has_align_start)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.has_align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->has_align_start, has_align_start);
    acsh_sweep_class->has_align_start--;
  }
  {
    BITCODE_RC miter_option;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "miter_option", &miter_option, NULL)
        && miter_option == acsh_sweep_class->miter_option)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.miter_option [RC] %u != %u", acsh_sweep_class->miter_option, miter_option);
    miter_option++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "miter_option", &miter_option, 0)
        && miter_option == acsh_sweep_class->miter_option)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.miter_option [RC] set+1 %u != %u", acsh_sweep_class->miter_option, miter_option);
    acsh_sweep_class->miter_option--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_sweep_class->parent, sizeof (acsh_sweep_class->parent)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD* pathentity_transform;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "pathentity_transform", &pathentity_transform, NULL)
        && !memcmp (&pathentity_transform, &acsh_sweep_class->pathentity_transform, sizeof (acsh_sweep_class->pathentity_transform)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.pathentity_transform [BD*]");
  }
  {
    BITCODE_3BD pt2;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "pt2", &pt2, NULL)
        && !memcmp (&pt2, &acsh_sweep_class->pt2, sizeof (acsh_sweep_class->pt2)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.pt2 [3BD]");
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "scale_factor", &scale_factor, NULL)
        && scale_factor == acsh_sweep_class->scale_factor)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.scale_factor [BD] %g != %g", acsh_sweep_class->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "scale_factor", &scale_factor, 0)
        && scale_factor == acsh_sweep_class->scale_factor)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.scale_factor [BD] set+1 %g != %g", acsh_sweep_class->scale_factor, scale_factor);
    acsh_sweep_class->scale_factor--;
  }
  {
    BITCODE_B shhn_b92;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_b92", &shhn_b92, NULL)
        && shhn_b92 == acsh_sweep_class->shhn_b92)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shhn_b92 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shhn_b92, shhn_b92);
    shhn_b92++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_b92", &shhn_b92, 0)
        && shhn_b92 == acsh_sweep_class->shhn_b92)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shhn_b92 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shhn_b92, shhn_b92);
    acsh_sweep_class->shhn_b92--;
  }
  {
    BITCODE_BL shhn_bl347;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl347", &shhn_bl347, NULL)
        && shhn_bl347 == acsh_sweep_class->shhn_bl347)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shhn_bl347 [BL] %u != %u", acsh_sweep_class->shhn_bl347, shhn_bl347);
    shhn_bl347++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl347", &shhn_bl347, 0)
        && shhn_bl347 == acsh_sweep_class->shhn_bl347)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shhn_bl347 [BL] set+1 %u != %u", acsh_sweep_class->shhn_bl347, shhn_bl347);
    acsh_sweep_class->shhn_bl347--;
  }
  {
    BITCODE_BL shhn_bl90;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl90", &shhn_bl90, NULL)
        && shhn_bl90 == acsh_sweep_class->shhn_bl90)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shhn_bl90 [BL] %u != %u", acsh_sweep_class->shhn_bl90, shhn_bl90);
    shhn_bl90++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl90", &shhn_bl90, 0)
        && shhn_bl90 == acsh_sweep_class->shhn_bl90)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shhn_bl90 [BL] set+1 %u != %u", acsh_sweep_class->shhn_bl90, shhn_bl90);
    acsh_sweep_class->shhn_bl90--;
  }
  {
    BITCODE_BL shhn_bl91;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl91", &shhn_bl91, NULL)
        && shhn_bl91 == acsh_sweep_class->shhn_bl91)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shhn_bl91 [BL] %u != %u", acsh_sweep_class->shhn_bl91, shhn_bl91);
    shhn_bl91++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl91", &shhn_bl91, 0)
        && shhn_bl91 == acsh_sweep_class->shhn_bl91)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shhn_bl91 [BL] set+1 %u != %u", acsh_sweep_class->shhn_bl91, shhn_bl91);
    acsh_sweep_class->shhn_bl91--;
  }
  {
    BITCODE_BD* shhn_pts;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_pts", &shhn_pts, NULL)
        && !memcmp (&shhn_pts, &acsh_sweep_class->shhn_pts, sizeof (acsh_sweep_class->shhn_pts)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.shhn_pts [BD*]");
  }
  {
    BITCODE_B shsw_b294;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b294", &shsw_b294, NULL)
        && shsw_b294 == acsh_sweep_class->shsw_b294)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b294 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b294, shsw_b294);
    shsw_b294++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b294", &shsw_b294, 0)
        && shsw_b294 == acsh_sweep_class->shsw_b294)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b294 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b294, shsw_b294);
    acsh_sweep_class->shsw_b294--;
  }
  {
    BITCODE_B shsw_b295;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b295", &shsw_b295, NULL)
        && shsw_b295 == acsh_sweep_class->shsw_b295)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b295 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b295, shsw_b295);
    shsw_b295++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b295", &shsw_b295, 0)
        && shsw_b295 == acsh_sweep_class->shsw_b295)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b295 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b295, shsw_b295);
    acsh_sweep_class->shsw_b295--;
  }
  {
    BITCODE_B shsw_b296;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b296", &shsw_b296, NULL)
        && shsw_b296 == acsh_sweep_class->shsw_b296)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b296 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b296, shsw_b296);
    shsw_b296++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b296", &shsw_b296, 0)
        && shsw_b296 == acsh_sweep_class->shsw_b296)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b296 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b296, shsw_b296);
    acsh_sweep_class->shsw_b296--;
  }
  {
    BITCODE_BL shsw_bl90;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl90", &shsw_bl90, NULL)
        && shsw_bl90 == acsh_sweep_class->shsw_bl90)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl90 [BL] %u != %u", acsh_sweep_class->shsw_bl90, shsw_bl90);
    shsw_bl90++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl90", &shsw_bl90, 0)
        && shsw_bl90 == acsh_sweep_class->shsw_bl90)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl90 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl90, shsw_bl90);
    acsh_sweep_class->shsw_bl90--;
  }
  {
    BITCODE_BL shsw_bl91;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl91", &shsw_bl91, NULL)
        && shsw_bl91 == acsh_sweep_class->shsw_bl91)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl91 [BL] %u != %u", acsh_sweep_class->shsw_bl91, shsw_bl91);
    shsw_bl91++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl91", &shsw_bl91, 0)
        && shsw_bl91 == acsh_sweep_class->shsw_bl91)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl91 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl91, shsw_bl91);
    acsh_sweep_class->shsw_bl91--;
  }
  {
    BITCODE_BL shsw_bl92;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl92", &shsw_bl92, NULL)
        && shsw_bl92 == acsh_sweep_class->shsw_bl92)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl92 [BL] %u != %u", acsh_sweep_class->shsw_bl92, shsw_bl92);
    shsw_bl92++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl92", &shsw_bl92, 0)
        && shsw_bl92 == acsh_sweep_class->shsw_bl92)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl92 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl92, shsw_bl92);
    acsh_sweep_class->shsw_bl92--;
  }
  {
    BITCODE_BL shsw_bl93;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl93", &shsw_bl93, NULL)
        && shsw_bl93 == acsh_sweep_class->shsw_bl93)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] %u != %u", acsh_sweep_class->shsw_bl93, shsw_bl93);
    shsw_bl93++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl93", &shsw_bl93, 0)
        && shsw_bl93 == acsh_sweep_class->shsw_bl93)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl93, shsw_bl93);
    acsh_sweep_class->shsw_bl93--;
  }
  {
    BITCODE_TF shsw_text;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text", &shsw_text, NULL)
        && !memcmp (&shsw_text, &acsh_sweep_class->shsw_text, sizeof (acsh_sweep_class->shsw_text)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.shsw_text [TF]");
  }
  {
    BITCODE_TF shsw_text2;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text2", &shsw_text2, NULL)
        && !memcmp (&shsw_text2, &acsh_sweep_class->shsw_text2, sizeof (acsh_sweep_class->shsw_text2)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.shsw_text2 [TF]");
  }
  {
    BITCODE_BL shsw_text2_size;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text2_size", &shsw_text2_size, NULL)
        && shsw_text2_size == acsh_sweep_class->shsw_text2_size)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_text2_size [BL] %u != %u", acsh_sweep_class->shsw_text2_size, shsw_text2_size);
    shsw_text2_size++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text2_size", &shsw_text2_size, 0)
        && shsw_text2_size == acsh_sweep_class->shsw_text2_size)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_text2_size [BL] set+1 %u != %u", acsh_sweep_class->shsw_text2_size, shsw_text2_size);
    acsh_sweep_class->shsw_text2_size--;
  }
  {
    BITCODE_BL shsw_text_size;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text_size", &shsw_text_size, NULL)
        && shsw_text_size == acsh_sweep_class->shsw_text_size)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_text_size [BL] %u != %u", acsh_sweep_class->shsw_text_size, shsw_text_size);
    shsw_text_size++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text_size", &shsw_text_size, 0)
        && shsw_text_size == acsh_sweep_class->shsw_text_size)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_text_size [BL] set+1 %u != %u", acsh_sweep_class->shsw_text_size, shsw_text_size);
    acsh_sweep_class->shsw_text_size--;
  }
  {
    BITCODE_BD start_draft_dist;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "start_draft_dist", &start_draft_dist, NULL)
        && start_draft_dist == acsh_sweep_class->start_draft_dist)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.start_draft_dist [BD] %g != %g", acsh_sweep_class->start_draft_dist, start_draft_dist);
    start_draft_dist++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "start_draft_dist", &start_draft_dist, 0)
        && start_draft_dist == acsh_sweep_class->start_draft_dist)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.start_draft_dist [BD] set+1 %g != %g", acsh_sweep_class->start_draft_dist, start_draft_dist);
    acsh_sweep_class->start_draft_dist--;
  }
  {
    BITCODE_BD* sweepentity_transform;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "sweepentity_transform", &sweepentity_transform, NULL)
        && !memcmp (&sweepentity_transform, &acsh_sweep_class->sweepentity_transform, sizeof (acsh_sweep_class->sweepentity_transform)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.sweepentity_transform [BD*]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "twist_angle", &twist_angle, NULL)
        && twist_angle == acsh_sweep_class->twist_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.twist_angle [BD] %g != %g", acsh_sweep_class->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "twist_angle", &twist_angle, 0)
        && twist_angle == acsh_sweep_class->twist_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.twist_angle [BD] set+1 %g != %g", acsh_sweep_class->twist_angle, twist_angle);
    acsh_sweep_class->twist_angle--;
  }
  if (failed && (is_class_unstable ("ACSH_SWEEP_CLASS") || is_class_debugging ("ACSH_SWEEP_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_SWEEP_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ALDIMOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ALDIMOBJECTCONTEXTDATA *restrict aldimobjectcontextdata = obj->tio.object->tio.ALDIMOBJECTCONTEXTDATA;
  failed = 0;
  {
    BITCODE_3BD _11pt;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "_11pt", &_11pt, NULL)
        && !memcmp (&_11pt, &aldimobjectcontextdata->_11pt, sizeof (aldimobjectcontextdata->_11pt)))
        pass ();
    else
        fail ("ALDIMOBJECTCONTEXTDATA._11pt [3BD]");
  }
  {
    BITCODE_B b280;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b280", &b280, NULL)
        && b280 == aldimobjectcontextdata->b280)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b280 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b280, b280);
    b280++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b280", &b280, 0)
        && b280 == aldimobjectcontextdata->b280)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b280 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b280, b280);
    aldimobjectcontextdata->b280--;
  }
  {
    BITCODE_B b291;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b291", &b291, NULL)
        && b291 == aldimobjectcontextdata->b291)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b291 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b291, b291);
    b291++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b291", &b291, 0)
        && b291 == aldimobjectcontextdata->b291)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b291 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b291, b291);
    aldimobjectcontextdata->b291--;
  }
  {
    BITCODE_B b292;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b292", &b292, NULL)
        && b292 == aldimobjectcontextdata->b292)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b292 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b292, b292);
    b292++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b292", &b292, 0)
        && b292 == aldimobjectcontextdata->b292)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b292 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b292, b292);
    aldimobjectcontextdata->b292--;
  }
  {
    BITCODE_B b293;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b293", &b293, NULL)
        && b293 == aldimobjectcontextdata->b293)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b293 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b293, b293);
    b293++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b293", &b293, 0)
        && b293 == aldimobjectcontextdata->b293)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b293 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b293, b293);
    aldimobjectcontextdata->b293--;
  }
  {
    BITCODE_B b294;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b294", &b294, NULL)
        && b294 == aldimobjectcontextdata->b294)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b294 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b294, b294);
    b294++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b294", &b294, 0)
        && b294 == aldimobjectcontextdata->b294)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b294 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b294, b294);
    aldimobjectcontextdata->b294--;
  }
  {
    BITCODE_B b295;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b295", &b295, NULL)
        && b295 == aldimobjectcontextdata->b295)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b295 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b295, b295);
    b295++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b295", &b295, 0)
        && b295 == aldimobjectcontextdata->b295)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b295 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b295, b295);
    aldimobjectcontextdata->b295--;
  }
  {
    BITCODE_B b296;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b296", &b296, NULL)
        && b296 == aldimobjectcontextdata->b296)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b296 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b296, b296);
    b296++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b296", &b296, 0)
        && b296 == aldimobjectcontextdata->b296)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b296 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b296, b296);
    aldimobjectcontextdata->b296--;
  }
  {
    BITCODE_B b297;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b297", &b297, NULL)
        && b297 == aldimobjectcontextdata->b297)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b297 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b297, b297);
    b297++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b297", &b297, 0)
        && b297 == aldimobjectcontextdata->b297)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b297 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b297, b297);
    aldimobjectcontextdata->b297--;
  }
  {
    BITCODE_B b298;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b298", &b298, NULL)
        && b298 == aldimobjectcontextdata->b298)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b298 [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b298, b298);
    b298++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "b298", &b298, 0)
        && b298 == aldimobjectcontextdata->b298)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.b298 [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->b298, b298);
    aldimobjectcontextdata->b298--;
  }
  {
    BITCODE_BD bd140;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "bd140", &bd140, NULL)
        && bd140 == aldimobjectcontextdata->bd140)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.bd140 [BD] %g != %g", aldimobjectcontextdata->bd140, bd140);
    bd140++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "bd140", &bd140, 0)
        && bd140 == aldimobjectcontextdata->bd140)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.bd140 [BD] set+1 %g != %g", aldimobjectcontextdata->bd140, bd140);
    aldimobjectcontextdata->bd140--;
  }
  {
    BITCODE_BS bs71;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "bs71", &bs71, NULL)
        && bs71 == aldimobjectcontextdata->bs71)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.bs71 [BS] %hu != %hu", aldimobjectcontextdata->bs71, bs71);
    bs71++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "bs71", &bs71, 0)
        && bs71 == aldimobjectcontextdata->bs71)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.bs71 [BS] set+1 %hu != %hu", aldimobjectcontextdata->bs71, bs71);
    aldimobjectcontextdata->bs71--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == aldimobjectcontextdata->class_version)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", aldimobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == aldimobjectcontextdata->class_version)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", aldimobjectcontextdata->class_version, class_version);
    aldimobjectcontextdata->class_version--;
  }
  {
    BITCODE_2RD def_pt;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &aldimobjectcontextdata->def_pt, sizeof (aldimobjectcontextdata->def_pt)))
        pass ();
    else
        fail ("ALDIMOBJECTCONTEXTDATA.def_pt [2RD]");
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL)
        && defaultflag == aldimobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->defaultflag, defaultflag);
    defaultflag++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "defaultflag", &defaultflag, 0)
        && defaultflag == aldimobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->defaultflag, defaultflag);
    aldimobjectcontextdata->defaultflag--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "flag", &flag, NULL)
        && flag == aldimobjectcontextdata->flag)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.flag [BS] %hu != %hu", aldimobjectcontextdata->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "flag", &flag, 0)
        && flag == aldimobjectcontextdata->flag)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.flag [BS] set+1 %hu != %hu", aldimobjectcontextdata->flag, flag);
    aldimobjectcontextdata->flag--;
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "has_file", &has_file, NULL)
        && has_file == aldimobjectcontextdata->has_file)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->has_file, has_file);
    has_file++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "has_file", &has_file, 0)
        && has_file == aldimobjectcontextdata->has_file)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->has_file, has_file);
    aldimobjectcontextdata->has_file--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)aldimobjectcontextdata->name)
           : !aldimobjectcontextdata->name)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.name [T] '%s' <> '%s'", name, aldimobjectcontextdata->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &aldimobjectcontextdata->parent, sizeof (aldimobjectcontextdata->parent)))
        pass ();
    else
        fail ("ALDIMOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &aldimobjectcontextdata->scale, sizeof (aldimobjectcontextdata->scale)))
        pass ();
    else
        fail ("ALDIMOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("ALDIMOBJECTCONTEXTDATA") || is_class_debugging ("ALDIMOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ALDIMOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_APPID (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_APPID *restrict appid = obj->tio.object->tio.APPID;
  failed = 0;
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (appid, "APPID", "flag", &flag, NULL)
        && flag == appid->flag)
      pass ();
    else
      fail ("APPID.flag [RC] %u != %u", appid->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "flag", &flag, 0)
        && flag == appid->flag)
      pass ();
    else
      fail ("APPID.flag [RC] set+1 %u != %u", appid->flag, flag);
    appid->flag--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (appid, "APPID", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)appid->name)
           : !appid->name)
      pass ();
    else
      fail ("APPID.name [TV] '%s' <> '%s'", name, appid->name);
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value (appid, "APPID", "null_handle", &null_handle, NULL)
        && !memcmp (&null_handle, &appid->null_handle, sizeof (appid->null_handle)))
        pass ();
    else
        fail ("APPID.null_handle [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (appid, "APPID", "parent", &parent, NULL)
        && !memcmp (&parent, &appid->parent, sizeof (appid->parent)))
        pass ();
    else
        fail ("APPID.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value (appid, "APPID", "unknown", &unknown, NULL)
        && unknown == appid->unknown)
      pass ();
    else
      fail ("APPID.unknown [RC] %u != %u", appid->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "unknown", &unknown, 0)
        && unknown == appid->unknown)
      pass ();
    else
      fail ("APPID.unknown [RC] set+1 %u != %u", appid->unknown, unknown);
    appid->unknown--;
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (appid, "APPID", "used", &used, NULL)
        && used == appid->used)
      pass ();
    else
      fail ("APPID.used [RS] %hu != %hu", appid->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "used", &used, 0)
        && used == appid->used)
      pass ();
    else
      fail ("APPID.used [RS] set+1 %hu != %hu", appid->used, used);
    appid->used--;
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (appid, "APPID", "xrefdep", &xrefdep, NULL)
        && xrefdep == appid->xrefdep)
      pass ();
    else
      fail ("APPID.xrefdep [B] " FORMAT_B " != " FORMAT_B "", appid->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "xrefdep", &xrefdep, 0)
        && xrefdep == appid->xrefdep)
      pass ();
    else
      fail ("APPID.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", appid->xrefdep, xrefdep);
    appid->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (appid, "APPID", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == appid->xrefindex_plus1)
      pass ();
    else
      fail ("APPID.xrefindex_plus1 [BS] %hu != %hu", appid->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == appid->xrefindex_plus1)
      pass ();
    else
      fail ("APPID.xrefindex_plus1 [BS] set+1 %hu != %hu", appid->xrefindex_plus1, xrefindex_plus1);
    appid->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (appid, "APPID", "xrefref", &xrefref, NULL)
        && xrefref == appid->xrefref)
      pass ();
    else
      fail ("APPID.xrefref [B] " FORMAT_B " != " FORMAT_B "", appid->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "xrefref", &xrefref, 0)
        && xrefref == appid->xrefref)
      pass ();
    else
      fail ("APPID.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", appid->xrefref, xrefref);
    appid->xrefref--;
  }
  if (failed && (is_class_unstable ("APPID") || is_class_debugging ("APPID")))
    {
      ok ("%s failed %d tests (TODO unstable)", "APPID", failed);
      failed = 0;
    }
  return failed;
}
static int test_APPID_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_APPID_CONTROL *restrict appid_control = obj->tio.object->tio.APPID_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "entries", &entries, NULL)
        && entries == appid_control->entries)
      pass ();
    else
      fail ("APPID_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == appid_control->num_entries)
      pass ();
    else
      fail ("APPID_CONTROL.num_entries [BS] %hu != %hu", appid_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (appid_control, "APPID_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == appid_control->num_entries)
      pass ();
    else
      fail ("APPID_CONTROL.num_entries [BS] set+1 %hu != %hu", appid_control->num_entries, num_entries);
    appid_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "objid", &objid, NULL)
        && objid == appid_control->objid)
      pass ();
    else
      fail ("APPID_CONTROL.objid [BL] %u != %u", appid_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (appid_control, "APPID_CONTROL", "objid", &objid, 0)
        && objid == appid_control->objid)
      pass ();
    else
      fail ("APPID_CONTROL.objid [BL] set+1 %u != %u", appid_control->objid, objid);
    appid_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &appid_control->parent, sizeof (appid_control->parent)))
        pass ();
    else
        fail ("APPID_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("APPID_CONTROL") || is_class_debugging ("APPID_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "APPID_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOC2DCONSTRAINTGROUP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOC2DCONSTRAINTGROUP *restrict assoc2dconstraintgroup = obj->tio.object->tio.ASSOC2DCONSTRAINTGROUP;
  failed = 0;
  {
    BITCODE_B b1;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1, NULL)
        && b1 == assoc2dconstraintgroup->b1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1);
    b1++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1, 0)
        && b1 == assoc2dconstraintgroup->b1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1);
    assoc2dconstraintgroup->b1--;
  }
  {
    BITCODE_3BD c1;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c1", &c1, NULL)
        && !memcmp (&c1, &assoc2dconstraintgroup->c1, sizeof (assoc2dconstraintgroup->c1)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.c1 [3BD]");
  }
  {
    BITCODE_3BD c2;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c2", &c2, NULL)
        && !memcmp (&c2, &assoc2dconstraintgroup->c2, sizeof (assoc2dconstraintgroup->c2)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.c2 [3BD]");
  }
  {
    BITCODE_3BD c3;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c3", &c3, NULL)
        && !memcmp (&c3, &assoc2dconstraintgroup->c3, sizeof (assoc2dconstraintgroup->c3)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.c3 [3BD]");
  }
  {
    BITCODE_BL cl1;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl1", &cl1, NULL)
        && cl1 == assoc2dconstraintgroup->cl1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cl1 [BL] %u != %u", assoc2dconstraintgroup->cl1, cl1);
    cl1++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl1", &cl1, 0)
        && cl1 == assoc2dconstraintgroup->cl1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cl1 [BL] set+1 %u != %u", assoc2dconstraintgroup->cl1, cl1);
    assoc2dconstraintgroup->cl1--;
  }
  {
    BITCODE_BL cl2;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl2", &cl2, NULL)
        && cl2 == assoc2dconstraintgroup->cl2)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cl2 [BL] %u != %u", assoc2dconstraintgroup->cl2, cl2);
    cl2++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl2", &cl2, 0)
        && cl2 == assoc2dconstraintgroup->cl2)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cl2 [BL] set+1 %u != %u", assoc2dconstraintgroup->cl2, cl2);
    assoc2dconstraintgroup->cl2--;
  }
  {
    BITCODE_BL cl3;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl3", &cl3, NULL)
        && cl3 == assoc2dconstraintgroup->cl3)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cl3 [BL] %u != %u", assoc2dconstraintgroup->cl3, cl3);
    cl3++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl3", &cl3, 0)
        && cl3 == assoc2dconstraintgroup->cl3)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cl3 [BL] set+1 %u != %u", assoc2dconstraintgroup->cl3, cl3);
    assoc2dconstraintgroup->cl3--;
  }
  {
    BITCODE_BL cl4;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl4", &cl4, NULL)
        && cl4 == assoc2dconstraintgroup->cl4)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cl4 [BL] %u != %u", assoc2dconstraintgroup->cl4, cl4);
    cl4++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl4", &cl4, 0)
        && cl4 == assoc2dconstraintgroup->cl4)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cl4 [BL] set+1 %u != %u", assoc2dconstraintgroup->cl4, cl4);
    assoc2dconstraintgroup->cl4--;
  }
  {
    BITCODE_BL constraint_status;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "constraint_status", &constraint_status, NULL)
        && constraint_status == assoc2dconstraintgroup->constraint_status)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.constraint_status [BL] %u != %u", assoc2dconstraintgroup->constraint_status, constraint_status);
    constraint_status++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "constraint_status", &constraint_status, 0)
        && constraint_status == assoc2dconstraintgroup->constraint_status)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.constraint_status [BL] set+1 %u != %u", assoc2dconstraintgroup->constraint_status, constraint_status);
    assoc2dconstraintgroup->constraint_status--;
  }
  {
    BITCODE_RC cs1;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cs1", &cs1, NULL)
        && cs1 == assoc2dconstraintgroup->cs1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cs1 [RC] %u != %u", assoc2dconstraintgroup->cs1, cs1);
    cs1++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cs1", &cs1, 0)
        && cs1 == assoc2dconstraintgroup->cs1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.cs1 [RC] set+1 %u != %u", assoc2dconstraintgroup->cs1, cs1);
    assoc2dconstraintgroup->cs1--;
  }
  {
    BITCODE_BL dof;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "dof", &dof, NULL)
        && dof == assoc2dconstraintgroup->dof)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.dof [BL] %u != %u", assoc2dconstraintgroup->dof, dof);
    dof++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "dof", &dof, 0)
        && dof == assoc2dconstraintgroup->dof)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.dof [BL] set+1 %u != %u", assoc2dconstraintgroup->dof, dof);
    assoc2dconstraintgroup->dof--;
  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status, NULL)
        && geometry_status == assoc2dconstraintgroup->geometry_status)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status);
    geometry_status++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status, 0)
        && geometry_status == assoc2dconstraintgroup->geometry_status)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] set+1 %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status);
    assoc2dconstraintgroup->geometry_status--;
  }
  {
    BITCODE_B is_body_a_proxy;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "is_body_a_proxy", &is_body_a_proxy, NULL)
        && is_body_a_proxy == assoc2dconstraintgroup->is_body_a_proxy)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.is_body_a_proxy [B] " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->is_body_a_proxy, is_body_a_proxy);
    is_body_a_proxy++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "is_body_a_proxy", &is_body_a_proxy, 0)
        && is_body_a_proxy == assoc2dconstraintgroup->is_body_a_proxy)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.is_body_a_proxy [B] set+1 " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->is_body_a_proxy, is_body_a_proxy);
    assoc2dconstraintgroup->is_body_a_proxy--;
  }
  {
    BITCODE_BL l5;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l5", &l5, NULL)
        && l5 == assoc2dconstraintgroup->l5)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.l5 [BL] %u != %u", assoc2dconstraintgroup->l5, l5);
    l5++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l5", &l5, 0)
        && l5 == assoc2dconstraintgroup->l5)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.l5 [BL] set+1 %u != %u", assoc2dconstraintgroup->l5, l5);
    assoc2dconstraintgroup->l5--;
  }
  {
    BITCODE_BL l6;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l6", &l6, NULL)
        && l6 == assoc2dconstraintgroup->l6)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.l6 [BL] %u != %u", assoc2dconstraintgroup->l6, l6);
    l6++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l6", &l6, 0)
        && l6 == assoc2dconstraintgroup->l6)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.l6 [BL] set+1 %u != %u", assoc2dconstraintgroup->l6, l6);
    assoc2dconstraintgroup->l6--;
  }
  {
    BITCODE_BL l7;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l7", &l7, NULL)
        && l7 == assoc2dconstraintgroup->l7)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.l7 [BL] %u != %u", assoc2dconstraintgroup->l7, l7);
    l7++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l7", &l7, 0)
        && l7 == assoc2dconstraintgroup->l7)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.l7 [BL] set+1 %u != %u", assoc2dconstraintgroup->l7, l7);
    assoc2dconstraintgroup->l7--;
  }
  {
    BITCODE_BL l8;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l8", &l8, NULL)
        && l8 == assoc2dconstraintgroup->l8)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.l8 [BL] %u != %u", assoc2dconstraintgroup->l8, l8);
    l8++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l8", &l8, 0)
        && l8 == assoc2dconstraintgroup->l8)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.l8 [BL] set+1 %u != %u", assoc2dconstraintgroup->l8, l8);
    assoc2dconstraintgroup->l8--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "parent", &parent, NULL)
        && !memcmp (&parent, &assoc2dconstraintgroup->parent, sizeof (assoc2dconstraintgroup->parent)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "readdep", &readdep, NULL)
        && !memcmp (&readdep, &assoc2dconstraintgroup->readdep, sizeof (assoc2dconstraintgroup->readdep)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.readdep [H]");
  }
  {
    BITCODE_BL solution_status;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "solution_status", &solution_status, NULL)
        && solution_status == assoc2dconstraintgroup->solution_status)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.solution_status [BL] %u != %u", assoc2dconstraintgroup->solution_status, solution_status);
    solution_status++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "solution_status", &solution_status, 0)
        && solution_status == assoc2dconstraintgroup->solution_status)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.solution_status [BL] set+1 %u != %u", assoc2dconstraintgroup->solution_status, solution_status);
    assoc2dconstraintgroup->solution_status--;
  }
  {
    BITCODE_BD w1;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w1", &w1, NULL)
        && w1 == assoc2dconstraintgroup->w1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.w1 [BD] %g != %g", assoc2dconstraintgroup->w1, w1);
    w1++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w1", &w1, 0)
        && w1 == assoc2dconstraintgroup->w1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.w1 [BD] set+1 %g != %g", assoc2dconstraintgroup->w1, w1);
    assoc2dconstraintgroup->w1--;
  }
  {
    BITCODE_BD w2;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w2", &w2, NULL)
        && w2 == assoc2dconstraintgroup->w2)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.w2 [BD] %g != %g", assoc2dconstraintgroup->w2, w2);
    w2++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w2", &w2, 0)
        && w2 == assoc2dconstraintgroup->w2)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.w2 [BD] set+1 %g != %g", assoc2dconstraintgroup->w2, w2);
    assoc2dconstraintgroup->w2--;
  }
  {
    BITCODE_BD w3;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w3", &w3, NULL)
        && w3 == assoc2dconstraintgroup->w3)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.w3 [BD] %g != %g", assoc2dconstraintgroup->w3, w3);
    w3++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w3", &w3, 0)
        && w3 == assoc2dconstraintgroup->w3)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.w3 [BD] set+1 %g != %g", assoc2dconstraintgroup->w3, w3);
    assoc2dconstraintgroup->w3--;
  }
  {
    BITCODE_3BD workplane[3];
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "workplane[3]", &workplane, NULL)
        && !memcmp (&workplane, &assoc2dconstraintgroup->workplane, sizeof (assoc2dconstraintgroup->workplane)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.workplane[3] [3BD]");
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "writedep", &writedep, NULL)
        && !memcmp (&writedep, &assoc2dconstraintgroup->writedep, sizeof (assoc2dconstraintgroup->writedep)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.writedep [H]");
  }
  if (failed && (is_class_unstable ("ASSOC2DCONSTRAINTGROUP") || is_class_debugging ("ASSOC2DCONSTRAINTGROUP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOC2DCONSTRAINTGROUP", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCACTION *restrict assocaction = obj->tio.object->tio.ASSOCACTION;
  failed = 0;
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assocaction->actionbody, sizeof (assocaction->actionbody)))
        pass ();
    else
        fail ("ASSOCACTION.actionbody [H]");
  }
  {
    Dwg_ACTIONBODY body;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "body", &body, NULL)
        && !memcmp (&body, &assocaction->body, sizeof (assocaction->body)))
        pass ();
    else
        fail ("ASSOCACTION.body [Dwg_ACTIONBODY]");
  }
  {
    BITCODE_H callback;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "callback", &callback, NULL)
        && !memcmp (&callback, &assocaction->callback, sizeof (assocaction->callback)))
        pass ();
    else
        fail ("ASSOCACTION.callback [H]");
  }
  {
    BITCODE_BL constraint_status;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "constraint_status", &constraint_status, NULL)
        && constraint_status == assocaction->constraint_status)
      pass ();
    else
      fail ("ASSOCACTION.constraint_status [BL] %u != %u", assocaction->constraint_status, constraint_status);
    constraint_status++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "constraint_status", &constraint_status, 0)
        && constraint_status == assocaction->constraint_status)
      pass ();
    else
      fail ("ASSOCACTION.constraint_status [BL] set+1 %u != %u", assocaction->constraint_status, constraint_status);
    assocaction->constraint_status--;
  }
  {
    BITCODE_BL dof;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "dof", &dof, NULL)
        && dof == assocaction->dof)
      pass ();
    else
      fail ("ASSOCACTION.dof [BL] %u != %u", assocaction->dof, dof);
    dof++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "dof", &dof, 0)
        && dof == assocaction->dof)
      pass ();
    else
      fail ("ASSOCACTION.dof [BL] set+1 %u != %u", assocaction->dof, dof);
    assocaction->dof--;
  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "geometry_status", &geometry_status, NULL)
        && geometry_status == assocaction->geometry_status)
      pass ();
    else
      fail ("ASSOCACTION.geometry_status [BL] %u != %u", assocaction->geometry_status, geometry_status);
    geometry_status++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "geometry_status", &geometry_status, 0)
        && geometry_status == assocaction->geometry_status)
      pass ();
    else
      fail ("ASSOCACTION.geometry_status [BL] set+1 %u != %u", assocaction->geometry_status, geometry_status);
    assocaction->geometry_status--;
  }
  {
    BITCODE_B is_body_a_proxy;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "is_body_a_proxy", &is_body_a_proxy, NULL)
        && is_body_a_proxy == assocaction->is_body_a_proxy)
      pass ();
    else
      fail ("ASSOCACTION.is_body_a_proxy [B] " FORMAT_B " != " FORMAT_B "", assocaction->is_body_a_proxy, is_body_a_proxy);
    is_body_a_proxy++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "is_body_a_proxy", &is_body_a_proxy, 0)
        && is_body_a_proxy == assocaction->is_body_a_proxy)
      pass ();
    else
      fail ("ASSOCACTION.is_body_a_proxy [B] set+1 " FORMAT_B " != " FORMAT_B "", assocaction->is_body_a_proxy, is_body_a_proxy);
    assocaction->is_body_a_proxy--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "num_deps", &num_deps, NULL)
        && num_deps == assocaction->num_deps)
      pass ();
    else
      fail ("ASSOCACTION.num_deps [BL] %u != %u", assocaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "num_deps", &num_deps, 0)
        && num_deps == assocaction->num_deps)
      pass ();
    else
      fail ("ASSOCACTION.num_deps [BL] set+1 %u != %u", assocaction->num_deps, num_deps);
    assocaction->num_deps--;
  }
  {
    BITCODE_H owningnetwork;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "owningnetwork", &owningnetwork, NULL)
        && !memcmp (&owningnetwork, &assocaction->owningnetwork, sizeof (assocaction->owningnetwork)))
        pass ();
    else
        fail ("ASSOCACTION.owningnetwork [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &assocaction->parent, sizeof (assocaction->parent)))
        pass ();
    else
        fail ("ASSOCACTION.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "readdep", &readdep, NULL)
        && !memcmp (&readdep, &assocaction->readdep, sizeof (assocaction->readdep)))
        pass ();
    else
        fail ("ASSOCACTION.readdep [H]");
  }
  {
    BITCODE_BL solution_status;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "solution_status", &solution_status, NULL)
        && solution_status == assocaction->solution_status)
      pass ();
    else
      fail ("ASSOCACTION.solution_status [BL] %u != %u", assocaction->solution_status, solution_status);
    solution_status++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "solution_status", &solution_status, 0)
        && solution_status == assocaction->solution_status)
      pass ();
    else
      fail ("ASSOCACTION.solution_status [BL] set+1 %u != %u", assocaction->solution_status, solution_status);
    assocaction->solution_status--;
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "status", &status, NULL)
        && status == assocaction->status)
      pass ();
    else
      fail ("ASSOCACTION.status [BL] %u != %u", assocaction->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "status", &status, 0)
        && status == assocaction->status)
      pass ();
    else
      fail ("ASSOCACTION.status [BL] set+1 %u != %u", assocaction->status, status);
    assocaction->status--;
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "writedep", &writedep, NULL)
        && !memcmp (&writedep, &assocaction->writedep, sizeof (assocaction->writedep)))
        pass ();
    else
        fail ("ASSOCACTION.writedep [H]");
  }
  if (failed && (is_class_unstable ("ASSOCACTION") || is_class_debugging ("ASSOCACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCALIGNEDDIMACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCALIGNEDDIMACTIONBODY *restrict assocaligneddimactionbody = obj->tio.object->tio.ASSOCALIGNEDDIMACTIONBODY;
  failed = 0;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aab_status", &aab_status, NULL)
        && aab_status == assocaligneddimactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.aab_status [BL] %u != %u", assocaligneddimactionbody->aab_status, aab_status);
    aab_status++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aab_status", &aab_status, 0)
        && aab_status == assocaligneddimactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.aab_status [BL] set+1 %u != %u", assocaligneddimactionbody->aab_status, aab_status);
    assocaligneddimactionbody->aab_status--;
  }
  {
    BITCODE_H d_node;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "d_node", &d_node, NULL)
        && !memcmp (&d_node, &assocaligneddimactionbody->d_node, sizeof (assocaligneddimactionbody->d_node)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.d_node [H]");
  }
  {
    BITCODE_BL dcm_status;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "dcm_status", &dcm_status, NULL)
        && dcm_status == assocaligneddimactionbody->dcm_status)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.dcm_status [BL] %u != %u", assocaligneddimactionbody->dcm_status, dcm_status);
    dcm_status++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "dcm_status", &dcm_status, 0)
        && dcm_status == assocaligneddimactionbody->dcm_status)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.dcm_status [BL] set+1 %u != %u", assocaligneddimactionbody->dcm_status, dcm_status);
    assocaligneddimactionbody->dcm_status--;
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l2", &pab_l2, NULL)
        && pab_l2 == assocaligneddimactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l2 [BL] %u != %u", assocaligneddimactionbody->pab_l2, pab_l2);
    pab_l2++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l2", &pab_l2, 0)
        && pab_l2 == assocaligneddimactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l2 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l2, pab_l2);
    assocaligneddimactionbody->pab_l2--;
  }
  {
    BITCODE_BL pab_l3;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l3", &pab_l3, NULL)
        && pab_l3 == assocaligneddimactionbody->pab_l3)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l3 [BL] %u != %u", assocaligneddimactionbody->pab_l3, pab_l3);
    pab_l3++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l3", &pab_l3, 0)
        && pab_l3 == assocaligneddimactionbody->pab_l3)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l3 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l3, pab_l3);
    assocaligneddimactionbody->pab_l3--;
  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l4", &pab_l4, NULL)
        && pab_l4 == assocaligneddimactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l4 [BL] %u != %u", assocaligneddimactionbody->pab_l4, pab_l4);
    pab_l4++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l4", &pab_l4, 0)
        && pab_l4 == assocaligneddimactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l4 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l4, pab_l4);
    assocaligneddimactionbody->pab_l4--;
  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l5", &pab_l5, NULL)
        && pab_l5 == assocaligneddimactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l5 [BL] %u != %u", assocaligneddimactionbody->pab_l5, pab_l5);
    pab_l5++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l5", &pab_l5, 0)
        && pab_l5 == assocaligneddimactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l5 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l5, pab_l5);
    assocaligneddimactionbody->pab_l5--;
  }
  {
    BITCODE_BL pab_l6;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l6", &pab_l6, NULL)
        && pab_l6 == assocaligneddimactionbody->pab_l6)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l6 [BL] %u != %u", assocaligneddimactionbody->pab_l6, pab_l6);
    pab_l6++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l6", &pab_l6, 0)
        && pab_l6 == assocaligneddimactionbody->pab_l6)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l6 [BL] set+1 %u != %u", assocaligneddimactionbody->pab_l6, pab_l6);
    assocaligneddimactionbody->pab_l6--;
  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_status", &pab_status, NULL)
        && pab_status == assocaligneddimactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_status [BL] %u != %u", assocaligneddimactionbody->pab_status, pab_status);
    pab_status++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_status", &pab_status, 0)
        && pab_status == assocaligneddimactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.pab_status [BL] set+1 %u != %u", assocaligneddimactionbody->pab_status, pab_status);
    assocaligneddimactionbody->pab_status--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocaligneddimactionbody->parent, sizeof (assocaligneddimactionbody->parent)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H r_node;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "r_node", &r_node, NULL)
        && !memcmp (&r_node, &assocaligneddimactionbody->r_node, sizeof (assocaligneddimactionbody->r_node)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.r_node [H]");
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "readdep", &readdep, NULL)
        && !memcmp (&readdep, &assocaligneddimactionbody->readdep, sizeof (assocaligneddimactionbody->readdep)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.readdep [H]");
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "writedep", &writedep, NULL)
        && !memcmp (&writedep, &assocaligneddimactionbody->writedep, sizeof (assocaligneddimactionbody->writedep)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.writedep [H]");
  }
  if (failed && (is_class_unstable ("ASSOCALIGNEDDIMACTIONBODY") || is_class_debugging ("ASSOCALIGNEDDIMACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCALIGNEDDIMACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCDEPENDENCY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCDEPENDENCY *restrict assocdependency = obj->tio.object->tio.ASSOCDEPENDENCY;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "class_version", &class_version, NULL)
        && class_version == assocdependency->class_version)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.class_version [BL] %u != %u", assocdependency->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "class_version", &class_version, 0)
        && class_version == assocdependency->class_version)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.class_version [BL] set+1 %u != %u", assocdependency->class_version, class_version);
    assocdependency->class_version--;
  }
  {
    BITCODE_BL depbodyid;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "depbodyid", &depbodyid, NULL)
        && depbodyid == assocdependency->depbodyid)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.depbodyid [BL] %u != %u", assocdependency->depbodyid, depbodyid);
    depbodyid++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "depbodyid", &depbodyid, 0)
        && depbodyid == assocdependency->depbodyid)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.depbodyid [BL] set+1 %u != %u", assocdependency->depbodyid, depbodyid);
    assocdependency->depbodyid--;
  }
  {
    BITCODE_B isobjectstate_dep;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "isobjectstate_dep", &isobjectstate_dep, NULL)
        && isobjectstate_dep == assocdependency->isobjectstate_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.isobjectstate_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->isobjectstate_dep, isobjectstate_dep);
    isobjectstate_dep++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "isobjectstate_dep", &isobjectstate_dep, 0)
        && isobjectstate_dep == assocdependency->isobjectstate_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.isobjectstate_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->isobjectstate_dep, isobjectstate_dep);
    assocdependency->isobjectstate_dep--;
  }
  {
    BITCODE_B isread_dep;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "isread_dep", &isread_dep, NULL)
        && isread_dep == assocdependency->isread_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.isread_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->isread_dep, isread_dep);
    isread_dep++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "isread_dep", &isread_dep, 0)
        && isread_dep == assocdependency->isread_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.isread_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->isread_dep, isread_dep);
    assocdependency->isread_dep--;
  }
  {
    BITCODE_B iswrite_dep;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "iswrite_dep", &iswrite_dep, NULL)
        && iswrite_dep == assocdependency->iswrite_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.iswrite_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->iswrite_dep, iswrite_dep);
    iswrite_dep++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "iswrite_dep", &iswrite_dep, 0)
        && iswrite_dep == assocdependency->iswrite_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.iswrite_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->iswrite_dep, iswrite_dep);
    assocdependency->iswrite_dep--;
  }
  {
    BITCODE_H node;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "node", &node, NULL)
        && !memcmp (&node, &assocdependency->node, sizeof (assocdependency->node)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.node [H]");
  }
  {
    BITCODE_BL order;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "order", &order, NULL)
        && order == assocdependency->order)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.order [BL] %u != %u", assocdependency->order, order);
    order++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "order", &order, 0)
        && order == assocdependency->order)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.order [BL] set+1 %u != %u", assocdependency->order, order);
    assocdependency->order--;
  }
  {
    BITCODE_H owner;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "owner", &owner, NULL)
        && !memcmp (&owner, &assocdependency->owner, sizeof (assocdependency->owner)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.owner [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocdependency->parent, sizeof (assocdependency->parent)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "readdep", &readdep, NULL)
        && !memcmp (&readdep, &assocdependency->readdep, sizeof (assocdependency->readdep)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.readdep [H]");
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "status", &status, NULL)
        && status == assocdependency->status)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.status [BL] %u != %u", assocdependency->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "status", &status, 0)
        && status == assocdependency->status)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.status [BL] set+1 %u != %u", assocdependency->status, status);
    assocdependency->status--;
  }
  {
    BITCODE_B unknown_b4;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "unknown_b4", &unknown_b4, NULL)
        && unknown_b4 == assocdependency->unknown_b4)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.unknown_b4 [B] " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b4, unknown_b4);
    unknown_b4++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "unknown_b4", &unknown_b4, 0)
        && unknown_b4 == assocdependency->unknown_b4)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.unknown_b4 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b4, unknown_b4);
    assocdependency->unknown_b4--;
  }
  {
    BITCODE_B unknown_b5;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "unknown_b5", &unknown_b5, NULL)
        && unknown_b5 == assocdependency->unknown_b5)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.unknown_b5 [B] " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b5, unknown_b5);
    unknown_b5++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "unknown_b5", &unknown_b5, 0)
        && unknown_b5 == assocdependency->unknown_b5)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.unknown_b5 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b5, unknown_b5);
    assocdependency->unknown_b5--;
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "writedep", &writedep, NULL)
        && !memcmp (&writedep, &assocdependency->writedep, sizeof (assocdependency->writedep)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.writedep [H]");
  }
  if (failed && (is_class_unstable ("ASSOCDEPENDENCY") || is_class_debugging ("ASSOCDEPENDENCY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCDEPENDENCY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCEXTRUDEDSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCEXTRUDEDSURFACEACTIONBODY *restrict assocextrudedsurfaceactionbody = obj->tio.object->tio.ASSOCEXTRUDEDSURFACEACTIONBODY;
  failed = 0;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "aab_status", &aab_status, NULL)
        && aab_status == assocextrudedsurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.aab_status [BL] %u != %u", assocextrudedsurfaceactionbody->aab_status, aab_status);
    aab_status++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "aab_status", &aab_status, 0)
        && aab_status == assocextrudedsurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.aab_status [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->aab_status, aab_status);
    assocextrudedsurfaceactionbody->aab_status--;
  }
  {
    BITCODE_TV* descriptions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "num_descriptions", &count, NULL)
        && dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "descriptions", &descriptions, NULL)
        && descriptions == assocextrudedsurfaceactionbody->descriptions)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.descriptions [TV*] * %u num_descriptions", count);
  }
  {
    BITCODE_BL esab_status;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "esab_status", &esab_status, NULL)
        && esab_status == assocextrudedsurfaceactionbody->esab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.esab_status [BL] %u != %u", assocextrudedsurfaceactionbody->esab_status, esab_status);
    esab_status++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "esab_status", &esab_status, 0)
        && esab_status == assocextrudedsurfaceactionbody->esab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.esab_status [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->esab_status, esab_status);
    assocextrudedsurfaceactionbody->esab_status--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "num_deps", &num_deps, NULL)
        && num_deps == assocextrudedsurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.num_deps [BL] %u != %u", assocextrudedsurfaceactionbody->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "num_deps", &num_deps, 0)
        && num_deps == assocextrudedsurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.num_deps [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->num_deps, num_deps);
    assocextrudedsurfaceactionbody->num_deps--;
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab_l2", &pab_l2, NULL)
        && pab_l2 == assocextrudedsurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab_l2 [BL] %u != %u", assocextrudedsurfaceactionbody->pab_l2, pab_l2);
    pab_l2++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab_l2", &pab_l2, 0)
        && pab_l2 == assocextrudedsurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab_l2 [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->pab_l2, pab_l2);
    assocextrudedsurfaceactionbody->pab_l2--;
  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab_l4", &pab_l4, NULL)
        && pab_l4 == assocextrudedsurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab_l4 [BL] %u != %u", assocextrudedsurfaceactionbody->pab_l4, pab_l4);
    pab_l4++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab_l4", &pab_l4, 0)
        && pab_l4 == assocextrudedsurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab_l4 [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->pab_l4, pab_l4);
    assocextrudedsurfaceactionbody->pab_l4--;
  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab_l5", &pab_l5, NULL)
        && pab_l5 == assocextrudedsurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab_l5 [BL] %u != %u", assocextrudedsurfaceactionbody->pab_l5, pab_l5);
    pab_l5++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab_l5", &pab_l5, 0)
        && pab_l5 == assocextrudedsurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab_l5 [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->pab_l5, pab_l5);
    assocextrudedsurfaceactionbody->pab_l5--;
  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab_status", &pab_status, NULL)
        && pab_status == assocextrudedsurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab_status [BL] %u != %u", assocextrudedsurfaceactionbody->pab_status, pab_status);
    pab_status++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab_status", &pab_status, 0)
        && pab_status == assocextrudedsurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab_status [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->pab_status, pab_status);
    assocextrudedsurfaceactionbody->pab_status--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocextrudedsurfaceactionbody->parent, sizeof (assocextrudedsurfaceactionbody->parent)))
        pass ();
    else
        fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocextrudedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocextrudedsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocextrudedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->pbsab_status, pbsab_status);
    assocextrudedsurfaceactionbody->pbsab_status--;
  }
  {
    BITCODE_H* readdeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "readdeps", &readdeps, NULL)
        && readdeps == assocextrudedsurfaceactionbody->readdeps)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.readdeps [H*] * %u num_deps", count);
  }
  {
    BITCODE_B sab_b1;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_b1", &sab_b1, NULL)
        && sab_b1 == assocextrudedsurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_b1 [B] " FORMAT_B " != " FORMAT_B "", assocextrudedsurfaceactionbody->sab_b1, sab_b1);
    sab_b1++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_b1", &sab_b1, 0)
        && sab_b1 == assocextrudedsurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocextrudedsurfaceactionbody->sab_b1, sab_b1);
    assocextrudedsurfaceactionbody->sab_b1--;
  }
  {
    BITCODE_B sab_b2;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_b2", &sab_b2, NULL)
        && sab_b2 == assocextrudedsurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_b2 [B] " FORMAT_B " != " FORMAT_B "", assocextrudedsurfaceactionbody->sab_b2, sab_b2);
    sab_b2++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_b2", &sab_b2, 0)
        && sab_b2 == assocextrudedsurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocextrudedsurfaceactionbody->sab_b2, sab_b2);
    assocextrudedsurfaceactionbody->sab_b2--;
  }
  {
    BITCODE_BL sab_l2;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_l2", &sab_l2, NULL)
        && sab_l2 == assocextrudedsurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_l2 [BL] %u != %u", assocextrudedsurfaceactionbody->sab_l2, sab_l2);
    sab_l2++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_l2", &sab_l2, 0)
        && sab_l2 == assocextrudedsurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_l2 [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->sab_l2, sab_l2);
    assocextrudedsurfaceactionbody->sab_l2--;
  }
  {
    BITCODE_BS sab_s1;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_s1", &sab_s1, NULL)
        && sab_s1 == assocextrudedsurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_s1 [BS] %hu != %hu", assocextrudedsurfaceactionbody->sab_s1, sab_s1);
    sab_s1++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_s1", &sab_s1, 0)
        && sab_s1 == assocextrudedsurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_s1 [BS] set+1 %hu != %hu", assocextrudedsurfaceactionbody->sab_s1, sab_s1);
    assocextrudedsurfaceactionbody->sab_s1--;
  }
  {
    BITCODE_BL sab_status;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_status", &sab_status, NULL)
        && sab_status == assocextrudedsurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_status [BL] %u != %u", assocextrudedsurfaceactionbody->sab_status, sab_status);
    sab_status++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab_status", &sab_status, 0)
        && sab_status == assocextrudedsurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab_status [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->sab_status, sab_status);
    assocextrudedsurfaceactionbody->sab_status--;
  }
  {
    BITCODE_H* writedeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "writedeps", &writedeps, NULL)
        && writedeps == assocextrudedsurfaceactionbody->writedeps)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.writedeps [H*] * %u num_deps", count);
  }
  if (failed && (is_class_unstable ("ASSOCEXTRUDEDSURFACEACTIONBODY") || is_class_debugging ("ASSOCEXTRUDEDSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCEXTRUDEDSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCLOFTEDSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCLOFTEDSURFACEACTIONBODY *restrict assocloftedsurfaceactionbody = obj->tio.object->tio.ASSOCLOFTEDSURFACEACTIONBODY;
  failed = 0;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "aab_status", &aab_status, NULL)
        && aab_status == assocloftedsurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.aab_status [BL] %u != %u", assocloftedsurfaceactionbody->aab_status, aab_status);
    aab_status++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "aab_status", &aab_status, 0)
        && aab_status == assocloftedsurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.aab_status [BL] set+1 %u != %u", assocloftedsurfaceactionbody->aab_status, aab_status);
    assocloftedsurfaceactionbody->aab_status--;
  }
  {
    BITCODE_TV* descriptions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "num_descriptions", &count, NULL)
        && dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "descriptions", &descriptions, NULL)
        && descriptions == assocloftedsurfaceactionbody->descriptions)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.descriptions [TV*] * %u num_descriptions", count);
  }
  {
    BITCODE_BL lsab_status;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "lsab_status", &lsab_status, NULL)
        && lsab_status == assocloftedsurfaceactionbody->lsab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.lsab_status [BL] %u != %u", assocloftedsurfaceactionbody->lsab_status, lsab_status);
    lsab_status++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "lsab_status", &lsab_status, 0)
        && lsab_status == assocloftedsurfaceactionbody->lsab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.lsab_status [BL] set+1 %u != %u", assocloftedsurfaceactionbody->lsab_status, lsab_status);
    assocloftedsurfaceactionbody->lsab_status--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "num_deps", &num_deps, NULL)
        && num_deps == assocloftedsurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.num_deps [BL] %u != %u", assocloftedsurfaceactionbody->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "num_deps", &num_deps, 0)
        && num_deps == assocloftedsurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.num_deps [BL] set+1 %u != %u", assocloftedsurfaceactionbody->num_deps, num_deps);
    assocloftedsurfaceactionbody->num_deps--;
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab_l2", &pab_l2, NULL)
        && pab_l2 == assocloftedsurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab_l2 [BL] %u != %u", assocloftedsurfaceactionbody->pab_l2, pab_l2);
    pab_l2++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab_l2", &pab_l2, 0)
        && pab_l2 == assocloftedsurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab_l2 [BL] set+1 %u != %u", assocloftedsurfaceactionbody->pab_l2, pab_l2);
    assocloftedsurfaceactionbody->pab_l2--;
  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab_l4", &pab_l4, NULL)
        && pab_l4 == assocloftedsurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab_l4 [BL] %u != %u", assocloftedsurfaceactionbody->pab_l4, pab_l4);
    pab_l4++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab_l4", &pab_l4, 0)
        && pab_l4 == assocloftedsurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab_l4 [BL] set+1 %u != %u", assocloftedsurfaceactionbody->pab_l4, pab_l4);
    assocloftedsurfaceactionbody->pab_l4--;
  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab_l5", &pab_l5, NULL)
        && pab_l5 == assocloftedsurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab_l5 [BL] %u != %u", assocloftedsurfaceactionbody->pab_l5, pab_l5);
    pab_l5++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab_l5", &pab_l5, 0)
        && pab_l5 == assocloftedsurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab_l5 [BL] set+1 %u != %u", assocloftedsurfaceactionbody->pab_l5, pab_l5);
    assocloftedsurfaceactionbody->pab_l5--;
  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab_status", &pab_status, NULL)
        && pab_status == assocloftedsurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab_status [BL] %u != %u", assocloftedsurfaceactionbody->pab_status, pab_status);
    pab_status++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab_status", &pab_status, 0)
        && pab_status == assocloftedsurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab_status [BL] set+1 %u != %u", assocloftedsurfaceactionbody->pab_status, pab_status);
    assocloftedsurfaceactionbody->pab_status--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocloftedsurfaceactionbody->parent, sizeof (assocloftedsurfaceactionbody->parent)))
        pass ();
    else
        fail ("ASSOCLOFTEDSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocloftedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocloftedsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocloftedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocloftedsurfaceactionbody->pbsab_status, pbsab_status);
    assocloftedsurfaceactionbody->pbsab_status--;
  }
  {
    BITCODE_H* readdeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "readdeps", &readdeps, NULL)
        && readdeps == assocloftedsurfaceactionbody->readdeps)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.readdeps [H*] * %u num_deps", count);
  }
  {
    BITCODE_B sab_b1;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_b1", &sab_b1, NULL)
        && sab_b1 == assocloftedsurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_b1 [B] " FORMAT_B " != " FORMAT_B "", assocloftedsurfaceactionbody->sab_b1, sab_b1);
    sab_b1++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_b1", &sab_b1, 0)
        && sab_b1 == assocloftedsurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocloftedsurfaceactionbody->sab_b1, sab_b1);
    assocloftedsurfaceactionbody->sab_b1--;
  }
  {
    BITCODE_B sab_b2;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_b2", &sab_b2, NULL)
        && sab_b2 == assocloftedsurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_b2 [B] " FORMAT_B " != " FORMAT_B "", assocloftedsurfaceactionbody->sab_b2, sab_b2);
    sab_b2++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_b2", &sab_b2, 0)
        && sab_b2 == assocloftedsurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocloftedsurfaceactionbody->sab_b2, sab_b2);
    assocloftedsurfaceactionbody->sab_b2--;
  }
  {
    BITCODE_BL sab_l2;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_l2", &sab_l2, NULL)
        && sab_l2 == assocloftedsurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_l2 [BL] %u != %u", assocloftedsurfaceactionbody->sab_l2, sab_l2);
    sab_l2++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_l2", &sab_l2, 0)
        && sab_l2 == assocloftedsurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_l2 [BL] set+1 %u != %u", assocloftedsurfaceactionbody->sab_l2, sab_l2);
    assocloftedsurfaceactionbody->sab_l2--;
  }
  {
    BITCODE_BS sab_s1;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_s1", &sab_s1, NULL)
        && sab_s1 == assocloftedsurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_s1 [BS] %hu != %hu", assocloftedsurfaceactionbody->sab_s1, sab_s1);
    sab_s1++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_s1", &sab_s1, 0)
        && sab_s1 == assocloftedsurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_s1 [BS] set+1 %hu != %hu", assocloftedsurfaceactionbody->sab_s1, sab_s1);
    assocloftedsurfaceactionbody->sab_s1--;
  }
  {
    BITCODE_BL sab_status;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_status", &sab_status, NULL)
        && sab_status == assocloftedsurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_status [BL] %u != %u", assocloftedsurfaceactionbody->sab_status, sab_status);
    sab_status++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab_status", &sab_status, 0)
        && sab_status == assocloftedsurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab_status [BL] set+1 %u != %u", assocloftedsurfaceactionbody->sab_status, sab_status);
    assocloftedsurfaceactionbody->sab_status--;
  }
  {
    BITCODE_H* writedeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "writedeps", &writedeps, NULL)
        && writedeps == assocloftedsurfaceactionbody->writedeps)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.writedeps [H*] * %u num_deps", count);
  }
  if (failed && (is_class_unstable ("ASSOCLOFTEDSURFACEACTIONBODY") || is_class_debugging ("ASSOCLOFTEDSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCLOFTEDSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCNETWORK (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCNETWORK *restrict assocnetwork = obj->tio.object->tio.ASSOCNETWORK;
  failed = 0;
  {
    BITCODE_H* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "actions", &actions, NULL)
        && actions == assocnetwork->actions)
      pass ();
    else
      fail ("ASSOCNETWORK.actions [H*] * %u num_actions", count);
  }
  {
    BITCODE_BL constraint_status;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "constraint_status", &constraint_status, NULL)
        && constraint_status == assocnetwork->constraint_status)
      pass ();
    else
      fail ("ASSOCNETWORK.constraint_status [BL] %u != %u", assocnetwork->constraint_status, constraint_status);
    constraint_status++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "constraint_status", &constraint_status, 0)
        && constraint_status == assocnetwork->constraint_status)
      pass ();
    else
      fail ("ASSOCNETWORK.constraint_status [BL] set+1 %u != %u", assocnetwork->constraint_status, constraint_status);
    assocnetwork->constraint_status--;
  }
  {
    BITCODE_BL dof;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "dof", &dof, NULL)
        && dof == assocnetwork->dof)
      pass ();
    else
      fail ("ASSOCNETWORK.dof [BL] %u != %u", assocnetwork->dof, dof);
    dof++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "dof", &dof, 0)
        && dof == assocnetwork->dof)
      pass ();
    else
      fail ("ASSOCNETWORK.dof [BL] set+1 %u != %u", assocnetwork->dof, dof);
    assocnetwork->dof--;
  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "geometry_status", &geometry_status, NULL)
        && geometry_status == assocnetwork->geometry_status)
      pass ();
    else
      fail ("ASSOCNETWORK.geometry_status [BL] %u != %u", assocnetwork->geometry_status, geometry_status);
    geometry_status++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "geometry_status", &geometry_status, 0)
        && geometry_status == assocnetwork->geometry_status)
      pass ();
    else
      fail ("ASSOCNETWORK.geometry_status [BL] set+1 %u != %u", assocnetwork->geometry_status, geometry_status);
    assocnetwork->geometry_status--;
  }
  {
    BITCODE_B is_body_a_proxy;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "is_body_a_proxy", &is_body_a_proxy, NULL)
        && is_body_a_proxy == assocnetwork->is_body_a_proxy)
      pass ();
    else
      fail ("ASSOCNETWORK.is_body_a_proxy [B] " FORMAT_B " != " FORMAT_B "", assocnetwork->is_body_a_proxy, is_body_a_proxy);
    is_body_a_proxy++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "is_body_a_proxy", &is_body_a_proxy, 0)
        && is_body_a_proxy == assocnetwork->is_body_a_proxy)
      pass ();
    else
      fail ("ASSOCNETWORK.is_body_a_proxy [B] set+1 " FORMAT_B " != " FORMAT_B "", assocnetwork->is_body_a_proxy, is_body_a_proxy);
    assocnetwork->is_body_a_proxy--;
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_actions", &num_actions, NULL)
        && num_actions == assocnetwork->num_actions)
      pass ();
    else
      fail ("ASSOCNETWORK.num_actions [BL] %u != %u", assocnetwork->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "num_actions", &num_actions, 0)
        && num_actions == assocnetwork->num_actions)
      pass ();
    else
      fail ("ASSOCNETWORK.num_actions [BL] set+1 %u != %u", assocnetwork->num_actions, num_actions);
    assocnetwork->num_actions--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "parent", &parent, NULL)
        && !memcmp (&parent, &assocnetwork->parent, sizeof (assocnetwork->parent)))
        pass ();
    else
        fail ("ASSOCNETWORK.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "readdep", &readdep, NULL)
        && !memcmp (&readdep, &assocnetwork->readdep, sizeof (assocnetwork->readdep)))
        pass ();
    else
        fail ("ASSOCNETWORK.readdep [H]");
  }
  {
    BITCODE_BL solution_status;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "solution_status", &solution_status, NULL)
        && solution_status == assocnetwork->solution_status)
      pass ();
    else
      fail ("ASSOCNETWORK.solution_status [BL] %u != %u", assocnetwork->solution_status, solution_status);
    solution_status++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "solution_status", &solution_status, 0)
        && solution_status == assocnetwork->solution_status)
      pass ();
    else
      fail ("ASSOCNETWORK.solution_status [BL] set+1 %u != %u", assocnetwork->solution_status, solution_status);
    assocnetwork->solution_status--;
  }
  {
    BITCODE_BL unknown_assoc;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "unknown_assoc", &unknown_assoc, NULL)
        && unknown_assoc == assocnetwork->unknown_assoc)
      pass ();
    else
      fail ("ASSOCNETWORK.unknown_assoc [BL] %u != %u", assocnetwork->unknown_assoc, unknown_assoc);
    unknown_assoc++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "unknown_assoc", &unknown_assoc, 0)
        && unknown_assoc == assocnetwork->unknown_assoc)
      pass ();
    else
      fail ("ASSOCNETWORK.unknown_assoc [BL] set+1 %u != %u", assocnetwork->unknown_assoc, unknown_assoc);
    assocnetwork->unknown_assoc--;
  }
  {
    BITCODE_BL unknown_n1;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "unknown_n1", &unknown_n1, NULL)
        && unknown_n1 == assocnetwork->unknown_n1)
      pass ();
    else
      fail ("ASSOCNETWORK.unknown_n1 [BL] %u != %u", assocnetwork->unknown_n1, unknown_n1);
    unknown_n1++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "unknown_n1", &unknown_n1, 0)
        && unknown_n1 == assocnetwork->unknown_n1)
      pass ();
    else
      fail ("ASSOCNETWORK.unknown_n1 [BL] set+1 %u != %u", assocnetwork->unknown_n1, unknown_n1);
    assocnetwork->unknown_n1--;
  }
  {
    BITCODE_BL unknown_n2;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "unknown_n2", &unknown_n2, NULL)
        && unknown_n2 == assocnetwork->unknown_n2)
      pass ();
    else
      fail ("ASSOCNETWORK.unknown_n2 [BL] %u != %u", assocnetwork->unknown_n2, unknown_n2);
    unknown_n2++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "unknown_n2", &unknown_n2, 0)
        && unknown_n2 == assocnetwork->unknown_n2)
      pass ();
    else
      fail ("ASSOCNETWORK.unknown_n2 [BL] set+1 %u != %u", assocnetwork->unknown_n2, unknown_n2);
    assocnetwork->unknown_n2--;
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "writedep", &writedep, NULL)
        && !memcmp (&writedep, &assocnetwork->writedep, sizeof (assocnetwork->writedep)))
        pass ();
    else
        fail ("ASSOCNETWORK.writedep [H]");
  }
  if (failed && (is_class_unstable ("ASSOCNETWORK") || is_class_debugging ("ASSOCNETWORK")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCNETWORK", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCOSNAPPOINTREFACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM *restrict assocosnappointrefactionparam = obj->tio.object->tio.ASSOCOSNAPPOINTREFACTIONPARAM;
  failed = 0;
  {
    BITCODE_H actionparam;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "actionparam", &actionparam, NULL)
        && !memcmp (&actionparam, &assocosnappointrefactionparam->actionparam, sizeof (assocosnappointrefactionparam->actionparam)))
        pass ();
    else
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.actionparam [H]");
  }
  {
    BITCODE_RS flags;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "flags", &flags, NULL)
        && flags == assocosnappointrefactionparam->flags)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.flags [RS] %hu != %hu", assocosnappointrefactionparam->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "flags", &flags, 0)
        && flags == assocosnappointrefactionparam->flags)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.flags [RS] set+1 %hu != %hu", assocosnappointrefactionparam->flags, flags);
    assocosnappointrefactionparam->flags--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocosnappointrefactionparam->name)
           : !assocosnappointrefactionparam->name)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.name [T] '%s' <> '%s'", name, assocosnappointrefactionparam->name);
  }
  {
    BITCODE_BS num_params;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "num_params", &num_params, NULL)
        && num_params == assocosnappointrefactionparam->num_params)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BS] %hu != %hu", assocosnappointrefactionparam->num_params, num_params);
    num_params++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "num_params", &num_params, 0)
        && num_params == assocosnappointrefactionparam->num_params)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BS] set+1 %hu != %hu", assocosnappointrefactionparam->num_params, num_params);
    assocosnappointrefactionparam->num_params--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocosnappointrefactionparam->parent, sizeof (assocosnappointrefactionparam->parent)))
        pass ();
    else
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS status;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "status", &status, NULL)
        && status == assocosnappointrefactionparam->status)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] %hu != %hu", assocosnappointrefactionparam->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "status", &status, 0)
        && status == assocosnappointrefactionparam->status)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] set+1 %hu != %hu", assocosnappointrefactionparam->status, status);
    assocosnappointrefactionparam->status--;
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown", &unknown, NULL)
        && unknown == assocosnappointrefactionparam->unknown)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown [RC] %u != %u", assocosnappointrefactionparam->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown", &unknown, 0)
        && unknown == assocosnappointrefactionparam->unknown)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown [RC] set+1 %u != %u", assocosnappointrefactionparam->unknown, unknown);
    assocosnappointrefactionparam->unknown--;
  }
  {
    BITCODE_B unknown1;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown1", &unknown1, NULL)
        && unknown1 == assocosnappointrefactionparam->unknown1)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown1 [B] " FORMAT_B " != " FORMAT_B "", assocosnappointrefactionparam->unknown1, unknown1);
    unknown1++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown1", &unknown1, 0)
        && unknown1 == assocosnappointrefactionparam->unknown1)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocosnappointrefactionparam->unknown1, unknown1);
    assocosnappointrefactionparam->unknown1--;
  }
  {
    BITCODE_BD unknown3;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown3", &unknown3, NULL)
        && unknown3 == assocosnappointrefactionparam->unknown3)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown3 [BD] %g != %g", assocosnappointrefactionparam->unknown3, unknown3);
    unknown3++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown3", &unknown3, 0)
        && unknown3 == assocosnappointrefactionparam->unknown3)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown3 [BD] set+1 %g != %g", assocosnappointrefactionparam->unknown3, unknown3);
    assocosnappointrefactionparam->unknown3--;
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "writedep", &writedep, NULL)
        && !memcmp (&writedep, &assocosnappointrefactionparam->writedep, sizeof (assocosnappointrefactionparam->writedep)))
        pass ();
    else
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.writedep [H]");
  }
  if (failed && (is_class_unstable ("ASSOCOSNAPPOINTREFACTIONPARAM") || is_class_debugging ("ASSOCOSNAPPOINTREFACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCOSNAPPOINTREFACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCPERSSUBENTMANAGER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCPERSSUBENTMANAGER *restrict assocperssubentmanager = obj->tio.object->tio.ASSOCPERSSUBENTMANAGER;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "class_version", &class_version, NULL)
        && class_version == assocperssubentmanager->class_version)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.class_version [BL] %u != %u", assocperssubentmanager->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "class_version", &class_version, 0)
        && class_version == assocperssubentmanager->class_version)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.class_version [BL] set+1 %u != %u", assocperssubentmanager->class_version, class_version);
    assocperssubentmanager->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "parent", &parent, NULL)
        && !memcmp (&parent, &assocperssubentmanager->parent, sizeof (assocperssubentmanager->parent)))
        pass ();
    else
        fail ("ASSOCPERSSUBENTMANAGER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B unknown_b37;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_b37", &unknown_b37, NULL)
        && unknown_b37 == assocperssubentmanager->unknown_b37)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] " FORMAT_B " != " FORMAT_B "", assocperssubentmanager->unknown_b37, unknown_b37);
    unknown_b37++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_b37", &unknown_b37, 0)
        && unknown_b37 == assocperssubentmanager->unknown_b37)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocperssubentmanager->unknown_b37, unknown_b37);
    assocperssubentmanager->unknown_b37--;
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1, NULL)
        && unknown_bl1 == assocperssubentmanager->unknown_bl1)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl1 [BL] %u != %u", assocperssubentmanager->unknown_bl1, unknown_bl1);
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1, 0)
        && unknown_bl1 == assocperssubentmanager->unknown_bl1)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl1 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl1, unknown_bl1);
    assocperssubentmanager->unknown_bl1--;
  }
  {
    BITCODE_BL unknown_bl10;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl10", &unknown_bl10, NULL)
        && unknown_bl10 == assocperssubentmanager->unknown_bl10)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] %u != %u", assocperssubentmanager->unknown_bl10, unknown_bl10);
    unknown_bl10++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl10", &unknown_bl10, 0)
        && unknown_bl10 == assocperssubentmanager->unknown_bl10)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl10, unknown_bl10);
    assocperssubentmanager->unknown_bl10--;
  }
  {
    BITCODE_BL unknown_bl11;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl11", &unknown_bl11, NULL)
        && unknown_bl11 == assocperssubentmanager->unknown_bl11)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] %u != %u", assocperssubentmanager->unknown_bl11, unknown_bl11);
    unknown_bl11++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl11", &unknown_bl11, 0)
        && unknown_bl11 == assocperssubentmanager->unknown_bl11)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl11, unknown_bl11);
    assocperssubentmanager->unknown_bl11--;
  }
  {
    BITCODE_BL unknown_bl12;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl12", &unknown_bl12, NULL)
        && unknown_bl12 == assocperssubentmanager->unknown_bl12)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] %u != %u", assocperssubentmanager->unknown_bl12, unknown_bl12);
    unknown_bl12++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl12", &unknown_bl12, 0)
        && unknown_bl12 == assocperssubentmanager->unknown_bl12)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl12, unknown_bl12);
    assocperssubentmanager->unknown_bl12--;
  }
  {
    BITCODE_BL unknown_bl13;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl13", &unknown_bl13, NULL)
        && unknown_bl13 == assocperssubentmanager->unknown_bl13)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] %u != %u", assocperssubentmanager->unknown_bl13, unknown_bl13);
    unknown_bl13++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl13", &unknown_bl13, 0)
        && unknown_bl13 == assocperssubentmanager->unknown_bl13)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl13, unknown_bl13);
    assocperssubentmanager->unknown_bl13--;
  }
  {
    BITCODE_BL unknown_bl14;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl14", &unknown_bl14, NULL)
        && unknown_bl14 == assocperssubentmanager->unknown_bl14)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] %u != %u", assocperssubentmanager->unknown_bl14, unknown_bl14);
    unknown_bl14++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl14", &unknown_bl14, 0)
        && unknown_bl14 == assocperssubentmanager->unknown_bl14)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl14, unknown_bl14);
    assocperssubentmanager->unknown_bl14--;
  }
  {
    BITCODE_BL unknown_bl15;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl15", &unknown_bl15, NULL)
        && unknown_bl15 == assocperssubentmanager->unknown_bl15)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] %u != %u", assocperssubentmanager->unknown_bl15, unknown_bl15);
    unknown_bl15++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl15", &unknown_bl15, 0)
        && unknown_bl15 == assocperssubentmanager->unknown_bl15)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl15, unknown_bl15);
    assocperssubentmanager->unknown_bl15--;
  }
  {
    BITCODE_BL unknown_bl16;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl16", &unknown_bl16, NULL)
        && unknown_bl16 == assocperssubentmanager->unknown_bl16)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] %u != %u", assocperssubentmanager->unknown_bl16, unknown_bl16);
    unknown_bl16++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl16", &unknown_bl16, 0)
        && unknown_bl16 == assocperssubentmanager->unknown_bl16)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl16, unknown_bl16);
    assocperssubentmanager->unknown_bl16--;
  }
  {
    BITCODE_BL unknown_bl17;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl17", &unknown_bl17, NULL)
        && unknown_bl17 == assocperssubentmanager->unknown_bl17)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] %u != %u", assocperssubentmanager->unknown_bl17, unknown_bl17);
    unknown_bl17++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl17", &unknown_bl17, 0)
        && unknown_bl17 == assocperssubentmanager->unknown_bl17)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl17, unknown_bl17);
    assocperssubentmanager->unknown_bl17--;
  }
  {
    BITCODE_BL unknown_bl18;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl18", &unknown_bl18, NULL)
        && unknown_bl18 == assocperssubentmanager->unknown_bl18)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] %u != %u", assocperssubentmanager->unknown_bl18, unknown_bl18);
    unknown_bl18++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl18", &unknown_bl18, 0)
        && unknown_bl18 == assocperssubentmanager->unknown_bl18)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl18, unknown_bl18);
    assocperssubentmanager->unknown_bl18--;
  }
  {
    BITCODE_BL unknown_bl19;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl19", &unknown_bl19, NULL)
        && unknown_bl19 == assocperssubentmanager->unknown_bl19)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] %u != %u", assocperssubentmanager->unknown_bl19, unknown_bl19);
    unknown_bl19++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl19", &unknown_bl19, 0)
        && unknown_bl19 == assocperssubentmanager->unknown_bl19)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl19, unknown_bl19);
    assocperssubentmanager->unknown_bl19--;
  }
  {
    BITCODE_BL unknown_bl2;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2, NULL)
        && unknown_bl2 == assocperssubentmanager->unknown_bl2)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl2 [BL] %u != %u", assocperssubentmanager->unknown_bl2, unknown_bl2);
    unknown_bl2++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2, 0)
        && unknown_bl2 == assocperssubentmanager->unknown_bl2)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl2 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl2, unknown_bl2);
    assocperssubentmanager->unknown_bl2--;
  }
  {
    BITCODE_BL unknown_bl20;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl20", &unknown_bl20, NULL)
        && unknown_bl20 == assocperssubentmanager->unknown_bl20)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] %u != %u", assocperssubentmanager->unknown_bl20, unknown_bl20);
    unknown_bl20++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl20", &unknown_bl20, 0)
        && unknown_bl20 == assocperssubentmanager->unknown_bl20)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl20, unknown_bl20);
    assocperssubentmanager->unknown_bl20--;
  }
  {
    BITCODE_BL unknown_bl21;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl21", &unknown_bl21, NULL)
        && unknown_bl21 == assocperssubentmanager->unknown_bl21)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] %u != %u", assocperssubentmanager->unknown_bl21, unknown_bl21);
    unknown_bl21++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl21", &unknown_bl21, 0)
        && unknown_bl21 == assocperssubentmanager->unknown_bl21)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl21, unknown_bl21);
    assocperssubentmanager->unknown_bl21--;
  }
  {
    BITCODE_BL unknown_bl22;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl22", &unknown_bl22, NULL)
        && unknown_bl22 == assocperssubentmanager->unknown_bl22)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] %u != %u", assocperssubentmanager->unknown_bl22, unknown_bl22);
    unknown_bl22++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl22", &unknown_bl22, 0)
        && unknown_bl22 == assocperssubentmanager->unknown_bl22)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl22, unknown_bl22);
    assocperssubentmanager->unknown_bl22--;
  }
  {
    BITCODE_BL unknown_bl23;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl23", &unknown_bl23, NULL)
        && unknown_bl23 == assocperssubentmanager->unknown_bl23)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] %u != %u", assocperssubentmanager->unknown_bl23, unknown_bl23);
    unknown_bl23++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl23", &unknown_bl23, 0)
        && unknown_bl23 == assocperssubentmanager->unknown_bl23)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl23, unknown_bl23);
    assocperssubentmanager->unknown_bl23--;
  }
  {
    BITCODE_BL unknown_bl24;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl24", &unknown_bl24, NULL)
        && unknown_bl24 == assocperssubentmanager->unknown_bl24)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] %u != %u", assocperssubentmanager->unknown_bl24, unknown_bl24);
    unknown_bl24++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl24", &unknown_bl24, 0)
        && unknown_bl24 == assocperssubentmanager->unknown_bl24)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl24, unknown_bl24);
    assocperssubentmanager->unknown_bl24--;
  }
  {
    BITCODE_BL unknown_bl25;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl25", &unknown_bl25, NULL)
        && unknown_bl25 == assocperssubentmanager->unknown_bl25)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] %u != %u", assocperssubentmanager->unknown_bl25, unknown_bl25);
    unknown_bl25++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl25", &unknown_bl25, 0)
        && unknown_bl25 == assocperssubentmanager->unknown_bl25)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl25, unknown_bl25);
    assocperssubentmanager->unknown_bl25--;
  }
  {
    BITCODE_BL unknown_bl26;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl26", &unknown_bl26, NULL)
        && unknown_bl26 == assocperssubentmanager->unknown_bl26)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] %u != %u", assocperssubentmanager->unknown_bl26, unknown_bl26);
    unknown_bl26++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl26", &unknown_bl26, 0)
        && unknown_bl26 == assocperssubentmanager->unknown_bl26)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl26, unknown_bl26);
    assocperssubentmanager->unknown_bl26--;
  }
  {
    BITCODE_BL unknown_bl27;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl27", &unknown_bl27, NULL)
        && unknown_bl27 == assocperssubentmanager->unknown_bl27)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] %u != %u", assocperssubentmanager->unknown_bl27, unknown_bl27);
    unknown_bl27++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl27", &unknown_bl27, 0)
        && unknown_bl27 == assocperssubentmanager->unknown_bl27)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl27, unknown_bl27);
    assocperssubentmanager->unknown_bl27--;
  }
  {
    BITCODE_BL unknown_bl28;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl28", &unknown_bl28, NULL)
        && unknown_bl28 == assocperssubentmanager->unknown_bl28)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] %u != %u", assocperssubentmanager->unknown_bl28, unknown_bl28);
    unknown_bl28++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl28", &unknown_bl28, 0)
        && unknown_bl28 == assocperssubentmanager->unknown_bl28)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl28, unknown_bl28);
    assocperssubentmanager->unknown_bl28--;
  }
  {
    BITCODE_BL unknown_bl29;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl29", &unknown_bl29, NULL)
        && unknown_bl29 == assocperssubentmanager->unknown_bl29)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] %u != %u", assocperssubentmanager->unknown_bl29, unknown_bl29);
    unknown_bl29++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl29", &unknown_bl29, 0)
        && unknown_bl29 == assocperssubentmanager->unknown_bl29)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl29, unknown_bl29);
    assocperssubentmanager->unknown_bl29--;
  }
  {
    BITCODE_BL unknown_bl3;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3, NULL)
        && unknown_bl3 == assocperssubentmanager->unknown_bl3)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl3 [BL] %u != %u", assocperssubentmanager->unknown_bl3, unknown_bl3);
    unknown_bl3++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3, 0)
        && unknown_bl3 == assocperssubentmanager->unknown_bl3)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl3 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl3, unknown_bl3);
    assocperssubentmanager->unknown_bl3--;
  }
  {
    BITCODE_BL unknown_bl30;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl30", &unknown_bl30, NULL)
        && unknown_bl30 == assocperssubentmanager->unknown_bl30)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] %u != %u", assocperssubentmanager->unknown_bl30, unknown_bl30);
    unknown_bl30++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl30", &unknown_bl30, 0)
        && unknown_bl30 == assocperssubentmanager->unknown_bl30)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl30, unknown_bl30);
    assocperssubentmanager->unknown_bl30--;
  }
  {
    BITCODE_BL unknown_bl31;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl31", &unknown_bl31, NULL)
        && unknown_bl31 == assocperssubentmanager->unknown_bl31)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] %u != %u", assocperssubentmanager->unknown_bl31, unknown_bl31);
    unknown_bl31++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl31", &unknown_bl31, 0)
        && unknown_bl31 == assocperssubentmanager->unknown_bl31)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl31, unknown_bl31);
    assocperssubentmanager->unknown_bl31--;
  }
  {
    BITCODE_BL unknown_bl32;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl32", &unknown_bl32, NULL)
        && unknown_bl32 == assocperssubentmanager->unknown_bl32)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] %u != %u", assocperssubentmanager->unknown_bl32, unknown_bl32);
    unknown_bl32++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl32", &unknown_bl32, 0)
        && unknown_bl32 == assocperssubentmanager->unknown_bl32)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl32, unknown_bl32);
    assocperssubentmanager->unknown_bl32--;
  }
  {
    BITCODE_BL unknown_bl33;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl33", &unknown_bl33, NULL)
        && unknown_bl33 == assocperssubentmanager->unknown_bl33)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] %u != %u", assocperssubentmanager->unknown_bl33, unknown_bl33);
    unknown_bl33++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl33", &unknown_bl33, 0)
        && unknown_bl33 == assocperssubentmanager->unknown_bl33)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl33, unknown_bl33);
    assocperssubentmanager->unknown_bl33--;
  }
  {
    BITCODE_BL unknown_bl34;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl34", &unknown_bl34, NULL)
        && unknown_bl34 == assocperssubentmanager->unknown_bl34)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] %u != %u", assocperssubentmanager->unknown_bl34, unknown_bl34);
    unknown_bl34++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl34", &unknown_bl34, 0)
        && unknown_bl34 == assocperssubentmanager->unknown_bl34)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl34, unknown_bl34);
    assocperssubentmanager->unknown_bl34--;
  }
  {
    BITCODE_BL unknown_bl35;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl35", &unknown_bl35, NULL)
        && unknown_bl35 == assocperssubentmanager->unknown_bl35)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] %u != %u", assocperssubentmanager->unknown_bl35, unknown_bl35);
    unknown_bl35++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl35", &unknown_bl35, 0)
        && unknown_bl35 == assocperssubentmanager->unknown_bl35)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl35, unknown_bl35);
    assocperssubentmanager->unknown_bl35--;
  }
  {
    BITCODE_BL unknown_bl36;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl36", &unknown_bl36, NULL)
        && unknown_bl36 == assocperssubentmanager->unknown_bl36)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] %u != %u", assocperssubentmanager->unknown_bl36, unknown_bl36);
    unknown_bl36++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl36", &unknown_bl36, 0)
        && unknown_bl36 == assocperssubentmanager->unknown_bl36)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl36, unknown_bl36);
    assocperssubentmanager->unknown_bl36--;
  }
  {
    BITCODE_BL unknown_bl4;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4, NULL)
        && unknown_bl4 == assocperssubentmanager->unknown_bl4)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl4 [BL] %u != %u", assocperssubentmanager->unknown_bl4, unknown_bl4);
    unknown_bl4++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4, 0)
        && unknown_bl4 == assocperssubentmanager->unknown_bl4)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl4 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl4, unknown_bl4);
    assocperssubentmanager->unknown_bl4--;
  }
  {
    BITCODE_BL unknown_bl5;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5, NULL)
        && unknown_bl5 == assocperssubentmanager->unknown_bl5)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl5 [BL] %u != %u", assocperssubentmanager->unknown_bl5, unknown_bl5);
    unknown_bl5++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5, 0)
        && unknown_bl5 == assocperssubentmanager->unknown_bl5)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl5 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl5, unknown_bl5);
    assocperssubentmanager->unknown_bl5--;
  }
  {
    BITCODE_BL unknown_bl6;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, NULL)
        && unknown_bl6 == assocperssubentmanager->unknown_bl6)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] %u != %u", assocperssubentmanager->unknown_bl6, unknown_bl6);
    unknown_bl6++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, 0)
        && unknown_bl6 == assocperssubentmanager->unknown_bl6)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl6, unknown_bl6);
    assocperssubentmanager->unknown_bl6--;
  }
  {
    BITCODE_BL unknown_bl6a;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6a", &unknown_bl6a, NULL)
        && unknown_bl6a == assocperssubentmanager->unknown_bl6a)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] %u != %u", assocperssubentmanager->unknown_bl6a, unknown_bl6a);
    unknown_bl6a++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6a", &unknown_bl6a, 0)
        && unknown_bl6a == assocperssubentmanager->unknown_bl6a)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl6a, unknown_bl6a);
    assocperssubentmanager->unknown_bl6a--;
  }
  {
    BITCODE_BL unknown_bl7;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7", &unknown_bl7, NULL)
        && unknown_bl7 == assocperssubentmanager->unknown_bl7)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] %u != %u", assocperssubentmanager->unknown_bl7, unknown_bl7);
    unknown_bl7++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7", &unknown_bl7, 0)
        && unknown_bl7 == assocperssubentmanager->unknown_bl7)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl7, unknown_bl7);
    assocperssubentmanager->unknown_bl7--;
  }
  {
    BITCODE_BL unknown_bl7a;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7a", &unknown_bl7a, NULL)
        && unknown_bl7a == assocperssubentmanager->unknown_bl7a)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] %u != %u", assocperssubentmanager->unknown_bl7a, unknown_bl7a);
    unknown_bl7a++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7a", &unknown_bl7a, 0)
        && unknown_bl7a == assocperssubentmanager->unknown_bl7a)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl7a, unknown_bl7a);
    assocperssubentmanager->unknown_bl7a--;
  }
  {
    BITCODE_BL unknown_bl8;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl8", &unknown_bl8, NULL)
        && unknown_bl8 == assocperssubentmanager->unknown_bl8)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] %u != %u", assocperssubentmanager->unknown_bl8, unknown_bl8);
    unknown_bl8++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl8", &unknown_bl8, 0)
        && unknown_bl8 == assocperssubentmanager->unknown_bl8)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl8, unknown_bl8);
    assocperssubentmanager->unknown_bl8--;
  }
  {
    BITCODE_BL unknown_bl9;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl9", &unknown_bl9, NULL)
        && unknown_bl9 == assocperssubentmanager->unknown_bl9)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] %u != %u", assocperssubentmanager->unknown_bl9, unknown_bl9);
    unknown_bl9++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl9", &unknown_bl9, 0)
        && unknown_bl9 == assocperssubentmanager->unknown_bl9)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl9, unknown_bl9);
    assocperssubentmanager->unknown_bl9--;
  }
  if (failed && (is_class_unstable ("ASSOCPERSSUBENTMANAGER") || is_class_debugging ("ASSOCPERSSUBENTMANAGER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCPERSSUBENTMANAGER", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCPLANESURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCPLANESURFACEACTIONBODY *restrict assocplanesurfaceactionbody = obj->tio.object->tio.ASSOCPLANESURFACEACTIONBODY;
  failed = 0;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "aab_status", &aab_status, NULL)
        && aab_status == assocplanesurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.aab_status [BL] %u != %u", assocplanesurfaceactionbody->aab_status, aab_status);
    aab_status++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "aab_status", &aab_status, 0)
        && aab_status == assocplanesurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.aab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->aab_status, aab_status);
    assocplanesurfaceactionbody->aab_status--;
  }
  {
    BITCODE_TV* descriptions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "num_descriptions", &count, NULL)
        && dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "descriptions", &descriptions, NULL)
        && descriptions == assocplanesurfaceactionbody->descriptions)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.descriptions [TV*] * %u num_descriptions", count);
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "num_deps", &num_deps, NULL)
        && num_deps == assocplanesurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.num_deps [BL] %u != %u", assocplanesurfaceactionbody->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "num_deps", &num_deps, 0)
        && num_deps == assocplanesurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.num_deps [BL] set+1 %u != %u", assocplanesurfaceactionbody->num_deps, num_deps);
    assocplanesurfaceactionbody->num_deps--;
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l2", &pab_l2, NULL)
        && pab_l2 == assocplanesurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pab_l2 [BL] %u != %u", assocplanesurfaceactionbody->pab_l2, pab_l2);
    pab_l2++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l2", &pab_l2, 0)
        && pab_l2 == assocplanesurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pab_l2 [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_l2, pab_l2);
    assocplanesurfaceactionbody->pab_l2--;
  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l4", &pab_l4, NULL)
        && pab_l4 == assocplanesurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pab_l4 [BL] %u != %u", assocplanesurfaceactionbody->pab_l4, pab_l4);
    pab_l4++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l4", &pab_l4, 0)
        && pab_l4 == assocplanesurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pab_l4 [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_l4, pab_l4);
    assocplanesurfaceactionbody->pab_l4--;
  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l5", &pab_l5, NULL)
        && pab_l5 == assocplanesurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pab_l5 [BL] %u != %u", assocplanesurfaceactionbody->pab_l5, pab_l5);
    pab_l5++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l5", &pab_l5, 0)
        && pab_l5 == assocplanesurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pab_l5 [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_l5, pab_l5);
    assocplanesurfaceactionbody->pab_l5--;
  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_status", &pab_status, NULL)
        && pab_status == assocplanesurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pab_status [BL] %u != %u", assocplanesurfaceactionbody->pab_status, pab_status);
    pab_status++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_status", &pab_status, 0)
        && pab_status == assocplanesurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->pab_status, pab_status);
    assocplanesurfaceactionbody->pab_status--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocplanesurfaceactionbody->parent, sizeof (assocplanesurfaceactionbody->parent)))
        pass ();
    else
        fail ("ASSOCPLANESURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocplanesurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocplanesurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocplanesurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->pbsab_status, pbsab_status);
    assocplanesurfaceactionbody->pbsab_status--;
  }
  {
    BITCODE_BL psab_status;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "psab_status", &psab_status, NULL)
        && psab_status == assocplanesurfaceactionbody->psab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.psab_status [BL] %u != %u", assocplanesurfaceactionbody->psab_status, psab_status);
    psab_status++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "psab_status", &psab_status, 0)
        && psab_status == assocplanesurfaceactionbody->psab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.psab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->psab_status, psab_status);
    assocplanesurfaceactionbody->psab_status--;
  }
  {
    BITCODE_H* readdeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "readdeps", &readdeps, NULL)
        && readdeps == assocplanesurfaceactionbody->readdeps)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.readdeps [H*] * %u num_deps", count);
  }
  {
    BITCODE_B sab_b1;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b1", &sab_b1, NULL)
        && sab_b1 == assocplanesurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_b1 [B] " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b1, sab_b1);
    sab_b1++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b1", &sab_b1, 0)
        && sab_b1 == assocplanesurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b1, sab_b1);
    assocplanesurfaceactionbody->sab_b1--;
  }
  {
    BITCODE_B sab_b2;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b2", &sab_b2, NULL)
        && sab_b2 == assocplanesurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_b2 [B] " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b2, sab_b2);
    sab_b2++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b2", &sab_b2, 0)
        && sab_b2 == assocplanesurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b2, sab_b2);
    assocplanesurfaceactionbody->sab_b2--;
  }
  {
    BITCODE_BL sab_l2;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_l2", &sab_l2, NULL)
        && sab_l2 == assocplanesurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_l2 [BL] %u != %u", assocplanesurfaceactionbody->sab_l2, sab_l2);
    sab_l2++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_l2", &sab_l2, 0)
        && sab_l2 == assocplanesurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_l2 [BL] set+1 %u != %u", assocplanesurfaceactionbody->sab_l2, sab_l2);
    assocplanesurfaceactionbody->sab_l2--;
  }
  {
    BITCODE_BS sab_s1;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_s1", &sab_s1, NULL)
        && sab_s1 == assocplanesurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_s1 [BS] %hu != %hu", assocplanesurfaceactionbody->sab_s1, sab_s1);
    sab_s1++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_s1", &sab_s1, 0)
        && sab_s1 == assocplanesurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_s1 [BS] set+1 %hu != %hu", assocplanesurfaceactionbody->sab_s1, sab_s1);
    assocplanesurfaceactionbody->sab_s1--;
  }
  {
    BITCODE_BL sab_status;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_status", &sab_status, NULL)
        && sab_status == assocplanesurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_status [BL] %u != %u", assocplanesurfaceactionbody->sab_status, sab_status);
    sab_status++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_status", &sab_status, 0)
        && sab_status == assocplanesurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.sab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->sab_status, sab_status);
    assocplanesurfaceactionbody->sab_status--;
  }
  {
    BITCODE_H* writedeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "writedeps", &writedeps, NULL)
        && writedeps == assocplanesurfaceactionbody->writedeps)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.writedeps [H*] * %u num_deps", count);
  }
  if (failed && (is_class_unstable ("ASSOCPLANESURFACEACTIONBODY") || is_class_debugging ("ASSOCPLANESURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCPLANESURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCREVOLVEDSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCREVOLVEDSURFACEACTIONBODY *restrict assocrevolvedsurfaceactionbody = obj->tio.object->tio.ASSOCREVOLVEDSURFACEACTIONBODY;
  failed = 0;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "aab_status", &aab_status, NULL)
        && aab_status == assocrevolvedsurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.aab_status [BL] %u != %u", assocrevolvedsurfaceactionbody->aab_status, aab_status);
    aab_status++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "aab_status", &aab_status, 0)
        && aab_status == assocrevolvedsurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.aab_status [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->aab_status, aab_status);
    assocrevolvedsurfaceactionbody->aab_status--;
  }
  {
    BITCODE_TV* descriptions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "num_descriptions", &count, NULL)
        && dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "descriptions", &descriptions, NULL)
        && descriptions == assocrevolvedsurfaceactionbody->descriptions)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.descriptions [TV*] * %u num_descriptions", count);
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "num_deps", &num_deps, NULL)
        && num_deps == assocrevolvedsurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.num_deps [BL] %u != %u", assocrevolvedsurfaceactionbody->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "num_deps", &num_deps, 0)
        && num_deps == assocrevolvedsurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.num_deps [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->num_deps, num_deps);
    assocrevolvedsurfaceactionbody->num_deps--;
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab_l2", &pab_l2, NULL)
        && pab_l2 == assocrevolvedsurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab_l2 [BL] %u != %u", assocrevolvedsurfaceactionbody->pab_l2, pab_l2);
    pab_l2++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab_l2", &pab_l2, 0)
        && pab_l2 == assocrevolvedsurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab_l2 [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->pab_l2, pab_l2);
    assocrevolvedsurfaceactionbody->pab_l2--;
  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab_l4", &pab_l4, NULL)
        && pab_l4 == assocrevolvedsurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab_l4 [BL] %u != %u", assocrevolvedsurfaceactionbody->pab_l4, pab_l4);
    pab_l4++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab_l4", &pab_l4, 0)
        && pab_l4 == assocrevolvedsurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab_l4 [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->pab_l4, pab_l4);
    assocrevolvedsurfaceactionbody->pab_l4--;
  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab_l5", &pab_l5, NULL)
        && pab_l5 == assocrevolvedsurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab_l5 [BL] %u != %u", assocrevolvedsurfaceactionbody->pab_l5, pab_l5);
    pab_l5++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab_l5", &pab_l5, 0)
        && pab_l5 == assocrevolvedsurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab_l5 [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->pab_l5, pab_l5);
    assocrevolvedsurfaceactionbody->pab_l5--;
  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab_status", &pab_status, NULL)
        && pab_status == assocrevolvedsurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab_status [BL] %u != %u", assocrevolvedsurfaceactionbody->pab_status, pab_status);
    pab_status++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab_status", &pab_status, 0)
        && pab_status == assocrevolvedsurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab_status [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->pab_status, pab_status);
    assocrevolvedsurfaceactionbody->pab_status--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocrevolvedsurfaceactionbody->parent, sizeof (assocrevolvedsurfaceactionbody->parent)))
        pass ();
    else
        fail ("ASSOCREVOLVEDSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocrevolvedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocrevolvedsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocrevolvedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->pbsab_status, pbsab_status);
    assocrevolvedsurfaceactionbody->pbsab_status--;
  }
  {
    BITCODE_H* readdeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "readdeps", &readdeps, NULL)
        && readdeps == assocrevolvedsurfaceactionbody->readdeps)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.readdeps [H*] * %u num_deps", count);
  }
  {
    BITCODE_BL rsab_status;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "rsab_status", &rsab_status, NULL)
        && rsab_status == assocrevolvedsurfaceactionbody->rsab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.rsab_status [BL] %u != %u", assocrevolvedsurfaceactionbody->rsab_status, rsab_status);
    rsab_status++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "rsab_status", &rsab_status, 0)
        && rsab_status == assocrevolvedsurfaceactionbody->rsab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.rsab_status [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->rsab_status, rsab_status);
    assocrevolvedsurfaceactionbody->rsab_status--;
  }
  {
    BITCODE_B sab_b1;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_b1", &sab_b1, NULL)
        && sab_b1 == assocrevolvedsurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_b1 [B] " FORMAT_B " != " FORMAT_B "", assocrevolvedsurfaceactionbody->sab_b1, sab_b1);
    sab_b1++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_b1", &sab_b1, 0)
        && sab_b1 == assocrevolvedsurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocrevolvedsurfaceactionbody->sab_b1, sab_b1);
    assocrevolvedsurfaceactionbody->sab_b1--;
  }
  {
    BITCODE_B sab_b2;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_b2", &sab_b2, NULL)
        && sab_b2 == assocrevolvedsurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_b2 [B] " FORMAT_B " != " FORMAT_B "", assocrevolvedsurfaceactionbody->sab_b2, sab_b2);
    sab_b2++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_b2", &sab_b2, 0)
        && sab_b2 == assocrevolvedsurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocrevolvedsurfaceactionbody->sab_b2, sab_b2);
    assocrevolvedsurfaceactionbody->sab_b2--;
  }
  {
    BITCODE_BL sab_l2;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_l2", &sab_l2, NULL)
        && sab_l2 == assocrevolvedsurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_l2 [BL] %u != %u", assocrevolvedsurfaceactionbody->sab_l2, sab_l2);
    sab_l2++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_l2", &sab_l2, 0)
        && sab_l2 == assocrevolvedsurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_l2 [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->sab_l2, sab_l2);
    assocrevolvedsurfaceactionbody->sab_l2--;
  }
  {
    BITCODE_BS sab_s1;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_s1", &sab_s1, NULL)
        && sab_s1 == assocrevolvedsurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_s1 [BS] %hu != %hu", assocrevolvedsurfaceactionbody->sab_s1, sab_s1);
    sab_s1++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_s1", &sab_s1, 0)
        && sab_s1 == assocrevolvedsurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_s1 [BS] set+1 %hu != %hu", assocrevolvedsurfaceactionbody->sab_s1, sab_s1);
    assocrevolvedsurfaceactionbody->sab_s1--;
  }
  {
    BITCODE_BL sab_status;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_status", &sab_status, NULL)
        && sab_status == assocrevolvedsurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_status [BL] %u != %u", assocrevolvedsurfaceactionbody->sab_status, sab_status);
    sab_status++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab_status", &sab_status, 0)
        && sab_status == assocrevolvedsurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab_status [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->sab_status, sab_status);
    assocrevolvedsurfaceactionbody->sab_status--;
  }
  {
    BITCODE_H* writedeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "writedeps", &writedeps, NULL)
        && writedeps == assocrevolvedsurfaceactionbody->writedeps)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.writedeps [H*] * %u num_deps", count);
  }
  if (failed && (is_class_unstable ("ASSOCREVOLVEDSURFACEACTIONBODY") || is_class_debugging ("ASSOCREVOLVEDSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCREVOLVEDSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCSWEPTSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCSWEPTSURFACEACTIONBODY *restrict assocsweptsurfaceactionbody = obj->tio.object->tio.ASSOCSWEPTSURFACEACTIONBODY;
  failed = 0;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "aab_status", &aab_status, NULL)
        && aab_status == assocsweptsurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.aab_status [BL] %u != %u", assocsweptsurfaceactionbody->aab_status, aab_status);
    aab_status++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "aab_status", &aab_status, 0)
        && aab_status == assocsweptsurfaceactionbody->aab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.aab_status [BL] set+1 %u != %u", assocsweptsurfaceactionbody->aab_status, aab_status);
    assocsweptsurfaceactionbody->aab_status--;
  }
  {
    BITCODE_TV* descriptions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "num_descriptions", &count, NULL)
        && dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "descriptions", &descriptions, NULL)
        && descriptions == assocsweptsurfaceactionbody->descriptions)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.descriptions [TV*] * %u num_descriptions", count);
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "num_deps", &num_deps, NULL)
        && num_deps == assocsweptsurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.num_deps [BL] %u != %u", assocsweptsurfaceactionbody->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "num_deps", &num_deps, 0)
        && num_deps == assocsweptsurfaceactionbody->num_deps)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.num_deps [BL] set+1 %u != %u", assocsweptsurfaceactionbody->num_deps, num_deps);
    assocsweptsurfaceactionbody->num_deps--;
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab_l2", &pab_l2, NULL)
        && pab_l2 == assocsweptsurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pab_l2 [BL] %u != %u", assocsweptsurfaceactionbody->pab_l2, pab_l2);
    pab_l2++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab_l2", &pab_l2, 0)
        && pab_l2 == assocsweptsurfaceactionbody->pab_l2)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pab_l2 [BL] set+1 %u != %u", assocsweptsurfaceactionbody->pab_l2, pab_l2);
    assocsweptsurfaceactionbody->pab_l2--;
  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab_l4", &pab_l4, NULL)
        && pab_l4 == assocsweptsurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pab_l4 [BL] %u != %u", assocsweptsurfaceactionbody->pab_l4, pab_l4);
    pab_l4++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab_l4", &pab_l4, 0)
        && pab_l4 == assocsweptsurfaceactionbody->pab_l4)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pab_l4 [BL] set+1 %u != %u", assocsweptsurfaceactionbody->pab_l4, pab_l4);
    assocsweptsurfaceactionbody->pab_l4--;
  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab_l5", &pab_l5, NULL)
        && pab_l5 == assocsweptsurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pab_l5 [BL] %u != %u", assocsweptsurfaceactionbody->pab_l5, pab_l5);
    pab_l5++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab_l5", &pab_l5, 0)
        && pab_l5 == assocsweptsurfaceactionbody->pab_l5)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pab_l5 [BL] set+1 %u != %u", assocsweptsurfaceactionbody->pab_l5, pab_l5);
    assocsweptsurfaceactionbody->pab_l5--;
  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab_status", &pab_status, NULL)
        && pab_status == assocsweptsurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pab_status [BL] %u != %u", assocsweptsurfaceactionbody->pab_status, pab_status);
    pab_status++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab_status", &pab_status, 0)
        && pab_status == assocsweptsurfaceactionbody->pab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pab_status [BL] set+1 %u != %u", assocsweptsurfaceactionbody->pab_status, pab_status);
    assocsweptsurfaceactionbody->pab_status--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocsweptsurfaceactionbody->parent, sizeof (assocsweptsurfaceactionbody->parent)))
        pass ();
    else
        fail ("ASSOCSWEPTSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocsweptsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocsweptsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocsweptsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocsweptsurfaceactionbody->pbsab_status, pbsab_status);
    assocsweptsurfaceactionbody->pbsab_status--;
  }
  {
    BITCODE_H* readdeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "readdeps", &readdeps, NULL)
        && readdeps == assocsweptsurfaceactionbody->readdeps)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.readdeps [H*] * %u num_deps", count);
  }
  {
    BITCODE_B sab_b1;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_b1", &sab_b1, NULL)
        && sab_b1 == assocsweptsurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_b1 [B] " FORMAT_B " != " FORMAT_B "", assocsweptsurfaceactionbody->sab_b1, sab_b1);
    sab_b1++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_b1", &sab_b1, 0)
        && sab_b1 == assocsweptsurfaceactionbody->sab_b1)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocsweptsurfaceactionbody->sab_b1, sab_b1);
    assocsweptsurfaceactionbody->sab_b1--;
  }
  {
    BITCODE_B sab_b2;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_b2", &sab_b2, NULL)
        && sab_b2 == assocsweptsurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_b2 [B] " FORMAT_B " != " FORMAT_B "", assocsweptsurfaceactionbody->sab_b2, sab_b2);
    sab_b2++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_b2", &sab_b2, 0)
        && sab_b2 == assocsweptsurfaceactionbody->sab_b2)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocsweptsurfaceactionbody->sab_b2, sab_b2);
    assocsweptsurfaceactionbody->sab_b2--;
  }
  {
    BITCODE_BL sab_l2;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_l2", &sab_l2, NULL)
        && sab_l2 == assocsweptsurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_l2 [BL] %u != %u", assocsweptsurfaceactionbody->sab_l2, sab_l2);
    sab_l2++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_l2", &sab_l2, 0)
        && sab_l2 == assocsweptsurfaceactionbody->sab_l2)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_l2 [BL] set+1 %u != %u", assocsweptsurfaceactionbody->sab_l2, sab_l2);
    assocsweptsurfaceactionbody->sab_l2--;
  }
  {
    BITCODE_BS sab_s1;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_s1", &sab_s1, NULL)
        && sab_s1 == assocsweptsurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_s1 [BS] %hu != %hu", assocsweptsurfaceactionbody->sab_s1, sab_s1);
    sab_s1++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_s1", &sab_s1, 0)
        && sab_s1 == assocsweptsurfaceactionbody->sab_s1)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_s1 [BS] set+1 %hu != %hu", assocsweptsurfaceactionbody->sab_s1, sab_s1);
    assocsweptsurfaceactionbody->sab_s1--;
  }
  {
    BITCODE_BL sab_status;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_status", &sab_status, NULL)
        && sab_status == assocsweptsurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_status [BL] %u != %u", assocsweptsurfaceactionbody->sab_status, sab_status);
    sab_status++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab_status", &sab_status, 0)
        && sab_status == assocsweptsurfaceactionbody->sab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.sab_status [BL] set+1 %u != %u", assocsweptsurfaceactionbody->sab_status, sab_status);
    assocsweptsurfaceactionbody->sab_status--;
  }
  {
    BITCODE_BL ssab_status;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "ssab_status", &ssab_status, NULL)
        && ssab_status == assocsweptsurfaceactionbody->ssab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.ssab_status [BL] %u != %u", assocsweptsurfaceactionbody->ssab_status, ssab_status);
    ssab_status++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "ssab_status", &ssab_status, 0)
        && ssab_status == assocsweptsurfaceactionbody->ssab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.ssab_status [BL] set+1 %u != %u", assocsweptsurfaceactionbody->ssab_status, ssab_status);
    assocsweptsurfaceactionbody->ssab_status--;
  }
  {
    BITCODE_H* writedeps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "writedeps", &writedeps, NULL)
        && writedeps == assocsweptsurfaceactionbody->writedeps)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.writedeps [H*] * %u num_deps", count);
  }
  if (failed && (is_class_unstable ("ASSOCSWEPTSURFACEACTIONBODY") || is_class_debugging ("ASSOCSWEPTSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCSWEPTSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLKREFOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLKREFOBJECTCONTEXTDATA *restrict blkrefobjectcontextdata = obj->tio.object->tio.BLKREFOBJECTCONTEXTDATA;
  failed = 0;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == blkrefobjectcontextdata->class_version)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", blkrefobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == blkrefobjectcontextdata->class_version)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", blkrefobjectcontextdata->class_version, class_version);
    blkrefobjectcontextdata->class_version--;
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL)
        && defaultflag == blkrefobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", blkrefobjectcontextdata->defaultflag, defaultflag);
    defaultflag++;
    if (dwg_dynapi_entity_set_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "defaultflag", &defaultflag, 0)
        && defaultflag == blkrefobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", blkrefobjectcontextdata->defaultflag, defaultflag);
    blkrefobjectcontextdata->defaultflag--;
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "has_file", &has_file, NULL)
        && has_file == blkrefobjectcontextdata->has_file)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", blkrefobjectcontextdata->has_file, has_file);
    has_file++;
    if (dwg_dynapi_entity_set_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "has_file", &has_file, 0)
        && has_file == blkrefobjectcontextdata->has_file)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", blkrefobjectcontextdata->has_file, has_file);
    blkrefobjectcontextdata->has_file--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &blkrefobjectcontextdata->parent, sizeof (blkrefobjectcontextdata->parent)))
        pass ();
    else
        fail ("BLKREFOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &blkrefobjectcontextdata->scale, sizeof (blkrefobjectcontextdata->scale)))
        pass ();
    else
        fail ("BLKREFOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("BLKREFOBJECTCONTEXTDATA") || is_class_debugging ("BLKREFOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLKREFOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCK_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCK_CONTROL *restrict block_control = obj->tio.object->tio.BLOCK_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "entries", &entries, NULL)
        && entries == block_control->entries)
      pass ();
    else
      fail ("BLOCK_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_H model_space;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "model_space", &model_space, NULL)
        && !memcmp (&model_space, &block_control->model_space, sizeof (block_control->model_space)))
        pass ();
    else
        fail ("BLOCK_CONTROL.model_space [H]");
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == block_control->num_entries)
      pass ();
    else
      fail ("BLOCK_CONTROL.num_entries [BS] %hu != %hu", block_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (block_control, "BLOCK_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == block_control->num_entries)
      pass ();
    else
      fail ("BLOCK_CONTROL.num_entries [BS] set+1 %hu != %hu", block_control->num_entries, num_entries);
    block_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "objid", &objid, NULL)
        && objid == block_control->objid)
      pass ();
    else
      fail ("BLOCK_CONTROL.objid [BL] %u != %u", block_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (block_control, "BLOCK_CONTROL", "objid", &objid, 0)
        && objid == block_control->objid)
      pass ();
    else
      fail ("BLOCK_CONTROL.objid [BL] set+1 %u != %u", block_control->objid, objid);
    block_control->objid--;
  }
  {
    BITCODE_H paper_space;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "paper_space", &paper_space, NULL)
        && !memcmp (&paper_space, &block_control->paper_space, sizeof (block_control->paper_space)))
        pass ();
    else
        fail ("BLOCK_CONTROL.paper_space [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &block_control->parent, sizeof (block_control->parent)))
        pass ();
    else
        fail ("BLOCK_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCK_CONTROL") || is_class_debugging ("BLOCK_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCK_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCK_HEADER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCK_HEADER *restrict block_header = obj->tio.object->tio.BLOCK_HEADER;
  failed = 0;
  {
    BITCODE_BL __iterator;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "__iterator", &__iterator, NULL)
        && __iterator == block_header->__iterator)
      pass ();
    else
      fail ("BLOCK_HEADER.__iterator [BL] %u != %u", block_header->__iterator, __iterator);
    __iterator++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "__iterator", &__iterator, 0)
        && __iterator == block_header->__iterator)
      pass ();
    else
      fail ("BLOCK_HEADER.__iterator [BL] set+1 %u != %u", block_header->__iterator, __iterator);
    block_header->__iterator--;
  }
  {
    BITCODE_B anonymous;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "anonymous", &anonymous, NULL)
        && anonymous == block_header->anonymous)
      pass ();
    else
      fail ("BLOCK_HEADER.anonymous [B] " FORMAT_B " != " FORMAT_B "", block_header->anonymous, anonymous);
    anonymous++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "anonymous", &anonymous, 0)
        && anonymous == block_header->anonymous)
      pass ();
    else
      fail ("BLOCK_HEADER.anonymous [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->anonymous, anonymous);
    block_header->anonymous--;
  }
  {
    BITCODE_3DPOINT base_pt;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "base_pt", &base_pt, NULL)
        && !memcmp (&base_pt, &block_header->base_pt, sizeof (block_header->base_pt)))
        pass ();
    else
        fail ("BLOCK_HEADER.base_pt [3DPOINT]");
  }
  {
    BITCODE_B blkisxref;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "blkisxref", &blkisxref, NULL)
        && blkisxref == block_header->blkisxref)
      pass ();
    else
      fail ("BLOCK_HEADER.blkisxref [B] " FORMAT_B " != " FORMAT_B "", block_header->blkisxref, blkisxref);
    blkisxref++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "blkisxref", &blkisxref, 0)
        && blkisxref == block_header->blkisxref)
      pass ();
    else
      fail ("BLOCK_HEADER.blkisxref [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->blkisxref, blkisxref);
    block_header->blkisxref--;
  }
  {
    BITCODE_H block_entity;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "block_entity", &block_entity, NULL)
        && !memcmp (&block_entity, &block_header->block_entity, sizeof (block_header->block_entity)))
        pass ();
    else
        fail ("BLOCK_HEADER.block_entity [H]");
  }
  {
    BITCODE_RC block_scaling;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "block_scaling", &block_scaling, NULL)
        && block_scaling == block_header->block_scaling)
      pass ();
    else
      fail ("BLOCK_HEADER.block_scaling [RC] %u != %u", block_header->block_scaling, block_scaling);
    block_scaling++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "block_scaling", &block_scaling, 0)
        && block_scaling == block_header->block_scaling)
      pass ();
    else
      fail ("BLOCK_HEADER.block_scaling [RC] set+1 %u != %u", block_header->block_scaling, block_scaling);
    block_header->block_scaling--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)block_header->description)
           : !block_header->description)
      pass ();
    else
      fail ("BLOCK_HEADER.description [T] '%s' <> '%s'", description, block_header->description);
  }
  {
    BITCODE_H endblk_entity;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "endblk_entity", &endblk_entity, NULL)
        && !memcmp (&endblk_entity, &block_header->endblk_entity, sizeof (block_header->endblk_entity)))
        pass ();
    else
        fail ("BLOCK_HEADER.endblk_entity [H]");
  }
  {
    BITCODE_H* entities;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "entities", &entities, NULL)
        && entities == block_header->entities)
      pass ();
    else
      fail ("BLOCK_HEADER.entities [H*] * %u num_owned", count);
  }
  {
    BITCODE_B explodable;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "explodable", &explodable, NULL)
        && explodable == block_header->explodable)
      pass ();
    else
      fail ("BLOCK_HEADER.explodable [B] " FORMAT_B " != " FORMAT_B "", block_header->explodable, explodable);
    explodable++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "explodable", &explodable, 0)
        && explodable == block_header->explodable)
      pass ();
    else
      fail ("BLOCK_HEADER.explodable [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->explodable, explodable);
    block_header->explodable--;
  }
  {
    BITCODE_H first_entity;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "first_entity", &first_entity, NULL)
        && !memcmp (&first_entity, &block_header->first_entity, sizeof (block_header->first_entity)))
        pass ();
    else
        fail ("BLOCK_HEADER.first_entity [H]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "flag", &flag, NULL)
        && flag == block_header->flag)
      pass ();
    else
      fail ("BLOCK_HEADER.flag [RC] %u != %u", block_header->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "flag", &flag, 0)
        && flag == block_header->flag)
      pass ();
    else
      fail ("BLOCK_HEADER.flag [RC] set+1 %u != %u", block_header->flag, flag);
    block_header->flag--;
  }
  {
    BITCODE_RC flag2;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "flag2", &flag2, NULL)
        && flag2 == block_header->flag2)
      pass ();
    else
      fail ("BLOCK_HEADER.flag2 [RC] %u != %u", block_header->flag2, flag2);
    flag2++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "flag2", &flag2, 0)
        && flag2 == block_header->flag2)
      pass ();
    else
      fail ("BLOCK_HEADER.flag2 [RC] set+1 %u != %u", block_header->flag2, flag2);
    block_header->flag2--;
  }
  {
    BITCODE_RS flag3;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "flag3", &flag3, NULL)
        && flag3 == block_header->flag3)
      pass ();
    else
      fail ("BLOCK_HEADER.flag3 [RS] %hu != %hu", block_header->flag3, flag3);
    flag3++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "flag3", &flag3, 0)
        && flag3 == block_header->flag3)
      pass ();
    else
      fail ("BLOCK_HEADER.flag3 [RS] set+1 %hu != %hu", block_header->flag3, flag3);
    block_header->flag3--;
  }
  {
    BITCODE_B hasattrs;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "hasattrs", &hasattrs, NULL)
        && hasattrs == block_header->hasattrs)
      pass ();
    else
      fail ("BLOCK_HEADER.hasattrs [B] " FORMAT_B " != " FORMAT_B "", block_header->hasattrs, hasattrs);
    hasattrs++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "hasattrs", &hasattrs, 0)
        && hasattrs == block_header->hasattrs)
      pass ();
    else
      fail ("BLOCK_HEADER.hasattrs [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->hasattrs, hasattrs);
    block_header->hasattrs--;
  }
  {
    BITCODE_BS insert_units;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "insert_units", &insert_units, NULL)
        && insert_units == block_header->insert_units)
      pass ();
    else
      fail ("BLOCK_HEADER.insert_units [BS] %hu != %hu", block_header->insert_units, insert_units);
    insert_units++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "insert_units", &insert_units, 0)
        && insert_units == block_header->insert_units)
      pass ();
    else
      fail ("BLOCK_HEADER.insert_units [BS] set+1 %hu != %hu", block_header->insert_units, insert_units);
    block_header->insert_units--;
  }
  {
    BITCODE_H* inserts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "num_inserts", &count, NULL)
        && dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "inserts", &inserts, NULL)
        && inserts == block_header->inserts)
      pass ();
    else
      fail ("BLOCK_HEADER.inserts [H*] * %u num_inserts", count);
  }
  {
    BITCODE_H last_entity;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "last_entity", &last_entity, NULL)
        && !memcmp (&last_entity, &block_header->last_entity, sizeof (block_header->last_entity)))
        pass ();
    else
        fail ("BLOCK_HEADER.last_entity [H]");
  }
  {
    BITCODE_H layout;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "layout", &layout, NULL)
        && !memcmp (&layout, &block_header->layout, sizeof (block_header->layout)))
        pass ();
    else
        fail ("BLOCK_HEADER.layout [H]");
  }
  {
    BITCODE_B loaded_bit;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "loaded_bit", &loaded_bit, NULL)
        && loaded_bit == block_header->loaded_bit)
      pass ();
    else
      fail ("BLOCK_HEADER.loaded_bit [B] " FORMAT_B " != " FORMAT_B "", block_header->loaded_bit, loaded_bit);
    loaded_bit++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "loaded_bit", &loaded_bit, 0)
        && loaded_bit == block_header->loaded_bit)
      pass ();
    else
      fail ("BLOCK_HEADER.loaded_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->loaded_bit, loaded_bit);
    block_header->loaded_bit--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)block_header->name)
           : !block_header->name)
      pass ();
    else
      fail ("BLOCK_HEADER.name [TV] '%s' <> '%s'", name, block_header->name);
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "null_handle", &null_handle, NULL)
        && !memcmp (&null_handle, &block_header->null_handle, sizeof (block_header->null_handle)))
        pass ();
    else
        fail ("BLOCK_HEADER.null_handle [H]");
  }
  {
    BITCODE_RL num_inserts;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "num_inserts", &num_inserts, NULL)
        && num_inserts == block_header->num_inserts)
      pass ();
    else
      fail ("BLOCK_HEADER.num_inserts [RL] %u != %u", block_header->num_inserts, num_inserts);
    num_inserts++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "num_inserts", &num_inserts, 0)
        && num_inserts == block_header->num_inserts)
      pass ();
    else
      fail ("BLOCK_HEADER.num_inserts [RL] set+1 %u != %u", block_header->num_inserts, num_inserts);
    block_header->num_inserts--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "num_owned", &num_owned, NULL)
        && num_owned == block_header->num_owned)
      pass ();
    else
      fail ("BLOCK_HEADER.num_owned [BL] %u != %u", block_header->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "num_owned", &num_owned, 0)
        && num_owned == block_header->num_owned)
      pass ();
    else
      fail ("BLOCK_HEADER.num_owned [BL] set+1 %u != %u", block_header->num_owned, num_owned);
    block_header->num_owned--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "parent", &parent, NULL)
        && !memcmp (&parent, &block_header->parent, sizeof (block_header->parent)))
        pass ();
    else
        fail ("BLOCK_HEADER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_TF preview;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "preview", &preview, NULL)
        && !memcmp (&preview, &block_header->preview, sizeof (block_header->preview)))
        pass ();
    else
        fail ("BLOCK_HEADER.preview [TF]");
  }
  {
    BITCODE_BL preview_size;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "preview_size", &preview_size, NULL)
        && preview_size == block_header->preview_size)
      pass ();
    else
      fail ("BLOCK_HEADER.preview_size [BL] %u != %u", block_header->preview_size, preview_size);
    preview_size++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "preview_size", &preview_size, 0)
        && preview_size == block_header->preview_size)
      pass ();
    else
      fail ("BLOCK_HEADER.preview_size [BL] set+1 %u != %u", block_header->preview_size, preview_size);
    block_header->preview_size--;
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "used", &used, NULL)
        && used == block_header->used)
      pass ();
    else
      fail ("BLOCK_HEADER.used [RS] %hu != %hu", block_header->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "used", &used, 0)
        && used == block_header->used)
      pass ();
    else
      fail ("BLOCK_HEADER.used [RS] set+1 %hu != %hu", block_header->used, used);
    block_header->used--;
  }
  {
    BITCODE_T xref_pname;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "xref_pname", &xref_pname, NULL)
        && xref_pname
           ? strEQ ((char *)xref_pname, (char *)block_header->xref_pname)
           : !block_header->xref_pname)
      pass ();
    else
      fail ("BLOCK_HEADER.xref_pname [T] '%s' <> '%s'", xref_pname, block_header->xref_pname);
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "xrefdep", &xrefdep, NULL)
        && xrefdep == block_header->xrefdep)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "xrefdep", &xrefdep, 0)
        && xrefdep == block_header->xrefdep)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->xrefdep, xrefdep);
    block_header->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == block_header->xrefindex_plus1)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefindex_plus1 [BS] %hu != %hu", block_header->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == block_header->xrefindex_plus1)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefindex_plus1 [BS] set+1 %hu != %hu", block_header->xrefindex_plus1, xrefindex_plus1);
    block_header->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefoverlaid;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "xrefoverlaid", &xrefoverlaid, NULL)
        && xrefoverlaid == block_header->xrefoverlaid)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefoverlaid [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefoverlaid, xrefoverlaid);
    xrefoverlaid++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "xrefoverlaid", &xrefoverlaid, 0)
        && xrefoverlaid == block_header->xrefoverlaid)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefoverlaid [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->xrefoverlaid, xrefoverlaid);
    block_header->xrefoverlaid--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "xrefref", &xrefref, NULL)
        && xrefref == block_header->xrefref)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefref [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "xrefref", &xrefref, 0)
        && xrefref == block_header->xrefref)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->xrefref, xrefref);
    block_header->xrefref--;
  }
  if (failed && (is_class_unstable ("BLOCK_HEADER") || is_class_debugging ("BLOCK_HEADER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCK_HEADER", failed);
      failed = 0;
    }
  return failed;
}
static int test_CELLSTYLEMAP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_CELLSTYLEMAP *restrict cellstylemap = obj->tio.object->tio.CELLSTYLEMAP;
  failed = 0;
  {
    Dwg_CELLSTYLEMAP_Cell* cells;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (cellstylemap, "CELLSTYLEMAP", "num_cells", &count, NULL)
        && dwg_dynapi_entity_value (cellstylemap, "CELLSTYLEMAP", "cells", &cells, NULL)
        && cells == cellstylemap->cells)
      pass ();
    else
      fail ("CELLSTYLEMAP.cells [Dwg_CELLSTYLEMAP_Cell*] * %u num_cells", count);
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value (cellstylemap, "CELLSTYLEMAP", "num_cells", &num_cells, NULL)
        && num_cells == cellstylemap->num_cells)
      pass ();
    else
      fail ("CELLSTYLEMAP.num_cells [BL] %u != %u", cellstylemap->num_cells, num_cells);
    num_cells++;
    if (dwg_dynapi_entity_set_value (cellstylemap, "CELLSTYLEMAP", "num_cells", &num_cells, 0)
        && num_cells == cellstylemap->num_cells)
      pass ();
    else
      fail ("CELLSTYLEMAP.num_cells [BL] set+1 %u != %u", cellstylemap->num_cells, num_cells);
    cellstylemap->num_cells--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (cellstylemap, "CELLSTYLEMAP", "parent", &parent, NULL)
        && !memcmp (&parent, &cellstylemap->parent, sizeof (cellstylemap->parent)))
        pass ();
    else
        fail ("CELLSTYLEMAP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("CELLSTYLEMAP") || is_class_debugging ("CELLSTYLEMAP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CELLSTYLEMAP", failed);
      failed = 0;
    }
  return failed;
}
static int test_DATALINK (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DATALINK *restrict datalink = obj->tio.object->tio.DATALINK;
  failed = 0;
  {
    BITCODE_T appname;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "appname", &appname, NULL)
        && appname
           ? strEQ ((char *)appname, (char *)datalink->appname)
           : !datalink->appname)
      pass ();
    else
      fail ("DATALINK.appname [T] '%s' <> '%s'", appname, datalink->appname);
  }
  {
    BITCODE_BS bs171;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "bs171", &bs171, NULL)
        && bs171 == datalink->bs171)
      pass ();
    else
      fail ("DATALINK.bs171 [BS] %hu != %hu", datalink->bs171, bs171);
    bs171++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "bs171", &bs171, 0)
        && bs171 == datalink->bs171)
      pass ();
    else
      fail ("DATALINK.bs171 [BS] set+1 %hu != %hu", datalink->bs171, bs171);
    datalink->bs171--;
  }
  {
    BITCODE_BS bs176;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "bs176", &bs176, NULL)
        && bs176 == datalink->bs176)
      pass ();
    else
      fail ("DATALINK.bs176 [BS] %hu != %hu", datalink->bs176, bs176);
    bs176++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "bs176", &bs176, 0)
        && bs176 == datalink->bs176)
      pass ();
    else
      fail ("DATALINK.bs176 [BS] set+1 %hu != %hu", datalink->bs176, bs176);
    datalink->bs176--;
  }
  {
    BITCODE_BS bs90;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "bs90", &bs90, NULL)
        && bs90 == datalink->bs90)
      pass ();
    else
      fail ("DATALINK.bs90 [BS] %hu != %hu", datalink->bs90, bs90);
    bs90++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "bs90", &bs90, 0)
        && bs90 == datalink->bs90)
      pass ();
    else
      fail ("DATALINK.bs90 [BS] set+1 %hu != %hu", datalink->bs90, bs90);
    datalink->bs90--;
  }
  {
    BITCODE_BS bs91;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "bs91", &bs91, NULL)
        && bs91 == datalink->bs91)
      pass ();
    else
      fail ("DATALINK.bs91 [BS] %hu != %hu", datalink->bs91, bs91);
    bs91++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "bs91", &bs91, 0)
        && bs91 == datalink->bs91)
      pass ();
    else
      fail ("DATALINK.bs91 [BS] set+1 %hu != %hu", datalink->bs91, bs91);
    datalink->bs91--;
  }
  {
    BITCODE_BS bs92;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "bs92", &bs92, NULL)
        && bs92 == datalink->bs92)
      pass ();
    else
      fail ("DATALINK.bs92 [BS] %hu != %hu", datalink->bs92, bs92);
    bs92++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "bs92", &bs92, 0)
        && bs92 == datalink->bs92)
      pass ();
    else
      fail ("DATALINK.bs92 [BS] set+1 %hu != %hu", datalink->bs92, bs92);
    datalink->bs92--;
  }
  {
    BITCODE_BS bs93;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "bs93", &bs93, NULL)
        && bs93 == datalink->bs93)
      pass ();
    else
      fail ("DATALINK.bs93 [BS] %hu != %hu", datalink->bs93, bs93);
    bs93++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "bs93", &bs93, 0)
        && bs93 == datalink->bs93)
      pass ();
    else
      fail ("DATALINK.bs93 [BS] set+1 %hu != %hu", datalink->bs93, bs93);
    datalink->bs93--;
  }
  {
    BITCODE_T cell;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "cell", &cell, NULL)
        && cell
           ? strEQ ((char *)cell, (char *)datalink->cell)
           : !datalink->cell)
      pass ();
    else
      fail ("DATALINK.cell [T] '%s' <> '%s'", cell, datalink->cell);
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "class_version", &class_version, NULL)
        && class_version == datalink->class_version)
      pass ();
    else
      fail ("DATALINK.class_version [BS] %hu != %hu", datalink->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "class_version", &class_version, 0)
        && class_version == datalink->class_version)
      pass ();
    else
      fail ("DATALINK.class_version [BS] set+1 %hu != %hu", datalink->class_version, class_version);
    datalink->class_version--;
  }
  {
    BITCODE_BS day;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "day", &day, NULL)
        && day == datalink->day)
      pass ();
    else
      fail ("DATALINK.day [BS] %hu != %hu", datalink->day, day);
    day++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "day", &day, 0)
        && day == datalink->day)
      pass ();
    else
      fail ("DATALINK.day [BS] set+1 %hu != %hu", datalink->day, day);
    datalink->day--;
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (datalink, "DATALINK", "deps", &deps, NULL)
        && deps == datalink->deps)
      pass ();
    else
      fail ("DATALINK.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)datalink->description)
           : !datalink->description)
      pass ();
    else
      fail ("DATALINK.description [T] '%s' <> '%s'", description, datalink->description);
  }
  {
    BITCODE_BS hour;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "hour", &hour, NULL)
        && hour == datalink->hour)
      pass ();
    else
      fail ("DATALINK.hour [BS] %hu != %hu", datalink->hour, hour);
    hour++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "hour", &hour, 0)
        && hour == datalink->hour)
      pass ();
    else
      fail ("DATALINK.hour [BS] set+1 %hu != %hu", datalink->hour, hour);
    datalink->hour--;
  }
  {
    BITCODE_T link;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "link", &link, NULL)
        && link
           ? strEQ ((char *)link, (char *)datalink->link)
           : !datalink->link)
      pass ();
    else
      fail ("DATALINK.link [T] '%s' <> '%s'", link, datalink->link);
  }
  {
    BITCODE_BS minute;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "minute", &minute, NULL)
        && minute == datalink->minute)
      pass ();
    else
      fail ("DATALINK.minute [BS] %hu != %hu", datalink->minute, minute);
    minute++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "minute", &minute, 0)
        && minute == datalink->minute)
      pass ();
    else
      fail ("DATALINK.minute [BS] set+1 %hu != %hu", datalink->minute, minute);
    datalink->minute--;
  }
  {
    BITCODE_BS month;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "month", &month, NULL)
        && month == datalink->month)
      pass ();
    else
      fail ("DATALINK.month [BS] %hu != %hu", datalink->month, month);
    month++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "month", &month, 0)
        && month == datalink->month)
      pass ();
    else
      fail ("DATALINK.month [BS] set+1 %hu != %hu", datalink->month, month);
    datalink->month--;
  }
  {
    BITCODE_BS num_deps;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "num_deps", &num_deps, NULL)
        && num_deps == datalink->num_deps)
      pass ();
    else
      fail ("DATALINK.num_deps [BS] %hu != %hu", datalink->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "num_deps", &num_deps, 0)
        && num_deps == datalink->num_deps)
      pass ();
    else
      fail ("DATALINK.num_deps [BS] set+1 %hu != %hu", datalink->num_deps, num_deps);
    datalink->num_deps--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "parent", &parent, NULL)
        && !memcmp (&parent, &datalink->parent, sizeof (datalink->parent)))
        pass ();
    else
        fail ("DATALINK.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS seconds;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "seconds", &seconds, NULL)
        && seconds == datalink->seconds)
      pass ();
    else
      fail ("DATALINK.seconds [BS] %hu != %hu", datalink->seconds, seconds);
    seconds++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "seconds", &seconds, 0)
        && seconds == datalink->seconds)
      pass ();
    else
      fail ("DATALINK.seconds [BS] set+1 %hu != %hu", datalink->seconds, seconds);
    datalink->seconds--;
  }
  {
    BITCODE_T t304;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "t304", &t304, NULL)
        && t304
           ? strEQ ((char *)t304, (char *)datalink->t304)
           : !datalink->t304)
      pass ();
    else
      fail ("DATALINK.t304 [T] '%s' <> '%s'", t304, datalink->t304);
  }
  {
    BITCODE_T t305;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "t305", &t305, NULL)
        && t305
           ? strEQ ((char *)t305, (char *)datalink->t305)
           : !datalink->t305)
      pass ();
    else
      fail ("DATALINK.t305 [T] '%s' <> '%s'", t305, datalink->t305);
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "writedep", &writedep, NULL)
        && !memcmp (&writedep, &datalink->writedep, sizeof (datalink->writedep)))
        pass ();
    else
        fail ("DATALINK.writedep [H]");
  }
  {
    BITCODE_BS year;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "year", &year, NULL)
        && year == datalink->year)
      pass ();
    else
      fail ("DATALINK.year [BS] %hu != %hu", datalink->year, year);
    year++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "year", &year, 0)
        && year == datalink->year)
      pass ();
    else
      fail ("DATALINK.year [BS] set+1 %hu != %hu", datalink->year, year);
    datalink->year--;
  }
  if (failed && (is_class_unstable ("DATALINK") || is_class_debugging ("DATALINK")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DATALINK", failed);
      failed = 0;
    }
  return failed;
}
static int test_DATATABLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DATATABLE *restrict datatable = obj->tio.object->tio.DATATABLE;
  failed = 0;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (datatable, "DATATABLE", "parent", &parent, NULL)
        && !memcmp (&parent, &datatable->parent, sizeof (datatable->parent)))
        pass ();
    else
        fail ("DATATABLE.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DATATABLE") || is_class_debugging ("DATATABLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DATATABLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DBCOLOR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DBCOLOR *restrict dbcolor = obj->tio.object->tio.DBCOLOR;
  failed = 0;
  {
    BITCODE_T catalog;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "catalog", &catalog, NULL)
        && catalog
           ? strEQ ((char *)catalog, (char *)dbcolor->catalog)
           : !dbcolor->catalog)
      pass ();
    else
      fail ("DBCOLOR.catalog [T] '%s' <> '%s'", catalog, dbcolor->catalog);
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "class_version", &class_version, NULL)
        && class_version == dbcolor->class_version)
      pass ();
    else
      fail ("DBCOLOR.class_version [BL] %u != %u", dbcolor->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dbcolor, "DBCOLOR", "class_version", &class_version, 0)
        && class_version == dbcolor->class_version)
      pass ();
    else
      fail ("DBCOLOR.class_version [BL] set+1 %u != %u", dbcolor->class_version, class_version);
    dbcolor->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "color", &color, NULL)
        && !memcmp (&color, &dbcolor->color, sizeof (dbcolor->color)))
        pass ();
    else
        fail ("DBCOLOR.color [CMC]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)dbcolor->name)
           : !dbcolor->name)
      pass ();
    else
      fail ("DBCOLOR.name [T] '%s' <> '%s'", name, dbcolor->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "parent", &parent, NULL)
        && !memcmp (&parent, &dbcolor->parent, sizeof (dbcolor->parent)))
        pass ();
    else
        fail ("DBCOLOR.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RL rgb;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "rgb", &rgb, NULL)
        && rgb == dbcolor->rgb)
      pass ();
    else
      fail ("DBCOLOR.rgb [RL] %u != %u", dbcolor->rgb, rgb);
    rgb++;
    if (dwg_dynapi_entity_set_value (dbcolor, "DBCOLOR", "rgb", &rgb, 0)
        && rgb == dbcolor->rgb)
      pass ();
    else
      fail ("DBCOLOR.rgb [RL] set+1 %u != %u", dbcolor->rgb, rgb);
    dbcolor->rgb--;
  }
  {
    BITCODE_BB unknown1;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "unknown1", &unknown1, NULL)
        && unknown1 == dbcolor->unknown1)
      pass ();
    else
      fail ("DBCOLOR.unknown1 [BB] " FORMAT_BB " != " FORMAT_BB "", dbcolor->unknown1, unknown1);
    unknown1++;
    if (dwg_dynapi_entity_set_value (dbcolor, "DBCOLOR", "unknown1", &unknown1, 0)
        && unknown1 == dbcolor->unknown1)
      pass ();
    else
      fail ("DBCOLOR.unknown1 [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", dbcolor->unknown1, unknown1);
    dbcolor->unknown1--;
  }
  {
    BITCODE_RC unknown2;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "unknown2", &unknown2, NULL)
        && unknown2 == dbcolor->unknown2)
      pass ();
    else
      fail ("DBCOLOR.unknown2 [RC] %u != %u", dbcolor->unknown2, unknown2);
    unknown2++;
    if (dwg_dynapi_entity_set_value (dbcolor, "DBCOLOR", "unknown2", &unknown2, 0)
        && unknown2 == dbcolor->unknown2)
      pass ();
    else
      fail ("DBCOLOR.unknown2 [RC] set+1 %u != %u", dbcolor->unknown2, unknown2);
    dbcolor->unknown2--;
  }
  if (failed && (is_class_unstable ("DBCOLOR") || is_class_debugging ("DBCOLOR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DBCOLOR", failed);
      failed = 0;
    }
  return failed;
}
static int test_DICTIONARY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DICTIONARY *restrict dictionary = obj->tio.object->tio.DICTIONARY;
  failed = 0;
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "cloning", &cloning, NULL)
        && cloning == dictionary->cloning)
      pass ();
    else
      fail ("DICTIONARY.cloning [BS] %hu != %hu", dictionary->cloning, cloning);
    cloning++;
    if (dwg_dynapi_entity_set_value (dictionary, "DICTIONARY", "cloning", &cloning, 0)
        && cloning == dictionary->cloning)
      pass ();
    else
      fail ("DICTIONARY.cloning [BS] set+1 %hu != %hu", dictionary->cloning, cloning);
    dictionary->cloning--;
  }
  {
    BITCODE_RC cloning_r14;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "cloning_r14", &cloning_r14, NULL)
        && cloning_r14 == dictionary->cloning_r14)
      pass ();
    else
      fail ("DICTIONARY.cloning_r14 [RC] %u != %u", dictionary->cloning_r14, cloning_r14);
    cloning_r14++;
    if (dwg_dynapi_entity_set_value (dictionary, "DICTIONARY", "cloning_r14", &cloning_r14, 0)
        && cloning_r14 == dictionary->cloning_r14)
      pass ();
    else
      fail ("DICTIONARY.cloning_r14 [RC] set+1 %u != %u", dictionary->cloning_r14, cloning_r14);
    dictionary->cloning_r14--;
  }
  {
    BITCODE_RC hard_owner;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "hard_owner", &hard_owner, NULL)
        && hard_owner == dictionary->hard_owner)
      pass ();
    else
      fail ("DICTIONARY.hard_owner [RC] %u != %u", dictionary->hard_owner, hard_owner);
    hard_owner++;
    if (dwg_dynapi_entity_set_value (dictionary, "DICTIONARY", "hard_owner", &hard_owner, 0)
        && hard_owner == dictionary->hard_owner)
      pass ();
    else
      fail ("DICTIONARY.hard_owner [RC] set+1 %u != %u", dictionary->hard_owner, hard_owner);
    dictionary->hard_owner--;
  }
  {
    BITCODE_H* itemhandles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "numitems", &count, NULL)
        && dwg_dynapi_entity_value (dictionary, "DICTIONARY", "itemhandles", &itemhandles, NULL)
        && itemhandles == dictionary->itemhandles)
      pass ();
    else
      fail ("DICTIONARY.itemhandles [H*] * %u numitems", count);
  }
  {
    BITCODE_BL numitems;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "numitems", &numitems, NULL)
        && numitems == dictionary->numitems)
      pass ();
    else
      fail ("DICTIONARY.numitems [BL] %u != %u", dictionary->numitems, numitems);
    numitems++;
    if (dwg_dynapi_entity_set_value (dictionary, "DICTIONARY", "numitems", &numitems, 0)
        && numitems == dictionary->numitems)
      pass ();
    else
      fail ("DICTIONARY.numitems [BL] set+1 %u != %u", dictionary->numitems, numitems);
    dictionary->numitems--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "parent", &parent, NULL)
        && !memcmp (&parent, &dictionary->parent, sizeof (dictionary->parent)))
        pass ();
    else
        fail ("DICTIONARY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_TV* texts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "numitems", &count, NULL)
        && dwg_dynapi_entity_value (dictionary, "DICTIONARY", "texts", &texts, NULL)
        && texts == dictionary->texts)
      pass ();
    else
      fail ("DICTIONARY.texts [TV*] * %u numitems", count);
  }
  if (failed && (is_class_unstable ("DICTIONARY") || is_class_debugging ("DICTIONARY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DICTIONARY", failed);
      failed = 0;
    }
  return failed;
}
static int test_DICTIONARYVAR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DICTIONARYVAR *restrict dictionaryvar = obj->tio.object->tio.DICTIONARYVAR;
  failed = 0;
  {
    BITCODE_RC intval;
    if (dwg_dynapi_entity_value (dictionaryvar, "DICTIONARYVAR", "intval", &intval, NULL)
        && intval == dictionaryvar->intval)
      pass ();
    else
      fail ("DICTIONARYVAR.intval [RC] %u != %u", dictionaryvar->intval, intval);
    intval++;
    if (dwg_dynapi_entity_set_value (dictionaryvar, "DICTIONARYVAR", "intval", &intval, 0)
        && intval == dictionaryvar->intval)
      pass ();
    else
      fail ("DICTIONARYVAR.intval [RC] set+1 %u != %u", dictionaryvar->intval, intval);
    dictionaryvar->intval--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dictionaryvar, "DICTIONARYVAR", "parent", &parent, NULL)
        && !memcmp (&parent, &dictionaryvar->parent, sizeof (dictionaryvar->parent)))
        pass ();
    else
        fail ("DICTIONARYVAR.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T str;
    if (dwg_dynapi_entity_value (dictionaryvar, "DICTIONARYVAR", "str", &str, NULL)
        && str
           ? strEQ ((char *)str, (char *)dictionaryvar->str)
           : !dictionaryvar->str)
      pass ();
    else
      fail ("DICTIONARYVAR.str [T] '%s' <> '%s'", str, dictionaryvar->str);
  }
  if (failed && (is_class_unstable ("DICTIONARYVAR") || is_class_debugging ("DICTIONARYVAR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DICTIONARYVAR", failed);
      failed = 0;
    }
  return failed;
}
static int test_DICTIONARYWDFLT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DICTIONARYWDFLT *restrict dictionarywdflt = obj->tio.object->tio.DICTIONARYWDFLT;
  failed = 0;
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "cloning", &cloning, NULL)
        && cloning == dictionarywdflt->cloning)
      pass ();
    else
      fail ("DICTIONARYWDFLT.cloning [BS] %hu != %hu", dictionarywdflt->cloning, cloning);
    cloning++;
    if (dwg_dynapi_entity_set_value (dictionarywdflt, "DICTIONARYWDFLT", "cloning", &cloning, 0)
        && cloning == dictionarywdflt->cloning)
      pass ();
    else
      fail ("DICTIONARYWDFLT.cloning [BS] set+1 %hu != %hu", dictionarywdflt->cloning, cloning);
    dictionarywdflt->cloning--;
  }
  {
    BITCODE_RL cloning_r14;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "cloning_r14", &cloning_r14, NULL)
        && cloning_r14 == dictionarywdflt->cloning_r14)
      pass ();
    else
      fail ("DICTIONARYWDFLT.cloning_r14 [RL] %u != %u", dictionarywdflt->cloning_r14, cloning_r14);
    cloning_r14++;
    if (dwg_dynapi_entity_set_value (dictionarywdflt, "DICTIONARYWDFLT", "cloning_r14", &cloning_r14, 0)
        && cloning_r14 == dictionarywdflt->cloning_r14)
      pass ();
    else
      fail ("DICTIONARYWDFLT.cloning_r14 [RL] set+1 %u != %u", dictionarywdflt->cloning_r14, cloning_r14);
    dictionarywdflt->cloning_r14--;
  }
  {
    BITCODE_H defaultid;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "defaultid", &defaultid, NULL)
        && !memcmp (&defaultid, &dictionarywdflt->defaultid, sizeof (dictionarywdflt->defaultid)))
        pass ();
    else
        fail ("DICTIONARYWDFLT.defaultid [H]");
  }
  {
    BITCODE_RC hard_owner;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "hard_owner", &hard_owner, NULL)
        && hard_owner == dictionarywdflt->hard_owner)
      pass ();
    else
      fail ("DICTIONARYWDFLT.hard_owner [RC] %u != %u", dictionarywdflt->hard_owner, hard_owner);
    hard_owner++;
    if (dwg_dynapi_entity_set_value (dictionarywdflt, "DICTIONARYWDFLT", "hard_owner", &hard_owner, 0)
        && hard_owner == dictionarywdflt->hard_owner)
      pass ();
    else
      fail ("DICTIONARYWDFLT.hard_owner [RC] set+1 %u != %u", dictionarywdflt->hard_owner, hard_owner);
    dictionarywdflt->hard_owner--;
  }
  {
    BITCODE_H* itemhandles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "numitems", &count, NULL)
        && dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "itemhandles", &itemhandles, NULL)
        && itemhandles == dictionarywdflt->itemhandles)
      pass ();
    else
      fail ("DICTIONARYWDFLT.itemhandles [H*] * %u numitems", count);
  }
  {
    BITCODE_BL numitems;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "numitems", &numitems, NULL)
        && numitems == dictionarywdflt->numitems)
      pass ();
    else
      fail ("DICTIONARYWDFLT.numitems [BL] %u != %u", dictionarywdflt->numitems, numitems);
    numitems++;
    if (dwg_dynapi_entity_set_value (dictionarywdflt, "DICTIONARYWDFLT", "numitems", &numitems, 0)
        && numitems == dictionarywdflt->numitems)
      pass ();
    else
      fail ("DICTIONARYWDFLT.numitems [BL] set+1 %u != %u", dictionarywdflt->numitems, numitems);
    dictionarywdflt->numitems--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "parent", &parent, NULL)
        && !memcmp (&parent, &dictionarywdflt->parent, sizeof (dictionarywdflt->parent)))
        pass ();
    else
        fail ("DICTIONARYWDFLT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_TV* texts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "numitems", &count, NULL)
        && dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "texts", &texts, NULL)
        && texts == dictionarywdflt->texts)
      pass ();
    else
      fail ("DICTIONARYWDFLT.texts [TV*] * %u numitems", count);
  }
  if (failed && (is_class_unstable ("DICTIONARYWDFLT") || is_class_debugging ("DICTIONARYWDFLT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DICTIONARYWDFLT", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMASSOC (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DIMASSOC *restrict dimassoc = obj->tio.object->tio.DIMASSOC;
  failed = 0;
  {
    BITCODE_BL associativity;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "associativity", &associativity, NULL)
        && associativity == dimassoc->associativity)
      pass ();
    else
      fail ("DIMASSOC.associativity [BL] %u != %u", dimassoc->associativity, associativity);
    associativity++;
    if (dwg_dynapi_entity_set_value (dimassoc, "DIMASSOC", "associativity", &associativity, 0)
        && associativity == dimassoc->associativity)
      pass ();
    else
      fail ("DIMASSOC.associativity [BL] set+1 %u != %u", dimassoc->associativity, associativity);
    dimassoc->associativity--;
  }
  {
    BITCODE_BL intsect_gsmarker;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "intsect_gsmarker", &intsect_gsmarker, NULL)
        && intsect_gsmarker == dimassoc->intsect_gsmarker)
      pass ();
    else
      fail ("DIMASSOC.intsect_gsmarker [BL] %u != %u", dimassoc->intsect_gsmarker, intsect_gsmarker);
    intsect_gsmarker++;
    if (dwg_dynapi_entity_set_value (dimassoc, "DIMASSOC", "intsect_gsmarker", &intsect_gsmarker, 0)
        && intsect_gsmarker == dimassoc->intsect_gsmarker)
      pass ();
    else
      fail ("DIMASSOC.intsect_gsmarker [BL] set+1 %u != %u", dimassoc->intsect_gsmarker, intsect_gsmarker);
    dimassoc->intsect_gsmarker--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "parent", &parent, NULL)
        && !memcmp (&parent, &dimassoc->parent, sizeof (dimassoc->parent)))
        pass ();
    else
        fail ("DIMASSOC.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_DIMASSOC_Ref* ref;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "ref", &ref, NULL)
        && !memcmp (&ref, &dimassoc->ref, sizeof (dimassoc->ref)))
        pass ();
    else
        fail ("DIMASSOC.ref [Dwg_DIMASSOC_Ref*]");
  }
  {
    BITCODE_RC trans_space_flag;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "trans_space_flag", &trans_space_flag, NULL)
        && trans_space_flag == dimassoc->trans_space_flag)
      pass ();
    else
      fail ("DIMASSOC.trans_space_flag [RC] %u != %u", dimassoc->trans_space_flag, trans_space_flag);
    trans_space_flag++;
    if (dwg_dynapi_entity_set_value (dimassoc, "DIMASSOC", "trans_space_flag", &trans_space_flag, 0)
        && trans_space_flag == dimassoc->trans_space_flag)
      pass ();
    else
      fail ("DIMASSOC.trans_space_flag [RC] set+1 %u != %u", dimassoc->trans_space_flag, trans_space_flag);
    dimassoc->trans_space_flag--;
  }
  if (failed && (is_class_unstable ("DIMASSOC") || is_class_debugging ("DIMASSOC")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMASSOC", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DIMSTYLE *restrict dimstyle = obj->tio.object->tio.DIMSTYLE;
  failed = 0;
  {
    BITCODE_BS DIMADEC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMADEC", &DIMADEC, NULL)
        && DIMADEC == dimstyle->DIMADEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMADEC [BS] %hu != %hu", dimstyle->DIMADEC, DIMADEC);
    DIMADEC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMADEC", &DIMADEC, 0)
        && DIMADEC == dimstyle->DIMADEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMADEC [BS] set+1 %hu != %hu", dimstyle->DIMADEC, DIMADEC);
    dimstyle->DIMADEC--;
  }
  {
    BITCODE_B DIMALT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALT", &DIMALT, NULL)
        && DIMALT == dimstyle->DIMALT)
      pass ();
    else
      fail ("DIMSTYLE.DIMALT [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMALT, DIMALT);
    DIMALT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALT", &DIMALT, 0)
        && DIMALT == dimstyle->DIMALT)
      pass ();
    else
      fail ("DIMSTYLE.DIMALT [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMALT, DIMALT);
    dimstyle->DIMALT--;
  }
  {
    BITCODE_BS DIMALTD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTD", &DIMALTD, NULL)
        && DIMALTD == dimstyle->DIMALTD)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTD [BS] %hu != %hu", dimstyle->DIMALTD, DIMALTD);
    DIMALTD++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTD", &DIMALTD, 0)
        && DIMALTD == dimstyle->DIMALTD)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTD [BS] set+1 %hu != %hu", dimstyle->DIMALTD, DIMALTD);
    dimstyle->DIMALTD--;
  }
  {
    BITCODE_BD DIMALTF;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTF", &DIMALTF, NULL)
        && DIMALTF == dimstyle->DIMALTF)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTF [BD] %g != %g", dimstyle->DIMALTF, DIMALTF);
    DIMALTF++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTF", &DIMALTF, 0)
        && DIMALTF == dimstyle->DIMALTF)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTF [BD] set+1 %g != %g", dimstyle->DIMALTF, DIMALTF);
    dimstyle->DIMALTF--;
  }
  {
    BITCODE_BD DIMALTMZF;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTMZF", &DIMALTMZF, NULL)
        && DIMALTMZF == dimstyle->DIMALTMZF)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTMZF [BD] %g != %g", dimstyle->DIMALTMZF, DIMALTMZF);
    DIMALTMZF++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTMZF", &DIMALTMZF, 0)
        && DIMALTMZF == dimstyle->DIMALTMZF)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTMZF [BD] set+1 %g != %g", dimstyle->DIMALTMZF, DIMALTMZF);
    dimstyle->DIMALTMZF--;
  }
  {
    BITCODE_T DIMALTMZS;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTMZS", &DIMALTMZS, NULL)
        && DIMALTMZS
           ? strEQ ((char *)DIMALTMZS, (char *)dimstyle->DIMALTMZS)
           : !dimstyle->DIMALTMZS)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTMZS [T] '%s' <> '%s'", DIMALTMZS, dimstyle->DIMALTMZS);
  }
  {
    BITCODE_BD DIMALTRND;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTRND", &DIMALTRND, NULL)
        && DIMALTRND == dimstyle->DIMALTRND)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTRND [BD] %g != %g", dimstyle->DIMALTRND, DIMALTRND);
    DIMALTRND++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTRND", &DIMALTRND, 0)
        && DIMALTRND == dimstyle->DIMALTRND)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTRND [BD] set+1 %g != %g", dimstyle->DIMALTRND, DIMALTRND);
    dimstyle->DIMALTRND--;
  }
  {
    BITCODE_BS DIMALTTD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTTD", &DIMALTTD, NULL)
        && DIMALTTD == dimstyle->DIMALTTD)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTTD [BS] %hu != %hu", dimstyle->DIMALTTD, DIMALTTD);
    DIMALTTD++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTTD", &DIMALTTD, 0)
        && DIMALTTD == dimstyle->DIMALTTD)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTTD [BS] set+1 %hu != %hu", dimstyle->DIMALTTD, DIMALTTD);
    dimstyle->DIMALTTD--;
  }
  {
    BITCODE_BS DIMALTTZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTTZ", &DIMALTTZ, NULL)
        && DIMALTTZ == dimstyle->DIMALTTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTTZ [BS] %hu != %hu", dimstyle->DIMALTTZ, DIMALTTZ);
    DIMALTTZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTTZ", &DIMALTTZ, 0)
        && DIMALTTZ == dimstyle->DIMALTTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTTZ [BS] set+1 %hu != %hu", dimstyle->DIMALTTZ, DIMALTTZ);
    dimstyle->DIMALTTZ--;
  }
  {
    BITCODE_BS DIMALTU;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTU", &DIMALTU, NULL)
        && DIMALTU == dimstyle->DIMALTU)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTU [BS] %hu != %hu", dimstyle->DIMALTU, DIMALTU);
    DIMALTU++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTU", &DIMALTU, 0)
        && DIMALTU == dimstyle->DIMALTU)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTU [BS] set+1 %hu != %hu", dimstyle->DIMALTU, DIMALTU);
    dimstyle->DIMALTU--;
  }
  {
    BITCODE_BS DIMALTZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTZ", &DIMALTZ, NULL)
        && DIMALTZ == dimstyle->DIMALTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTZ [BS] %hu != %hu", dimstyle->DIMALTZ, DIMALTZ);
    DIMALTZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTZ", &DIMALTZ, 0)
        && DIMALTZ == dimstyle->DIMALTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTZ [BS] set+1 %hu != %hu", dimstyle->DIMALTZ, DIMALTZ);
    dimstyle->DIMALTZ--;
  }
  {
    BITCODE_T DIMAPOST;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMAPOST", &DIMAPOST, NULL)
        && DIMAPOST
           ? strEQ ((char *)DIMAPOST, (char *)dimstyle->DIMAPOST)
           : !dimstyle->DIMAPOST)
      pass ();
    else
      fail ("DIMSTYLE.DIMAPOST [T] '%s' <> '%s'", DIMAPOST, dimstyle->DIMAPOST);
  }
  {
    BITCODE_BS DIMARCSYM;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMARCSYM", &DIMARCSYM, NULL)
        && DIMARCSYM == dimstyle->DIMARCSYM)
      pass ();
    else
      fail ("DIMSTYLE.DIMARCSYM [BS] %hu != %hu", dimstyle->DIMARCSYM, DIMARCSYM);
    DIMARCSYM++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMARCSYM", &DIMARCSYM, 0)
        && DIMARCSYM == dimstyle->DIMARCSYM)
      pass ();
    else
      fail ("DIMSTYLE.DIMARCSYM [BS] set+1 %hu != %hu", dimstyle->DIMARCSYM, DIMARCSYM);
    dimstyle->DIMARCSYM--;
  }
  {
    BITCODE_BD DIMASZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMASZ", &DIMASZ, NULL)
        && DIMASZ == dimstyle->DIMASZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMASZ [BD] %g != %g", dimstyle->DIMASZ, DIMASZ);
    DIMASZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMASZ", &DIMASZ, 0)
        && DIMASZ == dimstyle->DIMASZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMASZ [BD] set+1 %g != %g", dimstyle->DIMASZ, DIMASZ);
    dimstyle->DIMASZ--;
  }
  {
    BITCODE_BS DIMATFIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMATFIT", &DIMATFIT, NULL)
        && DIMATFIT == dimstyle->DIMATFIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMATFIT [BS] %hu != %hu", dimstyle->DIMATFIT, DIMATFIT);
    DIMATFIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMATFIT", &DIMATFIT, 0)
        && DIMATFIT == dimstyle->DIMATFIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMATFIT [BS] set+1 %hu != %hu", dimstyle->DIMATFIT, DIMATFIT);
    dimstyle->DIMATFIT--;
  }
  {
    BITCODE_BS DIMAUNIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMAUNIT", &DIMAUNIT, NULL)
        && DIMAUNIT == dimstyle->DIMAUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMAUNIT [BS] %hu != %hu", dimstyle->DIMAUNIT, DIMAUNIT);
    DIMAUNIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMAUNIT", &DIMAUNIT, 0)
        && DIMAUNIT == dimstyle->DIMAUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMAUNIT [BS] set+1 %hu != %hu", dimstyle->DIMAUNIT, DIMAUNIT);
    dimstyle->DIMAUNIT--;
  }
  {
    BITCODE_BS DIMAZIN;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMAZIN", &DIMAZIN, NULL)
        && DIMAZIN == dimstyle->DIMAZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMAZIN [BS] %hu != %hu", dimstyle->DIMAZIN, DIMAZIN);
    DIMAZIN++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMAZIN", &DIMAZIN, 0)
        && DIMAZIN == dimstyle->DIMAZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMAZIN [BS] set+1 %hu != %hu", dimstyle->DIMAZIN, DIMAZIN);
    dimstyle->DIMAZIN--;
  }
  {
    BITCODE_H DIMBLK;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK", &DIMBLK, NULL)
        && !memcmp (&DIMBLK, &dimstyle->DIMBLK, sizeof (dimstyle->DIMBLK)))
        pass ();
    else
        fail ("DIMSTYLE.DIMBLK [H]");
  }
  {
    BITCODE_H DIMBLK1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK1", &DIMBLK1, NULL)
        && !memcmp (&DIMBLK1, &dimstyle->DIMBLK1, sizeof (dimstyle->DIMBLK1)))
        pass ();
    else
        fail ("DIMSTYLE.DIMBLK1 [H]");
  }
  {
    BITCODE_TV DIMBLK1_T;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK1_T", &DIMBLK1_T, NULL)
        && DIMBLK1_T
           ? strEQ ((char *)DIMBLK1_T, (char *)dimstyle->DIMBLK1_T)
           : !dimstyle->DIMBLK1_T)
      pass ();
    else
      fail ("DIMSTYLE.DIMBLK1_T [TV] '%s' <> '%s'", DIMBLK1_T, dimstyle->DIMBLK1_T);
  }
  {
    BITCODE_H DIMBLK2;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK2", &DIMBLK2, NULL)
        && !memcmp (&DIMBLK2, &dimstyle->DIMBLK2, sizeof (dimstyle->DIMBLK2)))
        pass ();
    else
        fail ("DIMSTYLE.DIMBLK2 [H]");
  }
  {
    BITCODE_TV DIMBLK2_T;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK2_T", &DIMBLK2_T, NULL)
        && DIMBLK2_T
           ? strEQ ((char *)DIMBLK2_T, (char *)dimstyle->DIMBLK2_T)
           : !dimstyle->DIMBLK2_T)
      pass ();
    else
      fail ("DIMSTYLE.DIMBLK2_T [TV] '%s' <> '%s'", DIMBLK2_T, dimstyle->DIMBLK2_T);
  }
  {
    BITCODE_TV DIMBLK_T;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK_T", &DIMBLK_T, NULL)
        && DIMBLK_T
           ? strEQ ((char *)DIMBLK_T, (char *)dimstyle->DIMBLK_T)
           : !dimstyle->DIMBLK_T)
      pass ();
    else
      fail ("DIMSTYLE.DIMBLK_T [TV] '%s' <> '%s'", DIMBLK_T, dimstyle->DIMBLK_T);
  }
  {
    BITCODE_BD DIMCEN;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCEN", &DIMCEN, NULL)
        && DIMCEN == dimstyle->DIMCEN)
      pass ();
    else
      fail ("DIMSTYLE.DIMCEN [BD] %g != %g", dimstyle->DIMCEN, DIMCEN);
    DIMCEN++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMCEN", &DIMCEN, 0)
        && DIMCEN == dimstyle->DIMCEN)
      pass ();
    else
      fail ("DIMSTYLE.DIMCEN [BD] set+1 %g != %g", dimstyle->DIMCEN, DIMCEN);
    dimstyle->DIMCEN--;
  }
  {
    BITCODE_CMC DIMCLRD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRD", &DIMCLRD, NULL)
        && !memcmp (&DIMCLRD, &dimstyle->DIMCLRD, sizeof (dimstyle->DIMCLRD)))
        pass ();
    else
        fail ("DIMSTYLE.DIMCLRD [CMC]");
  }
  {
    BITCODE_RS DIMCLRD_N;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRD_N", &DIMCLRD_N, NULL)
        && DIMCLRD_N == dimstyle->DIMCLRD_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRD_N [RS] %hu != %hu", dimstyle->DIMCLRD_N, DIMCLRD_N);
    DIMCLRD_N++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMCLRD_N", &DIMCLRD_N, 0)
        && DIMCLRD_N == dimstyle->DIMCLRD_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRD_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRD_N, DIMCLRD_N);
    dimstyle->DIMCLRD_N--;
  }
  {
    BITCODE_CMC DIMCLRE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRE", &DIMCLRE, NULL)
        && !memcmp (&DIMCLRE, &dimstyle->DIMCLRE, sizeof (dimstyle->DIMCLRE)))
        pass ();
    else
        fail ("DIMSTYLE.DIMCLRE [CMC]");
  }
  {
    BITCODE_RS DIMCLRE_N;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRE_N", &DIMCLRE_N, NULL)
        && DIMCLRE_N == dimstyle->DIMCLRE_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRE_N [RS] %hu != %hu", dimstyle->DIMCLRE_N, DIMCLRE_N);
    DIMCLRE_N++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMCLRE_N", &DIMCLRE_N, 0)
        && DIMCLRE_N == dimstyle->DIMCLRE_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRE_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRE_N, DIMCLRE_N);
    dimstyle->DIMCLRE_N--;
  }
  {
    BITCODE_CMC DIMCLRT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRT", &DIMCLRT, NULL)
        && !memcmp (&DIMCLRT, &dimstyle->DIMCLRT, sizeof (dimstyle->DIMCLRT)))
        pass ();
    else
        fail ("DIMSTYLE.DIMCLRT [CMC]");
  }
  {
    BITCODE_RS DIMCLRT_N;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRT_N", &DIMCLRT_N, NULL)
        && DIMCLRT_N == dimstyle->DIMCLRT_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRT_N [RS] %hu != %hu", dimstyle->DIMCLRT_N, DIMCLRT_N);
    DIMCLRT_N++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMCLRT_N", &DIMCLRT_N, 0)
        && DIMCLRT_N == dimstyle->DIMCLRT_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRT_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRT_N, DIMCLRT_N);
    dimstyle->DIMCLRT_N--;
  }
  {
    BITCODE_BS DIMDEC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMDEC", &DIMDEC, NULL)
        && DIMDEC == dimstyle->DIMDEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMDEC [BS] %hu != %hu", dimstyle->DIMDEC, DIMDEC);
    DIMDEC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMDEC", &DIMDEC, 0)
        && DIMDEC == dimstyle->DIMDEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMDEC [BS] set+1 %hu != %hu", dimstyle->DIMDEC, DIMDEC);
    dimstyle->DIMDEC--;
  }
  {
    BITCODE_BD DIMDLE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMDLE", &DIMDLE, NULL)
        && DIMDLE == dimstyle->DIMDLE)
      pass ();
    else
      fail ("DIMSTYLE.DIMDLE [BD] %g != %g", dimstyle->DIMDLE, DIMDLE);
    DIMDLE++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMDLE", &DIMDLE, 0)
        && DIMDLE == dimstyle->DIMDLE)
      pass ();
    else
      fail ("DIMSTYLE.DIMDLE [BD] set+1 %g != %g", dimstyle->DIMDLE, DIMDLE);
    dimstyle->DIMDLE--;
  }
  {
    BITCODE_BD DIMDLI;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMDLI", &DIMDLI, NULL)
        && DIMDLI == dimstyle->DIMDLI)
      pass ();
    else
      fail ("DIMSTYLE.DIMDLI [BD] %g != %g", dimstyle->DIMDLI, DIMDLI);
    DIMDLI++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMDLI", &DIMDLI, 0)
        && DIMDLI == dimstyle->DIMDLI)
      pass ();
    else
      fail ("DIMSTYLE.DIMDLI [BD] set+1 %g != %g", dimstyle->DIMDLI, DIMDLI);
    dimstyle->DIMDLI--;
  }
  {
    BITCODE_BS DIMDSEP;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMDSEP", &DIMDSEP, NULL)
        && DIMDSEP == dimstyle->DIMDSEP)
      pass ();
    else
      fail ("DIMSTYLE.DIMDSEP [BS] %hu != %hu", dimstyle->DIMDSEP, DIMDSEP);
    DIMDSEP++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMDSEP", &DIMDSEP, 0)
        && DIMDSEP == dimstyle->DIMDSEP)
      pass ();
    else
      fail ("DIMSTYLE.DIMDSEP [BS] set+1 %hu != %hu", dimstyle->DIMDSEP, DIMDSEP);
    dimstyle->DIMDSEP--;
  }
  {
    BITCODE_BD DIMEXE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMEXE", &DIMEXE, NULL)
        && DIMEXE == dimstyle->DIMEXE)
      pass ();
    else
      fail ("DIMSTYLE.DIMEXE [BD] %g != %g", dimstyle->DIMEXE, DIMEXE);
    DIMEXE++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMEXE", &DIMEXE, 0)
        && DIMEXE == dimstyle->DIMEXE)
      pass ();
    else
      fail ("DIMSTYLE.DIMEXE [BD] set+1 %g != %g", dimstyle->DIMEXE, DIMEXE);
    dimstyle->DIMEXE--;
  }
  {
    BITCODE_BD DIMEXO;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMEXO", &DIMEXO, NULL)
        && DIMEXO == dimstyle->DIMEXO)
      pass ();
    else
      fail ("DIMSTYLE.DIMEXO [BD] %g != %g", dimstyle->DIMEXO, DIMEXO);
    DIMEXO++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMEXO", &DIMEXO, 0)
        && DIMEXO == dimstyle->DIMEXO)
      pass ();
    else
      fail ("DIMSTYLE.DIMEXO [BD] set+1 %g != %g", dimstyle->DIMEXO, DIMEXO);
    dimstyle->DIMEXO--;
  }
  {
    BITCODE_BS DIMFIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMFIT", &DIMFIT, NULL)
        && DIMFIT == dimstyle->DIMFIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMFIT [BS] %hu != %hu", dimstyle->DIMFIT, DIMFIT);
    DIMFIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMFIT", &DIMFIT, 0)
        && DIMFIT == dimstyle->DIMFIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMFIT [BS] set+1 %hu != %hu", dimstyle->DIMFIT, DIMFIT);
    dimstyle->DIMFIT--;
  }
  {
    BITCODE_BS DIMFRAC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMFRAC", &DIMFRAC, NULL)
        && DIMFRAC == dimstyle->DIMFRAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMFRAC [BS] %hu != %hu", dimstyle->DIMFRAC, DIMFRAC);
    DIMFRAC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMFRAC", &DIMFRAC, 0)
        && DIMFRAC == dimstyle->DIMFRAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMFRAC [BS] set+1 %hu != %hu", dimstyle->DIMFRAC, DIMFRAC);
    dimstyle->DIMFRAC--;
  }
  {
    BITCODE_BD DIMFXL;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMFXL", &DIMFXL, NULL)
        && DIMFXL == dimstyle->DIMFXL)
      pass ();
    else
      fail ("DIMSTYLE.DIMFXL [BD] %g != %g", dimstyle->DIMFXL, DIMFXL);
    DIMFXL++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMFXL", &DIMFXL, 0)
        && DIMFXL == dimstyle->DIMFXL)
      pass ();
    else
      fail ("DIMSTYLE.DIMFXL [BD] set+1 %g != %g", dimstyle->DIMFXL, DIMFXL);
    dimstyle->DIMFXL--;
  }
  {
    BITCODE_B DIMFXLON;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMFXLON", &DIMFXLON, NULL)
        && DIMFXLON == dimstyle->DIMFXLON)
      pass ();
    else
      fail ("DIMSTYLE.DIMFXLON [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMFXLON, DIMFXLON);
    DIMFXLON++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMFXLON", &DIMFXLON, 0)
        && DIMFXLON == dimstyle->DIMFXLON)
      pass ();
    else
      fail ("DIMSTYLE.DIMFXLON [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMFXLON, DIMFXLON);
    dimstyle->DIMFXLON--;
  }
  {
    BITCODE_BD DIMGAP;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMGAP", &DIMGAP, NULL)
        && DIMGAP == dimstyle->DIMGAP)
      pass ();
    else
      fail ("DIMSTYLE.DIMGAP [BD] %g != %g", dimstyle->DIMGAP, DIMGAP);
    DIMGAP++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMGAP", &DIMGAP, 0)
        && DIMGAP == dimstyle->DIMGAP)
      pass ();
    else
      fail ("DIMSTYLE.DIMGAP [BD] set+1 %g != %g", dimstyle->DIMGAP, DIMGAP);
    dimstyle->DIMGAP--;
  }
  {
    BITCODE_BD DIMJOGANG;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMJOGANG", &DIMJOGANG, NULL)
        && DIMJOGANG == dimstyle->DIMJOGANG)
      pass ();
    else
      fail ("DIMSTYLE.DIMJOGANG [BD] %g != %g", dimstyle->DIMJOGANG, DIMJOGANG);
    DIMJOGANG++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMJOGANG", &DIMJOGANG, 0)
        && DIMJOGANG == dimstyle->DIMJOGANG)
      pass ();
    else
      fail ("DIMSTYLE.DIMJOGANG [BD] set+1 %g != %g", dimstyle->DIMJOGANG, DIMJOGANG);
    dimstyle->DIMJOGANG--;
  }
  {
    BITCODE_BS DIMJUST;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMJUST", &DIMJUST, NULL)
        && DIMJUST == dimstyle->DIMJUST)
      pass ();
    else
      fail ("DIMSTYLE.DIMJUST [BS] %hu != %hu", dimstyle->DIMJUST, DIMJUST);
    DIMJUST++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMJUST", &DIMJUST, 0)
        && DIMJUST == dimstyle->DIMJUST)
      pass ();
    else
      fail ("DIMSTYLE.DIMJUST [BS] set+1 %hu != %hu", dimstyle->DIMJUST, DIMJUST);
    dimstyle->DIMJUST--;
  }
  {
    BITCODE_H DIMLDRBLK;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLDRBLK", &DIMLDRBLK, NULL)
        && !memcmp (&DIMLDRBLK, &dimstyle->DIMLDRBLK, sizeof (dimstyle->DIMLDRBLK)))
        pass ();
    else
        fail ("DIMSTYLE.DIMLDRBLK [H]");
  }
  {
    BITCODE_BD DIMLFAC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLFAC", &DIMLFAC, NULL)
        && DIMLFAC == dimstyle->DIMLFAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMLFAC [BD] %g != %g", dimstyle->DIMLFAC, DIMLFAC);
    DIMLFAC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLFAC", &DIMLFAC, 0)
        && DIMLFAC == dimstyle->DIMLFAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMLFAC [BD] set+1 %g != %g", dimstyle->DIMLFAC, DIMLFAC);
    dimstyle->DIMLFAC--;
  }
  {
    BITCODE_B DIMLIM;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLIM", &DIMLIM, NULL)
        && DIMLIM == dimstyle->DIMLIM)
      pass ();
    else
      fail ("DIMSTYLE.DIMLIM [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMLIM, DIMLIM);
    DIMLIM++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLIM", &DIMLIM, 0)
        && DIMLIM == dimstyle->DIMLIM)
      pass ();
    else
      fail ("DIMSTYLE.DIMLIM [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMLIM, DIMLIM);
    dimstyle->DIMLIM--;
  }
  {
    BITCODE_H DIMLTEX1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLTEX1", &DIMLTEX1, NULL)
        && !memcmp (&DIMLTEX1, &dimstyle->DIMLTEX1, sizeof (dimstyle->DIMLTEX1)))
        pass ();
    else
        fail ("DIMSTYLE.DIMLTEX1 [H]");
  }
  {
    BITCODE_H DIMLTEX2;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLTEX2", &DIMLTEX2, NULL)
        && !memcmp (&DIMLTEX2, &dimstyle->DIMLTEX2, sizeof (dimstyle->DIMLTEX2)))
        pass ();
    else
        fail ("DIMSTYLE.DIMLTEX2 [H]");
  }
  {
    BITCODE_H DIMLTYPE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLTYPE", &DIMLTYPE, NULL)
        && !memcmp (&DIMLTYPE, &dimstyle->DIMLTYPE, sizeof (dimstyle->DIMLTYPE)))
        pass ();
    else
        fail ("DIMSTYLE.DIMLTYPE [H]");
  }
  {
    BITCODE_BS DIMLUNIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLUNIT", &DIMLUNIT, NULL)
        && DIMLUNIT == dimstyle->DIMLUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMLUNIT [BS] %hu != %hu", dimstyle->DIMLUNIT, DIMLUNIT);
    DIMLUNIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLUNIT", &DIMLUNIT, 0)
        && DIMLUNIT == dimstyle->DIMLUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMLUNIT [BS] set+1 %hu != %hu", dimstyle->DIMLUNIT, DIMLUNIT);
    dimstyle->DIMLUNIT--;
  }
  {
    BITCODE_BSd DIMLWD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLWD", &DIMLWD, NULL)
        && DIMLWD == dimstyle->DIMLWD)
      pass ();
    else
      fail ("DIMSTYLE.DIMLWD [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dimstyle->DIMLWD, DIMLWD);
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLWD", &DIMLWD, 0)
        && DIMLWD == dimstyle->DIMLWD)
      pass ();
    else
      fail ("DIMSTYLE.DIMLWD [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "", dimstyle->DIMLWD, DIMLWD);
    dimstyle->DIMLWD--;
  }
  {
    BITCODE_BSd DIMLWE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLWE", &DIMLWE, NULL)
        && DIMLWE == dimstyle->DIMLWE)
      pass ();
    else
      fail ("DIMSTYLE.DIMLWE [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dimstyle->DIMLWE, DIMLWE);
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLWE", &DIMLWE, 0)
        && DIMLWE == dimstyle->DIMLWE)
      pass ();
    else
      fail ("DIMSTYLE.DIMLWE [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "", dimstyle->DIMLWE, DIMLWE);
    dimstyle->DIMLWE--;
  }
  {
    BITCODE_BS DIMMALTTZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMMALTTZ", &DIMMALTTZ, NULL)
        && DIMMALTTZ == dimstyle->DIMMALTTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMMALTTZ [BS] %hu != %hu", dimstyle->DIMMALTTZ, DIMMALTTZ);
    DIMMALTTZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMMALTTZ", &DIMMALTTZ, 0)
        && DIMMALTTZ == dimstyle->DIMMALTTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMMALTTZ [BS] set+1 %hu != %hu", dimstyle->DIMMALTTZ, DIMMALTTZ);
    dimstyle->DIMMALTTZ--;
  }
  {
    BITCODE_BS DIMMALTZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMMALTZ", &DIMMALTZ, NULL)
        && DIMMALTZ == dimstyle->DIMMALTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMMALTZ [BS] %hu != %hu", dimstyle->DIMMALTZ, DIMMALTZ);
    DIMMALTZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMMALTZ", &DIMMALTZ, 0)
        && DIMMALTZ == dimstyle->DIMMALTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMMALTZ [BS] set+1 %hu != %hu", dimstyle->DIMMALTZ, DIMMALTZ);
    dimstyle->DIMMALTZ--;
  }
  {
    BITCODE_BD DIMMZF;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMMZF", &DIMMZF, NULL)
        && DIMMZF == dimstyle->DIMMZF)
      pass ();
    else
      fail ("DIMSTYLE.DIMMZF [BD] %g != %g", dimstyle->DIMMZF, DIMMZF);
    DIMMZF++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMMZF", &DIMMZF, 0)
        && DIMMZF == dimstyle->DIMMZF)
      pass ();
    else
      fail ("DIMSTYLE.DIMMZF [BD] set+1 %g != %g", dimstyle->DIMMZF, DIMMZF);
    dimstyle->DIMMZF--;
  }
  {
    BITCODE_T DIMMZS;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMMZS", &DIMMZS, NULL)
        && DIMMZS
           ? strEQ ((char *)DIMMZS, (char *)dimstyle->DIMMZS)
           : !dimstyle->DIMMZS)
      pass ();
    else
      fail ("DIMSTYLE.DIMMZS [T] '%s' <> '%s'", DIMMZS, dimstyle->DIMMZS);
  }
  {
    BITCODE_T DIMPOST;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMPOST", &DIMPOST, NULL)
        && DIMPOST
           ? strEQ ((char *)DIMPOST, (char *)dimstyle->DIMPOST)
           : !dimstyle->DIMPOST)
      pass ();
    else
      fail ("DIMSTYLE.DIMPOST [T] '%s' <> '%s'", DIMPOST, dimstyle->DIMPOST);
  }
  {
    BITCODE_BD DIMRND;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMRND", &DIMRND, NULL)
        && DIMRND == dimstyle->DIMRND)
      pass ();
    else
      fail ("DIMSTYLE.DIMRND [BD] %g != %g", dimstyle->DIMRND, DIMRND);
    DIMRND++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMRND", &DIMRND, 0)
        && DIMRND == dimstyle->DIMRND)
      pass ();
    else
      fail ("DIMSTYLE.DIMRND [BD] set+1 %g != %g", dimstyle->DIMRND, DIMRND);
    dimstyle->DIMRND--;
  }
  {
    BITCODE_B DIMSAH;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSAH", &DIMSAH, NULL)
        && DIMSAH == dimstyle->DIMSAH)
      pass ();
    else
      fail ("DIMSTYLE.DIMSAH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSAH, DIMSAH);
    DIMSAH++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSAH", &DIMSAH, 0)
        && DIMSAH == dimstyle->DIMSAH)
      pass ();
    else
      fail ("DIMSTYLE.DIMSAH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSAH, DIMSAH);
    dimstyle->DIMSAH--;
  }
  {
    BITCODE_BD DIMSCALE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSCALE", &DIMSCALE, NULL)
        && DIMSCALE == dimstyle->DIMSCALE)
      pass ();
    else
      fail ("DIMSTYLE.DIMSCALE [BD] %g != %g", dimstyle->DIMSCALE, DIMSCALE);
    DIMSCALE++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSCALE", &DIMSCALE, 0)
        && DIMSCALE == dimstyle->DIMSCALE)
      pass ();
    else
      fail ("DIMSTYLE.DIMSCALE [BD] set+1 %g != %g", dimstyle->DIMSCALE, DIMSCALE);
    dimstyle->DIMSCALE--;
  }
  {
    BITCODE_B DIMSD1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSD1", &DIMSD1, NULL)
        && DIMSD1 == dimstyle->DIMSD1)
      pass ();
    else
      fail ("DIMSTYLE.DIMSD1 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD1, DIMSD1);
    DIMSD1++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSD1", &DIMSD1, 0)
        && DIMSD1 == dimstyle->DIMSD1)
      pass ();
    else
      fail ("DIMSTYLE.DIMSD1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD1, DIMSD1);
    dimstyle->DIMSD1--;
  }
  {
    BITCODE_B DIMSD2;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSD2", &DIMSD2, NULL)
        && DIMSD2 == dimstyle->DIMSD2)
      pass ();
    else
      fail ("DIMSTYLE.DIMSD2 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD2, DIMSD2);
    DIMSD2++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSD2", &DIMSD2, 0)
        && DIMSD2 == dimstyle->DIMSD2)
      pass ();
    else
      fail ("DIMSTYLE.DIMSD2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD2, DIMSD2);
    dimstyle->DIMSD2--;
  }
  {
    BITCODE_B DIMSE1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSE1", &DIMSE1, NULL)
        && DIMSE1 == dimstyle->DIMSE1)
      pass ();
    else
      fail ("DIMSTYLE.DIMSE1 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE1, DIMSE1);
    DIMSE1++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSE1", &DIMSE1, 0)
        && DIMSE1 == dimstyle->DIMSE1)
      pass ();
    else
      fail ("DIMSTYLE.DIMSE1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE1, DIMSE1);
    dimstyle->DIMSE1--;
  }
  {
    BITCODE_B DIMSE2;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSE2", &DIMSE2, NULL)
        && DIMSE2 == dimstyle->DIMSE2)
      pass ();
    else
      fail ("DIMSTYLE.DIMSE2 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE2, DIMSE2);
    DIMSE2++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSE2", &DIMSE2, 0)
        && DIMSE2 == dimstyle->DIMSE2)
      pass ();
    else
      fail ("DIMSTYLE.DIMSE2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE2, DIMSE2);
    dimstyle->DIMSE2--;
  }
  {
    BITCODE_B DIMSOXD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSOXD", &DIMSOXD, NULL)
        && DIMSOXD == dimstyle->DIMSOXD)
      pass ();
    else
      fail ("DIMSTYLE.DIMSOXD [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSOXD, DIMSOXD);
    DIMSOXD++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSOXD", &DIMSOXD, 0)
        && DIMSOXD == dimstyle->DIMSOXD)
      pass ();
    else
      fail ("DIMSTYLE.DIMSOXD [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSOXD, DIMSOXD);
    dimstyle->DIMSOXD--;
  }
  {
    BITCODE_BS DIMTAD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTAD", &DIMTAD, NULL)
        && DIMTAD == dimstyle->DIMTAD)
      pass ();
    else
      fail ("DIMSTYLE.DIMTAD [BS] %hu != %hu", dimstyle->DIMTAD, DIMTAD);
    DIMTAD++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTAD", &DIMTAD, 0)
        && DIMTAD == dimstyle->DIMTAD)
      pass ();
    else
      fail ("DIMSTYLE.DIMTAD [BS] set+1 %hu != %hu", dimstyle->DIMTAD, DIMTAD);
    dimstyle->DIMTAD--;
  }
  {
    BITCODE_BS DIMTDEC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTDEC", &DIMTDEC, NULL)
        && DIMTDEC == dimstyle->DIMTDEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMTDEC [BS] %hu != %hu", dimstyle->DIMTDEC, DIMTDEC);
    DIMTDEC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTDEC", &DIMTDEC, 0)
        && DIMTDEC == dimstyle->DIMTDEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMTDEC [BS] set+1 %hu != %hu", dimstyle->DIMTDEC, DIMTDEC);
    dimstyle->DIMTDEC--;
  }
  {
    BITCODE_BD DIMTFAC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTFAC", &DIMTFAC, NULL)
        && DIMTFAC == dimstyle->DIMTFAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMTFAC [BD] %g != %g", dimstyle->DIMTFAC, DIMTFAC);
    DIMTFAC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTFAC", &DIMTFAC, 0)
        && DIMTFAC == dimstyle->DIMTFAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMTFAC [BD] set+1 %g != %g", dimstyle->DIMTFAC, DIMTFAC);
    dimstyle->DIMTFAC--;
  }
  {
    BITCODE_BS DIMTFILL;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTFILL", &DIMTFILL, NULL)
        && DIMTFILL == dimstyle->DIMTFILL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTFILL [BS] %hu != %hu", dimstyle->DIMTFILL, DIMTFILL);
    DIMTFILL++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTFILL", &DIMTFILL, 0)
        && DIMTFILL == dimstyle->DIMTFILL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTFILL [BS] set+1 %hu != %hu", dimstyle->DIMTFILL, DIMTFILL);
    dimstyle->DIMTFILL--;
  }
  {
    BITCODE_CMC DIMTFILLCLR;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTFILLCLR", &DIMTFILLCLR, NULL)
        && !memcmp (&DIMTFILLCLR, &dimstyle->DIMTFILLCLR, sizeof (dimstyle->DIMTFILLCLR)))
        pass ();
    else
        fail ("DIMSTYLE.DIMTFILLCLR [CMC]");
  }
  {
    BITCODE_B DIMTIH;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTIH", &DIMTIH, NULL)
        && DIMTIH == dimstyle->DIMTIH)
      pass ();
    else
      fail ("DIMSTYLE.DIMTIH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIH, DIMTIH);
    DIMTIH++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTIH", &DIMTIH, 0)
        && DIMTIH == dimstyle->DIMTIH)
      pass ();
    else
      fail ("DIMSTYLE.DIMTIH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIH, DIMTIH);
    dimstyle->DIMTIH--;
  }
  {
    BITCODE_B DIMTIX;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTIX", &DIMTIX, NULL)
        && DIMTIX == dimstyle->DIMTIX)
      pass ();
    else
      fail ("DIMSTYLE.DIMTIX [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIX, DIMTIX);
    DIMTIX++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTIX", &DIMTIX, 0)
        && DIMTIX == dimstyle->DIMTIX)
      pass ();
    else
      fail ("DIMSTYLE.DIMTIX [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIX, DIMTIX);
    dimstyle->DIMTIX--;
  }
  {
    BITCODE_BD DIMTM;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTM", &DIMTM, NULL)
        && DIMTM == dimstyle->DIMTM)
      pass ();
    else
      fail ("DIMSTYLE.DIMTM [BD] %g != %g", dimstyle->DIMTM, DIMTM);
    DIMTM++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTM", &DIMTM, 0)
        && DIMTM == dimstyle->DIMTM)
      pass ();
    else
      fail ("DIMSTYLE.DIMTM [BD] set+1 %g != %g", dimstyle->DIMTM, DIMTM);
    dimstyle->DIMTM--;
  }
  {
    BITCODE_BS DIMTMOVE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTMOVE", &DIMTMOVE, NULL)
        && DIMTMOVE == dimstyle->DIMTMOVE)
      pass ();
    else
      fail ("DIMSTYLE.DIMTMOVE [BS] %hu != %hu", dimstyle->DIMTMOVE, DIMTMOVE);
    DIMTMOVE++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTMOVE", &DIMTMOVE, 0)
        && DIMTMOVE == dimstyle->DIMTMOVE)
      pass ();
    else
      fail ("DIMSTYLE.DIMTMOVE [BS] set+1 %hu != %hu", dimstyle->DIMTMOVE, DIMTMOVE);
    dimstyle->DIMTMOVE--;
  }
  {
    BITCODE_B DIMTOFL;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTOFL", &DIMTOFL, NULL)
        && DIMTOFL == dimstyle->DIMTOFL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOFL [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOFL, DIMTOFL);
    DIMTOFL++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTOFL", &DIMTOFL, 0)
        && DIMTOFL == dimstyle->DIMTOFL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOFL [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOFL, DIMTOFL);
    dimstyle->DIMTOFL--;
  }
  {
    BITCODE_B DIMTOH;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTOH", &DIMTOH, NULL)
        && DIMTOH == dimstyle->DIMTOH)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOH, DIMTOH);
    DIMTOH++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTOH", &DIMTOH, 0)
        && DIMTOH == dimstyle->DIMTOH)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOH, DIMTOH);
    dimstyle->DIMTOH--;
  }
  {
    BITCODE_B DIMTOL;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTOL", &DIMTOL, NULL)
        && DIMTOL == dimstyle->DIMTOL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOL [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOL, DIMTOL);
    DIMTOL++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTOL", &DIMTOL, 0)
        && DIMTOL == dimstyle->DIMTOL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOL [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOL, DIMTOL);
    dimstyle->DIMTOL--;
  }
  {
    BITCODE_BS DIMTOLJ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTOLJ", &DIMTOLJ, NULL)
        && DIMTOLJ == dimstyle->DIMTOLJ)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOLJ [BS] %hu != %hu", dimstyle->DIMTOLJ, DIMTOLJ);
    DIMTOLJ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTOLJ", &DIMTOLJ, 0)
        && DIMTOLJ == dimstyle->DIMTOLJ)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOLJ [BS] set+1 %hu != %hu", dimstyle->DIMTOLJ, DIMTOLJ);
    dimstyle->DIMTOLJ--;
  }
  {
    BITCODE_BD DIMTP;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTP", &DIMTP, NULL)
        && DIMTP == dimstyle->DIMTP)
      pass ();
    else
      fail ("DIMSTYLE.DIMTP [BD] %g != %g", dimstyle->DIMTP, DIMTP);
    DIMTP++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTP", &DIMTP, 0)
        && DIMTP == dimstyle->DIMTP)
      pass ();
    else
      fail ("DIMSTYLE.DIMTP [BD] set+1 %g != %g", dimstyle->DIMTP, DIMTP);
    dimstyle->DIMTP--;
  }
  {
    BITCODE_BD DIMTSZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTSZ", &DIMTSZ, NULL)
        && DIMTSZ == dimstyle->DIMTSZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMTSZ [BD] %g != %g", dimstyle->DIMTSZ, DIMTSZ);
    DIMTSZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTSZ", &DIMTSZ, 0)
        && DIMTSZ == dimstyle->DIMTSZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMTSZ [BD] set+1 %g != %g", dimstyle->DIMTSZ, DIMTSZ);
    dimstyle->DIMTSZ--;
  }
  {
    BITCODE_BD DIMTVP;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTVP", &DIMTVP, NULL)
        && DIMTVP == dimstyle->DIMTVP)
      pass ();
    else
      fail ("DIMSTYLE.DIMTVP [BD] %g != %g", dimstyle->DIMTVP, DIMTVP);
    DIMTVP++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTVP", &DIMTVP, 0)
        && DIMTVP == dimstyle->DIMTVP)
      pass ();
    else
      fail ("DIMSTYLE.DIMTVP [BD] set+1 %g != %g", dimstyle->DIMTVP, DIMTVP);
    dimstyle->DIMTVP--;
  }
  {
    BITCODE_H DIMTXSTY;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTXSTY", &DIMTXSTY, NULL)
        && !memcmp (&DIMTXSTY, &dimstyle->DIMTXSTY, sizeof (dimstyle->DIMTXSTY)))
        pass ();
    else
        fail ("DIMSTYLE.DIMTXSTY [H]");
  }
  {
    BITCODE_BD DIMTXT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTXT", &DIMTXT, NULL)
        && DIMTXT == dimstyle->DIMTXT)
      pass ();
    else
      fail ("DIMSTYLE.DIMTXT [BD] %g != %g", dimstyle->DIMTXT, DIMTXT);
    DIMTXT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTXT", &DIMTXT, 0)
        && DIMTXT == dimstyle->DIMTXT)
      pass ();
    else
      fail ("DIMSTYLE.DIMTXT [BD] set+1 %g != %g", dimstyle->DIMTXT, DIMTXT);
    dimstyle->DIMTXT--;
  }
  {
    BITCODE_B DIMTXTDIRECTION;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTXTDIRECTION", &DIMTXTDIRECTION, NULL)
        && DIMTXTDIRECTION == dimstyle->DIMTXTDIRECTION)
      pass ();
    else
      fail ("DIMSTYLE.DIMTXTDIRECTION [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTXTDIRECTION, DIMTXTDIRECTION);
    DIMTXTDIRECTION++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTXTDIRECTION", &DIMTXTDIRECTION, 0)
        && DIMTXTDIRECTION == dimstyle->DIMTXTDIRECTION)
      pass ();
    else
      fail ("DIMSTYLE.DIMTXTDIRECTION [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTXTDIRECTION, DIMTXTDIRECTION);
    dimstyle->DIMTXTDIRECTION--;
  }
  {
    BITCODE_BS DIMTZIN;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTZIN", &DIMTZIN, NULL)
        && DIMTZIN == dimstyle->DIMTZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMTZIN [BS] %hu != %hu", dimstyle->DIMTZIN, DIMTZIN);
    DIMTZIN++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTZIN", &DIMTZIN, 0)
        && DIMTZIN == dimstyle->DIMTZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMTZIN [BS] set+1 %hu != %hu", dimstyle->DIMTZIN, DIMTZIN);
    dimstyle->DIMTZIN--;
  }
  {
    BITCODE_BS DIMUNIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMUNIT", &DIMUNIT, NULL)
        && DIMUNIT == dimstyle->DIMUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMUNIT [BS] %hu != %hu", dimstyle->DIMUNIT, DIMUNIT);
    DIMUNIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMUNIT", &DIMUNIT, 0)
        && DIMUNIT == dimstyle->DIMUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMUNIT [BS] set+1 %hu != %hu", dimstyle->DIMUNIT, DIMUNIT);
    dimstyle->DIMUNIT--;
  }
  {
    BITCODE_B DIMUPT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMUPT", &DIMUPT, NULL)
        && DIMUPT == dimstyle->DIMUPT)
      pass ();
    else
      fail ("DIMSTYLE.DIMUPT [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMUPT, DIMUPT);
    DIMUPT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMUPT", &DIMUPT, 0)
        && DIMUPT == dimstyle->DIMUPT)
      pass ();
    else
      fail ("DIMSTYLE.DIMUPT [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMUPT, DIMUPT);
    dimstyle->DIMUPT--;
  }
  {
    BITCODE_BS DIMZIN;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMZIN", &DIMZIN, NULL)
        && DIMZIN == dimstyle->DIMZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMZIN [BS] %hu != %hu", dimstyle->DIMZIN, DIMZIN);
    DIMZIN++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMZIN", &DIMZIN, 0)
        && DIMZIN == dimstyle->DIMZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMZIN [BS] set+1 %hu != %hu", dimstyle->DIMZIN, DIMZIN);
    dimstyle->DIMZIN--;
  }
  {
    BITCODE_H extref_handle;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "extref_handle", &extref_handle, NULL)
        && !memcmp (&extref_handle, &dimstyle->extref_handle, sizeof (dimstyle->extref_handle)))
        pass ();
    else
        fail ("DIMSTYLE.extref_handle [H]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "flag", &flag, NULL)
        && flag == dimstyle->flag)
      pass ();
    else
      fail ("DIMSTYLE.flag [RC] %u != %u", dimstyle->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "flag", &flag, 0)
        && flag == dimstyle->flag)
      pass ();
    else
      fail ("DIMSTYLE.flag [RC] set+1 %u != %u", dimstyle->flag, flag);
    dimstyle->flag--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)dimstyle->name)
           : !dimstyle->name)
      pass ();
    else
      fail ("DIMSTYLE.name [TV] '%s' <> '%s'", name, dimstyle->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &dimstyle->parent, sizeof (dimstyle->parent)))
        pass ();
    else
        fail ("DIMSTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "used", &used, NULL)
        && used == dimstyle->used)
      pass ();
    else
      fail ("DIMSTYLE.used [RS] %hu != %hu", dimstyle->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "used", &used, 0)
        && used == dimstyle->used)
      pass ();
    else
      fail ("DIMSTYLE.used [RS] set+1 %hu != %hu", dimstyle->used, used);
    dimstyle->used--;
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "xrefdep", &xrefdep, NULL)
        && xrefdep == dimstyle->xrefdep)
      pass ();
    else
      fail ("DIMSTYLE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", dimstyle->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "xrefdep", &xrefdep, 0)
        && xrefdep == dimstyle->xrefdep)
      pass ();
    else
      fail ("DIMSTYLE.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->xrefdep, xrefdep);
    dimstyle->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == dimstyle->xrefindex_plus1)
      pass ();
    else
      fail ("DIMSTYLE.xrefindex_plus1 [BS] %hu != %hu", dimstyle->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == dimstyle->xrefindex_plus1)
      pass ();
    else
      fail ("DIMSTYLE.xrefindex_plus1 [BS] set+1 %hu != %hu", dimstyle->xrefindex_plus1, xrefindex_plus1);
    dimstyle->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "xrefref", &xrefref, NULL)
        && xrefref == dimstyle->xrefref)
      pass ();
    else
      fail ("DIMSTYLE.xrefref [B] " FORMAT_B " != " FORMAT_B "", dimstyle->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "xrefref", &xrefref, 0)
        && xrefref == dimstyle->xrefref)
      pass ();
    else
      fail ("DIMSTYLE.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->xrefref, xrefref);
    dimstyle->xrefref--;
  }
  if (failed && (is_class_unstable ("DIMSTYLE") || is_class_debugging ("DIMSTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMSTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMSTYLE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DIMSTYLE_CONTROL *restrict dimstyle_control = obj->tio.object->tio.DIMSTYLE_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "entries", &entries, NULL)
        && entries == dimstyle_control->entries)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_H* morehandles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &count, NULL)
        && dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "morehandles", &morehandles, NULL)
        && morehandles == dimstyle_control->morehandles)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.morehandles [H*] * %u num_morehandles", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == dimstyle_control->num_entries)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.num_entries [BS] %hu != %hu", dimstyle_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == dimstyle_control->num_entries)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.num_entries [BS] set+1 %hu != %hu", dimstyle_control->num_entries, num_entries);
    dimstyle_control->num_entries--;
  }
  {
    BITCODE_RC num_morehandles;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &num_morehandles, NULL)
        && num_morehandles == dimstyle_control->num_morehandles)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.num_morehandles [RC] %u != %u", dimstyle_control->num_morehandles, num_morehandles);
    num_morehandles++;
    if (dwg_dynapi_entity_set_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &num_morehandles, 0)
        && num_morehandles == dimstyle_control->num_morehandles)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.num_morehandles [RC] set+1 %u != %u", dimstyle_control->num_morehandles, num_morehandles);
    dimstyle_control->num_morehandles--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "objid", &objid, NULL)
        && objid == dimstyle_control->objid)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.objid [BL] %u != %u", dimstyle_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (dimstyle_control, "DIMSTYLE_CONTROL", "objid", &objid, 0)
        && objid == dimstyle_control->objid)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.objid [BL] set+1 %u != %u", dimstyle_control->objid, objid);
    dimstyle_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &dimstyle_control->parent, sizeof (dimstyle_control->parent)))
        pass ();
    else
        fail ("DIMSTYLE_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DIMSTYLE_CONTROL") || is_class_debugging ("DIMSTYLE_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMSTYLE_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_DUMMY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DUMMY *restrict dummy = obj->tio.object->tio.DUMMY;
  failed = 0;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dummy, "DUMMY", "parent", &parent, NULL)
        && !memcmp (&parent, &dummy->parent, sizeof (dummy->parent)))
        pass ();
    else
        fail ("DUMMY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DUMMY") || is_class_debugging ("DUMMY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DUMMY", failed);
      failed = 0;
    }
  return failed;
}
static int test_DYNAMICBLOCKPURGEPREVENTER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DYNAMICBLOCKPURGEPREVENTER *restrict dynamicblockpurgepreventer = obj->tio.object->tio.DYNAMICBLOCKPURGEPREVENTER;
  failed = 0;
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "block", &block, NULL)
        && !memcmp (&block, &dynamicblockpurgepreventer->block, sizeof (dynamicblockpurgepreventer->block)))
        pass ();
    else
        fail ("DYNAMICBLOCKPURGEPREVENTER.block [H]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "flag", &flag, NULL)
        && flag == dynamicblockpurgepreventer->flag)
      pass ();
    else
      fail ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] %hu != %hu", dynamicblockpurgepreventer->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "flag", &flag, 0)
        && flag == dynamicblockpurgepreventer->flag)
      pass ();
    else
      fail ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] set+1 %hu != %hu", dynamicblockpurgepreventer->flag, flag);
    dynamicblockpurgepreventer->flag--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "parent", &parent, NULL)
        && !memcmp (&parent, &dynamicblockpurgepreventer->parent, sizeof (dynamicblockpurgepreventer->parent)))
        pass ();
    else
        fail ("DYNAMICBLOCKPURGEPREVENTER.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DYNAMICBLOCKPURGEPREVENTER") || is_class_debugging ("DYNAMICBLOCKPURGEPREVENTER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DYNAMICBLOCKPURGEPREVENTER", failed);
      failed = 0;
    }
  return failed;
}
static int test_EVALUATION_GRAPH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_EVALUATION_GRAPH *restrict evaluation_graph = obj->tio.object->tio.EVALUATION_GRAPH;
  failed = 0;
  {
    BITCODE_BL edge_flags;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "edge_flags", &edge_flags, NULL)
        && edge_flags == evaluation_graph->edge_flags)
      pass ();
    else
      fail ("EVALUATION_GRAPH.edge_flags [BL] %u != %u", evaluation_graph->edge_flags, edge_flags);
    edge_flags++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "edge_flags", &edge_flags, 0)
        && edge_flags == evaluation_graph->edge_flags)
      pass ();
    else
      fail ("EVALUATION_GRAPH.edge_flags [BL] set+1 %u != %u", evaluation_graph->edge_flags, edge_flags);
    evaluation_graph->edge_flags--;
  }
  {
    BITCODE_H* evalexpr;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "num_evalexpr", &count, NULL)
        && dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "evalexpr", &evalexpr, NULL)
        && evalexpr == evaluation_graph->evalexpr)
      pass ();
    else
      fail ("EVALUATION_GRAPH.evalexpr [H*] * %u num_evalexpr", count);
  }
  {
    BITCODE_BL has_graph;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "has_graph", &has_graph, NULL)
        && has_graph == evaluation_graph->has_graph)
      pass ();
    else
      fail ("EVALUATION_GRAPH.has_graph [BL] %u != %u", evaluation_graph->has_graph, has_graph);
    has_graph++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "has_graph", &has_graph, 0)
        && has_graph == evaluation_graph->has_graph)
      pass ();
    else
      fail ("EVALUATION_GRAPH.has_graph [BL] set+1 %u != %u", evaluation_graph->has_graph, has_graph);
    evaluation_graph->has_graph--;
  }
  {
    BITCODE_BL node_edge1;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "node_edge1", &node_edge1, NULL)
        && node_edge1 == evaluation_graph->node_edge1)
      pass ();
    else
      fail ("EVALUATION_GRAPH.node_edge1 [BL] %u != %u", evaluation_graph->node_edge1, node_edge1);
    node_edge1++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "node_edge1", &node_edge1, 0)
        && node_edge1 == evaluation_graph->node_edge1)
      pass ();
    else
      fail ("EVALUATION_GRAPH.node_edge1 [BL] set+1 %u != %u", evaluation_graph->node_edge1, node_edge1);
    evaluation_graph->node_edge1--;
  }
  {
    BITCODE_BL node_edge2;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "node_edge2", &node_edge2, NULL)
        && node_edge2 == evaluation_graph->node_edge2)
      pass ();
    else
      fail ("EVALUATION_GRAPH.node_edge2 [BL] %u != %u", evaluation_graph->node_edge2, node_edge2);
    node_edge2++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "node_edge2", &node_edge2, 0)
        && node_edge2 == evaluation_graph->node_edge2)
      pass ();
    else
      fail ("EVALUATION_GRAPH.node_edge2 [BL] set+1 %u != %u", evaluation_graph->node_edge2, node_edge2);
    evaluation_graph->node_edge2--;
  }
  {
    BITCODE_BL node_edge3;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "node_edge3", &node_edge3, NULL)
        && node_edge3 == evaluation_graph->node_edge3)
      pass ();
    else
      fail ("EVALUATION_GRAPH.node_edge3 [BL] %u != %u", evaluation_graph->node_edge3, node_edge3);
    node_edge3++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "node_edge3", &node_edge3, 0)
        && node_edge3 == evaluation_graph->node_edge3)
      pass ();
    else
      fail ("EVALUATION_GRAPH.node_edge3 [BL] set+1 %u != %u", evaluation_graph->node_edge3, node_edge3);
    evaluation_graph->node_edge3--;
  }
  {
    BITCODE_BL node_edge4;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "node_edge4", &node_edge4, NULL)
        && node_edge4 == evaluation_graph->node_edge4)
      pass ();
    else
      fail ("EVALUATION_GRAPH.node_edge4 [BL] %u != %u", evaluation_graph->node_edge4, node_edge4);
    node_edge4++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "node_edge4", &node_edge4, 0)
        && node_edge4 == evaluation_graph->node_edge4)
      pass ();
    else
      fail ("EVALUATION_GRAPH.node_edge4 [BL] set+1 %u != %u", evaluation_graph->node_edge4, node_edge4);
    evaluation_graph->node_edge4--;
  }
  {
    BITCODE_BL nodeid;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "nodeid", &nodeid, NULL)
        && nodeid == evaluation_graph->nodeid)
      pass ();
    else
      fail ("EVALUATION_GRAPH.nodeid [BL] %u != %u", evaluation_graph->nodeid, nodeid);
    nodeid++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "nodeid", &nodeid, 0)
        && nodeid == evaluation_graph->nodeid)
      pass ();
    else
      fail ("EVALUATION_GRAPH.nodeid [BL] set+1 %u != %u", evaluation_graph->nodeid, nodeid);
    evaluation_graph->nodeid--;
  }
  {
    BITCODE_BL num_evalexpr;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "num_evalexpr", &num_evalexpr, NULL)
        && num_evalexpr == evaluation_graph->num_evalexpr)
      pass ();
    else
      fail ("EVALUATION_GRAPH.num_evalexpr [BL] %u != %u", evaluation_graph->num_evalexpr, num_evalexpr);
    num_evalexpr++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "num_evalexpr", &num_evalexpr, 0)
        && num_evalexpr == evaluation_graph->num_evalexpr)
      pass ();
    else
      fail ("EVALUATION_GRAPH.num_evalexpr [BL] set+1 %u != %u", evaluation_graph->num_evalexpr, num_evalexpr);
    evaluation_graph->num_evalexpr--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "parent", &parent, NULL)
        && !memcmp (&parent, &evaluation_graph->parent, sizeof (evaluation_graph->parent)))
        pass ();
    else
        fail ("EVALUATION_GRAPH.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL unknown1;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "unknown1", &unknown1, NULL)
        && unknown1 == evaluation_graph->unknown1)
      pass ();
    else
      fail ("EVALUATION_GRAPH.unknown1 [BL] %u != %u", evaluation_graph->unknown1, unknown1);
    unknown1++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "unknown1", &unknown1, 0)
        && unknown1 == evaluation_graph->unknown1)
      pass ();
    else
      fail ("EVALUATION_GRAPH.unknown1 [BL] set+1 %u != %u", evaluation_graph->unknown1, unknown1);
    evaluation_graph->unknown1--;
  }
  {
    BITCODE_BL unknown2;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "unknown2", &unknown2, NULL)
        && unknown2 == evaluation_graph->unknown2)
      pass ();
    else
      fail ("EVALUATION_GRAPH.unknown2 [BL] %u != %u", evaluation_graph->unknown2, unknown2);
    unknown2++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "unknown2", &unknown2, 0)
        && unknown2 == evaluation_graph->unknown2)
      pass ();
    else
      fail ("EVALUATION_GRAPH.unknown2 [BL] set+1 %u != %u", evaluation_graph->unknown2, unknown2);
    evaluation_graph->unknown2--;
  }
  if (failed && (is_class_unstable ("EVALUATION_GRAPH") || is_class_debugging ("EVALUATION_GRAPH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "EVALUATION_GRAPH", failed);
      failed = 0;
    }
  return failed;
}
static int test_FIELD (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_FIELD *restrict field = obj->tio.object->tio.FIELD;
  failed = 0;
  {
    BITCODE_H* childs;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_childs", &count, NULL)
        && dwg_dynapi_entity_value (field, "FIELD", "childs", &childs, NULL)
        && childs == field->childs)
      pass ();
    else
      fail ("FIELD.childs [H*] * %u num_childs", count);
  }
  {
    Dwg_FIELD_ChildValue* childval;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_childval", &count, NULL)
        && dwg_dynapi_entity_value (field, "FIELD", "childval", &childval, NULL)
        && childval == field->childval)
      pass ();
    else
      fail ("FIELD.childval [Dwg_FIELD_ChildValue*] * %u num_childval", count);
  }
  {
    BITCODE_T code;
    if (dwg_dynapi_entity_value (field, "FIELD", "code", &code, NULL)
        && code
           ? strEQ ((char *)code, (char *)field->code)
           : !field->code)
      pass ();
    else
      fail ("FIELD.code [T] '%s' <> '%s'", code, field->code);
  }
  {
    BITCODE_BL evaluation_error_code;
    if (dwg_dynapi_entity_value (field, "FIELD", "evaluation_error_code", &evaluation_error_code, NULL)
        && evaluation_error_code == field->evaluation_error_code)
      pass ();
    else
      fail ("FIELD.evaluation_error_code [BL] %u != %u", field->evaluation_error_code, evaluation_error_code);
    evaluation_error_code++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "evaluation_error_code", &evaluation_error_code, 0)
        && evaluation_error_code == field->evaluation_error_code)
      pass ();
    else
      fail ("FIELD.evaluation_error_code [BL] set+1 %u != %u", field->evaluation_error_code, evaluation_error_code);
    field->evaluation_error_code--;
  }
  {
    BITCODE_T evaluation_error_msg;
    if (dwg_dynapi_entity_value (field, "FIELD", "evaluation_error_msg", &evaluation_error_msg, NULL)
        && evaluation_error_msg
           ? strEQ ((char *)evaluation_error_msg, (char *)field->evaluation_error_msg)
           : !field->evaluation_error_msg)
      pass ();
    else
      fail ("FIELD.evaluation_error_msg [T] '%s' <> '%s'", evaluation_error_msg, field->evaluation_error_msg);
  }
  {
    BITCODE_BL evaluation_option;
    if (dwg_dynapi_entity_value (field, "FIELD", "evaluation_option", &evaluation_option, NULL)
        && evaluation_option == field->evaluation_option)
      pass ();
    else
      fail ("FIELD.evaluation_option [BL] %u != %u", field->evaluation_option, evaluation_option);
    evaluation_option++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "evaluation_option", &evaluation_option, 0)
        && evaluation_option == field->evaluation_option)
      pass ();
    else
      fail ("FIELD.evaluation_option [BL] set+1 %u != %u", field->evaluation_option, evaluation_option);
    field->evaluation_option--;
  }
  {
    BITCODE_BL evaluation_status;
    if (dwg_dynapi_entity_value (field, "FIELD", "evaluation_status", &evaluation_status, NULL)
        && evaluation_status == field->evaluation_status)
      pass ();
    else
      fail ("FIELD.evaluation_status [BL] %u != %u", field->evaluation_status, evaluation_status);
    evaluation_status++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "evaluation_status", &evaluation_status, 0)
        && evaluation_status == field->evaluation_status)
      pass ();
    else
      fail ("FIELD.evaluation_status [BL] set+1 %u != %u", field->evaluation_status, evaluation_status);
    field->evaluation_status--;
  }
  {
    BITCODE_BL field_state;
    if (dwg_dynapi_entity_value (field, "FIELD", "field_state", &field_state, NULL)
        && field_state == field->field_state)
      pass ();
    else
      fail ("FIELD.field_state [BL] %u != %u", field->field_state, field_state);
    field_state++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "field_state", &field_state, 0)
        && field_state == field->field_state)
      pass ();
    else
      fail ("FIELD.field_state [BL] set+1 %u != %u", field->field_state, field_state);
    field->field_state--;
  }
  {
    BITCODE_BL filing_option;
    if (dwg_dynapi_entity_value (field, "FIELD", "filing_option", &filing_option, NULL)
        && filing_option == field->filing_option)
      pass ();
    else
      fail ("FIELD.filing_option [BL] %u != %u", field->filing_option, filing_option);
    filing_option++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "filing_option", &filing_option, 0)
        && filing_option == field->filing_option)
      pass ();
    else
      fail ("FIELD.filing_option [BL] set+1 %u != %u", field->filing_option, filing_option);
    field->filing_option--;
  }
  {
    BITCODE_TV format;
    if (dwg_dynapi_entity_value (field, "FIELD", "format", &format, NULL)
        && format
           ? strEQ ((char *)format, (char *)field->format)
           : !field->format)
      pass ();
    else
      fail ("FIELD.format [TV] '%s' <> '%s'", format, field->format);
  }
  {
    BITCODE_T id;
    if (dwg_dynapi_entity_value (field, "FIELD", "id", &id, NULL)
        && id
           ? strEQ ((char *)id, (char *)field->id)
           : !field->id)
      pass ();
    else
      fail ("FIELD.id [T] '%s' <> '%s'", id, field->id);
  }
  {
    BITCODE_BL num_childs;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_childs", &num_childs, NULL)
        && num_childs == field->num_childs)
      pass ();
    else
      fail ("FIELD.num_childs [BL] %u != %u", field->num_childs, num_childs);
    num_childs++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "num_childs", &num_childs, 0)
        && num_childs == field->num_childs)
      pass ();
    else
      fail ("FIELD.num_childs [BL] set+1 %u != %u", field->num_childs, num_childs);
    field->num_childs--;
  }
  {
    BITCODE_BL num_childval;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_childval", &num_childval, NULL)
        && num_childval == field->num_childval)
      pass ();
    else
      fail ("FIELD.num_childval [BL] %u != %u", field->num_childval, num_childval);
    num_childval++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "num_childval", &num_childval, 0)
        && num_childval == field->num_childval)
      pass ();
    else
      fail ("FIELD.num_childval [BL] set+1 %u != %u", field->num_childval, num_childval);
    field->num_childval--;
  }
  {
    BITCODE_BL num_objects;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_objects", &num_objects, NULL)
        && num_objects == field->num_objects)
      pass ();
    else
      fail ("FIELD.num_objects [BL] %u != %u", field->num_objects, num_objects);
    num_objects++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "num_objects", &num_objects, 0)
        && num_objects == field->num_objects)
      pass ();
    else
      fail ("FIELD.num_objects [BL] set+1 %u != %u", field->num_objects, num_objects);
    field->num_objects--;
  }
  {
    BITCODE_H* objects;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_objects", &count, NULL)
        && dwg_dynapi_entity_value (field, "FIELD", "objects", &objects, NULL)
        && objects == field->objects)
      pass ();
    else
      fail ("FIELD.objects [H*] * %u num_objects", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (field, "FIELD", "parent", &parent, NULL)
        && !memcmp (&parent, &field->parent, sizeof (field->parent)))
        pass ();
    else
        fail ("FIELD.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_TABLE_value value;
    if (dwg_dynapi_entity_value (field, "FIELD", "value", &value, NULL)
        && !memcmp (&value, &field->value, sizeof (field->value)))
        pass ();
    else
        fail ("FIELD.value [Dwg_TABLE_value]");
  }
  {
    BITCODE_T value_string;
    if (dwg_dynapi_entity_value (field, "FIELD", "value_string", &value_string, NULL)
        && value_string
           ? strEQ ((char *)value_string, (char *)field->value_string)
           : !field->value_string)
      pass ();
    else
      fail ("FIELD.value_string [T] '%s' <> '%s'", value_string, field->value_string);
  }
  {
    BITCODE_BL value_string_length;
    if (dwg_dynapi_entity_value (field, "FIELD", "value_string_length", &value_string_length, NULL)
        && value_string_length == field->value_string_length)
      pass ();
    else
      fail ("FIELD.value_string_length [BL] %u != %u", field->value_string_length, value_string_length);
    value_string_length++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "value_string_length", &value_string_length, 0)
        && value_string_length == field->value_string_length)
      pass ();
    else
      fail ("FIELD.value_string_length [BL] set+1 %u != %u", field->value_string_length, value_string_length);
    field->value_string_length--;
  }
  if (failed && (is_class_unstable ("FIELD") || is_class_debugging ("FIELD")))
    {
      ok ("%s failed %d tests (TODO unstable)", "FIELD", failed);
      failed = 0;
    }
  return failed;
}
static int test_FIELDLIST (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_FIELDLIST *restrict fieldlist = obj->tio.object->tio.FIELDLIST;
  failed = 0;
  {
    BITCODE_H* fields;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "num_fields", &count, NULL)
        && dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "fields", &fields, NULL)
        && fields == fieldlist->fields)
      pass ();
    else
      fail ("FIELDLIST.fields [H*] * %u num_fields", count);
  }
  {
    BITCODE_BL num_fields;
    if (dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "num_fields", &num_fields, NULL)
        && num_fields == fieldlist->num_fields)
      pass ();
    else
      fail ("FIELDLIST.num_fields [BL] %u != %u", fieldlist->num_fields, num_fields);
    num_fields++;
    if (dwg_dynapi_entity_set_value (fieldlist, "FIELDLIST", "num_fields", &num_fields, 0)
        && num_fields == fieldlist->num_fields)
      pass ();
    else
      fail ("FIELDLIST.num_fields [BL] set+1 %u != %u", fieldlist->num_fields, num_fields);
    fieldlist->num_fields--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "parent", &parent, NULL)
        && !memcmp (&parent, &fieldlist->parent, sizeof (fieldlist->parent)))
        pass ();
    else
        fail ("FIELDLIST.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "unknown", &unknown, NULL)
        && unknown == fieldlist->unknown)
      pass ();
    else
      fail ("FIELDLIST.unknown [B] " FORMAT_B " != " FORMAT_B "", fieldlist->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (fieldlist, "FIELDLIST", "unknown", &unknown, 0)
        && unknown == fieldlist->unknown)
      pass ();
    else
      fail ("FIELDLIST.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", fieldlist->unknown, unknown);
    fieldlist->unknown--;
  }
  if (failed && (is_class_unstable ("FIELDLIST") || is_class_debugging ("FIELDLIST")))
    {
      ok ("%s failed %d tests (TODO unstable)", "FIELDLIST", failed);
      failed = 0;
    }
  return failed;
}
static int test_GEODATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_GEODATA *restrict geodata = obj->tio.object->tio.GEODATA;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "class_version", &class_version, NULL)
        && class_version == geodata->class_version)
      pass ();
    else
      fail ("GEODATA.class_version [BL] %u != %u", geodata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "class_version", &class_version, 0)
        && class_version == geodata->class_version)
      pass ();
    else
      fail ("GEODATA.class_version [BL] set+1 %u != %u", geodata->class_version, class_version);
    geodata->class_version--;
  }
  {
    BITCODE_BD coord_proj_radius;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_proj_radius", &coord_proj_radius, NULL)
        && coord_proj_radius == geodata->coord_proj_radius)
      pass ();
    else
      fail ("GEODATA.coord_proj_radius [BD] %g != %g", geodata->coord_proj_radius, coord_proj_radius);
    coord_proj_radius++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "coord_proj_radius", &coord_proj_radius, 0)
        && coord_proj_radius == geodata->coord_proj_radius)
      pass ();
    else
      fail ("GEODATA.coord_proj_radius [BD] set+1 %g != %g", geodata->coord_proj_radius, coord_proj_radius);
    geodata->coord_proj_radius--;
  }
  {
    BITCODE_T coord_system_datum;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_system_datum", &coord_system_datum, NULL)
        && coord_system_datum
           ? strEQ ((char *)coord_system_datum, (char *)geodata->coord_system_datum)
           : !geodata->coord_system_datum)
      pass ();
    else
      fail ("GEODATA.coord_system_datum [T] '%s' <> '%s'", coord_system_datum, geodata->coord_system_datum);
  }
  {
    BITCODE_T coord_system_def;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_system_def", &coord_system_def, NULL)
        && coord_system_def
           ? strEQ ((char *)coord_system_def, (char *)geodata->coord_system_def)
           : !geodata->coord_system_def)
      pass ();
    else
      fail ("GEODATA.coord_system_def [T] '%s' <> '%s'", coord_system_def, geodata->coord_system_def);
  }
  {
    BITCODE_T coord_system_wkt;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_system_wkt", &coord_system_wkt, NULL)
        && coord_system_wkt
           ? strEQ ((char *)coord_system_wkt, (char *)geodata->coord_system_wkt)
           : !geodata->coord_system_wkt)
      pass ();
    else
      fail ("GEODATA.coord_system_wkt [T] '%s' <> '%s'", coord_system_wkt, geodata->coord_system_wkt);
  }
  {
    BITCODE_BS coord_type;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_type", &coord_type, NULL)
        && coord_type == geodata->coord_type)
      pass ();
    else
      fail ("GEODATA.coord_type [BS] %hu != %hu", geodata->coord_type, coord_type);
    coord_type++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "coord_type", &coord_type, 0)
        && coord_type == geodata->coord_type)
      pass ();
    else
      fail ("GEODATA.coord_type [BS] set+1 %hu != %hu", geodata->coord_type, coord_type);
    geodata->coord_type--;
  }
  {
    BITCODE_3BD design_pt;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "design_pt", &design_pt, NULL)
        && !memcmp (&design_pt, &geodata->design_pt, sizeof (geodata->design_pt)))
        pass ();
    else
        fail ("GEODATA.design_pt [3BD]");
  }
  {
    BITCODE_T geo_rss_tag;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "geo_rss_tag", &geo_rss_tag, NULL)
        && geo_rss_tag
           ? strEQ ((char *)geo_rss_tag, (char *)geodata->geo_rss_tag)
           : !geodata->geo_rss_tag)
      pass ();
    else
      fail ("GEODATA.geo_rss_tag [T] '%s' <> '%s'", geo_rss_tag, geodata->geo_rss_tag);
  }
  {
    Dwg_GEODATA_meshface* geomesh_faces;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "num_geomesh_faces", &count, NULL)
        && dwg_dynapi_entity_value (geodata, "GEODATA", "geomesh_faces", &geomesh_faces, NULL)
        && geomesh_faces == geodata->geomesh_faces)
      pass ();
    else
      fail ("GEODATA.geomesh_faces [Dwg_GEODATA_meshface*] * %u num_geomesh_faces", count);
  }
  {
    Dwg_GEODATA_meshpt* geomesh_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "num_geomesh_pts", &count, NULL)
        && dwg_dynapi_entity_value (geodata, "GEODATA", "geomesh_pts", &geomesh_pts, NULL)
        && geomesh_pts == geodata->geomesh_pts)
      pass ();
    else
      fail ("GEODATA.geomesh_pts [Dwg_GEODATA_meshpt*] * %u num_geomesh_pts", count);
  }
  {
    BITCODE_B has_civil_data;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "has_civil_data", &has_civil_data, NULL)
        && has_civil_data == geodata->has_civil_data)
      pass ();
    else
      fail ("GEODATA.has_civil_data [B] " FORMAT_B " != " FORMAT_B "", geodata->has_civil_data, has_civil_data);
    has_civil_data++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "has_civil_data", &has_civil_data, 0)
        && has_civil_data == geodata->has_civil_data)
      pass ();
    else
      fail ("GEODATA.has_civil_data [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->has_civil_data, has_civil_data);
    geodata->has_civil_data--;
  }
  {
    BITCODE_H host_block;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "host_block", &host_block, NULL)
        && !memcmp (&host_block, &geodata->host_block, sizeof (geodata->host_block)))
        pass ();
    else
        fail ("GEODATA.host_block [H]");
  }
  {
    BITCODE_3BD north_dir;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "north_dir", &north_dir, NULL)
        && !memcmp (&north_dir, &geodata->north_dir, sizeof (geodata->north_dir)))
        pass ();
    else
        fail ("GEODATA.north_dir [3BD]");
  }
  {
    BITCODE_BD north_dir_angle_deg;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "north_dir_angle_deg", &north_dir_angle_deg, NULL)
        && north_dir_angle_deg == geodata->north_dir_angle_deg)
      pass ();
    else
      fail ("GEODATA.north_dir_angle_deg [BD] %g != %g", geodata->north_dir_angle_deg, north_dir_angle_deg);
    north_dir_angle_deg++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "north_dir_angle_deg", &north_dir_angle_deg, 0)
        && north_dir_angle_deg == geodata->north_dir_angle_deg)
      pass ();
    else
      fail ("GEODATA.north_dir_angle_deg [BD] set+1 %g != %g", geodata->north_dir_angle_deg, north_dir_angle_deg);
    geodata->north_dir_angle_deg--;
  }
  {
    BITCODE_BD north_dir_angle_rad;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "north_dir_angle_rad", &north_dir_angle_rad, NULL)
        && north_dir_angle_rad == geodata->north_dir_angle_rad)
      pass ();
    else
      fail ("GEODATA.north_dir_angle_rad [BD] %g != %g", geodata->north_dir_angle_rad, north_dir_angle_rad);
    north_dir_angle_rad++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "north_dir_angle_rad", &north_dir_angle_rad, 0)
        && north_dir_angle_rad == geodata->north_dir_angle_rad)
      pass ();
    else
      fail ("GEODATA.north_dir_angle_rad [BD] set+1 %g != %g", geodata->north_dir_angle_rad, north_dir_angle_rad);
    geodata->north_dir_angle_rad--;
  }
  {
    BITCODE_BL num_geomesh_faces;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "num_geomesh_faces", &num_geomesh_faces, NULL)
        && num_geomesh_faces == geodata->num_geomesh_faces)
      pass ();
    else
      fail ("GEODATA.num_geomesh_faces [BL] %u != %u", geodata->num_geomesh_faces, num_geomesh_faces);
    num_geomesh_faces++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "num_geomesh_faces", &num_geomesh_faces, 0)
        && num_geomesh_faces == geodata->num_geomesh_faces)
      pass ();
    else
      fail ("GEODATA.num_geomesh_faces [BL] set+1 %u != %u", geodata->num_geomesh_faces, num_geomesh_faces);
    geodata->num_geomesh_faces--;
  }
  {
    BITCODE_BL num_geomesh_pts;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "num_geomesh_pts", &num_geomesh_pts, NULL)
        && num_geomesh_pts == geodata->num_geomesh_pts)
      pass ();
    else
      fail ("GEODATA.num_geomesh_pts [BL] %u != %u", geodata->num_geomesh_pts, num_geomesh_pts);
    num_geomesh_pts++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "num_geomesh_pts", &num_geomesh_pts, 0)
        && num_geomesh_pts == geodata->num_geomesh_pts)
      pass ();
    else
      fail ("GEODATA.num_geomesh_pts [BL] set+1 %u != %u", geodata->num_geomesh_pts, num_geomesh_pts);
    geodata->num_geomesh_pts--;
  }
  {
    BITCODE_3BD obs_pt;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "obs_pt", &obs_pt, NULL)
        && !memcmp (&obs_pt, &geodata->obs_pt, sizeof (geodata->obs_pt)))
        pass ();
    else
        fail ("GEODATA.obs_pt [3BD]");
  }
  {
    BITCODE_T observation_coverage_tag;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "observation_coverage_tag", &observation_coverage_tag, NULL)
        && observation_coverage_tag
           ? strEQ ((char *)observation_coverage_tag, (char *)geodata->observation_coverage_tag)
           : !geodata->observation_coverage_tag)
      pass ();
    else
      fail ("GEODATA.observation_coverage_tag [T] '%s' <> '%s'", observation_coverage_tag, geodata->observation_coverage_tag);
  }
  {
    BITCODE_T observation_from_tag;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "observation_from_tag", &observation_from_tag, NULL)
        && observation_from_tag
           ? strEQ ((char *)observation_from_tag, (char *)geodata->observation_from_tag)
           : !geodata->observation_from_tag)
      pass ();
    else
      fail ("GEODATA.observation_from_tag [T] '%s' <> '%s'", observation_from_tag, geodata->observation_from_tag);
  }
  {
    BITCODE_T observation_to_tag;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "observation_to_tag", &observation_to_tag, NULL)
        && observation_to_tag
           ? strEQ ((char *)observation_to_tag, (char *)geodata->observation_to_tag)
           : !geodata->observation_to_tag)
      pass ();
    else
      fail ("GEODATA.observation_to_tag [T] '%s' <> '%s'", observation_to_tag, geodata->observation_to_tag);
  }
  {
    BITCODE_B obsolete_false;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "obsolete_false", &obsolete_false, NULL)
        && obsolete_false == geodata->obsolete_false)
      pass ();
    else
      fail ("GEODATA.obsolete_false [B] " FORMAT_B " != " FORMAT_B "", geodata->obsolete_false, obsolete_false);
    obsolete_false++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "obsolete_false", &obsolete_false, 0)
        && obsolete_false == geodata->obsolete_false)
      pass ();
    else
      fail ("GEODATA.obsolete_false [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->obsolete_false, obsolete_false);
    geodata->obsolete_false--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "parent", &parent, NULL)
        && !memcmp (&parent, &geodata->parent, sizeof (geodata->parent)))
        pass ();
    else
        fail ("GEODATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3BD ref_pt;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "ref_pt", &ref_pt, NULL)
        && !memcmp (&ref_pt, &geodata->ref_pt, sizeof (geodata->ref_pt)))
        pass ();
    else
        fail ("GEODATA.ref_pt [3BD]");
  }
  {
    BITCODE_RD refpt0x;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "refpt0x", &refpt0x, NULL)
        && refpt0x == geodata->refpt0x)
      pass ();
    else
      fail ("GEODATA.refpt0x [RD] %g != %g", geodata->refpt0x, refpt0x);
    refpt0x++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "refpt0x", &refpt0x, 0)
        && refpt0x == geodata->refpt0x)
      pass ();
    else
      fail ("GEODATA.refpt0x [RD] set+1 %g != %g", geodata->refpt0x, refpt0x);
    geodata->refpt0x--;
  }
  {
    BITCODE_RD refpt0y;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "refpt0y", &refpt0y, NULL)
        && refpt0y == geodata->refpt0y)
      pass ();
    else
      fail ("GEODATA.refpt0y [RD] %g != %g", geodata->refpt0y, refpt0y);
    refpt0y++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "refpt0y", &refpt0y, 0)
        && refpt0y == geodata->refpt0y)
      pass ();
    else
      fail ("GEODATA.refpt0y [RD] set+1 %g != %g", geodata->refpt0y, refpt0y);
    geodata->refpt0y--;
  }
  {
    BITCODE_RD refpt1x;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "refpt1x", &refpt1x, NULL)
        && refpt1x == geodata->refpt1x)
      pass ();
    else
      fail ("GEODATA.refpt1x [RD] %g != %g", geodata->refpt1x, refpt1x);
    refpt1x++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "refpt1x", &refpt1x, 0)
        && refpt1x == geodata->refpt1x)
      pass ();
    else
      fail ("GEODATA.refpt1x [RD] set+1 %g != %g", geodata->refpt1x, refpt1x);
    geodata->refpt1x--;
  }
  {
    BITCODE_RD refpt1y;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "refpt1y", &refpt1y, NULL)
        && refpt1y == geodata->refpt1y)
      pass ();
    else
      fail ("GEODATA.refpt1y [RD] %g != %g", geodata->refpt1y, refpt1y);
    refpt1y++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "refpt1y", &refpt1y, 0)
        && refpt1y == geodata->refpt1y)
      pass ();
    else
      fail ("GEODATA.refpt1y [RD] set+1 %g != %g", geodata->refpt1y, refpt1y);
    geodata->refpt1y--;
  }
  {
    BITCODE_BL scale_est;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "scale_est", &scale_est, NULL)
        && scale_est == geodata->scale_est)
      pass ();
    else
      fail ("GEODATA.scale_est [BL] %u != %u", geodata->scale_est, scale_est);
    scale_est++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "scale_est", &scale_est, 0)
        && scale_est == geodata->scale_est)
      pass ();
    else
      fail ("GEODATA.scale_est [BL] set+1 %u != %u", geodata->scale_est, scale_est);
    geodata->scale_est--;
  }
  {
    BITCODE_B sea_level_corr;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "sea_level_corr", &sea_level_corr, NULL)
        && sea_level_corr == geodata->sea_level_corr)
      pass ();
    else
      fail ("GEODATA.sea_level_corr [B] " FORMAT_B " != " FORMAT_B "", geodata->sea_level_corr, sea_level_corr);
    sea_level_corr++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "sea_level_corr", &sea_level_corr, 0)
        && sea_level_corr == geodata->sea_level_corr)
      pass ();
    else
      fail ("GEODATA.sea_level_corr [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->sea_level_corr, sea_level_corr);
    geodata->sea_level_corr--;
  }
  {
    BITCODE_BD sea_level_elev;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "sea_level_elev", &sea_level_elev, NULL)
        && sea_level_elev == geodata->sea_level_elev)
      pass ();
    else
      fail ("GEODATA.sea_level_elev [BD] %g != %g", geodata->sea_level_elev, sea_level_elev);
    sea_level_elev++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "sea_level_elev", &sea_level_elev, 0)
        && sea_level_elev == geodata->sea_level_elev)
      pass ();
    else
      fail ("GEODATA.sea_level_elev [BD] set+1 %g != %g", geodata->sea_level_elev, sea_level_elev);
    geodata->sea_level_elev--;
  }
  {
    BITCODE_BD unit_scale_horiz;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unit_scale_horiz", &unit_scale_horiz, NULL)
        && unit_scale_horiz == geodata->unit_scale_horiz)
      pass ();
    else
      fail ("GEODATA.unit_scale_horiz [BD] %g != %g", geodata->unit_scale_horiz, unit_scale_horiz);
    unit_scale_horiz++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unit_scale_horiz", &unit_scale_horiz, 0)
        && unit_scale_horiz == geodata->unit_scale_horiz)
      pass ();
    else
      fail ("GEODATA.unit_scale_horiz [BD] set+1 %g != %g", geodata->unit_scale_horiz, unit_scale_horiz);
    geodata->unit_scale_horiz--;
  }
  {
    BITCODE_BD unit_scale_vert;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unit_scale_vert", &unit_scale_vert, NULL)
        && unit_scale_vert == geodata->unit_scale_vert)
      pass ();
    else
      fail ("GEODATA.unit_scale_vert [BD] %g != %g", geodata->unit_scale_vert, unit_scale_vert);
    unit_scale_vert++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unit_scale_vert", &unit_scale_vert, 0)
        && unit_scale_vert == geodata->unit_scale_vert)
      pass ();
    else
      fail ("GEODATA.unit_scale_vert [BD] set+1 %g != %g", geodata->unit_scale_vert, unit_scale_vert);
    geodata->unit_scale_vert--;
  }
  {
    BITCODE_BL units_value_horiz;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "units_value_horiz", &units_value_horiz, NULL)
        && units_value_horiz == geodata->units_value_horiz)
      pass ();
    else
      fail ("GEODATA.units_value_horiz [BL] %u != %u", geodata->units_value_horiz, units_value_horiz);
    units_value_horiz++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "units_value_horiz", &units_value_horiz, 0)
        && units_value_horiz == geodata->units_value_horiz)
      pass ();
    else
      fail ("GEODATA.units_value_horiz [BL] set+1 %u != %u", geodata->units_value_horiz, units_value_horiz);
    geodata->units_value_horiz--;
  }
  {
    BITCODE_BL units_value_vert;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "units_value_vert", &units_value_vert, NULL)
        && units_value_vert == geodata->units_value_vert)
      pass ();
    else
      fail ("GEODATA.units_value_vert [BL] %u != %u", geodata->units_value_vert, units_value_vert);
    units_value_vert++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "units_value_vert", &units_value_vert, 0)
        && units_value_vert == geodata->units_value_vert)
      pass ();
    else
      fail ("GEODATA.units_value_vert [BL] set+1 %u != %u", geodata->units_value_vert, units_value_vert);
    geodata->units_value_vert--;
  }
  {
    BITCODE_BL unknown1;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unknown1", &unknown1, NULL)
        && unknown1 == geodata->unknown1)
      pass ();
    else
      fail ("GEODATA.unknown1 [BL] %u != %u", geodata->unknown1, unknown1);
    unknown1++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unknown1", &unknown1, 0)
        && unknown1 == geodata->unknown1)
      pass ();
    else
      fail ("GEODATA.unknown1 [BL] set+1 %u != %u", geodata->unknown1, unknown1);
    geodata->unknown1--;
  }
  {
    BITCODE_BL unknown2;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unknown2", &unknown2, NULL)
        && unknown2 == geodata->unknown2)
      pass ();
    else
      fail ("GEODATA.unknown2 [BL] %u != %u", geodata->unknown2, unknown2);
    unknown2++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unknown2", &unknown2, 0)
        && unknown2 == geodata->unknown2)
      pass ();
    else
      fail ("GEODATA.unknown2 [BL] set+1 %u != %u", geodata->unknown2, unknown2);
    geodata->unknown2--;
  }
  {
    BITCODE_B unknown_b;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unknown_b", &unknown_b, NULL)
        && unknown_b == geodata->unknown_b)
      pass ();
    else
      fail ("GEODATA.unknown_b [B] " FORMAT_B " != " FORMAT_B "", geodata->unknown_b, unknown_b);
    unknown_b++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unknown_b", &unknown_b, 0)
        && unknown_b == geodata->unknown_b)
      pass ();
    else
      fail ("GEODATA.unknown_b [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->unknown_b, unknown_b);
    geodata->unknown_b--;
  }
  {
    BITCODE_3BD up_dir;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "up_dir", &up_dir, NULL)
        && !memcmp (&up_dir, &geodata->up_dir, sizeof (geodata->up_dir)))
        pass ();
    else
        fail ("GEODATA.up_dir [3BD]");
  }
  {
    BITCODE_BD user_scale_factor;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "user_scale_factor", &user_scale_factor, NULL)
        && user_scale_factor == geodata->user_scale_factor)
      pass ();
    else
      fail ("GEODATA.user_scale_factor [BD] %g != %g", geodata->user_scale_factor, user_scale_factor);
    user_scale_factor++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "user_scale_factor", &user_scale_factor, 0)
        && user_scale_factor == geodata->user_scale_factor)
      pass ();
    else
      fail ("GEODATA.user_scale_factor [BD] set+1 %g != %g", geodata->user_scale_factor, user_scale_factor);
    geodata->user_scale_factor--;
  }
  {
    BITCODE_2RD zero0;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "zero0", &zero0, NULL)
        && !memcmp (&zero0, &geodata->zero0, sizeof (geodata->zero0)))
        pass ();
    else
        fail ("GEODATA.zero0 [2RD]");
  }
  {
    BITCODE_2RD zero1;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "zero1", &zero1, NULL)
        && !memcmp (&zero1, &geodata->zero1, sizeof (geodata->zero1)))
        pass ();
    else
        fail ("GEODATA.zero1 [2RD]");
  }
  if (failed && (is_class_unstable ("GEODATA") || is_class_debugging ("GEODATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GEODATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_GEOMAPIMAGE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_GEOMAPIMAGE *restrict geomapimage = obj->tio.object->tio.GEOMAPIMAGE;
  failed = 0;
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "brightness", &brightness, NULL)
        && brightness == geomapimage->brightness)
      pass ();
    else
      fail ("GEOMAPIMAGE.brightness [RC] %u != %u", geomapimage->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "brightness", &brightness, 0)
        && brightness == geomapimage->brightness)
      pass ();
    else
      fail ("GEOMAPIMAGE.brightness [RC] set+1 %u != %u", geomapimage->brightness, brightness);
    geomapimage->brightness--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "class_version", &class_version, NULL)
        && class_version == geomapimage->class_version)
      pass ();
    else
      fail ("GEOMAPIMAGE.class_version [BL] %u != %u", geomapimage->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "class_version", &class_version, 0)
        && class_version == geomapimage->class_version)
      pass ();
    else
      fail ("GEOMAPIMAGE.class_version [BL] set+1 %u != %u", geomapimage->class_version, class_version);
    geomapimage->class_version--;
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "clipping", &clipping, NULL)
        && clipping == geomapimage->clipping)
      pass ();
    else
      fail ("GEOMAPIMAGE.clipping [B] " FORMAT_B " != " FORMAT_B "", geomapimage->clipping, clipping);
    clipping++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "clipping", &clipping, 0)
        && clipping == geomapimage->clipping)
      pass ();
    else
      fail ("GEOMAPIMAGE.clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", geomapimage->clipping, clipping);
    geomapimage->clipping--;
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "contrast", &contrast, NULL)
        && contrast == geomapimage->contrast)
      pass ();
    else
      fail ("GEOMAPIMAGE.contrast [RC] %u != %u", geomapimage->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "contrast", &contrast, 0)
        && contrast == geomapimage->contrast)
      pass ();
    else
      fail ("GEOMAPIMAGE.contrast [RC] set+1 %u != %u", geomapimage->contrast, contrast);
    geomapimage->contrast--;
  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "display_props", &display_props, NULL)
        && display_props == geomapimage->display_props)
      pass ();
    else
      fail ("GEOMAPIMAGE.display_props [BS] %hu != %hu", geomapimage->display_props, display_props);
    display_props++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "display_props", &display_props, 0)
        && display_props == geomapimage->display_props)
      pass ();
    else
      fail ("GEOMAPIMAGE.display_props [BS] set+1 %hu != %hu", geomapimage->display_props, display_props);
    geomapimage->display_props--;
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "fade", &fade, NULL)
        && fade == geomapimage->fade)
      pass ();
    else
      fail ("GEOMAPIMAGE.fade [RC] %u != %u", geomapimage->fade, fade);
    fade++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "fade", &fade, 0)
        && fade == geomapimage->fade)
      pass ();
    else
      fail ("GEOMAPIMAGE.fade [RC] set+1 %u != %u", geomapimage->fade, fade);
    geomapimage->fade--;
  }
  {
    BITCODE_BS geoimage_brightness;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_brightness", &geoimage_brightness, NULL)
        && geoimage_brightness == geomapimage->geoimage_brightness)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_brightness [BS] %hu != %hu", geomapimage->geoimage_brightness, geoimage_brightness);
    geoimage_brightness++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_brightness", &geoimage_brightness, 0)
        && geoimage_brightness == geomapimage->geoimage_brightness)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_brightness [BS] set+1 %hu != %hu", geomapimage->geoimage_brightness, geoimage_brightness);
    geomapimage->geoimage_brightness--;
  }
  {
    BITCODE_BS geoimage_contrast;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_contrast", &geoimage_contrast, NULL)
        && geoimage_contrast == geomapimage->geoimage_contrast)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_contrast [BS] %hu != %hu", geomapimage->geoimage_contrast, geoimage_contrast);
    geoimage_contrast++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_contrast", &geoimage_contrast, 0)
        && geoimage_contrast == geomapimage->geoimage_contrast)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_contrast [BS] set+1 %hu != %hu", geomapimage->geoimage_contrast, geoimage_contrast);
    geomapimage->geoimage_contrast--;
  }
  {
    BITCODE_BS geoimage_fade;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_fade", &geoimage_fade, NULL)
        && geoimage_fade == geomapimage->geoimage_fade)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_fade [BS] %hu != %hu", geomapimage->geoimage_fade, geoimage_fade);
    geoimage_fade++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_fade", &geoimage_fade, 0)
        && geoimage_fade == geomapimage->geoimage_fade)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_fade [BS] set+1 %hu != %hu", geomapimage->geoimage_fade, geoimage_fade);
    geomapimage->geoimage_fade--;
  }
  {
    BITCODE_BS geoimage_height;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_height", &geoimage_height, NULL)
        && geoimage_height == geomapimage->geoimage_height)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_height [BS] %hu != %hu", geomapimage->geoimage_height, geoimage_height);
    geoimage_height++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_height", &geoimage_height, 0)
        && geoimage_height == geomapimage->geoimage_height)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_height [BS] set+1 %hu != %hu", geomapimage->geoimage_height, geoimage_height);
    geomapimage->geoimage_height--;
  }
  {
    BITCODE_BS geoimage_position;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_position", &geoimage_position, NULL)
        && geoimage_position == geomapimage->geoimage_position)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_position [BS] %hu != %hu", geomapimage->geoimage_position, geoimage_position);
    geoimage_position++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_position", &geoimage_position, 0)
        && geoimage_position == geomapimage->geoimage_position)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_position [BS] set+1 %hu != %hu", geomapimage->geoimage_position, geoimage_position);
    geomapimage->geoimage_position--;
  }
  {
    BITCODE_BS geoimage_width;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_width", &geoimage_width, NULL)
        && geoimage_width == geomapimage->geoimage_width)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_width [BS] %hu != %hu", geomapimage->geoimage_width, geoimage_width);
    geoimage_width++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_width", &geoimage_width, 0)
        && geoimage_width == geomapimage->geoimage_width)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_width [BS] set+1 %hu != %hu", geomapimage->geoimage_width, geoimage_width);
    geomapimage->geoimage_width--;
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "height", &height, NULL)
        && height == geomapimage->height)
      pass ();
    else
      fail ("GEOMAPIMAGE.height [BD] %g != %g", geomapimage->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "height", &height, 0)
        && height == geomapimage->height)
      pass ();
    else
      fail ("GEOMAPIMAGE.height [BD] set+1 %g != %g", geomapimage->height, height);
    geomapimage->height--;
  }
  {
    BITCODE_BD image_file;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "image_file", &image_file, NULL)
        && image_file == geomapimage->image_file)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_file [BD] %g != %g", geomapimage->image_file, image_file);
    image_file++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "image_file", &image_file, 0)
        && image_file == geomapimage->image_file)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_file [BD] set+1 %g != %g", geomapimage->image_file, image_file);
    geomapimage->image_file--;
  }
  {
    BITCODE_BD image_height;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "image_height", &image_height, NULL)
        && image_height == geomapimage->image_height)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_height [BD] %g != %g", geomapimage->image_height, image_height);
    image_height++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "image_height", &image_height, 0)
        && image_height == geomapimage->image_height)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_height [BD] set+1 %g != %g", geomapimage->image_height, image_height);
    geomapimage->image_height--;
  }
  {
    BITCODE_BD image_visibility;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "image_visibility", &image_visibility, NULL)
        && image_visibility == geomapimage->image_visibility)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_visibility [BD] %g != %g", geomapimage->image_visibility, image_visibility);
    image_visibility++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "image_visibility", &image_visibility, 0)
        && image_visibility == geomapimage->image_visibility)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_visibility [BD] set+1 %g != %g", geomapimage->image_visibility, image_visibility);
    geomapimage->image_visibility--;
  }
  {
    BITCODE_BD image_width;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "image_width", &image_width, NULL)
        && image_width == geomapimage->image_width)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_width [BD] %g != %g", geomapimage->image_width, image_width);
    image_width++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "image_width", &image_width, 0)
        && image_width == geomapimage->image_width)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_width [BD] set+1 %g != %g", geomapimage->image_width, image_width);
    geomapimage->image_width--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)geomapimage->name)
           : !geomapimage->name)
      pass ();
    else
      fail ("GEOMAPIMAGE.name [T] '%s' <> '%s'", name, geomapimage->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "parent", &parent, NULL)
        && !memcmp (&parent, &geomapimage->parent, sizeof (geomapimage->parent)))
        pass ();
    else
        fail ("GEOMAPIMAGE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "pt0", &pt0, NULL)
        && !memcmp (&pt0, &geomapimage->pt0, sizeof (geomapimage->pt0)))
        pass ();
    else
        fail ("GEOMAPIMAGE.pt0 [3BD]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "rotation", &rotation, NULL)
        && rotation == geomapimage->rotation)
      pass ();
    else
      fail ("GEOMAPIMAGE.rotation [BD] %g != %g", geomapimage->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "rotation", &rotation, 0)
        && rotation == geomapimage->rotation)
      pass ();
    else
      fail ("GEOMAPIMAGE.rotation [BD] set+1 %g != %g", geomapimage->rotation, rotation);
    geomapimage->rotation--;
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "scale_factor", &scale_factor, NULL)
        && scale_factor == geomapimage->scale_factor)
      pass ();
    else
      fail ("GEOMAPIMAGE.scale_factor [BD] %g != %g", geomapimage->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "scale_factor", &scale_factor, 0)
        && scale_factor == geomapimage->scale_factor)
      pass ();
    else
      fail ("GEOMAPIMAGE.scale_factor [BD] set+1 %g != %g", geomapimage->scale_factor, scale_factor);
    geomapimage->scale_factor--;
  }
  {
    BITCODE_B show_rotation;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "show_rotation", &show_rotation, NULL)
        && show_rotation == geomapimage->show_rotation)
      pass ();
    else
      fail ("GEOMAPIMAGE.show_rotation [B] " FORMAT_B " != " FORMAT_B "", geomapimage->show_rotation, show_rotation);
    show_rotation++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "show_rotation", &show_rotation, 0)
        && show_rotation == geomapimage->show_rotation)
      pass ();
    else
      fail ("GEOMAPIMAGE.show_rotation [B] set+1 " FORMAT_B " != " FORMAT_B "", geomapimage->show_rotation, show_rotation);
    geomapimage->show_rotation--;
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "size", &size, NULL)
        && !memcmp (&size, &geomapimage->size, sizeof (geomapimage->size)))
        pass ();
    else
        fail ("GEOMAPIMAGE.size [2RD]");
  }
  {
    BITCODE_BS transparency;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "transparency", &transparency, NULL)
        && transparency == geomapimage->transparency)
      pass ();
    else
      fail ("GEOMAPIMAGE.transparency [BS] %hu != %hu", geomapimage->transparency, transparency);
    transparency++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "transparency", &transparency, 0)
        && transparency == geomapimage->transparency)
      pass ();
    else
      fail ("GEOMAPIMAGE.transparency [BS] set+1 %hu != %hu", geomapimage->transparency, transparency);
    geomapimage->transparency--;
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "width", &width, NULL)
        && width == geomapimage->width)
      pass ();
    else
      fail ("GEOMAPIMAGE.width [BD] %g != %g", geomapimage->width, width);
    width++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "width", &width, 0)
        && width == geomapimage->width)
      pass ();
    else
      fail ("GEOMAPIMAGE.width [BD] set+1 %g != %g", geomapimage->width, width);
    geomapimage->width--;
  }
  if (failed && (is_class_unstable ("GEOMAPIMAGE") || is_class_debugging ("GEOMAPIMAGE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GEOMAPIMAGE", failed);
      failed = 0;
    }
  return failed;
}
static int test_GROUP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_GROUP *restrict group = obj->tio.object->tio.GROUP;
  failed = 0;
  {
    BITCODE_H* groups;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (group, "GROUP", "num_groups", &count, NULL)
        && dwg_dynapi_entity_value (group, "GROUP", "groups", &groups, NULL)
        && groups == group->groups)
      pass ();
    else
      fail ("GROUP.groups [H*] * %u num_groups", count);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (group, "GROUP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)group->name)
           : !group->name)
      pass ();
    else
      fail ("GROUP.name [T] '%s' <> '%s'", name, group->name);
  }
  {
    BITCODE_BL num_groups;
    if (dwg_dynapi_entity_value (group, "GROUP", "num_groups", &num_groups, NULL)
        && num_groups == group->num_groups)
      pass ();
    else
      fail ("GROUP.num_groups [BL] %u != %u", group->num_groups, num_groups);
    num_groups++;
    if (dwg_dynapi_entity_set_value (group, "GROUP", "num_groups", &num_groups, 0)
        && num_groups == group->num_groups)
      pass ();
    else
      fail ("GROUP.num_groups [BL] set+1 %u != %u", group->num_groups, num_groups);
    group->num_groups--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (group, "GROUP", "parent", &parent, NULL)
        && !memcmp (&parent, &group->parent, sizeof (group->parent)))
        pass ();
    else
        fail ("GROUP.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS selectable;
    if (dwg_dynapi_entity_value (group, "GROUP", "selectable", &selectable, NULL)
        && selectable == group->selectable)
      pass ();
    else
      fail ("GROUP.selectable [BS] %hu != %hu", group->selectable, selectable);
    selectable++;
    if (dwg_dynapi_entity_set_value (group, "GROUP", "selectable", &selectable, 0)
        && selectable == group->selectable)
      pass ();
    else
      fail ("GROUP.selectable [BS] set+1 %hu != %hu", group->selectable, selectable);
    group->selectable--;
  }
  {
    BITCODE_BS unnamed;
    if (dwg_dynapi_entity_value (group, "GROUP", "unnamed", &unnamed, NULL)
        && unnamed == group->unnamed)
      pass ();
    else
      fail ("GROUP.unnamed [BS] %hu != %hu", group->unnamed, unnamed);
    unnamed++;
    if (dwg_dynapi_entity_set_value (group, "GROUP", "unnamed", &unnamed, 0)
        && unnamed == group->unnamed)
      pass ();
    else
      fail ("GROUP.unnamed [BS] set+1 %hu != %hu", group->unnamed, unnamed);
    group->unnamed--;
  }
  if (failed && (is_class_unstable ("GROUP") || is_class_debugging ("GROUP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GROUP", failed);
      failed = 0;
    }
  return failed;
}
static int test_IDBUFFER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_IDBUFFER *restrict idbuffer = obj->tio.object->tio.IDBUFFER;
  failed = 0;
  {
    BITCODE_BL num_obj_ids;
    if (dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "num_obj_ids", &num_obj_ids, NULL)
        && num_obj_ids == idbuffer->num_obj_ids)
      pass ();
    else
      fail ("IDBUFFER.num_obj_ids [BL] %u != %u", idbuffer->num_obj_ids, num_obj_ids);
    num_obj_ids++;
    if (dwg_dynapi_entity_set_value (idbuffer, "IDBUFFER", "num_obj_ids", &num_obj_ids, 0)
        && num_obj_ids == idbuffer->num_obj_ids)
      pass ();
    else
      fail ("IDBUFFER.num_obj_ids [BL] set+1 %u != %u", idbuffer->num_obj_ids, num_obj_ids);
    idbuffer->num_obj_ids--;
  }
  {
    BITCODE_H* obj_ids;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "num_obj_ids", &count, NULL)
        && dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "obj_ids", &obj_ids, NULL)
        && obj_ids == idbuffer->obj_ids)
      pass ();
    else
      fail ("IDBUFFER.obj_ids [H*] * %u num_obj_ids", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "parent", &parent, NULL)
        && !memcmp (&parent, &idbuffer->parent, sizeof (idbuffer->parent)))
        pass ();
    else
        fail ("IDBUFFER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "unknown", &unknown, NULL)
        && unknown == idbuffer->unknown)
      pass ();
    else
      fail ("IDBUFFER.unknown [RC] %u != %u", idbuffer->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (idbuffer, "IDBUFFER", "unknown", &unknown, 0)
        && unknown == idbuffer->unknown)
      pass ();
    else
      fail ("IDBUFFER.unknown [RC] set+1 %u != %u", idbuffer->unknown, unknown);
    idbuffer->unknown--;
  }
  if (failed && (is_class_unstable ("IDBUFFER") || is_class_debugging ("IDBUFFER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IDBUFFER", failed);
      failed = 0;
    }
  return failed;
}
static int test_IMAGEDEF (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_IMAGEDEF *restrict imagedef = obj->tio.object->tio.IMAGEDEF;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "class_version", &class_version, NULL)
        && class_version == imagedef->class_version)
      pass ();
    else
      fail ("IMAGEDEF.class_version [BL] %u != %u", imagedef->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (imagedef, "IMAGEDEF", "class_version", &class_version, 0)
        && class_version == imagedef->class_version)
      pass ();
    else
      fail ("IMAGEDEF.class_version [BL] set+1 %u != %u", imagedef->class_version, class_version);
    imagedef->class_version--;
  }
  {
    BITCODE_T file_path;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "file_path", &file_path, NULL)
        && file_path
           ? strEQ ((char *)file_path, (char *)imagedef->file_path)
           : !imagedef->file_path)
      pass ();
    else
      fail ("IMAGEDEF.file_path [T] '%s' <> '%s'", file_path, imagedef->file_path);
  }
  {
    BITCODE_2RD image_size;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "image_size", &image_size, NULL)
        && !memcmp (&image_size, &imagedef->image_size, sizeof (imagedef->image_size)))
        pass ();
    else
        fail ("IMAGEDEF.image_size [2RD]");
  }
  {
    BITCODE_B is_loaded;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "is_loaded", &is_loaded, NULL)
        && is_loaded == imagedef->is_loaded)
      pass ();
    else
      fail ("IMAGEDEF.is_loaded [B] " FORMAT_B " != " FORMAT_B "", imagedef->is_loaded, is_loaded);
    is_loaded++;
    if (dwg_dynapi_entity_set_value (imagedef, "IMAGEDEF", "is_loaded", &is_loaded, 0)
        && is_loaded == imagedef->is_loaded)
      pass ();
    else
      fail ("IMAGEDEF.is_loaded [B] set+1 " FORMAT_B " != " FORMAT_B "", imagedef->is_loaded, is_loaded);
    imagedef->is_loaded--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "parent", &parent, NULL)
        && !memcmp (&parent, &imagedef->parent, sizeof (imagedef->parent)))
        pass ();
    else
        fail ("IMAGEDEF.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_2RD pixel_size;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "pixel_size", &pixel_size, NULL)
        && !memcmp (&pixel_size, &imagedef->pixel_size, sizeof (imagedef->pixel_size)))
        pass ();
    else
        fail ("IMAGEDEF.pixel_size [2RD]");
  }
  {
    BITCODE_RC resunits;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "resunits", &resunits, NULL)
        && resunits == imagedef->resunits)
      pass ();
    else
      fail ("IMAGEDEF.resunits [RC] %u != %u", imagedef->resunits, resunits);
    resunits++;
    if (dwg_dynapi_entity_set_value (imagedef, "IMAGEDEF", "resunits", &resunits, 0)
        && resunits == imagedef->resunits)
      pass ();
    else
      fail ("IMAGEDEF.resunits [RC] set+1 %u != %u", imagedef->resunits, resunits);
    imagedef->resunits--;
  }
  if (failed && (is_class_unstable ("IMAGEDEF") || is_class_debugging ("IMAGEDEF")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IMAGEDEF", failed);
      failed = 0;
    }
  return failed;
}
static int test_IMAGEDEF_REACTOR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_IMAGEDEF_REACTOR *restrict imagedef_reactor = obj->tio.object->tio.IMAGEDEF_REACTOR;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (imagedef_reactor, "IMAGEDEF_REACTOR", "class_version", &class_version, NULL)
        && class_version == imagedef_reactor->class_version)
      pass ();
    else
      fail ("IMAGEDEF_REACTOR.class_version [BL] %u != %u", imagedef_reactor->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (imagedef_reactor, "IMAGEDEF_REACTOR", "class_version", &class_version, 0)
        && class_version == imagedef_reactor->class_version)
      pass ();
    else
      fail ("IMAGEDEF_REACTOR.class_version [BL] set+1 %u != %u", imagedef_reactor->class_version, class_version);
    imagedef_reactor->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (imagedef_reactor, "IMAGEDEF_REACTOR", "parent", &parent, NULL)
        && !memcmp (&parent, &imagedef_reactor->parent, sizeof (imagedef_reactor->parent)))
        pass ();
    else
        fail ("IMAGEDEF_REACTOR.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("IMAGEDEF_REACTOR") || is_class_debugging ("IMAGEDEF_REACTOR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IMAGEDEF_REACTOR", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYER *restrict layer = obj->tio.object->tio.LAYER;
  failed = 0;
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (layer, "LAYER", "color", &color, NULL)
        && !memcmp (&color, &layer->color, sizeof (layer->color)))
        pass ();
    else
        fail ("LAYER.color [CMC]");
  }
  {
    short color_rs;
    if (dwg_dynapi_entity_value (layer, "LAYER", "color_rs", &color_rs, NULL)
        && color_rs == layer->color_rs)
      pass ();
    else
      fail ("LAYER.color_rs [short] %hd != %hd", layer->color_rs, color_rs);
    color_rs++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "color_rs", &color_rs, 0)
        && color_rs == layer->color_rs)
      pass ();
    else
      fail ("LAYER.color_rs [short] set+1 %hd != %hd", layer->color_rs, color_rs);
    layer->color_rs--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (layer, "LAYER", "flag", &flag, NULL)
        && flag == layer->flag)
      pass ();
    else
      fail ("LAYER.flag [BS] %hu != %hu", layer->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "flag", &flag, 0)
        && flag == layer->flag)
      pass ();
    else
      fail ("LAYER.flag [BS] set+1 %hu != %hu", layer->flag, flag);
    layer->flag--;
  }
  {
    BITCODE_B frozen;
    if (dwg_dynapi_entity_value (layer, "LAYER", "frozen", &frozen, NULL)
        && frozen == layer->frozen)
      pass ();
    else
      fail ("LAYER.frozen [B] " FORMAT_B " != " FORMAT_B "", layer->frozen, frozen);
    frozen++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "frozen", &frozen, 0)
        && frozen == layer->frozen)
      pass ();
    else
      fail ("LAYER.frozen [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->frozen, frozen);
    layer->frozen--;
  }
  {
    BITCODE_B frozen_in_new;
    if (dwg_dynapi_entity_value (layer, "LAYER", "frozen_in_new", &frozen_in_new, NULL)
        && frozen_in_new == layer->frozen_in_new)
      pass ();
    else
      fail ("LAYER.frozen_in_new [B] " FORMAT_B " != " FORMAT_B "", layer->frozen_in_new, frozen_in_new);
    frozen_in_new++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "frozen_in_new", &frozen_in_new, 0)
        && frozen_in_new == layer->frozen_in_new)
      pass ();
    else
      fail ("LAYER.frozen_in_new [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->frozen_in_new, frozen_in_new);
    layer->frozen_in_new--;
  }
  {
    BITCODE_RC linewt;
    if (dwg_dynapi_entity_value (layer, "LAYER", "linewt", &linewt, NULL)
        && linewt == layer->linewt)
      pass ();
    else
      fail ("LAYER.linewt [RC] %u != %u", layer->linewt, linewt);
    linewt++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "linewt", &linewt, 0)
        && linewt == layer->linewt)
      pass ();
    else
      fail ("LAYER.linewt [RC] set+1 %u != %u", layer->linewt, linewt);
    layer->linewt--;
  }
  {
    BITCODE_B locked;
    if (dwg_dynapi_entity_value (layer, "LAYER", "locked", &locked, NULL)
        && locked == layer->locked)
      pass ();
    else
      fail ("LAYER.locked [B] " FORMAT_B " != " FORMAT_B "", layer->locked, locked);
    locked++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "locked", &locked, 0)
        && locked == layer->locked)
      pass ();
    else
      fail ("LAYER.locked [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->locked, locked);
    layer->locked--;
  }
  {
    BITCODE_H ltype;
    if (dwg_dynapi_entity_value (layer, "LAYER", "ltype", &ltype, NULL)
        && !memcmp (&ltype, &layer->ltype, sizeof (layer->ltype)))
        pass ();
    else
        fail ("LAYER.ltype [H]");
  }
  {
    BITCODE_RS ltype_rs;
    if (dwg_dynapi_entity_value (layer, "LAYER", "ltype_rs", &ltype_rs, NULL)
        && ltype_rs == layer->ltype_rs)
      pass ();
    else
      fail ("LAYER.ltype_rs [RS] %hu != %hu", layer->ltype_rs, ltype_rs);
    ltype_rs++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "ltype_rs", &ltype_rs, 0)
        && ltype_rs == layer->ltype_rs)
      pass ();
    else
      fail ("LAYER.ltype_rs [RS] set+1 %hu != %hu", layer->ltype_rs, ltype_rs);
    layer->ltype_rs--;
  }
  {
    BITCODE_H material;
    if (dwg_dynapi_entity_value (layer, "LAYER", "material", &material, NULL)
        && !memcmp (&material, &layer->material, sizeof (layer->material)))
        pass ();
    else
        fail ("LAYER.material [H]");
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (layer, "LAYER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)layer->name)
           : !layer->name)
      pass ();
    else
      fail ("LAYER.name [TV] '%s' <> '%s'", name, layer->name);
  }
  {
    BITCODE_B on;
    if (dwg_dynapi_entity_value (layer, "LAYER", "on", &on, NULL)
        && on == layer->on)
      pass ();
    else
      fail ("LAYER.on [B] " FORMAT_B " != " FORMAT_B "", layer->on, on);
    on++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "on", &on, 0)
        && on == layer->on)
      pass ();
    else
      fail ("LAYER.on [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->on, on);
    layer->on--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layer, "LAYER", "parent", &parent, NULL)
        && !memcmp (&parent, &layer->parent, sizeof (layer->parent)))
        pass ();
    else
        fail ("LAYER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B plotflag;
    if (dwg_dynapi_entity_value (layer, "LAYER", "plotflag", &plotflag, NULL)
        && plotflag == layer->plotflag)
      pass ();
    else
      fail ("LAYER.plotflag [B] " FORMAT_B " != " FORMAT_B "", layer->plotflag, plotflag);
    plotflag++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "plotflag", &plotflag, 0)
        && plotflag == layer->plotflag)
      pass ();
    else
      fail ("LAYER.plotflag [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->plotflag, plotflag);
    layer->plotflag--;
  }
  {
    BITCODE_H plotstyle;
    if (dwg_dynapi_entity_value (layer, "LAYER", "plotstyle", &plotstyle, NULL)
        && !memcmp (&plotstyle, &layer->plotstyle, sizeof (layer->plotstyle)))
        pass ();
    else
        fail ("LAYER.plotstyle [H]");
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (layer, "LAYER", "used", &used, NULL)
        && used == layer->used)
      pass ();
    else
      fail ("LAYER.used [RS] %hu != %hu", layer->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "used", &used, 0)
        && used == layer->used)
      pass ();
    else
      fail ("LAYER.used [RS] set+1 %hu != %hu", layer->used, used);
    layer->used--;
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (layer, "LAYER", "xref", &xref, NULL)
        && !memcmp (&xref, &layer->xref, sizeof (layer->xref)))
        pass ();
    else
        fail ("LAYER.xref [H]");
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (layer, "LAYER", "xrefdep", &xrefdep, NULL)
        && xrefdep == layer->xrefdep)
      pass ();
    else
      fail ("LAYER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", layer->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "xrefdep", &xrefdep, 0)
        && xrefdep == layer->xrefdep)
      pass ();
    else
      fail ("LAYER.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->xrefdep, xrefdep);
    layer->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (layer, "LAYER", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == layer->xrefindex_plus1)
      pass ();
    else
      fail ("LAYER.xrefindex_plus1 [BS] %hu != %hu", layer->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == layer->xrefindex_plus1)
      pass ();
    else
      fail ("LAYER.xrefindex_plus1 [BS] set+1 %hu != %hu", layer->xrefindex_plus1, xrefindex_plus1);
    layer->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (layer, "LAYER", "xrefref", &xrefref, NULL)
        && xrefref == layer->xrefref)
      pass ();
    else
      fail ("LAYER.xrefref [B] " FORMAT_B " != " FORMAT_B "", layer->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "xrefref", &xrefref, 0)
        && xrefref == layer->xrefref)
      pass ();
    else
      fail ("LAYER.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->xrefref, xrefref);
    layer->xrefref--;
  }
  if (failed && (is_class_unstable ("LAYER") || is_class_debugging ("LAYER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYER", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYER_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYER_CONTROL *restrict layer_control = obj->tio.object->tio.LAYER_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "entries", &entries, NULL)
        && entries == layer_control->entries)
      pass ();
    else
      fail ("LAYER_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == layer_control->num_entries)
      pass ();
    else
      fail ("LAYER_CONTROL.num_entries [BS] %hu != %hu", layer_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (layer_control, "LAYER_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == layer_control->num_entries)
      pass ();
    else
      fail ("LAYER_CONTROL.num_entries [BS] set+1 %hu != %hu", layer_control->num_entries, num_entries);
    layer_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "objid", &objid, NULL)
        && objid == layer_control->objid)
      pass ();
    else
      fail ("LAYER_CONTROL.objid [BL] %u != %u", layer_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (layer_control, "LAYER_CONTROL", "objid", &objid, 0)
        && objid == layer_control->objid)
      pass ();
    else
      fail ("LAYER_CONTROL.objid [BL] set+1 %u != %u", layer_control->objid, objid);
    layer_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &layer_control->parent, sizeof (layer_control->parent)))
        pass ();
    else
        fail ("LAYER_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LAYER_CONTROL") || is_class_debugging ("LAYER_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYER_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYER_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYER_INDEX *restrict layer_index = obj->tio.object->tio.LAYER_INDEX;
  failed = 0;
  {
    Dwg_LAYER_entry* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "entries", &entries, NULL)
        && entries == layer_index->entries)
      pass ();
    else
      fail ("LAYER_INDEX.entries [Dwg_LAYER_entry*] * %u num_entries", count);
  }
  {
    BITCODE_H* layer_entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "layer_entries", &layer_entries, NULL)
        && layer_entries == layer_index->layer_entries)
      pass ();
    else
      fail ("LAYER_INDEX.layer_entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BL num_entries;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "num_entries", &num_entries, NULL)
        && num_entries == layer_index->num_entries)
      pass ();
    else
      fail ("LAYER_INDEX.num_entries [BL] %u != %u", layer_index->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (layer_index, "LAYER_INDEX", "num_entries", &num_entries, 0)
        && num_entries == layer_index->num_entries)
      pass ();
    else
      fail ("LAYER_INDEX.num_entries [BL] set+1 %u != %u", layer_index->num_entries, num_entries);
    layer_index->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "parent", &parent, NULL)
        && !memcmp (&parent, &layer_index->parent, sizeof (layer_index->parent)))
        pass ();
    else
        fail ("LAYER_INDEX.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL timestamp1;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "timestamp1", &timestamp1, NULL)
        && timestamp1 == layer_index->timestamp1)
      pass ();
    else
      fail ("LAYER_INDEX.timestamp1 [BL] %u != %u", layer_index->timestamp1, timestamp1);
    timestamp1++;
    if (dwg_dynapi_entity_set_value (layer_index, "LAYER_INDEX", "timestamp1", &timestamp1, 0)
        && timestamp1 == layer_index->timestamp1)
      pass ();
    else
      fail ("LAYER_INDEX.timestamp1 [BL] set+1 %u != %u", layer_index->timestamp1, timestamp1);
    layer_index->timestamp1--;
  }
  {
    BITCODE_BL timestamp2;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "timestamp2", &timestamp2, NULL)
        && timestamp2 == layer_index->timestamp2)
      pass ();
    else
      fail ("LAYER_INDEX.timestamp2 [BL] %u != %u", layer_index->timestamp2, timestamp2);
    timestamp2++;
    if (dwg_dynapi_entity_set_value (layer_index, "LAYER_INDEX", "timestamp2", &timestamp2, 0)
        && timestamp2 == layer_index->timestamp2)
      pass ();
    else
      fail ("LAYER_INDEX.timestamp2 [BL] set+1 %u != %u", layer_index->timestamp2, timestamp2);
    layer_index->timestamp2--;
  }
  if (failed && (is_class_unstable ("LAYER_INDEX") || is_class_debugging ("LAYER_INDEX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYER_INDEX", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYOUT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYOUT *restrict layout = obj->tio.object->tio.LAYOUT;
  failed = 0;
  {
    BITCODE_H active_viewport;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "active_viewport", &active_viewport, NULL)
        && !memcmp (&active_viewport, &layout->active_viewport, sizeof (layout->active_viewport)))
        pass ();
    else
        fail ("LAYOUT.active_viewport [H]");
  }
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &layout->base_ucs, sizeof (layout->base_ucs)))
        pass ();
    else
        fail ("LAYOUT.base_ucs [H]");
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "block_header", &block_header, NULL)
        && !memcmp (&block_header, &layout->block_header, sizeof (layout->block_header)))
        pass ();
    else
        fail ("LAYOUT.block_header [H]");
  }
  {
    BITCODE_BD bottom_margin;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "bottom_margin", &bottom_margin, NULL)
        && bottom_margin == layout->bottom_margin)
      pass ();
    else
      fail ("LAYOUT.bottom_margin [BD] %g != %g", layout->bottom_margin, bottom_margin);
    bottom_margin++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "bottom_margin", &bottom_margin, 0)
        && bottom_margin == layout->bottom_margin)
      pass ();
    else
      fail ("LAYOUT.bottom_margin [BD] set+1 %g != %g", layout->bottom_margin, bottom_margin);
    layout->bottom_margin--;
  }
  {
    BITCODE_T current_style_sheet;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "current_style_sheet", &current_style_sheet, NULL)
        && current_style_sheet
           ? strEQ ((char *)current_style_sheet, (char *)layout->current_style_sheet)
           : !layout->current_style_sheet)
      pass ();
    else
      fail ("LAYOUT.current_style_sheet [T] '%s' <> '%s'", current_style_sheet, layout->current_style_sheet);
  }
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "drawing_units", &drawing_units, NULL)
        && drawing_units == layout->drawing_units)
      pass ();
    else
      fail ("LAYOUT.drawing_units [BD] %g != %g", layout->drawing_units, drawing_units);
    drawing_units++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "drawing_units", &drawing_units, 0)
        && drawing_units == layout->drawing_units)
      pass ();
    else
      fail ("LAYOUT.drawing_units [BD] set+1 %g != %g", layout->drawing_units, drawing_units);
    layout->drawing_units--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "elevation", &elevation, NULL)
        && elevation == layout->elevation)
      pass ();
    else
      fail ("LAYOUT.elevation [BD] %g != %g", layout->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "elevation", &elevation, 0)
        && elevation == layout->elevation)
      pass ();
    else
      fail ("LAYOUT.elevation [BD] set+1 %g != %g", layout->elevation, elevation);
    layout->elevation--;
  }
  {
    BITCODE_3DPOINT extent_max;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "extent_max", &extent_max, NULL)
        && !memcmp (&extent_max, &layout->extent_max, sizeof (layout->extent_max)))
        pass ();
    else
        fail ("LAYOUT.extent_max [3DPOINT]");
  }
  {
    BITCODE_3DPOINT extent_min;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "extent_min", &extent_min, NULL)
        && !memcmp (&extent_min, &layout->extent_min, sizeof (layout->extent_min)))
        pass ();
    else
        fail ("LAYOUT.extent_min [3DPOINT]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "flag", &flag, NULL)
        && flag == layout->flag)
      pass ();
    else
      fail ("LAYOUT.flag [BS] %hu != %hu", layout->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "flag", &flag, 0)
        && flag == layout->flag)
      pass ();
    else
      fail ("LAYOUT.flag [BS] set+1 %hu != %hu", layout->flag, flag);
    layout->flag--;
  }
  {
    BITCODE_3DPOINT ins_point;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "ins_point", &ins_point, NULL)
        && !memcmp (&ins_point, &layout->ins_point, sizeof (layout->ins_point)))
        pass ();
    else
        fail ("LAYOUT.ins_point [3DPOINT]");
  }
  {
    BITCODE_T layout_name;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "layout_name", &layout_name, NULL)
        && layout_name
           ? strEQ ((char *)layout_name, (char *)layout->layout_name)
           : !layout->layout_name)
      pass ();
    else
      fail ("LAYOUT.layout_name [T] '%s' <> '%s'", layout_name, layout->layout_name);
  }
  {
    BITCODE_BD left_margin;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "left_margin", &left_margin, NULL)
        && left_margin == layout->left_margin)
      pass ();
    else
      fail ("LAYOUT.left_margin [BD] %g != %g", layout->left_margin, left_margin);
    left_margin++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "left_margin", &left_margin, 0)
        && left_margin == layout->left_margin)
      pass ();
    else
      fail ("LAYOUT.left_margin [BD] set+1 %g != %g", layout->left_margin, left_margin);
    layout->left_margin--;
  }
  {
    BITCODE_2DPOINT maximum_limits;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "maximum_limits", &maximum_limits, NULL)
        && !memcmp (&maximum_limits, &layout->maximum_limits, sizeof (layout->maximum_limits)))
        pass ();
    else
        fail ("LAYOUT.maximum_limits [2DPOINT]");
  }
  {
    BITCODE_2DPOINT minimum_limits;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "minimum_limits", &minimum_limits, NULL)
        && !memcmp (&minimum_limits, &layout->minimum_limits, sizeof (layout->minimum_limits)))
        pass ();
    else
        fail ("LAYOUT.minimum_limits [2DPOINT]");
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &layout->named_ucs, sizeof (layout->named_ucs)))
        pass ();
    else
        fail ("LAYOUT.named_ucs [H]");
  }
  {
    BITCODE_BL num_viewports;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "num_viewports", &num_viewports, NULL)
        && num_viewports == layout->num_viewports)
      pass ();
    else
      fail ("LAYOUT.num_viewports [BL] %u != %u", layout->num_viewports, num_viewports);
    num_viewports++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "num_viewports", &num_viewports, 0)
        && num_viewports == layout->num_viewports)
      pass ();
    else
      fail ("LAYOUT.num_viewports [BL] set+1 %u != %u", layout->num_viewports, num_viewports);
    layout->num_viewports--;
  }
  {
    BITCODE_BS orthoview_type;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "orthoview_type", &orthoview_type, NULL)
        && orthoview_type == layout->orthoview_type)
      pass ();
    else
      fail ("LAYOUT.orthoview_type [BS] %hu != %hu", layout->orthoview_type, orthoview_type);
    orthoview_type++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "orthoview_type", &orthoview_type, 0)
        && orthoview_type == layout->orthoview_type)
      pass ();
    else
      fail ("LAYOUT.orthoview_type [BS] set+1 %hu != %hu", layout->orthoview_type, orthoview_type);
    layout->orthoview_type--;
  }
  {
    BITCODE_T page_setup_name;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "page_setup_name", &page_setup_name, NULL)
        && page_setup_name
           ? strEQ ((char *)page_setup_name, (char *)layout->page_setup_name)
           : !layout->page_setup_name)
      pass ();
    else
      fail ("LAYOUT.page_setup_name [T] '%s' <> '%s'", page_setup_name, layout->page_setup_name);
  }
  {
    BITCODE_BD paper_height;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "paper_height", &paper_height, NULL)
        && paper_height == layout->paper_height)
      pass ();
    else
      fail ("LAYOUT.paper_height [BD] %g != %g", layout->paper_height, paper_height);
    paper_height++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "paper_height", &paper_height, 0)
        && paper_height == layout->paper_height)
      pass ();
    else
      fail ("LAYOUT.paper_height [BD] set+1 %g != %g", layout->paper_height, paper_height);
    layout->paper_height--;
  }
  {
    BITCODE_2BD paper_image_origin;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "paper_image_origin", &paper_image_origin, NULL)
        && !memcmp (&paper_image_origin, &layout->paper_image_origin, sizeof (layout->paper_image_origin)))
        pass ();
    else
        fail ("LAYOUT.paper_image_origin [2BD_1]");
  }
  {
    BITCODE_T paper_size;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "paper_size", &paper_size, NULL)
        && paper_size
           ? strEQ ((char *)paper_size, (char *)layout->paper_size)
           : !layout->paper_size)
      pass ();
    else
      fail ("LAYOUT.paper_size [T] '%s' <> '%s'", paper_size, layout->paper_size);
  }
  {
    BITCODE_BD paper_units;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "paper_units", &paper_units, NULL)
        && paper_units == layout->paper_units)
      pass ();
    else
      fail ("LAYOUT.paper_units [BD] %g != %g", layout->paper_units, paper_units);
    paper_units++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "paper_units", &paper_units, 0)
        && paper_units == layout->paper_units)
      pass ();
    else
      fail ("LAYOUT.paper_units [BD] set+1 %g != %g", layout->paper_units, paper_units);
    layout->paper_units--;
  }
  {
    BITCODE_BD paper_width;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "paper_width", &paper_width, NULL)
        && paper_width == layout->paper_width)
      pass ();
    else
      fail ("LAYOUT.paper_width [BD] %g != %g", layout->paper_width, paper_width);
    paper_width++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "paper_width", &paper_width, 0)
        && paper_width == layout->paper_width)
      pass ();
    else
      fail ("LAYOUT.paper_width [BD] set+1 %g != %g", layout->paper_width, paper_width);
    layout->paper_width--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "parent", &parent, NULL)
        && !memcmp (&parent, &layout->parent, sizeof (layout->parent)))
        pass ();
    else
        fail ("LAYOUT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS plot_layout_flags;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plot_layout_flags", &plot_layout_flags, NULL)
        && plot_layout_flags == layout->plot_layout_flags)
      pass ();
    else
      fail ("LAYOUT.plot_layout_flags [BS] %hu != %hu", layout->plot_layout_flags, plot_layout_flags);
    plot_layout_flags++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "plot_layout_flags", &plot_layout_flags, 0)
        && plot_layout_flags == layout->plot_layout_flags)
      pass ();
    else
      fail ("LAYOUT.plot_layout_flags [BS] set+1 %hu != %hu", layout->plot_layout_flags, plot_layout_flags);
    layout->plot_layout_flags--;
  }
  {
    BITCODE_2BD plot_origin;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plot_origin", &plot_origin, NULL)
        && !memcmp (&plot_origin, &layout->plot_origin, sizeof (layout->plot_origin)))
        pass ();
    else
        fail ("LAYOUT.plot_origin [2BD_1]");
  }
  {
    BITCODE_BS plot_paper_unit;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plot_paper_unit", &plot_paper_unit, NULL)
        && plot_paper_unit == layout->plot_paper_unit)
      pass ();
    else
      fail ("LAYOUT.plot_paper_unit [BS] %hu != %hu", layout->plot_paper_unit, plot_paper_unit);
    plot_paper_unit++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "plot_paper_unit", &plot_paper_unit, 0)
        && plot_paper_unit == layout->plot_paper_unit)
      pass ();
    else
      fail ("LAYOUT.plot_paper_unit [BS] set+1 %hu != %hu", layout->plot_paper_unit, plot_paper_unit);
    layout->plot_paper_unit--;
  }
  {
    BITCODE_BS plot_rotation;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plot_rotation", &plot_rotation, NULL)
        && plot_rotation == layout->plot_rotation)
      pass ();
    else
      fail ("LAYOUT.plot_rotation [BS] %hu != %hu", layout->plot_rotation, plot_rotation);
    plot_rotation++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "plot_rotation", &plot_rotation, 0)
        && plot_rotation == layout->plot_rotation)
      pass ();
    else
      fail ("LAYOUT.plot_rotation [BS] set+1 %hu != %hu", layout->plot_rotation, plot_rotation);
    layout->plot_rotation--;
  }
  {
    BITCODE_BS plot_type;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plot_type", &plot_type, NULL)
        && plot_type == layout->plot_type)
      pass ();
    else
      fail ("LAYOUT.plot_type [BS] %hu != %hu", layout->plot_type, plot_type);
    plot_type++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "plot_type", &plot_type, 0)
        && plot_type == layout->plot_type)
      pass ();
    else
      fail ("LAYOUT.plot_type [BS] set+1 %hu != %hu", layout->plot_type, plot_type);
    layout->plot_type--;
  }
  {
    BITCODE_TV plot_view_name;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plot_view_name", &plot_view_name, NULL)
        && plot_view_name
           ? strEQ ((char *)plot_view_name, (char *)layout->plot_view_name)
           : !layout->plot_view_name)
      pass ();
    else
      fail ("LAYOUT.plot_view_name [TV] '%s' <> '%s'", plot_view_name, layout->plot_view_name);
  }
  {
    BITCODE_2BD plot_window_ll;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plot_window_ll", &plot_window_ll, NULL)
        && !memcmp (&plot_window_ll, &layout->plot_window_ll, sizeof (layout->plot_window_ll)))
        pass ();
    else
        fail ("LAYOUT.plot_window_ll [2BD_1]");
  }
  {
    BITCODE_2BD plot_window_ur;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plot_window_ur", &plot_window_ur, NULL)
        && !memcmp (&plot_window_ur, &layout->plot_window_ur, sizeof (layout->plot_window_ur)))
        pass ();
    else
        fail ("LAYOUT.plot_window_ur [2BD_1]");
  }
  {
    BITCODE_H plotview;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plotview", &plotview, NULL)
        && !memcmp (&plotview, &layout->plotview, sizeof (layout->plotview)))
        pass ();
    else
        fail ("LAYOUT.plotview [H]");
  }
  {
    BITCODE_T printer_or_config;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "printer_or_config", &printer_or_config, NULL)
        && printer_or_config
           ? strEQ ((char *)printer_or_config, (char *)layout->printer_or_config)
           : !layout->printer_or_config)
      pass ();
    else
      fail ("LAYOUT.printer_or_config [T] '%s' <> '%s'", printer_or_config, layout->printer_or_config);
  }
  {
    BITCODE_BD right_margin;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "right_margin", &right_margin, NULL)
        && right_margin == layout->right_margin)
      pass ();
    else
      fail ("LAYOUT.right_margin [BD] %g != %g", layout->right_margin, right_margin);
    right_margin++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "right_margin", &right_margin, 0)
        && right_margin == layout->right_margin)
      pass ();
    else
      fail ("LAYOUT.right_margin [BD] set+1 %g != %g", layout->right_margin, right_margin);
    layout->right_margin--;
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "scale_factor", &scale_factor, NULL)
        && scale_factor == layout->scale_factor)
      pass ();
    else
      fail ("LAYOUT.scale_factor [BD] %g != %g", layout->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "scale_factor", &scale_factor, 0)
        && scale_factor == layout->scale_factor)
      pass ();
    else
      fail ("LAYOUT.scale_factor [BD] set+1 %g != %g", layout->scale_factor, scale_factor);
    layout->scale_factor--;
  }
  {
    BITCODE_BS scale_type;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "scale_type", &scale_type, NULL)
        && scale_type == layout->scale_type)
      pass ();
    else
      fail ("LAYOUT.scale_type [BS] %hu != %hu", layout->scale_type, scale_type);
    scale_type++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "scale_type", &scale_type, 0)
        && scale_type == layout->scale_type)
      pass ();
    else
      fail ("LAYOUT.scale_type [BS] set+1 %hu != %hu", layout->scale_type, scale_type);
    layout->scale_type--;
  }
  {
    BITCODE_BS shade_plot_customdpi;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "shade_plot_customdpi", &shade_plot_customdpi, NULL)
        && shade_plot_customdpi == layout->shade_plot_customdpi)
      pass ();
    else
      fail ("LAYOUT.shade_plot_customdpi [BS] %hu != %hu", layout->shade_plot_customdpi, shade_plot_customdpi);
    shade_plot_customdpi++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "shade_plot_customdpi", &shade_plot_customdpi, 0)
        && shade_plot_customdpi == layout->shade_plot_customdpi)
      pass ();
    else
      fail ("LAYOUT.shade_plot_customdpi [BS] set+1 %hu != %hu", layout->shade_plot_customdpi, shade_plot_customdpi);
    layout->shade_plot_customdpi--;
  }
  {
    BITCODE_BS shade_plot_mode;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "shade_plot_mode", &shade_plot_mode, NULL)
        && shade_plot_mode == layout->shade_plot_mode)
      pass ();
    else
      fail ("LAYOUT.shade_plot_mode [BS] %hu != %hu", layout->shade_plot_mode, shade_plot_mode);
    shade_plot_mode++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "shade_plot_mode", &shade_plot_mode, 0)
        && shade_plot_mode == layout->shade_plot_mode)
      pass ();
    else
      fail ("LAYOUT.shade_plot_mode [BS] set+1 %hu != %hu", layout->shade_plot_mode, shade_plot_mode);
    layout->shade_plot_mode--;
  }
  {
    BITCODE_BS shade_plot_reslevel;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "shade_plot_reslevel", &shade_plot_reslevel, NULL)
        && shade_plot_reslevel == layout->shade_plot_reslevel)
      pass ();
    else
      fail ("LAYOUT.shade_plot_reslevel [BS] %hu != %hu", layout->shade_plot_reslevel, shade_plot_reslevel);
    shade_plot_reslevel++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "shade_plot_reslevel", &shade_plot_reslevel, 0)
        && shade_plot_reslevel == layout->shade_plot_reslevel)
      pass ();
    else
      fail ("LAYOUT.shade_plot_reslevel [BS] set+1 %hu != %hu", layout->shade_plot_reslevel, shade_plot_reslevel);
    layout->shade_plot_reslevel--;
  }
  {
    BITCODE_BS tab_order;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "tab_order", &tab_order, NULL)
        && tab_order == layout->tab_order)
      pass ();
    else
      fail ("LAYOUT.tab_order [BS] %hu != %hu", layout->tab_order, tab_order);
    tab_order++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "tab_order", &tab_order, 0)
        && tab_order == layout->tab_order)
      pass ();
    else
      fail ("LAYOUT.tab_order [BS] set+1 %hu != %hu", layout->tab_order, tab_order);
    layout->tab_order--;
  }
  {
    BITCODE_BD top_margin;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "top_margin", &top_margin, NULL)
        && top_margin == layout->top_margin)
      pass ();
    else
      fail ("LAYOUT.top_margin [BD] %g != %g", layout->top_margin, top_margin);
    top_margin++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "top_margin", &top_margin, 0)
        && top_margin == layout->top_margin)
      pass ();
    else
      fail ("LAYOUT.top_margin [BD] set+1 %g != %g", layout->top_margin, top_margin);
    layout->top_margin--;
  }
  {
    BITCODE_3DPOINT ucs_origin;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp (&ucs_origin, &layout->ucs_origin, sizeof (layout->ucs_origin)))
        pass ();
    else
        fail ("LAYOUT.ucs_origin [3DPOINT]");
  }
  {
    BITCODE_3DPOINT ucs_x_axis;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp (&ucs_x_axis, &layout->ucs_x_axis, sizeof (layout->ucs_x_axis)))
        pass ();
    else
        fail ("LAYOUT.ucs_x_axis [3DPOINT]");
  }
  {
    BITCODE_3DPOINT ucs_y_axis;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp (&ucs_y_axis, &layout->ucs_y_axis, sizeof (layout->ucs_y_axis)))
        pass ();
    else
        fail ("LAYOUT.ucs_y_axis [3DPOINT]");
  }
  {
    BITCODE_H* viewports;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "num_viewports", &count, NULL)
        && dwg_dynapi_entity_value (layout, "LAYOUT", "viewports", &viewports, NULL)
        && viewports == layout->viewports)
      pass ();
    else
      fail ("LAYOUT.viewports [H*] * %u num_viewports", count);
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &layout->visualstyle, sizeof (layout->visualstyle)))
        pass ();
    else
        fail ("LAYOUT.visualstyle [H]");
  }
  if (failed && (is_class_unstable ("LAYOUT") || is_class_debugging ("LAYOUT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYOUT", failed);
      failed = 0;
    }
  return failed;
}
static int test_LEADEROBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LEADEROBJECTCONTEXTDATA *restrict leaderobjectcontextdata = obj->tio.object->tio.LEADEROBJECTCONTEXTDATA;
  failed = 0;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == leaderobjectcontextdata->class_version)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.class_version [BS] %hu != %hu", leaderobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == leaderobjectcontextdata->class_version)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", leaderobjectcontextdata->class_version, class_version);
    leaderobjectcontextdata->class_version--;
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL)
        && defaultflag == leaderobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", leaderobjectcontextdata->defaultflag, defaultflag);
    defaultflag++;
    if (dwg_dynapi_entity_set_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "defaultflag", &defaultflag, 0)
        && defaultflag == leaderobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", leaderobjectcontextdata->defaultflag, defaultflag);
    leaderobjectcontextdata->defaultflag--;
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "has_file", &has_file, NULL)
        && has_file == leaderobjectcontextdata->has_file)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", leaderobjectcontextdata->has_file, has_file);
    has_file++;
    if (dwg_dynapi_entity_set_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "has_file", &has_file, 0)
        && has_file == leaderobjectcontextdata->has_file)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", leaderobjectcontextdata->has_file, has_file);
    leaderobjectcontextdata->has_file--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &leaderobjectcontextdata->parent, sizeof (leaderobjectcontextdata->parent)))
        pass ();
    else
        fail ("LEADEROBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &leaderobjectcontextdata->scale, sizeof (leaderobjectcontextdata->scale)))
        pass ();
    else
        fail ("LEADEROBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("LEADEROBJECTCONTEXTDATA") || is_class_debugging ("LEADEROBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LEADEROBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_LIGHTLIST (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LIGHTLIST *restrict lightlist = obj->tio.object->tio.LIGHTLIST;
  failed = 0;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "class_version", &class_version, NULL)
        && class_version == lightlist->class_version)
      pass ();
    else
      fail ("LIGHTLIST.class_version [BS] %hu != %hu", lightlist->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (lightlist, "LIGHTLIST", "class_version", &class_version, 0)
        && class_version == lightlist->class_version)
      pass ();
    else
      fail ("LIGHTLIST.class_version [BS] set+1 %hu != %hu", lightlist->class_version, class_version);
    lightlist->class_version--;
  }
  {
    BITCODE_H dictionary;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "dictionary", &dictionary, NULL)
        && !memcmp (&dictionary, &lightlist->dictionary, sizeof (lightlist->dictionary)))
        pass ();
    else
        fail ("LIGHTLIST.dictionary [H]");
  }
  {
    BITCODE_H* lights_handles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "num_lights_handles", &count, NULL)
        && dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "lights_handles", &lights_handles, NULL)
        && lights_handles == lightlist->lights_handles)
      pass ();
    else
      fail ("LIGHTLIST.lights_handles [H*] * %u num_lights_handles", count);
  }
  {
    BITCODE_TV* lights_names;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "num_lights_names", &count, NULL)
        && dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "lights_names", &lights_names, NULL)
        && lights_names == lightlist->lights_names)
      pass ();
    else
      fail ("LIGHTLIST.lights_names [TV*] * %u num_lights_names", count);
  }
  {
    BITCODE_BS num_lights;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "num_lights", &num_lights, NULL)
        && num_lights == lightlist->num_lights)
      pass ();
    else
      fail ("LIGHTLIST.num_lights [BS] %hu != %hu", lightlist->num_lights, num_lights);
    num_lights++;
    if (dwg_dynapi_entity_set_value (lightlist, "LIGHTLIST", "num_lights", &num_lights, 0)
        && num_lights == lightlist->num_lights)
      pass ();
    else
      fail ("LIGHTLIST.num_lights [BS] set+1 %hu != %hu", lightlist->num_lights, num_lights);
    lightlist->num_lights--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "parent", &parent, NULL)
        && !memcmp (&parent, &lightlist->parent, sizeof (lightlist->parent)))
        pass ();
    else
        fail ("LIGHTLIST.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LIGHTLIST") || is_class_debugging ("LIGHTLIST")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LIGHTLIST", failed);
      failed = 0;
    }
  return failed;
}
static int test_LONG_TRANSACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LONG_TRANSACTION *restrict long_transaction = obj->tio.object->tio.LONG_TRANSACTION;
  failed = 0;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (long_transaction, "LONG_TRANSACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &long_transaction->parent, sizeof (long_transaction->parent)))
        pass ();
    else
        fail ("LONG_TRANSACTION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LONG_TRANSACTION") || is_class_debugging ("LONG_TRANSACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LONG_TRANSACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_LTYPE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LTYPE *restrict ltype = obj->tio.object->tio.LTYPE;
  failed = 0;
  {
    BITCODE_RC alignment;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "alignment", &alignment, NULL)
        && alignment == ltype->alignment)
      pass ();
    else
      fail ("LTYPE.alignment [RC] %u != %u", ltype->alignment, alignment);
    alignment++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "alignment", &alignment, 0)
        && alignment == ltype->alignment)
      pass ();
    else
      fail ("LTYPE.alignment [RC] set+1 %u != %u", ltype->alignment, alignment);
    ltype->alignment--;
  }
  {
    Dwg_LTYPE_dash* dashes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "num_dashes", &count, NULL)
        && dwg_dynapi_entity_value (ltype, "LTYPE", "dashes", &dashes, NULL)
        && dashes == ltype->dashes)
      pass ();
    else
      fail ("LTYPE.dashes [Dwg_LTYPE_dash*] * %u num_dashes", count);
  }
  {
    BITCODE_RD* dashes_r11;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "num_dashes", &count, NULL)
        && dwg_dynapi_entity_value (ltype, "LTYPE", "dashes_r11", &dashes_r11, NULL)
        && dashes_r11 == ltype->dashes_r11)
      pass ();
    else
      fail ("LTYPE.dashes_r11 [RD*] * %u num_dashes", count);
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)ltype->description)
           : !ltype->description)
      pass ();
    else
      fail ("LTYPE.description [T] '%s' <> '%s'", description, ltype->description);
  }
  {
    BITCODE_H extref_handle;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "extref_handle", &extref_handle, NULL)
        && !memcmp (&extref_handle, &ltype->extref_handle, sizeof (ltype->extref_handle)))
        pass ();
    else
        fail ("LTYPE.extref_handle [H]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "flag", &flag, NULL)
        && flag == ltype->flag)
      pass ();
    else
      fail ("LTYPE.flag [RC] %u != %u", ltype->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "flag", &flag, 0)
        && flag == ltype->flag)
      pass ();
    else
      fail ("LTYPE.flag [RC] set+1 %u != %u", ltype->flag, flag);
    ltype->flag--;
  }
  {
    BITCODE_B has_strings_area;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "has_strings_area", &has_strings_area, NULL)
        && has_strings_area == ltype->has_strings_area)
      pass ();
    else
      fail ("LTYPE.has_strings_area [B] " FORMAT_B " != " FORMAT_B "", ltype->has_strings_area, has_strings_area);
    has_strings_area++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "has_strings_area", &has_strings_area, 0)
        && has_strings_area == ltype->has_strings_area)
      pass ();
    else
      fail ("LTYPE.has_strings_area [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->has_strings_area, has_strings_area);
    ltype->has_strings_area--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)ltype->name)
           : !ltype->name)
      pass ();
    else
      fail ("LTYPE.name [TV] '%s' <> '%s'", name, ltype->name);
  }
  {
    BITCODE_RC num_dashes;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "num_dashes", &num_dashes, NULL)
        && num_dashes == ltype->num_dashes)
      pass ();
    else
      fail ("LTYPE.num_dashes [RC] %u != %u", ltype->num_dashes, num_dashes);
    num_dashes++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "num_dashes", &num_dashes, 0)
        && num_dashes == ltype->num_dashes)
      pass ();
    else
      fail ("LTYPE.num_dashes [RC] set+1 %u != %u", ltype->num_dashes, num_dashes);
    ltype->num_dashes--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "parent", &parent, NULL)
        && !memcmp (&parent, &ltype->parent, sizeof (ltype->parent)))
        pass ();
    else
        fail ("LTYPE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD pattern_len;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "pattern_len", &pattern_len, NULL)
        && pattern_len == ltype->pattern_len)
      pass ();
    else
      fail ("LTYPE.pattern_len [BD] %g != %g", ltype->pattern_len, pattern_len);
    pattern_len++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "pattern_len", &pattern_len, 0)
        && pattern_len == ltype->pattern_len)
      pass ();
    else
      fail ("LTYPE.pattern_len [BD] set+1 %g != %g", ltype->pattern_len, pattern_len);
    ltype->pattern_len--;
  }
  {
    BITCODE_TF strings_area;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "strings_area", &strings_area, NULL)
        && !memcmp (&strings_area, &ltype->strings_area, sizeof (ltype->strings_area)))
        pass ();
    else
        fail ("LTYPE.strings_area [TF]");
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "used", &used, NULL)
        && used == ltype->used)
      pass ();
    else
      fail ("LTYPE.used [RS] %hu != %hu", ltype->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "used", &used, 0)
        && used == ltype->used)
      pass ();
    else
      fail ("LTYPE.used [RS] set+1 %hu != %hu", ltype->used, used);
    ltype->used--;
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "xrefdep", &xrefdep, NULL)
        && xrefdep == ltype->xrefdep)
      pass ();
    else
      fail ("LTYPE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", ltype->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "xrefdep", &xrefdep, 0)
        && xrefdep == ltype->xrefdep)
      pass ();
    else
      fail ("LTYPE.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->xrefdep, xrefdep);
    ltype->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == ltype->xrefindex_plus1)
      pass ();
    else
      fail ("LTYPE.xrefindex_plus1 [BS] %hu != %hu", ltype->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == ltype->xrefindex_plus1)
      pass ();
    else
      fail ("LTYPE.xrefindex_plus1 [BS] set+1 %hu != %hu", ltype->xrefindex_plus1, xrefindex_plus1);
    ltype->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "xrefref", &xrefref, NULL)
        && xrefref == ltype->xrefref)
      pass ();
    else
      fail ("LTYPE.xrefref [B] " FORMAT_B " != " FORMAT_B "", ltype->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "xrefref", &xrefref, 0)
        && xrefref == ltype->xrefref)
      pass ();
    else
      fail ("LTYPE.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->xrefref, xrefref);
    ltype->xrefref--;
  }
  if (failed && (is_class_unstable ("LTYPE") || is_class_debugging ("LTYPE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LTYPE", failed);
      failed = 0;
    }
  return failed;
}
static int test_LTYPE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LTYPE_CONTROL *restrict ltype_control = obj->tio.object->tio.LTYPE_CONTROL;
  failed = 0;
  {
    BITCODE_H byblock;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "byblock", &byblock, NULL)
        && !memcmp (&byblock, &ltype_control->byblock, sizeof (ltype_control->byblock)))
        pass ();
    else
        fail ("LTYPE_CONTROL.byblock [H]");
  }
  {
    BITCODE_H bylayer;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "bylayer", &bylayer, NULL)
        && !memcmp (&bylayer, &ltype_control->bylayer, sizeof (ltype_control->bylayer)))
        pass ();
    else
        fail ("LTYPE_CONTROL.bylayer [H]");
  }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "entries", &entries, NULL)
        && entries == ltype_control->entries)
      pass ();
    else
      fail ("LTYPE_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == ltype_control->num_entries)
      pass ();
    else
      fail ("LTYPE_CONTROL.num_entries [BS] %hu != %hu", ltype_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (ltype_control, "LTYPE_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == ltype_control->num_entries)
      pass ();
    else
      fail ("LTYPE_CONTROL.num_entries [BS] set+1 %hu != %hu", ltype_control->num_entries, num_entries);
    ltype_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "objid", &objid, NULL)
        && objid == ltype_control->objid)
      pass ();
    else
      fail ("LTYPE_CONTROL.objid [BL] %u != %u", ltype_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (ltype_control, "LTYPE_CONTROL", "objid", &objid, 0)
        && objid == ltype_control->objid)
      pass ();
    else
      fail ("LTYPE_CONTROL.objid [BL] set+1 %u != %u", ltype_control->objid, objid);
    ltype_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &ltype_control->parent, sizeof (ltype_control->parent)))
        pass ();
    else
        fail ("LTYPE_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LTYPE_CONTROL") || is_class_debugging ("LTYPE_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LTYPE_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_MATERIAL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MATERIAL *restrict material = obj->tio.object->tio.MATERIAL;
  failed = 0;
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "ambient_color", &ambient_color, NULL)
        && !memcmp (&ambient_color, &material->ambient_color, sizeof (material->ambient_color)))
        pass ();
    else
        fail ("MATERIAL.ambient_color [CMC]");
  }
  {
    BITCODE_BD ambient_color_factor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "ambient_color_factor", &ambient_color_factor, NULL)
        && ambient_color_factor == material->ambient_color_factor)
      pass ();
    else
      fail ("MATERIAL.ambient_color_factor [BD] %g != %g", material->ambient_color_factor, ambient_color_factor);
    ambient_color_factor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "ambient_color_factor", &ambient_color_factor, 0)
        && ambient_color_factor == material->ambient_color_factor)
      pass ();
    else
      fail ("MATERIAL.ambient_color_factor [BD] set+1 %g != %g", material->ambient_color_factor, ambient_color_factor);
    material->ambient_color_factor--;
  }
  {
    BITCODE_BS ambient_color_flag;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "ambient_color_flag", &ambient_color_flag, NULL)
        && ambient_color_flag == material->ambient_color_flag)
      pass ();
    else
      fail ("MATERIAL.ambient_color_flag [BS] %hu != %hu", material->ambient_color_flag, ambient_color_flag);
    ambient_color_flag++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "ambient_color_flag", &ambient_color_flag, 0)
        && ambient_color_flag == material->ambient_color_flag)
      pass ();
    else
      fail ("MATERIAL.ambient_color_flag [BS] set+1 %hu != %hu", material->ambient_color_flag, ambient_color_flag);
    material->ambient_color_flag--;
  }
  {
    BITCODE_BS bumpmap_autotransform;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "bumpmap_autotransform", &bumpmap_autotransform, NULL)
        && bumpmap_autotransform == material->bumpmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.bumpmap_autotransform [BS] %hu != %hu", material->bumpmap_autotransform, bumpmap_autotransform);
    bumpmap_autotransform++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "bumpmap_autotransform", &bumpmap_autotransform, 0)
        && bumpmap_autotransform == material->bumpmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.bumpmap_autotransform [BS] set+1 %hu != %hu", material->bumpmap_autotransform, bumpmap_autotransform);
    material->bumpmap_autotransform--;
  }
  {
    BITCODE_BD bumpmap_blendfactor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "bumpmap_blendfactor", &bumpmap_blendfactor, NULL)
        && bumpmap_blendfactor == material->bumpmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.bumpmap_blendfactor [BD] %g != %g", material->bumpmap_blendfactor, bumpmap_blendfactor);
    bumpmap_blendfactor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "bumpmap_blendfactor", &bumpmap_blendfactor, 0)
        && bumpmap_blendfactor == material->bumpmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.bumpmap_blendfactor [BD] set+1 %g != %g", material->bumpmap_blendfactor, bumpmap_blendfactor);
    material->bumpmap_blendfactor--;
  }
  {
    BITCODE_T bumpmap_filename;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "bumpmap_filename", &bumpmap_filename, NULL)
        && bumpmap_filename
           ? strEQ ((char *)bumpmap_filename, (char *)material->bumpmap_filename)
           : !material->bumpmap_filename)
      pass ();
    else
      fail ("MATERIAL.bumpmap_filename [T] '%s' <> '%s'", bumpmap_filename, material->bumpmap_filename);
  }
  {
    BITCODE_BS bumpmap_projection;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "bumpmap_projection", &bumpmap_projection, NULL)
        && bumpmap_projection == material->bumpmap_projection)
      pass ();
    else
      fail ("MATERIAL.bumpmap_projection [BS] %hu != %hu", material->bumpmap_projection, bumpmap_projection);
    bumpmap_projection++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "bumpmap_projection", &bumpmap_projection, 0)
        && bumpmap_projection == material->bumpmap_projection)
      pass ();
    else
      fail ("MATERIAL.bumpmap_projection [BS] set+1 %hu != %hu", material->bumpmap_projection, bumpmap_projection);
    material->bumpmap_projection--;
  }
  {
    BITCODE_BS bumpmap_source;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "bumpmap_source", &bumpmap_source, NULL)
        && bumpmap_source == material->bumpmap_source)
      pass ();
    else
      fail ("MATERIAL.bumpmap_source [BS] %hu != %hu", material->bumpmap_source, bumpmap_source);
    bumpmap_source++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "bumpmap_source", &bumpmap_source, 0)
        && bumpmap_source == material->bumpmap_source)
      pass ();
    else
      fail ("MATERIAL.bumpmap_source [BS] set+1 %hu != %hu", material->bumpmap_source, bumpmap_source);
    material->bumpmap_source--;
  }
  {
    BITCODE_BS bumpmap_tiling;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "bumpmap_tiling", &bumpmap_tiling, NULL)
        && bumpmap_tiling == material->bumpmap_tiling)
      pass ();
    else
      fail ("MATERIAL.bumpmap_tiling [BS] %hu != %hu", material->bumpmap_tiling, bumpmap_tiling);
    bumpmap_tiling++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "bumpmap_tiling", &bumpmap_tiling, 0)
        && bumpmap_tiling == material->bumpmap_tiling)
      pass ();
    else
      fail ("MATERIAL.bumpmap_tiling [BS] set+1 %hu != %hu", material->bumpmap_tiling, bumpmap_tiling);
    material->bumpmap_tiling--;
  }
  {
    BITCODE_BD* bumpmap_transmatrix;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "bumpmap_transmatrix", &bumpmap_transmatrix, NULL)
        && !memcmp (&bumpmap_transmatrix, &material->bumpmap_transmatrix, sizeof (material->bumpmap_transmatrix)))
        pass ();
    else
        fail ("MATERIAL.bumpmap_transmatrix [BD*]");
  }
  {
    BITCODE_BL channel_flags;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "channel_flags", &channel_flags, NULL)
        && channel_flags == material->channel_flags)
      pass ();
    else
      fail ("MATERIAL.channel_flags [BL] %u != %u", material->channel_flags, channel_flags);
    channel_flags++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "channel_flags", &channel_flags, 0)
        && channel_flags == material->channel_flags)
      pass ();
    else
      fail ("MATERIAL.channel_flags [BL] set+1 %u != %u", material->channel_flags, channel_flags);
    material->channel_flags--;
  }
  {
    BITCODE_BD color_bleed_scale;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "color_bleed_scale", &color_bleed_scale, NULL)
        && color_bleed_scale == material->color_bleed_scale)
      pass ();
    else
      fail ("MATERIAL.color_bleed_scale [BD] %g != %g", material->color_bleed_scale, color_bleed_scale);
    color_bleed_scale++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "color_bleed_scale", &color_bleed_scale, 0)
        && color_bleed_scale == material->color_bleed_scale)
      pass ();
    else
      fail ("MATERIAL.color_bleed_scale [BD] set+1 %g != %g", material->color_bleed_scale, color_bleed_scale);
    material->color_bleed_scale--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)material->description)
           : !material->description)
      pass ();
    else
      fail ("MATERIAL.description [T] '%s' <> '%s'", description, material->description);
  }
  {
    BITCODE_CMC diffuse_color;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffuse_color", &diffuse_color, NULL)
        && !memcmp (&diffuse_color, &material->diffuse_color, sizeof (material->diffuse_color)))
        pass ();
    else
        fail ("MATERIAL.diffuse_color [CMC]");
  }
  {
    BITCODE_BD diffuse_color_factor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffuse_color_factor", &diffuse_color_factor, NULL)
        && diffuse_color_factor == material->diffuse_color_factor)
      pass ();
    else
      fail ("MATERIAL.diffuse_color_factor [BD] %g != %g", material->diffuse_color_factor, diffuse_color_factor);
    diffuse_color_factor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "diffuse_color_factor", &diffuse_color_factor, 0)
        && diffuse_color_factor == material->diffuse_color_factor)
      pass ();
    else
      fail ("MATERIAL.diffuse_color_factor [BD] set+1 %g != %g", material->diffuse_color_factor, diffuse_color_factor);
    material->diffuse_color_factor--;
  }
  {
    BITCODE_BS diffuse_color_flag;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffuse_color_flag", &diffuse_color_flag, NULL)
        && diffuse_color_flag == material->diffuse_color_flag)
      pass ();
    else
      fail ("MATERIAL.diffuse_color_flag [BS] %hu != %hu", material->diffuse_color_flag, diffuse_color_flag);
    diffuse_color_flag++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "diffuse_color_flag", &diffuse_color_flag, 0)
        && diffuse_color_flag == material->diffuse_color_flag)
      pass ();
    else
      fail ("MATERIAL.diffuse_color_flag [BS] set+1 %hu != %hu", material->diffuse_color_flag, diffuse_color_flag);
    material->diffuse_color_flag--;
  }
  {
    BITCODE_BS diffusemap_autotransform;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffusemap_autotransform", &diffusemap_autotransform, NULL)
        && diffusemap_autotransform == material->diffusemap_autotransform)
      pass ();
    else
      fail ("MATERIAL.diffusemap_autotransform [BS] %hu != %hu", material->diffusemap_autotransform, diffusemap_autotransform);
    diffusemap_autotransform++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "diffusemap_autotransform", &diffusemap_autotransform, 0)
        && diffusemap_autotransform == material->diffusemap_autotransform)
      pass ();
    else
      fail ("MATERIAL.diffusemap_autotransform [BS] set+1 %hu != %hu", material->diffusemap_autotransform, diffusemap_autotransform);
    material->diffusemap_autotransform--;
  }
  {
    BITCODE_BD diffusemap_blendfactor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffusemap_blendfactor", &diffusemap_blendfactor, NULL)
        && diffusemap_blendfactor == material->diffusemap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.diffusemap_blendfactor [BD] %g != %g", material->diffusemap_blendfactor, diffusemap_blendfactor);
    diffusemap_blendfactor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "diffusemap_blendfactor", &diffusemap_blendfactor, 0)
        && diffusemap_blendfactor == material->diffusemap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.diffusemap_blendfactor [BD] set+1 %g != %g", material->diffusemap_blendfactor, diffusemap_blendfactor);
    material->diffusemap_blendfactor--;
  }
  {
    BITCODE_T diffusemap_filename;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffusemap_filename", &diffusemap_filename, NULL)
        && diffusemap_filename
           ? strEQ ((char *)diffusemap_filename, (char *)material->diffusemap_filename)
           : !material->diffusemap_filename)
      pass ();
    else
      fail ("MATERIAL.diffusemap_filename [T] '%s' <> '%s'", diffusemap_filename, material->diffusemap_filename);
  }
  {
    BITCODE_BS diffusemap_projection;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffusemap_projection", &diffusemap_projection, NULL)
        && diffusemap_projection == material->diffusemap_projection)
      pass ();
    else
      fail ("MATERIAL.diffusemap_projection [BS] %hu != %hu", material->diffusemap_projection, diffusemap_projection);
    diffusemap_projection++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "diffusemap_projection", &diffusemap_projection, 0)
        && diffusemap_projection == material->diffusemap_projection)
      pass ();
    else
      fail ("MATERIAL.diffusemap_projection [BS] set+1 %hu != %hu", material->diffusemap_projection, diffusemap_projection);
    material->diffusemap_projection--;
  }
  {
    BITCODE_BS diffusemap_source;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffusemap_source", &diffusemap_source, NULL)
        && diffusemap_source == material->diffusemap_source)
      pass ();
    else
      fail ("MATERIAL.diffusemap_source [BS] %hu != %hu", material->diffusemap_source, diffusemap_source);
    diffusemap_source++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "diffusemap_source", &diffusemap_source, 0)
        && diffusemap_source == material->diffusemap_source)
      pass ();
    else
      fail ("MATERIAL.diffusemap_source [BS] set+1 %hu != %hu", material->diffusemap_source, diffusemap_source);
    material->diffusemap_source--;
  }
  {
    BITCODE_BS diffusemap_tiling;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffusemap_tiling", &diffusemap_tiling, NULL)
        && diffusemap_tiling == material->diffusemap_tiling)
      pass ();
    else
      fail ("MATERIAL.diffusemap_tiling [BS] %hu != %hu", material->diffusemap_tiling, diffusemap_tiling);
    diffusemap_tiling++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "diffusemap_tiling", &diffusemap_tiling, 0)
        && diffusemap_tiling == material->diffusemap_tiling)
      pass ();
    else
      fail ("MATERIAL.diffusemap_tiling [BS] set+1 %hu != %hu", material->diffusemap_tiling, diffusemap_tiling);
    material->diffusemap_tiling--;
  }
  {
    BITCODE_BD* diffusemap_transmatrix;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffusemap_transmatrix", &diffusemap_transmatrix, NULL)
        && !memcmp (&diffusemap_transmatrix, &material->diffusemap_transmatrix, sizeof (material->diffusemap_transmatrix)))
        pass ();
    else
        fail ("MATERIAL.diffusemap_transmatrix [BD*]");
  }
  {
    BITCODE_BS final_gather_mode;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "final_gather_mode", &final_gather_mode, NULL)
        && final_gather_mode == material->final_gather_mode)
      pass ();
    else
      fail ("MATERIAL.final_gather_mode [BS] %hu != %hu", material->final_gather_mode, final_gather_mode);
    final_gather_mode++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "final_gather_mode", &final_gather_mode, 0)
        && final_gather_mode == material->final_gather_mode)
      pass ();
    else
      fail ("MATERIAL.final_gather_mode [BS] set+1 %hu != %hu", material->final_gather_mode, final_gather_mode);
    material->final_gather_mode--;
  }
  {
    BITCODE_T genprocname;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocname", &genprocname, NULL)
        && genprocname
           ? strEQ ((char *)genprocname, (char *)material->genprocname)
           : !material->genprocname)
      pass ();
    else
      fail ("MATERIAL.genprocname [T] '%s' <> '%s'", genprocname, material->genprocname);
  }
  {
    BITCODE_B genproctableend;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genproctableend", &genproctableend, NULL)
        && genproctableend == material->genproctableend)
      pass ();
    else
      fail ("MATERIAL.genproctableend [B] " FORMAT_B " != " FORMAT_B "", material->genproctableend, genproctableend);
    genproctableend++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genproctableend", &genproctableend, 0)
        && genproctableend == material->genproctableend)
      pass ();
    else
      fail ("MATERIAL.genproctableend [B] set+1 " FORMAT_B " != " FORMAT_B "", material->genproctableend, genproctableend);
    material->genproctableend--;
  }
  {
    BITCODE_B genprocvalbool;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalbool", &genprocvalbool, NULL)
        && genprocvalbool == material->genprocvalbool)
      pass ();
    else
      fail ("MATERIAL.genprocvalbool [B] " FORMAT_B " != " FORMAT_B "", material->genprocvalbool, genprocvalbool);
    genprocvalbool++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genprocvalbool", &genprocvalbool, 0)
        && genprocvalbool == material->genprocvalbool)
      pass ();
    else
      fail ("MATERIAL.genprocvalbool [B] set+1 " FORMAT_B " != " FORMAT_B "", material->genprocvalbool, genprocvalbool);
    material->genprocvalbool--;
  }
  {
    BITCODE_CMC genprocvalcolorindex;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalcolorindex", &genprocvalcolorindex, NULL)
        && !memcmp (&genprocvalcolorindex, &material->genprocvalcolorindex, sizeof (material->genprocvalcolorindex)))
        pass ();
    else
        fail ("MATERIAL.genprocvalcolorindex [CMC]");
  }
  {
    BITCODE_T genprocvalcolorname;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalcolorname", &genprocvalcolorname, NULL)
        && genprocvalcolorname
           ? strEQ ((char *)genprocvalcolorname, (char *)material->genprocvalcolorname)
           : !material->genprocvalcolorname)
      pass ();
    else
      fail ("MATERIAL.genprocvalcolorname [T] '%s' <> '%s'", genprocvalcolorname, material->genprocvalcolorname);
  }
  {
    BITCODE_BS genprocvalcolorrgb;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalcolorrgb", &genprocvalcolorrgb, NULL)
        && genprocvalcolorrgb == material->genprocvalcolorrgb)
      pass ();
    else
      fail ("MATERIAL.genprocvalcolorrgb [BS] %hu != %hu", material->genprocvalcolorrgb, genprocvalcolorrgb);
    genprocvalcolorrgb++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genprocvalcolorrgb", &genprocvalcolorrgb, 0)
        && genprocvalcolorrgb == material->genprocvalcolorrgb)
      pass ();
    else
      fail ("MATERIAL.genprocvalcolorrgb [BS] set+1 %hu != %hu", material->genprocvalcolorrgb, genprocvalcolorrgb);
    material->genprocvalcolorrgb--;
  }
  {
    BITCODE_BS genprocvalint;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalint", &genprocvalint, NULL)
        && genprocvalint == material->genprocvalint)
      pass ();
    else
      fail ("MATERIAL.genprocvalint [BS] %hu != %hu", material->genprocvalint, genprocvalint);
    genprocvalint++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genprocvalint", &genprocvalint, 0)
        && genprocvalint == material->genprocvalint)
      pass ();
    else
      fail ("MATERIAL.genprocvalint [BS] set+1 %hu != %hu", material->genprocvalint, genprocvalint);
    material->genprocvalint--;
  }
  {
    BITCODE_BD genprocvalreal;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalreal", &genprocvalreal, NULL)
        && genprocvalreal == material->genprocvalreal)
      pass ();
    else
      fail ("MATERIAL.genprocvalreal [BD] %g != %g", material->genprocvalreal, genprocvalreal);
    genprocvalreal++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genprocvalreal", &genprocvalreal, 0)
        && genprocvalreal == material->genprocvalreal)
      pass ();
    else
      fail ("MATERIAL.genprocvalreal [BD] set+1 %g != %g", material->genprocvalreal, genprocvalreal);
    material->genprocvalreal--;
  }
  {
    BITCODE_T genprocvaltext;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvaltext", &genprocvaltext, NULL)
        && genprocvaltext
           ? strEQ ((char *)genprocvaltext, (char *)material->genprocvaltext)
           : !material->genprocvaltext)
      pass ();
    else
      fail ("MATERIAL.genprocvaltext [T] '%s' <> '%s'", genprocvaltext, material->genprocvaltext);
  }
  {
    BITCODE_BS global_illumination_mode;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "global_illumination_mode", &global_illumination_mode, NULL)
        && global_illumination_mode == material->global_illumination_mode)
      pass ();
    else
      fail ("MATERIAL.global_illumination_mode [BS] %hu != %hu", material->global_illumination_mode, global_illumination_mode);
    global_illumination_mode++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "global_illumination_mode", &global_illumination_mode, 0)
        && global_illumination_mode == material->global_illumination_mode)
      pass ();
    else
      fail ("MATERIAL.global_illumination_mode [BS] set+1 %hu != %hu", material->global_illumination_mode, global_illumination_mode);
    material->global_illumination_mode--;
  }
  {
    BITCODE_BL illumination_model;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "illumination_model", &illumination_model, NULL)
        && illumination_model == material->illumination_model)
      pass ();
    else
      fail ("MATERIAL.illumination_model [BL] %u != %u", material->illumination_model, illumination_model);
    illumination_model++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "illumination_model", &illumination_model, 0)
        && illumination_model == material->illumination_model)
      pass ();
    else
      fail ("MATERIAL.illumination_model [BL] set+1 %u != %u", material->illumination_model, illumination_model);
    material->illumination_model--;
  }
  {
    BITCODE_BD indirect_dump_scale;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "indirect_dump_scale", &indirect_dump_scale, NULL)
        && indirect_dump_scale == material->indirect_dump_scale)
      pass ();
    else
      fail ("MATERIAL.indirect_dump_scale [BD] %g != %g", material->indirect_dump_scale, indirect_dump_scale);
    indirect_dump_scale++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "indirect_dump_scale", &indirect_dump_scale, 0)
        && indirect_dump_scale == material->indirect_dump_scale)
      pass ();
    else
      fail ("MATERIAL.indirect_dump_scale [BD] set+1 %g != %g", material->indirect_dump_scale, indirect_dump_scale);
    material->indirect_dump_scale--;
  }
  {
    BITCODE_BD luminance;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "luminance", &luminance, NULL)
        && luminance == material->luminance)
      pass ();
    else
      fail ("MATERIAL.luminance [BD] %g != %g", material->luminance, luminance);
    luminance++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "luminance", &luminance, 0)
        && luminance == material->luminance)
      pass ();
    else
      fail ("MATERIAL.luminance [BD] set+1 %g != %g", material->luminance, luminance);
    material->luminance--;
  }
  {
    BITCODE_BS luminance_mode;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "luminance_mode", &luminance_mode, NULL)
        && luminance_mode == material->luminance_mode)
      pass ();
    else
      fail ("MATERIAL.luminance_mode [BS] %hu != %hu", material->luminance_mode, luminance_mode);
    luminance_mode++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "luminance_mode", &luminance_mode, 0)
        && luminance_mode == material->luminance_mode)
      pass ();
    else
      fail ("MATERIAL.luminance_mode [BS] set+1 %hu != %hu", material->luminance_mode, luminance_mode);
    material->luminance_mode--;
  }
  {
    BITCODE_BS map_utile;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "map_utile", &map_utile, NULL)
        && map_utile == material->map_utile)
      pass ();
    else
      fail ("MATERIAL.map_utile [BS] %hu != %hu", material->map_utile, map_utile);
    map_utile++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "map_utile", &map_utile, 0)
        && map_utile == material->map_utile)
      pass ();
    else
      fail ("MATERIAL.map_utile [BS] set+1 %hu != %hu", material->map_utile, map_utile);
    material->map_utile--;
  }
  {
    BITCODE_B materials_anonymous;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "materials_anonymous", &materials_anonymous, NULL)
        && materials_anonymous == material->materials_anonymous)
      pass ();
    else
      fail ("MATERIAL.materials_anonymous [B] " FORMAT_B " != " FORMAT_B "", material->materials_anonymous, materials_anonymous);
    materials_anonymous++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "materials_anonymous", &materials_anonymous, 0)
        && materials_anonymous == material->materials_anonymous)
      pass ();
    else
      fail ("MATERIAL.materials_anonymous [B] set+1 " FORMAT_B " != " FORMAT_B "", material->materials_anonymous, materials_anonymous);
    material->materials_anonymous--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)material->name)
           : !material->name)
      pass ();
    else
      fail ("MATERIAL.name [T] '%s' <> '%s'", name, material->name);
  }
  {
    BITCODE_BS normalmap_autotransform;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_autotransform", &normalmap_autotransform, NULL)
        && normalmap_autotransform == material->normalmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.normalmap_autotransform [BS] %hu != %hu", material->normalmap_autotransform, normalmap_autotransform);
    normalmap_autotransform++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "normalmap_autotransform", &normalmap_autotransform, 0)
        && normalmap_autotransform == material->normalmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.normalmap_autotransform [BS] set+1 %hu != %hu", material->normalmap_autotransform, normalmap_autotransform);
    material->normalmap_autotransform--;
  }
  {
    BITCODE_BD normalmap_blendfactor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_blendfactor", &normalmap_blendfactor, NULL)
        && normalmap_blendfactor == material->normalmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.normalmap_blendfactor [BD] %g != %g", material->normalmap_blendfactor, normalmap_blendfactor);
    normalmap_blendfactor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "normalmap_blendfactor", &normalmap_blendfactor, 0)
        && normalmap_blendfactor == material->normalmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.normalmap_blendfactor [BD] set+1 %g != %g", material->normalmap_blendfactor, normalmap_blendfactor);
    material->normalmap_blendfactor--;
  }
  {
    BITCODE_T normalmap_filename;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_filename", &normalmap_filename, NULL)
        && normalmap_filename
           ? strEQ ((char *)normalmap_filename, (char *)material->normalmap_filename)
           : !material->normalmap_filename)
      pass ();
    else
      fail ("MATERIAL.normalmap_filename [T] '%s' <> '%s'", normalmap_filename, material->normalmap_filename);
  }
  {
    BITCODE_BS normalmap_method;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_method", &normalmap_method, NULL)
        && normalmap_method == material->normalmap_method)
      pass ();
    else
      fail ("MATERIAL.normalmap_method [BS] %hu != %hu", material->normalmap_method, normalmap_method);
    normalmap_method++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "normalmap_method", &normalmap_method, 0)
        && normalmap_method == material->normalmap_method)
      pass ();
    else
      fail ("MATERIAL.normalmap_method [BS] set+1 %hu != %hu", material->normalmap_method, normalmap_method);
    material->normalmap_method--;
  }
  {
    BITCODE_BS normalmap_projection;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_projection", &normalmap_projection, NULL)
        && normalmap_projection == material->normalmap_projection)
      pass ();
    else
      fail ("MATERIAL.normalmap_projection [BS] %hu != %hu", material->normalmap_projection, normalmap_projection);
    normalmap_projection++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "normalmap_projection", &normalmap_projection, 0)
        && normalmap_projection == material->normalmap_projection)
      pass ();
    else
      fail ("MATERIAL.normalmap_projection [BS] set+1 %hu != %hu", material->normalmap_projection, normalmap_projection);
    material->normalmap_projection--;
  }
  {
    BITCODE_BS normalmap_source;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_source", &normalmap_source, NULL)
        && normalmap_source == material->normalmap_source)
      pass ();
    else
      fail ("MATERIAL.normalmap_source [BS] %hu != %hu", material->normalmap_source, normalmap_source);
    normalmap_source++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "normalmap_source", &normalmap_source, 0)
        && normalmap_source == material->normalmap_source)
      pass ();
    else
      fail ("MATERIAL.normalmap_source [BS] set+1 %hu != %hu", material->normalmap_source, normalmap_source);
    material->normalmap_source--;
  }
  {
    BITCODE_BD normalmap_strength;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_strength", &normalmap_strength, NULL)
        && normalmap_strength == material->normalmap_strength)
      pass ();
    else
      fail ("MATERIAL.normalmap_strength [BD] %g != %g", material->normalmap_strength, normalmap_strength);
    normalmap_strength++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "normalmap_strength", &normalmap_strength, 0)
        && normalmap_strength == material->normalmap_strength)
      pass ();
    else
      fail ("MATERIAL.normalmap_strength [BD] set+1 %g != %g", material->normalmap_strength, normalmap_strength);
    material->normalmap_strength--;
  }
  {
    BITCODE_BS normalmap_tiling;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_tiling", &normalmap_tiling, NULL)
        && normalmap_tiling == material->normalmap_tiling)
      pass ();
    else
      fail ("MATERIAL.normalmap_tiling [BS] %hu != %hu", material->normalmap_tiling, normalmap_tiling);
    normalmap_tiling++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "normalmap_tiling", &normalmap_tiling, 0)
        && normalmap_tiling == material->normalmap_tiling)
      pass ();
    else
      fail ("MATERIAL.normalmap_tiling [BS] set+1 %hu != %hu", material->normalmap_tiling, normalmap_tiling);
    material->normalmap_tiling--;
  }
  {
    BITCODE_BD* normalmap_transmatrix;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "normalmap_transmatrix", &normalmap_transmatrix, NULL)
        && !memcmp (&normalmap_transmatrix, &material->normalmap_transmatrix, sizeof (material->normalmap_transmatrix)))
        pass ();
    else
        fail ("MATERIAL.normalmap_transmatrix [BD*]");
  }
  {
    BITCODE_BD opacity_percent;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacity_percent", &opacity_percent, NULL)
        && opacity_percent == material->opacity_percent)
      pass ();
    else
      fail ("MATERIAL.opacity_percent [BD] %g != %g", material->opacity_percent, opacity_percent);
    opacity_percent++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "opacity_percent", &opacity_percent, 0)
        && opacity_percent == material->opacity_percent)
      pass ();
    else
      fail ("MATERIAL.opacity_percent [BD] set+1 %g != %g", material->opacity_percent, opacity_percent);
    material->opacity_percent--;
  }
  {
    BITCODE_BS opacitymap_autotransform;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacitymap_autotransform", &opacitymap_autotransform, NULL)
        && opacitymap_autotransform == material->opacitymap_autotransform)
      pass ();
    else
      fail ("MATERIAL.opacitymap_autotransform [BS] %hu != %hu", material->opacitymap_autotransform, opacitymap_autotransform);
    opacitymap_autotransform++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "opacitymap_autotransform", &opacitymap_autotransform, 0)
        && opacitymap_autotransform == material->opacitymap_autotransform)
      pass ();
    else
      fail ("MATERIAL.opacitymap_autotransform [BS] set+1 %hu != %hu", material->opacitymap_autotransform, opacitymap_autotransform);
    material->opacitymap_autotransform--;
  }
  {
    BITCODE_BD opacitymap_blendfactor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacitymap_blendfactor", &opacitymap_blendfactor, NULL)
        && opacitymap_blendfactor == material->opacitymap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.opacitymap_blendfactor [BD] %g != %g", material->opacitymap_blendfactor, opacitymap_blendfactor);
    opacitymap_blendfactor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "opacitymap_blendfactor", &opacitymap_blendfactor, 0)
        && opacitymap_blendfactor == material->opacitymap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.opacitymap_blendfactor [BD] set+1 %g != %g", material->opacitymap_blendfactor, opacitymap_blendfactor);
    material->opacitymap_blendfactor--;
  }
  {
    BITCODE_T opacitymap_filename;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacitymap_filename", &opacitymap_filename, NULL)
        && opacitymap_filename
           ? strEQ ((char *)opacitymap_filename, (char *)material->opacitymap_filename)
           : !material->opacitymap_filename)
      pass ();
    else
      fail ("MATERIAL.opacitymap_filename [T] '%s' <> '%s'", opacitymap_filename, material->opacitymap_filename);
  }
  {
    BITCODE_BS opacitymap_projection;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacitymap_projection", &opacitymap_projection, NULL)
        && opacitymap_projection == material->opacitymap_projection)
      pass ();
    else
      fail ("MATERIAL.opacitymap_projection [BS] %hu != %hu", material->opacitymap_projection, opacitymap_projection);
    opacitymap_projection++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "opacitymap_projection", &opacitymap_projection, 0)
        && opacitymap_projection == material->opacitymap_projection)
      pass ();
    else
      fail ("MATERIAL.opacitymap_projection [BS] set+1 %hu != %hu", material->opacitymap_projection, opacitymap_projection);
    material->opacitymap_projection--;
  }
  {
    BITCODE_BS opacitymap_source;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacitymap_source", &opacitymap_source, NULL)
        && opacitymap_source == material->opacitymap_source)
      pass ();
    else
      fail ("MATERIAL.opacitymap_source [BS] %hu != %hu", material->opacitymap_source, opacitymap_source);
    opacitymap_source++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "opacitymap_source", &opacitymap_source, 0)
        && opacitymap_source == material->opacitymap_source)
      pass ();
    else
      fail ("MATERIAL.opacitymap_source [BS] set+1 %hu != %hu", material->opacitymap_source, opacitymap_source);
    material->opacitymap_source--;
  }
  {
    BITCODE_BS opacitymap_tiling;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacitymap_tiling", &opacitymap_tiling, NULL)
        && opacitymap_tiling == material->opacitymap_tiling)
      pass ();
    else
      fail ("MATERIAL.opacitymap_tiling [BS] %hu != %hu", material->opacitymap_tiling, opacitymap_tiling);
    opacitymap_tiling++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "opacitymap_tiling", &opacitymap_tiling, 0)
        && opacitymap_tiling == material->opacitymap_tiling)
      pass ();
    else
      fail ("MATERIAL.opacitymap_tiling [BS] set+1 %hu != %hu", material->opacitymap_tiling, opacitymap_tiling);
    material->opacitymap_tiling--;
  }
  {
    BITCODE_BD* opacitymap_transmatrix;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacitymap_transmatrix", &opacitymap_transmatrix, NULL)
        && !memcmp (&opacitymap_transmatrix, &material->opacitymap_transmatrix, sizeof (material->opacitymap_transmatrix)))
        pass ();
    else
        fail ("MATERIAL.opacitymap_transmatrix [BD*]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "parent", &parent, NULL)
        && !memcmp (&parent, &material->parent, sizeof (material->parent)))
        pass ();
    else
        fail ("MATERIAL.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD reflectance_scale;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectance_scale", &reflectance_scale, NULL)
        && reflectance_scale == material->reflectance_scale)
      pass ();
    else
      fail ("MATERIAL.reflectance_scale [BD] %g != %g", material->reflectance_scale, reflectance_scale);
    reflectance_scale++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectance_scale", &reflectance_scale, 0)
        && reflectance_scale == material->reflectance_scale)
      pass ();
    else
      fail ("MATERIAL.reflectance_scale [BD] set+1 %g != %g", material->reflectance_scale, reflectance_scale);
    material->reflectance_scale--;
  }
  {
    BITCODE_BS reflectionmap_autotransform;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectionmap_autotransform", &reflectionmap_autotransform, NULL)
        && reflectionmap_autotransform == material->reflectionmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_autotransform [BS] %hu != %hu", material->reflectionmap_autotransform, reflectionmap_autotransform);
    reflectionmap_autotransform++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectionmap_autotransform", &reflectionmap_autotransform, 0)
        && reflectionmap_autotransform == material->reflectionmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_autotransform [BS] set+1 %hu != %hu", material->reflectionmap_autotransform, reflectionmap_autotransform);
    material->reflectionmap_autotransform--;
  }
  {
    BITCODE_BD reflectionmap_blendfactor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectionmap_blendfactor", &reflectionmap_blendfactor, NULL)
        && reflectionmap_blendfactor == material->reflectionmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_blendfactor [BD] %g != %g", material->reflectionmap_blendfactor, reflectionmap_blendfactor);
    reflectionmap_blendfactor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectionmap_blendfactor", &reflectionmap_blendfactor, 0)
        && reflectionmap_blendfactor == material->reflectionmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_blendfactor [BD] set+1 %g != %g", material->reflectionmap_blendfactor, reflectionmap_blendfactor);
    material->reflectionmap_blendfactor--;
  }
  {
    BITCODE_T reflectionmap_filename;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectionmap_filename", &reflectionmap_filename, NULL)
        && reflectionmap_filename
           ? strEQ ((char *)reflectionmap_filename, (char *)material->reflectionmap_filename)
           : !material->reflectionmap_filename)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_filename [T] '%s' <> '%s'", reflectionmap_filename, material->reflectionmap_filename);
  }
  {
    BITCODE_BS reflectionmap_projection;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectionmap_projection", &reflectionmap_projection, NULL)
        && reflectionmap_projection == material->reflectionmap_projection)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_projection [BS] %hu != %hu", material->reflectionmap_projection, reflectionmap_projection);
    reflectionmap_projection++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectionmap_projection", &reflectionmap_projection, 0)
        && reflectionmap_projection == material->reflectionmap_projection)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_projection [BS] set+1 %hu != %hu", material->reflectionmap_projection, reflectionmap_projection);
    material->reflectionmap_projection--;
  }
  {
    BITCODE_BS reflectionmap_source;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectionmap_source", &reflectionmap_source, NULL)
        && reflectionmap_source == material->reflectionmap_source)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_source [BS] %hu != %hu", material->reflectionmap_source, reflectionmap_source);
    reflectionmap_source++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectionmap_source", &reflectionmap_source, 0)
        && reflectionmap_source == material->reflectionmap_source)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_source [BS] set+1 %hu != %hu", material->reflectionmap_source, reflectionmap_source);
    material->reflectionmap_source--;
  }
  {
    BITCODE_BS reflectionmap_tiling;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectionmap_tiling", &reflectionmap_tiling, NULL)
        && reflectionmap_tiling == material->reflectionmap_tiling)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_tiling [BS] %hu != %hu", material->reflectionmap_tiling, reflectionmap_tiling);
    reflectionmap_tiling++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectionmap_tiling", &reflectionmap_tiling, 0)
        && reflectionmap_tiling == material->reflectionmap_tiling)
      pass ();
    else
      fail ("MATERIAL.reflectionmap_tiling [BS] set+1 %hu != %hu", material->reflectionmap_tiling, reflectionmap_tiling);
    material->reflectionmap_tiling--;
  }
  {
    BITCODE_BD* reflectionmap_transmatrix;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectionmap_transmatrix", &reflectionmap_transmatrix, NULL)
        && !memcmp (&reflectionmap_transmatrix, &material->reflectionmap_transmatrix, sizeof (material->reflectionmap_transmatrix)))
        pass ();
    else
        fail ("MATERIAL.reflectionmap_transmatrix [BD*]");
  }
  {
    BITCODE_BD reflectivity;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectivity", &reflectivity, NULL)
        && reflectivity == material->reflectivity)
      pass ();
    else
      fail ("MATERIAL.reflectivity [BD] %g != %g", material->reflectivity, reflectivity);
    reflectivity++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectivity", &reflectivity, 0)
        && reflectivity == material->reflectivity)
      pass ();
    else
      fail ("MATERIAL.reflectivity [BD] set+1 %g != %g", material->reflectivity, reflectivity);
    material->reflectivity--;
  }
  {
    BITCODE_BD refraction_index;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refraction_index", &refraction_index, NULL)
        && refraction_index == material->refraction_index)
      pass ();
    else
      fail ("MATERIAL.refraction_index [BD] %g != %g", material->refraction_index, refraction_index);
    refraction_index++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "refraction_index", &refraction_index, 0)
        && refraction_index == material->refraction_index)
      pass ();
    else
      fail ("MATERIAL.refraction_index [BD] set+1 %g != %g", material->refraction_index, refraction_index);
    material->refraction_index--;
  }
  {
    BITCODE_BS refractionmap_autotransform;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refractionmap_autotransform", &refractionmap_autotransform, NULL)
        && refractionmap_autotransform == material->refractionmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.refractionmap_autotransform [BS] %hu != %hu", material->refractionmap_autotransform, refractionmap_autotransform);
    refractionmap_autotransform++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "refractionmap_autotransform", &refractionmap_autotransform, 0)
        && refractionmap_autotransform == material->refractionmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.refractionmap_autotransform [BS] set+1 %hu != %hu", material->refractionmap_autotransform, refractionmap_autotransform);
    material->refractionmap_autotransform--;
  }
  {
    BITCODE_BD refractionmap_blendfactor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refractionmap_blendfactor", &refractionmap_blendfactor, NULL)
        && refractionmap_blendfactor == material->refractionmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.refractionmap_blendfactor [BD] %g != %g", material->refractionmap_blendfactor, refractionmap_blendfactor);
    refractionmap_blendfactor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "refractionmap_blendfactor", &refractionmap_blendfactor, 0)
        && refractionmap_blendfactor == material->refractionmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.refractionmap_blendfactor [BD] set+1 %g != %g", material->refractionmap_blendfactor, refractionmap_blendfactor);
    material->refractionmap_blendfactor--;
  }
  {
    BITCODE_T refractionmap_filename;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refractionmap_filename", &refractionmap_filename, NULL)
        && refractionmap_filename
           ? strEQ ((char *)refractionmap_filename, (char *)material->refractionmap_filename)
           : !material->refractionmap_filename)
      pass ();
    else
      fail ("MATERIAL.refractionmap_filename [T] '%s' <> '%s'", refractionmap_filename, material->refractionmap_filename);
  }
  {
    BITCODE_BS refractionmap_projection;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refractionmap_projection", &refractionmap_projection, NULL)
        && refractionmap_projection == material->refractionmap_projection)
      pass ();
    else
      fail ("MATERIAL.refractionmap_projection [BS] %hu != %hu", material->refractionmap_projection, refractionmap_projection);
    refractionmap_projection++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "refractionmap_projection", &refractionmap_projection, 0)
        && refractionmap_projection == material->refractionmap_projection)
      pass ();
    else
      fail ("MATERIAL.refractionmap_projection [BS] set+1 %hu != %hu", material->refractionmap_projection, refractionmap_projection);
    material->refractionmap_projection--;
  }
  {
    BITCODE_BS refractionmap_source;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refractionmap_source", &refractionmap_source, NULL)
        && refractionmap_source == material->refractionmap_source)
      pass ();
    else
      fail ("MATERIAL.refractionmap_source [BS] %hu != %hu", material->refractionmap_source, refractionmap_source);
    refractionmap_source++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "refractionmap_source", &refractionmap_source, 0)
        && refractionmap_source == material->refractionmap_source)
      pass ();
    else
      fail ("MATERIAL.refractionmap_source [BS] set+1 %hu != %hu", material->refractionmap_source, refractionmap_source);
    material->refractionmap_source--;
  }
  {
    BITCODE_BS refractionmap_tiling;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refractionmap_tiling", &refractionmap_tiling, NULL)
        && refractionmap_tiling == material->refractionmap_tiling)
      pass ();
    else
      fail ("MATERIAL.refractionmap_tiling [BS] %hu != %hu", material->refractionmap_tiling, refractionmap_tiling);
    refractionmap_tiling++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "refractionmap_tiling", &refractionmap_tiling, 0)
        && refractionmap_tiling == material->refractionmap_tiling)
      pass ();
    else
      fail ("MATERIAL.refractionmap_tiling [BS] set+1 %hu != %hu", material->refractionmap_tiling, refractionmap_tiling);
    material->refractionmap_tiling--;
  }
  {
    BITCODE_BD* refractionmap_transmatrix;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refractionmap_transmatrix", &refractionmap_transmatrix, NULL)
        && !memcmp (&refractionmap_transmatrix, &material->refractionmap_transmatrix, sizeof (material->refractionmap_transmatrix)))
        pass ();
    else
        fail ("MATERIAL.refractionmap_transmatrix [BD*]");
  }
  {
    BITCODE_BL self_illumination;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "self_illumination", &self_illumination, NULL)
        && self_illumination == material->self_illumination)
      pass ();
    else
      fail ("MATERIAL.self_illumination [BL] %u != %u", material->self_illumination, self_illumination);
    self_illumination++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "self_illumination", &self_illumination, 0)
        && self_illumination == material->self_illumination)
      pass ();
    else
      fail ("MATERIAL.self_illumination [BL] set+1 %u != %u", material->self_illumination, self_illumination);
    material->self_illumination--;
  }
  {
    BITCODE_CMC specular_color;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specular_color", &specular_color, NULL)
        && !memcmp (&specular_color, &material->specular_color, sizeof (material->specular_color)))
        pass ();
    else
        fail ("MATERIAL.specular_color [CMC]");
  }
  {
    BITCODE_BD specular_color_factor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specular_color_factor", &specular_color_factor, NULL)
        && specular_color_factor == material->specular_color_factor)
      pass ();
    else
      fail ("MATERIAL.specular_color_factor [BD] %g != %g", material->specular_color_factor, specular_color_factor);
    specular_color_factor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specular_color_factor", &specular_color_factor, 0)
        && specular_color_factor == material->specular_color_factor)
      pass ();
    else
      fail ("MATERIAL.specular_color_factor [BD] set+1 %g != %g", material->specular_color_factor, specular_color_factor);
    material->specular_color_factor--;
  }
  {
    BITCODE_BS specular_color_flag;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specular_color_flag", &specular_color_flag, NULL)
        && specular_color_flag == material->specular_color_flag)
      pass ();
    else
      fail ("MATERIAL.specular_color_flag [BS] %hu != %hu", material->specular_color_flag, specular_color_flag);
    specular_color_flag++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specular_color_flag", &specular_color_flag, 0)
        && specular_color_flag == material->specular_color_flag)
      pass ();
    else
      fail ("MATERIAL.specular_color_flag [BS] set+1 %hu != %hu", material->specular_color_flag, specular_color_flag);
    material->specular_color_flag--;
  }
  {
    BITCODE_BD specular_gloss_factor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specular_gloss_factor", &specular_gloss_factor, NULL)
        && specular_gloss_factor == material->specular_gloss_factor)
      pass ();
    else
      fail ("MATERIAL.specular_gloss_factor [BD] %g != %g", material->specular_gloss_factor, specular_gloss_factor);
    specular_gloss_factor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specular_gloss_factor", &specular_gloss_factor, 0)
        && specular_gloss_factor == material->specular_gloss_factor)
      pass ();
    else
      fail ("MATERIAL.specular_gloss_factor [BD] set+1 %g != %g", material->specular_gloss_factor, specular_gloss_factor);
    material->specular_gloss_factor--;
  }
  {
    BITCODE_BS specularmap_autotransform;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specularmap_autotransform", &specularmap_autotransform, NULL)
        && specularmap_autotransform == material->specularmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.specularmap_autotransform [BS] %hu != %hu", material->specularmap_autotransform, specularmap_autotransform);
    specularmap_autotransform++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specularmap_autotransform", &specularmap_autotransform, 0)
        && specularmap_autotransform == material->specularmap_autotransform)
      pass ();
    else
      fail ("MATERIAL.specularmap_autotransform [BS] set+1 %hu != %hu", material->specularmap_autotransform, specularmap_autotransform);
    material->specularmap_autotransform--;
  }
  {
    BITCODE_BD specularmap_blendfactor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specularmap_blendfactor", &specularmap_blendfactor, NULL)
        && specularmap_blendfactor == material->specularmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.specularmap_blendfactor [BD] %g != %g", material->specularmap_blendfactor, specularmap_blendfactor);
    specularmap_blendfactor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specularmap_blendfactor", &specularmap_blendfactor, 0)
        && specularmap_blendfactor == material->specularmap_blendfactor)
      pass ();
    else
      fail ("MATERIAL.specularmap_blendfactor [BD] set+1 %g != %g", material->specularmap_blendfactor, specularmap_blendfactor);
    material->specularmap_blendfactor--;
  }
  {
    BITCODE_T specularmap_filename;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specularmap_filename", &specularmap_filename, NULL)
        && specularmap_filename
           ? strEQ ((char *)specularmap_filename, (char *)material->specularmap_filename)
           : !material->specularmap_filename)
      pass ();
    else
      fail ("MATERIAL.specularmap_filename [T] '%s' <> '%s'", specularmap_filename, material->specularmap_filename);
  }
  {
    BITCODE_BS specularmap_projection;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specularmap_projection", &specularmap_projection, NULL)
        && specularmap_projection == material->specularmap_projection)
      pass ();
    else
      fail ("MATERIAL.specularmap_projection [BS] %hu != %hu", material->specularmap_projection, specularmap_projection);
    specularmap_projection++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specularmap_projection", &specularmap_projection, 0)
        && specularmap_projection == material->specularmap_projection)
      pass ();
    else
      fail ("MATERIAL.specularmap_projection [BS] set+1 %hu != %hu", material->specularmap_projection, specularmap_projection);
    material->specularmap_projection--;
  }
  {
    BITCODE_BS specularmap_source;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specularmap_source", &specularmap_source, NULL)
        && specularmap_source == material->specularmap_source)
      pass ();
    else
      fail ("MATERIAL.specularmap_source [BS] %hu != %hu", material->specularmap_source, specularmap_source);
    specularmap_source++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specularmap_source", &specularmap_source, 0)
        && specularmap_source == material->specularmap_source)
      pass ();
    else
      fail ("MATERIAL.specularmap_source [BS] set+1 %hu != %hu", material->specularmap_source, specularmap_source);
    material->specularmap_source--;
  }
  {
    BITCODE_BS specularmap_tiling;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specularmap_tiling", &specularmap_tiling, NULL)
        && specularmap_tiling == material->specularmap_tiling)
      pass ();
    else
      fail ("MATERIAL.specularmap_tiling [BS] %hu != %hu", material->specularmap_tiling, specularmap_tiling);
    specularmap_tiling++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specularmap_tiling", &specularmap_tiling, 0)
        && specularmap_tiling == material->specularmap_tiling)
      pass ();
    else
      fail ("MATERIAL.specularmap_tiling [BS] set+1 %hu != %hu", material->specularmap_tiling, specularmap_tiling);
    material->specularmap_tiling--;
  }
  {
    BITCODE_BD* specularmap_transmatrix;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specularmap_transmatrix", &specularmap_transmatrix, NULL)
        && !memcmp (&specularmap_transmatrix, &material->specularmap_transmatrix, sizeof (material->specularmap_transmatrix)))
        pass ();
    else
        fail ("MATERIAL.specularmap_transmatrix [BD*]");
  }
  {
    BITCODE_BD translucence;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "translucence", &translucence, NULL)
        && translucence == material->translucence)
      pass ();
    else
      fail ("MATERIAL.translucence [BD] %g != %g", material->translucence, translucence);
    translucence++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "translucence", &translucence, 0)
        && translucence == material->translucence)
      pass ();
    else
      fail ("MATERIAL.translucence [BD] set+1 %g != %g", material->translucence, translucence);
    material->translucence--;
  }
  {
    BITCODE_BD transmittance_scale;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "transmittance_scale", &transmittance_scale, NULL)
        && transmittance_scale == material->transmittance_scale)
      pass ();
    else
      fail ("MATERIAL.transmittance_scale [BD] %g != %g", material->transmittance_scale, transmittance_scale);
    transmittance_scale++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "transmittance_scale", &transmittance_scale, 0)
        && transmittance_scale == material->transmittance_scale)
      pass ();
    else
      fail ("MATERIAL.transmittance_scale [BD] set+1 %g != %g", material->transmittance_scale, transmittance_scale);
    material->transmittance_scale--;
  }
  {
    BITCODE_B two_sided_material;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "two_sided_material", &two_sided_material, NULL)
        && two_sided_material == material->two_sided_material)
      pass ();
    else
      fail ("MATERIAL.two_sided_material [B] " FORMAT_B " != " FORMAT_B "", material->two_sided_material, two_sided_material);
    two_sided_material++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "two_sided_material", &two_sided_material, 0)
        && two_sided_material == material->two_sided_material)
      pass ();
    else
      fail ("MATERIAL.two_sided_material [B] set+1 " FORMAT_B " != " FORMAT_B "", material->two_sided_material, two_sided_material);
    material->two_sided_material--;
  }
  if (failed && (is_class_unstable ("MATERIAL") || is_class_debugging ("MATERIAL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MATERIAL", failed);
      failed = 0;
    }
  return failed;
}
static int test_MLEADEROBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MLEADEROBJECTCONTEXTDATA *restrict mleaderobjectcontextdata = obj->tio.object->tio.MLEADEROBJECTCONTEXTDATA;
  failed = 0;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == mleaderobjectcontextdata->class_version)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.class_version [BS] %hu != %hu", mleaderobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == mleaderobjectcontextdata->class_version)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", mleaderobjectcontextdata->class_version, class_version);
    mleaderobjectcontextdata->class_version--;
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL)
        && defaultflag == mleaderobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", mleaderobjectcontextdata->defaultflag, defaultflag);
    defaultflag++;
    if (dwg_dynapi_entity_set_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "defaultflag", &defaultflag, 0)
        && defaultflag == mleaderobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderobjectcontextdata->defaultflag, defaultflag);
    mleaderobjectcontextdata->defaultflag--;
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "has_file", &has_file, NULL)
        && has_file == mleaderobjectcontextdata->has_file)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", mleaderobjectcontextdata->has_file, has_file);
    has_file++;
    if (dwg_dynapi_entity_set_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "has_file", &has_file, 0)
        && has_file == mleaderobjectcontextdata->has_file)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderobjectcontextdata->has_file, has_file);
    mleaderobjectcontextdata->has_file--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &mleaderobjectcontextdata->parent, sizeof (mleaderobjectcontextdata->parent)))
        pass ();
    else
        fail ("MLEADEROBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &mleaderobjectcontextdata->scale, sizeof (mleaderobjectcontextdata->scale)))
        pass ();
    else
        fail ("MLEADEROBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("MLEADEROBJECTCONTEXTDATA") || is_class_debugging ("MLEADEROBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MLEADEROBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_MLEADERSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MLEADERSTYLE *restrict mleaderstyle = obj->tio.object->tio.MLEADERSTYLE;
  failed = 0;
  {
    BITCODE_BD align_space;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "align_space", &align_space, NULL)
        && align_space == mleaderstyle->align_space)
      pass ();
    else
      fail ("MLEADERSTYLE.align_space [BD] %g != %g", mleaderstyle->align_space, align_space);
    align_space++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "align_space", &align_space, 0)
        && align_space == mleaderstyle->align_space)
      pass ();
    else
      fail ("MLEADERSTYLE.align_space [BD] set+1 %g != %g", mleaderstyle->align_space, align_space);
    mleaderstyle->align_space--;
  }
  {
    BITCODE_H arrow_head;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "arrow_head", &arrow_head, NULL)
        && !memcmp (&arrow_head, &mleaderstyle->arrow_head, sizeof (mleaderstyle->arrow_head)))
        pass ();
    else
        fail ("MLEADERSTYLE.arrow_head [H]");
  }
  {
    BITCODE_BD arrow_head_size;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "arrow_head_size", &arrow_head_size, NULL)
        && arrow_head_size == mleaderstyle->arrow_head_size)
      pass ();
    else
      fail ("MLEADERSTYLE.arrow_head_size [BD] %g != %g", mleaderstyle->arrow_head_size, arrow_head_size);
    arrow_head_size++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "arrow_head_size", &arrow_head_size, 0)
        && arrow_head_size == mleaderstyle->arrow_head_size)
      pass ();
    else
      fail ("MLEADERSTYLE.arrow_head_size [BD] set+1 %g != %g", mleaderstyle->arrow_head_size, arrow_head_size);
    mleaderstyle->arrow_head_size--;
  }
  {
    BITCODE_BS attach_bottom;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_bottom", &attach_bottom, NULL)
        && attach_bottom == mleaderstyle->attach_bottom)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_bottom [BS] %hu != %hu", mleaderstyle->attach_bottom, attach_bottom);
    attach_bottom++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_bottom", &attach_bottom, 0)
        && attach_bottom == mleaderstyle->attach_bottom)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_bottom [BS] set+1 %hu != %hu", mleaderstyle->attach_bottom, attach_bottom);
    mleaderstyle->attach_bottom--;
  }
  {
    BITCODE_BS attach_dir;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_dir", &attach_dir, NULL)
        && attach_dir == mleaderstyle->attach_dir)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_dir [BS] %hu != %hu", mleaderstyle->attach_dir, attach_dir);
    attach_dir++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_dir", &attach_dir, 0)
        && attach_dir == mleaderstyle->attach_dir)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_dir [BS] set+1 %hu != %hu", mleaderstyle->attach_dir, attach_dir);
    mleaderstyle->attach_dir--;
  }
  {
    BITCODE_BS attach_left;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_left", &attach_left, NULL)
        && attach_left == mleaderstyle->attach_left)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_left [BS] %hu != %hu", mleaderstyle->attach_left, attach_left);
    attach_left++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_left", &attach_left, 0)
        && attach_left == mleaderstyle->attach_left)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_left [BS] set+1 %hu != %hu", mleaderstyle->attach_left, attach_left);
    mleaderstyle->attach_left--;
  }
  {
    BITCODE_BS attach_right;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_right", &attach_right, NULL)
        && attach_right == mleaderstyle->attach_right)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_right [BS] %hu != %hu", mleaderstyle->attach_right, attach_right);
    attach_right++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_right", &attach_right, 0)
        && attach_right == mleaderstyle->attach_right)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_right [BS] set+1 %hu != %hu", mleaderstyle->attach_right, attach_right);
    mleaderstyle->attach_right--;
  }
  {
    BITCODE_BS attach_top;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_top", &attach_top, NULL)
        && attach_top == mleaderstyle->attach_top)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_top [BS] %hu != %hu", mleaderstyle->attach_top, attach_top);
    attach_top++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_top", &attach_top, 0)
        && attach_top == mleaderstyle->attach_top)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_top [BS] set+1 %hu != %hu", mleaderstyle->attach_top, attach_top);
    mleaderstyle->attach_top--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block", &block, NULL)
        && !memcmp (&block, &mleaderstyle->block, sizeof (mleaderstyle->block)))
        pass ();
    else
        fail ("MLEADERSTYLE.block [H]");
  }
  {
    BITCODE_CMC block_color;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block_color", &block_color, NULL)
        && !memcmp (&block_color, &mleaderstyle->block_color, sizeof (mleaderstyle->block_color)))
        pass ();
    else
        fail ("MLEADERSTYLE.block_color [CMC]");
  }
  {
    BITCODE_BS block_connection;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block_connection", &block_connection, NULL)
        && block_connection == mleaderstyle->block_connection)
      pass ();
    else
      fail ("MLEADERSTYLE.block_connection [BS] %hu != %hu", mleaderstyle->block_connection, block_connection);
    block_connection++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "block_connection", &block_connection, 0)
        && block_connection == mleaderstyle->block_connection)
      pass ();
    else
      fail ("MLEADERSTYLE.block_connection [BS] set+1 %hu != %hu", mleaderstyle->block_connection, block_connection);
    mleaderstyle->block_connection--;
  }
  {
    BITCODE_BD block_rotation;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block_rotation", &block_rotation, NULL)
        && block_rotation == mleaderstyle->block_rotation)
      pass ();
    else
      fail ("MLEADERSTYLE.block_rotation [BD] %g != %g", mleaderstyle->block_rotation, block_rotation);
    block_rotation++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "block_rotation", &block_rotation, 0)
        && block_rotation == mleaderstyle->block_rotation)
      pass ();
    else
      fail ("MLEADERSTYLE.block_rotation [BD] set+1 %g != %g", mleaderstyle->block_rotation, block_rotation);
    mleaderstyle->block_rotation--;
  }
  {
    BITCODE_3BD block_scale;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block_scale", &block_scale, NULL)
        && !memcmp (&block_scale, &mleaderstyle->block_scale, sizeof (mleaderstyle->block_scale)))
        pass ();
    else
        fail ("MLEADERSTYLE.block_scale [3BD]");
  }
  {
    BITCODE_BD break_size;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "break_size", &break_size, NULL)
        && break_size == mleaderstyle->break_size)
      pass ();
    else
      fail ("MLEADERSTYLE.break_size [BD] %g != %g", mleaderstyle->break_size, break_size);
    break_size++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "break_size", &break_size, 0)
        && break_size == mleaderstyle->break_size)
      pass ();
    else
      fail ("MLEADERSTYLE.break_size [BD] set+1 %g != %g", mleaderstyle->break_size, break_size);
    mleaderstyle->break_size--;
  }
  {
    BITCODE_B changed;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "changed", &changed, NULL)
        && changed == mleaderstyle->changed)
      pass ();
    else
      fail ("MLEADERSTYLE.changed [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->changed, changed);
    changed++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "changed", &changed, 0)
        && changed == mleaderstyle->changed)
      pass ();
    else
      fail ("MLEADERSTYLE.changed [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->changed, changed);
    mleaderstyle->changed--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "class_version", &class_version, NULL)
        && class_version == mleaderstyle->class_version)
      pass ();
    else
      fail ("MLEADERSTYLE.class_version [BS] %hu != %hu", mleaderstyle->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "class_version", &class_version, 0)
        && class_version == mleaderstyle->class_version)
      pass ();
    else
      fail ("MLEADERSTYLE.class_version [BS] set+1 %hu != %hu", mleaderstyle->class_version, class_version);
    mleaderstyle->class_version--;
  }
  {
    BITCODE_BS content_type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "content_type", &content_type, NULL)
        && content_type == mleaderstyle->content_type)
      pass ();
    else
      fail ("MLEADERSTYLE.content_type [BS] %hu != %hu", mleaderstyle->content_type, content_type);
    content_type++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "content_type", &content_type, 0)
        && content_type == mleaderstyle->content_type)
      pass ();
    else
      fail ("MLEADERSTYLE.content_type [BS] set+1 %hu != %hu", mleaderstyle->content_type, content_type);
    mleaderstyle->content_type--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)mleaderstyle->description)
           : !mleaderstyle->description)
      pass ();
    else
      fail ("MLEADERSTYLE.description [T] '%s' <> '%s'", description, mleaderstyle->description);
  }
  {
    BITCODE_BD first_seg_angle;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "first_seg_angle", &first_seg_angle, NULL)
        && first_seg_angle == mleaderstyle->first_seg_angle)
      pass ();
    else
      fail ("MLEADERSTYLE.first_seg_angle [BD] %g != %g", mleaderstyle->first_seg_angle, first_seg_angle);
    first_seg_angle++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "first_seg_angle", &first_seg_angle, 0)
        && first_seg_angle == mleaderstyle->first_seg_angle)
      pass ();
    else
      fail ("MLEADERSTYLE.first_seg_angle [BD] set+1 %g != %g", mleaderstyle->first_seg_angle, first_seg_angle);
    mleaderstyle->first_seg_angle--;
  }
  {
    BITCODE_B has_dogleg;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "has_dogleg", &has_dogleg, NULL)
        && has_dogleg == mleaderstyle->has_dogleg)
      pass ();
    else
      fail ("MLEADERSTYLE.has_dogleg [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_dogleg, has_dogleg);
    has_dogleg++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "has_dogleg", &has_dogleg, 0)
        && has_dogleg == mleaderstyle->has_dogleg)
      pass ();
    else
      fail ("MLEADERSTYLE.has_dogleg [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_dogleg, has_dogleg);
    mleaderstyle->has_dogleg--;
  }
  {
    BITCODE_B has_landing;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "has_landing", &has_landing, NULL)
        && has_landing == mleaderstyle->has_landing)
      pass ();
    else
      fail ("MLEADERSTYLE.has_landing [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_landing, has_landing);
    has_landing++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "has_landing", &has_landing, 0)
        && has_landing == mleaderstyle->has_landing)
      pass ();
    else
      fail ("MLEADERSTYLE.has_landing [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_landing, has_landing);
    mleaderstyle->has_landing--;
  }
  {
    BITCODE_B is_annotative;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "is_annotative", &is_annotative, NULL)
        && is_annotative == mleaderstyle->is_annotative)
      pass ();
    else
      fail ("MLEADERSTYLE.is_annotative [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_annotative, is_annotative);
    is_annotative++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "is_annotative", &is_annotative, 0)
        && is_annotative == mleaderstyle->is_annotative)
      pass ();
    else
      fail ("MLEADERSTYLE.is_annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_annotative, is_annotative);
    mleaderstyle->is_annotative--;
  }
  {
    BITCODE_B is_new_format;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "is_new_format", &is_new_format, NULL)
        && is_new_format == mleaderstyle->is_new_format)
      pass ();
    else
      fail ("MLEADERSTYLE.is_new_format [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_new_format, is_new_format);
    is_new_format++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "is_new_format", &is_new_format, 0)
        && is_new_format == mleaderstyle->is_new_format)
      pass ();
    else
      fail ("MLEADERSTYLE.is_new_format [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_new_format, is_new_format);
    mleaderstyle->is_new_format--;
  }
  {
    BITCODE_BD landing_dist;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "landing_dist", &landing_dist, NULL)
        && landing_dist == mleaderstyle->landing_dist)
      pass ();
    else
      fail ("MLEADERSTYLE.landing_dist [BD] %g != %g", mleaderstyle->landing_dist, landing_dist);
    landing_dist++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "landing_dist", &landing_dist, 0)
        && landing_dist == mleaderstyle->landing_dist)
      pass ();
    else
      fail ("MLEADERSTYLE.landing_dist [BD] set+1 %g != %g", mleaderstyle->landing_dist, landing_dist);
    mleaderstyle->landing_dist--;
  }
  {
    BITCODE_BD landing_gap;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "landing_gap", &landing_gap, NULL)
        && landing_gap == mleaderstyle->landing_gap)
      pass ();
    else
      fail ("MLEADERSTYLE.landing_gap [BD] %g != %g", mleaderstyle->landing_gap, landing_gap);
    landing_gap++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "landing_gap", &landing_gap, 0)
        && landing_gap == mleaderstyle->landing_gap)
      pass ();
    else
      fail ("MLEADERSTYLE.landing_gap [BD] set+1 %g != %g", mleaderstyle->landing_gap, landing_gap);
    mleaderstyle->landing_gap--;
  }
  {
    BITCODE_BS leader_order;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "leader_order", &leader_order, NULL)
        && leader_order == mleaderstyle->leader_order)
      pass ();
    else
      fail ("MLEADERSTYLE.leader_order [BS] %hu != %hu", mleaderstyle->leader_order, leader_order);
    leader_order++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "leader_order", &leader_order, 0)
        && leader_order == mleaderstyle->leader_order)
      pass ();
    else
      fail ("MLEADERSTYLE.leader_order [BS] set+1 %hu != %hu", mleaderstyle->leader_order, leader_order);
    mleaderstyle->leader_order--;
  }
  {
    BITCODE_CMC line_color;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "line_color", &line_color, NULL)
        && !memcmp (&line_color, &mleaderstyle->line_color, sizeof (mleaderstyle->line_color)))
        pass ();
    else
        fail ("MLEADERSTYLE.line_color [CMC]");
  }
  {
    BITCODE_H line_type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "line_type", &line_type, NULL)
        && !memcmp (&line_type, &mleaderstyle->line_type, sizeof (mleaderstyle->line_type)))
        pass ();
    else
        fail ("MLEADERSTYLE.line_type [H]");
  }
  {
    BITCODE_BLd linewt;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "linewt", &linewt, NULL)
        && linewt == mleaderstyle->linewt)
      pass ();
    else
      fail ("MLEADERSTYLE.linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", mleaderstyle->linewt, linewt);
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "linewt", &linewt, 0)
        && linewt == mleaderstyle->linewt)
      pass ();
    else
      fail ("MLEADERSTYLE.linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", mleaderstyle->linewt, linewt);
    mleaderstyle->linewt--;
  }
  {
    BITCODE_BL max_points;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "max_points", &max_points, NULL)
        && max_points == mleaderstyle->max_points)
      pass ();
    else
      fail ("MLEADERSTYLE.max_points [BL] %u != %u", mleaderstyle->max_points, max_points);
    max_points++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "max_points", &max_points, 0)
        && max_points == mleaderstyle->max_points)
      pass ();
    else
      fail ("MLEADERSTYLE.max_points [BL] set+1 %u != %u", mleaderstyle->max_points, max_points);
    mleaderstyle->max_points--;
  }
  {
    BITCODE_BS mleader_order;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "mleader_order", &mleader_order, NULL)
        && mleader_order == mleaderstyle->mleader_order)
      pass ();
    else
      fail ("MLEADERSTYLE.mleader_order [BS] %hu != %hu", mleaderstyle->mleader_order, mleader_order);
    mleader_order++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "mleader_order", &mleader_order, 0)
        && mleader_order == mleaderstyle->mleader_order)
      pass ();
    else
      fail ("MLEADERSTYLE.mleader_order [BS] set+1 %hu != %hu", mleaderstyle->mleader_order, mleader_order);
    mleaderstyle->mleader_order--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &mleaderstyle->parent, sizeof (mleaderstyle->parent)))
        pass ();
    else
        fail ("MLEADERSTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "scale", &scale, NULL)
        && scale == mleaderstyle->scale)
      pass ();
    else
      fail ("MLEADERSTYLE.scale [BD] %g != %g", mleaderstyle->scale, scale);
    scale++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "scale", &scale, 0)
        && scale == mleaderstyle->scale)
      pass ();
    else
      fail ("MLEADERSTYLE.scale [BD] set+1 %g != %g", mleaderstyle->scale, scale);
    mleaderstyle->scale--;
  }
  {
    BITCODE_BD second_seg_angle;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "second_seg_angle", &second_seg_angle, NULL)
        && second_seg_angle == mleaderstyle->second_seg_angle)
      pass ();
    else
      fail ("MLEADERSTYLE.second_seg_angle [BD] %g != %g", mleaderstyle->second_seg_angle, second_seg_angle);
    second_seg_angle++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "second_seg_angle", &second_seg_angle, 0)
        && second_seg_angle == mleaderstyle->second_seg_angle)
      pass ();
    else
      fail ("MLEADERSTYLE.second_seg_angle [BD] set+1 %g != %g", mleaderstyle->second_seg_angle, second_seg_angle);
    mleaderstyle->second_seg_angle--;
  }
  {
    BITCODE_BS text_align_type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_align_type", &text_align_type, NULL)
        && text_align_type == mleaderstyle->text_align_type)
      pass ();
    else
      fail ("MLEADERSTYLE.text_align_type [BS] %hu != %hu", mleaderstyle->text_align_type, text_align_type);
    text_align_type++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_align_type", &text_align_type, 0)
        && text_align_type == mleaderstyle->text_align_type)
      pass ();
    else
      fail ("MLEADERSTYLE.text_align_type [BS] set+1 %hu != %hu", mleaderstyle->text_align_type, text_align_type);
    mleaderstyle->text_align_type--;
  }
  {
    BITCODE_B text_always_left;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_always_left", &text_always_left, NULL)
        && text_always_left == mleaderstyle->text_always_left)
      pass ();
    else
      fail ("MLEADERSTYLE.text_always_left [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_always_left, text_always_left);
    text_always_left++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_always_left", &text_always_left, 0)
        && text_always_left == mleaderstyle->text_always_left)
      pass ();
    else
      fail ("MLEADERSTYLE.text_always_left [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_always_left, text_always_left);
    mleaderstyle->text_always_left--;
  }
  {
    BITCODE_BS text_angle_type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_angle_type", &text_angle_type, NULL)
        && text_angle_type == mleaderstyle->text_angle_type)
      pass ();
    else
      fail ("MLEADERSTYLE.text_angle_type [BS] %hu != %hu", mleaderstyle->text_angle_type, text_angle_type);
    text_angle_type++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_angle_type", &text_angle_type, 0)
        && text_angle_type == mleaderstyle->text_angle_type)
      pass ();
    else
      fail ("MLEADERSTYLE.text_angle_type [BS] set+1 %hu != %hu", mleaderstyle->text_angle_type, text_angle_type);
    mleaderstyle->text_angle_type--;
  }
  {
    BITCODE_CMC text_color;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_color", &text_color, NULL)
        && !memcmp (&text_color, &mleaderstyle->text_color, sizeof (mleaderstyle->text_color)))
        pass ();
    else
        fail ("MLEADERSTYLE.text_color [CMC]");
  }
  {
    BITCODE_T text_default;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_default", &text_default, NULL)
        && text_default
           ? strEQ ((char *)text_default, (char *)mleaderstyle->text_default)
           : !mleaderstyle->text_default)
      pass ();
    else
      fail ("MLEADERSTYLE.text_default [T] '%s' <> '%s'", text_default, mleaderstyle->text_default);
  }
  {
    BITCODE_B text_extended;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_extended", &text_extended, NULL)
        && text_extended == mleaderstyle->text_extended)
      pass ();
    else
      fail ("MLEADERSTYLE.text_extended [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_extended, text_extended);
    text_extended++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_extended", &text_extended, 0)
        && text_extended == mleaderstyle->text_extended)
      pass ();
    else
      fail ("MLEADERSTYLE.text_extended [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_extended, text_extended);
    mleaderstyle->text_extended--;
  }
  {
    BITCODE_B text_frame;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_frame", &text_frame, NULL)
        && text_frame == mleaderstyle->text_frame)
      pass ();
    else
      fail ("MLEADERSTYLE.text_frame [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_frame, text_frame);
    text_frame++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_frame", &text_frame, 0)
        && text_frame == mleaderstyle->text_frame)
      pass ();
    else
      fail ("MLEADERSTYLE.text_frame [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_frame, text_frame);
    mleaderstyle->text_frame--;
  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_height", &text_height, NULL)
        && text_height == mleaderstyle->text_height)
      pass ();
    else
      fail ("MLEADERSTYLE.text_height [BD] %g != %g", mleaderstyle->text_height, text_height);
    text_height++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_height", &text_height, 0)
        && text_height == mleaderstyle->text_height)
      pass ();
    else
      fail ("MLEADERSTYLE.text_height [BD] set+1 %g != %g", mleaderstyle->text_height, text_height);
    mleaderstyle->text_height--;
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_style", &text_style, NULL)
        && !memcmp (&text_style, &mleaderstyle->text_style, sizeof (mleaderstyle->text_style)))
        pass ();
    else
        fail ("MLEADERSTYLE.text_style [H]");
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "type", &type, NULL)
        && type == mleaderstyle->type)
      pass ();
    else
      fail ("MLEADERSTYLE.type [BS] %hu != %hu", mleaderstyle->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "type", &type, 0)
        && type == mleaderstyle->type)
      pass ();
    else
      fail ("MLEADERSTYLE.type [BS] set+1 %hu != %hu", mleaderstyle->type, type);
    mleaderstyle->type--;
  }
  {
    BITCODE_B use_block_rotation;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "use_block_rotation", &use_block_rotation, NULL)
        && use_block_rotation == mleaderstyle->use_block_rotation)
      pass ();
    else
      fail ("MLEADERSTYLE.use_block_rotation [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_rotation, use_block_rotation);
    use_block_rotation++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "use_block_rotation", &use_block_rotation, 0)
        && use_block_rotation == mleaderstyle->use_block_rotation)
      pass ();
    else
      fail ("MLEADERSTYLE.use_block_rotation [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_rotation, use_block_rotation);
    mleaderstyle->use_block_rotation--;
  }
  {
    BITCODE_B use_block_scale;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "use_block_scale", &use_block_scale, NULL)
        && use_block_scale == mleaderstyle->use_block_scale)
      pass ();
    else
      fail ("MLEADERSTYLE.use_block_scale [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_scale, use_block_scale);
    use_block_scale++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "use_block_scale", &use_block_scale, 0)
        && use_block_scale == mleaderstyle->use_block_scale)
      pass ();
    else
      fail ("MLEADERSTYLE.use_block_scale [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_scale, use_block_scale);
    mleaderstyle->use_block_scale--;
  }
  if (failed && (is_class_unstable ("MLEADERSTYLE") || is_class_debugging ("MLEADERSTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MLEADERSTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_MLINESTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MLINESTYLE *restrict mlinestyle = obj->tio.object->tio.MLINESTYLE;
  failed = 0;
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)mlinestyle->description)
           : !mlinestyle->description)
      pass ();
    else
      fail ("MLINESTYLE.description [T] '%s' <> '%s'", description, mlinestyle->description);
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "end_angle", &end_angle, NULL)
        && end_angle == mlinestyle->end_angle)
      pass ();
    else
      fail ("MLINESTYLE.end_angle [BD] %g != %g", mlinestyle->end_angle, end_angle);
    end_angle++;
    if (dwg_dynapi_entity_set_value (mlinestyle, "MLINESTYLE", "end_angle", &end_angle, 0)
        && end_angle == mlinestyle->end_angle)
      pass ();
    else
      fail ("MLINESTYLE.end_angle [BD] set+1 %g != %g", mlinestyle->end_angle, end_angle);
    mlinestyle->end_angle--;
  }
  {
    BITCODE_CMC fill_color;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "fill_color", &fill_color, NULL)
        && !memcmp (&fill_color, &mlinestyle->fill_color, sizeof (mlinestyle->fill_color)))
        pass ();
    else
        fail ("MLINESTYLE.fill_color [CMC]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "flag", &flag, NULL)
        && flag == mlinestyle->flag)
      pass ();
    else
      fail ("MLINESTYLE.flag [BS] %hu != %hu", mlinestyle->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (mlinestyle, "MLINESTYLE", "flag", &flag, 0)
        && flag == mlinestyle->flag)
      pass ();
    else
      fail ("MLINESTYLE.flag [BS] set+1 %hu != %hu", mlinestyle->flag, flag);
    mlinestyle->flag--;
  }
  {
    Dwg_MLINESTYLE_line* lines;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "num_lines", &count, NULL)
        && dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "lines", &lines, NULL)
        && lines == mlinestyle->lines)
      pass ();
    else
      fail ("MLINESTYLE.lines [Dwg_MLINESTYLE_line*] * %u num_lines", count);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)mlinestyle->name)
           : !mlinestyle->name)
      pass ();
    else
      fail ("MLINESTYLE.name [T] '%s' <> '%s'", name, mlinestyle->name);
  }
  {
    BITCODE_RC num_lines;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "num_lines", &num_lines, NULL)
        && num_lines == mlinestyle->num_lines)
      pass ();
    else
      fail ("MLINESTYLE.num_lines [RC] %u != %u", mlinestyle->num_lines, num_lines);
    num_lines++;
    if (dwg_dynapi_entity_set_value (mlinestyle, "MLINESTYLE", "num_lines", &num_lines, 0)
        && num_lines == mlinestyle->num_lines)
      pass ();
    else
      fail ("MLINESTYLE.num_lines [RC] set+1 %u != %u", mlinestyle->num_lines, num_lines);
    mlinestyle->num_lines--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &mlinestyle->parent, sizeof (mlinestyle->parent)))
        pass ();
    else
        fail ("MLINESTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "start_angle", &start_angle, NULL)
        && start_angle == mlinestyle->start_angle)
      pass ();
    else
      fail ("MLINESTYLE.start_angle [BD] %g != %g", mlinestyle->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (mlinestyle, "MLINESTYLE", "start_angle", &start_angle, 0)
        && start_angle == mlinestyle->start_angle)
      pass ();
    else
      fail ("MLINESTYLE.start_angle [BD] set+1 %g != %g", mlinestyle->start_angle, start_angle);
    mlinestyle->start_angle--;
  }
  if (failed && (is_class_unstable ("MLINESTYLE") || is_class_debugging ("MLINESTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MLINESTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_MTEXTATTRIBUTEOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MTEXTATTRIBUTEOBJECTCONTEXTDATA *restrict mtextattributeobjectcontextdata = obj->tio.object->tio.MTEXTATTRIBUTEOBJECTCONTEXTDATA;
  failed = 0;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == mtextattributeobjectcontextdata->class_version)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", mtextattributeobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == mtextattributeobjectcontextdata->class_version)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", mtextattributeobjectcontextdata->class_version, class_version);
    mtextattributeobjectcontextdata->class_version--;
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL)
        && defaultflag == mtextattributeobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", mtextattributeobjectcontextdata->defaultflag, defaultflag);
    defaultflag++;
    if (dwg_dynapi_entity_set_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "defaultflag", &defaultflag, 0)
        && defaultflag == mtextattributeobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextattributeobjectcontextdata->defaultflag, defaultflag);
    mtextattributeobjectcontextdata->defaultflag--;
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "has_file", &has_file, NULL)
        && has_file == mtextattributeobjectcontextdata->has_file)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", mtextattributeobjectcontextdata->has_file, has_file);
    has_file++;
    if (dwg_dynapi_entity_set_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "has_file", &has_file, 0)
        && has_file == mtextattributeobjectcontextdata->has_file)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextattributeobjectcontextdata->has_file, has_file);
    mtextattributeobjectcontextdata->has_file--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &mtextattributeobjectcontextdata->parent, sizeof (mtextattributeobjectcontextdata->parent)))
        pass ();
    else
        fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &mtextattributeobjectcontextdata->scale, sizeof (mtextattributeobjectcontextdata->scale)))
        pass ();
    else
        fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("MTEXTATTRIBUTEOBJECTCONTEXTDATA") || is_class_debugging ("MTEXTATTRIBUTEOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MTEXTATTRIBUTEOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_MTEXTOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MTEXTOBJECTCONTEXTDATA *restrict mtextobjectcontextdata = obj->tio.object->tio.MTEXTOBJECTCONTEXTDATA;
  failed = 0;
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "attachment", &attachment, NULL)
        && attachment == mtextobjectcontextdata->attachment)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.attachment [BS] %hu != %hu", mtextobjectcontextdata->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "attachment", &attachment, 0)
        && attachment == mtextobjectcontextdata->attachment)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.attachment [BS] set+1 %hu != %hu", mtextobjectcontextdata->attachment, attachment);
    mtextobjectcontextdata->attachment--;
  }
  {
    BITCODE_BD bd45;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "bd45", &bd45, NULL)
        && bd45 == mtextobjectcontextdata->bd45)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.bd45 [BD] %g != %g", mtextobjectcontextdata->bd45, bd45);
    bd45++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "bd45", &bd45, 0)
        && bd45 == mtextobjectcontextdata->bd45)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.bd45 [BD] set+1 %g != %g", mtextobjectcontextdata->bd45, bd45);
    mtextobjectcontextdata->bd45--;
  }
  {
    BITCODE_BD bd46;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "bd46", &bd46, NULL)
        && bd46 == mtextobjectcontextdata->bd46)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.bd46 [BD] %g != %g", mtextobjectcontextdata->bd46, bd46);
    bd46++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "bd46", &bd46, 0)
        && bd46 == mtextobjectcontextdata->bd46)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.bd46 [BD] set+1 %g != %g", mtextobjectcontextdata->bd46, bd46);
    mtextobjectcontextdata->bd46--;
  }
  {
    BITCODE_BS bs74;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "bs74", &bs74, NULL)
        && bs74 == mtextobjectcontextdata->bs74)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.bs74 [BS] %hu != %hu", mtextobjectcontextdata->bs74, bs74);
    bs74++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "bs74", &bs74, 0)
        && bs74 == mtextobjectcontextdata->bs74)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.bs74 [BS] set+1 %hu != %hu", mtextobjectcontextdata->bs74, bs74);
    mtextobjectcontextdata->bs74--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == mtextobjectcontextdata->class_version)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", mtextobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == mtextobjectcontextdata->class_version)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", mtextobjectcontextdata->class_version, class_version);
    mtextobjectcontextdata->class_version--;
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL)
        && defaultflag == mtextobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->defaultflag, defaultflag);
    defaultflag++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "defaultflag", &defaultflag, 0)
        && defaultflag == mtextobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->defaultflag, defaultflag);
    mtextobjectcontextdata->defaultflag--;
  }
  {
    BITCODE_BS drawing_dir;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "drawing_dir", &drawing_dir, NULL)
        && drawing_dir == mtextobjectcontextdata->drawing_dir)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.drawing_dir [BS] %hu != %hu", mtextobjectcontextdata->drawing_dir, drawing_dir);
    drawing_dir++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "drawing_dir", &drawing_dir, 0)
        && drawing_dir == mtextobjectcontextdata->drawing_dir)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.drawing_dir [BS] set+1 %hu != %hu", mtextobjectcontextdata->drawing_dir, drawing_dir);
    mtextobjectcontextdata->drawing_dir--;
  }
  {
    BITCODE_BD extents_height;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "extents_height", &extents_height, NULL)
        && extents_height == mtextobjectcontextdata->extents_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.extents_height [BD] %g != %g", mtextobjectcontextdata->extents_height, extents_height);
    extents_height++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "extents_height", &extents_height, 0)
        && extents_height == mtextobjectcontextdata->extents_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.extents_height [BD] set+1 %g != %g", mtextobjectcontextdata->extents_height, extents_height);
    mtextobjectcontextdata->extents_height--;
  }
  {
    BITCODE_BD extents_width;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "extents_width", &extents_width, NULL)
        && extents_width == mtextobjectcontextdata->extents_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.extents_width [BD] %g != %g", mtextobjectcontextdata->extents_width, extents_width);
    extents_width++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "extents_width", &extents_width, 0)
        && extents_width == mtextobjectcontextdata->extents_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.extents_width [BD] set+1 %g != %g", mtextobjectcontextdata->extents_width, extents_width);
    mtextobjectcontextdata->extents_width--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "flag", &flag, NULL)
        && flag == mtextobjectcontextdata->flag)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.flag [BS] %hu != %hu", mtextobjectcontextdata->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "flag", &flag, 0)
        && flag == mtextobjectcontextdata->flag)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.flag [BS] set+1 %hu != %hu", mtextobjectcontextdata->flag, flag);
    mtextobjectcontextdata->flag--;
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "has_file", &has_file, NULL)
        && has_file == mtextobjectcontextdata->has_file)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->has_file, has_file);
    has_file++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "has_file", &has_file, 0)
        && has_file == mtextobjectcontextdata->has_file)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->has_file, has_file);
    mtextobjectcontextdata->has_file--;
  }
  {
    BITCODE_3BD insertion_pt;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "insertion_pt", &insertion_pt, NULL)
        && !memcmp (&insertion_pt, &mtextobjectcontextdata->insertion_pt, sizeof (mtextobjectcontextdata->insertion_pt)))
        pass ();
    else
        fail ("MTEXTOBJECTCONTEXTDATA.insertion_pt [3BD]");
  }
  {
    BITCODE_BD linespace_factor;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "linespace_factor", &linespace_factor, NULL)
        && linespace_factor == mtextobjectcontextdata->linespace_factor)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.linespace_factor [BD] %g != %g", mtextobjectcontextdata->linespace_factor, linespace_factor);
    linespace_factor++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "linespace_factor", &linespace_factor, 0)
        && linespace_factor == mtextobjectcontextdata->linespace_factor)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.linespace_factor [BD] set+1 %g != %g", mtextobjectcontextdata->linespace_factor, linespace_factor);
    mtextobjectcontextdata->linespace_factor--;
  }
  {
    BITCODE_BS linespace_style;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "linespace_style", &linespace_style, NULL)
        && linespace_style == mtextobjectcontextdata->linespace_style)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.linespace_style [BS] %hu != %hu", mtextobjectcontextdata->linespace_style, linespace_style);
    linespace_style++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "linespace_style", &linespace_style, 0)
        && linespace_style == mtextobjectcontextdata->linespace_style)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.linespace_style [BS] set+1 %hu != %hu", mtextobjectcontextdata->linespace_style, linespace_style);
    mtextobjectcontextdata->linespace_style--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &mtextobjectcontextdata->parent, sizeof (mtextobjectcontextdata->parent)))
        pass ();
    else
        fail ("MTEXTOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD rect_height;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "rect_height", &rect_height, NULL)
        && rect_height == mtextobjectcontextdata->rect_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.rect_height [BD] %g != %g", mtextobjectcontextdata->rect_height, rect_height);
    rect_height++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "rect_height", &rect_height, 0)
        && rect_height == mtextobjectcontextdata->rect_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.rect_height [BD] set+1 %g != %g", mtextobjectcontextdata->rect_height, rect_height);
    mtextobjectcontextdata->rect_height--;
  }
  {
    BITCODE_BD rect_width;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "rect_width", &rect_width, NULL)
        && rect_width == mtextobjectcontextdata->rect_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.rect_width [BD] %g != %g", mtextobjectcontextdata->rect_width, rect_width);
    rect_width++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "rect_width", &rect_width, 0)
        && rect_width == mtextobjectcontextdata->rect_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.rect_width [BD] set+1 %g != %g", mtextobjectcontextdata->rect_width, rect_width);
    mtextobjectcontextdata->rect_width--;
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &mtextobjectcontextdata->scale, sizeof (mtextobjectcontextdata->scale)))
        pass ();
    else
        fail ("MTEXTOBJECTCONTEXTDATA.scale [H]");
  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "text_height", &text_height, NULL)
        && text_height == mtextobjectcontextdata->text_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.text_height [BD] %g != %g", mtextobjectcontextdata->text_height, text_height);
    text_height++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "text_height", &text_height, 0)
        && text_height == mtextobjectcontextdata->text_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.text_height [BD] set+1 %g != %g", mtextobjectcontextdata->text_height, text_height);
    mtextobjectcontextdata->text_height--;
  }
  {
    BITCODE_3BD x_axis_dir;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "x_axis_dir", &x_axis_dir, NULL)
        && !memcmp (&x_axis_dir, &mtextobjectcontextdata->x_axis_dir, sizeof (mtextobjectcontextdata->x_axis_dir)))
        pass ();
    else
        fail ("MTEXTOBJECTCONTEXTDATA.x_axis_dir [3BD]");
  }
  if (failed && (is_class_unstable ("MTEXTOBJECTCONTEXTDATA") || is_class_debugging ("MTEXTOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MTEXTOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_NAVISWORKSMODELDEF (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_NAVISWORKSMODELDEF *restrict navisworksmodeldef = obj->tio.object->tio.NAVISWORKSMODELDEF;
  failed = 0;
  {
    BITCODE_B host_drawing_visibility;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "host_drawing_visibility", &host_drawing_visibility, NULL)
        && host_drawing_visibility == navisworksmodeldef->host_drawing_visibility)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.host_drawing_visibility [B] " FORMAT_B " != " FORMAT_B "", navisworksmodeldef->host_drawing_visibility, host_drawing_visibility);
    host_drawing_visibility++;
    if (dwg_dynapi_entity_set_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "host_drawing_visibility", &host_drawing_visibility, 0)
        && host_drawing_visibility == navisworksmodeldef->host_drawing_visibility)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.host_drawing_visibility [B] set+1 " FORMAT_B " != " FORMAT_B "", navisworksmodeldef->host_drawing_visibility, host_drawing_visibility);
    navisworksmodeldef->host_drawing_visibility--;
  }
  {
    BITCODE_3BD max_extent;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "max_extent", &max_extent, NULL)
        && !memcmp (&max_extent, &navisworksmodeldef->max_extent, sizeof (navisworksmodeldef->max_extent)))
        pass ();
    else
        fail ("NAVISWORKSMODELDEF.max_extent [3BD]");
  }
  {
    BITCODE_3BD min_extent;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "min_extent", &min_extent, NULL)
        && !memcmp (&min_extent, &navisworksmodeldef->min_extent, sizeof (navisworksmodeldef->min_extent)))
        pass ();
    else
        fail ("NAVISWORKSMODELDEF.min_extent [3BD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "parent", &parent, NULL)
        && !memcmp (&parent, &navisworksmodeldef->parent, sizeof (navisworksmodeldef->parent)))
        pass ();
    else
        fail ("NAVISWORKSMODELDEF.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T path;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "path", &path, NULL)
        && path
           ? strEQ ((char *)path, (char *)navisworksmodeldef->path)
           : !navisworksmodeldef->path)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.path [T] '%s' <> '%s'", path, navisworksmodeldef->path);
  }
  {
    BITCODE_B status;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "status", &status, NULL)
        && status == navisworksmodeldef->status)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.status [B] " FORMAT_B " != " FORMAT_B "", navisworksmodeldef->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "status", &status, 0)
        && status == navisworksmodeldef->status)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.status [B] set+1 " FORMAT_B " != " FORMAT_B "", navisworksmodeldef->status, status);
    navisworksmodeldef->status--;
  }
  if (failed && (is_class_unstable ("NAVISWORKSMODELDEF") || is_class_debugging ("NAVISWORKSMODELDEF")))
    {
      ok ("%s failed %d tests (TODO unstable)", "NAVISWORKSMODELDEF", failed);
      failed = 0;
    }
  return failed;
}
static int test_OBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_OBJECTCONTEXTDATA *restrict objectcontextdata = obj->tio.object->tio.OBJECTCONTEXTDATA;
  failed = 0;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (objectcontextdata, "OBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == objectcontextdata->class_version)
      pass ();
    else
      fail ("OBJECTCONTEXTDATA.class_version [BS] %hu != %hu", objectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (objectcontextdata, "OBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == objectcontextdata->class_version)
      pass ();
    else
      fail ("OBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", objectcontextdata->class_version, class_version);
    objectcontextdata->class_version--;
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value (objectcontextdata, "OBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL)
        && defaultflag == objectcontextdata->defaultflag)
      pass ();
    else
      fail ("OBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", objectcontextdata->defaultflag, defaultflag);
    defaultflag++;
    if (dwg_dynapi_entity_set_value (objectcontextdata, "OBJECTCONTEXTDATA", "defaultflag", &defaultflag, 0)
        && defaultflag == objectcontextdata->defaultflag)
      pass ();
    else
      fail ("OBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", objectcontextdata->defaultflag, defaultflag);
    objectcontextdata->defaultflag--;
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value (objectcontextdata, "OBJECTCONTEXTDATA", "has_file", &has_file, NULL)
        && has_file == objectcontextdata->has_file)
      pass ();
    else
      fail ("OBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", objectcontextdata->has_file, has_file);
    has_file++;
    if (dwg_dynapi_entity_set_value (objectcontextdata, "OBJECTCONTEXTDATA", "has_file", &has_file, 0)
        && has_file == objectcontextdata->has_file)
      pass ();
    else
      fail ("OBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", objectcontextdata->has_file, has_file);
    objectcontextdata->has_file--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (objectcontextdata, "OBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &objectcontextdata->parent, sizeof (objectcontextdata->parent)))
        pass ();
    else
        fail ("OBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("OBJECTCONTEXTDATA") || is_class_debugging ("OBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "OBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_OBJECT_PTR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_OBJECT_PTR *restrict object_ptr = obj->tio.object->tio.OBJECT_PTR;
  failed = 0;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (object_ptr, "OBJECT_PTR", "parent", &parent, NULL)
        && !memcmp (&parent, &object_ptr->parent, sizeof (object_ptr->parent)))
        pass ();
    else
        fail ("OBJECT_PTR.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("OBJECT_PTR") || is_class_debugging ("OBJECT_PTR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "OBJECT_PTR", failed);
      failed = 0;
    }
  return failed;
}
static int test_PERSSUBENTMANAGER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PERSSUBENTMANAGER *restrict perssubentmanager = obj->tio.object->tio.PERSSUBENTMANAGER;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (perssubentmanager, "PERSSUBENTMANAGER", "class_version", &class_version, NULL)
        && class_version == perssubentmanager->class_version)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.class_version [BL] %u != %u", perssubentmanager->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (perssubentmanager, "PERSSUBENTMANAGER", "class_version", &class_version, 0)
        && class_version == perssubentmanager->class_version)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.class_version [BL] set+1 %u != %u", perssubentmanager->class_version, class_version);
    perssubentmanager->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (perssubentmanager, "PERSSUBENTMANAGER", "parent", &parent, NULL)
        && !memcmp (&parent, &perssubentmanager->parent, sizeof (perssubentmanager->parent)))
        pass ();
    else
        fail ("PERSSUBENTMANAGER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1, NULL)
        && unknown_bl1 == perssubentmanager->unknown_bl1)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl1 [BL] %u != %u", perssubentmanager->unknown_bl1, unknown_bl1);
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1, 0)
        && unknown_bl1 == perssubentmanager->unknown_bl1)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl1 [BL] set+1 %u != %u", perssubentmanager->unknown_bl1, unknown_bl1);
    perssubentmanager->unknown_bl1--;
  }
  {
    BITCODE_BL unknown_bl2;
    if (dwg_dynapi_entity_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2, NULL)
        && unknown_bl2 == perssubentmanager->unknown_bl2)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl2 [BL] %u != %u", perssubentmanager->unknown_bl2, unknown_bl2);
    unknown_bl2++;
    if (dwg_dynapi_entity_set_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2, 0)
        && unknown_bl2 == perssubentmanager->unknown_bl2)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl2 [BL] set+1 %u != %u", perssubentmanager->unknown_bl2, unknown_bl2);
    perssubentmanager->unknown_bl2--;
  }
  {
    BITCODE_BL unknown_bl3;
    if (dwg_dynapi_entity_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3, NULL)
        && unknown_bl3 == perssubentmanager->unknown_bl3)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl3 [BL] %u != %u", perssubentmanager->unknown_bl3, unknown_bl3);
    unknown_bl3++;
    if (dwg_dynapi_entity_set_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3, 0)
        && unknown_bl3 == perssubentmanager->unknown_bl3)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl3 [BL] set+1 %u != %u", perssubentmanager->unknown_bl3, unknown_bl3);
    perssubentmanager->unknown_bl3--;
  }
  {
    BITCODE_BL unknown_bl4;
    if (dwg_dynapi_entity_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4, NULL)
        && unknown_bl4 == perssubentmanager->unknown_bl4)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl4 [BL] %u != %u", perssubentmanager->unknown_bl4, unknown_bl4);
    unknown_bl4++;
    if (dwg_dynapi_entity_set_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4, 0)
        && unknown_bl4 == perssubentmanager->unknown_bl4)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl4 [BL] set+1 %u != %u", perssubentmanager->unknown_bl4, unknown_bl4);
    perssubentmanager->unknown_bl4--;
  }
  {
    BITCODE_BL unknown_bl5;
    if (dwg_dynapi_entity_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5, NULL)
        && unknown_bl5 == perssubentmanager->unknown_bl5)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl5 [BL] %u != %u", perssubentmanager->unknown_bl5, unknown_bl5);
    unknown_bl5++;
    if (dwg_dynapi_entity_set_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5, 0)
        && unknown_bl5 == perssubentmanager->unknown_bl5)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl5 [BL] set+1 %u != %u", perssubentmanager->unknown_bl5, unknown_bl5);
    perssubentmanager->unknown_bl5--;
  }
  {
    BITCODE_BL unknown_bl6;
    if (dwg_dynapi_entity_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, NULL)
        && unknown_bl6 == perssubentmanager->unknown_bl6)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl6 [BL] %u != %u", perssubentmanager->unknown_bl6, unknown_bl6);
    unknown_bl6++;
    if (dwg_dynapi_entity_set_value (perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, 0)
        && unknown_bl6 == perssubentmanager->unknown_bl6)
      pass ();
    else
      fail ("PERSSUBENTMANAGER.unknown_bl6 [BL] set+1 %u != %u", perssubentmanager->unknown_bl6, unknown_bl6);
    perssubentmanager->unknown_bl6--;
  }
  if (failed && (is_class_unstable ("PERSSUBENTMANAGER") || is_class_debugging ("PERSSUBENTMANAGER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PERSSUBENTMANAGER", failed);
      failed = 0;
    }
  return failed;
}
static int test_PLACEHOLDER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PLACEHOLDER *restrict placeholder = obj->tio.object->tio.PLACEHOLDER;
  failed = 0;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (placeholder, "PLACEHOLDER", "parent", &parent, NULL)
        && !memcmp (&parent, &placeholder->parent, sizeof (placeholder->parent)))
        pass ();
    else
        fail ("PLACEHOLDER.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("PLACEHOLDER") || is_class_debugging ("PLACEHOLDER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PLACEHOLDER", failed);
      failed = 0;
    }
  return failed;
}
static int test_PLOTSETTINGS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PLOTSETTINGS *restrict plotsettings = obj->tio.object->tio.PLOTSETTINGS;
  failed = 0;
  {
    BITCODE_BD bottom_margin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "bottom_margin", &bottom_margin, NULL)
        && bottom_margin == plotsettings->bottom_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.bottom_margin [BD] %g != %g", plotsettings->bottom_margin, bottom_margin);
    bottom_margin++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "bottom_margin", &bottom_margin, 0)
        && bottom_margin == plotsettings->bottom_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.bottom_margin [BD] set+1 %g != %g", plotsettings->bottom_margin, bottom_margin);
    plotsettings->bottom_margin--;
  }
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "drawing_units", &drawing_units, NULL)
        && drawing_units == plotsettings->drawing_units)
      pass ();
    else
      fail ("PLOTSETTINGS.drawing_units [BD] %g != %g", plotsettings->drawing_units, drawing_units);
    drawing_units++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "drawing_units", &drawing_units, 0)
        && drawing_units == plotsettings->drawing_units)
      pass ();
    else
      fail ("PLOTSETTINGS.drawing_units [BD] set+1 %g != %g", plotsettings->drawing_units, drawing_units);
    plotsettings->drawing_units--;
  }
  {
    BITCODE_BD left_margin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "left_margin", &left_margin, NULL)
        && left_margin == plotsettings->left_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.left_margin [BD] %g != %g", plotsettings->left_margin, left_margin);
    left_margin++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "left_margin", &left_margin, 0)
        && left_margin == plotsettings->left_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.left_margin [BD] set+1 %g != %g", plotsettings->left_margin, left_margin);
    plotsettings->left_margin--;
  }
  {
    BITCODE_T page_setup_name;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "page_setup_name", &page_setup_name, NULL)
        && page_setup_name
           ? strEQ ((char *)page_setup_name, (char *)plotsettings->page_setup_name)
           : !plotsettings->page_setup_name)
      pass ();
    else
      fail ("PLOTSETTINGS.page_setup_name [T] '%s' <> '%s'", page_setup_name, plotsettings->page_setup_name);
  }
  {
    BITCODE_BD paper_height;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_height", &paper_height, NULL)
        && paper_height == plotsettings->paper_height)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_height [BD] %g != %g", plotsettings->paper_height, paper_height);
    paper_height++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "paper_height", &paper_height, 0)
        && paper_height == plotsettings->paper_height)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_height [BD] set+1 %g != %g", plotsettings->paper_height, paper_height);
    plotsettings->paper_height--;
  }
  {
    BITCODE_2BD paper_image_origin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_image_origin", &paper_image_origin, NULL)
        && !memcmp (&paper_image_origin, &plotsettings->paper_image_origin, sizeof (plotsettings->paper_image_origin)))
        pass ();
    else
        fail ("PLOTSETTINGS.paper_image_origin [2BD_1]");
  }
  {
    BITCODE_T paper_size;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_size", &paper_size, NULL)
        && paper_size
           ? strEQ ((char *)paper_size, (char *)plotsettings->paper_size)
           : !plotsettings->paper_size)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_size [T] '%s' <> '%s'", paper_size, plotsettings->paper_size);
  }
  {
    BITCODE_BD paper_units;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_units", &paper_units, NULL)
        && paper_units == plotsettings->paper_units)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_units [BD] %g != %g", plotsettings->paper_units, paper_units);
    paper_units++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "paper_units", &paper_units, 0)
        && paper_units == plotsettings->paper_units)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_units [BD] set+1 %g != %g", plotsettings->paper_units, paper_units);
    plotsettings->paper_units--;
  }
  {
    BITCODE_BD paper_width;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_width", &paper_width, NULL)
        && paper_width == plotsettings->paper_width)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_width [BD] %g != %g", plotsettings->paper_width, paper_width);
    paper_width++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "paper_width", &paper_width, 0)
        && paper_width == plotsettings->paper_width)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_width [BD] set+1 %g != %g", plotsettings->paper_width, paper_width);
    plotsettings->paper_width--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "parent", &parent, NULL)
        && !memcmp (&parent, &plotsettings->parent, sizeof (plotsettings->parent)))
        pass ();
    else
        fail ("PLOTSETTINGS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS plot_layout;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_layout", &plot_layout, NULL)
        && plot_layout == plotsettings->plot_layout)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_layout [BS] %hu != %hu", plotsettings->plot_layout, plot_layout);
    plot_layout++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "plot_layout", &plot_layout, 0)
        && plot_layout == plotsettings->plot_layout)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_layout [BS] set+1 %hu != %hu", plotsettings->plot_layout, plot_layout);
    plotsettings->plot_layout--;
  }
  {
    BITCODE_2BD plot_origin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_origin", &plot_origin, NULL)
        && !memcmp (&plot_origin, &plotsettings->plot_origin, sizeof (plotsettings->plot_origin)))
        pass ();
    else
        fail ("PLOTSETTINGS.plot_origin [2BD_1]");
  }
  {
    BITCODE_BS plot_paper_unit;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_paper_unit", &plot_paper_unit, NULL)
        && plot_paper_unit == plotsettings->plot_paper_unit)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_paper_unit [BS] %hu != %hu", plotsettings->plot_paper_unit, plot_paper_unit);
    plot_paper_unit++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "plot_paper_unit", &plot_paper_unit, 0)
        && plot_paper_unit == plotsettings->plot_paper_unit)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_paper_unit [BS] set+1 %hu != %hu", plotsettings->plot_paper_unit, plot_paper_unit);
    plotsettings->plot_paper_unit--;
  }
  {
    BITCODE_BS plot_rotation;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_rotation", &plot_rotation, NULL)
        && plot_rotation == plotsettings->plot_rotation)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_rotation [BS] %hu != %hu", plotsettings->plot_rotation, plot_rotation);
    plot_rotation++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "plot_rotation", &plot_rotation, 0)
        && plot_rotation == plotsettings->plot_rotation)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_rotation [BS] set+1 %hu != %hu", plotsettings->plot_rotation, plot_rotation);
    plotsettings->plot_rotation--;
  }
  {
    BITCODE_BS plot_type;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_type", &plot_type, NULL)
        && plot_type == plotsettings->plot_type)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_type [BS] %hu != %hu", plotsettings->plot_type, plot_type);
    plot_type++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "plot_type", &plot_type, 0)
        && plot_type == plotsettings->plot_type)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_type [BS] set+1 %hu != %hu", plotsettings->plot_type, plot_type);
    plotsettings->plot_type--;
  }
  {
    BITCODE_2BD plot_window_ll;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_window_ll", &plot_window_ll, NULL)
        && !memcmp (&plot_window_ll, &plotsettings->plot_window_ll, sizeof (plotsettings->plot_window_ll)))
        pass ();
    else
        fail ("PLOTSETTINGS.plot_window_ll [2BD_1]");
  }
  {
    BITCODE_2BD plot_window_ur;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_window_ur", &plot_window_ur, NULL)
        && !memcmp (&plot_window_ur, &plotsettings->plot_window_ur, sizeof (plotsettings->plot_window_ur)))
        pass ();
    else
        fail ("PLOTSETTINGS.plot_window_ur [2BD_1]");
  }
  {
    BITCODE_H plotview;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plotview", &plotview, NULL)
        && !memcmp (&plotview, &plotsettings->plotview, sizeof (plotsettings->plotview)))
        pass ();
    else
        fail ("PLOTSETTINGS.plotview [H]");
  }
  {
    BITCODE_T printer_cfg_file;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "printer_cfg_file", &printer_cfg_file, NULL)
        && printer_cfg_file
           ? strEQ ((char *)printer_cfg_file, (char *)plotsettings->printer_cfg_file)
           : !plotsettings->printer_cfg_file)
      pass ();
    else
      fail ("PLOTSETTINGS.printer_cfg_file [T] '%s' <> '%s'", printer_cfg_file, plotsettings->printer_cfg_file);
  }
  {
    BITCODE_BD right_margin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "right_margin", &right_margin, NULL)
        && right_margin == plotsettings->right_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.right_margin [BD] %g != %g", plotsettings->right_margin, right_margin);
    right_margin++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "right_margin", &right_margin, 0)
        && right_margin == plotsettings->right_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.right_margin [BD] set+1 %g != %g", plotsettings->right_margin, right_margin);
    plotsettings->right_margin--;
  }
  {
    BITCODE_BS shade_plot_customdpi;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "shade_plot_customdpi", &shade_plot_customdpi, NULL)
        && shade_plot_customdpi == plotsettings->shade_plot_customdpi)
      pass ();
    else
      fail ("PLOTSETTINGS.shade_plot_customdpi [BS] %hu != %hu", plotsettings->shade_plot_customdpi, shade_plot_customdpi);
    shade_plot_customdpi++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "shade_plot_customdpi", &shade_plot_customdpi, 0)
        && shade_plot_customdpi == plotsettings->shade_plot_customdpi)
      pass ();
    else
      fail ("PLOTSETTINGS.shade_plot_customdpi [BS] set+1 %hu != %hu", plotsettings->shade_plot_customdpi, shade_plot_customdpi);
    plotsettings->shade_plot_customdpi--;
  }
  {
    BITCODE_H shade_plot_id;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "shade_plot_id", &shade_plot_id, NULL)
        && !memcmp (&shade_plot_id, &plotsettings->shade_plot_id, sizeof (plotsettings->shade_plot_id)))
        pass ();
    else
        fail ("PLOTSETTINGS.shade_plot_id [H]");
  }
  {
    BITCODE_BS shade_plot_mode;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "shade_plot_mode", &shade_plot_mode, NULL)
        && shade_plot_mode == plotsettings->shade_plot_mode)
      pass ();
    else
      fail ("PLOTSETTINGS.shade_plot_mode [BS] %hu != %hu", plotsettings->shade_plot_mode, shade_plot_mode);
    shade_plot_mode++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "shade_plot_mode", &shade_plot_mode, 0)
        && shade_plot_mode == plotsettings->shade_plot_mode)
      pass ();
    else
      fail ("PLOTSETTINGS.shade_plot_mode [BS] set+1 %hu != %hu", plotsettings->shade_plot_mode, shade_plot_mode);
    plotsettings->shade_plot_mode--;
  }
  {
    BITCODE_BS shade_plot_reslevel;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "shade_plot_reslevel", &shade_plot_reslevel, NULL)
        && shade_plot_reslevel == plotsettings->shade_plot_reslevel)
      pass ();
    else
      fail ("PLOTSETTINGS.shade_plot_reslevel [BS] %hu != %hu", plotsettings->shade_plot_reslevel, shade_plot_reslevel);
    shade_plot_reslevel++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "shade_plot_reslevel", &shade_plot_reslevel, 0)
        && shade_plot_reslevel == plotsettings->shade_plot_reslevel)
      pass ();
    else
      fail ("PLOTSETTINGS.shade_plot_reslevel [BS] set+1 %hu != %hu", plotsettings->shade_plot_reslevel, shade_plot_reslevel);
    plotsettings->shade_plot_reslevel--;
  }
  {
    BITCODE_BD std_scale_factor;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "std_scale_factor", &std_scale_factor, NULL)
        && std_scale_factor == plotsettings->std_scale_factor)
      pass ();
    else
      fail ("PLOTSETTINGS.std_scale_factor [BD] %g != %g", plotsettings->std_scale_factor, std_scale_factor);
    std_scale_factor++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "std_scale_factor", &std_scale_factor, 0)
        && std_scale_factor == plotsettings->std_scale_factor)
      pass ();
    else
      fail ("PLOTSETTINGS.std_scale_factor [BD] set+1 %g != %g", plotsettings->std_scale_factor, std_scale_factor);
    plotsettings->std_scale_factor--;
  }
  {
    BITCODE_BS std_scale_type;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "std_scale_type", &std_scale_type, NULL)
        && std_scale_type == plotsettings->std_scale_type)
      pass ();
    else
      fail ("PLOTSETTINGS.std_scale_type [BS] %hu != %hu", plotsettings->std_scale_type, std_scale_type);
    std_scale_type++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "std_scale_type", &std_scale_type, 0)
        && std_scale_type == plotsettings->std_scale_type)
      pass ();
    else
      fail ("PLOTSETTINGS.std_scale_type [BS] set+1 %hu != %hu", plotsettings->std_scale_type, std_scale_type);
    plotsettings->std_scale_type--;
  }
  {
    BITCODE_H stylesheet;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "stylesheet", &stylesheet, NULL)
        && !memcmp (&stylesheet, &plotsettings->stylesheet, sizeof (plotsettings->stylesheet)))
        pass ();
    else
        fail ("PLOTSETTINGS.stylesheet [H]");
  }
  {
    BITCODE_BD top_margin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "top_margin", &top_margin, NULL)
        && top_margin == plotsettings->top_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.top_margin [BD] %g != %g", plotsettings->top_margin, top_margin);
    top_margin++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "top_margin", &top_margin, 0)
        && top_margin == plotsettings->top_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.top_margin [BD] set+1 %g != %g", plotsettings->top_margin, top_margin);
    plotsettings->top_margin--;
  }
  {
    BITCODE_B use_std_scale;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "use_std_scale", &use_std_scale, NULL)
        && use_std_scale == plotsettings->use_std_scale)
      pass ();
    else
      fail ("PLOTSETTINGS.use_std_scale [B] " FORMAT_B " != " FORMAT_B "", plotsettings->use_std_scale, use_std_scale);
    use_std_scale++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "use_std_scale", &use_std_scale, 0)
        && use_std_scale == plotsettings->use_std_scale)
      pass ();
    else
      fail ("PLOTSETTINGS.use_std_scale [B] set+1 " FORMAT_B " != " FORMAT_B "", plotsettings->use_std_scale, use_std_scale);
    plotsettings->use_std_scale--;
  }
  if (failed && (is_class_unstable ("PLOTSETTINGS") || is_class_debugging ("PLOTSETTINGS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PLOTSETTINGS", failed);
      failed = 0;
    }
  return failed;
}
static int test_PROXY_OBJECT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PROXY_OBJECT *restrict proxy_object = obj->tio.object->tio.PROXY_OBJECT;
  failed = 0;
  {
    BITCODE_BL class_id;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "class_id", &class_id, NULL)
        && class_id == proxy_object->class_id)
      pass ();
    else
      fail ("PROXY_OBJECT.class_id [BL] %u != %u", proxy_object->class_id, class_id);
    class_id++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "class_id", &class_id, 0)
        && class_id == proxy_object->class_id)
      pass ();
    else
      fail ("PROXY_OBJECT.class_id [BL] set+1 %u != %u", proxy_object->class_id, class_id);
    proxy_object->class_id--;
  }
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "data", &data, NULL)
        && data
           ? strEQ ((char *)data, (char *)proxy_object->data)
           : !proxy_object->data)
      pass ();
    else
      fail ("PROXY_OBJECT.data [TV] '%s' <> '%s'", data, proxy_object->data);
  }
  {
    BITCODE_B from_dxf;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "from_dxf", &from_dxf, NULL)
        && from_dxf == proxy_object->from_dxf)
      pass ();
    else
      fail ("PROXY_OBJECT.from_dxf [B] " FORMAT_B " != " FORMAT_B "", proxy_object->from_dxf, from_dxf);
    from_dxf++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "from_dxf", &from_dxf, 0)
        && from_dxf == proxy_object->from_dxf)
      pass ();
    else
      fail ("PROXY_OBJECT.from_dxf [B] set+1 " FORMAT_B " != " FORMAT_B "", proxy_object->from_dxf, from_dxf);
    proxy_object->from_dxf--;
  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "maint_version", &maint_version, NULL)
        && maint_version == proxy_object->maint_version)
      pass ();
    else
      fail ("PROXY_OBJECT.maint_version [BL] %u != %u", proxy_object->maint_version, maint_version);
    maint_version++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "maint_version", &maint_version, 0)
        && maint_version == proxy_object->maint_version)
      pass ();
    else
      fail ("PROXY_OBJECT.maint_version [BL] set+1 %u != %u", proxy_object->maint_version, maint_version);
    proxy_object->maint_version--;
  }
  {
    BITCODE_H* objid_object_handles;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "objid_object_handles", &objid_object_handles, NULL)
        && !memcmp (&objid_object_handles, &proxy_object->objid_object_handles, sizeof (proxy_object->objid_object_handles)))
        pass ();
    else
        fail ("PROXY_OBJECT.objid_object_handles [H*]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "parent", &parent, NULL)
        && !memcmp (&parent, &proxy_object->parent, sizeof (proxy_object->parent)))
        pass ();
    else
        fail ("PROXY_OBJECT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "version", &version, NULL)
        && version == proxy_object->version)
      pass ();
    else
      fail ("PROXY_OBJECT.version [BL] %u != %u", proxy_object->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "version", &version, 0)
        && version == proxy_object->version)
      pass ();
    else
      fail ("PROXY_OBJECT.version [BL] set+1 %u != %u", proxy_object->version, version);
    proxy_object->version--;
  }
  if (failed && (is_class_unstable ("PROXY_OBJECT") || is_class_debugging ("PROXY_OBJECT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PROXY_OBJECT", failed);
      failed = 0;
    }
  return failed;
}
static int test_RASTERVARIABLES (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RASTERVARIABLES *restrict rastervariables = obj->tio.object->tio.RASTERVARIABLES;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "class_version", &class_version, NULL)
        && class_version == rastervariables->class_version)
      pass ();
    else
      fail ("RASTERVARIABLES.class_version [BL] %u != %u", rastervariables->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (rastervariables, "RASTERVARIABLES", "class_version", &class_version, 0)
        && class_version == rastervariables->class_version)
      pass ();
    else
      fail ("RASTERVARIABLES.class_version [BL] set+1 %u != %u", rastervariables->class_version, class_version);
    rastervariables->class_version--;
  }
  {
    BITCODE_BS display_frame;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "display_frame", &display_frame, NULL)
        && display_frame == rastervariables->display_frame)
      pass ();
    else
      fail ("RASTERVARIABLES.display_frame [BS] %hu != %hu", rastervariables->display_frame, display_frame);
    display_frame++;
    if (dwg_dynapi_entity_set_value (rastervariables, "RASTERVARIABLES", "display_frame", &display_frame, 0)
        && display_frame == rastervariables->display_frame)
      pass ();
    else
      fail ("RASTERVARIABLES.display_frame [BS] set+1 %hu != %hu", rastervariables->display_frame, display_frame);
    rastervariables->display_frame--;
  }
  {
    BITCODE_BS display_quality;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "display_quality", &display_quality, NULL)
        && display_quality == rastervariables->display_quality)
      pass ();
    else
      fail ("RASTERVARIABLES.display_quality [BS] %hu != %hu", rastervariables->display_quality, display_quality);
    display_quality++;
    if (dwg_dynapi_entity_set_value (rastervariables, "RASTERVARIABLES", "display_quality", &display_quality, 0)
        && display_quality == rastervariables->display_quality)
      pass ();
    else
      fail ("RASTERVARIABLES.display_quality [BS] set+1 %hu != %hu", rastervariables->display_quality, display_quality);
    rastervariables->display_quality--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "parent", &parent, NULL)
        && !memcmp (&parent, &rastervariables->parent, sizeof (rastervariables->parent)))
        pass ();
    else
        fail ("RASTERVARIABLES.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS units;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "units", &units, NULL)
        && units == rastervariables->units)
      pass ();
    else
      fail ("RASTERVARIABLES.units [BS] %hu != %hu", rastervariables->units, units);
    units++;
    if (dwg_dynapi_entity_set_value (rastervariables, "RASTERVARIABLES", "units", &units, 0)
        && units == rastervariables->units)
      pass ();
    else
      fail ("RASTERVARIABLES.units [BS] set+1 %hu != %hu", rastervariables->units, units);
    rastervariables->units--;
  }
  if (failed && (is_class_unstable ("RASTERVARIABLES") || is_class_debugging ("RASTERVARIABLES")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RASTERVARIABLES", failed);
      failed = 0;
    }
  return failed;
}
static int test_RENDERENVIRONMENT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RENDERENVIRONMENT *restrict renderenvironment = obj->tio.object->tio.RENDERENVIRONMENT;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "class_version", &class_version, NULL)
        && class_version == renderenvironment->class_version)
      pass ();
    else
      fail ("RENDERENVIRONMENT.class_version [BL] %u != %u", renderenvironment->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "class_version", &class_version, 0)
        && class_version == renderenvironment->class_version)
      pass ();
    else
      fail ("RENDERENVIRONMENT.class_version [BL] set+1 %u != %u", renderenvironment->class_version, class_version);
    renderenvironment->class_version--;
  }
  {
    BITCODE_B environ_image_enabled;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "environ_image_enabled", &environ_image_enabled, NULL)
        && environ_image_enabled == renderenvironment->environ_image_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.environ_image_enabled [B] " FORMAT_B " != " FORMAT_B "", renderenvironment->environ_image_enabled, environ_image_enabled);
    environ_image_enabled++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "environ_image_enabled", &environ_image_enabled, 0)
        && environ_image_enabled == renderenvironment->environ_image_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.environ_image_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", renderenvironment->environ_image_enabled, environ_image_enabled);
    renderenvironment->environ_image_enabled--;
  }
  {
    BITCODE_T environ_image_filename;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "environ_image_filename", &environ_image_filename, NULL)
        && environ_image_filename
           ? strEQ ((char *)environ_image_filename, (char *)renderenvironment->environ_image_filename)
           : !renderenvironment->environ_image_filename)
      pass ();
    else
      fail ("RENDERENVIRONMENT.environ_image_filename [T] '%s' <> '%s'", environ_image_filename, renderenvironment->environ_image_filename);
  }
  {
    BITCODE_B fog_background_enabled;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_background_enabled", &fog_background_enabled, NULL)
        && fog_background_enabled == renderenvironment->fog_background_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_background_enabled [B] " FORMAT_B " != " FORMAT_B "", renderenvironment->fog_background_enabled, fog_background_enabled);
    fog_background_enabled++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_background_enabled", &fog_background_enabled, 0)
        && fog_background_enabled == renderenvironment->fog_background_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_background_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", renderenvironment->fog_background_enabled, fog_background_enabled);
    renderenvironment->fog_background_enabled--;
  }
  {
    BITCODE_CMC fog_color;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_color", &fog_color, NULL)
        && !memcmp (&fog_color, &renderenvironment->fog_color, sizeof (renderenvironment->fog_color)))
        pass ();
    else
        fail ("RENDERENVIRONMENT.fog_color [CMC]");
  }
  {
    BITCODE_BD fog_density_far;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_density_far", &fog_density_far, NULL)
        && fog_density_far == renderenvironment->fog_density_far)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_density_far [BD] %g != %g", renderenvironment->fog_density_far, fog_density_far);
    fog_density_far++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_density_far", &fog_density_far, 0)
        && fog_density_far == renderenvironment->fog_density_far)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_density_far [BD] set+1 %g != %g", renderenvironment->fog_density_far, fog_density_far);
    renderenvironment->fog_density_far--;
  }
  {
    BITCODE_BD fog_density_near;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_density_near", &fog_density_near, NULL)
        && fog_density_near == renderenvironment->fog_density_near)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_density_near [BD] %g != %g", renderenvironment->fog_density_near, fog_density_near);
    fog_density_near++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_density_near", &fog_density_near, 0)
        && fog_density_near == renderenvironment->fog_density_near)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_density_near [BD] set+1 %g != %g", renderenvironment->fog_density_near, fog_density_near);
    renderenvironment->fog_density_near--;
  }
  {
    BITCODE_BD fog_distance_far;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_distance_far", &fog_distance_far, NULL)
        && fog_distance_far == renderenvironment->fog_distance_far)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_distance_far [BD] %g != %g", renderenvironment->fog_distance_far, fog_distance_far);
    fog_distance_far++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_distance_far", &fog_distance_far, 0)
        && fog_distance_far == renderenvironment->fog_distance_far)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_distance_far [BD] set+1 %g != %g", renderenvironment->fog_distance_far, fog_distance_far);
    renderenvironment->fog_distance_far--;
  }
  {
    BITCODE_BD fog_distance_near;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_distance_near", &fog_distance_near, NULL)
        && fog_distance_near == renderenvironment->fog_distance_near)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_distance_near [BD] %g != %g", renderenvironment->fog_distance_near, fog_distance_near);
    fog_distance_near++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_distance_near", &fog_distance_near, 0)
        && fog_distance_near == renderenvironment->fog_distance_near)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_distance_near [BD] set+1 %g != %g", renderenvironment->fog_distance_near, fog_distance_near);
    renderenvironment->fog_distance_near--;
  }
  {
    BITCODE_B fog_enabled;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_enabled", &fog_enabled, NULL)
        && fog_enabled == renderenvironment->fog_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_enabled [B] " FORMAT_B " != " FORMAT_B "", renderenvironment->fog_enabled, fog_enabled);
    fog_enabled++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_enabled", &fog_enabled, 0)
        && fog_enabled == renderenvironment->fog_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", renderenvironment->fog_enabled, fog_enabled);
    renderenvironment->fog_enabled--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "parent", &parent, NULL)
        && !memcmp (&parent, &renderenvironment->parent, sizeof (renderenvironment->parent)))
        pass ();
    else
        fail ("RENDERENVIRONMENT.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("RENDERENVIRONMENT") || is_class_debugging ("RENDERENVIRONMENT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RENDERENVIRONMENT", failed);
      failed = 0;
    }
  return failed;
}
static int test_RENDERGLOBAL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RENDERGLOBAL *restrict renderglobal = obj->tio.object->tio.RENDERGLOBAL;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "class_version", &class_version, NULL)
        && class_version == renderglobal->class_version)
      pass ();
    else
      fail ("RENDERGLOBAL.class_version [BL] %u != %u", renderglobal->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "class_version", &class_version, 0)
        && class_version == renderglobal->class_version)
      pass ();
    else
      fail ("RENDERGLOBAL.class_version [BL] set+1 %u != %u", renderglobal->class_version, class_version);
    renderglobal->class_version--;
  }
  {
    BITCODE_BL destination;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "destination", &destination, NULL)
        && destination == renderglobal->destination)
      pass ();
    else
      fail ("RENDERGLOBAL.destination [BL] %u != %u", renderglobal->destination, destination);
    destination++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "destination", &destination, 0)
        && destination == renderglobal->destination)
      pass ();
    else
      fail ("RENDERGLOBAL.destination [BL] set+1 %u != %u", renderglobal->destination, destination);
    renderglobal->destination--;
  }
  {
    BITCODE_B highlevel_info;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "highlevel_info", &highlevel_info, NULL)
        && highlevel_info == renderglobal->highlevel_info)
      pass ();
    else
      fail ("RENDERGLOBAL.highlevel_info [B] " FORMAT_B " != " FORMAT_B "", renderglobal->highlevel_info, highlevel_info);
    highlevel_info++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "highlevel_info", &highlevel_info, 0)
        && highlevel_info == renderglobal->highlevel_info)
      pass ();
    else
      fail ("RENDERGLOBAL.highlevel_info [B] set+1 " FORMAT_B " != " FORMAT_B "", renderglobal->highlevel_info, highlevel_info);
    renderglobal->highlevel_info--;
  }
  {
    BITCODE_BL image_height;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "image_height", &image_height, NULL)
        && image_height == renderglobal->image_height)
      pass ();
    else
      fail ("RENDERGLOBAL.image_height [BL] %u != %u", renderglobal->image_height, image_height);
    image_height++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "image_height", &image_height, 0)
        && image_height == renderglobal->image_height)
      pass ();
    else
      fail ("RENDERGLOBAL.image_height [BL] set+1 %u != %u", renderglobal->image_height, image_height);
    renderglobal->image_height--;
  }
  {
    BITCODE_BL image_width;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "image_width", &image_width, NULL)
        && image_width == renderglobal->image_width)
      pass ();
    else
      fail ("RENDERGLOBAL.image_width [BL] %u != %u", renderglobal->image_width, image_width);
    image_width++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "image_width", &image_width, 0)
        && image_width == renderglobal->image_width)
      pass ();
    else
      fail ("RENDERGLOBAL.image_width [BL] set+1 %u != %u", renderglobal->image_width, image_width);
    renderglobal->image_width--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "parent", &parent, NULL)
        && !memcmp (&parent, &renderglobal->parent, sizeof (renderglobal->parent)))
        pass ();
    else
        fail ("RENDERGLOBAL.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B predef_presets_first;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "predef_presets_first", &predef_presets_first, NULL)
        && predef_presets_first == renderglobal->predef_presets_first)
      pass ();
    else
      fail ("RENDERGLOBAL.predef_presets_first [B] " FORMAT_B " != " FORMAT_B "", renderglobal->predef_presets_first, predef_presets_first);
    predef_presets_first++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "predef_presets_first", &predef_presets_first, 0)
        && predef_presets_first == renderglobal->predef_presets_first)
      pass ();
    else
      fail ("RENDERGLOBAL.predef_presets_first [B] set+1 " FORMAT_B " != " FORMAT_B "", renderglobal->predef_presets_first, predef_presets_first);
    renderglobal->predef_presets_first--;
  }
  {
    BITCODE_BL procedure;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "procedure", &procedure, NULL)
        && procedure == renderglobal->procedure)
      pass ();
    else
      fail ("RENDERGLOBAL.procedure [BL] %u != %u", renderglobal->procedure, procedure);
    procedure++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "procedure", &procedure, 0)
        && procedure == renderglobal->procedure)
      pass ();
    else
      fail ("RENDERGLOBAL.procedure [BL] set+1 %u != %u", renderglobal->procedure, procedure);
    renderglobal->procedure--;
  }
  {
    BITCODE_B save_enabled;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "save_enabled", &save_enabled, NULL)
        && save_enabled == renderglobal->save_enabled)
      pass ();
    else
      fail ("RENDERGLOBAL.save_enabled [B] " FORMAT_B " != " FORMAT_B "", renderglobal->save_enabled, save_enabled);
    save_enabled++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "save_enabled", &save_enabled, 0)
        && save_enabled == renderglobal->save_enabled)
      pass ();
    else
      fail ("RENDERGLOBAL.save_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", renderglobal->save_enabled, save_enabled);
    renderglobal->save_enabled--;
  }
  {
    BITCODE_T save_filename;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "save_filename", &save_filename, NULL)
        && save_filename
           ? strEQ ((char *)save_filename, (char *)renderglobal->save_filename)
           : !renderglobal->save_filename)
      pass ();
    else
      fail ("RENDERGLOBAL.save_filename [T] '%s' <> '%s'", save_filename, renderglobal->save_filename);
  }
  if (failed && (is_class_unstable ("RENDERGLOBAL") || is_class_debugging ("RENDERGLOBAL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RENDERGLOBAL", failed);
      failed = 0;
    }
  return failed;
}
static int test_SCALE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SCALE *restrict scale = obj->tio.object->tio.SCALE;
  failed = 0;
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value (scale, "SCALE", "drawing_units", &drawing_units, NULL)
        && drawing_units == scale->drawing_units)
      pass ();
    else
      fail ("SCALE.drawing_units [BD] %g != %g", scale->drawing_units, drawing_units);
    drawing_units++;
    if (dwg_dynapi_entity_set_value (scale, "SCALE", "drawing_units", &drawing_units, 0)
        && drawing_units == scale->drawing_units)
      pass ();
    else
      fail ("SCALE.drawing_units [BD] set+1 %g != %g", scale->drawing_units, drawing_units);
    scale->drawing_units--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (scale, "SCALE", "flag", &flag, NULL)
        && flag == scale->flag)
      pass ();
    else
      fail ("SCALE.flag [BS] %hu != %hu", scale->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (scale, "SCALE", "flag", &flag, 0)
        && flag == scale->flag)
      pass ();
    else
      fail ("SCALE.flag [BS] set+1 %hu != %hu", scale->flag, flag);
    scale->flag--;
  }
  {
    BITCODE_B has_unit_scale;
    if (dwg_dynapi_entity_value (scale, "SCALE", "has_unit_scale", &has_unit_scale, NULL)
        && has_unit_scale == scale->has_unit_scale)
      pass ();
    else
      fail ("SCALE.has_unit_scale [B] " FORMAT_B " != " FORMAT_B "", scale->has_unit_scale, has_unit_scale);
    has_unit_scale++;
    if (dwg_dynapi_entity_set_value (scale, "SCALE", "has_unit_scale", &has_unit_scale, 0)
        && has_unit_scale == scale->has_unit_scale)
      pass ();
    else
      fail ("SCALE.has_unit_scale [B] set+1 " FORMAT_B " != " FORMAT_B "", scale->has_unit_scale, has_unit_scale);
    scale->has_unit_scale--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (scale, "SCALE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)scale->name)
           : !scale->name)
      pass ();
    else
      fail ("SCALE.name [T] '%s' <> '%s'", name, scale->name);
  }
  {
    BITCODE_BD paper_units;
    if (dwg_dynapi_entity_value (scale, "SCALE", "paper_units", &paper_units, NULL)
        && paper_units == scale->paper_units)
      pass ();
    else
      fail ("SCALE.paper_units [BD] %g != %g", scale->paper_units, paper_units);
    paper_units++;
    if (dwg_dynapi_entity_set_value (scale, "SCALE", "paper_units", &paper_units, 0)
        && paper_units == scale->paper_units)
      pass ();
    else
      fail ("SCALE.paper_units [BD] set+1 %g != %g", scale->paper_units, paper_units);
    scale->paper_units--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (scale, "SCALE", "parent", &parent, NULL)
        && !memcmp (&parent, &scale->parent, sizeof (scale->parent)))
        pass ();
    else
        fail ("SCALE.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("SCALE") || is_class_debugging ("SCALE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SCALE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SORTENTSTABLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SORTENTSTABLE *restrict sortentstable = obj->tio.object->tio.SORTENTSTABLE;
  failed = 0;
  {
    BITCODE_H dictionary;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "dictionary", &dictionary, NULL)
        && !memcmp (&dictionary, &sortentstable->dictionary, sizeof (sortentstable->dictionary)))
        pass ();
    else
        fail ("SORTENTSTABLE.dictionary [H]");
  }
  {
    BITCODE_H* ents;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "num_ents", &count, NULL)
        && dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "ents", &ents, NULL)
        && ents == sortentstable->ents)
      pass ();
    else
      fail ("SORTENTSTABLE.ents [H*] * %u num_ents", count);
  }
  {
    BITCODE_BL num_ents;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "num_ents", &num_ents, NULL)
        && num_ents == sortentstable->num_ents)
      pass ();
    else
      fail ("SORTENTSTABLE.num_ents [BL] %u != %u", sortentstable->num_ents, num_ents);
    num_ents++;
    if (dwg_dynapi_entity_set_value (sortentstable, "SORTENTSTABLE", "num_ents", &num_ents, 0)
        && num_ents == sortentstable->num_ents)
      pass ();
    else
      fail ("SORTENTSTABLE.num_ents [BL] set+1 %u != %u", sortentstable->num_ents, num_ents);
    sortentstable->num_ents--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "parent", &parent, NULL)
        && !memcmp (&parent, &sortentstable->parent, sizeof (sortentstable->parent)))
        pass ();
    else
        fail ("SORTENTSTABLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H* sort_ents;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "num_ents", &count, NULL)
        && dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "sort_ents", &sort_ents, NULL)
        && sort_ents == sortentstable->sort_ents)
      pass ();
    else
      fail ("SORTENTSTABLE.sort_ents [H*] * %u num_ents", count);
  }
  if (failed && (is_class_unstable ("SORTENTSTABLE") || is_class_debugging ("SORTENTSTABLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SORTENTSTABLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SPATIAL_FILTER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SPATIAL_FILTER *restrict spatial_filter = obj->tio.object->tio.SPATIAL_FILTER;
  failed = 0;
  {
    BITCODE_BD back_clip_dist;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "back_clip_dist", &back_clip_dist, NULL)
        && back_clip_dist == spatial_filter->back_clip_dist)
      pass ();
    else
      fail ("SPATIAL_FILTER.back_clip_dist [BD] %g != %g", spatial_filter->back_clip_dist, back_clip_dist);
    back_clip_dist++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "back_clip_dist", &back_clip_dist, 0)
        && back_clip_dist == spatial_filter->back_clip_dist)
      pass ();
    else
      fail ("SPATIAL_FILTER.back_clip_dist [BD] set+1 %g != %g", spatial_filter->back_clip_dist, back_clip_dist);
    spatial_filter->back_clip_dist--;
  }
  {
    BITCODE_BS back_clip_on;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "back_clip_on", &back_clip_on, NULL)
        && back_clip_on == spatial_filter->back_clip_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.back_clip_on [BS] %hu != %hu", spatial_filter->back_clip_on, back_clip_on);
    back_clip_on++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "back_clip_on", &back_clip_on, 0)
        && back_clip_on == spatial_filter->back_clip_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.back_clip_on [BS] set+1 %hu != %hu", spatial_filter->back_clip_on, back_clip_on);
    spatial_filter->back_clip_on--;
  }
  {
    BITCODE_3BD clip_bound_origin;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "clip_bound_origin", &clip_bound_origin, NULL)
        && !memcmp (&clip_bound_origin, &spatial_filter->clip_bound_origin, sizeof (spatial_filter->clip_bound_origin)))
        pass ();
    else
        fail ("SPATIAL_FILTER.clip_bound_origin [3BD]");
  }
  {
    BITCODE_BD* clip_bound_transform;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "clip_bound_transform", &clip_bound_transform, NULL)
        && !memcmp (&clip_bound_transform, &spatial_filter->clip_bound_transform, sizeof (spatial_filter->clip_bound_transform)))
        pass ();
    else
        fail ("SPATIAL_FILTER.clip_bound_transform [BD*]");
  }
  {
    BITCODE_BS display_boundary;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "display_boundary", &display_boundary, NULL)
        && display_boundary == spatial_filter->display_boundary)
      pass ();
    else
      fail ("SPATIAL_FILTER.display_boundary [BS] %hu != %hu", spatial_filter->display_boundary, display_boundary);
    display_boundary++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "display_boundary", &display_boundary, 0)
        && display_boundary == spatial_filter->display_boundary)
      pass ();
    else
      fail ("SPATIAL_FILTER.display_boundary [BS] set+1 %hu != %hu", spatial_filter->display_boundary, display_boundary);
    spatial_filter->display_boundary--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &spatial_filter->extrusion, sizeof (spatial_filter->extrusion)))
        pass ();
    else
        fail ("SPATIAL_FILTER.extrusion [BE]");
  }
  {
    BITCODE_BD front_clip_dist;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "front_clip_dist", &front_clip_dist, NULL)
        && front_clip_dist == spatial_filter->front_clip_dist)
      pass ();
    else
      fail ("SPATIAL_FILTER.front_clip_dist [BD] %g != %g", spatial_filter->front_clip_dist, front_clip_dist);
    front_clip_dist++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "front_clip_dist", &front_clip_dist, 0)
        && front_clip_dist == spatial_filter->front_clip_dist)
      pass ();
    else
      fail ("SPATIAL_FILTER.front_clip_dist [BD] set+1 %g != %g", spatial_filter->front_clip_dist, front_clip_dist);
    spatial_filter->front_clip_dist--;
  }
  {
    BITCODE_BS front_clip_on;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "front_clip_on", &front_clip_on, NULL)
        && front_clip_on == spatial_filter->front_clip_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.front_clip_on [BS] %hu != %hu", spatial_filter->front_clip_on, front_clip_on);
    front_clip_on++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "front_clip_on", &front_clip_on, 0)
        && front_clip_on == spatial_filter->front_clip_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.front_clip_on [BS] set+1 %hu != %hu", spatial_filter->front_clip_on, front_clip_on);
    spatial_filter->front_clip_on--;
  }
  {
    BITCODE_BD* inverse_block_transform;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "inverse_block_transform", &inverse_block_transform, NULL)
        && !memcmp (&inverse_block_transform, &spatial_filter->inverse_block_transform, sizeof (spatial_filter->inverse_block_transform)))
        pass ();
    else
        fail ("SPATIAL_FILTER.inverse_block_transform [BD*]");
  }
  {
    BITCODE_BS num_points;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "num_points", &num_points, NULL)
        && num_points == spatial_filter->num_points)
      pass ();
    else
      fail ("SPATIAL_FILTER.num_points [BS] %hu != %hu", spatial_filter->num_points, num_points);
    num_points++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "num_points", &num_points, 0)
        && num_points == spatial_filter->num_points)
      pass ();
    else
      fail ("SPATIAL_FILTER.num_points [BS] set+1 %hu != %hu", spatial_filter->num_points, num_points);
    spatial_filter->num_points--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "parent", &parent, NULL)
        && !memcmp (&parent, &spatial_filter->parent, sizeof (spatial_filter->parent)))
        pass ();
    else
        fail ("SPATIAL_FILTER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_2RD* points;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "num_points", &count, NULL)
        && dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "points", &points, NULL)
        && points == spatial_filter->points)
      pass ();
    else
      fail ("SPATIAL_FILTER.points [2RD*] * %u num_points", count);
  }
  if (failed && (is_class_unstable ("SPATIAL_FILTER") || is_class_debugging ("SPATIAL_FILTER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SPATIAL_FILTER", failed);
      failed = 0;
    }
  return failed;
}
static int test_SPATIAL_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SPATIAL_INDEX *restrict spatial_index = obj->tio.object->tio.SPATIAL_INDEX;
  failed = 0;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "parent", &parent, NULL)
        && !memcmp (&parent, &spatial_index->parent, sizeof (spatial_index->parent)))
        pass ();
    else
        fail ("SPATIAL_INDEX.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL timestamp1;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "timestamp1", &timestamp1, NULL)
        && timestamp1 == spatial_index->timestamp1)
      pass ();
    else
      fail ("SPATIAL_INDEX.timestamp1 [BL] %u != %u", spatial_index->timestamp1, timestamp1);
    timestamp1++;
    if (dwg_dynapi_entity_set_value (spatial_index, "SPATIAL_INDEX", "timestamp1", &timestamp1, 0)
        && timestamp1 == spatial_index->timestamp1)
      pass ();
    else
      fail ("SPATIAL_INDEX.timestamp1 [BL] set+1 %u != %u", spatial_index->timestamp1, timestamp1);
    spatial_index->timestamp1--;
  }
  {
    BITCODE_BL timestamp2;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "timestamp2", &timestamp2, NULL)
        && timestamp2 == spatial_index->timestamp2)
      pass ();
    else
      fail ("SPATIAL_INDEX.timestamp2 [BL] %u != %u", spatial_index->timestamp2, timestamp2);
    timestamp2++;
    if (dwg_dynapi_entity_set_value (spatial_index, "SPATIAL_INDEX", "timestamp2", &timestamp2, 0)
        && timestamp2 == spatial_index->timestamp2)
      pass ();
    else
      fail ("SPATIAL_INDEX.timestamp2 [BL] set+1 %u != %u", spatial_index->timestamp2, timestamp2);
    spatial_index->timestamp2--;
  }
  {
    BITCODE_TV unknown;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "unknown", &unknown, NULL)
        && unknown
           ? strEQ ((char *)unknown, (char *)spatial_index->unknown)
           : !spatial_index->unknown)
      pass ();
    else
      fail ("SPATIAL_INDEX.unknown [TV] '%s' <> '%s'", unknown, spatial_index->unknown);
  }
  if (failed && (is_class_unstable ("SPATIAL_INDEX") || is_class_debugging ("SPATIAL_INDEX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SPATIAL_INDEX", failed);
      failed = 0;
    }
  return failed;
}
static int test_STYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_STYLE *restrict style = obj->tio.object->tio.STYLE;
  failed = 0;
  {
    BITCODE_T bigfont_name;
    if (dwg_dynapi_entity_value (style, "STYLE", "bigfont_name", &bigfont_name, NULL)
        && bigfont_name
           ? strEQ ((char *)bigfont_name, (char *)style->bigfont_name)
           : !style->bigfont_name)
      pass ();
    else
      fail ("STYLE.bigfont_name [T] '%s' <> '%s'", bigfont_name, style->bigfont_name);
  }
  {
    BITCODE_H extref;
    if (dwg_dynapi_entity_value (style, "STYLE", "extref", &extref, NULL)
        && !memcmp (&extref, &style->extref, sizeof (style->extref)))
        pass ();
    else
        fail ("STYLE.extref [H]");
  }
  {
    BITCODE_BD fixed_height;
    if (dwg_dynapi_entity_value (style, "STYLE", "fixed_height", &fixed_height, NULL)
        && fixed_height == style->fixed_height)
      pass ();
    else
      fail ("STYLE.fixed_height [BD] %g != %g", style->fixed_height, fixed_height);
    fixed_height++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "fixed_height", &fixed_height, 0)
        && fixed_height == style->fixed_height)
      pass ();
    else
      fail ("STYLE.fixed_height [BD] set+1 %g != %g", style->fixed_height, fixed_height);
    style->fixed_height--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (style, "STYLE", "flag", &flag, NULL)
        && flag == style->flag)
      pass ();
    else
      fail ("STYLE.flag [RC] %u != %u", style->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "flag", &flag, 0)
        && flag == style->flag)
      pass ();
    else
      fail ("STYLE.flag [RC] set+1 %u != %u", style->flag, flag);
    style->flag--;
  }
  {
    BITCODE_T font_name;
    if (dwg_dynapi_entity_value (style, "STYLE", "font_name", &font_name, NULL)
        && font_name
           ? strEQ ((char *)font_name, (char *)style->font_name)
           : !style->font_name)
      pass ();
    else
      fail ("STYLE.font_name [T] '%s' <> '%s'", font_name, style->font_name);
  }
  {
    BITCODE_RC generation;
    if (dwg_dynapi_entity_value (style, "STYLE", "generation", &generation, NULL)
        && generation == style->generation)
      pass ();
    else
      fail ("STYLE.generation [RC] %u != %u", style->generation, generation);
    generation++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "generation", &generation, 0)
        && generation == style->generation)
      pass ();
    else
      fail ("STYLE.generation [RC] set+1 %u != %u", style->generation, generation);
    style->generation--;
  }
  {
    BITCODE_BD last_height;
    if (dwg_dynapi_entity_value (style, "STYLE", "last_height", &last_height, NULL)
        && last_height == style->last_height)
      pass ();
    else
      fail ("STYLE.last_height [BD] %g != %g", style->last_height, last_height);
    last_height++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "last_height", &last_height, 0)
        && last_height == style->last_height)
      pass ();
    else
      fail ("STYLE.last_height [BD] set+1 %g != %g", style->last_height, last_height);
    style->last_height--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (style, "STYLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)style->name)
           : !style->name)
      pass ();
    else
      fail ("STYLE.name [TV] '%s' <> '%s'", name, style->name);
  }
  {
    BITCODE_BD oblique_ang;
    if (dwg_dynapi_entity_value (style, "STYLE", "oblique_ang", &oblique_ang, NULL)
        && oblique_ang == style->oblique_ang)
      pass ();
    else
      fail ("STYLE.oblique_ang [BD] %g != %g", style->oblique_ang, oblique_ang);
    oblique_ang++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "oblique_ang", &oblique_ang, 0)
        && oblique_ang == style->oblique_ang)
      pass ();
    else
      fail ("STYLE.oblique_ang [BD] set+1 %g != %g", style->oblique_ang, oblique_ang);
    style->oblique_ang--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (style, "STYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &style->parent, sizeof (style->parent)))
        pass ();
    else
        fail ("STYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B shape_file;
    if (dwg_dynapi_entity_value (style, "STYLE", "shape_file", &shape_file, NULL)
        && shape_file == style->shape_file)
      pass ();
    else
      fail ("STYLE.shape_file [B] " FORMAT_B " != " FORMAT_B "", style->shape_file, shape_file);
    shape_file++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "shape_file", &shape_file, 0)
        && shape_file == style->shape_file)
      pass ();
    else
      fail ("STYLE.shape_file [B] set+1 " FORMAT_B " != " FORMAT_B "", style->shape_file, shape_file);
    style->shape_file--;
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (style, "STYLE", "used", &used, NULL)
        && used == style->used)
      pass ();
    else
      fail ("STYLE.used [RS] %hu != %hu", style->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "used", &used, 0)
        && used == style->used)
      pass ();
    else
      fail ("STYLE.used [RS] set+1 %hu != %hu", style->used, used);
    style->used--;
  }
  {
    BITCODE_B vertical;
    if (dwg_dynapi_entity_value (style, "STYLE", "vertical", &vertical, NULL)
        && vertical == style->vertical)
      pass ();
    else
      fail ("STYLE.vertical [B] " FORMAT_B " != " FORMAT_B "", style->vertical, vertical);
    vertical++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "vertical", &vertical, 0)
        && vertical == style->vertical)
      pass ();
    else
      fail ("STYLE.vertical [B] set+1 " FORMAT_B " != " FORMAT_B "", style->vertical, vertical);
    style->vertical--;
  }
  {
    BITCODE_BD width_factor;
    if (dwg_dynapi_entity_value (style, "STYLE", "width_factor", &width_factor, NULL)
        && width_factor == style->width_factor)
      pass ();
    else
      fail ("STYLE.width_factor [BD] %g != %g", style->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "width_factor", &width_factor, 0)
        && width_factor == style->width_factor)
      pass ();
    else
      fail ("STYLE.width_factor [BD] set+1 %g != %g", style->width_factor, width_factor);
    style->width_factor--;
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (style, "STYLE", "xrefdep", &xrefdep, NULL)
        && xrefdep == style->xrefdep)
      pass ();
    else
      fail ("STYLE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", style->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "xrefdep", &xrefdep, 0)
        && xrefdep == style->xrefdep)
      pass ();
    else
      fail ("STYLE.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", style->xrefdep, xrefdep);
    style->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (style, "STYLE", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == style->xrefindex_plus1)
      pass ();
    else
      fail ("STYLE.xrefindex_plus1 [BS] %hu != %hu", style->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == style->xrefindex_plus1)
      pass ();
    else
      fail ("STYLE.xrefindex_plus1 [BS] set+1 %hu != %hu", style->xrefindex_plus1, xrefindex_plus1);
    style->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (style, "STYLE", "xrefref", &xrefref, NULL)
        && xrefref == style->xrefref)
      pass ();
    else
      fail ("STYLE.xrefref [B] " FORMAT_B " != " FORMAT_B "", style->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "xrefref", &xrefref, 0)
        && xrefref == style->xrefref)
      pass ();
    else
      fail ("STYLE.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", style->xrefref, xrefref);
    style->xrefref--;
  }
  if (failed && (is_class_unstable ("STYLE") || is_class_debugging ("STYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "STYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_STYLE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_STYLE_CONTROL *restrict style_control = obj->tio.object->tio.STYLE_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "entries", &entries, NULL)
        && entries == style_control->entries)
      pass ();
    else
      fail ("STYLE_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == style_control->num_entries)
      pass ();
    else
      fail ("STYLE_CONTROL.num_entries [BS] %hu != %hu", style_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (style_control, "STYLE_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == style_control->num_entries)
      pass ();
    else
      fail ("STYLE_CONTROL.num_entries [BS] set+1 %hu != %hu", style_control->num_entries, num_entries);
    style_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "objid", &objid, NULL)
        && objid == style_control->objid)
      pass ();
    else
      fail ("STYLE_CONTROL.objid [BL] %u != %u", style_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (style_control, "STYLE_CONTROL", "objid", &objid, 0)
        && objid == style_control->objid)
      pass ();
    else
      fail ("STYLE_CONTROL.objid [BL] set+1 %u != %u", style_control->objid, objid);
    style_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &style_control->parent, sizeof (style_control->parent)))
        pass ();
    else
        fail ("STYLE_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("STYLE_CONTROL") || is_class_debugging ("STYLE_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "STYLE_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_SUN (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SUN *restrict sun = obj->tio.object->tio.SUN;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (sun, "SUN", "class_version", &class_version, NULL)
        && class_version == sun->class_version)
      pass ();
    else
      fail ("SUN.class_version [BL] %u != %u", sun->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "class_version", &class_version, 0)
        && class_version == sun->class_version)
      pass ();
    else
      fail ("SUN.class_version [BL] set+1 %u != %u", sun->class_version, class_version);
    sun->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (sun, "SUN", "color", &color, NULL)
        && !memcmp (&color, &sun->color, sizeof (sun->color)))
        pass ();
    else
        fail ("SUN.color [CMC]");
  }
  {
    BITCODE_B has_shadow;
    if (dwg_dynapi_entity_value (sun, "SUN", "has_shadow", &has_shadow, NULL)
        && has_shadow == sun->has_shadow)
      pass ();
    else
      fail ("SUN.has_shadow [B] " FORMAT_B " != " FORMAT_B "", sun->has_shadow, has_shadow);
    has_shadow++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "has_shadow", &has_shadow, 0)
        && has_shadow == sun->has_shadow)
      pass ();
    else
      fail ("SUN.has_shadow [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->has_shadow, has_shadow);
    sun->has_shadow--;
  }
  {
    BITCODE_BD intensity;
    if (dwg_dynapi_entity_value (sun, "SUN", "intensity", &intensity, NULL)
        && intensity == sun->intensity)
      pass ();
    else
      fail ("SUN.intensity [BD] %g != %g", sun->intensity, intensity);
    intensity++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "intensity", &intensity, 0)
        && intensity == sun->intensity)
      pass ();
    else
      fail ("SUN.intensity [BD] set+1 %g != %g", sun->intensity, intensity);
    sun->intensity--;
  }
  {
    BITCODE_B is_dst;
    if (dwg_dynapi_entity_value (sun, "SUN", "is_dst", &is_dst, NULL)
        && is_dst == sun->is_dst)
      pass ();
    else
      fail ("SUN.is_dst [B] " FORMAT_B " != " FORMAT_B "", sun->is_dst, is_dst);
    is_dst++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "is_dst", &is_dst, 0)
        && is_dst == sun->is_dst)
      pass ();
    else
      fail ("SUN.is_dst [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->is_dst, is_dst);
    sun->is_dst--;
  }
  {
    BITCODE_B is_on;
    if (dwg_dynapi_entity_value (sun, "SUN", "is_on", &is_on, NULL)
        && is_on == sun->is_on)
      pass ();
    else
      fail ("SUN.is_on [B] " FORMAT_B " != " FORMAT_B "", sun->is_on, is_on);
    is_on++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "is_on", &is_on, 0)
        && is_on == sun->is_on)
      pass ();
    else
      fail ("SUN.is_on [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->is_on, is_on);
    sun->is_on--;
  }
  {
    BITCODE_BL julian_day;
    if (dwg_dynapi_entity_value (sun, "SUN", "julian_day", &julian_day, NULL)
        && julian_day == sun->julian_day)
      pass ();
    else
      fail ("SUN.julian_day [BL] %u != %u", sun->julian_day, julian_day);
    julian_day++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "julian_day", &julian_day, 0)
        && julian_day == sun->julian_day)
      pass ();
    else
      fail ("SUN.julian_day [BL] set+1 %u != %u", sun->julian_day, julian_day);
    sun->julian_day--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (sun, "SUN", "parent", &parent, NULL)
        && !memcmp (&parent, &sun->parent, sizeof (sun->parent)))
        pass ();
    else
        fail ("SUN.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS shadow_mapsize;
    if (dwg_dynapi_entity_value (sun, "SUN", "shadow_mapsize", &shadow_mapsize, NULL)
        && shadow_mapsize == sun->shadow_mapsize)
      pass ();
    else
      fail ("SUN.shadow_mapsize [BS] %hu != %hu", sun->shadow_mapsize, shadow_mapsize);
    shadow_mapsize++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "shadow_mapsize", &shadow_mapsize, 0)
        && shadow_mapsize == sun->shadow_mapsize)
      pass ();
    else
      fail ("SUN.shadow_mapsize [BS] set+1 %hu != %hu", sun->shadow_mapsize, shadow_mapsize);
    sun->shadow_mapsize--;
  }
  {
    BITCODE_BS shadow_softness;
    if (dwg_dynapi_entity_value (sun, "SUN", "shadow_softness", &shadow_softness, NULL)
        && shadow_softness == sun->shadow_softness)
      pass ();
    else
      fail ("SUN.shadow_softness [BS] %hu != %hu", sun->shadow_softness, shadow_softness);
    shadow_softness++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "shadow_softness", &shadow_softness, 0)
        && shadow_softness == sun->shadow_softness)
      pass ();
    else
      fail ("SUN.shadow_softness [BS] set+1 %hu != %hu", sun->shadow_softness, shadow_softness);
    sun->shadow_softness--;
  }
  {
    BITCODE_BS shadow_type;
    if (dwg_dynapi_entity_value (sun, "SUN", "shadow_type", &shadow_type, NULL)
        && shadow_type == sun->shadow_type)
      pass ();
    else
      fail ("SUN.shadow_type [BS] %hu != %hu", sun->shadow_type, shadow_type);
    shadow_type++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "shadow_type", &shadow_type, 0)
        && shadow_type == sun->shadow_type)
      pass ();
    else
      fail ("SUN.shadow_type [BS] set+1 %hu != %hu", sun->shadow_type, shadow_type);
    sun->shadow_type--;
  }
  {
    BITCODE_H skyparams;
    if (dwg_dynapi_entity_value (sun, "SUN", "skyparams", &skyparams, NULL)
        && !memcmp (&skyparams, &sun->skyparams, sizeof (sun->skyparams)))
        pass ();
    else
        fail ("SUN.skyparams [H]");
  }
  {
    BITCODE_BL time;
    if (dwg_dynapi_entity_value (sun, "SUN", "time", &time, NULL)
        && time == sun->time)
      pass ();
    else
      fail ("SUN.time [BL] %u != %u", sun->time, time);
    time++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "time", &time, 0)
        && time == sun->time)
      pass ();
    else
      fail ("SUN.time [BL] set+1 %u != %u", sun->time, time);
    sun->time--;
  }
  {
    BITCODE_BS unknown;
    if (dwg_dynapi_entity_value (sun, "SUN", "unknown", &unknown, NULL)
        && unknown == sun->unknown)
      pass ();
    else
      fail ("SUN.unknown [BS] %hu != %hu", sun->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "unknown", &unknown, 0)
        && unknown == sun->unknown)
      pass ();
    else
      fail ("SUN.unknown [BS] set+1 %hu != %hu", sun->unknown, unknown);
    sun->unknown--;
  }
  if (failed && (is_class_unstable ("SUN") || is_class_debugging ("SUN")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SUN", failed);
      failed = 0;
    }
  return failed;
}
static int test_SUNSTUDY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SUNSTUDY *restrict sunstudy = obj->tio.object->tio.SUNSTUDY;
  failed = 0;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "class_version", &class_version, NULL)
        && class_version == sunstudy->class_version)
      pass ();
    else
      fail ("SUNSTUDY.class_version [BL] %u != %u", sunstudy->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "class_version", &class_version, 0)
        && class_version == sunstudy->class_version)
      pass ();
    else
      fail ("SUNSTUDY.class_version [BL] set+1 %u != %u", sunstudy->class_version, class_version);
    sunstudy->class_version--;
  }
  {
    Dwg_SUNSTUDY_Dates* dates;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "num_dates", &count, NULL)
        && dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "dates", &dates, NULL)
        && dates == sunstudy->dates)
      pass ();
    else
      fail ("SUNSTUDY.dates [Dwg_SUNSTUDY_Dates*] * %u num_dates", count);
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)sunstudy->description)
           : !sunstudy->description)
      pass ();
    else
      fail ("SUNSTUDY.description [T] '%s' <> '%s'", description, sunstudy->description);
  }
  {
    BITCODE_BL end_time;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "end_time", &end_time, NULL)
        && end_time == sunstudy->end_time)
      pass ();
    else
      fail ("SUNSTUDY.end_time [BL] %u != %u", sunstudy->end_time, end_time);
    end_time++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "end_time", &end_time, 0)
        && end_time == sunstudy->end_time)
      pass ();
    else
      fail ("SUNSTUDY.end_time [BL] set+1 %u != %u", sunstudy->end_time, end_time);
    sunstudy->end_time--;
  }
  {
    BITCODE_B* hours;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "num_hours", &count, NULL)
        && dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "hours", &hours, NULL)
        && hours == sunstudy->hours)
      pass ();
    else
      fail ("SUNSTUDY.hours [B*] * %u num_hours", count);
  }
  {
    BITCODE_BL interval;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "interval", &interval, NULL)
        && interval == sunstudy->interval)
      pass ();
    else
      fail ("SUNSTUDY.interval [BL] %u != %u", sunstudy->interval, interval);
    interval++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "interval", &interval, 0)
        && interval == sunstudy->interval)
      pass ();
    else
      fail ("SUNSTUDY.interval [BL] set+1 %u != %u", sunstudy->interval, interval);
    sunstudy->interval--;
  }
  {
    BITCODE_B label_viewports;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "label_viewports", &label_viewports, NULL)
        && label_viewports == sunstudy->label_viewports)
      pass ();
    else
      fail ("SUNSTUDY.label_viewports [B] " FORMAT_B " != " FORMAT_B "", sunstudy->label_viewports, label_viewports);
    label_viewports++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "label_viewports", &label_viewports, 0)
        && label_viewports == sunstudy->label_viewports)
      pass ();
    else
      fail ("SUNSTUDY.label_viewports [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->label_viewports, label_viewports);
    sunstudy->label_viewports--;
  }
  {
    BITCODE_B lock_viewports;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "lock_viewports", &lock_viewports, NULL)
        && lock_viewports == sunstudy->lock_viewports)
      pass ();
    else
      fail ("SUNSTUDY.lock_viewports [B] " FORMAT_B " != " FORMAT_B "", sunstudy->lock_viewports, lock_viewports);
    lock_viewports++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "lock_viewports", &lock_viewports, 0)
        && lock_viewports == sunstudy->lock_viewports)
      pass ();
    else
      fail ("SUNSTUDY.lock_viewports [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->lock_viewports, lock_viewports);
    sunstudy->lock_viewports--;
  }
  {
    BITCODE_BL num_dates;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "num_dates", &num_dates, NULL)
        && num_dates == sunstudy->num_dates)
      pass ();
    else
      fail ("SUNSTUDY.num_dates [BL] %u != %u", sunstudy->num_dates, num_dates);
    num_dates++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "num_dates", &num_dates, 0)
        && num_dates == sunstudy->num_dates)
      pass ();
    else
      fail ("SUNSTUDY.num_dates [BL] set+1 %u != %u", sunstudy->num_dates, num_dates);
    sunstudy->num_dates--;
  }
  {
    BITCODE_BL num_hours;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "num_hours", &num_hours, NULL)
        && num_hours == sunstudy->num_hours)
      pass ();
    else
      fail ("SUNSTUDY.num_hours [BL] %u != %u", sunstudy->num_hours, num_hours);
    num_hours++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "num_hours", &num_hours, 0)
        && num_hours == sunstudy->num_hours)
      pass ();
    else
      fail ("SUNSTUDY.num_hours [BL] set+1 %u != %u", sunstudy->num_hours, num_hours);
    sunstudy->num_hours--;
  }
  {
    BITCODE_BL numcols;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "numcols", &numcols, NULL)
        && numcols == sunstudy->numcols)
      pass ();
    else
      fail ("SUNSTUDY.numcols [BL] %u != %u", sunstudy->numcols, numcols);
    numcols++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "numcols", &numcols, 0)
        && numcols == sunstudy->numcols)
      pass ();
    else
      fail ("SUNSTUDY.numcols [BL] set+1 %u != %u", sunstudy->numcols, numcols);
    sunstudy->numcols--;
  }
  {
    BITCODE_BL numrows;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "numrows", &numrows, NULL)
        && numrows == sunstudy->numrows)
      pass ();
    else
      fail ("SUNSTUDY.numrows [BL] %u != %u", sunstudy->numrows, numrows);
    numrows++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "numrows", &numrows, 0)
        && numrows == sunstudy->numrows)
      pass ();
    else
      fail ("SUNSTUDY.numrows [BL] set+1 %u != %u", sunstudy->numrows, numrows);
    sunstudy->numrows--;
  }
  {
    BITCODE_BL numvports;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "numvports", &numvports, NULL)
        && numvports == sunstudy->numvports)
      pass ();
    else
      fail ("SUNSTUDY.numvports [BL] %u != %u", sunstudy->numvports, numvports);
    numvports++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "numvports", &numvports, 0)
        && numvports == sunstudy->numvports)
      pass ();
    else
      fail ("SUNSTUDY.numvports [BL] set+1 %u != %u", sunstudy->numvports, numvports);
    sunstudy->numvports--;
  }
  {
    BITCODE_BL output_type;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "output_type", &output_type, NULL)
        && output_type == sunstudy->output_type)
      pass ();
    else
      fail ("SUNSTUDY.output_type [BL] %u != %u", sunstudy->output_type, output_type);
    output_type++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "output_type", &output_type, 0)
        && output_type == sunstudy->output_type)
      pass ();
    else
      fail ("SUNSTUDY.output_type [BL] set+1 %u != %u", sunstudy->output_type, output_type);
    sunstudy->output_type--;
  }
  {
    BITCODE_H page_setup_wizard;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "page_setup_wizard", &page_setup_wizard, NULL)
        && !memcmp (&page_setup_wizard, &sunstudy->page_setup_wizard, sizeof (sunstudy->page_setup_wizard)))
        pass ();
    else
        fail ("SUNSTUDY.page_setup_wizard [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "parent", &parent, NULL)
        && !memcmp (&parent, &sunstudy->parent, sizeof (sunstudy->parent)))
        pass ();
    else
        fail ("SUNSTUDY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B select_dates_from_calendar;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "select_dates_from_calendar", &select_dates_from_calendar, NULL)
        && select_dates_from_calendar == sunstudy->select_dates_from_calendar)
      pass ();
    else
      fail ("SUNSTUDY.select_dates_from_calendar [B] " FORMAT_B " != " FORMAT_B "", sunstudy->select_dates_from_calendar, select_dates_from_calendar);
    select_dates_from_calendar++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "select_dates_from_calendar", &select_dates_from_calendar, 0)
        && select_dates_from_calendar == sunstudy->select_dates_from_calendar)
      pass ();
    else
      fail ("SUNSTUDY.select_dates_from_calendar [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->select_dates_from_calendar, select_dates_from_calendar);
    sunstudy->select_dates_from_calendar--;
  }
  {
    BITCODE_B select_range_of_dates;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "select_range_of_dates", &select_range_of_dates, NULL)
        && select_range_of_dates == sunstudy->select_range_of_dates)
      pass ();
    else
      fail ("SUNSTUDY.select_range_of_dates [B] " FORMAT_B " != " FORMAT_B "", sunstudy->select_range_of_dates, select_range_of_dates);
    select_range_of_dates++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "select_range_of_dates", &select_range_of_dates, 0)
        && select_range_of_dates == sunstudy->select_range_of_dates)
      pass ();
    else
      fail ("SUNSTUDY.select_range_of_dates [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->select_range_of_dates, select_range_of_dates);
    sunstudy->select_range_of_dates--;
  }
  {
    BITCODE_T setup_name;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "setup_name", &setup_name, NULL)
        && setup_name
           ? strEQ ((char *)setup_name, (char *)sunstudy->setup_name)
           : !sunstudy->setup_name)
      pass ();
    else
      fail ("SUNSTUDY.setup_name [T] '%s' <> '%s'", setup_name, sunstudy->setup_name);
  }
  {
    BITCODE_BL shade_plot_type;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "shade_plot_type", &shade_plot_type, NULL)
        && shade_plot_type == sunstudy->shade_plot_type)
      pass ();
    else
      fail ("SUNSTUDY.shade_plot_type [BL] %u != %u", sunstudy->shade_plot_type, shade_plot_type);
    shade_plot_type++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "shade_plot_type", &shade_plot_type, 0)
        && shade_plot_type == sunstudy->shade_plot_type)
      pass ();
    else
      fail ("SUNSTUDY.shade_plot_type [BL] set+1 %u != %u", sunstudy->shade_plot_type, shade_plot_type);
    sunstudy->shade_plot_type--;
  }
  {
    BITCODE_T sheet_set_name;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "sheet_set_name", &sheet_set_name, NULL)
        && sheet_set_name
           ? strEQ ((char *)sheet_set_name, (char *)sunstudy->sheet_set_name)
           : !sunstudy->sheet_set_name)
      pass ();
    else
      fail ("SUNSTUDY.sheet_set_name [T] '%s' <> '%s'", sheet_set_name, sunstudy->sheet_set_name);
  }
  {
    BITCODE_T sheet_subset_name;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "sheet_subset_name", &sheet_subset_name, NULL)
        && sheet_subset_name
           ? strEQ ((char *)sheet_subset_name, (char *)sunstudy->sheet_subset_name)
           : !sunstudy->sheet_subset_name)
      pass ();
    else
      fail ("SUNSTUDY.sheet_subset_name [T] '%s' <> '%s'", sheet_subset_name, sunstudy->sheet_subset_name);
  }
  {
    BITCODE_BD spacing;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "spacing", &spacing, NULL)
        && spacing == sunstudy->spacing)
      pass ();
    else
      fail ("SUNSTUDY.spacing [BD] %g != %g", sunstudy->spacing, spacing);
    spacing++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "spacing", &spacing, 0)
        && spacing == sunstudy->spacing)
      pass ();
    else
      fail ("SUNSTUDY.spacing [BD] set+1 %g != %g", sunstudy->spacing, spacing);
    sunstudy->spacing--;
  }
  {
    BITCODE_BL start_time;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "start_time", &start_time, NULL)
        && start_time == sunstudy->start_time)
      pass ();
    else
      fail ("SUNSTUDY.start_time [BL] %u != %u", sunstudy->start_time, start_time);
    start_time++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "start_time", &start_time, 0)
        && start_time == sunstudy->start_time)
      pass ();
    else
      fail ("SUNSTUDY.start_time [BL] set+1 %u != %u", sunstudy->start_time, start_time);
    sunstudy->start_time--;
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "text_style", &text_style, NULL)
        && !memcmp (&text_style, &sunstudy->text_style, sizeof (sunstudy->text_style)))
        pass ();
    else
        fail ("SUNSTUDY.text_style [H]");
  }
  {
    BITCODE_B use_subset;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "use_subset", &use_subset, NULL)
        && use_subset == sunstudy->use_subset)
      pass ();
    else
      fail ("SUNSTUDY.use_subset [B] " FORMAT_B " != " FORMAT_B "", sunstudy->use_subset, use_subset);
    use_subset++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "use_subset", &use_subset, 0)
        && use_subset == sunstudy->use_subset)
      pass ();
    else
      fail ("SUNSTUDY.use_subset [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->use_subset, use_subset);
    sunstudy->use_subset--;
  }
  {
    BITCODE_H view;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "view", &view, NULL)
        && !memcmp (&view, &sunstudy->view, sizeof (sunstudy->view)))
        pass ();
    else
        fail ("SUNSTUDY.view [H]");
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &sunstudy->visualstyle, sizeof (sunstudy->visualstyle)))
        pass ();
    else
        fail ("SUNSTUDY.visualstyle [H]");
  }
  if (failed && (is_class_unstable ("SUNSTUDY") || is_class_debugging ("SUNSTUDY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SUNSTUDY", failed);
      failed = 0;
    }
  return failed;
}
static int test_TABLECONTENT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TABLECONTENT *restrict tablecontent = obj->tio.object->tio.TABLECONTENT;
  failed = 0;
  {
    Dwg_FormattedTableData fdata;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "fdata", &fdata, NULL)
        && !memcmp (&fdata, &tablecontent->fdata, sizeof (tablecontent->fdata)))
        pass ();
    else
        fail ("TABLECONTENT.fdata [Dwg_FormattedTableData]");
  }
  {
    Dwg_LinkedData ldata;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "ldata", &ldata, NULL)
        && !memcmp (&ldata, &tablecontent->ldata, sizeof (tablecontent->ldata)))
        pass ();
    else
        fail ("TABLECONTENT.ldata [Dwg_LinkedData]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "parent", &parent, NULL)
        && !memcmp (&parent, &tablecontent->parent, sizeof (tablecontent->parent)))
        pass ();
    else
        fail ("TABLECONTENT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H table_style;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "table_style", &table_style, NULL)
        && !memcmp (&table_style, &tablecontent->table_style, sizeof (tablecontent->table_style)))
        pass ();
    else
        fail ("TABLECONTENT.table_style [H]");
  }
  {
    Dwg_LinkedTableData tdata;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "tdata", &tdata, NULL)
        && !memcmp (&tdata, &tablecontent->tdata, sizeof (tablecontent->tdata)))
        pass ();
    else
        fail ("TABLECONTENT.tdata [Dwg_LinkedTableData]");
  }
  if (failed && (is_class_unstable ("TABLECONTENT") || is_class_debugging ("TABLECONTENT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TABLECONTENT", failed);
      failed = 0;
    }
  return failed;
}
static int test_TABLEGEOMETRY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TABLEGEOMETRY *restrict tablegeometry = obj->tio.object->tio.TABLEGEOMETRY;
  failed = 0;
  {
    Dwg_TABLEGEOMETRY_Cell* cells;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "num_cells", &count, NULL)
        && dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "cells", &cells, NULL)
        && cells == tablegeometry->cells)
      pass ();
    else
      fail ("TABLEGEOMETRY.cells [Dwg_TABLEGEOMETRY_Cell*] * %u num_cells", count);
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "num_cells", &num_cells, NULL)
        && num_cells == tablegeometry->num_cells)
      pass ();
    else
      fail ("TABLEGEOMETRY.num_cells [BL] %u != %u", tablegeometry->num_cells, num_cells);
    num_cells++;
    if (dwg_dynapi_entity_set_value (tablegeometry, "TABLEGEOMETRY", "num_cells", &num_cells, 0)
        && num_cells == tablegeometry->num_cells)
      pass ();
    else
      fail ("TABLEGEOMETRY.num_cells [BL] set+1 %u != %u", tablegeometry->num_cells, num_cells);
    tablegeometry->num_cells--;
  }
  {
    BITCODE_BL num_cols;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "num_cols", &num_cols, NULL)
        && num_cols == tablegeometry->num_cols)
      pass ();
    else
      fail ("TABLEGEOMETRY.num_cols [BL] %u != %u", tablegeometry->num_cols, num_cols);
    num_cols++;
    if (dwg_dynapi_entity_set_value (tablegeometry, "TABLEGEOMETRY", "num_cols", &num_cols, 0)
        && num_cols == tablegeometry->num_cols)
      pass ();
    else
      fail ("TABLEGEOMETRY.num_cols [BL] set+1 %u != %u", tablegeometry->num_cols, num_cols);
    tablegeometry->num_cols--;
  }
  {
    BITCODE_BL num_rows;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "num_rows", &num_rows, NULL)
        && num_rows == tablegeometry->num_rows)
      pass ();
    else
      fail ("TABLEGEOMETRY.num_rows [BL] %u != %u", tablegeometry->num_rows, num_rows);
    num_rows++;
    if (dwg_dynapi_entity_set_value (tablegeometry, "TABLEGEOMETRY", "num_rows", &num_rows, 0)
        && num_rows == tablegeometry->num_rows)
      pass ();
    else
      fail ("TABLEGEOMETRY.num_rows [BL] set+1 %u != %u", tablegeometry->num_rows, num_rows);
    tablegeometry->num_rows--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "parent", &parent, NULL)
        && !memcmp (&parent, &tablegeometry->parent, sizeof (tablegeometry->parent)))
        pass ();
    else
        fail ("TABLEGEOMETRY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("TABLEGEOMETRY") || is_class_debugging ("TABLEGEOMETRY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TABLEGEOMETRY", failed);
      failed = 0;
    }
  return failed;
}
static int test_TABLESTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TABLESTYLE *restrict tablestyle = obj->tio.object->tio.TABLESTYLE;
  failed = 0;
  {
    Dwg_TABLESTYLE_Cell* cells;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "num_cells", &count, NULL)
        && dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "cells", &cells, NULL)
        && cells == tablestyle->cells)
      pass ();
    else
      fail ("TABLESTYLE.cells [Dwg_TABLESTYLE_Cell*] * %u num_cells", count);
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "class_version", &class_version, NULL)
        && class_version == tablestyle->class_version)
      pass ();
    else
      fail ("TABLESTYLE.class_version [BS] %hu != %hu", tablestyle->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "class_version", &class_version, 0)
        && class_version == tablestyle->class_version)
      pass ();
    else
      fail ("TABLESTYLE.class_version [BS] set+1 %hu != %hu", tablestyle->class_version, class_version);
    tablestyle->class_version--;
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "flags", &flags, NULL)
        && flags == tablestyle->flags)
      pass ();
    else
      fail ("TABLESTYLE.flags [BS] %hu != %hu", tablestyle->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "flags", &flags, 0)
        && flags == tablestyle->flags)
      pass ();
    else
      fail ("TABLESTYLE.flags [BS] set+1 %hu != %hu", tablestyle->flags, flags);
    tablestyle->flags--;
  }
  {
    BITCODE_BS flow_direction;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "flow_direction", &flow_direction, NULL)
        && flow_direction == tablestyle->flow_direction)
      pass ();
    else
      fail ("TABLESTYLE.flow_direction [BS] %hu != %hu", tablestyle->flow_direction, flow_direction);
    flow_direction++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "flow_direction", &flow_direction, 0)
        && flow_direction == tablestyle->flow_direction)
      pass ();
    else
      fail ("TABLESTYLE.flow_direction [BS] set+1 %hu != %hu", tablestyle->flow_direction, flow_direction);
    tablestyle->flow_direction--;
  }
  {
    BITCODE_B header_suppressed;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "header_suppressed", &header_suppressed, NULL)
        && header_suppressed == tablestyle->header_suppressed)
      pass ();
    else
      fail ("TABLESTYLE.header_suppressed [B] " FORMAT_B " != " FORMAT_B "", tablestyle->header_suppressed, header_suppressed);
    header_suppressed++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "header_suppressed", &header_suppressed, 0)
        && header_suppressed == tablestyle->header_suppressed)
      pass ();
    else
      fail ("TABLESTYLE.header_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", tablestyle->header_suppressed, header_suppressed);
    tablestyle->header_suppressed--;
  }
  {
    BITCODE_BD horiz_cell_margin;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "horiz_cell_margin", &horiz_cell_margin, NULL)
        && horiz_cell_margin == tablestyle->horiz_cell_margin)
      pass ();
    else
      fail ("TABLESTYLE.horiz_cell_margin [BD] %g != %g", tablestyle->horiz_cell_margin, horiz_cell_margin);
    horiz_cell_margin++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "horiz_cell_margin", &horiz_cell_margin, 0)
        && horiz_cell_margin == tablestyle->horiz_cell_margin)
      pass ();
    else
      fail ("TABLESTYLE.horiz_cell_margin [BD] set+1 %g != %g", tablestyle->horiz_cell_margin, horiz_cell_margin);
    tablestyle->horiz_cell_margin--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)tablestyle->name)
           : !tablestyle->name)
      pass ();
    else
      fail ("TABLESTYLE.name [T] '%s' <> '%s'", name, tablestyle->name);
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "num_cells", &num_cells, NULL)
        && num_cells == tablestyle->num_cells)
      pass ();
    else
      fail ("TABLESTYLE.num_cells [BL] %u != %u", tablestyle->num_cells, num_cells);
    num_cells++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "num_cells", &num_cells, 0)
        && num_cells == tablestyle->num_cells)
      pass ();
    else
      fail ("TABLESTYLE.num_cells [BL] set+1 %u != %u", tablestyle->num_cells, num_cells);
    tablestyle->num_cells--;
  }
  {
    BITCODE_BL num_rowstyles;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "num_rowstyles", &num_rowstyles, NULL)
        && num_rowstyles == tablestyle->num_rowstyles)
      pass ();
    else
      fail ("TABLESTYLE.num_rowstyles [BL] %u != %u", tablestyle->num_rowstyles, num_rowstyles);
    num_rowstyles++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "num_rowstyles", &num_rowstyles, 0)
        && num_rowstyles == tablestyle->num_rowstyles)
      pass ();
    else
      fail ("TABLESTYLE.num_rowstyles [BL] set+1 %u != %u", tablestyle->num_rowstyles, num_rowstyles);
    tablestyle->num_rowstyles--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &tablestyle->parent, sizeof (tablestyle->parent)))
        pass ();
    else
        fail ("TABLESTYLE.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_TABLESTYLE_rowstyles* rowstyles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "num_rowstyles", &count, NULL)
        && dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "rowstyles", &rowstyles, NULL)
        && rowstyles == tablestyle->rowstyles)
      pass ();
    else
      fail ("TABLESTYLE.rowstyles [Dwg_TABLESTYLE_rowstyles*] * %u num_rowstyles", count);
  }
  {
    BITCODE_B title_suppressed;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "title_suppressed", &title_suppressed, NULL)
        && title_suppressed == tablestyle->title_suppressed)
      pass ();
    else
      fail ("TABLESTYLE.title_suppressed [B] " FORMAT_B " != " FORMAT_B "", tablestyle->title_suppressed, title_suppressed);
    title_suppressed++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "title_suppressed", &title_suppressed, 0)
        && title_suppressed == tablestyle->title_suppressed)
      pass ();
    else
      fail ("TABLESTYLE.title_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", tablestyle->title_suppressed, title_suppressed);
    tablestyle->title_suppressed--;
  }
  {
    BITCODE_BD vert_cell_margin;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "vert_cell_margin", &vert_cell_margin, NULL)
        && vert_cell_margin == tablestyle->vert_cell_margin)
      pass ();
    else
      fail ("TABLESTYLE.vert_cell_margin [BD] %g != %g", tablestyle->vert_cell_margin, vert_cell_margin);
    vert_cell_margin++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "vert_cell_margin", &vert_cell_margin, 0)
        && vert_cell_margin == tablestyle->vert_cell_margin)
      pass ();
    else
      fail ("TABLESTYLE.vert_cell_margin [BD] set+1 %g != %g", tablestyle->vert_cell_margin, vert_cell_margin);
    tablestyle->vert_cell_margin--;
  }
  if (failed && (is_class_unstable ("TABLESTYLE") || is_class_debugging ("TABLESTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TABLESTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_TEXTOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TEXTOBJECTCONTEXTDATA *restrict textobjectcontextdata = obj->tio.object->tio.TEXTOBJECTCONTEXTDATA;
  failed = 0;
  {
    BITCODE_2RD alignment_pt;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &textobjectcontextdata->alignment_pt, sizeof (textobjectcontextdata->alignment_pt)))
        pass ();
    else
        fail ("TEXTOBJECTCONTEXTDATA.alignment_pt [2RD]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == textobjectcontextdata->class_version)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", textobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == textobjectcontextdata->class_version)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", textobjectcontextdata->class_version, class_version);
    textobjectcontextdata->class_version--;
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL)
        && defaultflag == textobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", textobjectcontextdata->defaultflag, defaultflag);
    defaultflag++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "defaultflag", &defaultflag, 0)
        && defaultflag == textobjectcontextdata->defaultflag)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.defaultflag [B] set+1 " FORMAT_B " != " FORMAT_B "", textobjectcontextdata->defaultflag, defaultflag);
    textobjectcontextdata->defaultflag--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "flag", &flag, NULL)
        && flag == textobjectcontextdata->flag)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.flag [BS] %hu != %hu", textobjectcontextdata->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "flag", &flag, 0)
        && flag == textobjectcontextdata->flag)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.flag [BS] set+1 %hu != %hu", textobjectcontextdata->flag, flag);
    textobjectcontextdata->flag--;
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "has_file", &has_file, NULL)
        && has_file == textobjectcontextdata->has_file)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", textobjectcontextdata->has_file, has_file);
    has_file++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "has_file", &has_file, 0)
        && has_file == textobjectcontextdata->has_file)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.has_file [B] set+1 " FORMAT_B " != " FORMAT_B "", textobjectcontextdata->has_file, has_file);
    textobjectcontextdata->has_file--;
  }
  {
    BITCODE_2RD insertion_pt;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "insertion_pt", &insertion_pt, NULL)
        && !memcmp (&insertion_pt, &textobjectcontextdata->insertion_pt, sizeof (textobjectcontextdata->insertion_pt)))
        pass ();
    else
        fail ("TEXTOBJECTCONTEXTDATA.insertion_pt [2RD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &textobjectcontextdata->parent, sizeof (textobjectcontextdata->parent)))
        pass ();
    else
        fail ("TEXTOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "rotation", &rotation, NULL)
        && rotation == textobjectcontextdata->rotation)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.rotation [BD] %g != %g", textobjectcontextdata->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "rotation", &rotation, 0)
        && rotation == textobjectcontextdata->rotation)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.rotation [BD] set+1 %g != %g", textobjectcontextdata->rotation, rotation);
    textobjectcontextdata->rotation--;
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &textobjectcontextdata->scale, sizeof (textobjectcontextdata->scale)))
        pass ();
    else
        fail ("TEXTOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("TEXTOBJECTCONTEXTDATA") || is_class_debugging ("TEXTOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TEXTOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_UCS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_UCS *restrict ucs = obj->tio.object->tio.UCS;
  failed = 0;
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (ucs, "UCS", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &ucs->base_ucs, sizeof (ucs->base_ucs)))
        pass ();
    else
        fail ("UCS.base_ucs [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (ucs, "UCS", "elevation", &elevation, NULL)
        && elevation == ucs->elevation)
      pass ();
    else
      fail ("UCS.elevation [BD] %g != %g", ucs->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "elevation", &elevation, 0)
        && elevation == ucs->elevation)
      pass ();
    else
      fail ("UCS.elevation [BD] set+1 %g != %g", ucs->elevation, elevation);
    ucs->elevation--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (ucs, "UCS", "flag", &flag, NULL)
        && flag == ucs->flag)
      pass ();
    else
      fail ("UCS.flag [RC] %u != %u", ucs->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "flag", &flag, 0)
        && flag == ucs->flag)
      pass ();
    else
      fail ("UCS.flag [RC] set+1 %u != %u", ucs->flag, flag);
    ucs->flag--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (ucs, "UCS", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)ucs->name)
           : !ucs->name)
      pass ();
    else
      fail ("UCS.name [TV] '%s' <> '%s'", name, ucs->name);
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (ucs, "UCS", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &ucs->named_ucs, sizeof (ucs->named_ucs)))
        pass ();
    else
        fail ("UCS.named_ucs [H]");
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value (ucs, "UCS", "null_handle", &null_handle, NULL)
        && !memcmp (&null_handle, &ucs->null_handle, sizeof (ucs->null_handle)))
        pass ();
    else
        fail ("UCS.null_handle [H]");
  }
  {
    BITCODE_3BD origin;
    if (dwg_dynapi_entity_value (ucs, "UCS", "origin", &origin, NULL)
        && !memcmp (&origin, &ucs->origin, sizeof (ucs->origin)))
        pass ();
    else
        fail ("UCS.origin [3BD]");
  }
  {
    BITCODE_BS orthographic_type;
    if (dwg_dynapi_entity_value (ucs, "UCS", "orthographic_type", &orthographic_type, NULL)
        && orthographic_type == ucs->orthographic_type)
      pass ();
    else
      fail ("UCS.orthographic_type [BS] %hu != %hu", ucs->orthographic_type, orthographic_type);
    orthographic_type++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "orthographic_type", &orthographic_type, 0)
        && orthographic_type == ucs->orthographic_type)
      pass ();
    else
      fail ("UCS.orthographic_type [BS] set+1 %hu != %hu", ucs->orthographic_type, orthographic_type);
    ucs->orthographic_type--;
  }
  {
    BITCODE_BS orthographic_view_type;
    if (dwg_dynapi_entity_value (ucs, "UCS", "orthographic_view_type", &orthographic_view_type, NULL)
        && orthographic_view_type == ucs->orthographic_view_type)
      pass ();
    else
      fail ("UCS.orthographic_view_type [BS] %hu != %hu", ucs->orthographic_view_type, orthographic_view_type);
    orthographic_view_type++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "orthographic_view_type", &orthographic_view_type, 0)
        && orthographic_view_type == ucs->orthographic_view_type)
      pass ();
    else
      fail ("UCS.orthographic_view_type [BS] set+1 %hu != %hu", ucs->orthographic_view_type, orthographic_view_type);
    ucs->orthographic_view_type--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ucs, "UCS", "parent", &parent, NULL)
        && !memcmp (&parent, &ucs->parent, sizeof (ucs->parent)))
        pass ();
    else
        fail ("UCS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (ucs, "UCS", "used", &used, NULL)
        && used == ucs->used)
      pass ();
    else
      fail ("UCS.used [RS] %hu != %hu", ucs->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "used", &used, 0)
        && used == ucs->used)
      pass ();
    else
      fail ("UCS.used [RS] set+1 %hu != %hu", ucs->used, used);
    ucs->used--;
  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value (ucs, "UCS", "x_direction", &x_direction, NULL)
        && !memcmp (&x_direction, &ucs->x_direction, sizeof (ucs->x_direction)))
        pass ();
    else
        fail ("UCS.x_direction [3BD]");
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (ucs, "UCS", "xrefdep", &xrefdep, NULL)
        && xrefdep == ucs->xrefdep)
      pass ();
    else
      fail ("UCS.xrefdep [B] " FORMAT_B " != " FORMAT_B "", ucs->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "xrefdep", &xrefdep, 0)
        && xrefdep == ucs->xrefdep)
      pass ();
    else
      fail ("UCS.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", ucs->xrefdep, xrefdep);
    ucs->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (ucs, "UCS", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == ucs->xrefindex_plus1)
      pass ();
    else
      fail ("UCS.xrefindex_plus1 [BS] %hu != %hu", ucs->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == ucs->xrefindex_plus1)
      pass ();
    else
      fail ("UCS.xrefindex_plus1 [BS] set+1 %hu != %hu", ucs->xrefindex_plus1, xrefindex_plus1);
    ucs->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (ucs, "UCS", "xrefref", &xrefref, NULL)
        && xrefref == ucs->xrefref)
      pass ();
    else
      fail ("UCS.xrefref [B] " FORMAT_B " != " FORMAT_B "", ucs->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "xrefref", &xrefref, 0)
        && xrefref == ucs->xrefref)
      pass ();
    else
      fail ("UCS.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", ucs->xrefref, xrefref);
    ucs->xrefref--;
  }
  {
    BITCODE_3BD y_direction;
    if (dwg_dynapi_entity_value (ucs, "UCS", "y_direction", &y_direction, NULL)
        && !memcmp (&y_direction, &ucs->y_direction, sizeof (ucs->y_direction)))
        pass ();
    else
        fail ("UCS.y_direction [3BD]");
  }
  if (failed && (is_class_unstable ("UCS") || is_class_debugging ("UCS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "UCS", failed);
      failed = 0;
    }
  return failed;
}
static int test_UCS_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_UCS_CONTROL *restrict ucs_control = obj->tio.object->tio.UCS_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "entries", &entries, NULL)
        && entries == ucs_control->entries)
      pass ();
    else
      fail ("UCS_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == ucs_control->num_entries)
      pass ();
    else
      fail ("UCS_CONTROL.num_entries [BS] %hu != %hu", ucs_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (ucs_control, "UCS_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == ucs_control->num_entries)
      pass ();
    else
      fail ("UCS_CONTROL.num_entries [BS] set+1 %hu != %hu", ucs_control->num_entries, num_entries);
    ucs_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "objid", &objid, NULL)
        && objid == ucs_control->objid)
      pass ();
    else
      fail ("UCS_CONTROL.objid [BL] %u != %u", ucs_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (ucs_control, "UCS_CONTROL", "objid", &objid, 0)
        && objid == ucs_control->objid)
      pass ();
    else
      fail ("UCS_CONTROL.objid [BL] set+1 %u != %u", ucs_control->objid, objid);
    ucs_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &ucs_control->parent, sizeof (ucs_control->parent)))
        pass ();
    else
        fail ("UCS_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("UCS_CONTROL") || is_class_debugging ("UCS_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "UCS_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_UNDERLAYDEFINITION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_UNDERLAYDEFINITION *restrict underlaydefinition = obj->tio.object->tio.UNDERLAYDEFINITION;
  failed = 0;
  {
    BITCODE_T filename;
    if (dwg_dynapi_entity_value (underlaydefinition, "UNDERLAYDEFINITION", "filename", &filename, NULL)
        && filename
           ? strEQ ((char *)filename, (char *)underlaydefinition->filename)
           : !underlaydefinition->filename)
      pass ();
    else
      fail ("UNDERLAYDEFINITION.filename [T] '%s' <> '%s'", filename, underlaydefinition->filename);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (underlaydefinition, "UNDERLAYDEFINITION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)underlaydefinition->name)
           : !underlaydefinition->name)
      pass ();
    else
      fail ("UNDERLAYDEFINITION.name [T] '%s' <> '%s'", name, underlaydefinition->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (underlaydefinition, "UNDERLAYDEFINITION", "parent", &parent, NULL)
        && !memcmp (&parent, &underlaydefinition->parent, sizeof (underlaydefinition->parent)))
        pass ();
    else
        fail ("UNDERLAYDEFINITION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("UNDERLAYDEFINITION") || is_class_debugging ("UNDERLAYDEFINITION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "UNDERLAYDEFINITION", failed);
      failed = 0;
    }
  return failed;
}
static int test_VBA_PROJECT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VBA_PROJECT *restrict vba_project = obj->tio.object->tio.VBA_PROJECT;
  failed = 0;
  {
    BITCODE_TF data;
    if (dwg_dynapi_entity_value (vba_project, "VBA_PROJECT", "data", &data, NULL)
        && !memcmp (&data, &vba_project->data, sizeof (vba_project->data)))
        pass ();
    else
        fail ("VBA_PROJECT.data [TF]");
  }
  {
    BITCODE_RL data_size;
    if (dwg_dynapi_entity_value (vba_project, "VBA_PROJECT", "data_size", &data_size, NULL)
        && data_size == vba_project->data_size)
      pass ();
    else
      fail ("VBA_PROJECT.data_size [RL] %u != %u", vba_project->data_size, data_size);
    data_size++;
    if (dwg_dynapi_entity_set_value (vba_project, "VBA_PROJECT", "data_size", &data_size, 0)
        && data_size == vba_project->data_size)
      pass ();
    else
      fail ("VBA_PROJECT.data_size [RL] set+1 %u != %u", vba_project->data_size, data_size);
    vba_project->data_size--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vba_project, "VBA_PROJECT", "parent", &parent, NULL)
        && !memcmp (&parent, &vba_project->parent, sizeof (vba_project->parent)))
        pass ();
    else
        fail ("VBA_PROJECT.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("VBA_PROJECT") || is_class_debugging ("VBA_PROJECT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VBA_PROJECT", failed);
      failed = 0;
    }
  return failed;
}
static int test_VIEW (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VIEW *restrict view = obj->tio.object->tio.VIEW;
  failed = 0;
  {
    BITCODE_4BITS VIEWMODE;
    if (dwg_dynapi_entity_value (view, "VIEW", "VIEWMODE", &VIEWMODE, NULL)
        && VIEWMODE == view->VIEWMODE)
      pass ();
    else
      fail ("VIEW.VIEWMODE [4BITS] " FORMAT_4BITS " != " FORMAT_4BITS "", view->VIEWMODE, VIEWMODE);
    if (dwg_dynapi_entity_set_value (view, "VIEW", "VIEWMODE", &VIEWMODE, 0)
        && VIEWMODE == view->VIEWMODE)
      pass ();
    else
      fail ("VIEW.VIEWMODE [4BITS] set+1 " FORMAT_4BITS " != " FORMAT_4BITS "", view->VIEWMODE, VIEWMODE);
    view->VIEWMODE--;
  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value (view, "VIEW", "ambient_color", &ambient_color, NULL)
        && !memcmp (&ambient_color, &view->ambient_color, sizeof (view->ambient_color)))
        pass ();
    else
        fail ("VIEW.ambient_color [CMC]");
  }
  {
    BITCODE_B associated_ucs;
    if (dwg_dynapi_entity_value (view, "VIEW", "associated_ucs", &associated_ucs, NULL)
        && associated_ucs == view->associated_ucs)
      pass ();
    else
      fail ("VIEW.associated_ucs [B] " FORMAT_B " != " FORMAT_B "", view->associated_ucs, associated_ucs);
    associated_ucs++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "associated_ucs", &associated_ucs, 0)
        && associated_ucs == view->associated_ucs)
      pass ();
    else
      fail ("VIEW.associated_ucs [B] set+1 " FORMAT_B " != " FORMAT_B "", view->associated_ucs, associated_ucs);
    view->associated_ucs--;
  }
  {
    BITCODE_BD back_clip;
    if (dwg_dynapi_entity_value (view, "VIEW", "back_clip", &back_clip, NULL)
        && back_clip == view->back_clip)
      pass ();
    else
      fail ("VIEW.back_clip [BD] %g != %g", view->back_clip, back_clip);
    back_clip++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "back_clip", &back_clip, 0)
        && back_clip == view->back_clip)
      pass ();
    else
      fail ("VIEW.back_clip [BD] set+1 %g != %g", view->back_clip, back_clip);
    view->back_clip--;
  }
  {
    BITCODE_H background;
    if (dwg_dynapi_entity_value (view, "VIEW", "background", &background, NULL)
        && !memcmp (&background, &view->background, sizeof (view->background)))
        pass ();
    else
        fail ("VIEW.background [H]");
  }
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (view, "VIEW", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &view->base_ucs, sizeof (view->base_ucs)))
        pass ();
    else
        fail ("VIEW.base_ucs [H]");
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value (view, "VIEW", "brightness", &brightness, NULL)
        && brightness == view->brightness)
      pass ();
    else
      fail ("VIEW.brightness [BD] %g != %g", view->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "brightness", &brightness, 0)
        && brightness == view->brightness)
      pass ();
    else
      fail ("VIEW.brightness [BD] set+1 %g != %g", view->brightness, brightness);
    view->brightness--;
  }
  {
    BITCODE_B camera_plottable;
    if (dwg_dynapi_entity_value (view, "VIEW", "camera_plottable", &camera_plottable, NULL)
        && camera_plottable == view->camera_plottable)
      pass ();
    else
      fail ("VIEW.camera_plottable [B] " FORMAT_B " != " FORMAT_B "", view->camera_plottable, camera_plottable);
    camera_plottable++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "camera_plottable", &camera_plottable, 0)
        && camera_plottable == view->camera_plottable)
      pass ();
    else
      fail ("VIEW.camera_plottable [B] set+1 " FORMAT_B " != " FORMAT_B "", view->camera_plottable, camera_plottable);
    view->camera_plottable--;
  }
  {
    BITCODE_2RD center;
    if (dwg_dynapi_entity_value (view, "VIEW", "center", &center, NULL)
        && !memcmp (&center, &view->center, sizeof (view->center)))
        pass ();
    else
        fail ("VIEW.center [2RD]");
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value (view, "VIEW", "contrast", &contrast, NULL)
        && contrast == view->contrast)
      pass ();
    else
      fail ("VIEW.contrast [BD] %g != %g", view->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "contrast", &contrast, 0)
        && contrast == view->contrast)
      pass ();
    else
      fail ("VIEW.contrast [BD] set+1 %g != %g", view->contrast, contrast);
    view->contrast--;
  }
  {
    BITCODE_RC default_lightning_type;
    if (dwg_dynapi_entity_value (view, "VIEW", "default_lightning_type", &default_lightning_type, NULL)
        && default_lightning_type == view->default_lightning_type)
      pass ();
    else
      fail ("VIEW.default_lightning_type [RC] %u != %u", view->default_lightning_type, default_lightning_type);
    default_lightning_type++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "default_lightning_type", &default_lightning_type, 0)
        && default_lightning_type == view->default_lightning_type)
      pass ();
    else
      fail ("VIEW.default_lightning_type [RC] set+1 %u != %u", view->default_lightning_type, default_lightning_type);
    view->default_lightning_type--;
  }
  {
    BITCODE_3BD direction;
    if (dwg_dynapi_entity_value (view, "VIEW", "direction", &direction, NULL)
        && !memcmp (&direction, &view->direction, sizeof (view->direction)))
        pass ();
    else
        fail ("VIEW.direction [3BD]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (view, "VIEW", "elevation", &elevation, NULL)
        && elevation == view->elevation)
      pass ();
    else
      fail ("VIEW.elevation [BD] %g != %g", view->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "elevation", &elevation, 0)
        && elevation == view->elevation)
      pass ();
    else
      fail ("VIEW.elevation [BD] set+1 %g != %g", view->elevation, elevation);
    view->elevation--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (view, "VIEW", "flag", &flag, NULL)
        && flag == view->flag)
      pass ();
    else
      fail ("VIEW.flag [RC] %u != %u", view->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "flag", &flag, 0)
        && flag == view->flag)
      pass ();
    else
      fail ("VIEW.flag [RC] set+1 %u != %u", view->flag, flag);
    view->flag--;
  }
  {
    BITCODE_BD front_clip;
    if (dwg_dynapi_entity_value (view, "VIEW", "front_clip", &front_clip, NULL)
        && front_clip == view->front_clip)
      pass ();
    else
      fail ("VIEW.front_clip [BD] %g != %g", view->front_clip, front_clip);
    front_clip++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "front_clip", &front_clip, 0)
        && front_clip == view->front_clip)
      pass ();
    else
      fail ("VIEW.front_clip [BD] set+1 %g != %g", view->front_clip, front_clip);
    view->front_clip--;
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (view, "VIEW", "height", &height, NULL)
        && height == view->height)
      pass ();
    else
      fail ("VIEW.height [BD] %g != %g", view->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "height", &height, 0)
        && height == view->height)
      pass ();
    else
      fail ("VIEW.height [BD] set+1 %g != %g", view->height, height);
    view->height--;
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value (view, "VIEW", "lens_length", &lens_length, NULL)
        && lens_length == view->lens_length)
      pass ();
    else
      fail ("VIEW.lens_length [BD] %g != %g", view->lens_length, lens_length);
    lens_length++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "lens_length", &lens_length, 0)
        && lens_length == view->lens_length)
      pass ();
    else
      fail ("VIEW.lens_length [BD] set+1 %g != %g", view->lens_length, lens_length);
    view->lens_length--;
  }
  {
    BITCODE_H livesection;
    if (dwg_dynapi_entity_value (view, "VIEW", "livesection", &livesection, NULL)
        && !memcmp (&livesection, &view->livesection, sizeof (view->livesection)))
        pass ();
    else
        fail ("VIEW.livesection [H]");
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (view, "VIEW", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)view->name)
           : !view->name)
      pass ();
    else
      fail ("VIEW.name [TV] '%s' <> '%s'", name, view->name);
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (view, "VIEW", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &view->named_ucs, sizeof (view->named_ucs)))
        pass ();
    else
        fail ("VIEW.named_ucs [H]");
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value (view, "VIEW", "null_handle", &null_handle, NULL)
        && !memcmp (&null_handle, &view->null_handle, sizeof (view->null_handle)))
        pass ();
    else
        fail ("VIEW.null_handle [H]");
  }
  {
    BITCODE_3BD origin;
    if (dwg_dynapi_entity_value (view, "VIEW", "origin", &origin, NULL)
        && !memcmp (&origin, &view->origin, sizeof (view->origin)))
        pass ();
    else
        fail ("VIEW.origin [3BD]");
  }
  {
    BITCODE_BS orthographic_view_type;
    if (dwg_dynapi_entity_value (view, "VIEW", "orthographic_view_type", &orthographic_view_type, NULL)
        && orthographic_view_type == view->orthographic_view_type)
      pass ();
    else
      fail ("VIEW.orthographic_view_type [BS] %hu != %hu", view->orthographic_view_type, orthographic_view_type);
    orthographic_view_type++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "orthographic_view_type", &orthographic_view_type, 0)
        && orthographic_view_type == view->orthographic_view_type)
      pass ();
    else
      fail ("VIEW.orthographic_view_type [BS] set+1 %hu != %hu", view->orthographic_view_type, orthographic_view_type);
    view->orthographic_view_type--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (view, "VIEW", "parent", &parent, NULL)
        && !memcmp (&parent, &view->parent, sizeof (view->parent)))
        pass ();
    else
        fail ("VIEW.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B pspace_flag;
    if (dwg_dynapi_entity_value (view, "VIEW", "pspace_flag", &pspace_flag, NULL)
        && pspace_flag == view->pspace_flag)
      pass ();
    else
      fail ("VIEW.pspace_flag [B] " FORMAT_B " != " FORMAT_B "", view->pspace_flag, pspace_flag);
    pspace_flag++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "pspace_flag", &pspace_flag, 0)
        && pspace_flag == view->pspace_flag)
      pass ();
    else
      fail ("VIEW.pspace_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", view->pspace_flag, pspace_flag);
    view->pspace_flag--;
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value (view, "VIEW", "render_mode", &render_mode, NULL)
        && render_mode == view->render_mode)
      pass ();
    else
      fail ("VIEW.render_mode [RC] %u != %u", view->render_mode, render_mode);
    render_mode++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "render_mode", &render_mode, 0)
        && render_mode == view->render_mode)
      pass ();
    else
      fail ("VIEW.render_mode [RC] set+1 %u != %u", view->render_mode, render_mode);
    view->render_mode--;
  }
  {
    BITCODE_H sun;
    if (dwg_dynapi_entity_value (view, "VIEW", "sun", &sun, NULL)
        && !memcmp (&sun, &view->sun, sizeof (view->sun)))
        pass ();
    else
        fail ("VIEW.sun [H]");
  }
  {
    BITCODE_3BD target;
    if (dwg_dynapi_entity_value (view, "VIEW", "target", &target, NULL)
        && !memcmp (&target, &view->target, sizeof (view->target)))
        pass ();
    else
        fail ("VIEW.target [3BD]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (view, "VIEW", "twist_angle", &twist_angle, NULL)
        && twist_angle == view->twist_angle)
      pass ();
    else
      fail ("VIEW.twist_angle [BD] %g != %g", view->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "twist_angle", &twist_angle, 0)
        && twist_angle == view->twist_angle)
      pass ();
    else
      fail ("VIEW.twist_angle [BD] set+1 %g != %g", view->twist_angle, twist_angle);
    view->twist_angle--;
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value (view, "VIEW", "use_default_lights", &use_default_lights, NULL)
        && use_default_lights == view->use_default_lights)
      pass ();
    else
      fail ("VIEW.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", view->use_default_lights, use_default_lights);
    use_default_lights++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "use_default_lights", &use_default_lights, 0)
        && use_default_lights == view->use_default_lights)
      pass ();
    else
      fail ("VIEW.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", view->use_default_lights, use_default_lights);
    view->use_default_lights--;
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (view, "VIEW", "used", &used, NULL)
        && used == view->used)
      pass ();
    else
      fail ("VIEW.used [RS] %hu != %hu", view->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "used", &used, 0)
        && used == view->used)
      pass ();
    else
      fail ("VIEW.used [RS] set+1 %hu != %hu", view->used, used);
    view->used--;
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (view, "VIEW", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &view->visualstyle, sizeof (view->visualstyle)))
        pass ();
    else
        fail ("VIEW.visualstyle [H]");
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value (view, "VIEW", "width", &width, NULL)
        && width == view->width)
      pass ();
    else
      fail ("VIEW.width [BD] %g != %g", view->width, width);
    width++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "width", &width, 0)
        && width == view->width)
      pass ();
    else
      fail ("VIEW.width [BD] set+1 %g != %g", view->width, width);
    view->width--;
  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value (view, "VIEW", "x_direction", &x_direction, NULL)
        && !memcmp (&x_direction, &view->x_direction, sizeof (view->x_direction)))
        pass ();
    else
        fail ("VIEW.x_direction [3BD]");
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (view, "VIEW", "xrefdep", &xrefdep, NULL)
        && xrefdep == view->xrefdep)
      pass ();
    else
      fail ("VIEW.xrefdep [B] " FORMAT_B " != " FORMAT_B "", view->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "xrefdep", &xrefdep, 0)
        && xrefdep == view->xrefdep)
      pass ();
    else
      fail ("VIEW.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", view->xrefdep, xrefdep);
    view->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (view, "VIEW", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == view->xrefindex_plus1)
      pass ();
    else
      fail ("VIEW.xrefindex_plus1 [BS] %hu != %hu", view->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == view->xrefindex_plus1)
      pass ();
    else
      fail ("VIEW.xrefindex_plus1 [BS] set+1 %hu != %hu", view->xrefindex_plus1, xrefindex_plus1);
    view->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (view, "VIEW", "xrefref", &xrefref, NULL)
        && xrefref == view->xrefref)
      pass ();
    else
      fail ("VIEW.xrefref [B] " FORMAT_B " != " FORMAT_B "", view->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "xrefref", &xrefref, 0)
        && xrefref == view->xrefref)
      pass ();
    else
      fail ("VIEW.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", view->xrefref, xrefref);
    view->xrefref--;
  }
  {
    BITCODE_3BD y_direction;
    if (dwg_dynapi_entity_value (view, "VIEW", "y_direction", &y_direction, NULL)
        && !memcmp (&y_direction, &view->y_direction, sizeof (view->y_direction)))
        pass ();
    else
        fail ("VIEW.y_direction [3BD]");
  }
  if (failed && (is_class_unstable ("VIEW") || is_class_debugging ("VIEW")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VIEW", failed);
      failed = 0;
    }
  return failed;
}
static int test_VIEW_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VIEW_CONTROL *restrict view_control = obj->tio.object->tio.VIEW_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "entries", &entries, NULL)
        && entries == view_control->entries)
      pass ();
    else
      fail ("VIEW_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == view_control->num_entries)
      pass ();
    else
      fail ("VIEW_CONTROL.num_entries [BS] %hu != %hu", view_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (view_control, "VIEW_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == view_control->num_entries)
      pass ();
    else
      fail ("VIEW_CONTROL.num_entries [BS] set+1 %hu != %hu", view_control->num_entries, num_entries);
    view_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "objid", &objid, NULL)
        && objid == view_control->objid)
      pass ();
    else
      fail ("VIEW_CONTROL.objid [BL] %u != %u", view_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (view_control, "VIEW_CONTROL", "objid", &objid, 0)
        && objid == view_control->objid)
      pass ();
    else
      fail ("VIEW_CONTROL.objid [BL] set+1 %u != %u", view_control->objid, objid);
    view_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &view_control->parent, sizeof (view_control->parent)))
        pass ();
    else
        fail ("VIEW_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("VIEW_CONTROL") || is_class_debugging ("VIEW_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VIEW_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_VISUALSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VISUALSTYLE *restrict visualstyle = obj->tio.object->tio.VISUALSTYLE;
  failed = 0;
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "color", &color, NULL)
        && !memcmp (&color, &visualstyle->color, sizeof (visualstyle->color)))
        pass ();
    else
        fail ("VISUALSTYLE.color [CMC]");
  }
  {
    BITCODE_BS color_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "color_ext", &color_ext, NULL)
        && color_ext == visualstyle->color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.color_ext [BS] %hu != %hu", visualstyle->color_ext, color_ext);
    color_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "color_ext", &color_ext, 0)
        && color_ext == visualstyle->color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.color_ext [BS] set+1 %hu != %hu", visualstyle->color_ext, color_ext);
    visualstyle->color_ext--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)visualstyle->description)
           : !visualstyle->description)
      pass ();
    else
      fail ("VISUALSTYLE.description [T] '%s' <> '%s'", description, visualstyle->description);
  }
  {
    BITCODE_BD display_brightness;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_brightness", &display_brightness, NULL)
        && display_brightness == visualstyle->display_brightness)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness [BD] %g != %g", visualstyle->display_brightness, display_brightness);
    display_brightness++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_brightness", &display_brightness, 0)
        && display_brightness == visualstyle->display_brightness)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness [BD] set+1 %g != %g", visualstyle->display_brightness, display_brightness);
    visualstyle->display_brightness--;
  }
  {
    BITCODE_BS display_brightness_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_brightness_ext", &display_brightness_ext, NULL)
        && display_brightness_ext == visualstyle->display_brightness_ext)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness_ext [BS] %hu != %hu", visualstyle->display_brightness_ext, display_brightness_ext);
    display_brightness_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_brightness_ext", &display_brightness_ext, 0)
        && display_brightness_ext == visualstyle->display_brightness_ext)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness_ext [BS] set+1 %hu != %hu", visualstyle->display_brightness_ext, display_brightness_ext);
    visualstyle->display_brightness_ext--;
  }
  {
    BITCODE_BS display_shadow_type;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_shadow_type", &display_shadow_type, NULL)
        && display_shadow_type == visualstyle->display_shadow_type)
      pass ();
    else
      fail ("VISUALSTYLE.display_shadow_type [BS] %hu != %hu", visualstyle->display_shadow_type, display_shadow_type);
    display_shadow_type++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_shadow_type", &display_shadow_type, 0)
        && display_shadow_type == visualstyle->display_shadow_type)
      pass ();
    else
      fail ("VISUALSTYLE.display_shadow_type [BS] set+1 %hu != %hu", visualstyle->display_shadow_type, display_shadow_type);
    visualstyle->display_shadow_type--;
  }
  {
    BITCODE_BS display_shadow_type_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_shadow_type_ext", &display_shadow_type_ext, NULL)
        && display_shadow_type_ext == visualstyle->display_shadow_type_ext)
      pass ();
    else
      fail ("VISUALSTYLE.display_shadow_type_ext [BS] %hu != %hu", visualstyle->display_shadow_type_ext, display_shadow_type_ext);
    display_shadow_type_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_shadow_type_ext", &display_shadow_type_ext, 0)
        && display_shadow_type_ext == visualstyle->display_shadow_type_ext)
      pass ();
    else
      fail ("VISUALSTYLE.display_shadow_type_ext [BS] set+1 %hu != %hu", visualstyle->display_shadow_type_ext, display_shadow_type_ext);
    visualstyle->display_shadow_type_ext--;
  }
  {
    BITCODE_BS display_style;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_style", &display_style, NULL)
        && display_style == visualstyle->display_style)
      pass ();
    else
      fail ("VISUALSTYLE.display_style [BS] %hu != %hu", visualstyle->display_style, display_style);
    display_style++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_style", &display_style, 0)
        && display_style == visualstyle->display_style)
      pass ();
    else
      fail ("VISUALSTYLE.display_style [BS] set+1 %hu != %hu", visualstyle->display_style, display_style);
    visualstyle->display_style--;
  }
  {
    BITCODE_BS display_style_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_style_ext", &display_style_ext, NULL)
        && display_style_ext == visualstyle->display_style_ext)
      pass ();
    else
      fail ("VISUALSTYLE.display_style_ext [BS] %hu != %hu", visualstyle->display_style_ext, display_style_ext);
    display_style_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_style_ext", &display_style_ext, 0)
        && display_style_ext == visualstyle->display_style_ext)
      pass ();
    else
      fail ("VISUALSTYLE.display_style_ext [BS] set+1 %hu != %hu", visualstyle->display_style_ext, display_style_ext);
    visualstyle->display_style_ext--;
  }
  {
    BITCODE_CMC edge_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_color", &edge_color, NULL)
        && !memcmp (&edge_color, &visualstyle->edge_color, sizeof (visualstyle->edge_color)))
        pass ();
    else
        fail ("VISUALSTYLE.edge_color [CMC]");
  }
  {
    BITCODE_BS edge_color_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_color_ext", &edge_color_ext, NULL)
        && edge_color_ext == visualstyle->edge_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_color_ext [BS] %hu != %hu", visualstyle->edge_color_ext, edge_color_ext);
    edge_color_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_color_ext", &edge_color_ext, 0)
        && edge_color_ext == visualstyle->edge_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_color_ext [BS] set+1 %hu != %hu", visualstyle->edge_color_ext, edge_color_ext);
    visualstyle->edge_color_ext--;
  }
  {
    BITCODE_BD edge_crease_angle;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_crease_angle", &edge_crease_angle, NULL)
        && edge_crease_angle == visualstyle->edge_crease_angle)
      pass ();
    else
      fail ("VISUALSTYLE.edge_crease_angle [BD] %g != %g", visualstyle->edge_crease_angle, edge_crease_angle);
    edge_crease_angle++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_crease_angle", &edge_crease_angle, 0)
        && edge_crease_angle == visualstyle->edge_crease_angle)
      pass ();
    else
      fail ("VISUALSTYLE.edge_crease_angle [BD] set+1 %g != %g", visualstyle->edge_crease_angle, edge_crease_angle);
    visualstyle->edge_crease_angle--;
  }
  {
    BITCODE_BS edge_crease_angle_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_crease_angle_ext", &edge_crease_angle_ext, NULL)
        && edge_crease_angle_ext == visualstyle->edge_crease_angle_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_crease_angle_ext [BS] %hu != %hu", visualstyle->edge_crease_angle_ext, edge_crease_angle_ext);
    edge_crease_angle_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_crease_angle_ext", &edge_crease_angle_ext, 0)
        && edge_crease_angle_ext == visualstyle->edge_crease_angle_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_crease_angle_ext [BS] set+1 %hu != %hu", visualstyle->edge_crease_angle_ext, edge_crease_angle_ext);
    visualstyle->edge_crease_angle_ext--;
  }
  {
    BITCODE_BS edge_halo_gap;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_halo_gap", &edge_halo_gap, NULL)
        && edge_halo_gap == visualstyle->edge_halo_gap)
      pass ();
    else
      fail ("VISUALSTYLE.edge_halo_gap [BS] %hu != %hu", visualstyle->edge_halo_gap, edge_halo_gap);
    edge_halo_gap++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_halo_gap", &edge_halo_gap, 0)
        && edge_halo_gap == visualstyle->edge_halo_gap)
      pass ();
    else
      fail ("VISUALSTYLE.edge_halo_gap [BS] set+1 %hu != %hu", visualstyle->edge_halo_gap, edge_halo_gap);
    visualstyle->edge_halo_gap--;
  }
  {
    BITCODE_BS edge_halo_gap_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_halo_gap_ext", &edge_halo_gap_ext, NULL)
        && edge_halo_gap_ext == visualstyle->edge_halo_gap_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_halo_gap_ext [BS] %hu != %hu", visualstyle->edge_halo_gap_ext, edge_halo_gap_ext);
    edge_halo_gap_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_halo_gap_ext", &edge_halo_gap_ext, 0)
        && edge_halo_gap_ext == visualstyle->edge_halo_gap_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_halo_gap_ext [BS] set+1 %hu != %hu", visualstyle->edge_halo_gap_ext, edge_halo_gap_ext);
    visualstyle->edge_halo_gap_ext--;
  }
  {
    BITCODE_B edge_hide_precision_flag;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_hide_precision_flag", &edge_hide_precision_flag, NULL)
        && edge_hide_precision_flag == visualstyle->edge_hide_precision_flag)
      pass ();
    else
      fail ("VISUALSTYLE.edge_hide_precision_flag [B] " FORMAT_B " != " FORMAT_B "", visualstyle->edge_hide_precision_flag, edge_hide_precision_flag);
    edge_hide_precision_flag++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_hide_precision_flag", &edge_hide_precision_flag, 0)
        && edge_hide_precision_flag == visualstyle->edge_hide_precision_flag)
      pass ();
    else
      fail ("VISUALSTYLE.edge_hide_precision_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->edge_hide_precision_flag, edge_hide_precision_flag);
    visualstyle->edge_hide_precision_flag--;
  }
  {
    BITCODE_BS edge_hide_precision_flag_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_hide_precision_flag_ext", &edge_hide_precision_flag_ext, NULL)
        && edge_hide_precision_flag_ext == visualstyle->edge_hide_precision_flag_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_hide_precision_flag_ext [BS] %hu != %hu", visualstyle->edge_hide_precision_flag_ext, edge_hide_precision_flag_ext);
    edge_hide_precision_flag_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_hide_precision_flag_ext", &edge_hide_precision_flag_ext, 0)
        && edge_hide_precision_flag_ext == visualstyle->edge_hide_precision_flag_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_hide_precision_flag_ext [BS] set+1 %hu != %hu", visualstyle->edge_hide_precision_flag_ext, edge_hide_precision_flag_ext);
    visualstyle->edge_hide_precision_flag_ext--;
  }
  {
    BITCODE_CMC edge_intersection_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_intersection_color", &edge_intersection_color, NULL)
        && !memcmp (&edge_intersection_color, &visualstyle->edge_intersection_color, sizeof (visualstyle->edge_intersection_color)))
        pass ();
    else
        fail ("VISUALSTYLE.edge_intersection_color [CMC]");
  }
  {
    BITCODE_BS edge_intersection_color_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_intersection_color_ext", &edge_intersection_color_ext, NULL)
        && edge_intersection_color_ext == visualstyle->edge_intersection_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_color_ext [BS] %hu != %hu", visualstyle->edge_intersection_color_ext, edge_intersection_color_ext);
    edge_intersection_color_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_intersection_color_ext", &edge_intersection_color_ext, 0)
        && edge_intersection_color_ext == visualstyle->edge_intersection_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_color_ext [BS] set+1 %hu != %hu", visualstyle->edge_intersection_color_ext, edge_intersection_color_ext);
    visualstyle->edge_intersection_color_ext--;
  }
  {
    BITCODE_BS edge_intersection_line_pattern;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_intersection_line_pattern", &edge_intersection_line_pattern, NULL)
        && edge_intersection_line_pattern == visualstyle->edge_intersection_line_pattern)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_line_pattern [BS] %hu != %hu", visualstyle->edge_intersection_line_pattern, edge_intersection_line_pattern);
    edge_intersection_line_pattern++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_intersection_line_pattern", &edge_intersection_line_pattern, 0)
        && edge_intersection_line_pattern == visualstyle->edge_intersection_line_pattern)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_line_pattern [BS] set+1 %hu != %hu", visualstyle->edge_intersection_line_pattern, edge_intersection_line_pattern);
    visualstyle->edge_intersection_line_pattern--;
  }
  {
    BITCODE_BS edge_intersection_line_pattern_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_intersection_line_pattern_ext", &edge_intersection_line_pattern_ext, NULL)
        && edge_intersection_line_pattern_ext == visualstyle->edge_intersection_line_pattern_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_line_pattern_ext [BS] %hu != %hu", visualstyle->edge_intersection_line_pattern_ext, edge_intersection_line_pattern_ext);
    edge_intersection_line_pattern_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_intersection_line_pattern_ext", &edge_intersection_line_pattern_ext, 0)
        && edge_intersection_line_pattern_ext == visualstyle->edge_intersection_line_pattern_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_line_pattern_ext [BS] set+1 %hu != %hu", visualstyle->edge_intersection_line_pattern_ext, edge_intersection_line_pattern_ext);
    visualstyle->edge_intersection_line_pattern_ext--;
  }
  {
    BITCODE_BS edge_jitter;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_jitter", &edge_jitter, NULL)
        && edge_jitter == visualstyle->edge_jitter)
      pass ();
    else
      fail ("VISUALSTYLE.edge_jitter [BS] %hu != %hu", visualstyle->edge_jitter, edge_jitter);
    edge_jitter++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_jitter", &edge_jitter, 0)
        && edge_jitter == visualstyle->edge_jitter)
      pass ();
    else
      fail ("VISUALSTYLE.edge_jitter [BS] set+1 %hu != %hu", visualstyle->edge_jitter, edge_jitter);
    visualstyle->edge_jitter--;
  }
  {
    BITCODE_BS edge_jitter_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_jitter_ext", &edge_jitter_ext, NULL)
        && edge_jitter_ext == visualstyle->edge_jitter_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_jitter_ext [BS] %hu != %hu", visualstyle->edge_jitter_ext, edge_jitter_ext);
    edge_jitter_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_jitter_ext", &edge_jitter_ext, 0)
        && edge_jitter_ext == visualstyle->edge_jitter_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_jitter_ext [BS] set+1 %hu != %hu", visualstyle->edge_jitter_ext, edge_jitter_ext);
    visualstyle->edge_jitter_ext--;
  }
  {
    BITCODE_BS edge_model;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_model", &edge_model, NULL)
        && edge_model == visualstyle->edge_model)
      pass ();
    else
      fail ("VISUALSTYLE.edge_model [BS] %hu != %hu", visualstyle->edge_model, edge_model);
    edge_model++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_model", &edge_model, 0)
        && edge_model == visualstyle->edge_model)
      pass ();
    else
      fail ("VISUALSTYLE.edge_model [BS] set+1 %hu != %hu", visualstyle->edge_model, edge_model);
    visualstyle->edge_model--;
  }
  {
    BITCODE_BS edge_model_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_model_ext", &edge_model_ext, NULL)
        && edge_model_ext == visualstyle->edge_model_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_model_ext [BS] %hu != %hu", visualstyle->edge_model_ext, edge_model_ext);
    edge_model_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_model_ext", &edge_model_ext, 0)
        && edge_model_ext == visualstyle->edge_model_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_model_ext [BS] set+1 %hu != %hu", visualstyle->edge_model_ext, edge_model_ext);
    visualstyle->edge_model_ext--;
  }
  {
    BITCODE_BS edge_modifier;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_modifier", &edge_modifier, NULL)
        && edge_modifier == visualstyle->edge_modifier)
      pass ();
    else
      fail ("VISUALSTYLE.edge_modifier [BS] %hu != %hu", visualstyle->edge_modifier, edge_modifier);
    edge_modifier++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_modifier", &edge_modifier, 0)
        && edge_modifier == visualstyle->edge_modifier)
      pass ();
    else
      fail ("VISUALSTYLE.edge_modifier [BS] set+1 %hu != %hu", visualstyle->edge_modifier, edge_modifier);
    visualstyle->edge_modifier--;
  }
  {
    BITCODE_BS edge_modifier_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_modifier_ext", &edge_modifier_ext, NULL)
        && edge_modifier_ext == visualstyle->edge_modifier_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_modifier_ext [BS] %hu != %hu", visualstyle->edge_modifier_ext, edge_modifier_ext);
    edge_modifier_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_modifier_ext", &edge_modifier_ext, 0)
        && edge_modifier_ext == visualstyle->edge_modifier_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_modifier_ext [BS] set+1 %hu != %hu", visualstyle->edge_modifier_ext, edge_modifier_ext);
    visualstyle->edge_modifier_ext--;
  }
  {
    BITCODE_CMC edge_obscured_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_obscured_color", &edge_obscured_color, NULL)
        && !memcmp (&edge_obscured_color, &visualstyle->edge_obscured_color, sizeof (visualstyle->edge_obscured_color)))
        pass ();
    else
        fail ("VISUALSTYLE.edge_obscured_color [CMC]");
  }
  {
    BITCODE_BS edge_obscured_color_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_obscured_color_ext", &edge_obscured_color_ext, NULL)
        && edge_obscured_color_ext == visualstyle->edge_obscured_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_color_ext [BS] %hu != %hu", visualstyle->edge_obscured_color_ext, edge_obscured_color_ext);
    edge_obscured_color_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_obscured_color_ext", &edge_obscured_color_ext, 0)
        && edge_obscured_color_ext == visualstyle->edge_obscured_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_color_ext [BS] set+1 %hu != %hu", visualstyle->edge_obscured_color_ext, edge_obscured_color_ext);
    visualstyle->edge_obscured_color_ext--;
  }
  {
    BITCODE_BS edge_obscured_line_pattern;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_obscured_line_pattern", &edge_obscured_line_pattern, NULL)
        && edge_obscured_line_pattern == visualstyle->edge_obscured_line_pattern)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_line_pattern [BS] %hu != %hu", visualstyle->edge_obscured_line_pattern, edge_obscured_line_pattern);
    edge_obscured_line_pattern++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_obscured_line_pattern", &edge_obscured_line_pattern, 0)
        && edge_obscured_line_pattern == visualstyle->edge_obscured_line_pattern)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_line_pattern [BS] set+1 %hu != %hu", visualstyle->edge_obscured_line_pattern, edge_obscured_line_pattern);
    visualstyle->edge_obscured_line_pattern--;
  }
  {
    BITCODE_BS edge_obscured_line_pattern_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_obscured_line_pattern_ext", &edge_obscured_line_pattern_ext, NULL)
        && edge_obscured_line_pattern_ext == visualstyle->edge_obscured_line_pattern_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_line_pattern_ext [BS] %hu != %hu", visualstyle->edge_obscured_line_pattern_ext, edge_obscured_line_pattern_ext);
    edge_obscured_line_pattern_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_obscured_line_pattern_ext", &edge_obscured_line_pattern_ext, 0)
        && edge_obscured_line_pattern_ext == visualstyle->edge_obscured_line_pattern_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_line_pattern_ext [BS] set+1 %hu != %hu", visualstyle->edge_obscured_line_pattern_ext, edge_obscured_line_pattern_ext);
    visualstyle->edge_obscured_line_pattern_ext--;
  }
  {
    BITCODE_BD edge_opacity;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_opacity", &edge_opacity, NULL)
        && edge_opacity == visualstyle->edge_opacity)
      pass ();
    else
      fail ("VISUALSTYLE.edge_opacity [BD] %g != %g", visualstyle->edge_opacity, edge_opacity);
    edge_opacity++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_opacity", &edge_opacity, 0)
        && edge_opacity == visualstyle->edge_opacity)
      pass ();
    else
      fail ("VISUALSTYLE.edge_opacity [BD] set+1 %g != %g", visualstyle->edge_opacity, edge_opacity);
    visualstyle->edge_opacity--;
  }
  {
    BITCODE_BS edge_opacity_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_opacity_ext", &edge_opacity_ext, NULL)
        && edge_opacity_ext == visualstyle->edge_opacity_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_opacity_ext [BS] %hu != %hu", visualstyle->edge_opacity_ext, edge_opacity_ext);
    edge_opacity_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_opacity_ext", &edge_opacity_ext, 0)
        && edge_opacity_ext == visualstyle->edge_opacity_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_opacity_ext [BS] set+1 %hu != %hu", visualstyle->edge_opacity_ext, edge_opacity_ext);
    visualstyle->edge_opacity_ext--;
  }
  {
    BITCODE_BS edge_overhang;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_overhang", &edge_overhang, NULL)
        && edge_overhang == visualstyle->edge_overhang)
      pass ();
    else
      fail ("VISUALSTYLE.edge_overhang [BS] %hu != %hu", visualstyle->edge_overhang, edge_overhang);
    edge_overhang++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_overhang", &edge_overhang, 0)
        && edge_overhang == visualstyle->edge_overhang)
      pass ();
    else
      fail ("VISUALSTYLE.edge_overhang [BS] set+1 %hu != %hu", visualstyle->edge_overhang, edge_overhang);
    visualstyle->edge_overhang--;
  }
  {
    BITCODE_BS edge_overhang_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_overhang_ext", &edge_overhang_ext, NULL)
        && edge_overhang_ext == visualstyle->edge_overhang_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_overhang_ext [BS] %hu != %hu", visualstyle->edge_overhang_ext, edge_overhang_ext);
    edge_overhang_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_overhang_ext", &edge_overhang_ext, 0)
        && edge_overhang_ext == visualstyle->edge_overhang_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_overhang_ext [BS] set+1 %hu != %hu", visualstyle->edge_overhang_ext, edge_overhang_ext);
    visualstyle->edge_overhang_ext--;
  }
  {
    BITCODE_CMC edge_silhouette_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_silhouette_color", &edge_silhouette_color, NULL)
        && !memcmp (&edge_silhouette_color, &visualstyle->edge_silhouette_color, sizeof (visualstyle->edge_silhouette_color)))
        pass ();
    else
        fail ("VISUALSTYLE.edge_silhouette_color [CMC]");
  }
  {
    BITCODE_BS edge_silhouette_color_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_silhouette_color_ext", &edge_silhouette_color_ext, NULL)
        && edge_silhouette_color_ext == visualstyle->edge_silhouette_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_color_ext [BS] %hu != %hu", visualstyle->edge_silhouette_color_ext, edge_silhouette_color_ext);
    edge_silhouette_color_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_silhouette_color_ext", &edge_silhouette_color_ext, 0)
        && edge_silhouette_color_ext == visualstyle->edge_silhouette_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_color_ext [BS] set+1 %hu != %hu", visualstyle->edge_silhouette_color_ext, edge_silhouette_color_ext);
    visualstyle->edge_silhouette_color_ext--;
  }
  {
    BITCODE_BS edge_silhouette_width;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_silhouette_width", &edge_silhouette_width, NULL)
        && edge_silhouette_width == visualstyle->edge_silhouette_width)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_width [BS] %hu != %hu", visualstyle->edge_silhouette_width, edge_silhouette_width);
    edge_silhouette_width++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_silhouette_width", &edge_silhouette_width, 0)
        && edge_silhouette_width == visualstyle->edge_silhouette_width)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_width [BS] set+1 %hu != %hu", visualstyle->edge_silhouette_width, edge_silhouette_width);
    visualstyle->edge_silhouette_width--;
  }
  {
    BITCODE_BS edge_silhouette_width_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_silhouette_width_ext", &edge_silhouette_width_ext, NULL)
        && edge_silhouette_width_ext == visualstyle->edge_silhouette_width_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_width_ext [BS] %hu != %hu", visualstyle->edge_silhouette_width_ext, edge_silhouette_width_ext);
    edge_silhouette_width_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_silhouette_width_ext", &edge_silhouette_width_ext, 0)
        && edge_silhouette_width_ext == visualstyle->edge_silhouette_width_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_width_ext [BS] set+1 %hu != %hu", visualstyle->edge_silhouette_width_ext, edge_silhouette_width_ext);
    visualstyle->edge_silhouette_width_ext--;
  }
  {
    BITCODE_BL edge_style;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_style", &edge_style, NULL)
        && edge_style == visualstyle->edge_style)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style [BL] %u != %u", visualstyle->edge_style, edge_style);
    edge_style++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_style", &edge_style, 0)
        && edge_style == visualstyle->edge_style)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style [BL] set+1 %u != %u", visualstyle->edge_style, edge_style);
    visualstyle->edge_style--;
  }
  {
    BITCODE_BS edge_style_apply_flag;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_style_apply_flag", &edge_style_apply_flag, NULL)
        && edge_style_apply_flag == visualstyle->edge_style_apply_flag)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_apply_flag [BS] %hu != %hu", visualstyle->edge_style_apply_flag, edge_style_apply_flag);
    edge_style_apply_flag++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_style_apply_flag", &edge_style_apply_flag, 0)
        && edge_style_apply_flag == visualstyle->edge_style_apply_flag)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_apply_flag [BS] set+1 %hu != %hu", visualstyle->edge_style_apply_flag, edge_style_apply_flag);
    visualstyle->edge_style_apply_flag--;
  }
  {
    BITCODE_BS edge_style_apply_flag_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_style_apply_flag_ext", &edge_style_apply_flag_ext, NULL)
        && edge_style_apply_flag_ext == visualstyle->edge_style_apply_flag_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_apply_flag_ext [BS] %hu != %hu", visualstyle->edge_style_apply_flag_ext, edge_style_apply_flag_ext);
    edge_style_apply_flag_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_style_apply_flag_ext", &edge_style_apply_flag_ext, 0)
        && edge_style_apply_flag_ext == visualstyle->edge_style_apply_flag_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_apply_flag_ext [BS] set+1 %hu != %hu", visualstyle->edge_style_apply_flag_ext, edge_style_apply_flag_ext);
    visualstyle->edge_style_apply_flag_ext--;
  }
  {
    BITCODE_BS edge_style_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_style_ext", &edge_style_ext, NULL)
        && edge_style_ext == visualstyle->edge_style_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_ext [BS] %hu != %hu", visualstyle->edge_style_ext, edge_style_ext);
    edge_style_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_style_ext", &edge_style_ext, 0)
        && edge_style_ext == visualstyle->edge_style_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_ext [BS] set+1 %hu != %hu", visualstyle->edge_style_ext, edge_style_ext);
    visualstyle->edge_style_ext--;
  }
  {
    BITCODE_BS edge_width;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_width", &edge_width, NULL)
        && edge_width == visualstyle->edge_width)
      pass ();
    else
      fail ("VISUALSTYLE.edge_width [BS] %hu != %hu", visualstyle->edge_width, edge_width);
    edge_width++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_width", &edge_width, 0)
        && edge_width == visualstyle->edge_width)
      pass ();
    else
      fail ("VISUALSTYLE.edge_width [BS] set+1 %hu != %hu", visualstyle->edge_width, edge_width);
    visualstyle->edge_width--;
  }
  {
    BITCODE_BS edge_width_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_width_ext", &edge_width_ext, NULL)
        && edge_width_ext == visualstyle->edge_width_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_width_ext [BS] %hu != %hu", visualstyle->edge_width_ext, edge_width_ext);
    edge_width_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_width_ext", &edge_width_ext, 0)
        && edge_width_ext == visualstyle->edge_width_ext)
      pass ();
    else
      fail ("VISUALSTYLE.edge_width_ext [BS] set+1 %hu != %hu", visualstyle->edge_width_ext, edge_width_ext);
    visualstyle->edge_width_ext--;
  }
  {
    BITCODE_BS ext_lighting_model;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "ext_lighting_model", &ext_lighting_model, NULL)
        && ext_lighting_model == visualstyle->ext_lighting_model)
      pass ();
    else
      fail ("VISUALSTYLE.ext_lighting_model [BS] %hu != %hu", visualstyle->ext_lighting_model, ext_lighting_model);
    ext_lighting_model++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "ext_lighting_model", &ext_lighting_model, 0)
        && ext_lighting_model == visualstyle->ext_lighting_model)
      pass ();
    else
      fail ("VISUALSTYLE.ext_lighting_model [BS] set+1 %hu != %hu", visualstyle->ext_lighting_model, ext_lighting_model);
    visualstyle->ext_lighting_model--;
  }
  {
    BITCODE_BS face_color_mode;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_color_mode", &face_color_mode, NULL)
        && face_color_mode == visualstyle->face_color_mode)
      pass ();
    else
      fail ("VISUALSTYLE.face_color_mode [BS] %hu != %hu", visualstyle->face_color_mode, face_color_mode);
    face_color_mode++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_color_mode", &face_color_mode, 0)
        && face_color_mode == visualstyle->face_color_mode)
      pass ();
    else
      fail ("VISUALSTYLE.face_color_mode [BS] set+1 %hu != %hu", visualstyle->face_color_mode, face_color_mode);
    visualstyle->face_color_mode--;
  }
  {
    BITCODE_BS face_color_mode_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_color_mode_ext", &face_color_mode_ext, NULL)
        && face_color_mode_ext == visualstyle->face_color_mode_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_color_mode_ext [BS] %hu != %hu", visualstyle->face_color_mode_ext, face_color_mode_ext);
    face_color_mode_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_color_mode_ext", &face_color_mode_ext, 0)
        && face_color_mode_ext == visualstyle->face_color_mode_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_color_mode_ext [BS] set+1 %hu != %hu", visualstyle->face_color_mode_ext, face_color_mode_ext);
    visualstyle->face_color_mode_ext--;
  }
  {
    BITCODE_BS face_lighting_model;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_lighting_model", &face_lighting_model, NULL)
        && face_lighting_model == visualstyle->face_lighting_model)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_model [BS] %hu != %hu", visualstyle->face_lighting_model, face_lighting_model);
    face_lighting_model++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_lighting_model", &face_lighting_model, 0)
        && face_lighting_model == visualstyle->face_lighting_model)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_model [BS] set+1 %hu != %hu", visualstyle->face_lighting_model, face_lighting_model);
    visualstyle->face_lighting_model--;
  }
  {
    BITCODE_BS face_lighting_model_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_lighting_model_ext", &face_lighting_model_ext, NULL)
        && face_lighting_model_ext == visualstyle->face_lighting_model_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_model_ext [BS] %hu != %hu", visualstyle->face_lighting_model_ext, face_lighting_model_ext);
    face_lighting_model_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_lighting_model_ext", &face_lighting_model_ext, 0)
        && face_lighting_model_ext == visualstyle->face_lighting_model_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_model_ext [BS] set+1 %hu != %hu", visualstyle->face_lighting_model_ext, face_lighting_model_ext);
    visualstyle->face_lighting_model_ext--;
  }
  {
    BITCODE_BS face_lighting_quality;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_lighting_quality", &face_lighting_quality, NULL)
        && face_lighting_quality == visualstyle->face_lighting_quality)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_quality [BS] %hu != %hu", visualstyle->face_lighting_quality, face_lighting_quality);
    face_lighting_quality++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_lighting_quality", &face_lighting_quality, 0)
        && face_lighting_quality == visualstyle->face_lighting_quality)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_quality [BS] set+1 %hu != %hu", visualstyle->face_lighting_quality, face_lighting_quality);
    visualstyle->face_lighting_quality--;
  }
  {
    BITCODE_BS face_lighting_quality_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_lighting_quality_ext", &face_lighting_quality_ext, NULL)
        && face_lighting_quality_ext == visualstyle->face_lighting_quality_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_quality_ext [BS] %hu != %hu", visualstyle->face_lighting_quality_ext, face_lighting_quality_ext);
    face_lighting_quality_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_lighting_quality_ext", &face_lighting_quality_ext, 0)
        && face_lighting_quality_ext == visualstyle->face_lighting_quality_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_quality_ext [BS] set+1 %hu != %hu", visualstyle->face_lighting_quality_ext, face_lighting_quality_ext);
    visualstyle->face_lighting_quality_ext--;
  }
  {
    BITCODE_BS face_modifier;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_modifier", &face_modifier, NULL)
        && face_modifier == visualstyle->face_modifier)
      pass ();
    else
      fail ("VISUALSTYLE.face_modifier [BS] %hu != %hu", visualstyle->face_modifier, face_modifier);
    face_modifier++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_modifier", &face_modifier, 0)
        && face_modifier == visualstyle->face_modifier)
      pass ();
    else
      fail ("VISUALSTYLE.face_modifier [BS] set+1 %hu != %hu", visualstyle->face_modifier, face_modifier);
    visualstyle->face_modifier--;
  }
  {
    BITCODE_BS face_modifier_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_modifier_ext", &face_modifier_ext, NULL)
        && face_modifier_ext == visualstyle->face_modifier_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_modifier_ext [BS] %hu != %hu", visualstyle->face_modifier_ext, face_modifier_ext);
    face_modifier_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_modifier_ext", &face_modifier_ext, 0)
        && face_modifier_ext == visualstyle->face_modifier_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_modifier_ext [BS] set+1 %hu != %hu", visualstyle->face_modifier_ext, face_modifier_ext);
    visualstyle->face_modifier_ext--;
  }
  {
    BITCODE_CMC face_mono_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_mono_color", &face_mono_color, NULL)
        && !memcmp (&face_mono_color, &visualstyle->face_mono_color, sizeof (visualstyle->face_mono_color)))
        pass ();
    else
        fail ("VISUALSTYLE.face_mono_color [CMC]");
  }
  {
    BITCODE_BS face_mono_color_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_mono_color_ext", &face_mono_color_ext, NULL)
        && face_mono_color_ext == visualstyle->face_mono_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_mono_color_ext [BS] %hu != %hu", visualstyle->face_mono_color_ext, face_mono_color_ext);
    face_mono_color_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_mono_color_ext", &face_mono_color_ext, 0)
        && face_mono_color_ext == visualstyle->face_mono_color_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_mono_color_ext [BS] set+1 %hu != %hu", visualstyle->face_mono_color_ext, face_mono_color_ext);
    visualstyle->face_mono_color_ext--;
  }
  {
    BITCODE_BD face_opacity;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_opacity", &face_opacity, NULL)
        && face_opacity == visualstyle->face_opacity)
      pass ();
    else
      fail ("VISUALSTYLE.face_opacity [BD] %g != %g", visualstyle->face_opacity, face_opacity);
    face_opacity++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_opacity", &face_opacity, 0)
        && face_opacity == visualstyle->face_opacity)
      pass ();
    else
      fail ("VISUALSTYLE.face_opacity [BD] set+1 %g != %g", visualstyle->face_opacity, face_opacity);
    visualstyle->face_opacity--;
  }
  {
    BITCODE_BS face_opacity_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_opacity_ext", &face_opacity_ext, NULL)
        && face_opacity_ext == visualstyle->face_opacity_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_opacity_ext [BS] %hu != %hu", visualstyle->face_opacity_ext, face_opacity_ext);
    face_opacity_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_opacity_ext", &face_opacity_ext, 0)
        && face_opacity_ext == visualstyle->face_opacity_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_opacity_ext [BS] set+1 %hu != %hu", visualstyle->face_opacity_ext, face_opacity_ext);
    visualstyle->face_opacity_ext--;
  }
  {
    BITCODE_BD face_specular;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_specular", &face_specular, NULL)
        && face_specular == visualstyle->face_specular)
      pass ();
    else
      fail ("VISUALSTYLE.face_specular [BD] %g != %g", visualstyle->face_specular, face_specular);
    face_specular++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_specular", &face_specular, 0)
        && face_specular == visualstyle->face_specular)
      pass ();
    else
      fail ("VISUALSTYLE.face_specular [BD] set+1 %g != %g", visualstyle->face_specular, face_specular);
    visualstyle->face_specular--;
  }
  {
    BITCODE_BS face_specular_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_specular_ext", &face_specular_ext, NULL)
        && face_specular_ext == visualstyle->face_specular_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_specular_ext [BS] %hu != %hu", visualstyle->face_specular_ext, face_specular_ext);
    face_specular_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_specular_ext", &face_specular_ext, 0)
        && face_specular_ext == visualstyle->face_specular_ext)
      pass ();
    else
      fail ("VISUALSTYLE.face_specular_ext [BS] set+1 %hu != %hu", visualstyle->face_specular_ext, face_specular_ext);
    visualstyle->face_specular_ext--;
  }
  {
    BITCODE_B has_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "has_ext", &has_ext, NULL)
        && has_ext == visualstyle->has_ext)
      pass ();
    else
      fail ("VISUALSTYLE.has_ext [B] " FORMAT_B " != " FORMAT_B "", visualstyle->has_ext, has_ext);
    has_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "has_ext", &has_ext, 0)
        && has_ext == visualstyle->has_ext)
      pass ();
    else
      fail ("VISUALSTYLE.has_ext [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->has_ext, has_ext);
    visualstyle->has_ext--;
  }
  {
    BITCODE_BS num_edge_isolines;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "num_edge_isolines", &num_edge_isolines, NULL)
        && num_edge_isolines == visualstyle->num_edge_isolines)
      pass ();
    else
      fail ("VISUALSTYLE.num_edge_isolines [BS] %hu != %hu", visualstyle->num_edge_isolines, num_edge_isolines);
    num_edge_isolines++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "num_edge_isolines", &num_edge_isolines, 0)
        && num_edge_isolines == visualstyle->num_edge_isolines)
      pass ();
    else
      fail ("VISUALSTYLE.num_edge_isolines [BS] set+1 %hu != %hu", visualstyle->num_edge_isolines, num_edge_isolines);
    visualstyle->num_edge_isolines--;
  }
  {
    BITCODE_BS num_edge_isolines_ext;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "num_edge_isolines_ext", &num_edge_isolines_ext, NULL)
        && num_edge_isolines_ext == visualstyle->num_edge_isolines_ext)
      pass ();
    else
      fail ("VISUALSTYLE.num_edge_isolines_ext [BS] %hu != %hu", visualstyle->num_edge_isolines_ext, num_edge_isolines_ext);
    num_edge_isolines_ext++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "num_edge_isolines_ext", &num_edge_isolines_ext, 0)
        && num_edge_isolines_ext == visualstyle->num_edge_isolines_ext)
      pass ();
    else
      fail ("VISUALSTYLE.num_edge_isolines_ext [BS] set+1 %hu != %hu", visualstyle->num_edge_isolines_ext, num_edge_isolines_ext);
    visualstyle->num_edge_isolines_ext--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &visualstyle->parent, sizeof (visualstyle->parent)))
        pass ();
    else
        fail ("VISUALSTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS style_type;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "style_type", &style_type, NULL)
        && style_type == visualstyle->style_type)
      pass ();
    else
      fail ("VISUALSTYLE.style_type [BS] %hu != %hu", visualstyle->style_type, style_type);
    style_type++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "style_type", &style_type, 0)
        && style_type == visualstyle->style_type)
      pass ();
    else
      fail ("VISUALSTYLE.style_type [BS] set+1 %hu != %hu", visualstyle->style_type, style_type);
    visualstyle->style_type--;
  }
  {
    BITCODE_B unknown_b;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "unknown_b", &unknown_b, NULL)
        && unknown_b == visualstyle->unknown_b)
      pass ();
    else
      fail ("VISUALSTYLE.unknown_b [B] " FORMAT_B " != " FORMAT_B "", visualstyle->unknown_b, unknown_b);
    unknown_b++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "unknown_b", &unknown_b, 0)
        && unknown_b == visualstyle->unknown_b)
      pass ();
    else
      fail ("VISUALSTYLE.unknown_b [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->unknown_b, unknown_b);
    visualstyle->unknown_b--;
  }
  {
    BITCODE_BD unknown_float45;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "unknown_float45", &unknown_float45, NULL)
        && unknown_float45 == visualstyle->unknown_float45)
      pass ();
    else
      fail ("VISUALSTYLE.unknown_float45 [BD] %g != %g", visualstyle->unknown_float45, unknown_float45);
    unknown_float45++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "unknown_float45", &unknown_float45, 0)
        && unknown_float45 == visualstyle->unknown_float45)
      pass ();
    else
      fail ("VISUALSTYLE.unknown_float45 [BD] set+1 %g != %g", visualstyle->unknown_float45, unknown_float45);
    visualstyle->unknown_float45--;
  }
  if (failed && (is_class_unstable ("VISUALSTYLE") || is_class_debugging ("VISUALSTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VISUALSTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_VPORT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VPORT *restrict vport = obj->tio.object->tio.VPORT;
  failed = 0;
  {
    BITCODE_B FASTZOOM;
    if (dwg_dynapi_entity_value (vport, "VPORT", "FASTZOOM", &FASTZOOM, NULL)
        && FASTZOOM == vport->FASTZOOM)
      pass ();
    else
      fail ("VPORT.FASTZOOM [B] " FORMAT_B " != " FORMAT_B "", vport->FASTZOOM, FASTZOOM);
    FASTZOOM++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "FASTZOOM", &FASTZOOM, 0)
        && FASTZOOM == vport->FASTZOOM)
      pass ();
    else
      fail ("VPORT.FASTZOOM [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->FASTZOOM, FASTZOOM);
    vport->FASTZOOM--;
  }
  {
    BITCODE_B GRIDMODE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "GRIDMODE", &GRIDMODE, NULL)
        && GRIDMODE == vport->GRIDMODE)
      pass ();
    else
      fail ("VPORT.GRIDMODE [B] " FORMAT_B " != " FORMAT_B "", vport->GRIDMODE, GRIDMODE);
    GRIDMODE++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "GRIDMODE", &GRIDMODE, 0)
        && GRIDMODE == vport->GRIDMODE)
      pass ();
    else
      fail ("VPORT.GRIDMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->GRIDMODE, GRIDMODE);
    vport->GRIDMODE--;
  }
  {
    BITCODE_2RD GRIDUNIT;
    if (dwg_dynapi_entity_value (vport, "VPORT", "GRIDUNIT", &GRIDUNIT, NULL)
        && !memcmp (&GRIDUNIT, &vport->GRIDUNIT, sizeof (vport->GRIDUNIT)))
        pass ();
    else
        fail ("VPORT.GRIDUNIT [2RD]");
  }
  {
    BITCODE_BD SNAPANG;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPANG", &SNAPANG, NULL)
        && SNAPANG == vport->SNAPANG)
      pass ();
    else
      fail ("VPORT.SNAPANG [BD] %g != %g", vport->SNAPANG, SNAPANG);
    SNAPANG++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "SNAPANG", &SNAPANG, 0)
        && SNAPANG == vport->SNAPANG)
      pass ();
    else
      fail ("VPORT.SNAPANG [BD] set+1 %g != %g", vport->SNAPANG, SNAPANG);
    vport->SNAPANG--;
  }
  {
    BITCODE_2RD SNAPBASE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPBASE", &SNAPBASE, NULL)
        && !memcmp (&SNAPBASE, &vport->SNAPBASE, sizeof (vport->SNAPBASE)))
        pass ();
    else
        fail ("VPORT.SNAPBASE [2RD]");
  }
  {
    BITCODE_BS SNAPISOPAIR;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPISOPAIR", &SNAPISOPAIR, NULL)
        && SNAPISOPAIR == vport->SNAPISOPAIR)
      pass ();
    else
      fail ("VPORT.SNAPISOPAIR [BS] %hu != %hu", vport->SNAPISOPAIR, SNAPISOPAIR);
    SNAPISOPAIR++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "SNAPISOPAIR", &SNAPISOPAIR, 0)
        && SNAPISOPAIR == vport->SNAPISOPAIR)
      pass ();
    else
      fail ("VPORT.SNAPISOPAIR [BS] set+1 %hu != %hu", vport->SNAPISOPAIR, SNAPISOPAIR);
    vport->SNAPISOPAIR--;
  }
  {
    BITCODE_B SNAPMODE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPMODE", &SNAPMODE, NULL)
        && SNAPMODE == vport->SNAPMODE)
      pass ();
    else
      fail ("VPORT.SNAPMODE [B] " FORMAT_B " != " FORMAT_B "", vport->SNAPMODE, SNAPMODE);
    SNAPMODE++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "SNAPMODE", &SNAPMODE, 0)
        && SNAPMODE == vport->SNAPMODE)
      pass ();
    else
      fail ("VPORT.SNAPMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->SNAPMODE, SNAPMODE);
    vport->SNAPMODE--;
  }
  {
    BITCODE_B SNAPSTYLE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPSTYLE", &SNAPSTYLE, NULL)
        && SNAPSTYLE == vport->SNAPSTYLE)
      pass ();
    else
      fail ("VPORT.SNAPSTYLE [B] " FORMAT_B " != " FORMAT_B "", vport->SNAPSTYLE, SNAPSTYLE);
    SNAPSTYLE++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "SNAPSTYLE", &SNAPSTYLE, 0)
        && SNAPSTYLE == vport->SNAPSTYLE)
      pass ();
    else
      fail ("VPORT.SNAPSTYLE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->SNAPSTYLE, SNAPSTYLE);
    vport->SNAPSTYLE--;
  }
  {
    BITCODE_2RD SNAPUNIT;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPUNIT", &SNAPUNIT, NULL)
        && !memcmp (&SNAPUNIT, &vport->SNAPUNIT, sizeof (vport->SNAPUNIT)))
        pass ();
    else
        fail ("VPORT.SNAPUNIT [2RD]");
  }
  {
    BITCODE_B UCSFOLLOW;
    if (dwg_dynapi_entity_value (vport, "VPORT", "UCSFOLLOW", &UCSFOLLOW, NULL)
        && UCSFOLLOW == vport->UCSFOLLOW)
      pass ();
    else
      fail ("VPORT.UCSFOLLOW [B] " FORMAT_B " != " FORMAT_B "", vport->UCSFOLLOW, UCSFOLLOW);
    UCSFOLLOW++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "UCSFOLLOW", &UCSFOLLOW, 0)
        && UCSFOLLOW == vport->UCSFOLLOW)
      pass ();
    else
      fail ("VPORT.UCSFOLLOW [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->UCSFOLLOW, UCSFOLLOW);
    vport->UCSFOLLOW--;
  }
  {
    BITCODE_RC UCSICON;
    if (dwg_dynapi_entity_value (vport, "VPORT", "UCSICON", &UCSICON, NULL)
        && UCSICON == vport->UCSICON)
      pass ();
    else
      fail ("VPORT.UCSICON [RC] %u != %u", vport->UCSICON, UCSICON);
    UCSICON++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "UCSICON", &UCSICON, 0)
        && UCSICON == vport->UCSICON)
      pass ();
    else
      fail ("VPORT.UCSICON [RC] set+1 %u != %u", vport->UCSICON, UCSICON);
    vport->UCSICON--;
  }
  {
    BITCODE_B UCSVP;
    if (dwg_dynapi_entity_value (vport, "VPORT", "UCSVP", &UCSVP, NULL)
        && UCSVP == vport->UCSVP)
      pass ();
    else
      fail ("VPORT.UCSVP [B] " FORMAT_B " != " FORMAT_B "", vport->UCSVP, UCSVP);
    UCSVP++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "UCSVP", &UCSVP, 0)
        && UCSVP == vport->UCSVP)
      pass ();
    else
      fail ("VPORT.UCSVP [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->UCSVP, UCSVP);
    vport->UCSVP--;
  }
  {
    BITCODE_2RD VIEWCTR;
    if (dwg_dynapi_entity_value (vport, "VPORT", "VIEWCTR", &VIEWCTR, NULL)
        && !memcmp (&VIEWCTR, &vport->VIEWCTR, sizeof (vport->VIEWCTR)))
        pass ();
    else
        fail ("VPORT.VIEWCTR [2RD]");
  }
  {
    BITCODE_3BD VIEWDIR;
    if (dwg_dynapi_entity_value (vport, "VPORT", "VIEWDIR", &VIEWDIR, NULL)
        && !memcmp (&VIEWDIR, &vport->VIEWDIR, sizeof (vport->VIEWDIR)))
        pass ();
    else
        fail ("VPORT.VIEWDIR [3BD]");
  }
  {
    BITCODE_4BITS VIEWMODE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "VIEWMODE", &VIEWMODE, NULL)
        && VIEWMODE == vport->VIEWMODE)
      pass ();
    else
      fail ("VPORT.VIEWMODE [4BITS] " FORMAT_4BITS " != " FORMAT_4BITS "", vport->VIEWMODE, VIEWMODE);
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "VIEWMODE", &VIEWMODE, 0)
        && VIEWMODE == vport->VIEWMODE)
      pass ();
    else
      fail ("VPORT.VIEWMODE [4BITS] set+1 " FORMAT_4BITS " != " FORMAT_4BITS "", vport->VIEWMODE, VIEWMODE);
    vport->VIEWMODE--;
  }
  {
    BITCODE_BD VIEWSIZE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "VIEWSIZE", &VIEWSIZE, NULL)
        && VIEWSIZE == vport->VIEWSIZE)
      pass ();
    else
      fail ("VPORT.VIEWSIZE [BD] %g != %g", vport->VIEWSIZE, VIEWSIZE);
    VIEWSIZE++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "VIEWSIZE", &VIEWSIZE, 0)
        && VIEWSIZE == vport->VIEWSIZE)
      pass ();
    else
      fail ("VPORT.VIEWSIZE [BD] set+1 %g != %g", vport->VIEWSIZE, VIEWSIZE);
    vport->VIEWSIZE--;
  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ambient_color", &ambient_color, NULL)
        && !memcmp (&ambient_color, &vport->ambient_color, sizeof (vport->ambient_color)))
        pass ();
    else
        fail ("VPORT.ambient_color [CMC]");
  }
  {
    BITCODE_BD aspect_ratio;
    if (dwg_dynapi_entity_value (vport, "VPORT", "aspect_ratio", &aspect_ratio, NULL)
        && aspect_ratio == vport->aspect_ratio)
      pass ();
    else
      fail ("VPORT.aspect_ratio [BD] %g != %g", vport->aspect_ratio, aspect_ratio);
    aspect_ratio++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "aspect_ratio", &aspect_ratio, 0)
        && aspect_ratio == vport->aspect_ratio)
      pass ();
    else
      fail ("VPORT.aspect_ratio [BD] set+1 %g != %g", vport->aspect_ratio, aspect_ratio);
    vport->aspect_ratio--;
  }
  {
    BITCODE_BD back_clip;
    if (dwg_dynapi_entity_value (vport, "VPORT", "back_clip", &back_clip, NULL)
        && back_clip == vport->back_clip)
      pass ();
    else
      fail ("VPORT.back_clip [BD] %g != %g", vport->back_clip, back_clip);
    back_clip++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "back_clip", &back_clip, 0)
        && back_clip == vport->back_clip)
      pass ();
    else
      fail ("VPORT.back_clip [BD] set+1 %g != %g", vport->back_clip, back_clip);
    vport->back_clip--;
  }
  {
    BITCODE_H background;
    if (dwg_dynapi_entity_value (vport, "VPORT", "background", &background, NULL)
        && !memcmp (&background, &vport->background, sizeof (vport->background)))
        pass ();
    else
        fail ("VPORT.background [H]");
  }
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (vport, "VPORT", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &vport->base_ucs, sizeof (vport->base_ucs)))
        pass ();
    else
        fail ("VPORT.base_ucs [H]");
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value (vport, "VPORT", "brightness", &brightness, NULL)
        && brightness == vport->brightness)
      pass ();
    else
      fail ("VPORT.brightness [BD] %g != %g", vport->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "brightness", &brightness, 0)
        && brightness == vport->brightness)
      pass ();
    else
      fail ("VPORT.brightness [BD] set+1 %g != %g", vport->brightness, brightness);
    vport->brightness--;
  }
  {
    BITCODE_BS circle_zoom;
    if (dwg_dynapi_entity_value (vport, "VPORT", "circle_zoom", &circle_zoom, NULL)
        && circle_zoom == vport->circle_zoom)
      pass ();
    else
      fail ("VPORT.circle_zoom [BS] %hu != %hu", vport->circle_zoom, circle_zoom);
    circle_zoom++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "circle_zoom", &circle_zoom, 0)
        && circle_zoom == vport->circle_zoom)
      pass ();
    else
      fail ("VPORT.circle_zoom [BS] set+1 %hu != %hu", vport->circle_zoom, circle_zoom);
    vport->circle_zoom--;
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value (vport, "VPORT", "contrast", &contrast, NULL)
        && contrast == vport->contrast)
      pass ();
    else
      fail ("VPORT.contrast [BD] %g != %g", vport->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "contrast", &contrast, 0)
        && contrast == vport->contrast)
      pass ();
    else
      fail ("VPORT.contrast [BD] set+1 %g != %g", vport->contrast, contrast);
    vport->contrast--;
  }
  {
    BITCODE_RC default_lightning_type;
    if (dwg_dynapi_entity_value (vport, "VPORT", "default_lightning_type", &default_lightning_type, NULL)
        && default_lightning_type == vport->default_lightning_type)
      pass ();
    else
      fail ("VPORT.default_lightning_type [RC] %u != %u", vport->default_lightning_type, default_lightning_type);
    default_lightning_type++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "default_lightning_type", &default_lightning_type, 0)
        && default_lightning_type == vport->default_lightning_type)
      pass ();
    else
      fail ("VPORT.default_lightning_type [RC] set+1 %u != %u", vport->default_lightning_type, default_lightning_type);
    vport->default_lightning_type--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vport, "VPORT", "flag", &flag, NULL)
        && flag == vport->flag)
      pass ();
    else
      fail ("VPORT.flag [RC] %u != %u", vport->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "flag", &flag, 0)
        && flag == vport->flag)
      pass ();
    else
      fail ("VPORT.flag [RC] set+1 %u != %u", vport->flag, flag);
    vport->flag--;
  }
  {
    BITCODE_BD front_clip;
    if (dwg_dynapi_entity_value (vport, "VPORT", "front_clip", &front_clip, NULL)
        && front_clip == vport->front_clip)
      pass ();
    else
      fail ("VPORT.front_clip [BD] %g != %g", vport->front_clip, front_clip);
    front_clip++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "front_clip", &front_clip, 0)
        && front_clip == vport->front_clip)
      pass ();
    else
      fail ("VPORT.front_clip [BD] set+1 %g != %g", vport->front_clip, front_clip);
    vport->front_clip--;
  }
  {
    BITCODE_BS grid_flags;
    if (dwg_dynapi_entity_value (vport, "VPORT", "grid_flags", &grid_flags, NULL)
        && grid_flags == vport->grid_flags)
      pass ();
    else
      fail ("VPORT.grid_flags [BS] %hu != %hu", vport->grid_flags, grid_flags);
    grid_flags++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "grid_flags", &grid_flags, 0)
        && grid_flags == vport->grid_flags)
      pass ();
    else
      fail ("VPORT.grid_flags [BS] set+1 %hu != %hu", vport->grid_flags, grid_flags);
    vport->grid_flags--;
  }
  {
    BITCODE_BS grid_major;
    if (dwg_dynapi_entity_value (vport, "VPORT", "grid_major", &grid_major, NULL)
        && grid_major == vport->grid_major)
      pass ();
    else
      fail ("VPORT.grid_major [BS] %hu != %hu", vport->grid_major, grid_major);
    grid_major++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "grid_major", &grid_major, 0)
        && grid_major == vport->grid_major)
      pass ();
    else
      fail ("VPORT.grid_major [BS] set+1 %hu != %hu", vport->grid_major, grid_major);
    vport->grid_major--;
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value (vport, "VPORT", "lens_length", &lens_length, NULL)
        && lens_length == vport->lens_length)
      pass ();
    else
      fail ("VPORT.lens_length [BD] %g != %g", vport->lens_length, lens_length);
    lens_length++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "lens_length", &lens_length, 0)
        && lens_length == vport->lens_length)
      pass ();
    else
      fail ("VPORT.lens_length [BD] set+1 %g != %g", vport->lens_length, lens_length);
    vport->lens_length--;
  }
  {
    BITCODE_2RD lower_left;
    if (dwg_dynapi_entity_value (vport, "VPORT", "lower_left", &lower_left, NULL)
        && !memcmp (&lower_left, &vport->lower_left, sizeof (vport->lower_left)))
        pass ();
    else
        fail ("VPORT.lower_left [2RD]");
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (vport, "VPORT", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)vport->name)
           : !vport->name)
      pass ();
    else
      fail ("VPORT.name [TV] '%s' <> '%s'", name, vport->name);
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (vport, "VPORT", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &vport->named_ucs, sizeof (vport->named_ucs)))
        pass ();
    else
        fail ("VPORT.named_ucs [H]");
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value (vport, "VPORT", "null_handle", &null_handle, NULL)
        && !memcmp (&null_handle, &vport->null_handle, sizeof (vport->null_handle)))
        pass ();
    else
        fail ("VPORT.null_handle [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vport, "VPORT", "parent", &parent, NULL)
        && !memcmp (&parent, &vport->parent, sizeof (vport->parent)))
        pass ();
    else
        fail ("VPORT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value (vport, "VPORT", "render_mode", &render_mode, NULL)
        && render_mode == vport->render_mode)
      pass ();
    else
      fail ("VPORT.render_mode [RC] %u != %u", vport->render_mode, render_mode);
    render_mode++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "render_mode", &render_mode, 0)
        && render_mode == vport->render_mode)
      pass ();
    else
      fail ("VPORT.render_mode [RC] set+1 %u != %u", vport->render_mode, render_mode);
    vport->render_mode--;
  }
  {
    BITCODE_H sun;
    if (dwg_dynapi_entity_value (vport, "VPORT", "sun", &sun, NULL)
        && !memcmp (&sun, &vport->sun, sizeof (vport->sun)))
        pass ();
    else
        fail ("VPORT.sun [H]");
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucs_elevation", &ucs_elevation, NULL)
        && ucs_elevation == vport->ucs_elevation)
      pass ();
    else
      fail ("VPORT.ucs_elevation [BD] %g != %g", vport->ucs_elevation, ucs_elevation);
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "ucs_elevation", &ucs_elevation, 0)
        && ucs_elevation == vport->ucs_elevation)
      pass ();
    else
      fail ("VPORT.ucs_elevation [BD] set+1 %g != %g", vport->ucs_elevation, ucs_elevation);
    vport->ucs_elevation--;
  }
  {
    BITCODE_3BD ucs_origin;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp (&ucs_origin, &vport->ucs_origin, sizeof (vport->ucs_origin)))
        pass ();
    else
        fail ("VPORT.ucs_origin [3BD]");
  }
  {
    BITCODE_BS ucs_orthografic_type;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucs_orthografic_type", &ucs_orthografic_type, NULL)
        && ucs_orthografic_type == vport->ucs_orthografic_type)
      pass ();
    else
      fail ("VPORT.ucs_orthografic_type [BS] %hu != %hu", vport->ucs_orthografic_type, ucs_orthografic_type);
    ucs_orthografic_type++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "ucs_orthografic_type", &ucs_orthografic_type, 0)
        && ucs_orthografic_type == vport->ucs_orthografic_type)
      pass ();
    else
      fail ("VPORT.ucs_orthografic_type [BS] set+1 %hu != %hu", vport->ucs_orthografic_type, ucs_orthografic_type);
    vport->ucs_orthografic_type--;
  }
  {
    BITCODE_3BD ucs_x_axis;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp (&ucs_x_axis, &vport->ucs_x_axis, sizeof (vport->ucs_x_axis)))
        pass ();
    else
        fail ("VPORT.ucs_x_axis [3BD]");
  }
  {
    BITCODE_3BD ucs_y_axis;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp (&ucs_y_axis, &vport->ucs_y_axis, sizeof (vport->ucs_y_axis)))
        pass ();
    else
        fail ("VPORT.ucs_y_axis [3BD]");
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (vport, "VPORT", "unknown", &unknown, NULL)
        && unknown == vport->unknown)
      pass ();
    else
      fail ("VPORT.unknown [B] " FORMAT_B " != " FORMAT_B "", vport->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "unknown", &unknown, 0)
        && unknown == vport->unknown)
      pass ();
    else
      fail ("VPORT.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->unknown, unknown);
    vport->unknown--;
  }
  {
    BITCODE_2RD upper_right;
    if (dwg_dynapi_entity_value (vport, "VPORT", "upper_right", &upper_right, NULL)
        && !memcmp (&upper_right, &vport->upper_right, sizeof (vport->upper_right)))
        pass ();
    else
        fail ("VPORT.upper_right [2RD]");
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value (vport, "VPORT", "use_default_lights", &use_default_lights, NULL)
        && use_default_lights == vport->use_default_lights)
      pass ();
    else
      fail ("VPORT.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", vport->use_default_lights, use_default_lights);
    use_default_lights++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "use_default_lights", &use_default_lights, 0)
        && use_default_lights == vport->use_default_lights)
      pass ();
    else
      fail ("VPORT.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->use_default_lights, use_default_lights);
    vport->use_default_lights--;
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (vport, "VPORT", "used", &used, NULL)
        && used == vport->used)
      pass ();
    else
      fail ("VPORT.used [RS] %hu != %hu", vport->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "used", &used, 0)
        && used == vport->used)
      pass ();
    else
      fail ("VPORT.used [RS] set+1 %hu != %hu", vport->used, used);
    vport->used--;
  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value (vport, "VPORT", "view_target", &view_target, NULL)
        && !memcmp (&view_target, &vport->view_target, sizeof (vport->view_target)))
        pass ();
    else
        fail ("VPORT.view_target [3BD]");
  }
  {
    BITCODE_BD view_twist;
    if (dwg_dynapi_entity_value (vport, "VPORT", "view_twist", &view_twist, NULL)
        && view_twist == vport->view_twist)
      pass ();
    else
      fail ("VPORT.view_twist [BD] %g != %g", vport->view_twist, view_twist);
    view_twist++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "view_twist", &view_twist, 0)
        && view_twist == vport->view_twist)
      pass ();
    else
      fail ("VPORT.view_twist [BD] set+1 %g != %g", vport->view_twist, view_twist);
    vport->view_twist--;
  }
  {
    BITCODE_BD viewwidth;
    if (dwg_dynapi_entity_value (vport, "VPORT", "viewwidth", &viewwidth, NULL)
        && viewwidth == vport->viewwidth)
      pass ();
    else
      fail ("VPORT.viewwidth [BD] %g != %g", vport->viewwidth, viewwidth);
    viewwidth++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "viewwidth", &viewwidth, 0)
        && viewwidth == vport->viewwidth)
      pass ();
    else
      fail ("VPORT.viewwidth [BD] set+1 %g != %g", vport->viewwidth, viewwidth);
    vport->viewwidth--;
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (vport, "VPORT", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &vport->visualstyle, sizeof (vport->visualstyle)))
        pass ();
    else
        fail ("VPORT.visualstyle [H]");
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (vport, "VPORT", "xrefdep", &xrefdep, NULL)
        && xrefdep == vport->xrefdep)
      pass ();
    else
      fail ("VPORT.xrefdep [B] " FORMAT_B " != " FORMAT_B "", vport->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "xrefdep", &xrefdep, 0)
        && xrefdep == vport->xrefdep)
      pass ();
    else
      fail ("VPORT.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->xrefdep, xrefdep);
    vport->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (vport, "VPORT", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == vport->xrefindex_plus1)
      pass ();
    else
      fail ("VPORT.xrefindex_plus1 [BS] %hu != %hu", vport->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == vport->xrefindex_plus1)
      pass ();
    else
      fail ("VPORT.xrefindex_plus1 [BS] set+1 %hu != %hu", vport->xrefindex_plus1, xrefindex_plus1);
    vport->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (vport, "VPORT", "xrefref", &xrefref, NULL)
        && xrefref == vport->xrefref)
      pass ();
    else
      fail ("VPORT.xrefref [B] " FORMAT_B " != " FORMAT_B "", vport->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "xrefref", &xrefref, 0)
        && xrefref == vport->xrefref)
      pass ();
    else
      fail ("VPORT.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->xrefref, xrefref);
    vport->xrefref--;
  }
  if (failed && (is_class_unstable ("VPORT") || is_class_debugging ("VPORT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VPORT", failed);
      failed = 0;
    }
  return failed;
}
static int test_VPORT_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VPORT_CONTROL *restrict vport_control = obj->tio.object->tio.VPORT_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "entries", &entries, NULL)
        && entries == vport_control->entries)
      pass ();
    else
      fail ("VPORT_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == vport_control->num_entries)
      pass ();
    else
      fail ("VPORT_CONTROL.num_entries [BS] %hu != %hu", vport_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (vport_control, "VPORT_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == vport_control->num_entries)
      pass ();
    else
      fail ("VPORT_CONTROL.num_entries [BS] set+1 %hu != %hu", vport_control->num_entries, num_entries);
    vport_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "objid", &objid, NULL)
        && objid == vport_control->objid)
      pass ();
    else
      fail ("VPORT_CONTROL.objid [BL] %u != %u", vport_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (vport_control, "VPORT_CONTROL", "objid", &objid, 0)
        && objid == vport_control->objid)
      pass ();
    else
      fail ("VPORT_CONTROL.objid [BL] set+1 %u != %u", vport_control->objid, objid);
    vport_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &vport_control->parent, sizeof (vport_control->parent)))
        pass ();
    else
        fail ("VPORT_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("VPORT_CONTROL") || is_class_debugging ("VPORT_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VPORT_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_VPORT_ENTITY_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VPORT_ENTITY_CONTROL *restrict vport_entity_control = obj->tio.object->tio.VPORT_ENTITY_CONTROL;
  failed = 0;
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (vport_entity_control, "VPORT_ENTITY_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (vport_entity_control, "VPORT_ENTITY_CONTROL", "entries", &entries, NULL)
        && entries == vport_entity_control->entries)
      pass ();
    else
      fail ("VPORT_ENTITY_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (vport_entity_control, "VPORT_ENTITY_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == vport_entity_control->num_entries)
      pass ();
    else
      fail ("VPORT_ENTITY_CONTROL.num_entries [BS] %hu != %hu", vport_entity_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (vport_entity_control, "VPORT_ENTITY_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == vport_entity_control->num_entries)
      pass ();
    else
      fail ("VPORT_ENTITY_CONTROL.num_entries [BS] set+1 %hu != %hu", vport_entity_control->num_entries, num_entries);
    vport_entity_control->num_entries--;
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value (vport_entity_control, "VPORT_ENTITY_CONTROL", "objid", &objid, NULL)
        && objid == vport_entity_control->objid)
      pass ();
    else
      fail ("VPORT_ENTITY_CONTROL.objid [BL] %u != %u", vport_entity_control->objid, objid);
    objid++;
    if (dwg_dynapi_entity_set_value (vport_entity_control, "VPORT_ENTITY_CONTROL", "objid", &objid, 0)
        && objid == vport_entity_control->objid)
      pass ();
    else
      fail ("VPORT_ENTITY_CONTROL.objid [BL] set+1 %u != %u", vport_entity_control->objid, objid);
    vport_entity_control->objid--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vport_entity_control, "VPORT_ENTITY_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &vport_entity_control->parent, sizeof (vport_entity_control->parent)))
        pass ();
    else
        fail ("VPORT_ENTITY_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("VPORT_ENTITY_CONTROL") || is_class_debugging ("VPORT_ENTITY_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VPORT_ENTITY_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_VPORT_ENTITY_HEADER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VPORT_ENTITY_HEADER *restrict vport_entity_header = obj->tio.object->tio.VPORT_ENTITY_HEADER;
  failed = 0;
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "flag", &flag, NULL)
        && flag == vport_entity_header->flag)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.flag [RC] %u != %u", vport_entity_header->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vport_entity_header, "VPORT_ENTITY_HEADER", "flag", &flag, 0)
        && flag == vport_entity_header->flag)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.flag [RC] set+1 %u != %u", vport_entity_header->flag, flag);
    vport_entity_header->flag--;
  }
  {
    BITCODE_B flag1;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "flag1", &flag1, NULL)
        && flag1 == vport_entity_header->flag1)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.flag1 [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (vport_entity_header, "VPORT_ENTITY_HEADER", "flag1", &flag1, 0)
        && flag1 == vport_entity_header->flag1)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.flag1 [B] set+1 " FORMAT_B " != " FORMAT_B "", vport_entity_header->flag1, flag1);
    vport_entity_header->flag1--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)vport_entity_header->name)
           : !vport_entity_header->name)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.name [TV] '%s' <> '%s'", name, vport_entity_header->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "parent", &parent, NULL)
        && !memcmp (&parent, &vport_entity_header->parent, sizeof (vport_entity_header->parent)))
        pass ();
    else
        fail ("VPORT_ENTITY_HEADER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "used", &used, NULL)
        && used == vport_entity_header->used)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.used [RS] %hu != %hu", vport_entity_header->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (vport_entity_header, "VPORT_ENTITY_HEADER", "used", &used, 0)
        && used == vport_entity_header->used)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.used [RS] set+1 %hu != %hu", vport_entity_header->used, used);
    vport_entity_header->used--;
  }
  {
    BITCODE_H vport_entity;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "vport_entity", &vport_entity, NULL)
        && !memcmp (&vport_entity, &vport_entity_header->vport_entity, sizeof (vport_entity_header->vport_entity)))
        pass ();
    else
        fail ("VPORT_ENTITY_HEADER.vport_entity [H]");
  }
  {
    BITCODE_H xref_handle;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "xref_handle", &xref_handle, NULL)
        && !memcmp (&xref_handle, &vport_entity_header->xref_handle, sizeof (vport_entity_header->xref_handle)))
        pass ();
    else
        fail ("VPORT_ENTITY_HEADER.xref_handle [H]");
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "xrefdep", &xrefdep, NULL)
        && xrefdep == vport_entity_header->xrefdep)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefdep, xrefdep);
    xrefdep++;
    if (dwg_dynapi_entity_set_value (vport_entity_header, "VPORT_ENTITY_HEADER", "xrefdep", &xrefdep, 0)
        && xrefdep == vport_entity_header->xrefdep)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.xrefdep [B] set+1 " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefdep, xrefdep);
    vport_entity_header->xrefdep--;
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "xrefindex_plus1", &xrefindex_plus1, NULL)
        && xrefindex_plus1 == vport_entity_header->xrefindex_plus1)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.xrefindex_plus1 [BS] %hu != %hu", vport_entity_header->xrefindex_plus1, xrefindex_plus1);
    xrefindex_plus1++;
    if (dwg_dynapi_entity_set_value (vport_entity_header, "VPORT_ENTITY_HEADER", "xrefindex_plus1", &xrefindex_plus1, 0)
        && xrefindex_plus1 == vport_entity_header->xrefindex_plus1)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.xrefindex_plus1 [BS] set+1 %hu != %hu", vport_entity_header->xrefindex_plus1, xrefindex_plus1);
    vport_entity_header->xrefindex_plus1--;
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value (vport_entity_header, "VPORT_ENTITY_HEADER", "xrefref", &xrefref, NULL)
        && xrefref == vport_entity_header->xrefref)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.xrefref [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefref, xrefref);
    xrefref++;
    if (dwg_dynapi_entity_set_value (vport_entity_header, "VPORT_ENTITY_HEADER", "xrefref", &xrefref, 0)
        && xrefref == vport_entity_header->xrefref)
      pass ();
    else
      fail ("VPORT_ENTITY_HEADER.xrefref [B] set+1 " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefref, xrefref);
    vport_entity_header->xrefref--;
  }
  if (failed && (is_class_unstable ("VPORT_ENTITY_HEADER") || is_class_debugging ("VPORT_ENTITY_HEADER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VPORT_ENTITY_HEADER", failed);
      failed = 0;
    }
  return failed;
}
static int test_WIPEOUTVARIABLES (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_WIPEOUTVARIABLES *restrict wipeoutvariables = obj->tio.object->tio.WIPEOUTVARIABLES;
  failed = 0;
  {
    BITCODE_BS display_frame;
    if (dwg_dynapi_entity_value (wipeoutvariables, "WIPEOUTVARIABLES", "display_frame", &display_frame, NULL)
        && display_frame == wipeoutvariables->display_frame)
      pass ();
    else
      fail ("WIPEOUTVARIABLES.display_frame [BS] %hu != %hu", wipeoutvariables->display_frame, display_frame);
    display_frame++;
    if (dwg_dynapi_entity_set_value (wipeoutvariables, "WIPEOUTVARIABLES", "display_frame", &display_frame, 0)
        && display_frame == wipeoutvariables->display_frame)
      pass ();
    else
      fail ("WIPEOUTVARIABLES.display_frame [BS] set+1 %hu != %hu", wipeoutvariables->display_frame, display_frame);
    wipeoutvariables->display_frame--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (wipeoutvariables, "WIPEOUTVARIABLES", "parent", &parent, NULL)
        && !memcmp (&parent, &wipeoutvariables->parent, sizeof (wipeoutvariables->parent)))
        pass ();
    else
        fail ("WIPEOUTVARIABLES.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("WIPEOUTVARIABLES") || is_class_debugging ("WIPEOUTVARIABLES")))
    {
      ok ("%s failed %d tests (TODO unstable)", "WIPEOUTVARIABLES", failed);
      failed = 0;
    }
  return failed;
}
static int test_XRECORD (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_XRECORD *restrict xrecord = obj->tio.object->tio.XRECORD;
  failed = 0;
  {
    BITCODE_BS cloning_flags;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "cloning_flags", &cloning_flags, NULL)
        && cloning_flags == xrecord->cloning_flags)
      pass ();
    else
      fail ("XRECORD.cloning_flags [BS] %hu != %hu", xrecord->cloning_flags, cloning_flags);
    cloning_flags++;
    if (dwg_dynapi_entity_set_value (xrecord, "XRECORD", "cloning_flags", &cloning_flags, 0)
        && cloning_flags == xrecord->cloning_flags)
      pass ();
    else
      fail ("XRECORD.cloning_flags [BS] set+1 %hu != %hu", xrecord->cloning_flags, cloning_flags);
    xrecord->cloning_flags--;
  }
  {
    BITCODE_BL num_objid_handles;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "num_objid_handles", &num_objid_handles, NULL)
        && num_objid_handles == xrecord->num_objid_handles)
      pass ();
    else
      fail ("XRECORD.num_objid_handles [BL] %u != %u", xrecord->num_objid_handles, num_objid_handles);
    num_objid_handles++;
    if (dwg_dynapi_entity_set_value (xrecord, "XRECORD", "num_objid_handles", &num_objid_handles, 0)
        && num_objid_handles == xrecord->num_objid_handles)
      pass ();
    else
      fail ("XRECORD.num_objid_handles [BL] set+1 %u != %u", xrecord->num_objid_handles, num_objid_handles);
    xrecord->num_objid_handles--;
  }
  {
    BITCODE_BL num_xdata;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "num_xdata", &num_xdata, NULL)
        && num_xdata == xrecord->num_xdata)
      pass ();
    else
      fail ("XRECORD.num_xdata [BL] %u != %u", xrecord->num_xdata, num_xdata);
    num_xdata++;
    if (dwg_dynapi_entity_set_value (xrecord, "XRECORD", "num_xdata", &num_xdata, 0)
        && num_xdata == xrecord->num_xdata)
      pass ();
    else
      fail ("XRECORD.num_xdata [BL] set+1 %u != %u", xrecord->num_xdata, num_xdata);
    xrecord->num_xdata--;
  }
  {
    BITCODE_H* objid_handles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "num_objid_handles", &count, NULL)
        && dwg_dynapi_entity_value (xrecord, "XRECORD", "objid_handles", &objid_handles, NULL)
        && objid_handles == xrecord->objid_handles)
      pass ();
    else
      fail ("XRECORD.objid_handles [H*] * %u num_objid_handles", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "parent", &parent, NULL)
        && !memcmp (&parent, &xrecord->parent, sizeof (xrecord->parent)))
        pass ();
    else
        fail ("XRECORD.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_Resbuf* xdata;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "num_xdata", &count, NULL)
        && dwg_dynapi_entity_value (xrecord, "XRECORD", "xdata", &xdata, NULL)
        && xdata == xrecord->xdata)
      pass ();
    else
      fail ("XRECORD.xdata [Dwg_Resbuf*] * %u num_xdata", count);
  }
  {
    BITCODE_BL xdata_size;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "xdata_size", &xdata_size, NULL)
        && xdata_size == xrecord->xdata_size)
      pass ();
    else
      fail ("XRECORD.xdata_size [BL] %u != %u", xrecord->xdata_size, xdata_size);
    xdata_size++;
    if (dwg_dynapi_entity_set_value (xrecord, "XRECORD", "xdata_size", &xdata_size, 0)
        && xdata_size == xrecord->xdata_size)
      pass ();
    else
      fail ("XRECORD.xdata_size [BL] set+1 %u != %u", xrecord->xdata_size, xdata_size);
    xrecord->xdata_size--;
  }
  if (failed && (is_class_unstable ("XRECORD") || is_class_debugging ("XRECORD")))
    {
      ok ("%s failed %d tests (TODO unstable)", "XRECORD", failed);
      failed = 0;
    }
  return failed;
}

#line 54 "dynapi_test.c.in"
static int
test_object (const Dwg_Data *restrict dwg, const Dwg_Object *restrict obj)
{
  int error = 0;
#line 37406 "dynapi_test.c"
  /* @@for if_test_OBJECT@@ */
  if (obj->fixedtype == DWG_TYPE__3DFACE)
    error += test__3DFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE__3DSOLID)
    error += test__3DSOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC_DIMENSION)
    error += test_ARC_DIMENSION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTDEF)
    error += test_ATTDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTRIB)
    error += test_ATTRIB(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK)
    error += test_BLOCK(obj);
  else  if (obj->fixedtype == DWG_TYPE_BODY)
    error += test_BODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_CAMERA)
    error += test_CAMERA(obj);
  else  if (obj->fixedtype == DWG_TYPE_CIRCLE)
    error += test_CIRCLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED)
    error += test_DIMENSION_ALIGNED(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
    error += test_DIMENSION_ANG2LN(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG3PT)
    error += test_DIMENSION_ANG3PT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_DIAMETER)
    error += test_DIMENSION_DIAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_LINEAR)
    error += test_DIMENSION_LINEAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ORDINATE)
    error += test_DIMENSION_ORDINATE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_RADIUS)
    error += test_DIMENSION_RADIUS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ELLIPSE)
    error += test_ELLIPSE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDBLK)
    error += test_ENDBLK(obj);
  else  if (obj->fixedtype == DWG_TYPE_EXTRUDEDSURFACE)
    error += test_EXTRUDEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOPOSITIONMARKER)
    error += test_GEOPOSITIONMARKER(obj);
  else  if (obj->fixedtype == DWG_TYPE_HATCH)
    error += test_HATCH(obj);
  else  if (obj->fixedtype == DWG_TYPE_HELIX)
    error += test_HELIX(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE)
    error += test_IMAGE(obj);
  else  if (obj->fixedtype == DWG_TYPE_INSERT)
    error += test_INSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADER)
    error += test_LEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHT)
    error += test_LIGHT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LINE)
    error += test_LINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LOFTEDSURFACE)
    error += test_LOFTEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LWPOLYLINE)
    error += test_LWPOLYLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MESH)
    error += test_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_MINSERT)
    error += test_MINSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINE)
    error += test_MLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXT)
    error += test_MTEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MULTILEADER)
    error += test_MULTILEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLE2FRAME)
    error += test_OLE2FRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLEFRAME)
    error += test_OLEFRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLANESURFACE)
    error += test_PLANESURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINT)
    error += test_POINT(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_2D)
    error += test_POLYLINE_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_3D)
    error += test_POLYLINE_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_MESH)
    error += test_POLYLINE_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_PFACE)
    error += test_POLYLINE_PFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY)
    error += test_PROXY_ENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_RAY)
    error += test_RAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_REGION)
    error += test_REGION(obj);
  else  if (obj->fixedtype == DWG_TYPE_REVOLVEDSURFACE)
    error += test_REVOLVEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SEQEND)
    error += test_SEQEND(obj);
  else  if (obj->fixedtype == DWG_TYPE_SHAPE)
    error += test_SHAPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID)
    error += test_SOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPLINE)
    error += test_SPLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SWEPTSURFACE)
    error += test_SWEPTSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLE)
    error += test_TABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXT)
    error += test_TEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TOLERANCE)
    error += test_TOLERANCE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TRACE)
    error += test_TRACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAY)
    error += test_UNDERLAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_2D)
    error += test_VERTEX_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_3D)
    error += test_VERTEX_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_MESH)
    error += test_VERTEX_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE)
    error += test_VERTEX_PFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE_FACE)
    error += test_VERTEX_PFACE_FACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEWPORT)
    error += test_VIEWPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUT)
    error += test_WIPEOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_XLINE)
    error += test_XLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_BOX_CLASS)
    error += test_ACSH_BOX_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_EXTRUSION_CLASS)
    error += test_ACSH_EXTRUSION_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SWEEP_CLASS)
    error += test_ACSH_SWEEP_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ALDIMOBJECTCONTEXTDATA)
    error += test_ALDIMOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID)
    error += test_APPID(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID_CONTROL)
    error += test_APPID_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC2DCONSTRAINTGROUP)
    error += test_ASSOC2DCONSTRAINTGROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTION)
    error += test_ASSOCACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY)
    error += test_ASSOCALIGNEDDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDEPENDENCY)
    error += test_ASSOCDEPENDENCY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEXTRUDEDSURFACEACTIONBODY)
    error += test_ASSOCEXTRUDEDSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCLOFTEDSURFACEACTIONBODY)
    error += test_ASSOCLOFTEDSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORK)
    error += test_ASSOCNETWORK(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM)
    error += test_ASSOCOSNAPPOINTREFACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPERSSUBENTMANAGER)
    error += test_ASSOCPERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPLANESURFACEACTIONBODY)
    error += test_ASSOCPLANESURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCREVOLVEDSURFACEACTIONBODY)
    error += test_ASSOCREVOLVEDSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCSWEPTSURFACEACTIONBODY)
    error += test_ASSOCSWEPTSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLKREFOBJECTCONTEXTDATA)
    error += test_BLKREFOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_CONTROL)
    error += test_BLOCK_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
    error += test_BLOCK_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
    error += test_CELLSTYLEMAP(obj);
  else  if (obj->fixedtype == DWG_TYPE_DATALINK)
    error += test_DATALINK(obj);
  else  if (obj->fixedtype == DWG_TYPE_DATATABLE)
    error += test_DATATABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DBCOLOR)
    error += test_DBCOLOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARY)
    error += test_DICTIONARY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYVAR)
    error += test_DICTIONARYVAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
    error += test_DICTIONARYWDFLT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMASSOC)
    error += test_DIMASSOC(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
    error += test_DIMSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE_CONTROL)
    error += test_DIMSTYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_DUMMY)
    error += test_DUMMY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER)
    error += test_DYNAMICBLOCKPURGEPREVENTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
    error += test_EVALUATION_GRAPH(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELD)
    error += test_FIELD(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELDLIST)
    error += test_FIELDLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEODATA)
    error += test_GEODATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOMAPIMAGE)
    error += test_GEOMAPIMAGE(obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUP)
    error += test_GROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_IDBUFFER)
    error += test_IDBUFFER(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF)
    error += test_IMAGEDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF_REACTOR)
    error += test_IMAGEDEF_REACTOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER)
    error += test_LAYER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_CONTROL)
    error += test_LAYER_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_INDEX)
    error += test_LAYER_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUT)
    error += test_LAYOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADEROBJECTCONTEXTDATA)
    error += test_LEADEROBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHTLIST)
    error += test_LIGHTLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_LONG_TRANSACTION)
    error += test_LONG_TRANSACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE)
    error += test_LTYPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE_CONTROL)
    error += test_LTYPE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MATERIAL)
    error += test_MATERIAL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADEROBJECTCONTEXTDATA)
    error += test_MLEADEROBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
    error += test_MLEADERSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINESTYLE)
    error += test_MLINESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXTATTRIBUTEOBJECTCONTEXTDATA)
    error += test_MTEXTATTRIBUTEOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXTOBJECTCONTEXTDATA)
    error += test_MTEXTOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_NAVISWORKSMODELDEF)
    error += test_NAVISWORKSMODELDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECTCONTEXTDATA)
    error += test_OBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECT_PTR)
    error += test_OBJECT_PTR(obj);
  else  if (obj->fixedtype == DWG_TYPE_PERSSUBENTMANAGER)
    error += test_PERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLACEHOLDER)
    error += test_PLACEHOLDER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
    error += test_PLOTSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_OBJECT)
    error += test_PROXY_OBJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_RASTERVARIABLES)
    error += test_RASTERVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERENVIRONMENT)
    error += test_RENDERENVIRONMENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERGLOBAL)
    error += test_RENDERGLOBAL(obj);
  else  if (obj->fixedtype == DWG_TYPE_SCALE)
    error += test_SCALE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SORTENTSTABLE)
    error += test_SORTENTSTABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_FILTER)
    error += test_SPATIAL_FILTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_INDEX)
    error += test_SPATIAL_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE)
    error += test_STYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE_CONTROL)
    error += test_STYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUN)
    error += test_SUN(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUNSTUDY)
    error += test_SUNSTUDY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLECONTENT)
    error += test_TABLECONTENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
    error += test_TABLEGEOMETRY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
    error += test_TABLESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXTOBJECTCONTEXTDATA)
    error += test_TEXTOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS)
    error += test_UCS(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS_CONTROL)
    error += test_UCS_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAYDEFINITION)
    error += test_UNDERLAYDEFINITION(obj);
  else  if (obj->fixedtype == DWG_TYPE_VBA_PROJECT)
    error += test_VBA_PROJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW)
    error += test_VIEW(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW_CONTROL)
    error += test_VIEW_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VISUALSTYLE)
    error += test_VISUALSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT)
    error += test_VPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_CONTROL)
    error += test_VPORT_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_CONTROL)
    error += test_VPORT_ENTITY_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_HEADER)
    error += test_VPORT_ENTITY_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUTVARIABLES)
    error += test_WIPEOUTVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_XRECORD)
    error += test_XRECORD(obj);
  if (obj->fixedtype == DWG_TYPE__3DFACE)
    error += test__3DFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE__3DSOLID)
    error += test__3DSOLID (obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC (obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC_DIMENSION)
    error += test_ARC_DIMENSION (obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTDEF)
    error += test_ATTDEF (obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTRIB)
    error += test_ATTRIB (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK)
    error += test_BLOCK (obj);
  else  if (obj->fixedtype == DWG_TYPE_BODY)
    error += test_BODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_CAMERA)
    error += test_CAMERA (obj);
  else  if (obj->fixedtype == DWG_TYPE_CIRCLE)
    error += test_CIRCLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED)
    error += test_DIMENSION_ALIGNED (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
    error += test_DIMENSION_ANG2LN (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG3PT)
    error += test_DIMENSION_ANG3PT (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_DIAMETER)
    error += test_DIMENSION_DIAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_LINEAR)
    error += test_DIMENSION_LINEAR (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ORDINATE)
    error += test_DIMENSION_ORDINATE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_RADIUS)
    error += test_DIMENSION_RADIUS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ELLIPSE)
    error += test_ELLIPSE (obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDBLK)
    error += test_ENDBLK (obj);
  else  if (obj->fixedtype == DWG_TYPE_EXTRUDEDSURFACE)
    error += test_EXTRUDEDSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOPOSITIONMARKER)
    error += test_GEOPOSITIONMARKER (obj);
  else  if (obj->fixedtype == DWG_TYPE_HATCH)
    error += test_HATCH (obj);
  else  if (obj->fixedtype == DWG_TYPE_HELIX)
    error += test_HELIX (obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE)
    error += test_IMAGE (obj);
  else  if (obj->fixedtype == DWG_TYPE_INSERT)
    error += test_INSERT (obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADER)
    error += test_LEADER (obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHT)
    error += test_LIGHT (obj);
  else  if (obj->fixedtype == DWG_TYPE_LINE)
    error += test_LINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_LOFTEDSURFACE)
    error += test_LOFTEDSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_LWPOLYLINE)
    error += test_LWPOLYLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_MESH)
    error += test_MESH (obj);
  else  if (obj->fixedtype == DWG_TYPE_MINSERT)
    error += test_MINSERT (obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINE)
    error += test_MLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXT)
    error += test_MTEXT (obj);
  else  if (obj->fixedtype == DWG_TYPE_MULTILEADER)
    error += test_MULTILEADER (obj);
  else  if (obj->fixedtype == DWG_TYPE_OLE2FRAME)
    error += test_OLE2FRAME (obj);
  else  if (obj->fixedtype == DWG_TYPE_OLEFRAME)
    error += test_OLEFRAME (obj);
  else  if (obj->fixedtype == DWG_TYPE_PLANESURFACE)
    error += test_PLANESURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINT)
    error += test_POINT (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_2D)
    error += test_POLYLINE_2D (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_3D)
    error += test_POLYLINE_3D (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_MESH)
    error += test_POLYLINE_MESH (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_PFACE)
    error += test_POLYLINE_PFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY)
    error += test_PROXY_ENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_RAY)
    error += test_RAY (obj);
  else  if (obj->fixedtype == DWG_TYPE_REGION)
    error += test_REGION (obj);
  else  if (obj->fixedtype == DWG_TYPE_REVOLVEDSURFACE)
    error += test_REVOLVEDSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SEQEND)
    error += test_SEQEND (obj);
  else  if (obj->fixedtype == DWG_TYPE_SHAPE)
    error += test_SHAPE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID)
    error += test_SOLID (obj);
  else  if (obj->fixedtype == DWG_TYPE_SPLINE)
    error += test_SPLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SWEPTSURFACE)
    error += test_SWEPTSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLE)
    error += test_TABLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXT)
    error += test_TEXT (obj);
  else  if (obj->fixedtype == DWG_TYPE_TOLERANCE)
    error += test_TOLERANCE (obj);
  else  if (obj->fixedtype == DWG_TYPE_TRACE)
    error += test_TRACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAY)
    error += test_UNDERLAY (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_2D)
    error += test_VERTEX_2D (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_3D)
    error += test_VERTEX_3D (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_MESH)
    error += test_VERTEX_MESH (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE)
    error += test_VERTEX_PFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE_FACE)
    error += test_VERTEX_PFACE_FACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEWPORT)
    error += test_VIEWPORT (obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUT)
    error += test_WIPEOUT (obj);
  else  if (obj->fixedtype == DWG_TYPE_XLINE)
    error += test_XLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_BOX_CLASS)
    error += test_ACSH_BOX_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_EXTRUSION_CLASS)
    error += test_ACSH_EXTRUSION_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SWEEP_CLASS)
    error += test_ACSH_SWEEP_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ALDIMOBJECTCONTEXTDATA)
    error += test_ALDIMOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID)
    error += test_APPID (obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID_CONTROL)
    error += test_APPID_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC2DCONSTRAINTGROUP)
    error += test_ASSOC2DCONSTRAINTGROUP (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTION)
    error += test_ASSOCACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY)
    error += test_ASSOCALIGNEDDIMACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDEPENDENCY)
    error += test_ASSOCDEPENDENCY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEXTRUDEDSURFACEACTIONBODY)
    error += test_ASSOCEXTRUDEDSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCLOFTEDSURFACEACTIONBODY)
    error += test_ASSOCLOFTEDSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORK)
    error += test_ASSOCNETWORK (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM)
    error += test_ASSOCOSNAPPOINTREFACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPERSSUBENTMANAGER)
    error += test_ASSOCPERSSUBENTMANAGER (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPLANESURFACEACTIONBODY)
    error += test_ASSOCPLANESURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCREVOLVEDSURFACEACTIONBODY)
    error += test_ASSOCREVOLVEDSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCSWEPTSURFACEACTIONBODY)
    error += test_ASSOCSWEPTSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLKREFOBJECTCONTEXTDATA)
    error += test_BLKREFOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_CONTROL)
    error += test_BLOCK_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
    error += test_BLOCK_HEADER (obj);
  else  if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
    error += test_CELLSTYLEMAP (obj);
  else  if (obj->fixedtype == DWG_TYPE_DATALINK)
    error += test_DATALINK (obj);
  else  if (obj->fixedtype == DWG_TYPE_DATATABLE)
    error += test_DATATABLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DBCOLOR)
    error += test_DBCOLOR (obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARY)
    error += test_DICTIONARY (obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYVAR)
    error += test_DICTIONARYVAR (obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
    error += test_DICTIONARYWDFLT (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMASSOC)
    error += test_DIMASSOC (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
    error += test_DIMSTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE_CONTROL)
    error += test_DIMSTYLE_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_DUMMY)
    error += test_DUMMY (obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER)
    error += test_DYNAMICBLOCKPURGEPREVENTER (obj);
  else  if (obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
    error += test_EVALUATION_GRAPH (obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELD)
    error += test_FIELD (obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELDLIST)
    error += test_FIELDLIST (obj);
  else  if (obj->fixedtype == DWG_TYPE_GEODATA)
    error += test_GEODATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOMAPIMAGE)
    error += test_GEOMAPIMAGE (obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUP)
    error += test_GROUP (obj);
  else  if (obj->fixedtype == DWG_TYPE_IDBUFFER)
    error += test_IDBUFFER (obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF)
    error += test_IMAGEDEF (obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF_REACTOR)
    error += test_IMAGEDEF_REACTOR (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER)
    error += test_LAYER (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_CONTROL)
    error += test_LAYER_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_INDEX)
    error += test_LAYER_INDEX (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUT)
    error += test_LAYOUT (obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADEROBJECTCONTEXTDATA)
    error += test_LEADEROBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHTLIST)
    error += test_LIGHTLIST (obj);
  else  if (obj->fixedtype == DWG_TYPE_LONG_TRANSACTION)
    error += test_LONG_TRANSACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE)
    error += test_LTYPE (obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE_CONTROL)
    error += test_LTYPE_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_MATERIAL)
    error += test_MATERIAL (obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADEROBJECTCONTEXTDATA)
    error += test_MLEADEROBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
    error += test_MLEADERSTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINESTYLE)
    error += test_MLINESTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXTATTRIBUTEOBJECTCONTEXTDATA)
    error += test_MTEXTATTRIBUTEOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXTOBJECTCONTEXTDATA)
    error += test_MTEXTOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_NAVISWORKSMODELDEF)
    error += test_NAVISWORKSMODELDEF (obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECTCONTEXTDATA)
    error += test_OBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECT_PTR)
    error += test_OBJECT_PTR (obj);
  else  if (obj->fixedtype == DWG_TYPE_PERSSUBENTMANAGER)
    error += test_PERSSUBENTMANAGER (obj);
  else  if (obj->fixedtype == DWG_TYPE_PLACEHOLDER)
    error += test_PLACEHOLDER (obj);
  else  if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
    error += test_PLOTSETTINGS (obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_OBJECT)
    error += test_PROXY_OBJECT (obj);
  else  if (obj->fixedtype == DWG_TYPE_RASTERVARIABLES)
    error += test_RASTERVARIABLES (obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERENVIRONMENT)
    error += test_RENDERENVIRONMENT (obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERGLOBAL)
    error += test_RENDERGLOBAL (obj);
  else  if (obj->fixedtype == DWG_TYPE_SCALE)
    error += test_SCALE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SORTENTSTABLE)
    error += test_SORTENTSTABLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_FILTER)
    error += test_SPATIAL_FILTER (obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_INDEX)
    error += test_SPATIAL_INDEX (obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE)
    error += test_STYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE_CONTROL)
    error += test_STYLE_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_SUN)
    error += test_SUN (obj);
  else  if (obj->fixedtype == DWG_TYPE_SUNSTUDY)
    error += test_SUNSTUDY (obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLECONTENT)
    error += test_TABLECONTENT (obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
    error += test_TABLEGEOMETRY (obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
    error += test_TABLESTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXTOBJECTCONTEXTDATA)
    error += test_TEXTOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS)
    error += test_UCS (obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS_CONTROL)
    error += test_UCS_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAYDEFINITION)
    error += test_UNDERLAYDEFINITION (obj);
  else  if (obj->fixedtype == DWG_TYPE_VBA_PROJECT)
    error += test_VBA_PROJECT (obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW)
    error += test_VIEW (obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW_CONTROL)
    error += test_VIEW_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_VISUALSTYLE)
    error += test_VISUALSTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT)
    error += test_VPORT (obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_CONTROL)
    error += test_VPORT_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_CONTROL)
    error += test_VPORT_ENTITY_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_HEADER)
    error += test_VPORT_ENTITY_HEADER (obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUTVARIABLES)
    error += test_WIPEOUTVARIABLES (obj);
  else  if (obj->fixedtype == DWG_TYPE_XRECORD)
    error += test_XRECORD (obj);
#line 61 "dynapi_test.c.in"
  return error + failed;
}

/* for all fields, checks its sizeof vs _fields_size_sum */
static int
test_sizes (void)
{
  int error = 0;
  int size1, size2;
#line 38002 "dynapi_test.c"
  /* @@for test_SIZES@@ */
  size1 = sizeof (Dwg_Entity__3DFACE);
  size2 = dwg_dynapi_fields_size ("3DFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity__3DFACE): %d != "
               "dwg_dynapi_fields_size (\"3DFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity__3DSOLID);
  size2 = dwg_dynapi_fields_size ("3DSOLID");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity__3DSOLID): %d != "
               "dwg_dynapi_fields_size (\"3DSOLID\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ARC);
  size2 = dwg_dynapi_fields_size ("ARC");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ARC): %d != "
               "dwg_dynapi_fields_size (\"ARC\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ARC_DIMENSION);
  size2 = dwg_dynapi_fields_size ("ARC_DIMENSION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ARC_DIMENSION): %d != "
               "dwg_dynapi_fields_size (\"ARC_DIMENSION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ATTDEF);
  size2 = dwg_dynapi_fields_size ("ATTDEF");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ATTDEF): %d != "
               "dwg_dynapi_fields_size (\"ATTDEF\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ATTRIB);
  size2 = dwg_dynapi_fields_size ("ATTRIB");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ATTRIB): %d != "
               "dwg_dynapi_fields_size (\"ATTRIB\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_BLOCK);
  size2 = dwg_dynapi_fields_size ("BLOCK");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_BLOCK): %d != "
               "dwg_dynapi_fields_size (\"BLOCK\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_BODY);
  size2 = dwg_dynapi_fields_size ("BODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_BODY): %d != "
               "dwg_dynapi_fields_size (\"BODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_CAMERA);
  size2 = dwg_dynapi_fields_size ("CAMERA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_CAMERA): %d != "
               "dwg_dynapi_fields_size (\"CAMERA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_CIRCLE);
  size2 = dwg_dynapi_fields_size ("CIRCLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_CIRCLE): %d != "
               "dwg_dynapi_fields_size (\"CIRCLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_ALIGNED);
  size2 = dwg_dynapi_fields_size ("DIMENSION_ALIGNED");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_ALIGNED): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_ALIGNED\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_ANG2LN);
  size2 = dwg_dynapi_fields_size ("DIMENSION_ANG2LN");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_ANG2LN): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_ANG2LN\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_ANG3PT);
  size2 = dwg_dynapi_fields_size ("DIMENSION_ANG3PT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_ANG3PT): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_ANG3PT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_DIAMETER);
  size2 = dwg_dynapi_fields_size ("DIMENSION_DIAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_DIAMETER): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_DIAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_LINEAR);
  size2 = dwg_dynapi_fields_size ("DIMENSION_LINEAR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_LINEAR): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_LINEAR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_ORDINATE);
  size2 = dwg_dynapi_fields_size ("DIMENSION_ORDINATE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_ORDINATE): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_ORDINATE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_RADIUS);
  size2 = dwg_dynapi_fields_size ("DIMENSION_RADIUS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_RADIUS): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_RADIUS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ELLIPSE);
  size2 = dwg_dynapi_fields_size ("ELLIPSE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ELLIPSE): %d != "
               "dwg_dynapi_fields_size (\"ELLIPSE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ENDBLK);
  size2 = dwg_dynapi_fields_size ("ENDBLK");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ENDBLK): %d != "
               "dwg_dynapi_fields_size (\"ENDBLK\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_EXTRUDEDSURFACE);
  size2 = dwg_dynapi_fields_size ("EXTRUDEDSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_EXTRUDEDSURFACE): %d != "
               "dwg_dynapi_fields_size (\"EXTRUDEDSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_GEOPOSITIONMARKER);
  size2 = dwg_dynapi_fields_size ("GEOPOSITIONMARKER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_GEOPOSITIONMARKER): %d != "
               "dwg_dynapi_fields_size (\"GEOPOSITIONMARKER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_HATCH);
  size2 = dwg_dynapi_fields_size ("HATCH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_HATCH): %d != "
               "dwg_dynapi_fields_size (\"HATCH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_HELIX);
  size2 = dwg_dynapi_fields_size ("HELIX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_HELIX): %d != "
               "dwg_dynapi_fields_size (\"HELIX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_IMAGE);
  size2 = dwg_dynapi_fields_size ("IMAGE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_IMAGE): %d != "
               "dwg_dynapi_fields_size (\"IMAGE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_INSERT);
  size2 = dwg_dynapi_fields_size ("INSERT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_INSERT): %d != "
               "dwg_dynapi_fields_size (\"INSERT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LEADER);
  size2 = dwg_dynapi_fields_size ("LEADER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LEADER): %d != "
               "dwg_dynapi_fields_size (\"LEADER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LIGHT);
  size2 = dwg_dynapi_fields_size ("LIGHT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LIGHT): %d != "
               "dwg_dynapi_fields_size (\"LIGHT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LINE);
  size2 = dwg_dynapi_fields_size ("LINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LINE): %d != "
               "dwg_dynapi_fields_size (\"LINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LOFTEDSURFACE);
  size2 = dwg_dynapi_fields_size ("LOFTEDSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LOFTEDSURFACE): %d != "
               "dwg_dynapi_fields_size (\"LOFTEDSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LWPOLYLINE);
  size2 = dwg_dynapi_fields_size ("LWPOLYLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LWPOLYLINE): %d != "
               "dwg_dynapi_fields_size (\"LWPOLYLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MESH);
  size2 = dwg_dynapi_fields_size ("MESH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MESH): %d != "
               "dwg_dynapi_fields_size (\"MESH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MINSERT);
  size2 = dwg_dynapi_fields_size ("MINSERT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MINSERT): %d != "
               "dwg_dynapi_fields_size (\"MINSERT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MLINE);
  size2 = dwg_dynapi_fields_size ("MLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MLINE): %d != "
               "dwg_dynapi_fields_size (\"MLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MTEXT);
  size2 = dwg_dynapi_fields_size ("MTEXT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MTEXT): %d != "
               "dwg_dynapi_fields_size (\"MTEXT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MULTILEADER);
  size2 = dwg_dynapi_fields_size ("MULTILEADER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MULTILEADER): %d != "
               "dwg_dynapi_fields_size (\"MULTILEADER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_OLE2FRAME);
  size2 = dwg_dynapi_fields_size ("OLE2FRAME");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_OLE2FRAME): %d != "
               "dwg_dynapi_fields_size (\"OLE2FRAME\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_OLEFRAME);
  size2 = dwg_dynapi_fields_size ("OLEFRAME");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_OLEFRAME): %d != "
               "dwg_dynapi_fields_size (\"OLEFRAME\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_PLANESURFACE);
  size2 = dwg_dynapi_fields_size ("PLANESURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_PLANESURFACE): %d != "
               "dwg_dynapi_fields_size (\"PLANESURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POINT);
  size2 = dwg_dynapi_fields_size ("POINT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POINT): %d != "
               "dwg_dynapi_fields_size (\"POINT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_2D);
  size2 = dwg_dynapi_fields_size ("POLYLINE_2D");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_2D): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_2D\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_3D);
  size2 = dwg_dynapi_fields_size ("POLYLINE_3D");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_3D): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_3D\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_MESH);
  size2 = dwg_dynapi_fields_size ("POLYLINE_MESH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_MESH): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_MESH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_PFACE);
  size2 = dwg_dynapi_fields_size ("POLYLINE_PFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_PFACE): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_PFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_PROXY_ENTITY);
  size2 = dwg_dynapi_fields_size ("PROXY_ENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_PROXY_ENTITY): %d != "
               "dwg_dynapi_fields_size (\"PROXY_ENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_PROXY_LWPOLYLINE);
  size2 = dwg_dynapi_fields_size ("PROXY_LWPOLYLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_PROXY_LWPOLYLINE): %d != "
               "dwg_dynapi_fields_size (\"PROXY_LWPOLYLINE\"): %d\n", size1, size2);
      error++;
    }
  if (size1 != size2) // TODO
    error--;
  size1 = sizeof (Dwg_Entity_RAY);
  size2 = dwg_dynapi_fields_size ("RAY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_RAY): %d != "
               "dwg_dynapi_fields_size (\"RAY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_REGION);
  size2 = dwg_dynapi_fields_size ("REGION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_REGION): %d != "
               "dwg_dynapi_fields_size (\"REGION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_REVOLVEDSURFACE);
  size2 = dwg_dynapi_fields_size ("REVOLVEDSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_REVOLVEDSURFACE): %d != "
               "dwg_dynapi_fields_size (\"REVOLVEDSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SEQEND);
  size2 = dwg_dynapi_fields_size ("SEQEND");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SEQEND): %d != "
               "dwg_dynapi_fields_size (\"SEQEND\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SHAPE);
  size2 = dwg_dynapi_fields_size ("SHAPE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SHAPE): %d != "
               "dwg_dynapi_fields_size (\"SHAPE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SOLID);
  size2 = dwg_dynapi_fields_size ("SOLID");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SOLID): %d != "
               "dwg_dynapi_fields_size (\"SOLID\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SPLINE);
  size2 = dwg_dynapi_fields_size ("SPLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SPLINE): %d != "
               "dwg_dynapi_fields_size (\"SPLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SWEPTSURFACE);
  size2 = dwg_dynapi_fields_size ("SWEPTSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SWEPTSURFACE): %d != "
               "dwg_dynapi_fields_size (\"SWEPTSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_TABLE);
  size2 = dwg_dynapi_fields_size ("TABLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_TABLE): %d != "
               "dwg_dynapi_fields_size (\"TABLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_TEXT);
  size2 = dwg_dynapi_fields_size ("TEXT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_TEXT): %d != "
               "dwg_dynapi_fields_size (\"TEXT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_TOLERANCE);
  size2 = dwg_dynapi_fields_size ("TOLERANCE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_TOLERANCE): %d != "
               "dwg_dynapi_fields_size (\"TOLERANCE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_TRACE);
  size2 = dwg_dynapi_fields_size ("TRACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_TRACE): %d != "
               "dwg_dynapi_fields_size (\"TRACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_UNDERLAY);
  size2 = dwg_dynapi_fields_size ("UNDERLAY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_UNDERLAY): %d != "
               "dwg_dynapi_fields_size (\"UNDERLAY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_UNKNOWN_ENT);
  size2 = dwg_dynapi_fields_size ("UNKNOWN_ENT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_UNKNOWN_ENT): %d != "
               "dwg_dynapi_fields_size (\"UNKNOWN_ENT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_2D);
  size2 = dwg_dynapi_fields_size ("VERTEX_2D");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_2D): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_2D\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_3D);
  size2 = dwg_dynapi_fields_size ("VERTEX_3D");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_3D): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_3D\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_MESH);
  size2 = dwg_dynapi_fields_size ("VERTEX_MESH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_MESH): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_MESH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_PFACE);
  size2 = dwg_dynapi_fields_size ("VERTEX_PFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_PFACE): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_PFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_PFACE_FACE);
  size2 = dwg_dynapi_fields_size ("VERTEX_PFACE_FACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_PFACE_FACE): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_PFACE_FACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VIEWPORT);
  size2 = dwg_dynapi_fields_size ("VIEWPORT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VIEWPORT): %d != "
               "dwg_dynapi_fields_size (\"VIEWPORT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_WIPEOUT);
  size2 = dwg_dynapi_fields_size ("WIPEOUT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_WIPEOUT): %d != "
               "dwg_dynapi_fields_size (\"WIPEOUT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_XLINE);
  size2 = dwg_dynapi_fields_size ("XLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_XLINE): %d != "
               "dwg_dynapi_fields_size (\"XLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ACSH_BOX_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_BOX_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ACSH_BOX_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_BOX_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ACSH_EXTRUSION_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_EXTRUSION_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ACSH_EXTRUSION_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_EXTRUSION_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ACSH_SWEEP_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_SWEEP_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ACSH_SWEEP_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_SWEEP_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ALDIMOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("ALDIMOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ALDIMOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"ALDIMOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_APPID);
  size2 = dwg_dynapi_fields_size ("APPID");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_APPID): %d != "
               "dwg_dynapi_fields_size (\"APPID\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_APPID_CONTROL);
  size2 = dwg_dynapi_fields_size ("APPID_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_APPID_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"APPID_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOC2DCONSTRAINTGROUP);
  size2 = dwg_dynapi_fields_size ("ASSOC2DCONSTRAINTGROUP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOC2DCONSTRAINTGROUP): %d != "
               "dwg_dynapi_fields_size (\"ASSOC2DCONSTRAINTGROUP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCACTION);
  size2 = dwg_dynapi_fields_size ("ASSOCACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCACTION): %d != "
               "dwg_dynapi_fields_size (\"ASSOCACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCALIGNEDDIMACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCALIGNEDDIMACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCALIGNEDDIMACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCALIGNEDDIMACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCDEPENDENCY);
  size2 = dwg_dynapi_fields_size ("ASSOCDEPENDENCY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCDEPENDENCY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCDEPENDENCY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCEXTRUDEDSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCEXTRUDEDSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCEXTRUDEDSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCEXTRUDEDSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCLOFTEDSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCLOFTEDSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCLOFTEDSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCLOFTEDSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCNETWORK);
  size2 = dwg_dynapi_fields_size ("ASSOCNETWORK");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCNETWORK): %d != "
               "dwg_dynapi_fields_size (\"ASSOCNETWORK\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCOSNAPPOINTREFACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCOSNAPPOINTREFACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCOSNAPPOINTREFACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCOSNAPPOINTREFACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCPERSSUBENTMANAGER);
  size2 = dwg_dynapi_fields_size ("ASSOCPERSSUBENTMANAGER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCPERSSUBENTMANAGER): %d != "
               "dwg_dynapi_fields_size (\"ASSOCPERSSUBENTMANAGER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCPLANESURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCPLANESURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCPLANESURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCPLANESURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCREVOLVEDSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCREVOLVEDSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCREVOLVEDSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCREVOLVEDSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_ASSOCSWEPTSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCSWEPTSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_ASSOCSWEPTSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCSWEPTSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_BLKREFOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("BLKREFOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_BLKREFOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"BLKREFOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_BLOCK_CONTROL);
  size2 = dwg_dynapi_fields_size ("BLOCK_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_BLOCK_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"BLOCK_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_BLOCK_HEADER);
  size2 = dwg_dynapi_fields_size ("BLOCK_HEADER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_BLOCK_HEADER): %d != "
               "dwg_dynapi_fields_size (\"BLOCK_HEADER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_CELLSTYLEMAP);
  size2 = dwg_dynapi_fields_size ("CELLSTYLEMAP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_CELLSTYLEMAP): %d != "
               "dwg_dynapi_fields_size (\"CELLSTYLEMAP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DATALINK);
  size2 = dwg_dynapi_fields_size ("DATALINK");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DATALINK): %d != "
               "dwg_dynapi_fields_size (\"DATALINK\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DATATABLE);
  size2 = dwg_dynapi_fields_size ("DATATABLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DATATABLE): %d != "
               "dwg_dynapi_fields_size (\"DATATABLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DBCOLOR);
  size2 = dwg_dynapi_fields_size ("DBCOLOR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DBCOLOR): %d != "
               "dwg_dynapi_fields_size (\"DBCOLOR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DICTIONARY);
  size2 = dwg_dynapi_fields_size ("DICTIONARY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DICTIONARY): %d != "
               "dwg_dynapi_fields_size (\"DICTIONARY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DICTIONARYVAR);
  size2 = dwg_dynapi_fields_size ("DICTIONARYVAR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DICTIONARYVAR): %d != "
               "dwg_dynapi_fields_size (\"DICTIONARYVAR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DICTIONARYWDFLT);
  size2 = dwg_dynapi_fields_size ("DICTIONARYWDFLT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DICTIONARYWDFLT): %d != "
               "dwg_dynapi_fields_size (\"DICTIONARYWDFLT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DIMASSOC);
  size2 = dwg_dynapi_fields_size ("DIMASSOC");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DIMASSOC): %d != "
               "dwg_dynapi_fields_size (\"DIMASSOC\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DIMSTYLE);
  size2 = dwg_dynapi_fields_size ("DIMSTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DIMSTYLE): %d != "
               "dwg_dynapi_fields_size (\"DIMSTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DIMSTYLE_CONTROL);
  size2 = dwg_dynapi_fields_size ("DIMSTYLE_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DIMSTYLE_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"DIMSTYLE_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DUMMY);
  size2 = dwg_dynapi_fields_size ("DUMMY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DUMMY): %d != "
               "dwg_dynapi_fields_size (\"DUMMY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_DYNAMICBLOCKPURGEPREVENTER);
  size2 = dwg_dynapi_fields_size ("DYNAMICBLOCKPURGEPREVENTER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_DYNAMICBLOCKPURGEPREVENTER): %d != "
               "dwg_dynapi_fields_size (\"DYNAMICBLOCKPURGEPREVENTER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_EVALUATION_GRAPH);
  size2 = dwg_dynapi_fields_size ("EVALUATION_GRAPH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_EVALUATION_GRAPH): %d != "
               "dwg_dynapi_fields_size (\"EVALUATION_GRAPH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_FIELD);
  size2 = dwg_dynapi_fields_size ("FIELD");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_FIELD): %d != "
               "dwg_dynapi_fields_size (\"FIELD\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_FIELDLIST);
  size2 = dwg_dynapi_fields_size ("FIELDLIST");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_FIELDLIST): %d != "
               "dwg_dynapi_fields_size (\"FIELDLIST\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_GEODATA);
  size2 = dwg_dynapi_fields_size ("GEODATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_GEODATA): %d != "
               "dwg_dynapi_fields_size (\"GEODATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_GEOMAPIMAGE);
  size2 = dwg_dynapi_fields_size ("GEOMAPIMAGE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_GEOMAPIMAGE): %d != "
               "dwg_dynapi_fields_size (\"GEOMAPIMAGE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_GROUP);
  size2 = dwg_dynapi_fields_size ("GROUP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_GROUP): %d != "
               "dwg_dynapi_fields_size (\"GROUP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_IDBUFFER);
  size2 = dwg_dynapi_fields_size ("IDBUFFER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_IDBUFFER): %d != "
               "dwg_dynapi_fields_size (\"IDBUFFER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_IMAGEDEF);
  size2 = dwg_dynapi_fields_size ("IMAGEDEF");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_IMAGEDEF): %d != "
               "dwg_dynapi_fields_size (\"IMAGEDEF\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_IMAGEDEF_REACTOR);
  size2 = dwg_dynapi_fields_size ("IMAGEDEF_REACTOR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_IMAGEDEF_REACTOR): %d != "
               "dwg_dynapi_fields_size (\"IMAGEDEF_REACTOR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LAYER);
  size2 = dwg_dynapi_fields_size ("LAYER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LAYER): %d != "
               "dwg_dynapi_fields_size (\"LAYER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LAYER_CONTROL);
  size2 = dwg_dynapi_fields_size ("LAYER_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LAYER_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"LAYER_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LAYER_INDEX);
  size2 = dwg_dynapi_fields_size ("LAYER_INDEX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LAYER_INDEX): %d != "
               "dwg_dynapi_fields_size (\"LAYER_INDEX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LAYOUT);
  size2 = dwg_dynapi_fields_size ("LAYOUT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LAYOUT): %d != "
               "dwg_dynapi_fields_size (\"LAYOUT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LEADEROBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("LEADEROBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LEADEROBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"LEADEROBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LIGHTLIST);
  size2 = dwg_dynapi_fields_size ("LIGHTLIST");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LIGHTLIST): %d != "
               "dwg_dynapi_fields_size (\"LIGHTLIST\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LONG_TRANSACTION);
  size2 = dwg_dynapi_fields_size ("LONG_TRANSACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LONG_TRANSACTION): %d != "
               "dwg_dynapi_fields_size (\"LONG_TRANSACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LTYPE);
  size2 = dwg_dynapi_fields_size ("LTYPE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LTYPE): %d != "
               "dwg_dynapi_fields_size (\"LTYPE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_LTYPE_CONTROL);
  size2 = dwg_dynapi_fields_size ("LTYPE_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_LTYPE_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"LTYPE_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_MATERIAL);
  size2 = dwg_dynapi_fields_size ("MATERIAL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_MATERIAL): %d != "
               "dwg_dynapi_fields_size (\"MATERIAL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_MLEADEROBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("MLEADEROBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_MLEADEROBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"MLEADEROBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_MLEADERSTYLE);
  size2 = dwg_dynapi_fields_size ("MLEADERSTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_MLEADERSTYLE): %d != "
               "dwg_dynapi_fields_size (\"MLEADERSTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_MLINESTYLE);
  size2 = dwg_dynapi_fields_size ("MLINESTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_MLINESTYLE): %d != "
               "dwg_dynapi_fields_size (\"MLINESTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_MTEXTATTRIBUTEOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("MTEXTATTRIBUTEOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_MTEXTATTRIBUTEOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"MTEXTATTRIBUTEOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_MTEXTOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("MTEXTOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_MTEXTOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"MTEXTOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_NAVISWORKSMODELDEF);
  size2 = dwg_dynapi_fields_size ("NAVISWORKSMODELDEF");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_NAVISWORKSMODELDEF): %d != "
               "dwg_dynapi_fields_size (\"NAVISWORKSMODELDEF\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_OBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("OBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_OBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"OBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_OBJECT_PTR);
  size2 = dwg_dynapi_fields_size ("OBJECT_PTR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_OBJECT_PTR): %d != "
               "dwg_dynapi_fields_size (\"OBJECT_PTR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_PERSSUBENTMANAGER);
  size2 = dwg_dynapi_fields_size ("PERSSUBENTMANAGER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_PERSSUBENTMANAGER): %d != "
               "dwg_dynapi_fields_size (\"PERSSUBENTMANAGER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_PLACEHOLDER);
  size2 = dwg_dynapi_fields_size ("PLACEHOLDER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_PLACEHOLDER): %d != "
               "dwg_dynapi_fields_size (\"PLACEHOLDER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_PLOTSETTINGS);
  size2 = dwg_dynapi_fields_size ("PLOTSETTINGS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_PLOTSETTINGS): %d != "
               "dwg_dynapi_fields_size (\"PLOTSETTINGS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_PROXY_OBJECT);
  size2 = dwg_dynapi_fields_size ("PROXY_OBJECT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_PROXY_OBJECT): %d != "
               "dwg_dynapi_fields_size (\"PROXY_OBJECT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_RASTERVARIABLES);
  size2 = dwg_dynapi_fields_size ("RASTERVARIABLES");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_RASTERVARIABLES): %d != "
               "dwg_dynapi_fields_size (\"RASTERVARIABLES\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_RENDERENVIRONMENT);
  size2 = dwg_dynapi_fields_size ("RENDERENVIRONMENT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_RENDERENVIRONMENT): %d != "
               "dwg_dynapi_fields_size (\"RENDERENVIRONMENT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_RENDERGLOBAL);
  size2 = dwg_dynapi_fields_size ("RENDERGLOBAL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_RENDERGLOBAL): %d != "
               "dwg_dynapi_fields_size (\"RENDERGLOBAL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_SCALE);
  size2 = dwg_dynapi_fields_size ("SCALE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_SCALE): %d != "
               "dwg_dynapi_fields_size (\"SCALE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_SORTENTSTABLE);
  size2 = dwg_dynapi_fields_size ("SORTENTSTABLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_SORTENTSTABLE): %d != "
               "dwg_dynapi_fields_size (\"SORTENTSTABLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_SPATIAL_FILTER);
  size2 = dwg_dynapi_fields_size ("SPATIAL_FILTER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_SPATIAL_FILTER): %d != "
               "dwg_dynapi_fields_size (\"SPATIAL_FILTER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_SPATIAL_INDEX);
  size2 = dwg_dynapi_fields_size ("SPATIAL_INDEX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_SPATIAL_INDEX): %d != "
               "dwg_dynapi_fields_size (\"SPATIAL_INDEX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_STYLE);
  size2 = dwg_dynapi_fields_size ("STYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_STYLE): %d != "
               "dwg_dynapi_fields_size (\"STYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_STYLE_CONTROL);
  size2 = dwg_dynapi_fields_size ("STYLE_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_STYLE_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"STYLE_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_SUN);
  size2 = dwg_dynapi_fields_size ("SUN");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_SUN): %d != "
               "dwg_dynapi_fields_size (\"SUN\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_SUNSTUDY);
  size2 = dwg_dynapi_fields_size ("SUNSTUDY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_SUNSTUDY): %d != "
               "dwg_dynapi_fields_size (\"SUNSTUDY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_TABLECONTENT);
  size2 = dwg_dynapi_fields_size ("TABLECONTENT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_TABLECONTENT): %d != "
               "dwg_dynapi_fields_size (\"TABLECONTENT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_TABLEGEOMETRY);
  size2 = dwg_dynapi_fields_size ("TABLEGEOMETRY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_TABLEGEOMETRY): %d != "
               "dwg_dynapi_fields_size (\"TABLEGEOMETRY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_TABLESTYLE);
  size2 = dwg_dynapi_fields_size ("TABLESTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_TABLESTYLE): %d != "
               "dwg_dynapi_fields_size (\"TABLESTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_TEXTOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("TEXTOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_TEXTOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"TEXTOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_UCS);
  size2 = dwg_dynapi_fields_size ("UCS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_UCS): %d != "
               "dwg_dynapi_fields_size (\"UCS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_UCS_CONTROL);
  size2 = dwg_dynapi_fields_size ("UCS_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_UCS_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"UCS_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_UNDERLAYDEFINITION);
  size2 = dwg_dynapi_fields_size ("UNDERLAYDEFINITION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_UNDERLAYDEFINITION): %d != "
               "dwg_dynapi_fields_size (\"UNDERLAYDEFINITION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_UNKNOWN_OBJ);
  size2 = dwg_dynapi_fields_size ("UNKNOWN_OBJ");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_UNKNOWN_OBJ): %d != "
               "dwg_dynapi_fields_size (\"UNKNOWN_OBJ\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_VBA_PROJECT);
  size2 = dwg_dynapi_fields_size ("VBA_PROJECT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_VBA_PROJECT): %d != "
               "dwg_dynapi_fields_size (\"VBA_PROJECT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_VIEW);
  size2 = dwg_dynapi_fields_size ("VIEW");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_VIEW): %d != "
               "dwg_dynapi_fields_size (\"VIEW\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_VIEW_CONTROL);
  size2 = dwg_dynapi_fields_size ("VIEW_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_VIEW_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"VIEW_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_VISUALSTYLE);
  size2 = dwg_dynapi_fields_size ("VISUALSTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_VISUALSTYLE): %d != "
               "dwg_dynapi_fields_size (\"VISUALSTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_VPORT);
  size2 = dwg_dynapi_fields_size ("VPORT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_VPORT): %d != "
               "dwg_dynapi_fields_size (\"VPORT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_VPORT_CONTROL);
  size2 = dwg_dynapi_fields_size ("VPORT_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_VPORT_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"VPORT_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_VPORT_ENTITY_CONTROL);
  size2 = dwg_dynapi_fields_size ("VPORT_ENTITY_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_VPORT_ENTITY_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"VPORT_ENTITY_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_VPORT_ENTITY_HEADER);
  size2 = dwg_dynapi_fields_size ("VPORT_ENTITY_HEADER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_VPORT_ENTITY_HEADER): %d != "
               "dwg_dynapi_fields_size (\"VPORT_ENTITY_HEADER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_WIPEOUTVARIABLES);
  size2 = dwg_dynapi_fields_size ("WIPEOUTVARIABLES");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_WIPEOUTVARIABLES): %d != "
               "dwg_dynapi_fields_size (\"WIPEOUTVARIABLES\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_object_XRECORD);
  size2 = dwg_dynapi_fields_size ("XRECORD");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_object_XRECORD): %d != "
               "dwg_dynapi_fields_size (\"XRECORD\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_3DSOLID_silhouette);
  size2 = dwg_dynapi_fields_size ("3DSOLID_silhouette");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_3DSOLID_silhouette): %d != "
               "dwg_dynapi_fields_size (\"3DSOLID_silhouette\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_3DSOLID_wire);
  size2 = dwg_dynapi_fields_size ("3DSOLID_wire");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_3DSOLID_wire): %d != "
               "dwg_dynapi_fields_size (\"3DSOLID_wire\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_BorderStyle);
  size2 = dwg_dynapi_fields_size ("BorderStyle");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_BorderStyle): %d != "
               "dwg_dynapi_fields_size (\"BorderStyle\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_CELLSTYLEMAP_Cell);
  size2 = dwg_dynapi_fields_size ("CELLSTYLEMAP_Cell");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_CELLSTYLEMAP_Cell): %d != "
               "dwg_dynapi_fields_size (\"CELLSTYLEMAP_Cell\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_CellContentGeometry);
  size2 = dwg_dynapi_fields_size ("CellContentGeometry");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_CellContentGeometry): %d != "
               "dwg_dynapi_fields_size (\"CellContentGeometry\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_CellStyle);
  size2 = dwg_dynapi_fields_size ("CellStyle");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_CellStyle): %d != "
               "dwg_dynapi_fields_size (\"CellStyle\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ContentFormat);
  size2 = dwg_dynapi_fields_size ("ContentFormat");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ContentFormat): %d != "
               "dwg_dynapi_fields_size (\"ContentFormat\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_DIMASSOC_Ref);
  size2 = dwg_dynapi_fields_size ("DIMASSOC_Ref");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_DIMASSOC_Ref): %d != "
               "dwg_dynapi_fields_size (\"DIMASSOC_Ref\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_DIMENSION_common);
  size2 = dwg_dynapi_fields_size ("DIMENSION_common");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_DIMENSION_common): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_common\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_EVAL_Node);
  size2 = dwg_dynapi_fields_size ("EVAL_Node");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_EVAL_Node): %d != "
               "dwg_dynapi_fields_size (\"EVAL_Node\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_FIELD_ChildValue);
  size2 = dwg_dynapi_fields_size ("FIELD_ChildValue");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_FIELD_ChildValue): %d != "
               "dwg_dynapi_fields_size (\"FIELD_ChildValue\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_FileDepList_Files);
  size2 = dwg_dynapi_fields_size ("FileDepList_Files");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_FileDepList_Files): %d != "
               "dwg_dynapi_fields_size (\"FileDepList_Files\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_FormattedTableData);
  size2 = dwg_dynapi_fields_size ("FormattedTableData");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_FormattedTableData): %d != "
               "dwg_dynapi_fields_size (\"FormattedTableData\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_FormattedTableMerged);
  size2 = dwg_dynapi_fields_size ("FormattedTableMerged");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_FormattedTableMerged): %d != "
               "dwg_dynapi_fields_size (\"FormattedTableMerged\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_GEODATA_meshface);
  size2 = dwg_dynapi_fields_size ("GEODATA_meshface");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_GEODATA_meshface): %d != "
               "dwg_dynapi_fields_size (\"GEODATA_meshface\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_GEODATA_meshpt);
  size2 = dwg_dynapi_fields_size ("GEODATA_meshpt");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_GEODATA_meshpt): %d != "
               "dwg_dynapi_fields_size (\"GEODATA_meshpt\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_Color);
  size2 = dwg_dynapi_fields_size ("HATCH_Color");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_Color): %d != "
               "dwg_dynapi_fields_size (\"HATCH_Color\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_ControlPoint);
  size2 = dwg_dynapi_fields_size ("HATCH_ControlPoint");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_ControlPoint): %d != "
               "dwg_dynapi_fields_size (\"HATCH_ControlPoint\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_DefLine);
  size2 = dwg_dynapi_fields_size ("HATCH_DefLine");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_DefLine): %d != "
               "dwg_dynapi_fields_size (\"HATCH_DefLine\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_Path);
  size2 = dwg_dynapi_fields_size ("HATCH_Path");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_Path): %d != "
               "dwg_dynapi_fields_size (\"HATCH_Path\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_PathSeg);
  size2 = dwg_dynapi_fields_size ("HATCH_PathSeg");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_PathSeg): %d != "
               "dwg_dynapi_fields_size (\"HATCH_PathSeg\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_PolylinePath);
  size2 = dwg_dynapi_fields_size ("HATCH_PolylinePath");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_PolylinePath): %d != "
               "dwg_dynapi_fields_size (\"HATCH_PolylinePath\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LAYER_entry);
  size2 = dwg_dynapi_fields_size ("LAYER_entry");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LAYER_entry): %d != "
               "dwg_dynapi_fields_size (\"LAYER_entry\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_ArrowHead);
  size2 = dwg_dynapi_fields_size ("LEADER_ArrowHead");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_ArrowHead): %d != "
               "dwg_dynapi_fields_size (\"LEADER_ArrowHead\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_BlockLabel);
  size2 = dwg_dynapi_fields_size ("LEADER_BlockLabel");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_BlockLabel): %d != "
               "dwg_dynapi_fields_size (\"LEADER_BlockLabel\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_Break);
  size2 = dwg_dynapi_fields_size ("LEADER_Break");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_Break): %d != "
               "dwg_dynapi_fields_size (\"LEADER_Break\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_Line);
  size2 = dwg_dynapi_fields_size ("LEADER_Line");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_Line): %d != "
               "dwg_dynapi_fields_size (\"LEADER_Line\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_Node);
  size2 = dwg_dynapi_fields_size ("LEADER_Node");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_Node): %d != "
               "dwg_dynapi_fields_size (\"LEADER_Node\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LTYPE_dash);
  size2 = dwg_dynapi_fields_size ("LTYPE_dash");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LTYPE_dash): %d != "
               "dwg_dynapi_fields_size (\"LTYPE_dash\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LWPOLYLINE_width);
  size2 = dwg_dynapi_fields_size ("LWPOLYLINE_width");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LWPOLYLINE_width): %d != "
               "dwg_dynapi_fields_size (\"LWPOLYLINE_width\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LinkedData);
  size2 = dwg_dynapi_fields_size ("LinkedData");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LinkedData): %d != "
               "dwg_dynapi_fields_size (\"LinkedData\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LinkedTableData);
  size2 = dwg_dynapi_fields_size ("LinkedTableData");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LinkedTableData): %d != "
               "dwg_dynapi_fields_size (\"LinkedTableData\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MESH_edge);
  size2 = dwg_dynapi_fields_size ("MESH_edge");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MESH_edge): %d != "
               "dwg_dynapi_fields_size (\"MESH_edge\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLEADER_AnnotContext);
  size2 = dwg_dynapi_fields_size ("MLEADER_AnnotContext");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLEADER_AnnotContext): %d != "
               "dwg_dynapi_fields_size (\"MLEADER_AnnotContext\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLINESTYLE_line);
  size2 = dwg_dynapi_fields_size ("MLINESTYLE_line");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLINESTYLE_line): %d != "
               "dwg_dynapi_fields_size (\"MLINESTYLE_line\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLINE_line);
  size2 = dwg_dynapi_fields_size ("MLINE_line");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLINE_line): %d != "
               "dwg_dynapi_fields_size (\"MLINE_line\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLINE_vertex);
  size2 = dwg_dynapi_fields_size ("MLINE_vertex");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLINE_vertex): %d != "
               "dwg_dynapi_fields_size (\"MLINE_vertex\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_SPLINE_control_point);
  size2 = dwg_dynapi_fields_size ("SPLINE_control_point");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_SPLINE_control_point): %d != "
               "dwg_dynapi_fields_size (\"SPLINE_control_point\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_SUNSTUDY_Dates);
  size2 = dwg_dynapi_fields_size ("SUNSTUDY_Dates");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_SUNSTUDY_Dates): %d != "
               "dwg_dynapi_fields_size (\"SUNSTUDY_Dates\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_SummaryInfo_Property);
  size2 = dwg_dynapi_fields_size ("SummaryInfo_Property");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_SummaryInfo_Property): %d != "
               "dwg_dynapi_fields_size (\"SummaryInfo_Property\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLEGEOMETRY_Cell);
  size2 = dwg_dynapi_fields_size ("TABLEGEOMETRY_Cell");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLEGEOMETRY_Cell): %d != "
               "dwg_dynapi_fields_size (\"TABLEGEOMETRY_Cell\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLESTYLE_Cell);
  size2 = dwg_dynapi_fields_size ("TABLESTYLE_Cell");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLESTYLE_Cell): %d != "
               "dwg_dynapi_fields_size (\"TABLESTYLE_Cell\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLESTYLE_border);
  size2 = dwg_dynapi_fields_size ("TABLESTYLE_border");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLESTYLE_border): %d != "
               "dwg_dynapi_fields_size (\"TABLESTYLE_border\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLESTYLE_rowstyles);
  size2 = dwg_dynapi_fields_size ("TABLESTYLE_rowstyles");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLESTYLE_rowstyles): %d != "
               "dwg_dynapi_fields_size (\"TABLESTYLE_rowstyles\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_BreakHeight);
  size2 = dwg_dynapi_fields_size ("TABLE_BreakHeight");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_BreakHeight): %d != "
               "dwg_dynapi_fields_size (\"TABLE_BreakHeight\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_BreakRow);
  size2 = dwg_dynapi_fields_size ("TABLE_BreakRow");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_BreakRow): %d != "
               "dwg_dynapi_fields_size (\"TABLE_BreakRow\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_Cell);
  size2 = dwg_dynapi_fields_size ("TABLE_Cell");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_Cell): %d != "
               "dwg_dynapi_fields_size (\"TABLE_Cell\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_CustomDataItem);
  size2 = dwg_dynapi_fields_size ("TABLE_CustomDataItem");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_CustomDataItem): %d != "
               "dwg_dynapi_fields_size (\"TABLE_CustomDataItem\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_value);
  size2 = dwg_dynapi_fields_size ("TABLE_value");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_value): %d != "
               "dwg_dynapi_fields_size (\"TABLE_value\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableCell);
  size2 = dwg_dynapi_fields_size ("TableCell");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableCell): %d != "
               "dwg_dynapi_fields_size (\"TableCell\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableCellContent);
  size2 = dwg_dynapi_fields_size ("TableCellContent");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableCellContent): %d != "
               "dwg_dynapi_fields_size (\"TableCellContent\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableCellContent_Attr);
  size2 = dwg_dynapi_fields_size ("TableCellContent_Attr");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableCellContent_Attr): %d != "
               "dwg_dynapi_fields_size (\"TableCellContent_Attr\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableDataColumn);
  size2 = dwg_dynapi_fields_size ("TableDataColumn");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableDataColumn): %d != "
               "dwg_dynapi_fields_size (\"TableDataColumn\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableRow);
  size2 = dwg_dynapi_fields_size ("TableRow");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableRow): %d != "
               "dwg_dynapi_fields_size (\"TableRow\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (union _dwg_MLEADER_Content);
  size2 = dwg_dynapi_fields_size ("MLEADER_Content");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(union _dwg_MLEADER_Content): %d != "
               "dwg_dynapi_fields_size (\"MLEADER_Content\"): %d\n", size1, size2);
      error++;
    }
#line 73 "dynapi_test.c.in"
  return error;
}

static int
test_dynapi (const char *filename)
{
  int error;
  Dwg_Data dwg;
  BITCODE_BL i;
  num = passed = failed = 0;

  dwg.opts = 0;
  error = test_sizes ();
  if (dwg_read_file (filename, &dwg) >= DWG_ERR_CRITICAL)
    {
      dwg_free (&dwg);
      return 1;
    }

  /* On cygwin32 the dynapi works fine, but the dwg->header_vars.VARS
     reference is broken somehow (some wrong offset) */
#if !defined(__CYGWIN__) || defined(__amd64__)
  error += test_header (&dwg);
#endif
  for (i = 0; i < dwg.num_objects; i++)
    {
      error += test_object (&dwg, &dwg.object[i]);
    }
  dwg_free (&dwg);
  /* This value is the return value for `main',
     so clamp it to either 0 or 1.  */
  return error ? 1 : 0;
}

int
main (int argc, char *argv[])
{
  char *input = getenv ("INPUT");

  if (input == NULL)
    {
      int error = 0;
      char **ptr;
      const char *const files[] =
        {
         "example_2000.dwg",
         "example_2004.dwg",
         "example_2007.dwg",
         "example_2010.dwg",
         "example_2013.dwg",
         "example_2018.dwg",
         "example_r14.dwg",
         "2007/PolyLine3D.dwg",
         NULL
        };
      for (ptr = (char**)&files[0]; *ptr; ptr++)
        {
          struct stat attrib;
          if (stat (*ptr, &attrib))
            {
              char tmp[80];
              strcpy (tmp, "../test-data/");
              strcat (tmp, *ptr);
              if (stat (tmp, &attrib))
                fprintf (stderr, "Env var INPUT not defined, %s not found\n", tmp);
              else
                error += test_dynapi (tmp);
            }
          else
            error += test_dynapi (*ptr);
        }
      return error;
    }
  else
    return test_dynapi (input);
}
