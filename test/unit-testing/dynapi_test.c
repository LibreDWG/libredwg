/* ex: set ro ft=c: -*- mode: c; buffer-read-only: t -*- */
/*****************************************************************************/
/*  LibreDWG - free implementation of the DWG file format                    */
/*                                                                           */
/*  Copyright (C) 2019-2023 Free Software Foundation, Inc.                   */
/*                                                                           */
/*  This library is free software, licensed under the terms of the GNU       */
/*  General Public License as published by the Free Software Foundation,     */
/*  either version 3 of the License, or (at your option) any later version.  */
/*  You should have received a copy of the GNU General Public License        */
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
/*****************************************************************************/
/* dynapi coverage tests, generated by gen-dynapi.pl from dynapi_test.c.in
   do not modify */
/* written by: Reini Urban */

#line 16 "dynapi_test.c.in"
#define DYNAPI_TEST_C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "config.h"
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#include "../../programs/my_stat.h"
#include "common.h"
#include "classes.h"
#include "dwg.h"
#include "tests_common.h"
#include "dwg_api.h"

/* for all objects/entities/header_vars:
   compare direct api vs dynapi values
*/
static int
test_header (Dwg_Data *dwg)
{
  int error = 0;
  BITCODE_RL rl;
  BITCODE_RC rc;
  BITCODE_BLL bll;
  BITCODE_BD bd;
  BITCODE_TV tv;

#line 46 "dynapi_test.c"
  /* @@for test_HEADER@@ */
  {
    BITCODE_RL size;
    if (dwg_dynapi_header_value (dwg, "size", &size, NULL)
        && size == dwg->header_vars.size)
      pass ();
    else
      fail ("HEADER.size [RL] %u != %u", dwg->header_vars.size, size);
    size++;
    if (dwg_dynapi_header_set_value (dwg, "size", &size, 0)
        && size == dwg->header_vars.size)
      pass ();
    else
      fail ("HEADER.size [RL] set+1 %u != %u",
            dwg->header_vars.size, size);
    size--;
    dwg_dynapi_header_set_value (dwg, "size", &size, 0);

  }
  {
    BITCODE_RL bitsize_hi;
    if (dwg_dynapi_header_value (dwg, "bitsize_hi", &bitsize_hi, NULL)
        && bitsize_hi == dwg->header_vars.bitsize_hi)
      pass ();
    else
      fail ("HEADER.bitsize_hi [RL] %u != %u", dwg->header_vars.bitsize_hi, bitsize_hi);
    bitsize_hi++;
    if (dwg_dynapi_header_set_value (dwg, "bitsize_hi", &bitsize_hi, 0)
        && bitsize_hi == dwg->header_vars.bitsize_hi)
      pass ();
    else
      fail ("HEADER.bitsize_hi [RL] set+1 %u != %u",
            dwg->header_vars.bitsize_hi, bitsize_hi);
    bitsize_hi--;
    dwg_dynapi_header_set_value (dwg, "bitsize_hi", &bitsize_hi, 0);

  }
  {
    BITCODE_RL bitsize;
    if (dwg_dynapi_header_value (dwg, "bitsize", &bitsize, NULL)
        && bitsize == dwg->header_vars.bitsize)
      pass ();
    else
      fail ("HEADER.bitsize [RL] %u != %u", dwg->header_vars.bitsize, bitsize);
    bitsize++;
    if (dwg_dynapi_header_set_value (dwg, "bitsize", &bitsize, 0)
        && bitsize == dwg->header_vars.bitsize)
      pass ();
    else
      fail ("HEADER.bitsize [RL] set+1 %u != %u",
            dwg->header_vars.bitsize, bitsize);
    bitsize--;
    dwg_dynapi_header_set_value (dwg, "bitsize", &bitsize, 0);

  }
  {
    BITCODE_RC acadmaintver;
    if (dwg_dynapi_header_value (dwg, "ACADMAINTVER", &acadmaintver, NULL)
        && acadmaintver == dwg->header_vars.ACADMAINTVER)
      pass ();
    else
      fail ("HEADER.ACADMAINTVER [RC] %u != %u", dwg->header_vars.ACADMAINTVER, acadmaintver);
    acadmaintver++;
    if (dwg_dynapi_header_set_value (dwg, "ACADMAINTVER", &acadmaintver, 0)
        && acadmaintver == dwg->header_vars.ACADMAINTVER)
      pass ();
    else
      fail ("HEADER.ACADMAINTVER [RC] set+1 %u != %u",
            dwg->header_vars.ACADMAINTVER, acadmaintver);
    acadmaintver--;
    dwg_dynapi_header_set_value (dwg, "ACADMAINTVER", &acadmaintver, 0);

  }
  {
    BITCODE_BLL requiredversions;
    if (dwg_dynapi_header_value (dwg, "REQUIREDVERSIONS", &requiredversions, NULL)
        && requiredversions == dwg->header_vars.REQUIREDVERSIONS)
      pass ();
    else
      fail ("HEADER.REQUIREDVERSIONS [BLL] " FORMAT_BLL " != " FORMAT_BLL "", dwg->header_vars.REQUIREDVERSIONS, requiredversions);
    requiredversions++;
    if (dwg_dynapi_header_set_value (dwg, "REQUIREDVERSIONS", &requiredversions, 0)
        && requiredversions == dwg->header_vars.REQUIREDVERSIONS)
      pass ();
    else
      fail ("HEADER.REQUIREDVERSIONS [BLL] set+1 " FORMAT_BLL " != " FORMAT_BLL "",
            dwg->header_vars.REQUIREDVERSIONS, requiredversions);
    requiredversions--;
    dwg_dynapi_header_set_value (dwg, "REQUIREDVERSIONS", &requiredversions, 0);

  }
  {
    BITCODE_TV dwgcodepage;
    if (dwg_dynapi_header_value (dwg, "DWGCODEPAGE", &dwgcodepage, NULL)
        && !memcmp (&dwgcodepage, &dwg->header_vars.DWGCODEPAGE, sizeof (dwg->header_vars.DWGCODEPAGE))
       )
      pass ();
    else
      fail ("HEADER.DWGCODEPAGE [TV]");
  }
  {
    BITCODE_RS codepage;
    if (dwg_dynapi_header_value (dwg, "codepage", &codepage, NULL)
        && codepage == dwg->header_vars.codepage)
      pass ();
    else
      fail ("HEADER.codepage [RS] %hu != %hu", dwg->header_vars.codepage, codepage);
    codepage++;
    if (dwg_dynapi_header_set_value (dwg, "codepage", &codepage, 0)
        && codepage == dwg->header_vars.codepage)
      pass ();
    else
      fail ("HEADER.codepage [RS] set+1 %hu != %hu",
            dwg->header_vars.codepage, codepage);
    codepage--;
    dwg_dynapi_header_set_value (dwg, "codepage", &codepage, 0);

  }
  {
    BITCODE_BD unit1_ratio;
    if (dwg_dynapi_header_value (dwg, "unit1_ratio", &unit1_ratio, NULL)
        && unit1_ratio == dwg->header_vars.unit1_ratio)
      pass ();
    else
      fail ("HEADER.unit1_ratio [BD] %g != %g", dwg->header_vars.unit1_ratio, unit1_ratio);
    unit1_ratio++;
    if (dwg_dynapi_header_set_value (dwg, "unit1_ratio", &unit1_ratio, 0)
        && unit1_ratio == dwg->header_vars.unit1_ratio)
      pass ();
    else
      fail ("HEADER.unit1_ratio [BD] set+1 %g != %g",
            dwg->header_vars.unit1_ratio, unit1_ratio);
    unit1_ratio--;
    dwg_dynapi_header_set_value (dwg, "unit1_ratio", &unit1_ratio, 0);

  }
  {
    BITCODE_BD unit2_ratio;
    if (dwg_dynapi_header_value (dwg, "unit2_ratio", &unit2_ratio, NULL)
        && unit2_ratio == dwg->header_vars.unit2_ratio)
      pass ();
    else
      fail ("HEADER.unit2_ratio [BD] %g != %g", dwg->header_vars.unit2_ratio, unit2_ratio);
    unit2_ratio++;
    if (dwg_dynapi_header_set_value (dwg, "unit2_ratio", &unit2_ratio, 0)
        && unit2_ratio == dwg->header_vars.unit2_ratio)
      pass ();
    else
      fail ("HEADER.unit2_ratio [BD] set+1 %g != %g",
            dwg->header_vars.unit2_ratio, unit2_ratio);
    unit2_ratio--;
    dwg_dynapi_header_set_value (dwg, "unit2_ratio", &unit2_ratio, 0);

  }
  {
    BITCODE_BD unit3_ratio;
    if (dwg_dynapi_header_value (dwg, "unit3_ratio", &unit3_ratio, NULL)
        && unit3_ratio == dwg->header_vars.unit3_ratio)
      pass ();
    else
      fail ("HEADER.unit3_ratio [BD] %g != %g", dwg->header_vars.unit3_ratio, unit3_ratio);
    unit3_ratio++;
    if (dwg_dynapi_header_set_value (dwg, "unit3_ratio", &unit3_ratio, 0)
        && unit3_ratio == dwg->header_vars.unit3_ratio)
      pass ();
    else
      fail ("HEADER.unit3_ratio [BD] set+1 %g != %g",
            dwg->header_vars.unit3_ratio, unit3_ratio);
    unit3_ratio--;
    dwg_dynapi_header_set_value (dwg, "unit3_ratio", &unit3_ratio, 0);

  }
  {
    BITCODE_BD unit4_ratio;
    if (dwg_dynapi_header_value (dwg, "unit4_ratio", &unit4_ratio, NULL)
        && unit4_ratio == dwg->header_vars.unit4_ratio)
      pass ();
    else
      fail ("HEADER.unit4_ratio [BD] %g != %g", dwg->header_vars.unit4_ratio, unit4_ratio);
    unit4_ratio++;
    if (dwg_dynapi_header_set_value (dwg, "unit4_ratio", &unit4_ratio, 0)
        && unit4_ratio == dwg->header_vars.unit4_ratio)
      pass ();
    else
      fail ("HEADER.unit4_ratio [BD] set+1 %g != %g",
            dwg->header_vars.unit4_ratio, unit4_ratio);
    unit4_ratio--;
    dwg_dynapi_header_set_value (dwg, "unit4_ratio", &unit4_ratio, 0);

  }
  {
    BITCODE_TV unit1_name;
    if (dwg_dynapi_header_value (dwg, "unit1_name", &unit1_name, NULL)
        && !memcmp (&unit1_name, &dwg->header_vars.unit1_name, sizeof (dwg->header_vars.unit1_name))
       )
      pass ();
    else
      fail ("HEADER.unit1_name [TV]");
  }
  {
    BITCODE_TV unit2_name;
    if (dwg_dynapi_header_value (dwg, "unit2_name", &unit2_name, NULL)
        && !memcmp (&unit2_name, &dwg->header_vars.unit2_name, sizeof (dwg->header_vars.unit2_name))
       )
      pass ();
    else
      fail ("HEADER.unit2_name [TV]");
  }
  {
    BITCODE_TV unit3_name;
    if (dwg_dynapi_header_value (dwg, "unit3_name", &unit3_name, NULL)
        && !memcmp (&unit3_name, &dwg->header_vars.unit3_name, sizeof (dwg->header_vars.unit3_name))
       )
      pass ();
    else
      fail ("HEADER.unit3_name [TV]");
  }
  {
    BITCODE_TV unit4_name;
    if (dwg_dynapi_header_value (dwg, "unit4_name", &unit4_name, NULL)
        && !memcmp (&unit4_name, &dwg->header_vars.unit4_name, sizeof (dwg->header_vars.unit4_name))
       )
      pass ();
    else
      fail ("HEADER.unit4_name [TV]");
  }
  {
    BITCODE_BL unknown_8;
    if (dwg_dynapi_header_value (dwg, "unknown_8", &unknown_8, NULL)
        && unknown_8 == dwg->header_vars.unknown_8)
      pass ();
    else
      fail ("HEADER.unknown_8 [BL] %u != %u", dwg->header_vars.unknown_8, unknown_8);
    unknown_8++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_8", &unknown_8, 0)
        && unknown_8 == dwg->header_vars.unknown_8)
      pass ();
    else
      fail ("HEADER.unknown_8 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_8, unknown_8);
    unknown_8--;
    dwg_dynapi_header_set_value (dwg, "unknown_8", &unknown_8, 0);

  }
  {
    BITCODE_BL unknown_9;
    if (dwg_dynapi_header_value (dwg, "unknown_9", &unknown_9, NULL)
        && unknown_9 == dwg->header_vars.unknown_9)
      pass ();
    else
      fail ("HEADER.unknown_9 [BL] %u != %u", dwg->header_vars.unknown_9, unknown_9);
    unknown_9++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_9", &unknown_9, 0)
        && unknown_9 == dwg->header_vars.unknown_9)
      pass ();
    else
      fail ("HEADER.unknown_9 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_9, unknown_9);
    unknown_9--;
    dwg_dynapi_header_set_value (dwg, "unknown_9", &unknown_9, 0);

  }
  {
    BITCODE_BS unknown_10;
    if (dwg_dynapi_header_value (dwg, "unknown_10", &unknown_10, NULL)
        && unknown_10 == dwg->header_vars.unknown_10)
      pass ();
    else
      fail ("HEADER.unknown_10 [BS] %hu != %hu", dwg->header_vars.unknown_10, unknown_10);
    unknown_10++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_10", &unknown_10, 0)
        && unknown_10 == dwg->header_vars.unknown_10)
      pass ();
    else
      fail ("HEADER.unknown_10 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_10, unknown_10);
    unknown_10--;
    dwg_dynapi_header_set_value (dwg, "unknown_10", &unknown_10, 0);

  }
  {
    BITCODE_H vx_table_record;
    if (dwg_dynapi_header_value (dwg, "VX_TABLE_RECORD", &vx_table_record, NULL)
        && !memcmp (&vx_table_record, &dwg->header_vars.VX_TABLE_RECORD, sizeof (dwg->header_vars.VX_TABLE_RECORD))
       )
      pass ();
    else
      fail ("HEADER.VX_TABLE_RECORD [H]");
  }
  {
    BITCODE_B dimaso;
    if (dwg_dynapi_header_value (dwg, "DIMASO", &dimaso, NULL)
        && dimaso == dwg->header_vars.DIMASO)
      pass ();
    else
      fail ("HEADER.DIMASO [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMASO, dimaso);
    dimaso++;
    if (dwg_dynapi_header_set_value (dwg, "DIMASO", &dimaso, 0)
        && dimaso == dwg->header_vars.DIMASO)
      pass ();
    else
      fail ("HEADER.DIMASO [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMASO, dimaso);
    dimaso--;
    dwg_dynapi_header_set_value (dwg, "DIMASO", &dimaso, 0);

  }
  {
    BITCODE_B dimsho;
    if (dwg_dynapi_header_value (dwg, "DIMSHO", &dimsho, NULL)
        && dimsho == dwg->header_vars.DIMSHO)
      pass ();
    else
      fail ("HEADER.DIMSHO [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSHO, dimsho);
    dimsho++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSHO", &dimsho, 0)
        && dimsho == dwg->header_vars.DIMSHO)
      pass ();
    else
      fail ("HEADER.DIMSHO [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSHO, dimsho);
    dimsho--;
    dwg_dynapi_header_set_value (dwg, "DIMSHO", &dimsho, 0);

  }
  {
    BITCODE_B dimsav;
    if (dwg_dynapi_header_value (dwg, "DIMSAV", &dimsav, NULL)
        && dimsav == dwg->header_vars.DIMSAV)
      pass ();
    else
      fail ("HEADER.DIMSAV [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAV, dimsav);
    dimsav++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSAV", &dimsav, 0)
        && dimsav == dwg->header_vars.DIMSAV)
      pass ();
    else
      fail ("HEADER.DIMSAV [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSAV, dimsav);
    dimsav--;
    dwg_dynapi_header_set_value (dwg, "DIMSAV", &dimsav, 0);

  }
  {
    BITCODE_B plinegen;
    if (dwg_dynapi_header_value (dwg, "PLINEGEN", &plinegen, NULL)
        && plinegen == dwg->header_vars.PLINEGEN)
      pass ();
    else
      fail ("HEADER.PLINEGEN [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLINEGEN, plinegen);
    plinegen++;
    if (dwg_dynapi_header_set_value (dwg, "PLINEGEN", &plinegen, 0)
        && plinegen == dwg->header_vars.PLINEGEN)
      pass ();
    else
      fail ("HEADER.PLINEGEN [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PLINEGEN, plinegen);
    plinegen--;
    dwg_dynapi_header_set_value (dwg, "PLINEGEN", &plinegen, 0);

  }
  {
    BITCODE_B orthomode;
    if (dwg_dynapi_header_value (dwg, "ORTHOMODE", &orthomode, NULL)
        && orthomode == dwg->header_vars.ORTHOMODE)
      pass ();
    else
      fail ("HEADER.ORTHOMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ORTHOMODE, orthomode);
    orthomode++;
    if (dwg_dynapi_header_set_value (dwg, "ORTHOMODE", &orthomode, 0)
        && orthomode == dwg->header_vars.ORTHOMODE)
      pass ();
    else
      fail ("HEADER.ORTHOMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ORTHOMODE, orthomode);
    orthomode--;
    dwg_dynapi_header_set_value (dwg, "ORTHOMODE", &orthomode, 0);

  }
  {
    BITCODE_B regenmode;
    if (dwg_dynapi_header_value (dwg, "REGENMODE", &regenmode, NULL)
        && regenmode == dwg->header_vars.REGENMODE)
      pass ();
    else
      fail ("HEADER.REGENMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REGENMODE, regenmode);
    regenmode++;
    if (dwg_dynapi_header_set_value (dwg, "REGENMODE", &regenmode, 0)
        && regenmode == dwg->header_vars.REGENMODE)
      pass ();
    else
      fail ("HEADER.REGENMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.REGENMODE, regenmode);
    regenmode--;
    dwg_dynapi_header_set_value (dwg, "REGENMODE", &regenmode, 0);

  }
  {
    BITCODE_B fillmode;
    if (dwg_dynapi_header_value (dwg, "FILLMODE", &fillmode, NULL)
        && fillmode == dwg->header_vars.FILLMODE)
      pass ();
    else
      fail ("HEADER.FILLMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FILLMODE, fillmode);
    fillmode++;
    if (dwg_dynapi_header_set_value (dwg, "FILLMODE", &fillmode, 0)
        && fillmode == dwg->header_vars.FILLMODE)
      pass ();
    else
      fail ("HEADER.FILLMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.FILLMODE, fillmode);
    fillmode--;
    dwg_dynapi_header_set_value (dwg, "FILLMODE", &fillmode, 0);

  }
  {
    BITCODE_B qtextmode;
    if (dwg_dynapi_header_value (dwg, "QTEXTMODE", &qtextmode, NULL)
        && qtextmode == dwg->header_vars.QTEXTMODE)
      pass ();
    else
      fail ("HEADER.QTEXTMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.QTEXTMODE, qtextmode);
    qtextmode++;
    if (dwg_dynapi_header_set_value (dwg, "QTEXTMODE", &qtextmode, 0)
        && qtextmode == dwg->header_vars.QTEXTMODE)
      pass ();
    else
      fail ("HEADER.QTEXTMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.QTEXTMODE, qtextmode);
    qtextmode--;
    dwg_dynapi_header_set_value (dwg, "QTEXTMODE", &qtextmode, 0);

  }
  {
    BITCODE_B psltscale;
    if (dwg_dynapi_header_value (dwg, "PSLTSCALE", &psltscale, NULL)
        && psltscale == dwg->header_vars.PSLTSCALE)
      pass ();
    else
      fail ("HEADER.PSLTSCALE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSLTSCALE, psltscale);
    psltscale++;
    if (dwg_dynapi_header_set_value (dwg, "PSLTSCALE", &psltscale, 0)
        && psltscale == dwg->header_vars.PSLTSCALE)
      pass ();
    else
      fail ("HEADER.PSLTSCALE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PSLTSCALE, psltscale);
    psltscale--;
    dwg_dynapi_header_set_value (dwg, "PSLTSCALE", &psltscale, 0);

  }
  {
    BITCODE_B limcheck;
    if (dwg_dynapi_header_value (dwg, "LIMCHECK", &limcheck, NULL)
        && limcheck == dwg->header_vars.LIMCHECK)
      pass ();
    else
      fail ("HEADER.LIMCHECK [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LIMCHECK, limcheck);
    limcheck++;
    if (dwg_dynapi_header_set_value (dwg, "LIMCHECK", &limcheck, 0)
        && limcheck == dwg->header_vars.LIMCHECK)
      pass ();
    else
      fail ("HEADER.LIMCHECK [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.LIMCHECK, limcheck);
    limcheck--;
    dwg_dynapi_header_set_value (dwg, "LIMCHECK", &limcheck, 0);

  }
  {
    BITCODE_RC menuext[46];
    if (dwg_dynapi_header_value (dwg, "MENUEXT[46]", &menuext, NULL)
        && !memcmp (&menuext, &dwg->header_vars.MENUEXT, sizeof (dwg->header_vars.MENUEXT))
       )
      pass ();
    else
      fail ("HEADER.MENUEXT[46] [RC]");
  }
  {
    BITCODE_B blipmode;
    if (dwg_dynapi_header_value (dwg, "BLIPMODE", &blipmode, NULL)
        && blipmode == dwg->header_vars.BLIPMODE)
      pass ();
    else
      fail ("HEADER.BLIPMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.BLIPMODE, blipmode);
    blipmode++;
    if (dwg_dynapi_header_set_value (dwg, "BLIPMODE", &blipmode, 0)
        && blipmode == dwg->header_vars.BLIPMODE)
      pass ();
    else
      fail ("HEADER.BLIPMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.BLIPMODE, blipmode);
    blipmode--;
    dwg_dynapi_header_set_value (dwg, "BLIPMODE", &blipmode, 0);

  }
  {
    BITCODE_B unknown_11;
    if (dwg_dynapi_header_value (dwg, "unknown_11", &unknown_11, NULL)
        && unknown_11 == dwg->header_vars.unknown_11)
      pass ();
    else
      fail ("HEADER.unknown_11 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.unknown_11, unknown_11);
    unknown_11++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_11", &unknown_11, 0)
        && unknown_11 == dwg->header_vars.unknown_11)
      pass ();
    else
      fail ("HEADER.unknown_11 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.unknown_11, unknown_11);
    unknown_11--;
    dwg_dynapi_header_set_value (dwg, "unknown_11", &unknown_11, 0);

  }
  {
    BITCODE_B usrtimer;
    if (dwg_dynapi_header_value (dwg, "USRTIMER", &usrtimer, NULL)
        && usrtimer == dwg->header_vars.USRTIMER)
      pass ();
    else
      fail ("HEADER.USRTIMER [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.USRTIMER, usrtimer);
    usrtimer++;
    if (dwg_dynapi_header_set_value (dwg, "USRTIMER", &usrtimer, 0)
        && usrtimer == dwg->header_vars.USRTIMER)
      pass ();
    else
      fail ("HEADER.USRTIMER [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.USRTIMER, usrtimer);
    usrtimer--;
    dwg_dynapi_header_set_value (dwg, "USRTIMER", &usrtimer, 0);

  }
  {
    BITCODE_B fastzoom;
    if (dwg_dynapi_header_value (dwg, "FASTZOOM", &fastzoom, NULL)
        && fastzoom == dwg->header_vars.FASTZOOM)
      pass ();
    else
      fail ("HEADER.FASTZOOM [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FASTZOOM, fastzoom);
    fastzoom++;
    if (dwg_dynapi_header_set_value (dwg, "FASTZOOM", &fastzoom, 0)
        && fastzoom == dwg->header_vars.FASTZOOM)
      pass ();
    else
      fail ("HEADER.FASTZOOM [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.FASTZOOM, fastzoom);
    fastzoom--;
    dwg_dynapi_header_set_value (dwg, "FASTZOOM", &fastzoom, 0);

  }
  {
    BITCODE_B flatland;
    if (dwg_dynapi_header_value (dwg, "FLATLAND", &flatland, NULL)
        && flatland == dwg->header_vars.FLATLAND)
      pass ();
    else
      fail ("HEADER.FLATLAND [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FLATLAND, flatland);
    flatland++;
    if (dwg_dynapi_header_set_value (dwg, "FLATLAND", &flatland, 0)
        && flatland == dwg->header_vars.FLATLAND)
      pass ();
    else
      fail ("HEADER.FLATLAND [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.FLATLAND, flatland);
    flatland--;
    dwg_dynapi_header_set_value (dwg, "FLATLAND", &flatland, 0);

  }
  {
    BITCODE_B viewmode;
    if (dwg_dynapi_header_value (dwg, "VIEWMODE", &viewmode, NULL)
        && viewmode == dwg->header_vars.VIEWMODE)
      pass ();
    else
      fail ("HEADER.VIEWMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.VIEWMODE, viewmode);
    viewmode++;
    if (dwg_dynapi_header_set_value (dwg, "VIEWMODE", &viewmode, 0)
        && viewmode == dwg->header_vars.VIEWMODE)
      pass ();
    else
      fail ("HEADER.VIEWMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.VIEWMODE, viewmode);
    viewmode--;
    dwg_dynapi_header_set_value (dwg, "VIEWMODE", &viewmode, 0);

  }
  {
    BITCODE_B skpoly;
    if (dwg_dynapi_header_value (dwg, "SKPOLY", &skpoly, NULL)
        && skpoly == dwg->header_vars.SKPOLY)
      pass ();
    else
      fail ("HEADER.SKPOLY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SKPOLY, skpoly);
    skpoly++;
    if (dwg_dynapi_header_set_value (dwg, "SKPOLY", &skpoly, 0)
        && skpoly == dwg->header_vars.SKPOLY)
      pass ();
    else
      fail ("HEADER.SKPOLY [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.SKPOLY, skpoly);
    skpoly--;
    dwg_dynapi_header_set_value (dwg, "SKPOLY", &skpoly, 0);

  }
  {
    BITCODE_RS unknown_mon;
    if (dwg_dynapi_header_value (dwg, "unknown_mon", &unknown_mon, NULL)
        && unknown_mon == dwg->header_vars.unknown_mon)
      pass ();
    else
      fail ("HEADER.unknown_mon [RS] %hu != %hu", dwg->header_vars.unknown_mon, unknown_mon);
    unknown_mon++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_mon", &unknown_mon, 0)
        && unknown_mon == dwg->header_vars.unknown_mon)
      pass ();
    else
      fail ("HEADER.unknown_mon [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_mon, unknown_mon);
    unknown_mon--;
    dwg_dynapi_header_set_value (dwg, "unknown_mon", &unknown_mon, 0);

  }
  {
    BITCODE_RS unknown_day;
    if (dwg_dynapi_header_value (dwg, "unknown_day", &unknown_day, NULL)
        && unknown_day == dwg->header_vars.unknown_day)
      pass ();
    else
      fail ("HEADER.unknown_day [RS] %hu != %hu", dwg->header_vars.unknown_day, unknown_day);
    unknown_day++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_day", &unknown_day, 0)
        && unknown_day == dwg->header_vars.unknown_day)
      pass ();
    else
      fail ("HEADER.unknown_day [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_day, unknown_day);
    unknown_day--;
    dwg_dynapi_header_set_value (dwg, "unknown_day", &unknown_day, 0);

  }
  {
    BITCODE_RS unknown_year;
    if (dwg_dynapi_header_value (dwg, "unknown_year", &unknown_year, NULL)
        && unknown_year == dwg->header_vars.unknown_year)
      pass ();
    else
      fail ("HEADER.unknown_year [RS] %hu != %hu", dwg->header_vars.unknown_year, unknown_year);
    unknown_year++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_year", &unknown_year, 0)
        && unknown_year == dwg->header_vars.unknown_year)
      pass ();
    else
      fail ("HEADER.unknown_year [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_year, unknown_year);
    unknown_year--;
    dwg_dynapi_header_set_value (dwg, "unknown_year", &unknown_year, 0);

  }
  {
    BITCODE_RS unknown_hour;
    if (dwg_dynapi_header_value (dwg, "unknown_hour", &unknown_hour, NULL)
        && unknown_hour == dwg->header_vars.unknown_hour)
      pass ();
    else
      fail ("HEADER.unknown_hour [RS] %hu != %hu", dwg->header_vars.unknown_hour, unknown_hour);
    unknown_hour++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_hour", &unknown_hour, 0)
        && unknown_hour == dwg->header_vars.unknown_hour)
      pass ();
    else
      fail ("HEADER.unknown_hour [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_hour, unknown_hour);
    unknown_hour--;
    dwg_dynapi_header_set_value (dwg, "unknown_hour", &unknown_hour, 0);

  }
  {
    BITCODE_RS unknown_min;
    if (dwg_dynapi_header_value (dwg, "unknown_min", &unknown_min, NULL)
        && unknown_min == dwg->header_vars.unknown_min)
      pass ();
    else
      fail ("HEADER.unknown_min [RS] %hu != %hu", dwg->header_vars.unknown_min, unknown_min);
    unknown_min++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_min", &unknown_min, 0)
        && unknown_min == dwg->header_vars.unknown_min)
      pass ();
    else
      fail ("HEADER.unknown_min [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_min, unknown_min);
    unknown_min--;
    dwg_dynapi_header_set_value (dwg, "unknown_min", &unknown_min, 0);

  }
  {
    BITCODE_RS unknown_sec;
    if (dwg_dynapi_header_value (dwg, "unknown_sec", &unknown_sec, NULL)
        && unknown_sec == dwg->header_vars.unknown_sec)
      pass ();
    else
      fail ("HEADER.unknown_sec [RS] %hu != %hu", dwg->header_vars.unknown_sec, unknown_sec);
    unknown_sec++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_sec", &unknown_sec, 0)
        && unknown_sec == dwg->header_vars.unknown_sec)
      pass ();
    else
      fail ("HEADER.unknown_sec [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_sec, unknown_sec);
    unknown_sec--;
    dwg_dynapi_header_set_value (dwg, "unknown_sec", &unknown_sec, 0);

  }
  {
    BITCODE_RS unknown_ms;
    if (dwg_dynapi_header_value (dwg, "unknown_ms", &unknown_ms, NULL)
        && unknown_ms == dwg->header_vars.unknown_ms)
      pass ();
    else
      fail ("HEADER.unknown_ms [RS] %hu != %hu", dwg->header_vars.unknown_ms, unknown_ms);
    unknown_ms++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_ms", &unknown_ms, 0)
        && unknown_ms == dwg->header_vars.unknown_ms)
      pass ();
    else
      fail ("HEADER.unknown_ms [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_ms, unknown_ms);
    unknown_ms--;
    dwg_dynapi_header_set_value (dwg, "unknown_ms", &unknown_ms, 0);

  }
  {
    BITCODE_B angdir;
    if (dwg_dynapi_header_value (dwg, "ANGDIR", &angdir, NULL)
        && angdir == dwg->header_vars.ANGDIR)
      pass ();
    else
      fail ("HEADER.ANGDIR [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ANGDIR, angdir);
    angdir++;
    if (dwg_dynapi_header_set_value (dwg, "ANGDIR", &angdir, 0)
        && angdir == dwg->header_vars.ANGDIR)
      pass ();
    else
      fail ("HEADER.ANGDIR [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ANGDIR, angdir);
    angdir--;
    dwg_dynapi_header_set_value (dwg, "ANGDIR", &angdir, 0);

  }
  {
    BITCODE_B splframe;
    if (dwg_dynapi_header_value (dwg, "SPLFRAME", &splframe, NULL)
        && splframe == dwg->header_vars.SPLFRAME)
      pass ();
    else
      fail ("HEADER.SPLFRAME [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SPLFRAME, splframe);
    splframe++;
    if (dwg_dynapi_header_set_value (dwg, "SPLFRAME", &splframe, 0)
        && splframe == dwg->header_vars.SPLFRAME)
      pass ();
    else
      fail ("HEADER.SPLFRAME [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.SPLFRAME, splframe);
    splframe--;
    dwg_dynapi_header_set_value (dwg, "SPLFRAME", &splframe, 0);

  }
  {
    BITCODE_B attreq;
    if (dwg_dynapi_header_value (dwg, "ATTREQ", &attreq, NULL)
        && attreq == dwg->header_vars.ATTREQ)
      pass ();
    else
      fail ("HEADER.ATTREQ [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTREQ, attreq);
    attreq++;
    if (dwg_dynapi_header_set_value (dwg, "ATTREQ", &attreq, 0)
        && attreq == dwg->header_vars.ATTREQ)
      pass ();
    else
      fail ("HEADER.ATTREQ [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ATTREQ, attreq);
    attreq--;
    dwg_dynapi_header_set_value (dwg, "ATTREQ", &attreq, 0);

  }
  {
    BITCODE_B attdia;
    if (dwg_dynapi_header_value (dwg, "ATTDIA", &attdia, NULL)
        && attdia == dwg->header_vars.ATTDIA)
      pass ();
    else
      fail ("HEADER.ATTDIA [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTDIA, attdia);
    attdia++;
    if (dwg_dynapi_header_set_value (dwg, "ATTDIA", &attdia, 0)
        && attdia == dwg->header_vars.ATTDIA)
      pass ();
    else
      fail ("HEADER.ATTDIA [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ATTDIA, attdia);
    attdia--;
    dwg_dynapi_header_set_value (dwg, "ATTDIA", &attdia, 0);

  }
  {
    BITCODE_B mirrtext;
    if (dwg_dynapi_header_value (dwg, "MIRRTEXT", &mirrtext, NULL)
        && mirrtext == dwg->header_vars.MIRRTEXT)
      pass ();
    else
      fail ("HEADER.MIRRTEXT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.MIRRTEXT, mirrtext);
    mirrtext++;
    if (dwg_dynapi_header_set_value (dwg, "MIRRTEXT", &mirrtext, 0)
        && mirrtext == dwg->header_vars.MIRRTEXT)
      pass ();
    else
      fail ("HEADER.MIRRTEXT [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.MIRRTEXT, mirrtext);
    mirrtext--;
    dwg_dynapi_header_set_value (dwg, "MIRRTEXT", &mirrtext, 0);

  }
  {
    BITCODE_B worldview;
    if (dwg_dynapi_header_value (dwg, "WORLDVIEW", &worldview, NULL)
        && worldview == dwg->header_vars.WORLDVIEW)
      pass ();
    else
      fail ("HEADER.WORLDVIEW [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WORLDVIEW, worldview);
    worldview++;
    if (dwg_dynapi_header_set_value (dwg, "WORLDVIEW", &worldview, 0)
        && worldview == dwg->header_vars.WORLDVIEW)
      pass ();
    else
      fail ("HEADER.WORLDVIEW [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.WORLDVIEW, worldview);
    worldview--;
    dwg_dynapi_header_set_value (dwg, "WORLDVIEW", &worldview, 0);

  }
  {
    BITCODE_B wireframe;
    if (dwg_dynapi_header_value (dwg, "WIREFRAME", &wireframe, NULL)
        && wireframe == dwg->header_vars.WIREFRAME)
      pass ();
    else
      fail ("HEADER.WIREFRAME [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WIREFRAME, wireframe);
    wireframe++;
    if (dwg_dynapi_header_set_value (dwg, "WIREFRAME", &wireframe, 0)
        && wireframe == dwg->header_vars.WIREFRAME)
      pass ();
    else
      fail ("HEADER.WIREFRAME [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.WIREFRAME, wireframe);
    wireframe--;
    dwg_dynapi_header_set_value (dwg, "WIREFRAME", &wireframe, 0);

  }
  {
    BITCODE_B tilemode;
    if (dwg_dynapi_header_value (dwg, "TILEMODE", &tilemode, NULL)
        && tilemode == dwg->header_vars.TILEMODE)
      pass ();
    else
      fail ("HEADER.TILEMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.TILEMODE, tilemode);
    tilemode++;
    if (dwg_dynapi_header_set_value (dwg, "TILEMODE", &tilemode, 0)
        && tilemode == dwg->header_vars.TILEMODE)
      pass ();
    else
      fail ("HEADER.TILEMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.TILEMODE, tilemode);
    tilemode--;
    dwg_dynapi_header_set_value (dwg, "TILEMODE", &tilemode, 0);

  }
  {
    BITCODE_B plimcheck;
    if (dwg_dynapi_header_value (dwg, "PLIMCHECK", &plimcheck, NULL)
        && plimcheck == dwg->header_vars.PLIMCHECK)
      pass ();
    else
      fail ("HEADER.PLIMCHECK [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLIMCHECK, plimcheck);
    plimcheck++;
    if (dwg_dynapi_header_set_value (dwg, "PLIMCHECK", &plimcheck, 0)
        && plimcheck == dwg->header_vars.PLIMCHECK)
      pass ();
    else
      fail ("HEADER.PLIMCHECK [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PLIMCHECK, plimcheck);
    plimcheck--;
    dwg_dynapi_header_set_value (dwg, "PLIMCHECK", &plimcheck, 0);

  }
  {
    BITCODE_B visretain;
    if (dwg_dynapi_header_value (dwg, "VISRETAIN", &visretain, NULL)
        && visretain == dwg->header_vars.VISRETAIN)
      pass ();
    else
      fail ("HEADER.VISRETAIN [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.VISRETAIN, visretain);
    visretain++;
    if (dwg_dynapi_header_set_value (dwg, "VISRETAIN", &visretain, 0)
        && visretain == dwg->header_vars.VISRETAIN)
      pass ();
    else
      fail ("HEADER.VISRETAIN [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.VISRETAIN, visretain);
    visretain--;
    dwg_dynapi_header_set_value (dwg, "VISRETAIN", &visretain, 0);

  }
  {
    BITCODE_B delobj;
    if (dwg_dynapi_header_value (dwg, "DELOBJ", &delobj, NULL)
        && delobj == dwg->header_vars.DELOBJ)
      pass ();
    else
      fail ("HEADER.DELOBJ [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DELOBJ, delobj);
    delobj++;
    if (dwg_dynapi_header_set_value (dwg, "DELOBJ", &delobj, 0)
        && delobj == dwg->header_vars.DELOBJ)
      pass ();
    else
      fail ("HEADER.DELOBJ [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DELOBJ, delobj);
    delobj--;
    dwg_dynapi_header_set_value (dwg, "DELOBJ", &delobj, 0);

  }
  {
    BITCODE_B dispsilh;
    if (dwg_dynapi_header_value (dwg, "DISPSILH", &dispsilh, NULL)
        && dispsilh == dwg->header_vars.DISPSILH)
      pass ();
    else
      fail ("HEADER.DISPSILH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DISPSILH, dispsilh);
    dispsilh++;
    if (dwg_dynapi_header_set_value (dwg, "DISPSILH", &dispsilh, 0)
        && dispsilh == dwg->header_vars.DISPSILH)
      pass ();
    else
      fail ("HEADER.DISPSILH [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DISPSILH, dispsilh);
    dispsilh--;
    dwg_dynapi_header_set_value (dwg, "DISPSILH", &dispsilh, 0);

  }
  {
    BITCODE_B pellipse;
    if (dwg_dynapi_header_value (dwg, "PELLIPSE", &pellipse, NULL)
        && pellipse == dwg->header_vars.PELLIPSE)
      pass ();
    else
      fail ("HEADER.PELLIPSE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PELLIPSE, pellipse);
    pellipse++;
    if (dwg_dynapi_header_set_value (dwg, "PELLIPSE", &pellipse, 0)
        && pellipse == dwg->header_vars.PELLIPSE)
      pass ();
    else
      fail ("HEADER.PELLIPSE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PELLIPSE, pellipse);
    pellipse--;
    dwg_dynapi_header_set_value (dwg, "PELLIPSE", &pellipse, 0);

  }
  {
    BITCODE_BS saveimages;
    if (dwg_dynapi_header_value (dwg, "SAVEIMAGES", &saveimages, NULL)
        && saveimages == dwg->header_vars.SAVEIMAGES)
      pass ();
    else
      fail ("HEADER.SAVEIMAGES [BS] %hu != %hu", dwg->header_vars.SAVEIMAGES, saveimages);
    saveimages++;
    if (dwg_dynapi_header_set_value (dwg, "SAVEIMAGES", &saveimages, 0)
        && saveimages == dwg->header_vars.SAVEIMAGES)
      pass ();
    else
      fail ("HEADER.SAVEIMAGES [BS] set+1 %hu != %hu",
            dwg->header_vars.SAVEIMAGES, saveimages);
    saveimages--;
    dwg_dynapi_header_set_value (dwg, "SAVEIMAGES", &saveimages, 0);

  }
  {
    BITCODE_BS proxygraphics;
    if (dwg_dynapi_header_value (dwg, "PROXYGRAPHICS", &proxygraphics, NULL)
        && proxygraphics == dwg->header_vars.PROXYGRAPHICS)
      pass ();
    else
      fail ("HEADER.PROXYGRAPHICS [BS] %hu != %hu", dwg->header_vars.PROXYGRAPHICS, proxygraphics);
    proxygraphics++;
    if (dwg_dynapi_header_set_value (dwg, "PROXYGRAPHICS", &proxygraphics, 0)
        && proxygraphics == dwg->header_vars.PROXYGRAPHICS)
      pass ();
    else
      fail ("HEADER.PROXYGRAPHICS [BS] set+1 %hu != %hu",
            dwg->header_vars.PROXYGRAPHICS, proxygraphics);
    proxygraphics--;
    dwg_dynapi_header_set_value (dwg, "PROXYGRAPHICS", &proxygraphics, 0);

  }
  {
    BITCODE_BS measurement;
    if (dwg_dynapi_header_value (dwg, "MEASUREMENT", &measurement, NULL)
        && measurement == dwg->header_vars.MEASUREMENT)
      pass ();
    else
      fail ("HEADER.MEASUREMENT [BS] %hu != %hu", dwg->header_vars.MEASUREMENT, measurement);
    measurement++;
    if (dwg_dynapi_header_set_value (dwg, "MEASUREMENT", &measurement, 0)
        && measurement == dwg->header_vars.MEASUREMENT)
      pass ();
    else
      fail ("HEADER.MEASUREMENT [BS] set+1 %hu != %hu",
            dwg->header_vars.MEASUREMENT, measurement);
    measurement--;
    dwg_dynapi_header_set_value (dwg, "MEASUREMENT", &measurement, 0);

  }
  {
    BITCODE_BS dragmode;
    if (dwg_dynapi_header_value (dwg, "DRAGMODE", &dragmode, NULL)
        && dragmode == dwg->header_vars.DRAGMODE)
      pass ();
    else
      fail ("HEADER.DRAGMODE [BS] %hu != %hu", dwg->header_vars.DRAGMODE, dragmode);
    dragmode++;
    if (dwg_dynapi_header_set_value (dwg, "DRAGMODE", &dragmode, 0)
        && dragmode == dwg->header_vars.DRAGMODE)
      pass ();
    else
      fail ("HEADER.DRAGMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.DRAGMODE, dragmode);
    dragmode--;
    dwg_dynapi_header_set_value (dwg, "DRAGMODE", &dragmode, 0);

  }
  {
    BITCODE_BS treedepth;
    if (dwg_dynapi_header_value (dwg, "TREEDEPTH", &treedepth, NULL)
        && treedepth == dwg->header_vars.TREEDEPTH)
      pass ();
    else
      fail ("HEADER.TREEDEPTH [BS] %hu != %hu", dwg->header_vars.TREEDEPTH, treedepth);
    treedepth++;
    if (dwg_dynapi_header_set_value (dwg, "TREEDEPTH", &treedepth, 0)
        && treedepth == dwg->header_vars.TREEDEPTH)
      pass ();
    else
      fail ("HEADER.TREEDEPTH [BS] set+1 %hu != %hu",
            dwg->header_vars.TREEDEPTH, treedepth);
    treedepth--;
    dwg_dynapi_header_set_value (dwg, "TREEDEPTH", &treedepth, 0);

  }
  {
    BITCODE_BS lunits;
    if (dwg_dynapi_header_value (dwg, "LUNITS", &lunits, NULL)
        && lunits == dwg->header_vars.LUNITS)
      pass ();
    else
      fail ("HEADER.LUNITS [BS] %hu != %hu", dwg->header_vars.LUNITS, lunits);
    lunits++;
    if (dwg_dynapi_header_set_value (dwg, "LUNITS", &lunits, 0)
        && lunits == dwg->header_vars.LUNITS)
      pass ();
    else
      fail ("HEADER.LUNITS [BS] set+1 %hu != %hu",
            dwg->header_vars.LUNITS, lunits);
    lunits--;
    dwg_dynapi_header_set_value (dwg, "LUNITS", &lunits, 0);

  }
  {
    BITCODE_BS luprec;
    if (dwg_dynapi_header_value (dwg, "LUPREC", &luprec, NULL)
        && luprec == dwg->header_vars.LUPREC)
      pass ();
    else
      fail ("HEADER.LUPREC [BS] %hu != %hu", dwg->header_vars.LUPREC, luprec);
    luprec++;
    if (dwg_dynapi_header_set_value (dwg, "LUPREC", &luprec, 0)
        && luprec == dwg->header_vars.LUPREC)
      pass ();
    else
      fail ("HEADER.LUPREC [BS] set+1 %hu != %hu",
            dwg->header_vars.LUPREC, luprec);
    luprec--;
    dwg_dynapi_header_set_value (dwg, "LUPREC", &luprec, 0);

  }
  {
    BITCODE_BS aunits;
    if (dwg_dynapi_header_value (dwg, "AUNITS", &aunits, NULL)
        && aunits == dwg->header_vars.AUNITS)
      pass ();
    else
      fail ("HEADER.AUNITS [BS] %hu != %hu", dwg->header_vars.AUNITS, aunits);
    aunits++;
    if (dwg_dynapi_header_set_value (dwg, "AUNITS", &aunits, 0)
        && aunits == dwg->header_vars.AUNITS)
      pass ();
    else
      fail ("HEADER.AUNITS [BS] set+1 %hu != %hu",
            dwg->header_vars.AUNITS, aunits);
    aunits--;
    dwg_dynapi_header_set_value (dwg, "AUNITS", &aunits, 0);

  }
  {
    BITCODE_BS auprec;
    if (dwg_dynapi_header_value (dwg, "AUPREC", &auprec, NULL)
        && auprec == dwg->header_vars.AUPREC)
      pass ();
    else
      fail ("HEADER.AUPREC [BS] %hu != %hu", dwg->header_vars.AUPREC, auprec);
    auprec++;
    if (dwg_dynapi_header_set_value (dwg, "AUPREC", &auprec, 0)
        && auprec == dwg->header_vars.AUPREC)
      pass ();
    else
      fail ("HEADER.AUPREC [BS] set+1 %hu != %hu",
            dwg->header_vars.AUPREC, auprec);
    auprec--;
    dwg_dynapi_header_set_value (dwg, "AUPREC", &auprec, 0);

  }
  {
    BITCODE_BS attmode;
    if (dwg_dynapi_header_value (dwg, "ATTMODE", &attmode, NULL)
        && attmode == dwg->header_vars.ATTMODE)
      pass ();
    else
      fail ("HEADER.ATTMODE [BS] %hu != %hu", dwg->header_vars.ATTMODE, attmode);
    attmode++;
    if (dwg_dynapi_header_set_value (dwg, "ATTMODE", &attmode, 0)
        && attmode == dwg->header_vars.ATTMODE)
      pass ();
    else
      fail ("HEADER.ATTMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.ATTMODE, attmode);
    attmode--;
    dwg_dynapi_header_set_value (dwg, "ATTMODE", &attmode, 0);

  }
  {
    BITCODE_BS coords;
    if (dwg_dynapi_header_value (dwg, "COORDS", &coords, NULL)
        && coords == dwg->header_vars.COORDS)
      pass ();
    else
      fail ("HEADER.COORDS [BS] %hu != %hu", dwg->header_vars.COORDS, coords);
    coords++;
    if (dwg_dynapi_header_set_value (dwg, "COORDS", &coords, 0)
        && coords == dwg->header_vars.COORDS)
      pass ();
    else
      fail ("HEADER.COORDS [BS] set+1 %hu != %hu",
            dwg->header_vars.COORDS, coords);
    coords--;
    dwg_dynapi_header_set_value (dwg, "COORDS", &coords, 0);

  }
  {
    BITCODE_BS pdmode;
    if (dwg_dynapi_header_value (dwg, "PDMODE", &pdmode, NULL)
        && pdmode == dwg->header_vars.PDMODE)
      pass ();
    else
      fail ("HEADER.PDMODE [BS] %hu != %hu", dwg->header_vars.PDMODE, pdmode);
    pdmode++;
    if (dwg_dynapi_header_set_value (dwg, "PDMODE", &pdmode, 0)
        && pdmode == dwg->header_vars.PDMODE)
      pass ();
    else
      fail ("HEADER.PDMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.PDMODE, pdmode);
    pdmode--;
    dwg_dynapi_header_set_value (dwg, "PDMODE", &pdmode, 0);

  }
  {
    BITCODE_BS pickstyle;
    if (dwg_dynapi_header_value (dwg, "PICKSTYLE", &pickstyle, NULL)
        && pickstyle == dwg->header_vars.PICKSTYLE)
      pass ();
    else
      fail ("HEADER.PICKSTYLE [BS] %hu != %hu", dwg->header_vars.PICKSTYLE, pickstyle);
    pickstyle++;
    if (dwg_dynapi_header_set_value (dwg, "PICKSTYLE", &pickstyle, 0)
        && pickstyle == dwg->header_vars.PICKSTYLE)
      pass ();
    else
      fail ("HEADER.PICKSTYLE [BS] set+1 %hu != %hu",
            dwg->header_vars.PICKSTYLE, pickstyle);
    pickstyle--;
    dwg_dynapi_header_set_value (dwg, "PICKSTYLE", &pickstyle, 0);

  }
  {
    BITCODE_BL osmode;
    if (dwg_dynapi_header_value (dwg, "OSMODE", &osmode, NULL)
        && osmode == dwg->header_vars.OSMODE)
      pass ();
    else
      fail ("HEADER.OSMODE [BL] %u != %u", dwg->header_vars.OSMODE, osmode);
    osmode++;
    if (dwg_dynapi_header_set_value (dwg, "OSMODE", &osmode, 0)
        && osmode == dwg->header_vars.OSMODE)
      pass ();
    else
      fail ("HEADER.OSMODE [BL] set+1 %u != %u",
            dwg->header_vars.OSMODE, osmode);
    osmode--;
    dwg_dynapi_header_set_value (dwg, "OSMODE", &osmode, 0);

  }
  {
    BITCODE_BL unknown_12;
    if (dwg_dynapi_header_value (dwg, "unknown_12", &unknown_12, NULL)
        && unknown_12 == dwg->header_vars.unknown_12)
      pass ();
    else
      fail ("HEADER.unknown_12 [BL] %u != %u", dwg->header_vars.unknown_12, unknown_12);
    unknown_12++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_12", &unknown_12, 0)
        && unknown_12 == dwg->header_vars.unknown_12)
      pass ();
    else
      fail ("HEADER.unknown_12 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_12, unknown_12);
    unknown_12--;
    dwg_dynapi_header_set_value (dwg, "unknown_12", &unknown_12, 0);

  }
  {
    BITCODE_BL unknown_13;
    if (dwg_dynapi_header_value (dwg, "unknown_13", &unknown_13, NULL)
        && unknown_13 == dwg->header_vars.unknown_13)
      pass ();
    else
      fail ("HEADER.unknown_13 [BL] %u != %u", dwg->header_vars.unknown_13, unknown_13);
    unknown_13++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_13", &unknown_13, 0)
        && unknown_13 == dwg->header_vars.unknown_13)
      pass ();
    else
      fail ("HEADER.unknown_13 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_13, unknown_13);
    unknown_13--;
    dwg_dynapi_header_set_value (dwg, "unknown_13", &unknown_13, 0);

  }
  {
    BITCODE_BL unknown_14;
    if (dwg_dynapi_header_value (dwg, "unknown_14", &unknown_14, NULL)
        && unknown_14 == dwg->header_vars.unknown_14)
      pass ();
    else
      fail ("HEADER.unknown_14 [BL] %u != %u", dwg->header_vars.unknown_14, unknown_14);
    unknown_14++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_14", &unknown_14, 0)
        && unknown_14 == dwg->header_vars.unknown_14)
      pass ();
    else
      fail ("HEADER.unknown_14 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_14, unknown_14);
    unknown_14--;
    dwg_dynapi_header_set_value (dwg, "unknown_14", &unknown_14, 0);

  }
  {
    BITCODE_BSd useri1;
    if (dwg_dynapi_header_value (dwg, "USERI1", &useri1, NULL)
        && useri1 == dwg->header_vars.USERI1)
      pass ();
    else
      fail ("HEADER.USERI1 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI1, useri1);
    useri1++;
    if (dwg_dynapi_header_set_value (dwg, "USERI1", &useri1, 0)
        && useri1 == dwg->header_vars.USERI1)
      pass ();
    else
      fail ("HEADER.USERI1 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.USERI1, useri1);
    useri1--;
    dwg_dynapi_header_set_value (dwg, "USERI1", &useri1, 0);

  }
  {
    BITCODE_BSd useri2;
    if (dwg_dynapi_header_value (dwg, "USERI2", &useri2, NULL)
        && useri2 == dwg->header_vars.USERI2)
      pass ();
    else
      fail ("HEADER.USERI2 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI2, useri2);
    useri2++;
    if (dwg_dynapi_header_set_value (dwg, "USERI2", &useri2, 0)
        && useri2 == dwg->header_vars.USERI2)
      pass ();
    else
      fail ("HEADER.USERI2 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.USERI2, useri2);
    useri2--;
    dwg_dynapi_header_set_value (dwg, "USERI2", &useri2, 0);

  }
  {
    BITCODE_BSd useri3;
    if (dwg_dynapi_header_value (dwg, "USERI3", &useri3, NULL)
        && useri3 == dwg->header_vars.USERI3)
      pass ();
    else
      fail ("HEADER.USERI3 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI3, useri3);
    useri3++;
    if (dwg_dynapi_header_set_value (dwg, "USERI3", &useri3, 0)
        && useri3 == dwg->header_vars.USERI3)
      pass ();
    else
      fail ("HEADER.USERI3 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.USERI3, useri3);
    useri3--;
    dwg_dynapi_header_set_value (dwg, "USERI3", &useri3, 0);

  }
  {
    BITCODE_BSd useri4;
    if (dwg_dynapi_header_value (dwg, "USERI4", &useri4, NULL)
        && useri4 == dwg->header_vars.USERI4)
      pass ();
    else
      fail ("HEADER.USERI4 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI4, useri4);
    useri4++;
    if (dwg_dynapi_header_set_value (dwg, "USERI4", &useri4, 0)
        && useri4 == dwg->header_vars.USERI4)
      pass ();
    else
      fail ("HEADER.USERI4 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.USERI4, useri4);
    useri4--;
    dwg_dynapi_header_set_value (dwg, "USERI4", &useri4, 0);

  }
  {
    BITCODE_BSd useri5;
    if (dwg_dynapi_header_value (dwg, "USERI5", &useri5, NULL)
        && useri5 == dwg->header_vars.USERI5)
      pass ();
    else
      fail ("HEADER.USERI5 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI5, useri5);
    useri5++;
    if (dwg_dynapi_header_set_value (dwg, "USERI5", &useri5, 0)
        && useri5 == dwg->header_vars.USERI5)
      pass ();
    else
      fail ("HEADER.USERI5 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.USERI5, useri5);
    useri5--;
    dwg_dynapi_header_set_value (dwg, "USERI5", &useri5, 0);

  }
  {
    BITCODE_BS splinesegs;
    if (dwg_dynapi_header_value (dwg, "SPLINESEGS", &splinesegs, NULL)
        && splinesegs == dwg->header_vars.SPLINESEGS)
      pass ();
    else
      fail ("HEADER.SPLINESEGS [BS] %hu != %hu", dwg->header_vars.SPLINESEGS, splinesegs);
    splinesegs++;
    if (dwg_dynapi_header_set_value (dwg, "SPLINESEGS", &splinesegs, 0)
        && splinesegs == dwg->header_vars.SPLINESEGS)
      pass ();
    else
      fail ("HEADER.SPLINESEGS [BS] set+1 %hu != %hu",
            dwg->header_vars.SPLINESEGS, splinesegs);
    splinesegs--;
    dwg_dynapi_header_set_value (dwg, "SPLINESEGS", &splinesegs, 0);

  }
  {
    BITCODE_BS surfu;
    if (dwg_dynapi_header_value (dwg, "SURFU", &surfu, NULL)
        && surfu == dwg->header_vars.SURFU)
      pass ();
    else
      fail ("HEADER.SURFU [BS] %hu != %hu", dwg->header_vars.SURFU, surfu);
    surfu++;
    if (dwg_dynapi_header_set_value (dwg, "SURFU", &surfu, 0)
        && surfu == dwg->header_vars.SURFU)
      pass ();
    else
      fail ("HEADER.SURFU [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFU, surfu);
    surfu--;
    dwg_dynapi_header_set_value (dwg, "SURFU", &surfu, 0);

  }
  {
    BITCODE_BS surfv;
    if (dwg_dynapi_header_value (dwg, "SURFV", &surfv, NULL)
        && surfv == dwg->header_vars.SURFV)
      pass ();
    else
      fail ("HEADER.SURFV [BS] %hu != %hu", dwg->header_vars.SURFV, surfv);
    surfv++;
    if (dwg_dynapi_header_set_value (dwg, "SURFV", &surfv, 0)
        && surfv == dwg->header_vars.SURFV)
      pass ();
    else
      fail ("HEADER.SURFV [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFV, surfv);
    surfv--;
    dwg_dynapi_header_set_value (dwg, "SURFV", &surfv, 0);

  }
  {
    BITCODE_BS surftype;
    if (dwg_dynapi_header_value (dwg, "SURFTYPE", &surftype, NULL)
        && surftype == dwg->header_vars.SURFTYPE)
      pass ();
    else
      fail ("HEADER.SURFTYPE [BS] %hu != %hu", dwg->header_vars.SURFTYPE, surftype);
    surftype++;
    if (dwg_dynapi_header_set_value (dwg, "SURFTYPE", &surftype, 0)
        && surftype == dwg->header_vars.SURFTYPE)
      pass ();
    else
      fail ("HEADER.SURFTYPE [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFTYPE, surftype);
    surftype--;
    dwg_dynapi_header_set_value (dwg, "SURFTYPE", &surftype, 0);

  }
  {
    BITCODE_BS surftab1;
    if (dwg_dynapi_header_value (dwg, "SURFTAB1", &surftab1, NULL)
        && surftab1 == dwg->header_vars.SURFTAB1)
      pass ();
    else
      fail ("HEADER.SURFTAB1 [BS] %hu != %hu", dwg->header_vars.SURFTAB1, surftab1);
    surftab1++;
    if (dwg_dynapi_header_set_value (dwg, "SURFTAB1", &surftab1, 0)
        && surftab1 == dwg->header_vars.SURFTAB1)
      pass ();
    else
      fail ("HEADER.SURFTAB1 [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFTAB1, surftab1);
    surftab1--;
    dwg_dynapi_header_set_value (dwg, "SURFTAB1", &surftab1, 0);

  }
  {
    BITCODE_BS surftab2;
    if (dwg_dynapi_header_value (dwg, "SURFTAB2", &surftab2, NULL)
        && surftab2 == dwg->header_vars.SURFTAB2)
      pass ();
    else
      fail ("HEADER.SURFTAB2 [BS] %hu != %hu", dwg->header_vars.SURFTAB2, surftab2);
    surftab2++;
    if (dwg_dynapi_header_set_value (dwg, "SURFTAB2", &surftab2, 0)
        && surftab2 == dwg->header_vars.SURFTAB2)
      pass ();
    else
      fail ("HEADER.SURFTAB2 [BS] set+1 %hu != %hu",
            dwg->header_vars.SURFTAB2, surftab2);
    surftab2--;
    dwg_dynapi_header_set_value (dwg, "SURFTAB2", &surftab2, 0);

  }
  {
    BITCODE_BS splinetype;
    if (dwg_dynapi_header_value (dwg, "SPLINETYPE", &splinetype, NULL)
        && splinetype == dwg->header_vars.SPLINETYPE)
      pass ();
    else
      fail ("HEADER.SPLINETYPE [BS] %hu != %hu", dwg->header_vars.SPLINETYPE, splinetype);
    splinetype++;
    if (dwg_dynapi_header_set_value (dwg, "SPLINETYPE", &splinetype, 0)
        && splinetype == dwg->header_vars.SPLINETYPE)
      pass ();
    else
      fail ("HEADER.SPLINETYPE [BS] set+1 %hu != %hu",
            dwg->header_vars.SPLINETYPE, splinetype);
    splinetype--;
    dwg_dynapi_header_set_value (dwg, "SPLINETYPE", &splinetype, 0);

  }
  {
    BITCODE_BS shadedge;
    if (dwg_dynapi_header_value (dwg, "SHADEDGE", &shadedge, NULL)
        && shadedge == dwg->header_vars.SHADEDGE)
      pass ();
    else
      fail ("HEADER.SHADEDGE [BS] %hu != %hu", dwg->header_vars.SHADEDGE, shadedge);
    shadedge++;
    if (dwg_dynapi_header_set_value (dwg, "SHADEDGE", &shadedge, 0)
        && shadedge == dwg->header_vars.SHADEDGE)
      pass ();
    else
      fail ("HEADER.SHADEDGE [BS] set+1 %hu != %hu",
            dwg->header_vars.SHADEDGE, shadedge);
    shadedge--;
    dwg_dynapi_header_set_value (dwg, "SHADEDGE", &shadedge, 0);

  }
  {
    BITCODE_BS shadedif;
    if (dwg_dynapi_header_value (dwg, "SHADEDIF", &shadedif, NULL)
        && shadedif == dwg->header_vars.SHADEDIF)
      pass ();
    else
      fail ("HEADER.SHADEDIF [BS] %hu != %hu", dwg->header_vars.SHADEDIF, shadedif);
    shadedif++;
    if (dwg_dynapi_header_set_value (dwg, "SHADEDIF", &shadedif, 0)
        && shadedif == dwg->header_vars.SHADEDIF)
      pass ();
    else
      fail ("HEADER.SHADEDIF [BS] set+1 %hu != %hu",
            dwg->header_vars.SHADEDIF, shadedif);
    shadedif--;
    dwg_dynapi_header_set_value (dwg, "SHADEDIF", &shadedif, 0);

  }
  {
    BITCODE_BS unitmode;
    if (dwg_dynapi_header_value (dwg, "UNITMODE", &unitmode, NULL)
        && unitmode == dwg->header_vars.UNITMODE)
      pass ();
    else
      fail ("HEADER.UNITMODE [BS] %hu != %hu", dwg->header_vars.UNITMODE, unitmode);
    unitmode++;
    if (dwg_dynapi_header_set_value (dwg, "UNITMODE", &unitmode, 0)
        && unitmode == dwg->header_vars.UNITMODE)
      pass ();
    else
      fail ("HEADER.UNITMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.UNITMODE, unitmode);
    unitmode--;
    dwg_dynapi_header_set_value (dwg, "UNITMODE", &unitmode, 0);

  }
  {
    BITCODE_BS maxactvp;
    if (dwg_dynapi_header_value (dwg, "MAXACTVP", &maxactvp, NULL)
        && maxactvp == dwg->header_vars.MAXACTVP)
      pass ();
    else
      fail ("HEADER.MAXACTVP [BS] %hu != %hu", dwg->header_vars.MAXACTVP, maxactvp);
    maxactvp++;
    if (dwg_dynapi_header_set_value (dwg, "MAXACTVP", &maxactvp, 0)
        && maxactvp == dwg->header_vars.MAXACTVP)
      pass ();
    else
      fail ("HEADER.MAXACTVP [BS] set+1 %hu != %hu",
            dwg->header_vars.MAXACTVP, maxactvp);
    maxactvp--;
    dwg_dynapi_header_set_value (dwg, "MAXACTVP", &maxactvp, 0);

  }
  {
    BITCODE_BS isolines;
    if (dwg_dynapi_header_value (dwg, "ISOLINES", &isolines, NULL)
        && isolines == dwg->header_vars.ISOLINES)
      pass ();
    else
      fail ("HEADER.ISOLINES [BS] %hu != %hu", dwg->header_vars.ISOLINES, isolines);
    isolines++;
    if (dwg_dynapi_header_set_value (dwg, "ISOLINES", &isolines, 0)
        && isolines == dwg->header_vars.ISOLINES)
      pass ();
    else
      fail ("HEADER.ISOLINES [BS] set+1 %hu != %hu",
            dwg->header_vars.ISOLINES, isolines);
    isolines--;
    dwg_dynapi_header_set_value (dwg, "ISOLINES", &isolines, 0);

  }
  {
    BITCODE_BS cmljust;
    if (dwg_dynapi_header_value (dwg, "CMLJUST", &cmljust, NULL)
        && cmljust == dwg->header_vars.CMLJUST)
      pass ();
    else
      fail ("HEADER.CMLJUST [BS] %hu != %hu", dwg->header_vars.CMLJUST, cmljust);
    cmljust++;
    if (dwg_dynapi_header_set_value (dwg, "CMLJUST", &cmljust, 0)
        && cmljust == dwg->header_vars.CMLJUST)
      pass ();
    else
      fail ("HEADER.CMLJUST [BS] set+1 %hu != %hu",
            dwg->header_vars.CMLJUST, cmljust);
    cmljust--;
    dwg_dynapi_header_set_value (dwg, "CMLJUST", &cmljust, 0);

  }
  {
    BITCODE_BS textqlty;
    if (dwg_dynapi_header_value (dwg, "TEXTQLTY", &textqlty, NULL)
        && textqlty == dwg->header_vars.TEXTQLTY)
      pass ();
    else
      fail ("HEADER.TEXTQLTY [BS] %hu != %hu", dwg->header_vars.TEXTQLTY, textqlty);
    textqlty++;
    if (dwg_dynapi_header_set_value (dwg, "TEXTQLTY", &textqlty, 0)
        && textqlty == dwg->header_vars.TEXTQLTY)
      pass ();
    else
      fail ("HEADER.TEXTQLTY [BS] set+1 %hu != %hu",
            dwg->header_vars.TEXTQLTY, textqlty);
    textqlty--;
    dwg_dynapi_header_set_value (dwg, "TEXTQLTY", &textqlty, 0);

  }
  {
    BITCODE_BL unknown_14b;
    if (dwg_dynapi_header_value (dwg, "unknown_14b", &unknown_14b, NULL)
        && unknown_14b == dwg->header_vars.unknown_14b)
      pass ();
    else
      fail ("HEADER.unknown_14b [BL] %u != %u", dwg->header_vars.unknown_14b, unknown_14b);
    unknown_14b++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_14b", &unknown_14b, 0)
        && unknown_14b == dwg->header_vars.unknown_14b)
      pass ();
    else
      fail ("HEADER.unknown_14b [BL] set+1 %u != %u",
            dwg->header_vars.unknown_14b, unknown_14b);
    unknown_14b--;
    dwg_dynapi_header_set_value (dwg, "unknown_14b", &unknown_14b, 0);

  }
  {
    BITCODE_BD ltscale;
    if (dwg_dynapi_header_value (dwg, "LTSCALE", &ltscale, NULL)
        && ltscale == dwg->header_vars.LTSCALE)
      pass ();
    else
      fail ("HEADER.LTSCALE [BD] %g != %g", dwg->header_vars.LTSCALE, ltscale);
    ltscale++;
    if (dwg_dynapi_header_set_value (dwg, "LTSCALE", &ltscale, 0)
        && ltscale == dwg->header_vars.LTSCALE)
      pass ();
    else
      fail ("HEADER.LTSCALE [BD] set+1 %g != %g",
            dwg->header_vars.LTSCALE, ltscale);
    ltscale--;
    dwg_dynapi_header_set_value (dwg, "LTSCALE", &ltscale, 0);

  }
  {
    BITCODE_BD textsize;
    if (dwg_dynapi_header_value (dwg, "TEXTSIZE", &textsize, NULL)
        && textsize == dwg->header_vars.TEXTSIZE)
      pass ();
    else
      fail ("HEADER.TEXTSIZE [BD] %g != %g", dwg->header_vars.TEXTSIZE, textsize);
    textsize++;
    if (dwg_dynapi_header_set_value (dwg, "TEXTSIZE", &textsize, 0)
        && textsize == dwg->header_vars.TEXTSIZE)
      pass ();
    else
      fail ("HEADER.TEXTSIZE [BD] set+1 %g != %g",
            dwg->header_vars.TEXTSIZE, textsize);
    textsize--;
    dwg_dynapi_header_set_value (dwg, "TEXTSIZE", &textsize, 0);

  }
  {
    BITCODE_BD tracewid;
    if (dwg_dynapi_header_value (dwg, "TRACEWID", &tracewid, NULL)
        && tracewid == dwg->header_vars.TRACEWID)
      pass ();
    else
      fail ("HEADER.TRACEWID [BD] %g != %g", dwg->header_vars.TRACEWID, tracewid);
    tracewid++;
    if (dwg_dynapi_header_set_value (dwg, "TRACEWID", &tracewid, 0)
        && tracewid == dwg->header_vars.TRACEWID)
      pass ();
    else
      fail ("HEADER.TRACEWID [BD] set+1 %g != %g",
            dwg->header_vars.TRACEWID, tracewid);
    tracewid--;
    dwg_dynapi_header_set_value (dwg, "TRACEWID", &tracewid, 0);

  }
  {
    BITCODE_BD sketchinc;
    if (dwg_dynapi_header_value (dwg, "SKETCHINC", &sketchinc, NULL)
        && sketchinc == dwg->header_vars.SKETCHINC)
      pass ();
    else
      fail ("HEADER.SKETCHINC [BD] %g != %g", dwg->header_vars.SKETCHINC, sketchinc);
    sketchinc++;
    if (dwg_dynapi_header_set_value (dwg, "SKETCHINC", &sketchinc, 0)
        && sketchinc == dwg->header_vars.SKETCHINC)
      pass ();
    else
      fail ("HEADER.SKETCHINC [BD] set+1 %g != %g",
            dwg->header_vars.SKETCHINC, sketchinc);
    sketchinc--;
    dwg_dynapi_header_set_value (dwg, "SKETCHINC", &sketchinc, 0);

  }
  {
    BITCODE_BD filletrad;
    if (dwg_dynapi_header_value (dwg, "FILLETRAD", &filletrad, NULL)
        && filletrad == dwg->header_vars.FILLETRAD)
      pass ();
    else
      fail ("HEADER.FILLETRAD [BD] %g != %g", dwg->header_vars.FILLETRAD, filletrad);
    filletrad++;
    if (dwg_dynapi_header_set_value (dwg, "FILLETRAD", &filletrad, 0)
        && filletrad == dwg->header_vars.FILLETRAD)
      pass ();
    else
      fail ("HEADER.FILLETRAD [BD] set+1 %g != %g",
            dwg->header_vars.FILLETRAD, filletrad);
    filletrad--;
    dwg_dynapi_header_set_value (dwg, "FILLETRAD", &filletrad, 0);

  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_header_value (dwg, "THICKNESS", &thickness, NULL)
        && thickness == dwg->header_vars.THICKNESS)
      pass ();
    else
      fail ("HEADER.THICKNESS [BD] %g != %g", dwg->header_vars.THICKNESS, thickness);
    thickness++;
    if (dwg_dynapi_header_set_value (dwg, "THICKNESS", &thickness, 0)
        && thickness == dwg->header_vars.THICKNESS)
      pass ();
    else
      fail ("HEADER.THICKNESS [BD] set+1 %g != %g",
            dwg->header_vars.THICKNESS, thickness);
    thickness--;
    dwg_dynapi_header_set_value (dwg, "THICKNESS", &thickness, 0);

  }
  {
    BITCODE_BD angbase;
    if (dwg_dynapi_header_value (dwg, "ANGBASE", &angbase, NULL)
        && angbase == dwg->header_vars.ANGBASE)
      pass ();
    else
      fail ("HEADER.ANGBASE [BD] %g != %g", dwg->header_vars.ANGBASE, angbase);
    angbase++;
    if (dwg_dynapi_header_set_value (dwg, "ANGBASE", &angbase, 0)
        && angbase == dwg->header_vars.ANGBASE)
      pass ();
    else
      fail ("HEADER.ANGBASE [BD] set+1 %g != %g",
            dwg->header_vars.ANGBASE, angbase);
    angbase--;
    dwg_dynapi_header_set_value (dwg, "ANGBASE", &angbase, 0);

  }
  {
    BITCODE_BD pdsize;
    if (dwg_dynapi_header_value (dwg, "PDSIZE", &pdsize, NULL)
        && pdsize == dwg->header_vars.PDSIZE)
      pass ();
    else
      fail ("HEADER.PDSIZE [BD] %g != %g", dwg->header_vars.PDSIZE, pdsize);
    pdsize++;
    if (dwg_dynapi_header_set_value (dwg, "PDSIZE", &pdsize, 0)
        && pdsize == dwg->header_vars.PDSIZE)
      pass ();
    else
      fail ("HEADER.PDSIZE [BD] set+1 %g != %g",
            dwg->header_vars.PDSIZE, pdsize);
    pdsize--;
    dwg_dynapi_header_set_value (dwg, "PDSIZE", &pdsize, 0);

  }
  {
    BITCODE_BD plinewid;
    if (dwg_dynapi_header_value (dwg, "PLINEWID", &plinewid, NULL)
        && plinewid == dwg->header_vars.PLINEWID)
      pass ();
    else
      fail ("HEADER.PLINEWID [BD] %g != %g", dwg->header_vars.PLINEWID, plinewid);
    plinewid++;
    if (dwg_dynapi_header_set_value (dwg, "PLINEWID", &plinewid, 0)
        && plinewid == dwg->header_vars.PLINEWID)
      pass ();
    else
      fail ("HEADER.PLINEWID [BD] set+1 %g != %g",
            dwg->header_vars.PLINEWID, plinewid);
    plinewid--;
    dwg_dynapi_header_set_value (dwg, "PLINEWID", &plinewid, 0);

  }
  {
    BITCODE_BD userr1;
    if (dwg_dynapi_header_value (dwg, "USERR1", &userr1, NULL)
        && userr1 == dwg->header_vars.USERR1)
      pass ();
    else
      fail ("HEADER.USERR1 [BD] %g != %g", dwg->header_vars.USERR1, userr1);
    userr1++;
    if (dwg_dynapi_header_set_value (dwg, "USERR1", &userr1, 0)
        && userr1 == dwg->header_vars.USERR1)
      pass ();
    else
      fail ("HEADER.USERR1 [BD] set+1 %g != %g",
            dwg->header_vars.USERR1, userr1);
    userr1--;
    dwg_dynapi_header_set_value (dwg, "USERR1", &userr1, 0);

  }
  {
    BITCODE_BD userr2;
    if (dwg_dynapi_header_value (dwg, "USERR2", &userr2, NULL)
        && userr2 == dwg->header_vars.USERR2)
      pass ();
    else
      fail ("HEADER.USERR2 [BD] %g != %g", dwg->header_vars.USERR2, userr2);
    userr2++;
    if (dwg_dynapi_header_set_value (dwg, "USERR2", &userr2, 0)
        && userr2 == dwg->header_vars.USERR2)
      pass ();
    else
      fail ("HEADER.USERR2 [BD] set+1 %g != %g",
            dwg->header_vars.USERR2, userr2);
    userr2--;
    dwg_dynapi_header_set_value (dwg, "USERR2", &userr2, 0);

  }
  {
    BITCODE_BD userr3;
    if (dwg_dynapi_header_value (dwg, "USERR3", &userr3, NULL)
        && userr3 == dwg->header_vars.USERR3)
      pass ();
    else
      fail ("HEADER.USERR3 [BD] %g != %g", dwg->header_vars.USERR3, userr3);
    userr3++;
    if (dwg_dynapi_header_set_value (dwg, "USERR3", &userr3, 0)
        && userr3 == dwg->header_vars.USERR3)
      pass ();
    else
      fail ("HEADER.USERR3 [BD] set+1 %g != %g",
            dwg->header_vars.USERR3, userr3);
    userr3--;
    dwg_dynapi_header_set_value (dwg, "USERR3", &userr3, 0);

  }
  {
    BITCODE_BD userr4;
    if (dwg_dynapi_header_value (dwg, "USERR4", &userr4, NULL)
        && userr4 == dwg->header_vars.USERR4)
      pass ();
    else
      fail ("HEADER.USERR4 [BD] %g != %g", dwg->header_vars.USERR4, userr4);
    userr4++;
    if (dwg_dynapi_header_set_value (dwg, "USERR4", &userr4, 0)
        && userr4 == dwg->header_vars.USERR4)
      pass ();
    else
      fail ("HEADER.USERR4 [BD] set+1 %g != %g",
            dwg->header_vars.USERR4, userr4);
    userr4--;
    dwg_dynapi_header_set_value (dwg, "USERR4", &userr4, 0);

  }
  {
    BITCODE_BD userr5;
    if (dwg_dynapi_header_value (dwg, "USERR5", &userr5, NULL)
        && userr5 == dwg->header_vars.USERR5)
      pass ();
    else
      fail ("HEADER.USERR5 [BD] %g != %g", dwg->header_vars.USERR5, userr5);
    userr5++;
    if (dwg_dynapi_header_set_value (dwg, "USERR5", &userr5, 0)
        && userr5 == dwg->header_vars.USERR5)
      pass ();
    else
      fail ("HEADER.USERR5 [BD] set+1 %g != %g",
            dwg->header_vars.USERR5, userr5);
    userr5--;
    dwg_dynapi_header_set_value (dwg, "USERR5", &userr5, 0);

  }
  {
    BITCODE_BD chamfera;
    if (dwg_dynapi_header_value (dwg, "CHAMFERA", &chamfera, NULL)
        && chamfera == dwg->header_vars.CHAMFERA)
      pass ();
    else
      fail ("HEADER.CHAMFERA [BD] %g != %g", dwg->header_vars.CHAMFERA, chamfera);
    chamfera++;
    if (dwg_dynapi_header_set_value (dwg, "CHAMFERA", &chamfera, 0)
        && chamfera == dwg->header_vars.CHAMFERA)
      pass ();
    else
      fail ("HEADER.CHAMFERA [BD] set+1 %g != %g",
            dwg->header_vars.CHAMFERA, chamfera);
    chamfera--;
    dwg_dynapi_header_set_value (dwg, "CHAMFERA", &chamfera, 0);

  }
  {
    BITCODE_BD chamferb;
    if (dwg_dynapi_header_value (dwg, "CHAMFERB", &chamferb, NULL)
        && chamferb == dwg->header_vars.CHAMFERB)
      pass ();
    else
      fail ("HEADER.CHAMFERB [BD] %g != %g", dwg->header_vars.CHAMFERB, chamferb);
    chamferb++;
    if (dwg_dynapi_header_set_value (dwg, "CHAMFERB", &chamferb, 0)
        && chamferb == dwg->header_vars.CHAMFERB)
      pass ();
    else
      fail ("HEADER.CHAMFERB [BD] set+1 %g != %g",
            dwg->header_vars.CHAMFERB, chamferb);
    chamferb--;
    dwg_dynapi_header_set_value (dwg, "CHAMFERB", &chamferb, 0);

  }
  {
    BITCODE_BD chamferc;
    if (dwg_dynapi_header_value (dwg, "CHAMFERC", &chamferc, NULL)
        && chamferc == dwg->header_vars.CHAMFERC)
      pass ();
    else
      fail ("HEADER.CHAMFERC [BD] %g != %g", dwg->header_vars.CHAMFERC, chamferc);
    chamferc++;
    if (dwg_dynapi_header_set_value (dwg, "CHAMFERC", &chamferc, 0)
        && chamferc == dwg->header_vars.CHAMFERC)
      pass ();
    else
      fail ("HEADER.CHAMFERC [BD] set+1 %g != %g",
            dwg->header_vars.CHAMFERC, chamferc);
    chamferc--;
    dwg_dynapi_header_set_value (dwg, "CHAMFERC", &chamferc, 0);

  }
  {
    BITCODE_BD chamferd;
    if (dwg_dynapi_header_value (dwg, "CHAMFERD", &chamferd, NULL)
        && chamferd == dwg->header_vars.CHAMFERD)
      pass ();
    else
      fail ("HEADER.CHAMFERD [BD] %g != %g", dwg->header_vars.CHAMFERD, chamferd);
    chamferd++;
    if (dwg_dynapi_header_set_value (dwg, "CHAMFERD", &chamferd, 0)
        && chamferd == dwg->header_vars.CHAMFERD)
      pass ();
    else
      fail ("HEADER.CHAMFERD [BD] set+1 %g != %g",
            dwg->header_vars.CHAMFERD, chamferd);
    chamferd--;
    dwg_dynapi_header_set_value (dwg, "CHAMFERD", &chamferd, 0);

  }
  {
    BITCODE_BD facetres;
    if (dwg_dynapi_header_value (dwg, "FACETRES", &facetres, NULL)
        && facetres == dwg->header_vars.FACETRES)
      pass ();
    else
      fail ("HEADER.FACETRES [BD] %g != %g", dwg->header_vars.FACETRES, facetres);
    facetres++;
    if (dwg_dynapi_header_set_value (dwg, "FACETRES", &facetres, 0)
        && facetres == dwg->header_vars.FACETRES)
      pass ();
    else
      fail ("HEADER.FACETRES [BD] set+1 %g != %g",
            dwg->header_vars.FACETRES, facetres);
    facetres--;
    dwg_dynapi_header_set_value (dwg, "FACETRES", &facetres, 0);

  }
  {
    BITCODE_BD cmlscale;
    if (dwg_dynapi_header_value (dwg, "CMLSCALE", &cmlscale, NULL)
        && cmlscale == dwg->header_vars.CMLSCALE)
      pass ();
    else
      fail ("HEADER.CMLSCALE [BD] %g != %g", dwg->header_vars.CMLSCALE, cmlscale);
    cmlscale++;
    if (dwg_dynapi_header_set_value (dwg, "CMLSCALE", &cmlscale, 0)
        && cmlscale == dwg->header_vars.CMLSCALE)
      pass ();
    else
      fail ("HEADER.CMLSCALE [BD] set+1 %g != %g",
            dwg->header_vars.CMLSCALE, cmlscale);
    cmlscale--;
    dwg_dynapi_header_set_value (dwg, "CMLSCALE", &cmlscale, 0);

  }
  {
    BITCODE_BD celtscale;
    if (dwg_dynapi_header_value (dwg, "CELTSCALE", &celtscale, NULL)
        && celtscale == dwg->header_vars.CELTSCALE)
      pass ();
    else
      fail ("HEADER.CELTSCALE [BD] %g != %g", dwg->header_vars.CELTSCALE, celtscale);
    celtscale++;
    if (dwg_dynapi_header_set_value (dwg, "CELTSCALE", &celtscale, 0)
        && celtscale == dwg->header_vars.CELTSCALE)
      pass ();
    else
      fail ("HEADER.CELTSCALE [BD] set+1 %g != %g",
            dwg->header_vars.CELTSCALE, celtscale);
    celtscale--;
    dwg_dynapi_header_set_value (dwg, "CELTSCALE", &celtscale, 0);

  }
  {
    BITCODE_BD viewtwist;
    if (dwg_dynapi_header_value (dwg, "VIEWTWIST", &viewtwist, NULL)
        && viewtwist == dwg->header_vars.VIEWTWIST)
      pass ();
    else
      fail ("HEADER.VIEWTWIST [BD] %g != %g", dwg->header_vars.VIEWTWIST, viewtwist);
    viewtwist++;
    if (dwg_dynapi_header_set_value (dwg, "VIEWTWIST", &viewtwist, 0)
        && viewtwist == dwg->header_vars.VIEWTWIST)
      pass ();
    else
      fail ("HEADER.VIEWTWIST [BD] set+1 %g != %g",
            dwg->header_vars.VIEWTWIST, viewtwist);
    viewtwist--;
    dwg_dynapi_header_set_value (dwg, "VIEWTWIST", &viewtwist, 0);

  }
  {
    BITCODE_TV menu;
    if (dwg_dynapi_header_value (dwg, "MENU", &menu, NULL)
        && !memcmp (&menu, &dwg->header_vars.MENU, sizeof (dwg->header_vars.MENU))
       )
      pass ();
    else
      fail ("HEADER.MENU [TV]");
  }
  {
    BITCODE_TIMEBLL tdcreate;
    if (dwg_dynapi_header_value (dwg, "TDCREATE", &tdcreate, NULL)
        && !memcmp (&tdcreate, &dwg->header_vars.TDCREATE, sizeof (dwg->header_vars.TDCREATE))
       )
      pass ();
    else
      fail ("HEADER.TDCREATE [TIMEBLL]");
  }
  {
    BITCODE_TIMEBLL tdupdate;
    if (dwg_dynapi_header_value (dwg, "TDUPDATE", &tdupdate, NULL)
        && !memcmp (&tdupdate, &dwg->header_vars.TDUPDATE, sizeof (dwg->header_vars.TDUPDATE))
       )
      pass ();
    else
      fail ("HEADER.TDUPDATE [TIMEBLL]");
  }
  {
    BITCODE_TIMEBLL tducreate;
    if (dwg_dynapi_header_value (dwg, "TDUCREATE", &tducreate, NULL)
        && !memcmp (&tducreate, &dwg->header_vars.TDUCREATE, sizeof (dwg->header_vars.TDUCREATE))
       )
      pass ();
    else
      fail ("HEADER.TDUCREATE [TIMEBLL]");
  }
  {
    BITCODE_TIMEBLL tduupdate;
    if (dwg_dynapi_header_value (dwg, "TDUUPDATE", &tduupdate, NULL)
        && !memcmp (&tduupdate, &dwg->header_vars.TDUUPDATE, sizeof (dwg->header_vars.TDUUPDATE))
       )
      pass ();
    else
      fail ("HEADER.TDUUPDATE [TIMEBLL]");
  }
  {
    BITCODE_BL unknown_15;
    if (dwg_dynapi_header_value (dwg, "unknown_15", &unknown_15, NULL)
        && unknown_15 == dwg->header_vars.unknown_15)
      pass ();
    else
      fail ("HEADER.unknown_15 [BL] %u != %u", dwg->header_vars.unknown_15, unknown_15);
    unknown_15++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_15", &unknown_15, 0)
        && unknown_15 == dwg->header_vars.unknown_15)
      pass ();
    else
      fail ("HEADER.unknown_15 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_15, unknown_15);
    unknown_15--;
    dwg_dynapi_header_set_value (dwg, "unknown_15", &unknown_15, 0);

  }
  {
    BITCODE_BL unknown_16;
    if (dwg_dynapi_header_value (dwg, "unknown_16", &unknown_16, NULL)
        && unknown_16 == dwg->header_vars.unknown_16)
      pass ();
    else
      fail ("HEADER.unknown_16 [BL] %u != %u", dwg->header_vars.unknown_16, unknown_16);
    unknown_16++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_16", &unknown_16, 0)
        && unknown_16 == dwg->header_vars.unknown_16)
      pass ();
    else
      fail ("HEADER.unknown_16 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_16, unknown_16);
    unknown_16--;
    dwg_dynapi_header_set_value (dwg, "unknown_16", &unknown_16, 0);

  }
  {
    BITCODE_BL unknown_17;
    if (dwg_dynapi_header_value (dwg, "unknown_17", &unknown_17, NULL)
        && unknown_17 == dwg->header_vars.unknown_17)
      pass ();
    else
      fail ("HEADER.unknown_17 [BL] %u != %u", dwg->header_vars.unknown_17, unknown_17);
    unknown_17++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_17", &unknown_17, 0)
        && unknown_17 == dwg->header_vars.unknown_17)
      pass ();
    else
      fail ("HEADER.unknown_17 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_17, unknown_17);
    unknown_17--;
    dwg_dynapi_header_set_value (dwg, "unknown_17", &unknown_17, 0);

  }
  {
    BITCODE_TIMEBLL tdindwg;
    if (dwg_dynapi_header_value (dwg, "TDINDWG", &tdindwg, NULL)
        && !memcmp (&tdindwg, &dwg->header_vars.TDINDWG, sizeof (dwg->header_vars.TDINDWG))
       )
      pass ();
    else
      fail ("HEADER.TDINDWG [TIMEBLL]");
  }
  {
    BITCODE_TIMEBLL tdusrtimer;
    if (dwg_dynapi_header_value (dwg, "TDUSRTIMER", &tdusrtimer, NULL)
        && !memcmp (&tdusrtimer, &dwg->header_vars.TDUSRTIMER, sizeof (dwg->header_vars.TDUSRTIMER))
       )
      pass ();
    else
      fail ("HEADER.TDUSRTIMER [TIMEBLL]");
  }
  {
    BITCODE_CMC cecolor;
    if (dwg_dynapi_header_value (dwg, "CECOLOR", &cecolor, NULL)
        && !memcmp (&cecolor, &dwg->header_vars.CECOLOR, sizeof (dwg->header_vars.CECOLOR))
       )
      pass ();
    else
      fail ("HEADER.CECOLOR [CMC]");
  }
  {
    BITCODE_BS handling;
    if (dwg_dynapi_header_value (dwg, "HANDLING", &handling, NULL)
        && handling == dwg->header_vars.HANDLING)
      pass ();
    else
      fail ("HEADER.HANDLING [BS] %hu != %hu", dwg->header_vars.HANDLING, handling);
    handling++;
    if (dwg_dynapi_header_set_value (dwg, "HANDLING", &handling, 0)
        && handling == dwg->header_vars.HANDLING)
      pass ();
    else
      fail ("HEADER.HANDLING [BS] set+1 %hu != %hu",
            dwg->header_vars.HANDLING, handling);
    handling--;
    dwg_dynapi_header_set_value (dwg, "HANDLING", &handling, 0);

  }
  {
    BITCODE_H handseed;
    if (dwg_dynapi_header_value (dwg, "HANDSEED", &handseed, NULL)
        && !memcmp (&handseed, &dwg->header_vars.HANDSEED, sizeof (dwg->header_vars.HANDSEED))
       )
      pass ();
    else
      fail ("HEADER.HANDSEED [H]");
  }
  {
    BITCODE_RL unknown_4f2;
    if (dwg_dynapi_header_value (dwg, "unknown_4f2", &unknown_4f2, NULL)
        && unknown_4f2 == dwg->header_vars.unknown_4f2)
      pass ();
    else
      fail ("HEADER.unknown_4f2 [RL] %u != %u", dwg->header_vars.unknown_4f2, unknown_4f2);
    unknown_4f2++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_4f2", &unknown_4f2, 0)
        && unknown_4f2 == dwg->header_vars.unknown_4f2)
      pass ();
    else
      fail ("HEADER.unknown_4f2 [RL] set+1 %u != %u",
            dwg->header_vars.unknown_4f2, unknown_4f2);
    unknown_4f2--;
    dwg_dynapi_header_set_value (dwg, "unknown_4f2", &unknown_4f2, 0);

  }
  {
    BITCODE_RS unknown_5;
    if (dwg_dynapi_header_value (dwg, "unknown_5", &unknown_5, NULL)
        && unknown_5 == dwg->header_vars.unknown_5)
      pass ();
    else
      fail ("HEADER.unknown_5 [RS] %hu != %hu", dwg->header_vars.unknown_5, unknown_5);
    unknown_5++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_5", &unknown_5, 0)
        && unknown_5 == dwg->header_vars.unknown_5)
      pass ();
    else
      fail ("HEADER.unknown_5 [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_5, unknown_5);
    unknown_5--;
    dwg_dynapi_header_set_value (dwg, "unknown_5", &unknown_5, 0);

  }
  {
    BITCODE_RS unknown_6;
    if (dwg_dynapi_header_value (dwg, "unknown_6", &unknown_6, NULL)
        && unknown_6 == dwg->header_vars.unknown_6)
      pass ();
    else
      fail ("HEADER.unknown_6 [RS] %hu != %hu", dwg->header_vars.unknown_6, unknown_6);
    unknown_6++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_6", &unknown_6, 0)
        && unknown_6 == dwg->header_vars.unknown_6)
      pass ();
    else
      fail ("HEADER.unknown_6 [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_6, unknown_6);
    unknown_6--;
    dwg_dynapi_header_set_value (dwg, "unknown_6", &unknown_6, 0);

  }
  {
    BITCODE_H clayer;
    if (dwg_dynapi_header_value (dwg, "CLAYER", &clayer, NULL)
        && !memcmp (&clayer, &dwg->header_vars.CLAYER, sizeof (dwg->header_vars.CLAYER))
       )
      pass ();
    else
      fail ("HEADER.CLAYER [H]");
  }
  {
    BITCODE_H textstyle;
    if (dwg_dynapi_header_value (dwg, "TEXTSTYLE", &textstyle, NULL)
        && !memcmp (&textstyle, &dwg->header_vars.TEXTSTYLE, sizeof (dwg->header_vars.TEXTSTYLE))
       )
      pass ();
    else
      fail ("HEADER.TEXTSTYLE [H]");
  }
  {
    BITCODE_H celtype;
    if (dwg_dynapi_header_value (dwg, "CELTYPE", &celtype, NULL)
        && !memcmp (&celtype, &dwg->header_vars.CELTYPE, sizeof (dwg->header_vars.CELTYPE))
       )
      pass ();
    else
      fail ("HEADER.CELTYPE [H]");
  }
  {
    BITCODE_H cmaterial;
    if (dwg_dynapi_header_value (dwg, "CMATERIAL", &cmaterial, NULL)
        && !memcmp (&cmaterial, &dwg->header_vars.CMATERIAL, sizeof (dwg->header_vars.CMATERIAL))
       )
      pass ();
    else
      fail ("HEADER.CMATERIAL [H]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_header_value (dwg, "DIMSTYLE", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dwg->header_vars.DIMSTYLE, sizeof (dwg->header_vars.DIMSTYLE))
       )
      pass ();
    else
      fail ("HEADER.DIMSTYLE [H]");
  }
  {
    BITCODE_H cmlstyle;
    if (dwg_dynapi_header_value (dwg, "CMLSTYLE", &cmlstyle, NULL)
        && !memcmp (&cmlstyle, &dwg->header_vars.CMLSTYLE, sizeof (dwg->header_vars.CMLSTYLE))
       )
      pass ();
    else
      fail ("HEADER.CMLSTYLE [H]");
  }
  {
    BITCODE_BD psvpscale;
    if (dwg_dynapi_header_value (dwg, "PSVPSCALE", &psvpscale, NULL)
        && psvpscale == dwg->header_vars.PSVPSCALE)
      pass ();
    else
      fail ("HEADER.PSVPSCALE [BD] %g != %g", dwg->header_vars.PSVPSCALE, psvpscale);
    psvpscale++;
    if (dwg_dynapi_header_set_value (dwg, "PSVPSCALE", &psvpscale, 0)
        && psvpscale == dwg->header_vars.PSVPSCALE)
      pass ();
    else
      fail ("HEADER.PSVPSCALE [BD] set+1 %g != %g",
            dwg->header_vars.PSVPSCALE, psvpscale);
    psvpscale--;
    dwg_dynapi_header_set_value (dwg, "PSVPSCALE", &psvpscale, 0);

  }
  {
    BITCODE_3BD pinsbase;
    if (dwg_dynapi_header_value (dwg, "PINSBASE", &pinsbase, NULL)
        && !memcmp (&pinsbase, &dwg->header_vars.PINSBASE, sizeof (dwg->header_vars.PINSBASE))
       )
      pass ();
    else
      fail ("HEADER.PINSBASE [3BD]");
  }
  {
    BITCODE_3BD pextmin;
    if (dwg_dynapi_header_value (dwg, "PEXTMIN", &pextmin, NULL)
        && !memcmp (&pextmin, &dwg->header_vars.PEXTMIN, sizeof (dwg->header_vars.PEXTMIN))
       )
      pass ();
    else
      fail ("HEADER.PEXTMIN [3BD]");
  }
  {
    BITCODE_3BD pextmax;
    if (dwg_dynapi_header_value (dwg, "PEXTMAX", &pextmax, NULL)
        && !memcmp (&pextmax, &dwg->header_vars.PEXTMAX, sizeof (dwg->header_vars.PEXTMAX))
       )
      pass ();
    else
      fail ("HEADER.PEXTMAX [3BD]");
  }
  {
    BITCODE_2DPOINT plimmin;
    if (dwg_dynapi_header_value (dwg, "PLIMMIN", &plimmin, NULL)
        && !memcmp (&plimmin, &dwg->header_vars.PLIMMIN, sizeof (dwg->header_vars.PLIMMIN))
       )
      pass ();
    else
      fail ("HEADER.PLIMMIN [2DPOINT]");
  }
  {
    BITCODE_2DPOINT plimmax;
    if (dwg_dynapi_header_value (dwg, "PLIMMAX", &plimmax, NULL)
        && !memcmp (&plimmax, &dwg->header_vars.PLIMMAX, sizeof (dwg->header_vars.PLIMMAX))
       )
      pass ();
    else
      fail ("HEADER.PLIMMAX [2DPOINT]");
  }
  {
    BITCODE_BD pelevation;
    if (dwg_dynapi_header_value (dwg, "PELEVATION", &pelevation, NULL)
        && pelevation == dwg->header_vars.PELEVATION)
      pass ();
    else
      fail ("HEADER.PELEVATION [BD] %g != %g", dwg->header_vars.PELEVATION, pelevation);
    pelevation++;
    if (dwg_dynapi_header_set_value (dwg, "PELEVATION", &pelevation, 0)
        && pelevation == dwg->header_vars.PELEVATION)
      pass ();
    else
      fail ("HEADER.PELEVATION [BD] set+1 %g != %g",
            dwg->header_vars.PELEVATION, pelevation);
    pelevation--;
    dwg_dynapi_header_set_value (dwg, "PELEVATION", &pelevation, 0);

  }
  {
    BITCODE_3BD pucsorg;
    if (dwg_dynapi_header_value (dwg, "PUCSORG", &pucsorg, NULL)
        && !memcmp (&pucsorg, &dwg->header_vars.PUCSORG, sizeof (dwg->header_vars.PUCSORG))
       )
      pass ();
    else
      fail ("HEADER.PUCSORG [3BD]");
  }
  {
    BITCODE_3BD pucsxdir;
    if (dwg_dynapi_header_value (dwg, "PUCSXDIR", &pucsxdir, NULL)
        && !memcmp (&pucsxdir, &dwg->header_vars.PUCSXDIR, sizeof (dwg->header_vars.PUCSXDIR))
       )
      pass ();
    else
      fail ("HEADER.PUCSXDIR [3BD]");
  }
  {
    BITCODE_3BD pucsydir;
    if (dwg_dynapi_header_value (dwg, "PUCSYDIR", &pucsydir, NULL)
        && !memcmp (&pucsydir, &dwg->header_vars.PUCSYDIR, sizeof (dwg->header_vars.PUCSYDIR))
       )
      pass ();
    else
      fail ("HEADER.PUCSYDIR [3BD]");
  }
  {
    BITCODE_H pucsname;
    if (dwg_dynapi_header_value (dwg, "PUCSNAME", &pucsname, NULL)
        && !memcmp (&pucsname, &dwg->header_vars.PUCSNAME, sizeof (dwg->header_vars.PUCSNAME))
       )
      pass ();
    else
      fail ("HEADER.PUCSNAME [H]");
  }
  {
    BITCODE_H pucsbase;
    if (dwg_dynapi_header_value (dwg, "PUCSBASE", &pucsbase, NULL)
        && !memcmp (&pucsbase, &dwg->header_vars.PUCSBASE, sizeof (dwg->header_vars.PUCSBASE))
       )
      pass ();
    else
      fail ("HEADER.PUCSBASE [H]");
  }
  {
    BITCODE_H pucsorthoref;
    if (dwg_dynapi_header_value (dwg, "PUCSORTHOREF", &pucsorthoref, NULL)
        && !memcmp (&pucsorthoref, &dwg->header_vars.PUCSORTHOREF, sizeof (dwg->header_vars.PUCSORTHOREF))
       )
      pass ();
    else
      fail ("HEADER.PUCSORTHOREF [H]");
  }
  {
    BITCODE_BS pucsorthoview;
    if (dwg_dynapi_header_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, NULL)
        && pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
      pass ();
    else
      fail ("HEADER.PUCSORTHOVIEW [BS] %hu != %hu", dwg->header_vars.PUCSORTHOVIEW, pucsorthoview);
    pucsorthoview++;
    if (dwg_dynapi_header_set_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, 0)
        && pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
      pass ();
    else
      fail ("HEADER.PUCSORTHOVIEW [BS] set+1 %hu != %hu",
            dwg->header_vars.PUCSORTHOVIEW, pucsorthoview);
    pucsorthoview--;
    dwg_dynapi_header_set_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, 0);

  }
  {
    BITCODE_3BD pucsorgtop;
    if (dwg_dynapi_header_value (dwg, "PUCSORGTOP", &pucsorgtop, NULL)
        && !memcmp (&pucsorgtop, &dwg->header_vars.PUCSORGTOP, sizeof (dwg->header_vars.PUCSORGTOP))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGTOP [3BD]");
  }
  {
    BITCODE_3BD pucsorgbottom;
    if (dwg_dynapi_header_value (dwg, "PUCSORGBOTTOM", &pucsorgbottom, NULL)
        && !memcmp (&pucsorgbottom, &dwg->header_vars.PUCSORGBOTTOM, sizeof (dwg->header_vars.PUCSORGBOTTOM))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGBOTTOM [3BD]");
  }
  {
    BITCODE_3BD pucsorgleft;
    if (dwg_dynapi_header_value (dwg, "PUCSORGLEFT", &pucsorgleft, NULL)
        && !memcmp (&pucsorgleft, &dwg->header_vars.PUCSORGLEFT, sizeof (dwg->header_vars.PUCSORGLEFT))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGLEFT [3BD]");
  }
  {
    BITCODE_3BD pucsorgright;
    if (dwg_dynapi_header_value (dwg, "PUCSORGRIGHT", &pucsorgright, NULL)
        && !memcmp (&pucsorgright, &dwg->header_vars.PUCSORGRIGHT, sizeof (dwg->header_vars.PUCSORGRIGHT))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGRIGHT [3BD]");
  }
  {
    BITCODE_3BD pucsorgfront;
    if (dwg_dynapi_header_value (dwg, "PUCSORGFRONT", &pucsorgfront, NULL)
        && !memcmp (&pucsorgfront, &dwg->header_vars.PUCSORGFRONT, sizeof (dwg->header_vars.PUCSORGFRONT))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGFRONT [3BD]");
  }
  {
    BITCODE_3BD pucsorgback;
    if (dwg_dynapi_header_value (dwg, "PUCSORGBACK", &pucsorgback, NULL)
        && !memcmp (&pucsorgback, &dwg->header_vars.PUCSORGBACK, sizeof (dwg->header_vars.PUCSORGBACK))
       )
      pass ();
    else
      fail ("HEADER.PUCSORGBACK [3BD]");
  }
  {
    BITCODE_3BD insbase;
    if (dwg_dynapi_header_value (dwg, "INSBASE", &insbase, NULL)
        && !memcmp (&insbase, &dwg->header_vars.INSBASE, sizeof (dwg->header_vars.INSBASE))
       )
      pass ();
    else
      fail ("HEADER.INSBASE [3BD]");
  }
  {
    BITCODE_3BD extmin;
    if (dwg_dynapi_header_value (dwg, "EXTMIN", &extmin, NULL)
        && !memcmp (&extmin, &dwg->header_vars.EXTMIN, sizeof (dwg->header_vars.EXTMIN))
       )
      pass ();
    else
      fail ("HEADER.EXTMIN [3BD]");
  }
  {
    BITCODE_3BD extmax;
    if (dwg_dynapi_header_value (dwg, "EXTMAX", &extmax, NULL)
        && !memcmp (&extmax, &dwg->header_vars.EXTMAX, sizeof (dwg->header_vars.EXTMAX))
       )
      pass ();
    else
      fail ("HEADER.EXTMAX [3BD]");
  }
  {
    BITCODE_3BD viewdir;
    if (dwg_dynapi_header_value (dwg, "VIEWDIR", &viewdir, NULL)
        && !memcmp (&viewdir, &dwg->header_vars.VIEWDIR, sizeof (dwg->header_vars.VIEWDIR))
       )
      pass ();
    else
      fail ("HEADER.VIEWDIR [3BD]");
  }
  {
    BITCODE_3BD target;
    if (dwg_dynapi_header_value (dwg, "TARGET", &target, NULL)
        && !memcmp (&target, &dwg->header_vars.TARGET, sizeof (dwg->header_vars.TARGET))
       )
      pass ();
    else
      fail ("HEADER.TARGET [3BD]");
  }
  {
    BITCODE_2DPOINT limmin;
    if (dwg_dynapi_header_value (dwg, "LIMMIN", &limmin, NULL)
        && !memcmp (&limmin, &dwg->header_vars.LIMMIN, sizeof (dwg->header_vars.LIMMIN))
       )
      pass ();
    else
      fail ("HEADER.LIMMIN [2DPOINT]");
  }
  {
    BITCODE_2DPOINT limmax;
    if (dwg_dynapi_header_value (dwg, "LIMMAX", &limmax, NULL)
        && !memcmp (&limmax, &dwg->header_vars.LIMMAX, sizeof (dwg->header_vars.LIMMAX))
       )
      pass ();
    else
      fail ("HEADER.LIMMAX [2DPOINT]");
  }
  {
    BITCODE_3RD viewctr;
    if (dwg_dynapi_header_value (dwg, "VIEWCTR", &viewctr, NULL)
        && !memcmp (&viewctr, &dwg->header_vars.VIEWCTR, sizeof (dwg->header_vars.VIEWCTR))
       )
      pass ();
    else
      fail ("HEADER.VIEWCTR [3RD]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_header_value (dwg, "ELEVATION", &elevation, NULL)
        && elevation == dwg->header_vars.ELEVATION)
      pass ();
    else
      fail ("HEADER.ELEVATION [BD] %g != %g", dwg->header_vars.ELEVATION, elevation);
    elevation++;
    if (dwg_dynapi_header_set_value (dwg, "ELEVATION", &elevation, 0)
        && elevation == dwg->header_vars.ELEVATION)
      pass ();
    else
      fail ("HEADER.ELEVATION [BD] set+1 %g != %g",
            dwg->header_vars.ELEVATION, elevation);
    elevation--;
    dwg_dynapi_header_set_value (dwg, "ELEVATION", &elevation, 0);

  }
  {
    BITCODE_RD viewsize;
    if (dwg_dynapi_header_value (dwg, "VIEWSIZE", &viewsize, NULL)
        && viewsize == dwg->header_vars.VIEWSIZE)
      pass ();
    else
      fail ("HEADER.VIEWSIZE [RD] %g != %g", dwg->header_vars.VIEWSIZE, viewsize);
    viewsize++;
    if (dwg_dynapi_header_set_value (dwg, "VIEWSIZE", &viewsize, 0)
        && viewsize == dwg->header_vars.VIEWSIZE)
      pass ();
    else
      fail ("HEADER.VIEWSIZE [RD] set+1 %g != %g",
            dwg->header_vars.VIEWSIZE, viewsize);
    viewsize--;
    dwg_dynapi_header_set_value (dwg, "VIEWSIZE", &viewsize, 0);

  }
  {
    BITCODE_RS snapmode;
    if (dwg_dynapi_header_value (dwg, "SNAPMODE", &snapmode, NULL)
        && snapmode == dwg->header_vars.SNAPMODE)
      pass ();
    else
      fail ("HEADER.SNAPMODE [RS] %hu != %hu", dwg->header_vars.SNAPMODE, snapmode);
    snapmode++;
    if (dwg_dynapi_header_set_value (dwg, "SNAPMODE", &snapmode, 0)
        && snapmode == dwg->header_vars.SNAPMODE)
      pass ();
    else
      fail ("HEADER.SNAPMODE [RS] set+1 %hu != %hu",
            dwg->header_vars.SNAPMODE, snapmode);
    snapmode--;
    dwg_dynapi_header_set_value (dwg, "SNAPMODE", &snapmode, 0);

  }
  {
    BITCODE_2RD snapunit;
    if (dwg_dynapi_header_value (dwg, "SNAPUNIT", &snapunit, NULL)
        && !memcmp (&snapunit, &dwg->header_vars.SNAPUNIT, sizeof (dwg->header_vars.SNAPUNIT))
       )
      pass ();
    else
      fail ("HEADER.SNAPUNIT [2RD]");
  }
  {
    BITCODE_2RD snapbase;
    if (dwg_dynapi_header_value (dwg, "SNAPBASE", &snapbase, NULL)
        && !memcmp (&snapbase, &dwg->header_vars.SNAPBASE, sizeof (dwg->header_vars.SNAPBASE))
       )
      pass ();
    else
      fail ("HEADER.SNAPBASE [2RD]");
  }
  {
    BITCODE_RD snapang;
    if (dwg_dynapi_header_value (dwg, "SNAPANG", &snapang, NULL)
        && snapang == dwg->header_vars.SNAPANG)
      pass ();
    else
      fail ("HEADER.SNAPANG [RD] %g != %g", dwg->header_vars.SNAPANG, snapang);
    snapang++;
    if (dwg_dynapi_header_set_value (dwg, "SNAPANG", &snapang, 0)
        && snapang == dwg->header_vars.SNAPANG)
      pass ();
    else
      fail ("HEADER.SNAPANG [RD] set+1 %g != %g",
            dwg->header_vars.SNAPANG, snapang);
    snapang--;
    dwg_dynapi_header_set_value (dwg, "SNAPANG", &snapang, 0);

  }
  {
    BITCODE_RS snapstyle;
    if (dwg_dynapi_header_value (dwg, "SNAPSTYLE", &snapstyle, NULL)
        && snapstyle == dwg->header_vars.SNAPSTYLE)
      pass ();
    else
      fail ("HEADER.SNAPSTYLE [RS] %hu != %hu", dwg->header_vars.SNAPSTYLE, snapstyle);
    snapstyle++;
    if (dwg_dynapi_header_set_value (dwg, "SNAPSTYLE", &snapstyle, 0)
        && snapstyle == dwg->header_vars.SNAPSTYLE)
      pass ();
    else
      fail ("HEADER.SNAPSTYLE [RS] set+1 %hu != %hu",
            dwg->header_vars.SNAPSTYLE, snapstyle);
    snapstyle--;
    dwg_dynapi_header_set_value (dwg, "SNAPSTYLE", &snapstyle, 0);

  }
  {
    BITCODE_RS snapisopair;
    if (dwg_dynapi_header_value (dwg, "SNAPISOPAIR", &snapisopair, NULL)
        && snapisopair == dwg->header_vars.SNAPISOPAIR)
      pass ();
    else
      fail ("HEADER.SNAPISOPAIR [RS] %hu != %hu", dwg->header_vars.SNAPISOPAIR, snapisopair);
    snapisopair++;
    if (dwg_dynapi_header_set_value (dwg, "SNAPISOPAIR", &snapisopair, 0)
        && snapisopair == dwg->header_vars.SNAPISOPAIR)
      pass ();
    else
      fail ("HEADER.SNAPISOPAIR [RS] set+1 %hu != %hu",
            dwg->header_vars.SNAPISOPAIR, snapisopair);
    snapisopair--;
    dwg_dynapi_header_set_value (dwg, "SNAPISOPAIR", &snapisopair, 0);

  }
  {
    BITCODE_RS gridmode;
    if (dwg_dynapi_header_value (dwg, "GRIDMODE", &gridmode, NULL)
        && gridmode == dwg->header_vars.GRIDMODE)
      pass ();
    else
      fail ("HEADER.GRIDMODE [RS] %hu != %hu", dwg->header_vars.GRIDMODE, gridmode);
    gridmode++;
    if (dwg_dynapi_header_set_value (dwg, "GRIDMODE", &gridmode, 0)
        && gridmode == dwg->header_vars.GRIDMODE)
      pass ();
    else
      fail ("HEADER.GRIDMODE [RS] set+1 %hu != %hu",
            dwg->header_vars.GRIDMODE, gridmode);
    gridmode--;
    dwg_dynapi_header_set_value (dwg, "GRIDMODE", &gridmode, 0);

  }
  {
    BITCODE_2RD gridunit;
    if (dwg_dynapi_header_value (dwg, "GRIDUNIT", &gridunit, NULL)
        && !memcmp (&gridunit, &dwg->header_vars.GRIDUNIT, sizeof (dwg->header_vars.GRIDUNIT))
       )
      pass ();
    else
      fail ("HEADER.GRIDUNIT [2RD]");
  }
  {
    BITCODE_BS axismode;
    if (dwg_dynapi_header_value (dwg, "AXISMODE", &axismode, NULL)
        && axismode == dwg->header_vars.AXISMODE)
      pass ();
    else
      fail ("HEADER.AXISMODE [BS] %hu != %hu", dwg->header_vars.AXISMODE, axismode);
    axismode++;
    if (dwg_dynapi_header_set_value (dwg, "AXISMODE", &axismode, 0)
        && axismode == dwg->header_vars.AXISMODE)
      pass ();
    else
      fail ("HEADER.AXISMODE [BS] set+1 %hu != %hu",
            dwg->header_vars.AXISMODE, axismode);
    axismode--;
    dwg_dynapi_header_set_value (dwg, "AXISMODE", &axismode, 0);

  }
  {
    BITCODE_2RD axisunit;
    if (dwg_dynapi_header_value (dwg, "AXISUNIT", &axisunit, NULL)
        && !memcmp (&axisunit, &dwg->header_vars.AXISUNIT, sizeof (dwg->header_vars.AXISUNIT))
       )
      pass ();
    else
      fail ("HEADER.AXISUNIT [2RD]");
  }
  {
    BITCODE_3RD vpointx;
    if (dwg_dynapi_header_value (dwg, "VPOINTX", &vpointx, NULL)
        && !memcmp (&vpointx, &dwg->header_vars.VPOINTX, sizeof (dwg->header_vars.VPOINTX))
       )
      pass ();
    else
      fail ("HEADER.VPOINTX [3RD]");
  }
  {
    BITCODE_3RD vpointy;
    if (dwg_dynapi_header_value (dwg, "VPOINTY", &vpointy, NULL)
        && !memcmp (&vpointy, &dwg->header_vars.VPOINTY, sizeof (dwg->header_vars.VPOINTY))
       )
      pass ();
    else
      fail ("HEADER.VPOINTY [3RD]");
  }
  {
    BITCODE_3RD vpointz;
    if (dwg_dynapi_header_value (dwg, "VPOINTZ", &vpointz, NULL)
        && !memcmp (&vpointz, &dwg->header_vars.VPOINTZ, sizeof (dwg->header_vars.VPOINTZ))
       )
      pass ();
    else
      fail ("HEADER.VPOINTZ [3RD]");
  }
  {
    BITCODE_3RD vpointxalt;
    if (dwg_dynapi_header_value (dwg, "VPOINTXALT", &vpointxalt, NULL)
        && !memcmp (&vpointxalt, &dwg->header_vars.VPOINTXALT, sizeof (dwg->header_vars.VPOINTXALT))
       )
      pass ();
    else
      fail ("HEADER.VPOINTXALT [3RD]");
  }
  {
    BITCODE_3RD vpointyalt;
    if (dwg_dynapi_header_value (dwg, "VPOINTYALT", &vpointyalt, NULL)
        && !memcmp (&vpointyalt, &dwg->header_vars.VPOINTYALT, sizeof (dwg->header_vars.VPOINTYALT))
       )
      pass ();
    else
      fail ("HEADER.VPOINTYALT [3RD]");
  }
  {
    BITCODE_3RD vpointzalt;
    if (dwg_dynapi_header_value (dwg, "VPOINTZALT", &vpointzalt, NULL)
        && !memcmp (&vpointzalt, &dwg->header_vars.VPOINTZALT, sizeof (dwg->header_vars.VPOINTZALT))
       )
      pass ();
    else
      fail ("HEADER.VPOINTZALT [3RD]");
  }
  {
    BITCODE_RS flag_3d;
    if (dwg_dynapi_header_value (dwg, "flag_3d", &flag_3d, NULL)
        && flag_3d == dwg->header_vars.flag_3d)
      pass ();
    else
      fail ("HEADER.flag_3d [RS] %hu != %hu", dwg->header_vars.flag_3d, flag_3d);
    flag_3d++;
    if (dwg_dynapi_header_set_value (dwg, "flag_3d", &flag_3d, 0)
        && flag_3d == dwg->header_vars.flag_3d)
      pass ();
    else
      fail ("HEADER.flag_3d [RS] set+1 %hu != %hu",
            dwg->header_vars.flag_3d, flag_3d);
    flag_3d--;
    dwg_dynapi_header_set_value (dwg, "flag_3d", &flag_3d, 0);

  }
  {
    BITCODE_3BD ucsorg;
    if (dwg_dynapi_header_value (dwg, "UCSORG", &ucsorg, NULL)
        && !memcmp (&ucsorg, &dwg->header_vars.UCSORG, sizeof (dwg->header_vars.UCSORG))
       )
      pass ();
    else
      fail ("HEADER.UCSORG [3BD]");
  }
  {
    BITCODE_3BD ucsxdir;
    if (dwg_dynapi_header_value (dwg, "UCSXDIR", &ucsxdir, NULL)
        && !memcmp (&ucsxdir, &dwg->header_vars.UCSXDIR, sizeof (dwg->header_vars.UCSXDIR))
       )
      pass ();
    else
      fail ("HEADER.UCSXDIR [3BD]");
  }
  {
    BITCODE_3BD ucsydir;
    if (dwg_dynapi_header_value (dwg, "UCSYDIR", &ucsydir, NULL)
        && !memcmp (&ucsydir, &dwg->header_vars.UCSYDIR, sizeof (dwg->header_vars.UCSYDIR))
       )
      pass ();
    else
      fail ("HEADER.UCSYDIR [3BD]");
  }
  {
    BITCODE_H ucsname;
    if (dwg_dynapi_header_value (dwg, "UCSNAME", &ucsname, NULL)
        && !memcmp (&ucsname, &dwg->header_vars.UCSNAME, sizeof (dwg->header_vars.UCSNAME))
       )
      pass ();
    else
      fail ("HEADER.UCSNAME [H]");
  }
  {
    BITCODE_H ucsbase;
    if (dwg_dynapi_header_value (dwg, "UCSBASE", &ucsbase, NULL)
        && !memcmp (&ucsbase, &dwg->header_vars.UCSBASE, sizeof (dwg->header_vars.UCSBASE))
       )
      pass ();
    else
      fail ("HEADER.UCSBASE [H]");
  }
  {
    BITCODE_BS ucsorthoview;
    if (dwg_dynapi_header_value (dwg, "UCSORTHOVIEW", &ucsorthoview, NULL)
        && ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
      pass ();
    else
      fail ("HEADER.UCSORTHOVIEW [BS] %hu != %hu", dwg->header_vars.UCSORTHOVIEW, ucsorthoview);
    ucsorthoview++;
    if (dwg_dynapi_header_set_value (dwg, "UCSORTHOVIEW", &ucsorthoview, 0)
        && ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
      pass ();
    else
      fail ("HEADER.UCSORTHOVIEW [BS] set+1 %hu != %hu",
            dwg->header_vars.UCSORTHOVIEW, ucsorthoview);
    ucsorthoview--;
    dwg_dynapi_header_set_value (dwg, "UCSORTHOVIEW", &ucsorthoview, 0);

  }
  {
    BITCODE_H ucsorthoref;
    if (dwg_dynapi_header_value (dwg, "UCSORTHOREF", &ucsorthoref, NULL)
        && !memcmp (&ucsorthoref, &dwg->header_vars.UCSORTHOREF, sizeof (dwg->header_vars.UCSORTHOREF))
       )
      pass ();
    else
      fail ("HEADER.UCSORTHOREF [H]");
  }
  {
    BITCODE_3BD ucsorgtop;
    if (dwg_dynapi_header_value (dwg, "UCSORGTOP", &ucsorgtop, NULL)
        && !memcmp (&ucsorgtop, &dwg->header_vars.UCSORGTOP, sizeof (dwg->header_vars.UCSORGTOP))
       )
      pass ();
    else
      fail ("HEADER.UCSORGTOP [3BD]");
  }
  {
    BITCODE_3BD ucsorgbottom;
    if (dwg_dynapi_header_value (dwg, "UCSORGBOTTOM", &ucsorgbottom, NULL)
        && !memcmp (&ucsorgbottom, &dwg->header_vars.UCSORGBOTTOM, sizeof (dwg->header_vars.UCSORGBOTTOM))
       )
      pass ();
    else
      fail ("HEADER.UCSORGBOTTOM [3BD]");
  }
  {
    BITCODE_3BD ucsorgleft;
    if (dwg_dynapi_header_value (dwg, "UCSORGLEFT", &ucsorgleft, NULL)
        && !memcmp (&ucsorgleft, &dwg->header_vars.UCSORGLEFT, sizeof (dwg->header_vars.UCSORGLEFT))
       )
      pass ();
    else
      fail ("HEADER.UCSORGLEFT [3BD]");
  }
  {
    BITCODE_3BD ucsorgright;
    if (dwg_dynapi_header_value (dwg, "UCSORGRIGHT", &ucsorgright, NULL)
        && !memcmp (&ucsorgright, &dwg->header_vars.UCSORGRIGHT, sizeof (dwg->header_vars.UCSORGRIGHT))
       )
      pass ();
    else
      fail ("HEADER.UCSORGRIGHT [3BD]");
  }
  {
    BITCODE_3BD ucsorgfront;
    if (dwg_dynapi_header_value (dwg, "UCSORGFRONT", &ucsorgfront, NULL)
        && !memcmp (&ucsorgfront, &dwg->header_vars.UCSORGFRONT, sizeof (dwg->header_vars.UCSORGFRONT))
       )
      pass ();
    else
      fail ("HEADER.UCSORGFRONT [3BD]");
  }
  {
    BITCODE_3BD ucsorgback;
    if (dwg_dynapi_header_value (dwg, "UCSORGBACK", &ucsorgback, NULL)
        && !memcmp (&ucsorgback, &dwg->header_vars.UCSORGBACK, sizeof (dwg->header_vars.UCSORGBACK))
       )
      pass ();
    else
      fail ("HEADER.UCSORGBACK [3BD]");
  }
  {
    BITCODE_TV dimpost;
    if (dwg_dynapi_header_value (dwg, "DIMPOST", &dimpost, NULL)
        && !memcmp (&dimpost, &dwg->header_vars.DIMPOST, sizeof (dwg->header_vars.DIMPOST))
       )
      pass ();
    else
      fail ("HEADER.DIMPOST [TV]");
  }
  {
    BITCODE_TV dimapost;
    if (dwg_dynapi_header_value (dwg, "DIMAPOST", &dimapost, NULL)
        && !memcmp (&dimapost, &dwg->header_vars.DIMAPOST, sizeof (dwg->header_vars.DIMAPOST))
       )
      pass ();
    else
      fail ("HEADER.DIMAPOST [TV]");
  }
  {
    BITCODE_B dimtol;
    if (dwg_dynapi_header_value (dwg, "DIMTOL", &dimtol, NULL)
        && dimtol == dwg->header_vars.DIMTOL)
      pass ();
    else
      fail ("HEADER.DIMTOL [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOL, dimtol);
    dimtol++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTOL", &dimtol, 0)
        && dimtol == dwg->header_vars.DIMTOL)
      pass ();
    else
      fail ("HEADER.DIMTOL [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTOL, dimtol);
    dimtol--;
    dwg_dynapi_header_set_value (dwg, "DIMTOL", &dimtol, 0);

  }
  {
    BITCODE_B dimlim;
    if (dwg_dynapi_header_value (dwg, "DIMLIM", &dimlim, NULL)
        && dimlim == dwg->header_vars.DIMLIM)
      pass ();
    else
      fail ("HEADER.DIMLIM [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMLIM, dimlim);
    dimlim++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLIM", &dimlim, 0)
        && dimlim == dwg->header_vars.DIMLIM)
      pass ();
    else
      fail ("HEADER.DIMLIM [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMLIM, dimlim);
    dimlim--;
    dwg_dynapi_header_set_value (dwg, "DIMLIM", &dimlim, 0);

  }
  {
    BITCODE_B dimtih;
    if (dwg_dynapi_header_value (dwg, "DIMTIH", &dimtih, NULL)
        && dimtih == dwg->header_vars.DIMTIH)
      pass ();
    else
      fail ("HEADER.DIMTIH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIH, dimtih);
    dimtih++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTIH", &dimtih, 0)
        && dimtih == dwg->header_vars.DIMTIH)
      pass ();
    else
      fail ("HEADER.DIMTIH [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTIH, dimtih);
    dimtih--;
    dwg_dynapi_header_set_value (dwg, "DIMTIH", &dimtih, 0);

  }
  {
    BITCODE_B dimtoh;
    if (dwg_dynapi_header_value (dwg, "DIMTOH", &dimtoh, NULL)
        && dimtoh == dwg->header_vars.DIMTOH)
      pass ();
    else
      fail ("HEADER.DIMTOH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOH, dimtoh);
    dimtoh++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTOH", &dimtoh, 0)
        && dimtoh == dwg->header_vars.DIMTOH)
      pass ();
    else
      fail ("HEADER.DIMTOH [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTOH, dimtoh);
    dimtoh--;
    dwg_dynapi_header_set_value (dwg, "DIMTOH", &dimtoh, 0);

  }
  {
    BITCODE_B dimse1;
    if (dwg_dynapi_header_value (dwg, "DIMSE1", &dimse1, NULL)
        && dimse1 == dwg->header_vars.DIMSE1)
      pass ();
    else
      fail ("HEADER.DIMSE1 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE1, dimse1);
    dimse1++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSE1", &dimse1, 0)
        && dimse1 == dwg->header_vars.DIMSE1)
      pass ();
    else
      fail ("HEADER.DIMSE1 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSE1, dimse1);
    dimse1--;
    dwg_dynapi_header_set_value (dwg, "DIMSE1", &dimse1, 0);

  }
  {
    BITCODE_B dimse2;
    if (dwg_dynapi_header_value (dwg, "DIMSE2", &dimse2, NULL)
        && dimse2 == dwg->header_vars.DIMSE2)
      pass ();
    else
      fail ("HEADER.DIMSE2 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE2, dimse2);
    dimse2++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSE2", &dimse2, 0)
        && dimse2 == dwg->header_vars.DIMSE2)
      pass ();
    else
      fail ("HEADER.DIMSE2 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSE2, dimse2);
    dimse2--;
    dwg_dynapi_header_set_value (dwg, "DIMSE2", &dimse2, 0);

  }
  {
    BITCODE_B dimalt;
    if (dwg_dynapi_header_value (dwg, "DIMALT", &dimalt, NULL)
        && dimalt == dwg->header_vars.DIMALT)
      pass ();
    else
      fail ("HEADER.DIMALT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMALT, dimalt);
    dimalt++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALT", &dimalt, 0)
        && dimalt == dwg->header_vars.DIMALT)
      pass ();
    else
      fail ("HEADER.DIMALT [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMALT, dimalt);
    dimalt--;
    dwg_dynapi_header_set_value (dwg, "DIMALT", &dimalt, 0);

  }
  {
    BITCODE_B dimtofl;
    if (dwg_dynapi_header_value (dwg, "DIMTOFL", &dimtofl, NULL)
        && dimtofl == dwg->header_vars.DIMTOFL)
      pass ();
    else
      fail ("HEADER.DIMTOFL [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOFL, dimtofl);
    dimtofl++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTOFL", &dimtofl, 0)
        && dimtofl == dwg->header_vars.DIMTOFL)
      pass ();
    else
      fail ("HEADER.DIMTOFL [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTOFL, dimtofl);
    dimtofl--;
    dwg_dynapi_header_set_value (dwg, "DIMTOFL", &dimtofl, 0);

  }
  {
    BITCODE_B dimsah;
    if (dwg_dynapi_header_value (dwg, "DIMSAH", &dimsah, NULL)
        && dimsah == dwg->header_vars.DIMSAH)
      pass ();
    else
      fail ("HEADER.DIMSAH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAH, dimsah);
    dimsah++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSAH", &dimsah, 0)
        && dimsah == dwg->header_vars.DIMSAH)
      pass ();
    else
      fail ("HEADER.DIMSAH [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSAH, dimsah);
    dimsah--;
    dwg_dynapi_header_set_value (dwg, "DIMSAH", &dimsah, 0);

  }
  {
    BITCODE_B dimtix;
    if (dwg_dynapi_header_value (dwg, "DIMTIX", &dimtix, NULL)
        && dimtix == dwg->header_vars.DIMTIX)
      pass ();
    else
      fail ("HEADER.DIMTIX [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIX, dimtix);
    dimtix++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTIX", &dimtix, 0)
        && dimtix == dwg->header_vars.DIMTIX)
      pass ();
    else
      fail ("HEADER.DIMTIX [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTIX, dimtix);
    dimtix--;
    dwg_dynapi_header_set_value (dwg, "DIMTIX", &dimtix, 0);

  }
  {
    BITCODE_B dimsoxd;
    if (dwg_dynapi_header_value (dwg, "DIMSOXD", &dimsoxd, NULL)
        && dimsoxd == dwg->header_vars.DIMSOXD)
      pass ();
    else
      fail ("HEADER.DIMSOXD [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSOXD, dimsoxd);
    dimsoxd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSOXD", &dimsoxd, 0)
        && dimsoxd == dwg->header_vars.DIMSOXD)
      pass ();
    else
      fail ("HEADER.DIMSOXD [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSOXD, dimsoxd);
    dimsoxd--;
    dwg_dynapi_header_set_value (dwg, "DIMSOXD", &dimsoxd, 0);

  }
  {
    BITCODE_BS dimaltd;
    if (dwg_dynapi_header_value (dwg, "DIMALTD", &dimaltd, NULL)
        && dimaltd == dwg->header_vars.DIMALTD)
      pass ();
    else
      fail ("HEADER.DIMALTD [BS] %hu != %hu", dwg->header_vars.DIMALTD, dimaltd);
    dimaltd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTD", &dimaltd, 0)
        && dimaltd == dwg->header_vars.DIMALTD)
      pass ();
    else
      fail ("HEADER.DIMALTD [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTD, dimaltd);
    dimaltd--;
    dwg_dynapi_header_set_value (dwg, "DIMALTD", &dimaltd, 0);

  }
  {
    BITCODE_BS dimzin;
    if (dwg_dynapi_header_value (dwg, "DIMZIN", &dimzin, NULL)
        && dimzin == dwg->header_vars.DIMZIN)
      pass ();
    else
      fail ("HEADER.DIMZIN [BS] %hu != %hu", dwg->header_vars.DIMZIN, dimzin);
    dimzin++;
    if (dwg_dynapi_header_set_value (dwg, "DIMZIN", &dimzin, 0)
        && dimzin == dwg->header_vars.DIMZIN)
      pass ();
    else
      fail ("HEADER.DIMZIN [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMZIN, dimzin);
    dimzin--;
    dwg_dynapi_header_set_value (dwg, "DIMZIN", &dimzin, 0);

  }
  {
    BITCODE_B dimsd1;
    if (dwg_dynapi_header_value (dwg, "DIMSD1", &dimsd1, NULL)
        && dimsd1 == dwg->header_vars.DIMSD1)
      pass ();
    else
      fail ("HEADER.DIMSD1 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD1, dimsd1);
    dimsd1++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSD1", &dimsd1, 0)
        && dimsd1 == dwg->header_vars.DIMSD1)
      pass ();
    else
      fail ("HEADER.DIMSD1 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSD1, dimsd1);
    dimsd1--;
    dwg_dynapi_header_set_value (dwg, "DIMSD1", &dimsd1, 0);

  }
  {
    BITCODE_B dimsd2;
    if (dwg_dynapi_header_value (dwg, "DIMSD2", &dimsd2, NULL)
        && dimsd2 == dwg->header_vars.DIMSD2)
      pass ();
    else
      fail ("HEADER.DIMSD2 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD2, dimsd2);
    dimsd2++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSD2", &dimsd2, 0)
        && dimsd2 == dwg->header_vars.DIMSD2)
      pass ();
    else
      fail ("HEADER.DIMSD2 [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMSD2, dimsd2);
    dimsd2--;
    dwg_dynapi_header_set_value (dwg, "DIMSD2", &dimsd2, 0);

  }
  {
    BITCODE_BS dimtolj;
    if (dwg_dynapi_header_value (dwg, "DIMTOLJ", &dimtolj, NULL)
        && dimtolj == dwg->header_vars.DIMTOLJ)
      pass ();
    else
      fail ("HEADER.DIMTOLJ [BS] %hu != %hu", dwg->header_vars.DIMTOLJ, dimtolj);
    dimtolj++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTOLJ", &dimtolj, 0)
        && dimtolj == dwg->header_vars.DIMTOLJ)
      pass ();
    else
      fail ("HEADER.DIMTOLJ [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTOLJ, dimtolj);
    dimtolj--;
    dwg_dynapi_header_set_value (dwg, "DIMTOLJ", &dimtolj, 0);

  }
  {
    BITCODE_BS dimjust;
    if (dwg_dynapi_header_value (dwg, "DIMJUST", &dimjust, NULL)
        && dimjust == dwg->header_vars.DIMJUST)
      pass ();
    else
      fail ("HEADER.DIMJUST [BS] %hu != %hu", dwg->header_vars.DIMJUST, dimjust);
    dimjust++;
    if (dwg_dynapi_header_set_value (dwg, "DIMJUST", &dimjust, 0)
        && dimjust == dwg->header_vars.DIMJUST)
      pass ();
    else
      fail ("HEADER.DIMJUST [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMJUST, dimjust);
    dimjust--;
    dwg_dynapi_header_set_value (dwg, "DIMJUST", &dimjust, 0);

  }
  {
    BITCODE_BS dimfit;
    if (dwg_dynapi_header_value (dwg, "DIMFIT", &dimfit, NULL)
        && dimfit == dwg->header_vars.DIMFIT)
      pass ();
    else
      fail ("HEADER.DIMFIT [BS] %hu != %hu", dwg->header_vars.DIMFIT, dimfit);
    dimfit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMFIT", &dimfit, 0)
        && dimfit == dwg->header_vars.DIMFIT)
      pass ();
    else
      fail ("HEADER.DIMFIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMFIT, dimfit);
    dimfit--;
    dwg_dynapi_header_set_value (dwg, "DIMFIT", &dimfit, 0);

  }
  {
    BITCODE_B dimupt;
    if (dwg_dynapi_header_value (dwg, "DIMUPT", &dimupt, NULL)
        && dimupt == dwg->header_vars.DIMUPT)
      pass ();
    else
      fail ("HEADER.DIMUPT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMUPT, dimupt);
    dimupt++;
    if (dwg_dynapi_header_set_value (dwg, "DIMUPT", &dimupt, 0)
        && dimupt == dwg->header_vars.DIMUPT)
      pass ();
    else
      fail ("HEADER.DIMUPT [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMUPT, dimupt);
    dimupt--;
    dwg_dynapi_header_set_value (dwg, "DIMUPT", &dimupt, 0);

  }
  {
    BITCODE_BS dimtzin;
    if (dwg_dynapi_header_value (dwg, "DIMTZIN", &dimtzin, NULL)
        && dimtzin == dwg->header_vars.DIMTZIN)
      pass ();
    else
      fail ("HEADER.DIMTZIN [BS] %hu != %hu", dwg->header_vars.DIMTZIN, dimtzin);
    dimtzin++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTZIN", &dimtzin, 0)
        && dimtzin == dwg->header_vars.DIMTZIN)
      pass ();
    else
      fail ("HEADER.DIMTZIN [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTZIN, dimtzin);
    dimtzin--;
    dwg_dynapi_header_set_value (dwg, "DIMTZIN", &dimtzin, 0);

  }
  {
    BITCODE_BS dimtad;
    if (dwg_dynapi_header_value (dwg, "DIMTAD", &dimtad, NULL)
        && dimtad == dwg->header_vars.DIMTAD)
      pass ();
    else
      fail ("HEADER.DIMTAD [BS] %hu != %hu", dwg->header_vars.DIMTAD, dimtad);
    dimtad++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTAD", &dimtad, 0)
        && dimtad == dwg->header_vars.DIMTAD)
      pass ();
    else
      fail ("HEADER.DIMTAD [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTAD, dimtad);
    dimtad--;
    dwg_dynapi_header_set_value (dwg, "DIMTAD", &dimtad, 0);

  }
  {
    BITCODE_BS dimunit;
    if (dwg_dynapi_header_value (dwg, "DIMUNIT", &dimunit, NULL)
        && dimunit == dwg->header_vars.DIMUNIT)
      pass ();
    else
      fail ("HEADER.DIMUNIT [BS] %hu != %hu", dwg->header_vars.DIMUNIT, dimunit);
    dimunit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMUNIT", &dimunit, 0)
        && dimunit == dwg->header_vars.DIMUNIT)
      pass ();
    else
      fail ("HEADER.DIMUNIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMUNIT, dimunit);
    dimunit--;
    dwg_dynapi_header_set_value (dwg, "DIMUNIT", &dimunit, 0);

  }
  {
    BITCODE_BS dimaunit;
    if (dwg_dynapi_header_value (dwg, "DIMAUNIT", &dimaunit, NULL)
        && dimaunit == dwg->header_vars.DIMAUNIT)
      pass ();
    else
      fail ("HEADER.DIMAUNIT [BS] %hu != %hu", dwg->header_vars.DIMAUNIT, dimaunit);
    dimaunit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMAUNIT", &dimaunit, 0)
        && dimaunit == dwg->header_vars.DIMAUNIT)
      pass ();
    else
      fail ("HEADER.DIMAUNIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMAUNIT, dimaunit);
    dimaunit--;
    dwg_dynapi_header_set_value (dwg, "DIMAUNIT", &dimaunit, 0);

  }
  {
    BITCODE_BS dimdec;
    if (dwg_dynapi_header_value (dwg, "DIMDEC", &dimdec, NULL)
        && dimdec == dwg->header_vars.DIMDEC)
      pass ();
    else
      fail ("HEADER.DIMDEC [BS] %hu != %hu", dwg->header_vars.DIMDEC, dimdec);
    dimdec++;
    if (dwg_dynapi_header_set_value (dwg, "DIMDEC", &dimdec, 0)
        && dimdec == dwg->header_vars.DIMDEC)
      pass ();
    else
      fail ("HEADER.DIMDEC [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMDEC, dimdec);
    dimdec--;
    dwg_dynapi_header_set_value (dwg, "DIMDEC", &dimdec, 0);

  }
  {
    BITCODE_BS dimtdec;
    if (dwg_dynapi_header_value (dwg, "DIMTDEC", &dimtdec, NULL)
        && dimtdec == dwg->header_vars.DIMTDEC)
      pass ();
    else
      fail ("HEADER.DIMTDEC [BS] %hu != %hu", dwg->header_vars.DIMTDEC, dimtdec);
    dimtdec++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTDEC", &dimtdec, 0)
        && dimtdec == dwg->header_vars.DIMTDEC)
      pass ();
    else
      fail ("HEADER.DIMTDEC [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTDEC, dimtdec);
    dimtdec--;
    dwg_dynapi_header_set_value (dwg, "DIMTDEC", &dimtdec, 0);

  }
  {
    BITCODE_BS dimaltu;
    if (dwg_dynapi_header_value (dwg, "DIMALTU", &dimaltu, NULL)
        && dimaltu == dwg->header_vars.DIMALTU)
      pass ();
    else
      fail ("HEADER.DIMALTU [BS] %hu != %hu", dwg->header_vars.DIMALTU, dimaltu);
    dimaltu++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTU", &dimaltu, 0)
        && dimaltu == dwg->header_vars.DIMALTU)
      pass ();
    else
      fail ("HEADER.DIMALTU [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTU, dimaltu);
    dimaltu--;
    dwg_dynapi_header_set_value (dwg, "DIMALTU", &dimaltu, 0);

  }
  {
    BITCODE_BS dimalttd;
    if (dwg_dynapi_header_value (dwg, "DIMALTTD", &dimalttd, NULL)
        && dimalttd == dwg->header_vars.DIMALTTD)
      pass ();
    else
      fail ("HEADER.DIMALTTD [BS] %hu != %hu", dwg->header_vars.DIMALTTD, dimalttd);
    dimalttd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTTD", &dimalttd, 0)
        && dimalttd == dwg->header_vars.DIMALTTD)
      pass ();
    else
      fail ("HEADER.DIMALTTD [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTTD, dimalttd);
    dimalttd--;
    dwg_dynapi_header_set_value (dwg, "DIMALTTD", &dimalttd, 0);

  }
  {
    BITCODE_H dimtxsty;
    if (dwg_dynapi_header_value (dwg, "DIMTXSTY", &dimtxsty, NULL)
        && !memcmp (&dimtxsty, &dwg->header_vars.DIMTXSTY, sizeof (dwg->header_vars.DIMTXSTY))
       )
      pass ();
    else
      fail ("HEADER.DIMTXSTY [H]");
  }
  {
    BITCODE_BD dimscale;
    if (dwg_dynapi_header_value (dwg, "DIMSCALE", &dimscale, NULL)
        && dimscale == dwg->header_vars.DIMSCALE)
      pass ();
    else
      fail ("HEADER.DIMSCALE [BD] %g != %g", dwg->header_vars.DIMSCALE, dimscale);
    dimscale++;
    if (dwg_dynapi_header_set_value (dwg, "DIMSCALE", &dimscale, 0)
        && dimscale == dwg->header_vars.DIMSCALE)
      pass ();
    else
      fail ("HEADER.DIMSCALE [BD] set+1 %g != %g",
            dwg->header_vars.DIMSCALE, dimscale);
    dimscale--;
    dwg_dynapi_header_set_value (dwg, "DIMSCALE", &dimscale, 0);

  }
  {
    BITCODE_BD dimasz;
    if (dwg_dynapi_header_value (dwg, "DIMASZ", &dimasz, NULL)
        && dimasz == dwg->header_vars.DIMASZ)
      pass ();
    else
      fail ("HEADER.DIMASZ [BD] %g != %g", dwg->header_vars.DIMASZ, dimasz);
    dimasz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMASZ", &dimasz, 0)
        && dimasz == dwg->header_vars.DIMASZ)
      pass ();
    else
      fail ("HEADER.DIMASZ [BD] set+1 %g != %g",
            dwg->header_vars.DIMASZ, dimasz);
    dimasz--;
    dwg_dynapi_header_set_value (dwg, "DIMASZ", &dimasz, 0);

  }
  {
    BITCODE_BD dimexo;
    if (dwg_dynapi_header_value (dwg, "DIMEXO", &dimexo, NULL)
        && dimexo == dwg->header_vars.DIMEXO)
      pass ();
    else
      fail ("HEADER.DIMEXO [BD] %g != %g", dwg->header_vars.DIMEXO, dimexo);
    dimexo++;
    if (dwg_dynapi_header_set_value (dwg, "DIMEXO", &dimexo, 0)
        && dimexo == dwg->header_vars.DIMEXO)
      pass ();
    else
      fail ("HEADER.DIMEXO [BD] set+1 %g != %g",
            dwg->header_vars.DIMEXO, dimexo);
    dimexo--;
    dwg_dynapi_header_set_value (dwg, "DIMEXO", &dimexo, 0);

  }
  {
    BITCODE_BD dimdli;
    if (dwg_dynapi_header_value (dwg, "DIMDLI", &dimdli, NULL)
        && dimdli == dwg->header_vars.DIMDLI)
      pass ();
    else
      fail ("HEADER.DIMDLI [BD] %g != %g", dwg->header_vars.DIMDLI, dimdli);
    dimdli++;
    if (dwg_dynapi_header_set_value (dwg, "DIMDLI", &dimdli, 0)
        && dimdli == dwg->header_vars.DIMDLI)
      pass ();
    else
      fail ("HEADER.DIMDLI [BD] set+1 %g != %g",
            dwg->header_vars.DIMDLI, dimdli);
    dimdli--;
    dwg_dynapi_header_set_value (dwg, "DIMDLI", &dimdli, 0);

  }
  {
    BITCODE_BD dimexe;
    if (dwg_dynapi_header_value (dwg, "DIMEXE", &dimexe, NULL)
        && dimexe == dwg->header_vars.DIMEXE)
      pass ();
    else
      fail ("HEADER.DIMEXE [BD] %g != %g", dwg->header_vars.DIMEXE, dimexe);
    dimexe++;
    if (dwg_dynapi_header_set_value (dwg, "DIMEXE", &dimexe, 0)
        && dimexe == dwg->header_vars.DIMEXE)
      pass ();
    else
      fail ("HEADER.DIMEXE [BD] set+1 %g != %g",
            dwg->header_vars.DIMEXE, dimexe);
    dimexe--;
    dwg_dynapi_header_set_value (dwg, "DIMEXE", &dimexe, 0);

  }
  {
    BITCODE_BD dimrnd;
    if (dwg_dynapi_header_value (dwg, "DIMRND", &dimrnd, NULL)
        && dimrnd == dwg->header_vars.DIMRND)
      pass ();
    else
      fail ("HEADER.DIMRND [BD] %g != %g", dwg->header_vars.DIMRND, dimrnd);
    dimrnd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMRND", &dimrnd, 0)
        && dimrnd == dwg->header_vars.DIMRND)
      pass ();
    else
      fail ("HEADER.DIMRND [BD] set+1 %g != %g",
            dwg->header_vars.DIMRND, dimrnd);
    dimrnd--;
    dwg_dynapi_header_set_value (dwg, "DIMRND", &dimrnd, 0);

  }
  {
    BITCODE_BD dimdle;
    if (dwg_dynapi_header_value (dwg, "DIMDLE", &dimdle, NULL)
        && dimdle == dwg->header_vars.DIMDLE)
      pass ();
    else
      fail ("HEADER.DIMDLE [BD] %g != %g", dwg->header_vars.DIMDLE, dimdle);
    dimdle++;
    if (dwg_dynapi_header_set_value (dwg, "DIMDLE", &dimdle, 0)
        && dimdle == dwg->header_vars.DIMDLE)
      pass ();
    else
      fail ("HEADER.DIMDLE [BD] set+1 %g != %g",
            dwg->header_vars.DIMDLE, dimdle);
    dimdle--;
    dwg_dynapi_header_set_value (dwg, "DIMDLE", &dimdle, 0);

  }
  {
    BITCODE_BD dimtp;
    if (dwg_dynapi_header_value (dwg, "DIMTP", &dimtp, NULL)
        && dimtp == dwg->header_vars.DIMTP)
      pass ();
    else
      fail ("HEADER.DIMTP [BD] %g != %g", dwg->header_vars.DIMTP, dimtp);
    dimtp++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTP", &dimtp, 0)
        && dimtp == dwg->header_vars.DIMTP)
      pass ();
    else
      fail ("HEADER.DIMTP [BD] set+1 %g != %g",
            dwg->header_vars.DIMTP, dimtp);
    dimtp--;
    dwg_dynapi_header_set_value (dwg, "DIMTP", &dimtp, 0);

  }
  {
    BITCODE_BD dimtm;
    if (dwg_dynapi_header_value (dwg, "DIMTM", &dimtm, NULL)
        && dimtm == dwg->header_vars.DIMTM)
      pass ();
    else
      fail ("HEADER.DIMTM [BD] %g != %g", dwg->header_vars.DIMTM, dimtm);
    dimtm++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTM", &dimtm, 0)
        && dimtm == dwg->header_vars.DIMTM)
      pass ();
    else
      fail ("HEADER.DIMTM [BD] set+1 %g != %g",
            dwg->header_vars.DIMTM, dimtm);
    dimtm--;
    dwg_dynapi_header_set_value (dwg, "DIMTM", &dimtm, 0);

  }
  {
    BITCODE_BD dimfxl;
    if (dwg_dynapi_header_value (dwg, "DIMFXL", &dimfxl, NULL)
        && dimfxl == dwg->header_vars.DIMFXL)
      pass ();
    else
      fail ("HEADER.DIMFXL [BD] %g != %g", dwg->header_vars.DIMFXL, dimfxl);
    dimfxl++;
    if (dwg_dynapi_header_set_value (dwg, "DIMFXL", &dimfxl, 0)
        && dimfxl == dwg->header_vars.DIMFXL)
      pass ();
    else
      fail ("HEADER.DIMFXL [BD] set+1 %g != %g",
            dwg->header_vars.DIMFXL, dimfxl);
    dimfxl--;
    dwg_dynapi_header_set_value (dwg, "DIMFXL", &dimfxl, 0);

  }
  {
    BITCODE_BD dimjogang;
    if (dwg_dynapi_header_value (dwg, "DIMJOGANG", &dimjogang, NULL)
        && dimjogang == dwg->header_vars.DIMJOGANG)
      pass ();
    else
      fail ("HEADER.DIMJOGANG [BD] %g != %g", dwg->header_vars.DIMJOGANG, dimjogang);
    dimjogang++;
    if (dwg_dynapi_header_set_value (dwg, "DIMJOGANG", &dimjogang, 0)
        && dimjogang == dwg->header_vars.DIMJOGANG)
      pass ();
    else
      fail ("HEADER.DIMJOGANG [BD] set+1 %g != %g",
            dwg->header_vars.DIMJOGANG, dimjogang);
    dimjogang--;
    dwg_dynapi_header_set_value (dwg, "DIMJOGANG", &dimjogang, 0);

  }
  {
    BITCODE_BS dimtfill;
    if (dwg_dynapi_header_value (dwg, "DIMTFILL", &dimtfill, NULL)
        && dimtfill == dwg->header_vars.DIMTFILL)
      pass ();
    else
      fail ("HEADER.DIMTFILL [BS] %hu != %hu", dwg->header_vars.DIMTFILL, dimtfill);
    dimtfill++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTFILL", &dimtfill, 0)
        && dimtfill == dwg->header_vars.DIMTFILL)
      pass ();
    else
      fail ("HEADER.DIMTFILL [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTFILL, dimtfill);
    dimtfill--;
    dwg_dynapi_header_set_value (dwg, "DIMTFILL", &dimtfill, 0);

  }
  {
    BITCODE_CMC dimtfillclr;
    if (dwg_dynapi_header_value (dwg, "DIMTFILLCLR", &dimtfillclr, NULL)
        && !memcmp (&dimtfillclr, &dwg->header_vars.DIMTFILLCLR, sizeof (dwg->header_vars.DIMTFILLCLR))
       )
      pass ();
    else
      fail ("HEADER.DIMTFILLCLR [CMC]");
  }
  {
    BITCODE_BS dimazin;
    if (dwg_dynapi_header_value (dwg, "DIMAZIN", &dimazin, NULL)
        && dimazin == dwg->header_vars.DIMAZIN)
      pass ();
    else
      fail ("HEADER.DIMAZIN [BS] %hu != %hu", dwg->header_vars.DIMAZIN, dimazin);
    dimazin++;
    if (dwg_dynapi_header_set_value (dwg, "DIMAZIN", &dimazin, 0)
        && dimazin == dwg->header_vars.DIMAZIN)
      pass ();
    else
      fail ("HEADER.DIMAZIN [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMAZIN, dimazin);
    dimazin--;
    dwg_dynapi_header_set_value (dwg, "DIMAZIN", &dimazin, 0);

  }
  {
    BITCODE_BS dimarcsym;
    if (dwg_dynapi_header_value (dwg, "DIMARCSYM", &dimarcsym, NULL)
        && dimarcsym == dwg->header_vars.DIMARCSYM)
      pass ();
    else
      fail ("HEADER.DIMARCSYM [BS] %hu != %hu", dwg->header_vars.DIMARCSYM, dimarcsym);
    dimarcsym++;
    if (dwg_dynapi_header_set_value (dwg, "DIMARCSYM", &dimarcsym, 0)
        && dimarcsym == dwg->header_vars.DIMARCSYM)
      pass ();
    else
      fail ("HEADER.DIMARCSYM [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMARCSYM, dimarcsym);
    dimarcsym--;
    dwg_dynapi_header_set_value (dwg, "DIMARCSYM", &dimarcsym, 0);

  }
  {
    BITCODE_BD dimtxt;
    if (dwg_dynapi_header_value (dwg, "DIMTXT", &dimtxt, NULL)
        && dimtxt == dwg->header_vars.DIMTXT)
      pass ();
    else
      fail ("HEADER.DIMTXT [BD] %g != %g", dwg->header_vars.DIMTXT, dimtxt);
    dimtxt++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTXT", &dimtxt, 0)
        && dimtxt == dwg->header_vars.DIMTXT)
      pass ();
    else
      fail ("HEADER.DIMTXT [BD] set+1 %g != %g",
            dwg->header_vars.DIMTXT, dimtxt);
    dimtxt--;
    dwg_dynapi_header_set_value (dwg, "DIMTXT", &dimtxt, 0);

  }
  {
    BITCODE_BD dimcen;
    if (dwg_dynapi_header_value (dwg, "DIMCEN", &dimcen, NULL)
        && dimcen == dwg->header_vars.DIMCEN)
      pass ();
    else
      fail ("HEADER.DIMCEN [BD] %g != %g", dwg->header_vars.DIMCEN, dimcen);
    dimcen++;
    if (dwg_dynapi_header_set_value (dwg, "DIMCEN", &dimcen, 0)
        && dimcen == dwg->header_vars.DIMCEN)
      pass ();
    else
      fail ("HEADER.DIMCEN [BD] set+1 %g != %g",
            dwg->header_vars.DIMCEN, dimcen);
    dimcen--;
    dwg_dynapi_header_set_value (dwg, "DIMCEN", &dimcen, 0);

  }
  {
    BITCODE_BD dimtsz;
    if (dwg_dynapi_header_value (dwg, "DIMTSZ", &dimtsz, NULL)
        && dimtsz == dwg->header_vars.DIMTSZ)
      pass ();
    else
      fail ("HEADER.DIMTSZ [BD] %g != %g", dwg->header_vars.DIMTSZ, dimtsz);
    dimtsz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTSZ", &dimtsz, 0)
        && dimtsz == dwg->header_vars.DIMTSZ)
      pass ();
    else
      fail ("HEADER.DIMTSZ [BD] set+1 %g != %g",
            dwg->header_vars.DIMTSZ, dimtsz);
    dimtsz--;
    dwg_dynapi_header_set_value (dwg, "DIMTSZ", &dimtsz, 0);

  }
  {
    BITCODE_BD dimaltf;
    if (dwg_dynapi_header_value (dwg, "DIMALTF", &dimaltf, NULL)
        && dimaltf == dwg->header_vars.DIMALTF)
      pass ();
    else
      fail ("HEADER.DIMALTF [BD] %g != %g", dwg->header_vars.DIMALTF, dimaltf);
    dimaltf++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTF", &dimaltf, 0)
        && dimaltf == dwg->header_vars.DIMALTF)
      pass ();
    else
      fail ("HEADER.DIMALTF [BD] set+1 %g != %g",
            dwg->header_vars.DIMALTF, dimaltf);
    dimaltf--;
    dwg_dynapi_header_set_value (dwg, "DIMALTF", &dimaltf, 0);

  }
  {
    BITCODE_BD dimlfac;
    if (dwg_dynapi_header_value (dwg, "DIMLFAC", &dimlfac, NULL)
        && dimlfac == dwg->header_vars.DIMLFAC)
      pass ();
    else
      fail ("HEADER.DIMLFAC [BD] %g != %g", dwg->header_vars.DIMLFAC, dimlfac);
    dimlfac++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLFAC", &dimlfac, 0)
        && dimlfac == dwg->header_vars.DIMLFAC)
      pass ();
    else
      fail ("HEADER.DIMLFAC [BD] set+1 %g != %g",
            dwg->header_vars.DIMLFAC, dimlfac);
    dimlfac--;
    dwg_dynapi_header_set_value (dwg, "DIMLFAC", &dimlfac, 0);

  }
  {
    BITCODE_BD dimtvp;
    if (dwg_dynapi_header_value (dwg, "DIMTVP", &dimtvp, NULL)
        && dimtvp == dwg->header_vars.DIMTVP)
      pass ();
    else
      fail ("HEADER.DIMTVP [BD] %g != %g", dwg->header_vars.DIMTVP, dimtvp);
    dimtvp++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTVP", &dimtvp, 0)
        && dimtvp == dwg->header_vars.DIMTVP)
      pass ();
    else
      fail ("HEADER.DIMTVP [BD] set+1 %g != %g",
            dwg->header_vars.DIMTVP, dimtvp);
    dimtvp--;
    dwg_dynapi_header_set_value (dwg, "DIMTVP", &dimtvp, 0);

  }
  {
    BITCODE_BD dimtfac;
    if (dwg_dynapi_header_value (dwg, "DIMTFAC", &dimtfac, NULL)
        && dimtfac == dwg->header_vars.DIMTFAC)
      pass ();
    else
      fail ("HEADER.DIMTFAC [BD] %g != %g", dwg->header_vars.DIMTFAC, dimtfac);
    dimtfac++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTFAC", &dimtfac, 0)
        && dimtfac == dwg->header_vars.DIMTFAC)
      pass ();
    else
      fail ("HEADER.DIMTFAC [BD] set+1 %g != %g",
            dwg->header_vars.DIMTFAC, dimtfac);
    dimtfac--;
    dwg_dynapi_header_set_value (dwg, "DIMTFAC", &dimtfac, 0);

  }
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_header_value (dwg, "DIMGAP", &dimgap, NULL)
        && dimgap == dwg->header_vars.DIMGAP)
      pass ();
    else
      fail ("HEADER.DIMGAP [BD] %g != %g", dwg->header_vars.DIMGAP, dimgap);
    dimgap++;
    if (dwg_dynapi_header_set_value (dwg, "DIMGAP", &dimgap, 0)
        && dimgap == dwg->header_vars.DIMGAP)
      pass ();
    else
      fail ("HEADER.DIMGAP [BD] set+1 %g != %g",
            dwg->header_vars.DIMGAP, dimgap);
    dimgap--;
    dwg_dynapi_header_set_value (dwg, "DIMGAP", &dimgap, 0);

  }
  {
    BITCODE_T dimpost_t;
    if (dwg_dynapi_header_value (dwg, "DIMPOST_T", &dimpost_t, NULL)
        && !memcmp (&dimpost_t, &dwg->header_vars.DIMPOST_T, sizeof (dwg->header_vars.DIMPOST_T))
       )
      pass ();
    else
      fail ("HEADER.DIMPOST_T [T]");
  }
  {
    BITCODE_T dimapost_t;
    if (dwg_dynapi_header_value (dwg, "DIMAPOST_T", &dimapost_t, NULL)
        && !memcmp (&dimapost_t, &dwg->header_vars.DIMAPOST_T, sizeof (dwg->header_vars.DIMAPOST_T))
       )
      pass ();
    else
      fail ("HEADER.DIMAPOST_T [T]");
  }
  {
    BITCODE_T dimblk_t;
    if (dwg_dynapi_header_value (dwg, "DIMBLK_T", &dimblk_t, NULL)
        && !memcmp (&dimblk_t, &dwg->header_vars.DIMBLK_T, sizeof (dwg->header_vars.DIMBLK_T))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK_T [T]");
  }
  {
    BITCODE_T dimblk1_t;
    if (dwg_dynapi_header_value (dwg, "DIMBLK1_T", &dimblk1_t, NULL)
        && !memcmp (&dimblk1_t, &dwg->header_vars.DIMBLK1_T, sizeof (dwg->header_vars.DIMBLK1_T))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK1_T [T]");
  }
  {
    BITCODE_T dimblk2_t;
    if (dwg_dynapi_header_value (dwg, "DIMBLK2_T", &dimblk2_t, NULL)
        && !memcmp (&dimblk2_t, &dwg->header_vars.DIMBLK2_T, sizeof (dwg->header_vars.DIMBLK2_T))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK2_T [T]");
  }
  {
    BITCODE_T unknown_string;
    if (dwg_dynapi_header_value (dwg, "unknown_string", &unknown_string, NULL)
        && !memcmp (&unknown_string, &dwg->header_vars.unknown_string, sizeof (dwg->header_vars.unknown_string))
       )
      pass ();
    else
      fail ("HEADER.unknown_string [T]");
  }
  {
    BITCODE_BD dimaltrnd;
    if (dwg_dynapi_header_value (dwg, "DIMALTRND", &dimaltrnd, NULL)
        && dimaltrnd == dwg->header_vars.DIMALTRND)
      pass ();
    else
      fail ("HEADER.DIMALTRND [BD] %g != %g", dwg->header_vars.DIMALTRND, dimaltrnd);
    dimaltrnd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTRND", &dimaltrnd, 0)
        && dimaltrnd == dwg->header_vars.DIMALTRND)
      pass ();
    else
      fail ("HEADER.DIMALTRND [BD] set+1 %g != %g",
            dwg->header_vars.DIMALTRND, dimaltrnd);
    dimaltrnd--;
    dwg_dynapi_header_set_value (dwg, "DIMALTRND", &dimaltrnd, 0);

  }
  {
    BITCODE_RS dimclrd_c;
    if (dwg_dynapi_header_value (dwg, "DIMCLRD_C", &dimclrd_c, NULL)
        && dimclrd_c == dwg->header_vars.DIMCLRD_C)
      pass ();
    else
      fail ("HEADER.DIMCLRD_C [RS] %hu != %hu", dwg->header_vars.DIMCLRD_C, dimclrd_c);
    dimclrd_c++;
    if (dwg_dynapi_header_set_value (dwg, "DIMCLRD_C", &dimclrd_c, 0)
        && dimclrd_c == dwg->header_vars.DIMCLRD_C)
      pass ();
    else
      fail ("HEADER.DIMCLRD_C [RS] set+1 %hu != %hu",
            dwg->header_vars.DIMCLRD_C, dimclrd_c);
    dimclrd_c--;
    dwg_dynapi_header_set_value (dwg, "DIMCLRD_C", &dimclrd_c, 0);

  }
  {
    BITCODE_RS dimclre_c;
    if (dwg_dynapi_header_value (dwg, "DIMCLRE_C", &dimclre_c, NULL)
        && dimclre_c == dwg->header_vars.DIMCLRE_C)
      pass ();
    else
      fail ("HEADER.DIMCLRE_C [RS] %hu != %hu", dwg->header_vars.DIMCLRE_C, dimclre_c);
    dimclre_c++;
    if (dwg_dynapi_header_set_value (dwg, "DIMCLRE_C", &dimclre_c, 0)
        && dimclre_c == dwg->header_vars.DIMCLRE_C)
      pass ();
    else
      fail ("HEADER.DIMCLRE_C [RS] set+1 %hu != %hu",
            dwg->header_vars.DIMCLRE_C, dimclre_c);
    dimclre_c--;
    dwg_dynapi_header_set_value (dwg, "DIMCLRE_C", &dimclre_c, 0);

  }
  {
    BITCODE_RS dimclrt_c;
    if (dwg_dynapi_header_value (dwg, "DIMCLRT_C", &dimclrt_c, NULL)
        && dimclrt_c == dwg->header_vars.DIMCLRT_C)
      pass ();
    else
      fail ("HEADER.DIMCLRT_C [RS] %hu != %hu", dwg->header_vars.DIMCLRT_C, dimclrt_c);
    dimclrt_c++;
    if (dwg_dynapi_header_set_value (dwg, "DIMCLRT_C", &dimclrt_c, 0)
        && dimclrt_c == dwg->header_vars.DIMCLRT_C)
      pass ();
    else
      fail ("HEADER.DIMCLRT_C [RS] set+1 %hu != %hu",
            dwg->header_vars.DIMCLRT_C, dimclrt_c);
    dimclrt_c--;
    dwg_dynapi_header_set_value (dwg, "DIMCLRT_C", &dimclrt_c, 0);

  }
  {
    BITCODE_CMC dimclrd;
    if (dwg_dynapi_header_value (dwg, "DIMCLRD", &dimclrd, NULL)
        && !memcmp (&dimclrd, &dwg->header_vars.DIMCLRD, sizeof (dwg->header_vars.DIMCLRD))
       )
      pass ();
    else
      fail ("HEADER.DIMCLRD [CMC]");
  }
  {
    BITCODE_CMC dimclre;
    if (dwg_dynapi_header_value (dwg, "DIMCLRE", &dimclre, NULL)
        && !memcmp (&dimclre, &dwg->header_vars.DIMCLRE, sizeof (dwg->header_vars.DIMCLRE))
       )
      pass ();
    else
      fail ("HEADER.DIMCLRE [CMC]");
  }
  {
    BITCODE_CMC dimclrt;
    if (dwg_dynapi_header_value (dwg, "DIMCLRT", &dimclrt, NULL)
        && !memcmp (&dimclrt, &dwg->header_vars.DIMCLRT, sizeof (dwg->header_vars.DIMCLRT))
       )
      pass ();
    else
      fail ("HEADER.DIMCLRT [CMC]");
  }
  {
    BITCODE_BS dimadec;
    if (dwg_dynapi_header_value (dwg, "DIMADEC", &dimadec, NULL)
        && dimadec == dwg->header_vars.DIMADEC)
      pass ();
    else
      fail ("HEADER.DIMADEC [BS] %hu != %hu", dwg->header_vars.DIMADEC, dimadec);
    dimadec++;
    if (dwg_dynapi_header_set_value (dwg, "DIMADEC", &dimadec, 0)
        && dimadec == dwg->header_vars.DIMADEC)
      pass ();
    else
      fail ("HEADER.DIMADEC [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMADEC, dimadec);
    dimadec--;
    dwg_dynapi_header_set_value (dwg, "DIMADEC", &dimadec, 0);

  }
  {
    BITCODE_BS dimfrac;
    if (dwg_dynapi_header_value (dwg, "DIMFRAC", &dimfrac, NULL)
        && dimfrac == dwg->header_vars.DIMFRAC)
      pass ();
    else
      fail ("HEADER.DIMFRAC [BS] %hu != %hu", dwg->header_vars.DIMFRAC, dimfrac);
    dimfrac++;
    if (dwg_dynapi_header_set_value (dwg, "DIMFRAC", &dimfrac, 0)
        && dimfrac == dwg->header_vars.DIMFRAC)
      pass ();
    else
      fail ("HEADER.DIMFRAC [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMFRAC, dimfrac);
    dimfrac--;
    dwg_dynapi_header_set_value (dwg, "DIMFRAC", &dimfrac, 0);

  }
  {
    BITCODE_BS dimlunit;
    if (dwg_dynapi_header_value (dwg, "DIMLUNIT", &dimlunit, NULL)
        && dimlunit == dwg->header_vars.DIMLUNIT)
      pass ();
    else
      fail ("HEADER.DIMLUNIT [BS] %hu != %hu", dwg->header_vars.DIMLUNIT, dimlunit);
    dimlunit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLUNIT", &dimlunit, 0)
        && dimlunit == dwg->header_vars.DIMLUNIT)
      pass ();
    else
      fail ("HEADER.DIMLUNIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMLUNIT, dimlunit);
    dimlunit--;
    dwg_dynapi_header_set_value (dwg, "DIMLUNIT", &dimlunit, 0);

  }
  {
    BITCODE_BS dimdsep;
    if (dwg_dynapi_header_value (dwg, "DIMDSEP", &dimdsep, NULL)
        && dimdsep == dwg->header_vars.DIMDSEP)
      pass ();
    else
      fail ("HEADER.DIMDSEP [BS] %hu != %hu", dwg->header_vars.DIMDSEP, dimdsep);
    dimdsep++;
    if (dwg_dynapi_header_set_value (dwg, "DIMDSEP", &dimdsep, 0)
        && dimdsep == dwg->header_vars.DIMDSEP)
      pass ();
    else
      fail ("HEADER.DIMDSEP [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMDSEP, dimdsep);
    dimdsep--;
    dwg_dynapi_header_set_value (dwg, "DIMDSEP", &dimdsep, 0);

  }
  {
    BITCODE_BS dimtmove;
    if (dwg_dynapi_header_value (dwg, "DIMTMOVE", &dimtmove, NULL)
        && dimtmove == dwg->header_vars.DIMTMOVE)
      pass ();
    else
      fail ("HEADER.DIMTMOVE [BS] %hu != %hu", dwg->header_vars.DIMTMOVE, dimtmove);
    dimtmove++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTMOVE", &dimtmove, 0)
        && dimtmove == dwg->header_vars.DIMTMOVE)
      pass ();
    else
      fail ("HEADER.DIMTMOVE [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMTMOVE, dimtmove);
    dimtmove--;
    dwg_dynapi_header_set_value (dwg, "DIMTMOVE", &dimtmove, 0);

  }
  {
    BITCODE_BS dimaltz;
    if (dwg_dynapi_header_value (dwg, "DIMALTZ", &dimaltz, NULL)
        && dimaltz == dwg->header_vars.DIMALTZ)
      pass ();
    else
      fail ("HEADER.DIMALTZ [BS] %hu != %hu", dwg->header_vars.DIMALTZ, dimaltz);
    dimaltz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTZ", &dimaltz, 0)
        && dimaltz == dwg->header_vars.DIMALTZ)
      pass ();
    else
      fail ("HEADER.DIMALTZ [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTZ, dimaltz);
    dimaltz--;
    dwg_dynapi_header_set_value (dwg, "DIMALTZ", &dimaltz, 0);

  }
  {
    BITCODE_BS dimalttz;
    if (dwg_dynapi_header_value (dwg, "DIMALTTZ", &dimalttz, NULL)
        && dimalttz == dwg->header_vars.DIMALTTZ)
      pass ();
    else
      fail ("HEADER.DIMALTTZ [BS] %hu != %hu", dwg->header_vars.DIMALTTZ, dimalttz);
    dimalttz++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTTZ", &dimalttz, 0)
        && dimalttz == dwg->header_vars.DIMALTTZ)
      pass ();
    else
      fail ("HEADER.DIMALTTZ [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMALTTZ, dimalttz);
    dimalttz--;
    dwg_dynapi_header_set_value (dwg, "DIMALTTZ", &dimalttz, 0);

  }
  {
    BITCODE_BS dimatfit;
    if (dwg_dynapi_header_value (dwg, "DIMATFIT", &dimatfit, NULL)
        && dimatfit == dwg->header_vars.DIMATFIT)
      pass ();
    else
      fail ("HEADER.DIMATFIT [BS] %hu != %hu", dwg->header_vars.DIMATFIT, dimatfit);
    dimatfit++;
    if (dwg_dynapi_header_set_value (dwg, "DIMATFIT", &dimatfit, 0)
        && dimatfit == dwg->header_vars.DIMATFIT)
      pass ();
    else
      fail ("HEADER.DIMATFIT [BS] set+1 %hu != %hu",
            dwg->header_vars.DIMATFIT, dimatfit);
    dimatfit--;
    dwg_dynapi_header_set_value (dwg, "DIMATFIT", &dimatfit, 0);

  }
  {
    BITCODE_B dimfxlon;
    if (dwg_dynapi_header_value (dwg, "DIMFXLON", &dimfxlon, NULL)
        && dimfxlon == dwg->header_vars.DIMFXLON)
      pass ();
    else
      fail ("HEADER.DIMFXLON [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMFXLON, dimfxlon);
    dimfxlon++;
    if (dwg_dynapi_header_set_value (dwg, "DIMFXLON", &dimfxlon, 0)
        && dimfxlon == dwg->header_vars.DIMFXLON)
      pass ();
    else
      fail ("HEADER.DIMFXLON [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMFXLON, dimfxlon);
    dimfxlon--;
    dwg_dynapi_header_set_value (dwg, "DIMFXLON", &dimfxlon, 0);

  }
  {
    BITCODE_B dimtxtdirection;
    if (dwg_dynapi_header_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, NULL)
        && dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
      pass ();
    else
      fail ("HEADER.DIMTXTDIRECTION [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection);
    dimtxtdirection++;
    if (dwg_dynapi_header_set_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, 0)
        && dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
      pass ();
    else
      fail ("HEADER.DIMTXTDIRECTION [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection);
    dimtxtdirection--;
    dwg_dynapi_header_set_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, 0);

  }
  {
    BITCODE_BD dimaltmzf;
    if (dwg_dynapi_header_value (dwg, "DIMALTMZF", &dimaltmzf, NULL)
        && dimaltmzf == dwg->header_vars.DIMALTMZF)
      pass ();
    else
      fail ("HEADER.DIMALTMZF [BD] %g != %g", dwg->header_vars.DIMALTMZF, dimaltmzf);
    dimaltmzf++;
    if (dwg_dynapi_header_set_value (dwg, "DIMALTMZF", &dimaltmzf, 0)
        && dimaltmzf == dwg->header_vars.DIMALTMZF)
      pass ();
    else
      fail ("HEADER.DIMALTMZF [BD] set+1 %g != %g",
            dwg->header_vars.DIMALTMZF, dimaltmzf);
    dimaltmzf--;
    dwg_dynapi_header_set_value (dwg, "DIMALTMZF", &dimaltmzf, 0);

  }
  {
    BITCODE_T dimaltmzs;
    if (dwg_dynapi_header_value (dwg, "DIMALTMZS", &dimaltmzs, NULL)
        && !memcmp (&dimaltmzs, &dwg->header_vars.DIMALTMZS, sizeof (dwg->header_vars.DIMALTMZS))
       )
      pass ();
    else
      fail ("HEADER.DIMALTMZS [T]");
  }
  {
    BITCODE_BD dimmzf;
    if (dwg_dynapi_header_value (dwg, "DIMMZF", &dimmzf, NULL)
        && dimmzf == dwg->header_vars.DIMMZF)
      pass ();
    else
      fail ("HEADER.DIMMZF [BD] %g != %g", dwg->header_vars.DIMMZF, dimmzf);
    dimmzf++;
    if (dwg_dynapi_header_set_value (dwg, "DIMMZF", &dimmzf, 0)
        && dimmzf == dwg->header_vars.DIMMZF)
      pass ();
    else
      fail ("HEADER.DIMMZF [BD] set+1 %g != %g",
            dwg->header_vars.DIMMZF, dimmzf);
    dimmzf--;
    dwg_dynapi_header_set_value (dwg, "DIMMZF", &dimmzf, 0);

  }
  {
    BITCODE_T dimmzs;
    if (dwg_dynapi_header_value (dwg, "DIMMZS", &dimmzs, NULL)
        && !memcmp (&dimmzs, &dwg->header_vars.DIMMZS, sizeof (dwg->header_vars.DIMMZS))
       )
      pass ();
    else
      fail ("HEADER.DIMMZS [T]");
  }
  {
    BITCODE_H dimldrblk;
    if (dwg_dynapi_header_value (dwg, "DIMLDRBLK", &dimldrblk, NULL)
        && !memcmp (&dimldrblk, &dwg->header_vars.DIMLDRBLK, sizeof (dwg->header_vars.DIMLDRBLK))
       )
      pass ();
    else
      fail ("HEADER.DIMLDRBLK [H]");
  }
  {
    BITCODE_H dimblk;
    if (dwg_dynapi_header_value (dwg, "DIMBLK", &dimblk, NULL)
        && !memcmp (&dimblk, &dwg->header_vars.DIMBLK, sizeof (dwg->header_vars.DIMBLK))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK [H]");
  }
  {
    BITCODE_H dimblk1;
    if (dwg_dynapi_header_value (dwg, "DIMBLK1", &dimblk1, NULL)
        && !memcmp (&dimblk1, &dwg->header_vars.DIMBLK1, sizeof (dwg->header_vars.DIMBLK1))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK1 [H]");
  }
  {
    BITCODE_H dimblk2;
    if (dwg_dynapi_header_value (dwg, "DIMBLK2", &dimblk2, NULL)
        && !memcmp (&dimblk2, &dwg->header_vars.DIMBLK2, sizeof (dwg->header_vars.DIMBLK2))
       )
      pass ();
    else
      fail ("HEADER.DIMBLK2 [H]");
  }
  {
    BITCODE_H dimltype;
    if (dwg_dynapi_header_value (dwg, "DIMLTYPE", &dimltype, NULL)
        && !memcmp (&dimltype, &dwg->header_vars.DIMLTYPE, sizeof (dwg->header_vars.DIMLTYPE))
       )
      pass ();
    else
      fail ("HEADER.DIMLTYPE [H]");
  }
  {
    BITCODE_H dimltex1;
    if (dwg_dynapi_header_value (dwg, "DIMLTEX1", &dimltex1, NULL)
        && !memcmp (&dimltex1, &dwg->header_vars.DIMLTEX1, sizeof (dwg->header_vars.DIMLTEX1))
       )
      pass ();
    else
      fail ("HEADER.DIMLTEX1 [H]");
  }
  {
    BITCODE_H dimltex2;
    if (dwg_dynapi_header_value (dwg, "DIMLTEX2", &dimltex2, NULL)
        && !memcmp (&dimltex2, &dwg->header_vars.DIMLTEX2, sizeof (dwg->header_vars.DIMLTEX2))
       )
      pass ();
    else
      fail ("HEADER.DIMLTEX2 [H]");
  }
  {
    BITCODE_BSd dimlwd;
    if (dwg_dynapi_header_value (dwg, "DIMLWD", &dimlwd, NULL)
        && dimlwd == dwg->header_vars.DIMLWD)
      pass ();
    else
      fail ("HEADER.DIMLWD [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.DIMLWD, dimlwd);
    dimlwd++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLWD", &dimlwd, 0)
        && dimlwd == dwg->header_vars.DIMLWD)
      pass ();
    else
      fail ("HEADER.DIMLWD [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.DIMLWD, dimlwd);
    dimlwd--;
    dwg_dynapi_header_set_value (dwg, "DIMLWD", &dimlwd, 0);

  }
  {
    BITCODE_BSd dimlwe;
    if (dwg_dynapi_header_value (dwg, "DIMLWE", &dimlwe, NULL)
        && dimlwe == dwg->header_vars.DIMLWE)
      pass ();
    else
      fail ("HEADER.DIMLWE [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.DIMLWE, dimlwe);
    dimlwe++;
    if (dwg_dynapi_header_set_value (dwg, "DIMLWE", &dimlwe, 0)
        && dimlwe == dwg->header_vars.DIMLWE)
      pass ();
    else
      fail ("HEADER.DIMLWE [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.DIMLWE, dimlwe);
    dimlwe--;
    dwg_dynapi_header_set_value (dwg, "DIMLWE", &dimlwe, 0);

  }
  {
    BITCODE_H block_control_object;
    if (dwg_dynapi_header_value (dwg, "BLOCK_CONTROL_OBJECT", &block_control_object, NULL)
        && !memcmp (&block_control_object, &dwg->header_vars.BLOCK_CONTROL_OBJECT, sizeof (dwg->header_vars.BLOCK_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.BLOCK_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H layer_control_object;
    if (dwg_dynapi_header_value (dwg, "LAYER_CONTROL_OBJECT", &layer_control_object, NULL)
        && !memcmp (&layer_control_object, &dwg->header_vars.LAYER_CONTROL_OBJECT, sizeof (dwg->header_vars.LAYER_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.LAYER_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H style_control_object;
    if (dwg_dynapi_header_value (dwg, "STYLE_CONTROL_OBJECT", &style_control_object, NULL)
        && !memcmp (&style_control_object, &dwg->header_vars.STYLE_CONTROL_OBJECT, sizeof (dwg->header_vars.STYLE_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.STYLE_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H ltype_control_object;
    if (dwg_dynapi_header_value (dwg, "LTYPE_CONTROL_OBJECT", &ltype_control_object, NULL)
        && !memcmp (&ltype_control_object, &dwg->header_vars.LTYPE_CONTROL_OBJECT, sizeof (dwg->header_vars.LTYPE_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.LTYPE_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H view_control_object;
    if (dwg_dynapi_header_value (dwg, "VIEW_CONTROL_OBJECT", &view_control_object, NULL)
        && !memcmp (&view_control_object, &dwg->header_vars.VIEW_CONTROL_OBJECT, sizeof (dwg->header_vars.VIEW_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.VIEW_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H ucs_control_object;
    if (dwg_dynapi_header_value (dwg, "UCS_CONTROL_OBJECT", &ucs_control_object, NULL)
        && !memcmp (&ucs_control_object, &dwg->header_vars.UCS_CONTROL_OBJECT, sizeof (dwg->header_vars.UCS_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.UCS_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H vport_control_object;
    if (dwg_dynapi_header_value (dwg, "VPORT_CONTROL_OBJECT", &vport_control_object, NULL)
        && !memcmp (&vport_control_object, &dwg->header_vars.VPORT_CONTROL_OBJECT, sizeof (dwg->header_vars.VPORT_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.VPORT_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H appid_control_object;
    if (dwg_dynapi_header_value (dwg, "APPID_CONTROL_OBJECT", &appid_control_object, NULL)
        && !memcmp (&appid_control_object, &dwg->header_vars.APPID_CONTROL_OBJECT, sizeof (dwg->header_vars.APPID_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.APPID_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H dimstyle_control_object;
    if (dwg_dynapi_header_value (dwg, "DIMSTYLE_CONTROL_OBJECT", &dimstyle_control_object, NULL)
        && !memcmp (&dimstyle_control_object, &dwg->header_vars.DIMSTYLE_CONTROL_OBJECT, sizeof (dwg->header_vars.DIMSTYLE_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.DIMSTYLE_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H vx_control_object;
    if (dwg_dynapi_header_value (dwg, "VX_CONTROL_OBJECT", &vx_control_object, NULL)
        && !memcmp (&vx_control_object, &dwg->header_vars.VX_CONTROL_OBJECT, sizeof (dwg->header_vars.VX_CONTROL_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.VX_CONTROL_OBJECT [H]");
  }
  {
    BITCODE_H dictionary_acad_group;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_ACAD_GROUP", &dictionary_acad_group, NULL)
        && !memcmp (&dictionary_acad_group, &dwg->header_vars.DICTIONARY_ACAD_GROUP, sizeof (dwg->header_vars.DICTIONARY_ACAD_GROUP))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_ACAD_GROUP [H]");
  }
  {
    BITCODE_H dictionary_acad_mlinestyle;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_ACAD_MLINESTYLE", &dictionary_acad_mlinestyle, NULL)
        && !memcmp (&dictionary_acad_mlinestyle, &dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE, sizeof (dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_ACAD_MLINESTYLE [H]");
  }
  {
    BITCODE_H dictionary_named_object;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_NAMED_OBJECT", &dictionary_named_object, NULL)
        && !memcmp (&dictionary_named_object, &dwg->header_vars.DICTIONARY_NAMED_OBJECT, sizeof (dwg->header_vars.DICTIONARY_NAMED_OBJECT))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_NAMED_OBJECT [H]");
  }
  {
    BITCODE_BS tstackalign;
    if (dwg_dynapi_header_value (dwg, "TSTACKALIGN", &tstackalign, NULL)
        && tstackalign == dwg->header_vars.TSTACKALIGN)
      pass ();
    else
      fail ("HEADER.TSTACKALIGN [BS] %hu != %hu", dwg->header_vars.TSTACKALIGN, tstackalign);
    tstackalign++;
    if (dwg_dynapi_header_set_value (dwg, "TSTACKALIGN", &tstackalign, 0)
        && tstackalign == dwg->header_vars.TSTACKALIGN)
      pass ();
    else
      fail ("HEADER.TSTACKALIGN [BS] set+1 %hu != %hu",
            dwg->header_vars.TSTACKALIGN, tstackalign);
    tstackalign--;
    dwg_dynapi_header_set_value (dwg, "TSTACKALIGN", &tstackalign, 0);

  }
  {
    BITCODE_BS tstacksize;
    if (dwg_dynapi_header_value (dwg, "TSTACKSIZE", &tstacksize, NULL)
        && tstacksize == dwg->header_vars.TSTACKSIZE)
      pass ();
    else
      fail ("HEADER.TSTACKSIZE [BS] %hu != %hu", dwg->header_vars.TSTACKSIZE, tstacksize);
    tstacksize++;
    if (dwg_dynapi_header_set_value (dwg, "TSTACKSIZE", &tstacksize, 0)
        && tstacksize == dwg->header_vars.TSTACKSIZE)
      pass ();
    else
      fail ("HEADER.TSTACKSIZE [BS] set+1 %hu != %hu",
            dwg->header_vars.TSTACKSIZE, tstacksize);
    tstacksize--;
    dwg_dynapi_header_set_value (dwg, "TSTACKSIZE", &tstacksize, 0);

  }
  {
    BITCODE_T hyperlinkbase;
    if (dwg_dynapi_header_value (dwg, "HYPERLINKBASE", &hyperlinkbase, NULL)
        && !memcmp (&hyperlinkbase, &dwg->header_vars.HYPERLINKBASE, sizeof (dwg->header_vars.HYPERLINKBASE))
       )
      pass ();
    else
      fail ("HEADER.HYPERLINKBASE [T]");
  }
  {
    BITCODE_TV stylesheet;
    if (dwg_dynapi_header_value (dwg, "STYLESHEET", &stylesheet, NULL)
        && !memcmp (&stylesheet, &dwg->header_vars.STYLESHEET, sizeof (dwg->header_vars.STYLESHEET))
       )
      pass ();
    else
      fail ("HEADER.STYLESHEET [TV]");
  }
  {
    BITCODE_H dictionary_layout;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_LAYOUT", &dictionary_layout, NULL)
        && !memcmp (&dictionary_layout, &dwg->header_vars.DICTIONARY_LAYOUT, sizeof (dwg->header_vars.DICTIONARY_LAYOUT))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_LAYOUT [H]");
  }
  {
    BITCODE_H dictionary_plotsettings;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_PLOTSETTINGS", &dictionary_plotsettings, NULL)
        && !memcmp (&dictionary_plotsettings, &dwg->header_vars.DICTIONARY_PLOTSETTINGS, sizeof (dwg->header_vars.DICTIONARY_PLOTSETTINGS))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_PLOTSETTINGS [H]");
  }
  {
    BITCODE_H dictionary_plotstylename;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_PLOTSTYLENAME", &dictionary_plotstylename, NULL)
        && !memcmp (&dictionary_plotstylename, &dwg->header_vars.DICTIONARY_PLOTSTYLENAME, sizeof (dwg->header_vars.DICTIONARY_PLOTSTYLENAME))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_PLOTSTYLENAME [H]");
  }
  {
    BITCODE_H dictionary_material;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_MATERIAL", &dictionary_material, NULL)
        && !memcmp (&dictionary_material, &dwg->header_vars.DICTIONARY_MATERIAL, sizeof (dwg->header_vars.DICTIONARY_MATERIAL))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_MATERIAL [H]");
  }
  {
    BITCODE_H dictionary_color;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_COLOR", &dictionary_color, NULL)
        && !memcmp (&dictionary_color, &dwg->header_vars.DICTIONARY_COLOR, sizeof (dwg->header_vars.DICTIONARY_COLOR))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_COLOR [H]");
  }
  {
    BITCODE_H dictionary_visualstyle;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_VISUALSTYLE", &dictionary_visualstyle, NULL)
        && !memcmp (&dictionary_visualstyle, &dwg->header_vars.DICTIONARY_VISUALSTYLE, sizeof (dwg->header_vars.DICTIONARY_VISUALSTYLE))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_VISUALSTYLE [H]");
  }
  {
    BITCODE_H dictionary_lightlist;
    if (dwg_dynapi_header_value (dwg, "DICTIONARY_LIGHTLIST", &dictionary_lightlist, NULL)
        && !memcmp (&dictionary_lightlist, &dwg->header_vars.DICTIONARY_LIGHTLIST, sizeof (dwg->header_vars.DICTIONARY_LIGHTLIST))
       )
      pass ();
    else
      fail ("HEADER.DICTIONARY_LIGHTLIST [H]");
  }
  {
    BITCODE_H unknown_20;
    if (dwg_dynapi_header_value (dwg, "unknown_20", &unknown_20, NULL)
        && !memcmp (&unknown_20, &dwg->header_vars.unknown_20, sizeof (dwg->header_vars.unknown_20))
       )
      pass ();
    else
      fail ("HEADER.unknown_20 [H]");
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_header_value (dwg, "FLAGS", &flags, NULL)
        && flags == dwg->header_vars.FLAGS)
      pass ();
    else
      fail ("HEADER.FLAGS [BL] %u != %u", dwg->header_vars.FLAGS, flags);
    flags++;
    if (dwg_dynapi_header_set_value (dwg, "FLAGS", &flags, 0)
        && flags == dwg->header_vars.FLAGS)
      pass ();
    else
      fail ("HEADER.FLAGS [BL] set+1 %u != %u",
            dwg->header_vars.FLAGS, flags);
    flags--;
    dwg_dynapi_header_set_value (dwg, "FLAGS", &flags, 0);

  }
  {
    BITCODE_BSd celweight;
    if (dwg_dynapi_header_value (dwg, "CELWEIGHT", &celweight, NULL)
        && celweight == dwg->header_vars.CELWEIGHT)
      pass ();
    else
      fail ("HEADER.CELWEIGHT [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.CELWEIGHT, celweight);
    celweight++;
    if (dwg_dynapi_header_set_value (dwg, "CELWEIGHT", &celweight, 0)
        && celweight == dwg->header_vars.CELWEIGHT)
      pass ();
    else
      fail ("HEADER.CELWEIGHT [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
            dwg->header_vars.CELWEIGHT, celweight);
    celweight--;
    dwg_dynapi_header_set_value (dwg, "CELWEIGHT", &celweight, 0);

  }
  {
    BITCODE_B endcaps;
    if (dwg_dynapi_header_value (dwg, "ENDCAPS", &endcaps, NULL)
        && endcaps == dwg->header_vars.ENDCAPS)
      pass ();
    else
      fail ("HEADER.ENDCAPS [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ENDCAPS, endcaps);
    endcaps++;
    if (dwg_dynapi_header_set_value (dwg, "ENDCAPS", &endcaps, 0)
        && endcaps == dwg->header_vars.ENDCAPS)
      pass ();
    else
      fail ("HEADER.ENDCAPS [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.ENDCAPS, endcaps);
    endcaps--;
    dwg_dynapi_header_set_value (dwg, "ENDCAPS", &endcaps, 0);

  }
  {
    BITCODE_B joinstyle;
    if (dwg_dynapi_header_value (dwg, "JOINSTYLE", &joinstyle, NULL)
        && joinstyle == dwg->header_vars.JOINSTYLE)
      pass ();
    else
      fail ("HEADER.JOINSTYLE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.JOINSTYLE, joinstyle);
    joinstyle++;
    if (dwg_dynapi_header_set_value (dwg, "JOINSTYLE", &joinstyle, 0)
        && joinstyle == dwg->header_vars.JOINSTYLE)
      pass ();
    else
      fail ("HEADER.JOINSTYLE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.JOINSTYLE, joinstyle);
    joinstyle--;
    dwg_dynapi_header_set_value (dwg, "JOINSTYLE", &joinstyle, 0);

  }
  {
    BITCODE_B lwdisplay;
    if (dwg_dynapi_header_value (dwg, "LWDISPLAY", &lwdisplay, NULL)
        && lwdisplay == dwg->header_vars.LWDISPLAY)
      pass ();
    else
      fail ("HEADER.LWDISPLAY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LWDISPLAY, lwdisplay);
    lwdisplay++;
    if (dwg_dynapi_header_set_value (dwg, "LWDISPLAY", &lwdisplay, 0)
        && lwdisplay == dwg->header_vars.LWDISPLAY)
      pass ();
    else
      fail ("HEADER.LWDISPLAY [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.LWDISPLAY, lwdisplay);
    lwdisplay--;
    dwg_dynapi_header_set_value (dwg, "LWDISPLAY", &lwdisplay, 0);

  }
  {
    BITCODE_B xedit;
    if (dwg_dynapi_header_value (dwg, "XEDIT", &xedit, NULL)
        && xedit == dwg->header_vars.XEDIT)
      pass ();
    else
      fail ("HEADER.XEDIT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.XEDIT, xedit);
    xedit++;
    if (dwg_dynapi_header_set_value (dwg, "XEDIT", &xedit, 0)
        && xedit == dwg->header_vars.XEDIT)
      pass ();
    else
      fail ("HEADER.XEDIT [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.XEDIT, xedit);
    xedit--;
    dwg_dynapi_header_set_value (dwg, "XEDIT", &xedit, 0);

  }
  {
    BITCODE_B extnames;
    if (dwg_dynapi_header_value (dwg, "EXTNAMES", &extnames, NULL)
        && extnames == dwg->header_vars.EXTNAMES)
      pass ();
    else
      fail ("HEADER.EXTNAMES [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.EXTNAMES, extnames);
    extnames++;
    if (dwg_dynapi_header_set_value (dwg, "EXTNAMES", &extnames, 0)
        && extnames == dwg->header_vars.EXTNAMES)
      pass ();
    else
      fail ("HEADER.EXTNAMES [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.EXTNAMES, extnames);
    extnames--;
    dwg_dynapi_header_set_value (dwg, "EXTNAMES", &extnames, 0);

  }
  {
    BITCODE_B pstylemode;
    if (dwg_dynapi_header_value (dwg, "PSTYLEMODE", &pstylemode, NULL)
        && pstylemode == dwg->header_vars.PSTYLEMODE)
      pass ();
    else
      fail ("HEADER.PSTYLEMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSTYLEMODE, pstylemode);
    pstylemode++;
    if (dwg_dynapi_header_set_value (dwg, "PSTYLEMODE", &pstylemode, 0)
        && pstylemode == dwg->header_vars.PSTYLEMODE)
      pass ();
    else
      fail ("HEADER.PSTYLEMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.PSTYLEMODE, pstylemode);
    pstylemode--;
    dwg_dynapi_header_set_value (dwg, "PSTYLEMODE", &pstylemode, 0);

  }
  {
    BITCODE_B olestartup;
    if (dwg_dynapi_header_value (dwg, "OLESTARTUP", &olestartup, NULL)
        && olestartup == dwg->header_vars.OLESTARTUP)
      pass ();
    else
      fail ("HEADER.OLESTARTUP [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.OLESTARTUP, olestartup);
    olestartup++;
    if (dwg_dynapi_header_set_value (dwg, "OLESTARTUP", &olestartup, 0)
        && olestartup == dwg->header_vars.OLESTARTUP)
      pass ();
    else
      fail ("HEADER.OLESTARTUP [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.OLESTARTUP, olestartup);
    olestartup--;
    dwg_dynapi_header_set_value (dwg, "OLESTARTUP", &olestartup, 0);

  }
  {
    BITCODE_BS insunits;
    if (dwg_dynapi_header_value (dwg, "INSUNITS", &insunits, NULL)
        && insunits == dwg->header_vars.INSUNITS)
      pass ();
    else
      fail ("HEADER.INSUNITS [BS] %hu != %hu", dwg->header_vars.INSUNITS, insunits);
    insunits++;
    if (dwg_dynapi_header_set_value (dwg, "INSUNITS", &insunits, 0)
        && insunits == dwg->header_vars.INSUNITS)
      pass ();
    else
      fail ("HEADER.INSUNITS [BS] set+1 %hu != %hu",
            dwg->header_vars.INSUNITS, insunits);
    insunits--;
    dwg_dynapi_header_set_value (dwg, "INSUNITS", &insunits, 0);

  }
  {
    BITCODE_BS cepsntype;
    if (dwg_dynapi_header_value (dwg, "CEPSNTYPE", &cepsntype, NULL)
        && cepsntype == dwg->header_vars.CEPSNTYPE)
      pass ();
    else
      fail ("HEADER.CEPSNTYPE [BS] %hu != %hu", dwg->header_vars.CEPSNTYPE, cepsntype);
    cepsntype++;
    if (dwg_dynapi_header_set_value (dwg, "CEPSNTYPE", &cepsntype, 0)
        && cepsntype == dwg->header_vars.CEPSNTYPE)
      pass ();
    else
      fail ("HEADER.CEPSNTYPE [BS] set+1 %hu != %hu",
            dwg->header_vars.CEPSNTYPE, cepsntype);
    cepsntype--;
    dwg_dynapi_header_set_value (dwg, "CEPSNTYPE", &cepsntype, 0);

  }
  {
    BITCODE_H cpsnid;
    if (dwg_dynapi_header_value (dwg, "CPSNID", &cpsnid, NULL)
        && !memcmp (&cpsnid, &dwg->header_vars.CPSNID, sizeof (dwg->header_vars.CPSNID))
       )
      pass ();
    else
      fail ("HEADER.CPSNID [H]");
  }
  {
    BITCODE_TV fingerprintguid;
    if (dwg_dynapi_header_value (dwg, "FINGERPRINTGUID", &fingerprintguid, NULL)
        && !memcmp (&fingerprintguid, &dwg->header_vars.FINGERPRINTGUID, sizeof (dwg->header_vars.FINGERPRINTGUID))
       )
      pass ();
    else
      fail ("HEADER.FINGERPRINTGUID [TV]");
  }
  {
    BITCODE_TV versionguid;
    if (dwg_dynapi_header_value (dwg, "VERSIONGUID", &versionguid, NULL)
        && !memcmp (&versionguid, &dwg->header_vars.VERSIONGUID, sizeof (dwg->header_vars.VERSIONGUID))
       )
      pass ();
    else
      fail ("HEADER.VERSIONGUID [TV]");
  }
  {
    BITCODE_RC sortents;
    if (dwg_dynapi_header_value (dwg, "SORTENTS", &sortents, NULL)
        && sortents == dwg->header_vars.SORTENTS)
      pass ();
    else
      fail ("HEADER.SORTENTS [RC] %u != %u", dwg->header_vars.SORTENTS, sortents);
    sortents++;
    if (dwg_dynapi_header_set_value (dwg, "SORTENTS", &sortents, 0)
        && sortents == dwg->header_vars.SORTENTS)
      pass ();
    else
      fail ("HEADER.SORTENTS [RC] set+1 %u != %u",
            dwg->header_vars.SORTENTS, sortents);
    sortents--;
    dwg_dynapi_header_set_value (dwg, "SORTENTS", &sortents, 0);

  }
  {
    BITCODE_RC indexctl;
    if (dwg_dynapi_header_value (dwg, "INDEXCTL", &indexctl, NULL)
        && indexctl == dwg->header_vars.INDEXCTL)
      pass ();
    else
      fail ("HEADER.INDEXCTL [RC] %u != %u", dwg->header_vars.INDEXCTL, indexctl);
    indexctl++;
    if (dwg_dynapi_header_set_value (dwg, "INDEXCTL", &indexctl, 0)
        && indexctl == dwg->header_vars.INDEXCTL)
      pass ();
    else
      fail ("HEADER.INDEXCTL [RC] set+1 %u != %u",
            dwg->header_vars.INDEXCTL, indexctl);
    indexctl--;
    dwg_dynapi_header_set_value (dwg, "INDEXCTL", &indexctl, 0);

  }
  {
    BITCODE_RC hidetext;
    if (dwg_dynapi_header_value (dwg, "HIDETEXT", &hidetext, NULL)
        && hidetext == dwg->header_vars.HIDETEXT)
      pass ();
    else
      fail ("HEADER.HIDETEXT [RC] %u != %u", dwg->header_vars.HIDETEXT, hidetext);
    hidetext++;
    if (dwg_dynapi_header_set_value (dwg, "HIDETEXT", &hidetext, 0)
        && hidetext == dwg->header_vars.HIDETEXT)
      pass ();
    else
      fail ("HEADER.HIDETEXT [RC] set+1 %u != %u",
            dwg->header_vars.HIDETEXT, hidetext);
    hidetext--;
    dwg_dynapi_header_set_value (dwg, "HIDETEXT", &hidetext, 0);

  }
  {
    BITCODE_RC xclipframe;
    if (dwg_dynapi_header_value (dwg, "XCLIPFRAME", &xclipframe, NULL)
        && xclipframe == dwg->header_vars.XCLIPFRAME)
      pass ();
    else
      fail ("HEADER.XCLIPFRAME [RC] %u != %u", dwg->header_vars.XCLIPFRAME, xclipframe);
    xclipframe++;
    if (dwg_dynapi_header_set_value (dwg, "XCLIPFRAME", &xclipframe, 0)
        && xclipframe == dwg->header_vars.XCLIPFRAME)
      pass ();
    else
      fail ("HEADER.XCLIPFRAME [RC] set+1 %u != %u",
            dwg->header_vars.XCLIPFRAME, xclipframe);
    xclipframe--;
    dwg_dynapi_header_set_value (dwg, "XCLIPFRAME", &xclipframe, 0);

  }
  {
    BITCODE_RC dimassoc;
    if (dwg_dynapi_header_value (dwg, "DIMASSOC", &dimassoc, NULL)
        && dimassoc == dwg->header_vars.DIMASSOC)
      pass ();
    else
      fail ("HEADER.DIMASSOC [RC] %u != %u", dwg->header_vars.DIMASSOC, dimassoc);
    dimassoc++;
    if (dwg_dynapi_header_set_value (dwg, "DIMASSOC", &dimassoc, 0)
        && dimassoc == dwg->header_vars.DIMASSOC)
      pass ();
    else
      fail ("HEADER.DIMASSOC [RC] set+1 %u != %u",
            dwg->header_vars.DIMASSOC, dimassoc);
    dimassoc--;
    dwg_dynapi_header_set_value (dwg, "DIMASSOC", &dimassoc, 0);

  }
  {
    BITCODE_RC halogap;
    if (dwg_dynapi_header_value (dwg, "HALOGAP", &halogap, NULL)
        && halogap == dwg->header_vars.HALOGAP)
      pass ();
    else
      fail ("HEADER.HALOGAP [RC] %u != %u", dwg->header_vars.HALOGAP, halogap);
    halogap++;
    if (dwg_dynapi_header_set_value (dwg, "HALOGAP", &halogap, 0)
        && halogap == dwg->header_vars.HALOGAP)
      pass ();
    else
      fail ("HEADER.HALOGAP [RC] set+1 %u != %u",
            dwg->header_vars.HALOGAP, halogap);
    halogap--;
    dwg_dynapi_header_set_value (dwg, "HALOGAP", &halogap, 0);

  }
  {
    BITCODE_BS obscolor;
    if (dwg_dynapi_header_value (dwg, "OBSCOLOR", &obscolor, NULL)
        && obscolor == dwg->header_vars.OBSCOLOR)
      pass ();
    else
      fail ("HEADER.OBSCOLOR [BS] %hu != %hu", dwg->header_vars.OBSCOLOR, obscolor);
    obscolor++;
    if (dwg_dynapi_header_set_value (dwg, "OBSCOLOR", &obscolor, 0)
        && obscolor == dwg->header_vars.OBSCOLOR)
      pass ();
    else
      fail ("HEADER.OBSCOLOR [BS] set+1 %hu != %hu",
            dwg->header_vars.OBSCOLOR, obscolor);
    obscolor--;
    dwg_dynapi_header_set_value (dwg, "OBSCOLOR", &obscolor, 0);

  }
  {
    BITCODE_BS intersectioncolor;
    if (dwg_dynapi_header_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, NULL)
        && intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
      pass ();
    else
      fail ("HEADER.INTERSECTIONCOLOR [BS] %hu != %hu", dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor);
    intersectioncolor++;
    if (dwg_dynapi_header_set_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, 0)
        && intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
      pass ();
    else
      fail ("HEADER.INTERSECTIONCOLOR [BS] set+1 %hu != %hu",
            dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor);
    intersectioncolor--;
    dwg_dynapi_header_set_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, 0);

  }
  {
    BITCODE_RC obsltype;
    if (dwg_dynapi_header_value (dwg, "OBSLTYPE", &obsltype, NULL)
        && obsltype == dwg->header_vars.OBSLTYPE)
      pass ();
    else
      fail ("HEADER.OBSLTYPE [RC] %u != %u", dwg->header_vars.OBSLTYPE, obsltype);
    obsltype++;
    if (dwg_dynapi_header_set_value (dwg, "OBSLTYPE", &obsltype, 0)
        && obsltype == dwg->header_vars.OBSLTYPE)
      pass ();
    else
      fail ("HEADER.OBSLTYPE [RC] set+1 %u != %u",
            dwg->header_vars.OBSLTYPE, obsltype);
    obsltype--;
    dwg_dynapi_header_set_value (dwg, "OBSLTYPE", &obsltype, 0);

  }
  {
    BITCODE_RC intersectiondisplay;
    if (dwg_dynapi_header_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, NULL)
        && intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
      pass ();
    else
      fail ("HEADER.INTERSECTIONDISPLAY [RC] %u != %u", dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay);
    intersectiondisplay++;
    if (dwg_dynapi_header_set_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, 0)
        && intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
      pass ();
    else
      fail ("HEADER.INTERSECTIONDISPLAY [RC] set+1 %u != %u",
            dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay);
    intersectiondisplay--;
    dwg_dynapi_header_set_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, 0);

  }
  {
    BITCODE_TV projectname;
    if (dwg_dynapi_header_value (dwg, "PROJECTNAME", &projectname, NULL)
        && !memcmp (&projectname, &dwg->header_vars.PROJECTNAME, sizeof (dwg->header_vars.PROJECTNAME))
       )
      pass ();
    else
      fail ("HEADER.PROJECTNAME [TV]");
  }
  {
    BITCODE_H block_record_pspace;
    if (dwg_dynapi_header_value (dwg, "BLOCK_RECORD_PSPACE", &block_record_pspace, NULL)
        && !memcmp (&block_record_pspace, &dwg->header_vars.BLOCK_RECORD_PSPACE, sizeof (dwg->header_vars.BLOCK_RECORD_PSPACE))
       )
      pass ();
    else
      fail ("HEADER.BLOCK_RECORD_PSPACE [H]");
  }
  {
    BITCODE_H block_record_mspace;
    if (dwg_dynapi_header_value (dwg, "BLOCK_RECORD_MSPACE", &block_record_mspace, NULL)
        && !memcmp (&block_record_mspace, &dwg->header_vars.BLOCK_RECORD_MSPACE, sizeof (dwg->header_vars.BLOCK_RECORD_MSPACE))
       )
      pass ();
    else
      fail ("HEADER.BLOCK_RECORD_MSPACE [H]");
  }
  {
    BITCODE_H ltype_bylayer;
    if (dwg_dynapi_header_value (dwg, "LTYPE_BYLAYER", &ltype_bylayer, NULL)
        && !memcmp (&ltype_bylayer, &dwg->header_vars.LTYPE_BYLAYER, sizeof (dwg->header_vars.LTYPE_BYLAYER))
       )
      pass ();
    else
      fail ("HEADER.LTYPE_BYLAYER [H]");
  }
  {
    BITCODE_H ltype_byblock;
    if (dwg_dynapi_header_value (dwg, "LTYPE_BYBLOCK", &ltype_byblock, NULL)
        && !memcmp (&ltype_byblock, &dwg->header_vars.LTYPE_BYBLOCK, sizeof (dwg->header_vars.LTYPE_BYBLOCK))
       )
      pass ();
    else
      fail ("HEADER.LTYPE_BYBLOCK [H]");
  }
  {
    BITCODE_H ltype_continuous;
    if (dwg_dynapi_header_value (dwg, "LTYPE_CONTINUOUS", &ltype_continuous, NULL)
        && !memcmp (&ltype_continuous, &dwg->header_vars.LTYPE_CONTINUOUS, sizeof (dwg->header_vars.LTYPE_CONTINUOUS))
       )
      pass ();
    else
      fail ("HEADER.LTYPE_CONTINUOUS [H]");
  }
  {
    BITCODE_B cameradisplay;
    if (dwg_dynapi_header_value (dwg, "CAMERADISPLAY", &cameradisplay, NULL)
        && cameradisplay == dwg->header_vars.CAMERADISPLAY)
      pass ();
    else
      fail ("HEADER.CAMERADISPLAY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.CAMERADISPLAY, cameradisplay);
    cameradisplay++;
    if (dwg_dynapi_header_set_value (dwg, "CAMERADISPLAY", &cameradisplay, 0)
        && cameradisplay == dwg->header_vars.CAMERADISPLAY)
      pass ();
    else
      fail ("HEADER.CAMERADISPLAY [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.CAMERADISPLAY, cameradisplay);
    cameradisplay--;
    dwg_dynapi_header_set_value (dwg, "CAMERADISPLAY", &cameradisplay, 0);

  }
  {
    BITCODE_BL unknown_21;
    if (dwg_dynapi_header_value (dwg, "unknown_21", &unknown_21, NULL)
        && unknown_21 == dwg->header_vars.unknown_21)
      pass ();
    else
      fail ("HEADER.unknown_21 [BL] %u != %u", dwg->header_vars.unknown_21, unknown_21);
    unknown_21++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_21", &unknown_21, 0)
        && unknown_21 == dwg->header_vars.unknown_21)
      pass ();
    else
      fail ("HEADER.unknown_21 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_21, unknown_21);
    unknown_21--;
    dwg_dynapi_header_set_value (dwg, "unknown_21", &unknown_21, 0);

  }
  {
    BITCODE_BL unknown_22;
    if (dwg_dynapi_header_value (dwg, "unknown_22", &unknown_22, NULL)
        && unknown_22 == dwg->header_vars.unknown_22)
      pass ();
    else
      fail ("HEADER.unknown_22 [BL] %u != %u", dwg->header_vars.unknown_22, unknown_22);
    unknown_22++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_22", &unknown_22, 0)
        && unknown_22 == dwg->header_vars.unknown_22)
      pass ();
    else
      fail ("HEADER.unknown_22 [BL] set+1 %u != %u",
            dwg->header_vars.unknown_22, unknown_22);
    unknown_22--;
    dwg_dynapi_header_set_value (dwg, "unknown_22", &unknown_22, 0);

  }
  {
    BITCODE_BD unknown_23;
    if (dwg_dynapi_header_value (dwg, "unknown_23", &unknown_23, NULL)
        && unknown_23 == dwg->header_vars.unknown_23)
      pass ();
    else
      fail ("HEADER.unknown_23 [BD] %g != %g", dwg->header_vars.unknown_23, unknown_23);
    unknown_23++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_23", &unknown_23, 0)
        && unknown_23 == dwg->header_vars.unknown_23)
      pass ();
    else
      fail ("HEADER.unknown_23 [BD] set+1 %g != %g",
            dwg->header_vars.unknown_23, unknown_23);
    unknown_23--;
    dwg_dynapi_header_set_value (dwg, "unknown_23", &unknown_23, 0);

  }
  {
    BITCODE_BD stepspersec;
    if (dwg_dynapi_header_value (dwg, "STEPSPERSEC", &stepspersec, NULL)
        && stepspersec == dwg->header_vars.STEPSPERSEC)
      pass ();
    else
      fail ("HEADER.STEPSPERSEC [BD] %g != %g", dwg->header_vars.STEPSPERSEC, stepspersec);
    stepspersec++;
    if (dwg_dynapi_header_set_value (dwg, "STEPSPERSEC", &stepspersec, 0)
        && stepspersec == dwg->header_vars.STEPSPERSEC)
      pass ();
    else
      fail ("HEADER.STEPSPERSEC [BD] set+1 %g != %g",
            dwg->header_vars.STEPSPERSEC, stepspersec);
    stepspersec--;
    dwg_dynapi_header_set_value (dwg, "STEPSPERSEC", &stepspersec, 0);

  }
  {
    BITCODE_BD stepsize;
    if (dwg_dynapi_header_value (dwg, "STEPSIZE", &stepsize, NULL)
        && stepsize == dwg->header_vars.STEPSIZE)
      pass ();
    else
      fail ("HEADER.STEPSIZE [BD] %g != %g", dwg->header_vars.STEPSIZE, stepsize);
    stepsize++;
    if (dwg_dynapi_header_set_value (dwg, "STEPSIZE", &stepsize, 0)
        && stepsize == dwg->header_vars.STEPSIZE)
      pass ();
    else
      fail ("HEADER.STEPSIZE [BD] set+1 %g != %g",
            dwg->header_vars.STEPSIZE, stepsize);
    stepsize--;
    dwg_dynapi_header_set_value (dwg, "STEPSIZE", &stepsize, 0);

  }
  {
    BITCODE_BD _3ddwfprec;
    if (dwg_dynapi_header_value (dwg, "_3DDWFPREC", &_3ddwfprec, NULL)
        && _3ddwfprec == dwg->header_vars._3DDWFPREC)
      pass ();
    else
      fail ("HEADER._3DDWFPREC [BD] %g != %g", dwg->header_vars._3DDWFPREC, _3ddwfprec);
    _3ddwfprec++;
    if (dwg_dynapi_header_set_value (dwg, "_3DDWFPREC", &_3ddwfprec, 0)
        && _3ddwfprec == dwg->header_vars._3DDWFPREC)
      pass ();
    else
      fail ("HEADER._3DDWFPREC [BD] set+1 %g != %g",
            dwg->header_vars._3DDWFPREC, _3ddwfprec);
    _3ddwfprec--;
    dwg_dynapi_header_set_value (dwg, "_3DDWFPREC", &_3ddwfprec, 0);

  }
  {
    BITCODE_BD lenslength;
    if (dwg_dynapi_header_value (dwg, "LENSLENGTH", &lenslength, NULL)
        && lenslength == dwg->header_vars.LENSLENGTH)
      pass ();
    else
      fail ("HEADER.LENSLENGTH [BD] %g != %g", dwg->header_vars.LENSLENGTH, lenslength);
    lenslength++;
    if (dwg_dynapi_header_set_value (dwg, "LENSLENGTH", &lenslength, 0)
        && lenslength == dwg->header_vars.LENSLENGTH)
      pass ();
    else
      fail ("HEADER.LENSLENGTH [BD] set+1 %g != %g",
            dwg->header_vars.LENSLENGTH, lenslength);
    lenslength--;
    dwg_dynapi_header_set_value (dwg, "LENSLENGTH", &lenslength, 0);

  }
  {
    BITCODE_BD cameraheight;
    if (dwg_dynapi_header_value (dwg, "CAMERAHEIGHT", &cameraheight, NULL)
        && cameraheight == dwg->header_vars.CAMERAHEIGHT)
      pass ();
    else
      fail ("HEADER.CAMERAHEIGHT [BD] %g != %g", dwg->header_vars.CAMERAHEIGHT, cameraheight);
    cameraheight++;
    if (dwg_dynapi_header_set_value (dwg, "CAMERAHEIGHT", &cameraheight, 0)
        && cameraheight == dwg->header_vars.CAMERAHEIGHT)
      pass ();
    else
      fail ("HEADER.CAMERAHEIGHT [BD] set+1 %g != %g",
            dwg->header_vars.CAMERAHEIGHT, cameraheight);
    cameraheight--;
    dwg_dynapi_header_set_value (dwg, "CAMERAHEIGHT", &cameraheight, 0);

  }
  {
    BITCODE_RC solidhist;
    if (dwg_dynapi_header_value (dwg, "SOLIDHIST", &solidhist, NULL)
        && solidhist == dwg->header_vars.SOLIDHIST)
      pass ();
    else
      fail ("HEADER.SOLIDHIST [RC] %u != %u", dwg->header_vars.SOLIDHIST, solidhist);
    solidhist++;
    if (dwg_dynapi_header_set_value (dwg, "SOLIDHIST", &solidhist, 0)
        && solidhist == dwg->header_vars.SOLIDHIST)
      pass ();
    else
      fail ("HEADER.SOLIDHIST [RC] set+1 %u != %u",
            dwg->header_vars.SOLIDHIST, solidhist);
    solidhist--;
    dwg_dynapi_header_set_value (dwg, "SOLIDHIST", &solidhist, 0);

  }
  {
    BITCODE_RC showhist;
    if (dwg_dynapi_header_value (dwg, "SHOWHIST", &showhist, NULL)
        && showhist == dwg->header_vars.SHOWHIST)
      pass ();
    else
      fail ("HEADER.SHOWHIST [RC] %u != %u", dwg->header_vars.SHOWHIST, showhist);
    showhist++;
    if (dwg_dynapi_header_set_value (dwg, "SHOWHIST", &showhist, 0)
        && showhist == dwg->header_vars.SHOWHIST)
      pass ();
    else
      fail ("HEADER.SHOWHIST [RC] set+1 %u != %u",
            dwg->header_vars.SHOWHIST, showhist);
    showhist--;
    dwg_dynapi_header_set_value (dwg, "SHOWHIST", &showhist, 0);

  }
  {
    BITCODE_BD psolwidth;
    if (dwg_dynapi_header_value (dwg, "PSOLWIDTH", &psolwidth, NULL)
        && psolwidth == dwg->header_vars.PSOLWIDTH)
      pass ();
    else
      fail ("HEADER.PSOLWIDTH [BD] %g != %g", dwg->header_vars.PSOLWIDTH, psolwidth);
    psolwidth++;
    if (dwg_dynapi_header_set_value (dwg, "PSOLWIDTH", &psolwidth, 0)
        && psolwidth == dwg->header_vars.PSOLWIDTH)
      pass ();
    else
      fail ("HEADER.PSOLWIDTH [BD] set+1 %g != %g",
            dwg->header_vars.PSOLWIDTH, psolwidth);
    psolwidth--;
    dwg_dynapi_header_set_value (dwg, "PSOLWIDTH", &psolwidth, 0);

  }
  {
    BITCODE_BD psolheight;
    if (dwg_dynapi_header_value (dwg, "PSOLHEIGHT", &psolheight, NULL)
        && psolheight == dwg->header_vars.PSOLHEIGHT)
      pass ();
    else
      fail ("HEADER.PSOLHEIGHT [BD] %g != %g", dwg->header_vars.PSOLHEIGHT, psolheight);
    psolheight++;
    if (dwg_dynapi_header_set_value (dwg, "PSOLHEIGHT", &psolheight, 0)
        && psolheight == dwg->header_vars.PSOLHEIGHT)
      pass ();
    else
      fail ("HEADER.PSOLHEIGHT [BD] set+1 %g != %g",
            dwg->header_vars.PSOLHEIGHT, psolheight);
    psolheight--;
    dwg_dynapi_header_set_value (dwg, "PSOLHEIGHT", &psolheight, 0);

  }
  {
    BITCODE_BD loftang1;
    if (dwg_dynapi_header_value (dwg, "LOFTANG1", &loftang1, NULL)
        && loftang1 == dwg->header_vars.LOFTANG1)
      pass ();
    else
      fail ("HEADER.LOFTANG1 [BD] %g != %g", dwg->header_vars.LOFTANG1, loftang1);
    loftang1++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTANG1", &loftang1, 0)
        && loftang1 == dwg->header_vars.LOFTANG1)
      pass ();
    else
      fail ("HEADER.LOFTANG1 [BD] set+1 %g != %g",
            dwg->header_vars.LOFTANG1, loftang1);
    loftang1--;
    dwg_dynapi_header_set_value (dwg, "LOFTANG1", &loftang1, 0);

  }
  {
    BITCODE_BD loftang2;
    if (dwg_dynapi_header_value (dwg, "LOFTANG2", &loftang2, NULL)
        && loftang2 == dwg->header_vars.LOFTANG2)
      pass ();
    else
      fail ("HEADER.LOFTANG2 [BD] %g != %g", dwg->header_vars.LOFTANG2, loftang2);
    loftang2++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTANG2", &loftang2, 0)
        && loftang2 == dwg->header_vars.LOFTANG2)
      pass ();
    else
      fail ("HEADER.LOFTANG2 [BD] set+1 %g != %g",
            dwg->header_vars.LOFTANG2, loftang2);
    loftang2--;
    dwg_dynapi_header_set_value (dwg, "LOFTANG2", &loftang2, 0);

  }
  {
    BITCODE_BD loftmag1;
    if (dwg_dynapi_header_value (dwg, "LOFTMAG1", &loftmag1, NULL)
        && loftmag1 == dwg->header_vars.LOFTMAG1)
      pass ();
    else
      fail ("HEADER.LOFTMAG1 [BD] %g != %g", dwg->header_vars.LOFTMAG1, loftmag1);
    loftmag1++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTMAG1", &loftmag1, 0)
        && loftmag1 == dwg->header_vars.LOFTMAG1)
      pass ();
    else
      fail ("HEADER.LOFTMAG1 [BD] set+1 %g != %g",
            dwg->header_vars.LOFTMAG1, loftmag1);
    loftmag1--;
    dwg_dynapi_header_set_value (dwg, "LOFTMAG1", &loftmag1, 0);

  }
  {
    BITCODE_BD loftmag2;
    if (dwg_dynapi_header_value (dwg, "LOFTMAG2", &loftmag2, NULL)
        && loftmag2 == dwg->header_vars.LOFTMAG2)
      pass ();
    else
      fail ("HEADER.LOFTMAG2 [BD] %g != %g", dwg->header_vars.LOFTMAG2, loftmag2);
    loftmag2++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTMAG2", &loftmag2, 0)
        && loftmag2 == dwg->header_vars.LOFTMAG2)
      pass ();
    else
      fail ("HEADER.LOFTMAG2 [BD] set+1 %g != %g",
            dwg->header_vars.LOFTMAG2, loftmag2);
    loftmag2--;
    dwg_dynapi_header_set_value (dwg, "LOFTMAG2", &loftmag2, 0);

  }
  {
    BITCODE_BS loftparam;
    if (dwg_dynapi_header_value (dwg, "LOFTPARAM", &loftparam, NULL)
        && loftparam == dwg->header_vars.LOFTPARAM)
      pass ();
    else
      fail ("HEADER.LOFTPARAM [BS] %hu != %hu", dwg->header_vars.LOFTPARAM, loftparam);
    loftparam++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTPARAM", &loftparam, 0)
        && loftparam == dwg->header_vars.LOFTPARAM)
      pass ();
    else
      fail ("HEADER.LOFTPARAM [BS] set+1 %hu != %hu",
            dwg->header_vars.LOFTPARAM, loftparam);
    loftparam--;
    dwg_dynapi_header_set_value (dwg, "LOFTPARAM", &loftparam, 0);

  }
  {
    BITCODE_RC loftnormals;
    if (dwg_dynapi_header_value (dwg, "LOFTNORMALS", &loftnormals, NULL)
        && loftnormals == dwg->header_vars.LOFTNORMALS)
      pass ();
    else
      fail ("HEADER.LOFTNORMALS [RC] %u != %u", dwg->header_vars.LOFTNORMALS, loftnormals);
    loftnormals++;
    if (dwg_dynapi_header_set_value (dwg, "LOFTNORMALS", &loftnormals, 0)
        && loftnormals == dwg->header_vars.LOFTNORMALS)
      pass ();
    else
      fail ("HEADER.LOFTNORMALS [RC] set+1 %u != %u",
            dwg->header_vars.LOFTNORMALS, loftnormals);
    loftnormals--;
    dwg_dynapi_header_set_value (dwg, "LOFTNORMALS", &loftnormals, 0);

  }
  {
    BITCODE_BD latitude;
    if (dwg_dynapi_header_value (dwg, "LATITUDE", &latitude, NULL)
        && latitude == dwg->header_vars.LATITUDE)
      pass ();
    else
      fail ("HEADER.LATITUDE [BD] %g != %g", dwg->header_vars.LATITUDE, latitude);
    latitude++;
    if (dwg_dynapi_header_set_value (dwg, "LATITUDE", &latitude, 0)
        && latitude == dwg->header_vars.LATITUDE)
      pass ();
    else
      fail ("HEADER.LATITUDE [BD] set+1 %g != %g",
            dwg->header_vars.LATITUDE, latitude);
    latitude--;
    dwg_dynapi_header_set_value (dwg, "LATITUDE", &latitude, 0);

  }
  {
    BITCODE_BD longitude;
    if (dwg_dynapi_header_value (dwg, "LONGITUDE", &longitude, NULL)
        && longitude == dwg->header_vars.LONGITUDE)
      pass ();
    else
      fail ("HEADER.LONGITUDE [BD] %g != %g", dwg->header_vars.LONGITUDE, longitude);
    longitude++;
    if (dwg_dynapi_header_set_value (dwg, "LONGITUDE", &longitude, 0)
        && longitude == dwg->header_vars.LONGITUDE)
      pass ();
    else
      fail ("HEADER.LONGITUDE [BD] set+1 %g != %g",
            dwg->header_vars.LONGITUDE, longitude);
    longitude--;
    dwg_dynapi_header_set_value (dwg, "LONGITUDE", &longitude, 0);

  }
  {
    BITCODE_BD northdirection;
    if (dwg_dynapi_header_value (dwg, "NORTHDIRECTION", &northdirection, NULL)
        && northdirection == dwg->header_vars.NORTHDIRECTION)
      pass ();
    else
      fail ("HEADER.NORTHDIRECTION [BD] %g != %g", dwg->header_vars.NORTHDIRECTION, northdirection);
    northdirection++;
    if (dwg_dynapi_header_set_value (dwg, "NORTHDIRECTION", &northdirection, 0)
        && northdirection == dwg->header_vars.NORTHDIRECTION)
      pass ();
    else
      fail ("HEADER.NORTHDIRECTION [BD] set+1 %g != %g",
            dwg->header_vars.NORTHDIRECTION, northdirection);
    northdirection--;
    dwg_dynapi_header_set_value (dwg, "NORTHDIRECTION", &northdirection, 0);

  }
  {
    BITCODE_BL timezn;
    if (dwg_dynapi_header_value (dwg, "TIMEZONE", &timezn, NULL)
        && timezn == dwg->header_vars.TIMEZONE)
      pass ();
    else
      fail ("HEADER.TIMEZONE [BL] %u != %u", dwg->header_vars.TIMEZONE, timezn);
    timezn++;
    if (dwg_dynapi_header_set_value (dwg, "TIMEZONE", &timezn, 0)
        && timezn == dwg->header_vars.TIMEZONE)
      pass ();
    else
      fail ("HEADER.TIMEZONE [BL] set+1 %u != %u",
            dwg->header_vars.TIMEZONE, timezn);
    timezn--;
    dwg_dynapi_header_set_value (dwg, "TIMEZONE", &timezn, 0);

  }
  {
    BITCODE_RC lightglyphdisplay;
    if (dwg_dynapi_header_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, NULL)
        && lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
      pass ();
    else
      fail ("HEADER.LIGHTGLYPHDISPLAY [RC] %u != %u", dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay);
    lightglyphdisplay++;
    if (dwg_dynapi_header_set_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, 0)
        && lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
      pass ();
    else
      fail ("HEADER.LIGHTGLYPHDISPLAY [RC] set+1 %u != %u",
            dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay);
    lightglyphdisplay--;
    dwg_dynapi_header_set_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, 0);

  }
  {
    BITCODE_RC tilemodelightsynch;
    if (dwg_dynapi_header_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, NULL)
        && tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
      pass ();
    else
      fail ("HEADER.TILEMODELIGHTSYNCH [RC] %u != %u", dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch);
    tilemodelightsynch++;
    if (dwg_dynapi_header_set_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, 0)
        && tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
      pass ();
    else
      fail ("HEADER.TILEMODELIGHTSYNCH [RC] set+1 %u != %u",
            dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch);
    tilemodelightsynch--;
    dwg_dynapi_header_set_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, 0);

  }
  {
    BITCODE_RC dwfframe;
    if (dwg_dynapi_header_value (dwg, "DWFFRAME", &dwfframe, NULL)
        && dwfframe == dwg->header_vars.DWFFRAME)
      pass ();
    else
      fail ("HEADER.DWFFRAME [RC] %u != %u", dwg->header_vars.DWFFRAME, dwfframe);
    dwfframe++;
    if (dwg_dynapi_header_set_value (dwg, "DWFFRAME", &dwfframe, 0)
        && dwfframe == dwg->header_vars.DWFFRAME)
      pass ();
    else
      fail ("HEADER.DWFFRAME [RC] set+1 %u != %u",
            dwg->header_vars.DWFFRAME, dwfframe);
    dwfframe--;
    dwg_dynapi_header_set_value (dwg, "DWFFRAME", &dwfframe, 0);

  }
  {
    BITCODE_RC dgnframe;
    if (dwg_dynapi_header_value (dwg, "DGNFRAME", &dgnframe, NULL)
        && dgnframe == dwg->header_vars.DGNFRAME)
      pass ();
    else
      fail ("HEADER.DGNFRAME [RC] %u != %u", dwg->header_vars.DGNFRAME, dgnframe);
    dgnframe++;
    if (dwg_dynapi_header_set_value (dwg, "DGNFRAME", &dgnframe, 0)
        && dgnframe == dwg->header_vars.DGNFRAME)
      pass ();
    else
      fail ("HEADER.DGNFRAME [RC] set+1 %u != %u",
            dwg->header_vars.DGNFRAME, dgnframe);
    dgnframe--;
    dwg_dynapi_header_set_value (dwg, "DGNFRAME", &dgnframe, 0);

  }
  {
    BITCODE_B realworldscale;
    if (dwg_dynapi_header_value (dwg, "REALWORLDSCALE", &realworldscale, NULL)
        && realworldscale == dwg->header_vars.REALWORLDSCALE)
      pass ();
    else
      fail ("HEADER.REALWORLDSCALE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REALWORLDSCALE, realworldscale);
    realworldscale++;
    if (dwg_dynapi_header_set_value (dwg, "REALWORLDSCALE", &realworldscale, 0)
        && realworldscale == dwg->header_vars.REALWORLDSCALE)
      pass ();
    else
      fail ("HEADER.REALWORLDSCALE [B] set+1 " FORMAT_B " != " FORMAT_B "",
            dwg->header_vars.REALWORLDSCALE, realworldscale);
    realworldscale--;
    dwg_dynapi_header_set_value (dwg, "REALWORLDSCALE", &realworldscale, 0);

  }
  {
    BITCODE_CMC interferecolor;
    if (dwg_dynapi_header_value (dwg, "INTERFERECOLOR", &interferecolor, NULL)
        && !memcmp (&interferecolor, &dwg->header_vars.INTERFERECOLOR, sizeof (dwg->header_vars.INTERFERECOLOR))
       )
      pass ();
    else
      fail ("HEADER.INTERFERECOLOR [CMC]");
  }
  {
    BITCODE_H interfereobjvs;
    if (dwg_dynapi_header_value (dwg, "INTERFEREOBJVS", &interfereobjvs, NULL)
        && !memcmp (&interfereobjvs, &dwg->header_vars.INTERFEREOBJVS, sizeof (dwg->header_vars.INTERFEREOBJVS))
       )
      pass ();
    else
      fail ("HEADER.INTERFEREOBJVS [H]");
  }
  {
    BITCODE_H interferevpvs;
    if (dwg_dynapi_header_value (dwg, "INTERFEREVPVS", &interferevpvs, NULL)
        && !memcmp (&interferevpvs, &dwg->header_vars.INTERFEREVPVS, sizeof (dwg->header_vars.INTERFEREVPVS))
       )
      pass ();
    else
      fail ("HEADER.INTERFEREVPVS [H]");
  }
  {
    BITCODE_H dragvs;
    if (dwg_dynapi_header_value (dwg, "DRAGVS", &dragvs, NULL)
        && !memcmp (&dragvs, &dwg->header_vars.DRAGVS, sizeof (dwg->header_vars.DRAGVS))
       )
      pass ();
    else
      fail ("HEADER.DRAGVS [H]");
  }
  {
    BITCODE_RC cshadow;
    if (dwg_dynapi_header_value (dwg, "CSHADOW", &cshadow, NULL)
        && cshadow == dwg->header_vars.CSHADOW)
      pass ();
    else
      fail ("HEADER.CSHADOW [RC] %u != %u", dwg->header_vars.CSHADOW, cshadow);
    cshadow++;
    if (dwg_dynapi_header_set_value (dwg, "CSHADOW", &cshadow, 0)
        && cshadow == dwg->header_vars.CSHADOW)
      pass ();
    else
      fail ("HEADER.CSHADOW [RC] set+1 %u != %u",
            dwg->header_vars.CSHADOW, cshadow);
    cshadow--;
    dwg_dynapi_header_set_value (dwg, "CSHADOW", &cshadow, 0);

  }
  {
    BITCODE_BD shadowplanelocation;
    if (dwg_dynapi_header_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, NULL)
        && shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
      pass ();
    else
      fail ("HEADER.SHADOWPLANELOCATION [BD] %g != %g", dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation);
    shadowplanelocation++;
    if (dwg_dynapi_header_set_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, 0)
        && shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
      pass ();
    else
      fail ("HEADER.SHADOWPLANELOCATION [BD] set+1 %g != %g",
            dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation);
    shadowplanelocation--;
    dwg_dynapi_header_set_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, 0);

  }
  {
    BITCODE_BS unknown_54;
    if (dwg_dynapi_header_value (dwg, "unknown_54", &unknown_54, NULL)
        && unknown_54 == dwg->header_vars.unknown_54)
      pass ();
    else
      fail ("HEADER.unknown_54 [BS] %hu != %hu", dwg->header_vars.unknown_54, unknown_54);
    unknown_54++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_54", &unknown_54, 0)
        && unknown_54 == dwg->header_vars.unknown_54)
      pass ();
    else
      fail ("HEADER.unknown_54 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_54, unknown_54);
    unknown_54--;
    dwg_dynapi_header_set_value (dwg, "unknown_54", &unknown_54, 0);

  }
  {
    BITCODE_BS unknown_55;
    if (dwg_dynapi_header_value (dwg, "unknown_55", &unknown_55, NULL)
        && unknown_55 == dwg->header_vars.unknown_55)
      pass ();
    else
      fail ("HEADER.unknown_55 [BS] %hu != %hu", dwg->header_vars.unknown_55, unknown_55);
    unknown_55++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_55", &unknown_55, 0)
        && unknown_55 == dwg->header_vars.unknown_55)
      pass ();
    else
      fail ("HEADER.unknown_55 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_55, unknown_55);
    unknown_55--;
    dwg_dynapi_header_set_value (dwg, "unknown_55", &unknown_55, 0);

  }
  {
    BITCODE_BS unknown_56;
    if (dwg_dynapi_header_value (dwg, "unknown_56", &unknown_56, NULL)
        && unknown_56 == dwg->header_vars.unknown_56)
      pass ();
    else
      fail ("HEADER.unknown_56 [BS] %hu != %hu", dwg->header_vars.unknown_56, unknown_56);
    unknown_56++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_56", &unknown_56, 0)
        && unknown_56 == dwg->header_vars.unknown_56)
      pass ();
    else
      fail ("HEADER.unknown_56 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_56, unknown_56);
    unknown_56--;
    dwg_dynapi_header_set_value (dwg, "unknown_56", &unknown_56, 0);

  }
  {
    BITCODE_BS unknown_57;
    if (dwg_dynapi_header_value (dwg, "unknown_57", &unknown_57, NULL)
        && unknown_57 == dwg->header_vars.unknown_57)
      pass ();
    else
      fail ("HEADER.unknown_57 [BS] %hu != %hu", dwg->header_vars.unknown_57, unknown_57);
    unknown_57++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_57", &unknown_57, 0)
        && unknown_57 == dwg->header_vars.unknown_57)
      pass ();
    else
      fail ("HEADER.unknown_57 [BS] set+1 %hu != %hu",
            dwg->header_vars.unknown_57, unknown_57);
    unknown_57--;
    dwg_dynapi_header_set_value (dwg, "unknown_57", &unknown_57, 0);

  }
  {
    BITCODE_RL dwg_size;
    if (dwg_dynapi_header_value (dwg, "dwg_size", &dwg_size, NULL)
        && dwg_size == dwg->header_vars.dwg_size)
      pass ();
    else
      fail ("HEADER.dwg_size [RL] %u != %u", dwg->header_vars.dwg_size, dwg_size);
    dwg_size++;
    if (dwg_dynapi_header_set_value (dwg, "dwg_size", &dwg_size, 0)
        && dwg_size == dwg->header_vars.dwg_size)
      pass ();
    else
      fail ("HEADER.dwg_size [RL] set+1 %u != %u",
            dwg->header_vars.dwg_size, dwg_size);
    dwg_size--;
    dwg_dynapi_header_set_value (dwg, "dwg_size", &dwg_size, 0);

  }
  {
    BITCODE_RS numentities;
    if (dwg_dynapi_header_value (dwg, "numentities", &numentities, NULL)
        && numentities == dwg->header_vars.numentities)
      pass ();
    else
      fail ("HEADER.numentities [RS] %hu != %hu", dwg->header_vars.numentities, numentities);
    numentities++;
    if (dwg_dynapi_header_set_value (dwg, "numentities", &numentities, 0)
        && numentities == dwg->header_vars.numentities)
      pass ();
    else
      fail ("HEADER.numentities [RS] set+1 %hu != %hu",
            dwg->header_vars.numentities, numentities);
    numentities--;
    dwg_dynapi_header_set_value (dwg, "numentities", &numentities, 0);

  }
  {
    BITCODE_RS circle_zoom_percent;
    if (dwg_dynapi_header_value (dwg, "circle_zoom_percent", &circle_zoom_percent, NULL)
        && circle_zoom_percent == dwg->header_vars.circle_zoom_percent)
      pass ();
    else
      fail ("HEADER.circle_zoom_percent [RS] %hu != %hu", dwg->header_vars.circle_zoom_percent, circle_zoom_percent);
    circle_zoom_percent++;
    if (dwg_dynapi_header_set_value (dwg, "circle_zoom_percent", &circle_zoom_percent, 0)
        && circle_zoom_percent == dwg->header_vars.circle_zoom_percent)
      pass ();
    else
      fail ("HEADER.circle_zoom_percent [RS] set+1 %hu != %hu",
            dwg->header_vars.circle_zoom_percent, circle_zoom_percent);
    circle_zoom_percent--;
    dwg_dynapi_header_set_value (dwg, "circle_zoom_percent", &circle_zoom_percent, 0);

  }
  {
    BITCODE_BD frontz;
    if (dwg_dynapi_header_value (dwg, "FRONTZ", &frontz, NULL)
        && frontz == dwg->header_vars.FRONTZ)
      pass ();
    else
      fail ("HEADER.FRONTZ [BD] %g != %g", dwg->header_vars.FRONTZ, frontz);
    frontz++;
    if (dwg_dynapi_header_set_value (dwg, "FRONTZ", &frontz, 0)
        && frontz == dwg->header_vars.FRONTZ)
      pass ();
    else
      fail ("HEADER.FRONTZ [BD] set+1 %g != %g",
            dwg->header_vars.FRONTZ, frontz);
    frontz--;
    dwg_dynapi_header_set_value (dwg, "FRONTZ", &frontz, 0);

  }
  {
    BITCODE_BD backz;
    if (dwg_dynapi_header_value (dwg, "BACKZ", &backz, NULL)
        && backz == dwg->header_vars.BACKZ)
      pass ();
    else
      fail ("HEADER.BACKZ [BD] %g != %g", dwg->header_vars.BACKZ, backz);
    backz++;
    if (dwg_dynapi_header_set_value (dwg, "BACKZ", &backz, 0)
        && backz == dwg->header_vars.BACKZ)
      pass ();
    else
      fail ("HEADER.BACKZ [BD] set+1 %g != %g",
            dwg->header_vars.BACKZ, backz);
    backz--;
    dwg_dynapi_header_set_value (dwg, "BACKZ", &backz, 0);

  }
  {
    BITCODE_RC ucsicon;
    if (dwg_dynapi_header_value (dwg, "UCSICON", &ucsicon, NULL)
        && ucsicon == dwg->header_vars.UCSICON)
      pass ();
    else
      fail ("HEADER.UCSICON [RC] %u != %u", dwg->header_vars.UCSICON, ucsicon);
    ucsicon++;
    if (dwg_dynapi_header_set_value (dwg, "UCSICON", &ucsicon, 0)
        && ucsicon == dwg->header_vars.UCSICON)
      pass ();
    else
      fail ("HEADER.UCSICON [RC] set+1 %u != %u",
            dwg->header_vars.UCSICON, ucsicon);
    ucsicon--;
    dwg_dynapi_header_set_value (dwg, "UCSICON", &ucsicon, 0);

  }
  {
    BITCODE_RL oldcecolor_hi;
    if (dwg_dynapi_header_value (dwg, "oldCECOLOR_hi", &oldcecolor_hi, NULL)
        && oldcecolor_hi == dwg->header_vars.oldCECOLOR_hi)
      pass ();
    else
      fail ("HEADER.oldCECOLOR_hi [RL] %u != %u", dwg->header_vars.oldCECOLOR_hi, oldcecolor_hi);
    oldcecolor_hi++;
    if (dwg_dynapi_header_set_value (dwg, "oldCECOLOR_hi", &oldcecolor_hi, 0)
        && oldcecolor_hi == dwg->header_vars.oldCECOLOR_hi)
      pass ();
    else
      fail ("HEADER.oldCECOLOR_hi [RL] set+1 %u != %u",
            dwg->header_vars.oldCECOLOR_hi, oldcecolor_hi);
    oldcecolor_hi--;
    dwg_dynapi_header_set_value (dwg, "oldCECOLOR_hi", &oldcecolor_hi, 0);

  }
  {
    BITCODE_RL oldcecolor_lo;
    if (dwg_dynapi_header_value (dwg, "oldCECOLOR_lo", &oldcecolor_lo, NULL)
        && oldcecolor_lo == dwg->header_vars.oldCECOLOR_lo)
      pass ();
    else
      fail ("HEADER.oldCECOLOR_lo [RL] %u != %u", dwg->header_vars.oldCECOLOR_lo, oldcecolor_lo);
    oldcecolor_lo++;
    if (dwg_dynapi_header_set_value (dwg, "oldCECOLOR_lo", &oldcecolor_lo, 0)
        && oldcecolor_lo == dwg->header_vars.oldCECOLOR_lo)
      pass ();
    else
      fail ("HEADER.oldCECOLOR_lo [RL] set+1 %u != %u",
            dwg->header_vars.oldCECOLOR_lo, oldcecolor_lo);
    oldcecolor_lo--;
    dwg_dynapi_header_set_value (dwg, "oldCECOLOR_lo", &oldcecolor_lo, 0);

  }
  {
    BITCODE_RS layer_colors[128];
    if (dwg_dynapi_header_value (dwg, "layer_colors[128]", &layer_colors, NULL)
        && !memcmp (&layer_colors, &dwg->header_vars.layer_colors, sizeof (dwg->header_vars.layer_colors))
       )
      pass ();
    else
      fail ("HEADER.layer_colors[128] [RS]");
  }
  {
    BITCODE_RS unknown_51e;
    if (dwg_dynapi_header_value (dwg, "unknown_51e", &unknown_51e, NULL)
        && unknown_51e == dwg->header_vars.unknown_51e)
      pass ();
    else
      fail ("HEADER.unknown_51e [RS] %hu != %hu", dwg->header_vars.unknown_51e, unknown_51e);
    unknown_51e++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_51e", &unknown_51e, 0)
        && unknown_51e == dwg->header_vars.unknown_51e)
      pass ();
    else
      fail ("HEADER.unknown_51e [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_51e, unknown_51e);
    unknown_51e--;
    dwg_dynapi_header_set_value (dwg, "unknown_51e", &unknown_51e, 0);

  }
  {
    BITCODE_RS unknown_520;
    if (dwg_dynapi_header_value (dwg, "unknown_520", &unknown_520, NULL)
        && unknown_520 == dwg->header_vars.unknown_520)
      pass ();
    else
      fail ("HEADER.unknown_520 [RS] %hu != %hu", dwg->header_vars.unknown_520, unknown_520);
    unknown_520++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_520", &unknown_520, 0)
        && unknown_520 == dwg->header_vars.unknown_520)
      pass ();
    else
      fail ("HEADER.unknown_520 [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_520, unknown_520);
    unknown_520--;
    dwg_dynapi_header_set_value (dwg, "unknown_520", &unknown_520, 0);

  }
  {
    BITCODE_RSd unknown_52c;
    if (dwg_dynapi_header_value (dwg, "unknown_52c", &unknown_52c, NULL)
        && unknown_52c == dwg->header_vars.unknown_52c)
      pass ();
    else
      fail ("HEADER.unknown_52c [RSd] " FORMAT_RSd " != " FORMAT_RSd "", dwg->header_vars.unknown_52c, unknown_52c);
    unknown_52c++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_52c", &unknown_52c, 0)
        && unknown_52c == dwg->header_vars.unknown_52c)
      pass ();
    else
      fail ("HEADER.unknown_52c [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "",
            dwg->header_vars.unknown_52c, unknown_52c);
    unknown_52c--;
    dwg_dynapi_header_set_value (dwg, "unknown_52c", &unknown_52c, 0);

  }
  {
    BITCODE_RS unknown_52e;
    if (dwg_dynapi_header_value (dwg, "unknown_52e", &unknown_52e, NULL)
        && unknown_52e == dwg->header_vars.unknown_52e)
      pass ();
    else
      fail ("HEADER.unknown_52e [RS] %hu != %hu", dwg->header_vars.unknown_52e, unknown_52e);
    unknown_52e++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_52e", &unknown_52e, 0)
        && unknown_52e == dwg->header_vars.unknown_52e)
      pass ();
    else
      fail ("HEADER.unknown_52e [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_52e, unknown_52e);
    unknown_52e--;
    dwg_dynapi_header_set_value (dwg, "unknown_52e", &unknown_52e, 0);

  }
  {
    BITCODE_RC unknown_530;
    if (dwg_dynapi_header_value (dwg, "unknown_530", &unknown_530, NULL)
        && unknown_530 == dwg->header_vars.unknown_530)
      pass ();
    else
      fail ("HEADER.unknown_530 [RC] %u != %u", dwg->header_vars.unknown_530, unknown_530);
    unknown_530++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_530", &unknown_530, 0)
        && unknown_530 == dwg->header_vars.unknown_530)
      pass ();
    else
      fail ("HEADER.unknown_530 [RC] set+1 %u != %u",
            dwg->header_vars.unknown_530, unknown_530);
    unknown_530--;
    dwg_dynapi_header_set_value (dwg, "unknown_530", &unknown_530, 0);

  }
  {
    BITCODE_RS unknown_59;
    if (dwg_dynapi_header_value (dwg, "unknown_59", &unknown_59, NULL)
        && unknown_59 == dwg->header_vars.unknown_59)
      pass ();
    else
      fail ("HEADER.unknown_59 [RS] %hu != %hu", dwg->header_vars.unknown_59, unknown_59);
    unknown_59++;
    if (dwg_dynapi_header_set_value (dwg, "unknown_59", &unknown_59, 0)
        && unknown_59 == dwg->header_vars.unknown_59)
      pass ();
    else
      fail ("HEADER.unknown_59 [RS] set+1 %hu != %hu",
            dwg->header_vars.unknown_59, unknown_59);
    unknown_59--;
    dwg_dynapi_header_set_value (dwg, "unknown_59", &unknown_59, 0);

  }
  {
    BITCODE_RD aspect_ratio;
    if (dwg_dynapi_header_value (dwg, "aspect_ratio", &aspect_ratio, NULL)
        && aspect_ratio == dwg->header_vars.aspect_ratio)
      pass ();
    else
      fail ("HEADER.aspect_ratio [RD] %g != %g", dwg->header_vars.aspect_ratio, aspect_ratio);
    aspect_ratio++;
    if (dwg_dynapi_header_set_value (dwg, "aspect_ratio", &aspect_ratio, 0)
        && aspect_ratio == dwg->header_vars.aspect_ratio)
      pass ();
    else
      fail ("HEADER.aspect_ratio [RD] set+1 %g != %g",
            dwg->header_vars.aspect_ratio, aspect_ratio);
    aspect_ratio--;
    dwg_dynapi_header_set_value (dwg, "aspect_ratio", &aspect_ratio, 0);

  }
#line 47 "dynapi_test.c.in"
  return error;
}
#line 5379 "dynapi_test.c"
/* @@for test_OBJECT@@ */
static int test__3DFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity__3DFACE *restrict _3dface = obj->tio.entity->tio._3DFACE;
  failed = 0;
  if (!obj_obj || !_3dface)
    {
      fail ("NULL _3DFACE");
      return 1;
    }
  {
    BITCODE_3BD corner1;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "corner1", &corner1, NULL)
        && !memcmp (&corner1, &_3dface->corner1, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("3DFACE.corner1 [3BD]");
  }
  {
    BITCODE_3BD corner2;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "corner2", &corner2, NULL)
        && !memcmp (&corner2, &_3dface->corner2, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("3DFACE.corner2 [3BD]");
  }
  {
    BITCODE_3BD corner3;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "corner3", &corner3, NULL)
        && !memcmp (&corner3, &_3dface->corner3, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("3DFACE.corner3 [3BD]");
  }
  {
    BITCODE_3BD corner4;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "corner4", &corner4, NULL)
        && !memcmp (&corner4, &_3dface->corner4, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("3DFACE.corner4 [3BD]");
  }
  {
    BITCODE_B has_no_flags;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "has_no_flags", &has_no_flags, NULL)
        && has_no_flags == _3dface->has_no_flags)
      pass ();
    else
      fail ("3DFACE.has_no_flags [B] " FORMAT_B " != " FORMAT_B "", _3dface->has_no_flags, has_no_flags);
    has_no_flags++;
    if (dwg_dynapi_entity_set_value (_3dface, "3DFACE", "has_no_flags", &has_no_flags, 0)
        && has_no_flags == _3dface->has_no_flags)
      pass ();
    else
      fail ("3DFACE.has_no_flags [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dface->has_no_flags, has_no_flags);
    _3dface->has_no_flags--;
  }
  {
    BITCODE_BS invis_flags;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "invis_flags", &invis_flags, NULL)
        && invis_flags == _3dface->invis_flags)
      pass ();
    else
      fail ("3DFACE.invis_flags [BS] %hu != %hu", _3dface->invis_flags, invis_flags);
    invis_flags++;
    if (dwg_dynapi_entity_set_value (_3dface, "3DFACE", "invis_flags", &invis_flags, 0)
        && invis_flags == _3dface->invis_flags)
      pass ();
    else
      fail ("3DFACE.invis_flags [BS] set+1 %hu != %hu", _3dface->invis_flags, invis_flags);
    _3dface->invis_flags--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &_3dface->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("3DFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_B z_is_zero;
    if (dwg_dynapi_entity_value (_3dface, "3DFACE", "z_is_zero", &z_is_zero, NULL)
        && z_is_zero == _3dface->z_is_zero)
      pass ();
    else
      fail ("3DFACE.z_is_zero [B] " FORMAT_B " != " FORMAT_B "", _3dface->z_is_zero, z_is_zero);
    z_is_zero++;
    if (dwg_dynapi_entity_set_value (_3dface, "3DFACE", "z_is_zero", &z_is_zero, 0)
        && z_is_zero == _3dface->z_is_zero)
      pass ();
    else
      fail ("3DFACE.z_is_zero [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dface->z_is_zero, z_is_zero);
    _3dface->z_is_zero--;
  }
  if (failed && (is_class_unstable ("3DFACE") || is_class_debugging ("3DFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "3DFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test__3DLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity__3DLINE *restrict _3dline = obj->tio.entity->tio._3DLINE;
  failed = 0;
  if (!obj_obj || !_3dline)
    {
      fail ("NULL _3DLINE");
      return 1;
    }
  {
    BITCODE_3RD end;
    if (dwg_dynapi_entity_value (_3dline, "3DLINE", "end", &end, NULL)
        && !memcmp (&end, &_3dline->end, sizeof (BITCODE_3RD)))
        pass ();
    else
        fail ("3DLINE.end [3RD]");
  }
  {
    BITCODE_3RD extrusion;
    if (dwg_dynapi_entity_value (_3dline, "3DLINE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &_3dline->extrusion, sizeof (BITCODE_3RD)))
        pass ();
    else
        fail ("3DLINE.extrusion [3RD]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (_3dline, "3DLINE", "parent", &parent, NULL)
        && !memcmp (&parent, &_3dline->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("3DLINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3RD start;
    if (dwg_dynapi_entity_value (_3dline, "3DLINE", "start", &start, NULL)
        && !memcmp (&start, &_3dline->start, sizeof (BITCODE_3RD)))
        pass ();
    else
        fail ("3DLINE.start [3RD]");
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value (_3dline, "3DLINE", "thickness", &thickness, NULL)
        && thickness == _3dline->thickness)
      pass ();
    else
      fail ("3DLINE.thickness [RD] %g != %g", _3dline->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (_3dline, "3DLINE", "thickness", &thickness, 0)
        && thickness == _3dline->thickness)
      pass ();
    else
      fail ("3DLINE.thickness [RD] set+1 %g != %g", _3dline->thickness, thickness);
    _3dline->thickness--;
  }
  if (failed && (is_class_unstable ("3DLINE") || is_class_debugging ("3DLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "3DLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test__3DSOLID (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity__3DSOLID *restrict _3dsolid = obj->tio.entity->tio._3DSOLID;
  failed = 0;
  if (!obj_obj || !_3dsolid)
    {
      fail ("NULL _3DSOLID");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == _3dsolid->_dxf_sab_converted)
      pass ();
    else
      fail ("3DSOLID._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == _3dsolid->_dxf_sab_converted)
      pass ();
    else
      fail ("3DSOLID._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->_dxf_sab_converted, _dxf_sab_converted);
    _3dsolid->_dxf_sab_converted--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)_3dsolid->acis_data)
           : !_3dsolid->acis_data)
      pass ();
    else
      fail ("3DSOLID.acis_data [RC*] '%s' <> '%s'", acis_data, _3dsolid->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty", &acis_empty, NULL)
        && acis_empty == _3dsolid->acis_empty)
      pass ();
    else
      fail ("3DSOLID.acis_empty [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty", &acis_empty, 0)
        && acis_empty == _3dsolid->acis_empty)
      pass ();
    else
      fail ("3DSOLID.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty);
    _3dsolid->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == _3dsolid->acis_empty2)
      pass ();
    else
      fail ("3DSOLID.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == _3dsolid->acis_empty2)
      pass ();
    else
      fail ("3DSOLID.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2);
    _3dsolid->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == _3dsolid->acis_empty_bit)
      pass ();
    else
      fail ("3DSOLID.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == _3dsolid->acis_empty_bit)
      pass ();
    else
      fail ("3DSOLID.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit);
    _3dsolid->acis_empty_bit--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &_3dsolid->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("3DSOLID.block_size [BL*]");
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &_3dsolid->encr_sat_data, sizeof (_3dsolid->encr_sat_data)))
      pass ();
    else
      fail ("3DSOLID.encr_sat_data [char **]");
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "end_marker", &end_marker, NULL)
        && end_marker == _3dsolid->end_marker)
      pass ();
    else
      fail ("3DSOLID.end_marker [BL] %u != %u", _3dsolid->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "end_marker", &end_marker, 0)
        && end_marker == _3dsolid->end_marker)
      pass ();
    else
      fail ("3DSOLID.end_marker [BL] set+1 %u != %u", _3dsolid->end_marker, end_marker);
    _3dsolid->end_marker--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &_3dsolid->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("3DSOLID.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == _3dsolid->has_revision_guid)
      pass ();
    else
      fail ("3DSOLID.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == _3dsolid->has_revision_guid)
      pass ();
    else
      fail ("3DSOLID.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->has_revision_guid, has_revision_guid);
    _3dsolid->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &_3dsolid->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("3DSOLID.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "isoline_present", &isoline_present, NULL)
        && isoline_present == _3dsolid->isoline_present)
      pass ();
    else
      fail ("3DSOLID.isoline_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "isoline_present", &isoline_present, 0)
        && isoline_present == _3dsolid->isoline_present)
      pass ();
    else
      fail ("3DSOLID.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present);
    _3dsolid->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "isolines", &isolines, NULL)
        && isolines == _3dsolid->isolines)
      pass ();
    else
      fail ("3DSOLID.isolines [BL] %u != %u", _3dsolid->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "isolines", &isolines, 0)
        && isolines == _3dsolid->isolines)
      pass ();
    else
      fail ("3DSOLID.isolines [BL] set+1 %u != %u", _3dsolid->isolines, isolines);
    _3dsolid->isolines--;
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "materials", &materials, NULL)
        && materials == _3dsolid->materials)
      pass ();
    else
      fail ("3DSOLID.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_blocks", &num_blocks, NULL)
        && num_blocks == _3dsolid->num_blocks)
      pass ();
    else
      fail ("3DSOLID.num_blocks [BL] %u != %u", _3dsolid->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_blocks", &num_blocks, 0)
        && num_blocks == _3dsolid->num_blocks)
      pass ();
    else
      fail ("3DSOLID.num_blocks [BL] set+1 %u != %u", _3dsolid->num_blocks, num_blocks);
    _3dsolid->num_blocks--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_materials", &num_materials, NULL)
        && num_materials == _3dsolid->num_materials)
      pass ();
    else
      fail ("3DSOLID.num_materials [BL] %u != %u", _3dsolid->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_materials", &num_materials, 0)
        && num_materials == _3dsolid->num_materials)
      pass ();
    else
      fail ("3DSOLID.num_materials [BL] set+1 %u != %u", _3dsolid->num_materials, num_materials);
    _3dsolid->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == _3dsolid->num_silhouettes)
      pass ();
    else
      fail ("3DSOLID.num_silhouettes [BL] %u != %u", _3dsolid->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == _3dsolid->num_silhouettes)
      pass ();
    else
      fail ("3DSOLID.num_silhouettes [BL] set+1 %u != %u", _3dsolid->num_silhouettes, num_silhouettes);
    _3dsolid->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_wires", &num_wires, NULL)
        && num_wires == _3dsolid->num_wires)
      pass ();
    else
      fail ("3DSOLID.num_wires [BL] %u != %u", _3dsolid->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_wires", &num_wires, 0)
        && num_wires == _3dsolid->num_wires)
      pass ();
    else
      fail ("3DSOLID.num_wires [BL] set+1 %u != %u", _3dsolid->num_wires, num_wires);
    _3dsolid->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "parent", &parent, NULL)
        && !memcmp (&parent, &_3dsolid->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("3DSOLID.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "point", &point, NULL)
        && !memcmp (&point, &_3dsolid->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("3DSOLID.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "point_present", &point_present, NULL)
        && point_present == _3dsolid->point_present)
      pass ();
    else
      fail ("3DSOLID.point_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "point_present", &point_present, 0)
        && point_present == _3dsolid->point_present)
      pass ();
    else
      fail ("3DSOLID.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present);
    _3dsolid->point_present--;
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &_3dsolid->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("3DSOLID.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &_3dsolid->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("3DSOLID.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_major", &revision_major, NULL)
        && revision_major == _3dsolid->revision_major)
      pass ();
    else
      fail ("3DSOLID.revision_major [BL] %u != %u", _3dsolid->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "revision_major", &revision_major, 0)
        && revision_major == _3dsolid->revision_major)
      pass ();
    else
      fail ("3DSOLID.revision_major [BL] set+1 %u != %u", _3dsolid->revision_major, revision_major);
    _3dsolid->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == _3dsolid->revision_minor1)
      pass ();
    else
      fail ("3DSOLID.revision_minor1 [BS] %hu != %hu", _3dsolid->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == _3dsolid->revision_minor1)
      pass ();
    else
      fail ("3DSOLID.revision_minor1 [BS] set+1 %hu != %hu", _3dsolid->revision_minor1, revision_minor1);
    _3dsolid->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == _3dsolid->revision_minor2)
      pass ();
    else
      fail ("3DSOLID.revision_minor2 [BS] %hu != %hu", _3dsolid->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == _3dsolid->revision_minor2)
      pass ();
    else
      fail ("3DSOLID.revision_minor2 [BS] set+1 %hu != %hu", _3dsolid->revision_minor2, revision_minor2);
    _3dsolid->revision_minor2--;
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "sab_size", &sab_size, NULL)
        && sab_size == _3dsolid->sab_size)
      pass ();
    else
      fail ("3DSOLID.sab_size [BL] %u != %u", _3dsolid->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "sab_size", &sab_size, 0)
        && sab_size == _3dsolid->sab_size)
      pass ();
    else
      fail ("3DSOLID.sab_size [BL] set+1 %u != %u", _3dsolid->sab_size, sab_size);
    _3dsolid->sab_size--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "silhouettes", &silhouettes, NULL)
        && silhouettes == _3dsolid->silhouettes)
      pass ();
    else
      fail ("3DSOLID.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "unknown", &unknown, NULL)
        && unknown == _3dsolid->unknown)
      pass ();
    else
      fail ("3DSOLID.unknown [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "unknown", &unknown, 0)
        && unknown == _3dsolid->unknown)
      pass ();
    else
      fail ("3DSOLID.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown);
    _3dsolid->unknown--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "version", &version, NULL)
        && version == _3dsolid->version)
      pass ();
    else
      fail ("3DSOLID.version [BS] %hu != %hu", _3dsolid->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "version", &version, 0)
        && version == _3dsolid->version)
      pass ();
    else
      fail ("3DSOLID.version [BS] set+1 %hu != %hu", _3dsolid->version, version);
    _3dsolid->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == _3dsolid->wireframe_data_present)
      pass ();
    else
      fail ("3DSOLID.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == _3dsolid->wireframe_data_present)
      pass ();
    else
      fail ("3DSOLID.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present);
    _3dsolid->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "wires", &wires, NULL)
        && wires == _3dsolid->wires)
      pass ();
    else
      fail ("3DSOLID.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("3DSOLID") || is_class_debugging ("3DSOLID")))
    {
      ok ("%s failed %d tests (TODO unstable)", "3DSOLID", failed);
      failed = 0;
    }
  return failed;
}
static int test_ALIGNMENTPARAMETERENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ALIGNMENTPARAMETERENTITY *restrict alignmentparameterentity = obj->tio.entity->tio.ALIGNMENTPARAMETERENTITY;
  failed = 0;
  if (!obj_obj || !alignmentparameterentity)
    {
      fail ("NULL ALIGNMENTPARAMETERENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (alignmentparameterentity, "ALIGNMENTPARAMETERENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &alignmentparameterentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ALIGNMENTPARAMETERENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("ALIGNMENTPARAMETERENTITY") || is_class_debugging ("ALIGNMENTPARAMETERENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ALIGNMENTPARAMETERENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ARC (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ARC *restrict arc = obj->tio.entity->tio.ARC;
  failed = 0;
  if (!obj_obj || !arc)
    {
      fail ("NULL ARC");
      return 1;
    }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (arc, "ARC", "center", &center, NULL)
        && !memcmp (&center, &arc->center, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARC.center [3BD]");
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value (arc, "ARC", "end_angle", &end_angle, NULL)
        && end_angle == arc->end_angle)
      pass ();
    else
      fail ("ARC.end_angle [BD] %g != %g", arc->end_angle, end_angle);
    end_angle++;
    if (dwg_dynapi_entity_set_value (arc, "ARC", "end_angle", &end_angle, 0)
        && end_angle == arc->end_angle)
      pass ();
    else
      fail ("ARC.end_angle [BD] set+1 %g != %g", arc->end_angle, end_angle);
    arc->end_angle--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (arc, "ARC", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &arc->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("ARC.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (arc, "ARC", "parent", &parent, NULL)
        && !memcmp (&parent, &arc->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ARC.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (arc, "ARC", "radius", &radius, NULL)
        && radius == arc->radius)
      pass ();
    else
      fail ("ARC.radius [BD] %g != %g", arc->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (arc, "ARC", "radius", &radius, 0)
        && radius == arc->radius)
      pass ();
    else
      fail ("ARC.radius [BD] set+1 %g != %g", arc->radius, radius);
    arc->radius--;
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (arc, "ARC", "start_angle", &start_angle, NULL)
        && start_angle == arc->start_angle)
      pass ();
    else
      fail ("ARC.start_angle [BD] %g != %g", arc->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (arc, "ARC", "start_angle", &start_angle, 0)
        && start_angle == arc->start_angle)
      pass ();
    else
      fail ("ARC.start_angle [BD] set+1 %g != %g", arc->start_angle, start_angle);
    arc->start_angle--;
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (arc, "ARC", "thickness", &thickness, NULL)
        && thickness == arc->thickness)
      pass ();
    else
      fail ("ARC.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", arc->thickness, thickness);
    if (dwg_dynapi_entity_set_value (arc, "ARC", "thickness", &thickness, 0)
        && thickness == arc->thickness)
      pass ();
    else
      fail ("ARC.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", arc->thickness, thickness);
    arc->thickness--;
  }
  if (failed && (is_class_unstable ("ARC") || is_class_debugging ("ARC")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ARC", failed);
      failed = 0;
    }
  return failed;
}
static int test_ARCALIGNEDTEXT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ARCALIGNEDTEXT *restrict arcalignedtext = obj->tio.entity->tio.ARCALIGNEDTEXT;
  failed = 0;
  if (!obj_obj || !arcalignedtext)
    {
      fail ("NULL ARCALIGNEDTEXT");
      return 1;
    }
  {
    BITCODE_BS alignment;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "alignment", &alignment, NULL)
        && alignment == arcalignedtext->alignment)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.alignment [BS] %hu != %hu", arcalignedtext->alignment, alignment);
    alignment++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "alignment", &alignment, 0)
        && alignment == arcalignedtext->alignment)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.alignment [BS] set+1 %hu != %hu", arcalignedtext->alignment, alignment);
    arcalignedtext->alignment--;
  }
  {
    BITCODE_H arc_handle;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "arc_handle", &arc_handle, NULL)
        && !memcmp (&arc_handle, &arcalignedtext->arc_handle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ARCALIGNEDTEXT.arc_handle [H]");
  }
  {
    BITCODE_BS bs1;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "bs1", &bs1, NULL)
        && bs1 == arcalignedtext->bs1)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.bs1 [BS] %hu != %hu", arcalignedtext->bs1, bs1);
    bs1++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "bs1", &bs1, 0)
        && bs1 == arcalignedtext->bs1)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.bs1 [BS] set+1 %hu != %hu", arcalignedtext->bs1, bs1);
    arcalignedtext->bs1--;
  }
  {
    BITCODE_BS bs2;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "bs2", &bs2, NULL)
        && bs2 == arcalignedtext->bs2)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.bs2 [BS] %hu != %hu", arcalignedtext->bs2, bs2);
    bs2++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "bs2", &bs2, 0)
        && bs2 == arcalignedtext->bs2)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.bs2 [BS] set+1 %hu != %hu", arcalignedtext->bs2, bs2);
    arcalignedtext->bs2--;
  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "center", &center, NULL)
        && !memcmp (&center, &arcalignedtext->center, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARCALIGNEDTEXT.center [3BD]");
  }
  {
    BITCODE_D2T char_spacing;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "char_spacing", &char_spacing, NULL)
        && char_spacing == arcalignedtext->char_spacing)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.char_spacing [D2T] %s != %s", arcalignedtext->char_spacing, char_spacing);
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "char_spacing", &char_spacing, 0)
        && char_spacing == arcalignedtext->char_spacing)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.char_spacing [D2T] set+1 %s != %s", arcalignedtext->char_spacing, char_spacing);
    arcalignedtext->char_spacing--;
  }
  {
    BITCODE_BL color;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "color", &color, NULL)
        && color == arcalignedtext->color)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.color [BL] %u != %u", arcalignedtext->color, color);
    color++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "color", &color, 0)
        && color == arcalignedtext->color)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.color [BL] set+1 %u != %u", arcalignedtext->color, color);
    arcalignedtext->color--;
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "end_angle", &end_angle, NULL)
        && end_angle == arcalignedtext->end_angle)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.end_angle [BD] %g != %g", arcalignedtext->end_angle, end_angle);
    end_angle++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "end_angle", &end_angle, 0)
        && end_angle == arcalignedtext->end_angle)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.end_angle [BD] set+1 %g != %g", arcalignedtext->end_angle, end_angle);
    arcalignedtext->end_angle--;
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &arcalignedtext->extrusion, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARCALIGNEDTEXT.extrusion [3BD]");
  }
  {
    BITCODE_BS font;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "font", &font, NULL)
        && font == arcalignedtext->font)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.font [BS] %hu != %hu", arcalignedtext->font, font);
    font++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "font", &font, 0)
        && font == arcalignedtext->font)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.font [BS] set+1 %hu != %hu", arcalignedtext->font, font);
    arcalignedtext->font--;
  }
  {
    BITCODE_BS font_19;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "font_19", &font_19, NULL)
        && font_19 == arcalignedtext->font_19)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.font_19 [BS] %hu != %hu", arcalignedtext->font_19, font_19);
    font_19++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "font_19", &font_19, 0)
        && font_19 == arcalignedtext->font_19)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.font_19 [BS] set+1 %hu != %hu", arcalignedtext->font_19, font_19);
    arcalignedtext->font_19--;
  }
  {
    BITCODE_BS is_reverse;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "is_reverse", &is_reverse, NULL)
        && is_reverse == arcalignedtext->is_reverse)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.is_reverse [BS] %hu != %hu", arcalignedtext->is_reverse, is_reverse);
    is_reverse++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "is_reverse", &is_reverse, 0)
        && is_reverse == arcalignedtext->is_reverse)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.is_reverse [BS] set+1 %hu != %hu", arcalignedtext->is_reverse, is_reverse);
    arcalignedtext->is_reverse--;
  }
  {
    BITCODE_BS is_shx;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "is_shx", &is_shx, NULL)
        && is_shx == arcalignedtext->is_shx)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.is_shx [BS] %hu != %hu", arcalignedtext->is_shx, is_shx);
    is_shx++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "is_shx", &is_shx, 0)
        && is_shx == arcalignedtext->is_shx)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.is_shx [BS] set+1 %hu != %hu", arcalignedtext->is_shx, is_shx);
    arcalignedtext->is_shx--;
  }
  {
    BITCODE_BS is_underlined;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "is_underlined", &is_underlined, NULL)
        && is_underlined == arcalignedtext->is_underlined)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.is_underlined [BS] %hu != %hu", arcalignedtext->is_underlined, is_underlined);
    is_underlined++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "is_underlined", &is_underlined, 0)
        && is_underlined == arcalignedtext->is_underlined)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.is_underlined [BS] set+1 %hu != %hu", arcalignedtext->is_underlined, is_underlined);
    arcalignedtext->is_underlined--;
  }
  {
    BITCODE_D2T left_offset;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "left_offset", &left_offset, NULL)
        && left_offset == arcalignedtext->left_offset)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.left_offset [D2T] %s != %s", arcalignedtext->left_offset, left_offset);
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "left_offset", &left_offset, 0)
        && left_offset == arcalignedtext->left_offset)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.left_offset [D2T] set+1 %s != %s", arcalignedtext->left_offset, left_offset);
    arcalignedtext->left_offset--;
  }
  {
    BITCODE_D2T offset_from_arc;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "offset_from_arc", &offset_from_arc, NULL)
        && offset_from_arc == arcalignedtext->offset_from_arc)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.offset_from_arc [D2T] %s != %s", arcalignedtext->offset_from_arc, offset_from_arc);
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "offset_from_arc", &offset_from_arc, 0)
        && offset_from_arc == arcalignedtext->offset_from_arc)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.offset_from_arc [D2T] set+1 %s != %s", arcalignedtext->offset_from_arc, offset_from_arc);
    arcalignedtext->offset_from_arc--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "parent", &parent, NULL)
        && !memcmp (&parent, &arcalignedtext->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ARCALIGNEDTEXT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "radius", &radius, NULL)
        && radius == arcalignedtext->radius)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.radius [BD] %g != %g", arcalignedtext->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "radius", &radius, 0)
        && radius == arcalignedtext->radius)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.radius [BD] set+1 %g != %g", arcalignedtext->radius, radius);
    arcalignedtext->radius--;
  }
  {
    BITCODE_D2T right_offset;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "right_offset", &right_offset, NULL)
        && right_offset == arcalignedtext->right_offset)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.right_offset [D2T] %s != %s", arcalignedtext->right_offset, right_offset);
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "right_offset", &right_offset, 0)
        && right_offset == arcalignedtext->right_offset)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.right_offset [D2T] set+1 %s != %s", arcalignedtext->right_offset, right_offset);
    arcalignedtext->right_offset--;
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "start_angle", &start_angle, NULL)
        && start_angle == arcalignedtext->start_angle)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.start_angle [BD] %g != %g", arcalignedtext->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "start_angle", &start_angle, 0)
        && start_angle == arcalignedtext->start_angle)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.start_angle [BD] set+1 %g != %g", arcalignedtext->start_angle, start_angle);
    arcalignedtext->start_angle--;
  }
  {
    BITCODE_T style;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "style", &style, NULL)
        && style
           ? strEQ ((char *)style, (char *)arcalignedtext->style)
           : !arcalignedtext->style)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.style [T] '%s' <> '%s'", style, arcalignedtext->style);
  }
  {
    BITCODE_T t2;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "t2", &t2, NULL)
        && t2
           ? strEQ ((char *)t2, (char *)arcalignedtext->t2)
           : !arcalignedtext->t2)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.t2 [T] '%s' <> '%s'", t2, arcalignedtext->t2);
  }
  {
    BITCODE_T t3;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "t3", &t3, NULL)
        && t3
           ? strEQ ((char *)t3, (char *)arcalignedtext->t3)
           : !arcalignedtext->t3)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.t3 [T] '%s' <> '%s'", t3, arcalignedtext->t3);
  }
  {
    BITCODE_BS text_direction;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "text_direction", &text_direction, NULL)
        && text_direction == arcalignedtext->text_direction)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.text_direction [BS] %hu != %hu", arcalignedtext->text_direction, text_direction);
    text_direction++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "text_direction", &text_direction, 0)
        && text_direction == arcalignedtext->text_direction)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.text_direction [BS] set+1 %hu != %hu", arcalignedtext->text_direction, text_direction);
    arcalignedtext->text_direction--;
  }
  {
    BITCODE_BS text_position;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "text_position", &text_position, NULL)
        && text_position == arcalignedtext->text_position)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.text_position [BS] %hu != %hu", arcalignedtext->text_position, text_position);
    text_position++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "text_position", &text_position, 0)
        && text_position == arcalignedtext->text_position)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.text_position [BS] set+1 %hu != %hu", arcalignedtext->text_position, text_position);
    arcalignedtext->text_position--;
  }
  {
    BITCODE_D2T text_size;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "text_size", &text_size, NULL)
        && text_size == arcalignedtext->text_size)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.text_size [D2T] %s != %s", arcalignedtext->text_size, text_size);
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "text_size", &text_size, 0)
        && text_size == arcalignedtext->text_size)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.text_size [D2T] set+1 %s != %s", arcalignedtext->text_size, text_size);
    arcalignedtext->text_size--;
  }
  {
    BITCODE_T text_value;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "text_value", &text_value, NULL)
        && text_value
           ? strEQ ((char *)text_value, (char *)arcalignedtext->text_value)
           : !arcalignedtext->text_value)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.text_value [T] '%s' <> '%s'", text_value, arcalignedtext->text_value);
  }
  {
    BITCODE_BS wizard_flag;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "wizard_flag", &wizard_flag, NULL)
        && wizard_flag == arcalignedtext->wizard_flag)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.wizard_flag [BS] %hu != %hu", arcalignedtext->wizard_flag, wizard_flag);
    wizard_flag++;
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "wizard_flag", &wizard_flag, 0)
        && wizard_flag == arcalignedtext->wizard_flag)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.wizard_flag [BS] set+1 %hu != %hu", arcalignedtext->wizard_flag, wizard_flag);
    arcalignedtext->wizard_flag--;
  }
  {
    BITCODE_D2T xscale;
    if (dwg_dynapi_entity_value (arcalignedtext, "ARCALIGNEDTEXT", "xscale", &xscale, NULL)
        && xscale == arcalignedtext->xscale)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.xscale [D2T] %s != %s", arcalignedtext->xscale, xscale);
    if (dwg_dynapi_entity_set_value (arcalignedtext, "ARCALIGNEDTEXT", "xscale", &xscale, 0)
        && xscale == arcalignedtext->xscale)
      pass ();
    else
      fail ("ARCALIGNEDTEXT.xscale [D2T] set+1 %s != %s", arcalignedtext->xscale, xscale);
    arcalignedtext->xscale--;
  }
  if (failed && (is_class_unstable ("ARCALIGNEDTEXT") || is_class_debugging ("ARCALIGNEDTEXT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ARCALIGNEDTEXT", failed);
      failed = 0;
    }
  return failed;
}
static int test_ARC_DIMENSION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ARC_DIMENSION *restrict arc_dimension = obj->tio.entity->tio.ARC_DIMENSION;
  failed = 0;
  if (!obj_obj || !arc_dimension)
    {
      fail ("NULL ARC_DIMENSION");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "act_measurement", &act_measurement, NULL)
        && act_measurement == arc_dimension->act_measurement)
      pass ();
    else
      fail ("ARC_DIMENSION.act_measurement [BD] %g != %g", arc_dimension->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "act_measurement", &act_measurement, 0)
        && act_measurement == arc_dimension->act_measurement)
      pass ();
    else
      fail ("ARC_DIMENSION.act_measurement [BD] set+1 %g != %g", arc_dimension->act_measurement, act_measurement);
    arc_dimension->act_measurement--;
  }
  {
    BITCODE_BD arc_end_param;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "arc_end_param", &arc_end_param, NULL)
        && arc_end_param == arc_dimension->arc_end_param)
      pass ();
    else
      fail ("ARC_DIMENSION.arc_end_param [BD] %g != %g", arc_dimension->arc_end_param, arc_end_param);
    arc_end_param++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "arc_end_param", &arc_end_param, 0)
        && arc_end_param == arc_dimension->arc_end_param)
      pass ();
    else
      fail ("ARC_DIMENSION.arc_end_param [BD] set+1 %g != %g", arc_dimension->arc_end_param, arc_end_param);
    arc_dimension->arc_end_param--;
  }
  {
    BITCODE_BD arc_start_param;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "arc_start_param", &arc_start_param, NULL)
        && arc_start_param == arc_dimension->arc_start_param)
      pass ();
    else
      fail ("ARC_DIMENSION.arc_start_param [BD] %g != %g", arc_dimension->arc_start_param, arc_start_param);
    arc_start_param++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "arc_start_param", &arc_start_param, 0)
        && arc_start_param == arc_dimension->arc_start_param)
      pass ();
    else
      fail ("ARC_DIMENSION.arc_start_param [BD] set+1 %g != %g", arc_dimension->arc_start_param, arc_start_param);
    arc_dimension->arc_start_param--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "attachment", &attachment, NULL)
        && attachment == arc_dimension->attachment)
      pass ();
    else
      fail ("ARC_DIMENSION.attachment [BS] %hu != %hu", arc_dimension->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "attachment", &attachment, 0)
        && attachment == arc_dimension->attachment)
      pass ();
    else
      fail ("ARC_DIMENSION.attachment [BS] set+1 %hu != %hu", arc_dimension->attachment, attachment);
    arc_dimension->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "block", &block, NULL)
        && !memcmp (&block, &arc_dimension->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ARC_DIMENSION.block [H]");
  }
  {
    BITCODE_3BD center_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "center_pt", &center_pt, NULL)
        && !memcmp (&center_pt, &arc_dimension->center_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARC_DIMENSION.center_pt [3BD]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "class_version", &class_version, NULL)
        && class_version == arc_dimension->class_version)
      pass ();
    else
      fail ("ARC_DIMENSION.class_version [RC] %u != %u", arc_dimension->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "class_version", &class_version, 0)
        && class_version == arc_dimension->class_version)
      pass ();
    else
      fail ("ARC_DIMENSION.class_version [RC] set+1 %u != %u", arc_dimension->class_version, class_version);
    arc_dimension->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &arc_dimension->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("ARC_DIMENSION.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &arc_dimension->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARC_DIMENSION.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &arc_dimension->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ARC_DIMENSION.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "elevation", &elevation, NULL)
        && elevation == arc_dimension->elevation)
      pass ();
    else
      fail ("ARC_DIMENSION.elevation [BD] %g != %g", arc_dimension->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "elevation", &elevation, 0)
        && elevation == arc_dimension->elevation)
      pass ();
    else
      fail ("ARC_DIMENSION.elevation [BD] set+1 %g != %g", arc_dimension->elevation, elevation);
    arc_dimension->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &arc_dimension->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("ARC_DIMENSION.extrusion [BE]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flag", &flag, NULL)
        && flag == arc_dimension->flag)
      pass ();
    else
      fail ("ARC_DIMENSION.flag [RC] %u != %u", arc_dimension->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flag", &flag, 0)
        && flag == arc_dimension->flag)
      pass ();
    else
      fail ("ARC_DIMENSION.flag [RC] set+1 %u != %u", arc_dimension->flag, flag);
    arc_dimension->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flag1", &flag1, NULL)
        && flag1 == arc_dimension->flag1)
      pass ();
    else
      fail ("ARC_DIMENSION.flag1 [RC] %u != %u", arc_dimension->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flag1", &flag1, 0)
        && flag1 == arc_dimension->flag1)
      pass ();
    else
      fail ("ARC_DIMENSION.flag1 [RC] set+1 %u != %u", arc_dimension->flag1, flag1);
    arc_dimension->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == arc_dimension->flip_arrow1)
      pass ();
    else
      fail ("ARC_DIMENSION.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", arc_dimension->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == arc_dimension->flip_arrow1)
      pass ();
    else
      fail ("ARC_DIMENSION.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", arc_dimension->flip_arrow1, flip_arrow1);
    arc_dimension->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == arc_dimension->flip_arrow2)
      pass ();
    else
      fail ("ARC_DIMENSION.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", arc_dimension->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == arc_dimension->flip_arrow2)
      pass ();
    else
      fail ("ARC_DIMENSION.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", arc_dimension->flip_arrow2, flip_arrow2);
    arc_dimension->flip_arrow2--;
  }
  {
    BITCODE_B has_leader;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "has_leader", &has_leader, NULL)
        && has_leader == arc_dimension->has_leader)
      pass ();
    else
      fail ("ARC_DIMENSION.has_leader [B] " FORMAT_B " != " FORMAT_B "", arc_dimension->has_leader, has_leader);
    has_leader++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "has_leader", &has_leader, 0)
        && has_leader == arc_dimension->has_leader)
      pass ();
    else
      fail ("ARC_DIMENSION.has_leader [B] set+1 " FORMAT_B " != " FORMAT_B "", arc_dimension->has_leader, has_leader);
    arc_dimension->has_leader--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == arc_dimension->horiz_dir)
      pass ();
    else
      fail ("ARC_DIMENSION.horiz_dir [BD] %g != %g", arc_dimension->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == arc_dimension->horiz_dir)
      pass ();
    else
      fail ("ARC_DIMENSION.horiz_dir [BD] set+1 %g != %g", arc_dimension->horiz_dir, horiz_dir);
    arc_dimension->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == arc_dimension->ins_rotation)
      pass ();
    else
      fail ("ARC_DIMENSION.ins_rotation [BD] %g != %g", arc_dimension->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == arc_dimension->ins_rotation)
      pass ();
    else
      fail ("ARC_DIMENSION.ins_rotation [BD] set+1 %g != %g", arc_dimension->ins_rotation, ins_rotation);
    arc_dimension->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &arc_dimension->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARC_DIMENSION.ins_scale [3BD_1]");
  }
  {
    BITCODE_B is_partial;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "is_partial", &is_partial, NULL)
        && is_partial == arc_dimension->is_partial)
      pass ();
    else
      fail ("ARC_DIMENSION.is_partial [B] " FORMAT_B " != " FORMAT_B "", arc_dimension->is_partial, is_partial);
    is_partial++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "is_partial", &is_partial, 0)
        && is_partial == arc_dimension->is_partial)
      pass ();
    else
      fail ("ARC_DIMENSION.is_partial [B] set+1 " FORMAT_B " != " FORMAT_B "", arc_dimension->is_partial, is_partial);
    arc_dimension->is_partial--;
  }
  {
    BITCODE_3BD leader1_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "leader1_pt", &leader1_pt, NULL)
        && !memcmp (&leader1_pt, &arc_dimension->leader1_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARC_DIMENSION.leader1_pt [3BD]");
  }
  {
    BITCODE_3BD leader2_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "leader2_pt", &leader2_pt, NULL)
        && !memcmp (&leader2_pt, &arc_dimension->leader2_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARC_DIMENSION.leader2_pt [3BD]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == arc_dimension->lspace_factor)
      pass ();
    else
      fail ("ARC_DIMENSION.lspace_factor [BD] %g != %g", arc_dimension->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == arc_dimension->lspace_factor)
      pass ();
    else
      fail ("ARC_DIMENSION.lspace_factor [BD] set+1 %g != %g", arc_dimension->lspace_factor, lspace_factor);
    arc_dimension->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "lspace_style", &lspace_style, NULL)
        && lspace_style == arc_dimension->lspace_style)
      pass ();
    else
      fail ("ARC_DIMENSION.lspace_style [BS] %hu != %hu", arc_dimension->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "lspace_style", &lspace_style, 0)
        && lspace_style == arc_dimension->lspace_style)
      pass ();
    else
      fail ("ARC_DIMENSION.lspace_style [BS] set+1 %hu != %hu", arc_dimension->lspace_style, lspace_style);
    arc_dimension->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "parent", &parent, NULL)
        && !memcmp (&parent, &arc_dimension->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ARC_DIMENSION.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &arc_dimension->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("ARC_DIMENSION.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "text_rotation", &text_rotation, NULL)
        && text_rotation == arc_dimension->text_rotation)
      pass ();
    else
      fail ("ARC_DIMENSION.text_rotation [BD] %g != %g", arc_dimension->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "text_rotation", &text_rotation, 0)
        && text_rotation == arc_dimension->text_rotation)
      pass ();
    else
      fail ("ARC_DIMENSION.text_rotation [BD] set+1 %g != %g", arc_dimension->text_rotation, text_rotation);
    arc_dimension->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "unknown", &unknown, NULL)
        && unknown == arc_dimension->unknown)
      pass ();
    else
      fail ("ARC_DIMENSION.unknown [B] " FORMAT_B " != " FORMAT_B "", arc_dimension->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (arc_dimension, "ARC_DIMENSION", "unknown", &unknown, 0)
        && unknown == arc_dimension->unknown)
      pass ();
    else
      fail ("ARC_DIMENSION.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", arc_dimension->unknown, unknown);
    arc_dimension->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)arc_dimension->user_text)
           : !arc_dimension->user_text)
      pass ();
    else
      fail ("ARC_DIMENSION.user_text [T] '%s' <> '%s'", user_text, arc_dimension->user_text);
  }
  {
    BITCODE_3BD xline1_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "xline1_pt", &xline1_pt, NULL)
        && !memcmp (&xline1_pt, &arc_dimension->xline1_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARC_DIMENSION.xline1_pt [3BD]");
  }
  {
    BITCODE_3BD xline2_pt;
    if (dwg_dynapi_entity_value (arc_dimension, "ARC_DIMENSION", "xline2_pt", &xline2_pt, NULL)
        && !memcmp (&xline2_pt, &arc_dimension->xline2_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ARC_DIMENSION.xline2_pt [3BD]");
  }
  if (failed && (is_class_unstable ("ARC_DIMENSION") || is_class_debugging ("ARC_DIMENSION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ARC_DIMENSION", failed);
      failed = 0;
    }
  return failed;
}
static int test_ATTDEF (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ATTDEF *restrict attdef = obj->tio.entity->tio.ATTDEF;
  failed = 0;
  if (!obj_obj || !attdef)
    {
      fail ("NULL ATTDEF");
      return 1;
    }
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &attdef->alignment_pt, sizeof (BITCODE_2DPOINT)))
        pass ();
    else
        fail ("ATTDEF.alignment_pt [2DPOINT]");
  }
  {
    BITCODE_H annotative_app;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "annotative_app", &annotative_app, NULL)
        && !memcmp (&annotative_app, &attdef->annotative_app, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ATTDEF.annotative_app [H]");
  }
  {
    BITCODE_RC annotative_data_bytes;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "annotative_data_bytes", &annotative_data_bytes, NULL)
        && annotative_data_bytes == attdef->annotative_data_bytes)
      pass ();
    else
      fail ("ATTDEF.annotative_data_bytes [RC] %u != %u", attdef->annotative_data_bytes, annotative_data_bytes);
    annotative_data_bytes++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "annotative_data_bytes", &annotative_data_bytes, 0)
        && annotative_data_bytes == attdef->annotative_data_bytes)
      pass ();
    else
      fail ("ATTDEF.annotative_data_bytes [RC] set+1 %u != %u", attdef->annotative_data_bytes, annotative_data_bytes);
    attdef->annotative_data_bytes--;
  }
  {
    BITCODE_BS annotative_data_size;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "annotative_data_size", &annotative_data_size, NULL)
        && annotative_data_size == attdef->annotative_data_size)
      pass ();
    else
      fail ("ATTDEF.annotative_data_size [BS] %hu != %hu", attdef->annotative_data_size, annotative_data_size);
    annotative_data_size++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "annotative_data_size", &annotative_data_size, 0)
        && annotative_data_size == attdef->annotative_data_size)
      pass ();
    else
      fail ("ATTDEF.annotative_data_size [BS] set+1 %hu != %hu", attdef->annotative_data_size, annotative_data_size);
    attdef->annotative_data_size--;
  }
  {
    BITCODE_BS annotative_short;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "annotative_short", &annotative_short, NULL)
        && annotative_short == attdef->annotative_short)
      pass ();
    else
      fail ("ATTDEF.annotative_short [BS] %hu != %hu", attdef->annotative_short, annotative_short);
    annotative_short++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "annotative_short", &annotative_short, 0)
        && annotative_short == attdef->annotative_short)
      pass ();
    else
      fail ("ATTDEF.annotative_short [BS] set+1 %hu != %hu", attdef->annotative_short, annotative_short);
    attdef->annotative_short--;
  }
  {
    BITCODE_RC attdef_class_version;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "attdef_class_version", &attdef_class_version, NULL)
        && attdef_class_version == attdef->attdef_class_version)
      pass ();
    else
      fail ("ATTDEF.attdef_class_version [RC] %u != %u", attdef->attdef_class_version, attdef_class_version);
    attdef_class_version++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "attdef_class_version", &attdef_class_version, 0)
        && attdef_class_version == attdef->attdef_class_version)
      pass ();
    else
      fail ("ATTDEF.attdef_class_version [RC] set+1 %u != %u", attdef->attdef_class_version, attdef_class_version);
    attdef->attdef_class_version--;
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "class_version", &class_version, NULL)
        && class_version == attdef->class_version)
      pass ();
    else
      fail ("ATTDEF.class_version [RC] %u != %u", attdef->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "class_version", &class_version, 0)
        && class_version == attdef->class_version)
      pass ();
    else
      fail ("ATTDEF.class_version [RC] set+1 %u != %u", attdef->class_version, class_version);
    attdef->class_version--;
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "dataflags", &dataflags, NULL)
        && dataflags == attdef->dataflags)
      pass ();
    else
      fail ("ATTDEF.dataflags [RC] %u != %u", attdef->dataflags, dataflags);
    dataflags++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "dataflags", &dataflags, 0)
        && dataflags == attdef->dataflags)
      pass ();
    else
      fail ("ATTDEF.dataflags [RC] set+1 %u != %u", attdef->dataflags, dataflags);
    attdef->dataflags--;
  }
  {
    BITCODE_T default_value;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "default_value", &default_value, NULL)
        && default_value
           ? strEQ ((char *)default_value, (char *)attdef->default_value)
           : !attdef->default_value)
      pass ();
    else
      fail ("ATTDEF.default_value [T] '%s' <> '%s'", default_value, attdef->default_value);
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "elevation", &elevation, NULL)
        && elevation == attdef->elevation)
      pass ();
    else
      fail ("ATTDEF.elevation [BD] %g != %g", attdef->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "elevation", &elevation, 0)
        && elevation == attdef->elevation)
      pass ();
    else
      fail ("ATTDEF.elevation [BD] set+1 %g != %g", attdef->elevation, elevation);
    attdef->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &attdef->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("ATTDEF.extrusion [BE]");
  }
  {
    BITCODE_BS field_length;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "field_length", &field_length, NULL)
        && field_length == attdef->field_length)
      pass ();
    else
      fail ("ATTDEF.field_length [BS] %hu != %hu", attdef->field_length, field_length);
    field_length++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "field_length", &field_length, 0)
        && field_length == attdef->field_length)
      pass ();
    else
      fail ("ATTDEF.field_length [BS] set+1 %hu != %hu", attdef->field_length, field_length);
    attdef->field_length--;
  }
  {
    BITCODE_RC flags;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "flags", &flags, NULL)
        && flags == attdef->flags)
      pass ();
    else
      fail ("ATTDEF.flags [RC] %u != %u", attdef->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "flags", &flags, 0)
        && flags == attdef->flags)
      pass ();
    else
      fail ("ATTDEF.flags [RC] set+1 %u != %u", attdef->flags, flags);
    attdef->flags--;
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "generation", &generation, NULL)
        && generation == attdef->generation)
      pass ();
    else
      fail ("ATTDEF.generation [BS] %hu != %hu", attdef->generation, generation);
    generation++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "generation", &generation, 0)
        && generation == attdef->generation)
      pass ();
    else
      fail ("ATTDEF.generation [BS] set+1 %hu != %hu", attdef->generation, generation);
    attdef->generation--;
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "height", &height, NULL)
        && height == attdef->height)
      pass ();
    else
      fail ("ATTDEF.height [RD] %g != %g", attdef->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "height", &height, 0)
        && height == attdef->height)
      pass ();
    else
      fail ("ATTDEF.height [RD] set+1 %g != %g", attdef->height, height);
    attdef->height--;
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "horiz_alignment", &horiz_alignment, NULL)
        && horiz_alignment == attdef->horiz_alignment)
      pass ();
    else
      fail ("ATTDEF.horiz_alignment [BS] %hu != %hu", attdef->horiz_alignment, horiz_alignment);
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "horiz_alignment", &horiz_alignment, 0)
        && horiz_alignment == attdef->horiz_alignment)
      pass ();
    else
      fail ("ATTDEF.horiz_alignment [BS] set+1 %hu != %hu", attdef->horiz_alignment, horiz_alignment);
    attdef->horiz_alignment--;
  }
  {
    BITCODE_2DPOINT ins_pt;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &attdef->ins_pt, sizeof (BITCODE_2DPOINT)))
        pass ();
    else
        fail ("ATTDEF.ins_pt [2DPOINT]");
  }
  {
    BITCODE_B lock_position_flag;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "lock_position_flag", &lock_position_flag, NULL)
        && lock_position_flag == attdef->lock_position_flag)
      pass ();
    else
      fail ("ATTDEF.lock_position_flag [B] " FORMAT_B " != " FORMAT_B "", attdef->lock_position_flag, lock_position_flag);
    lock_position_flag++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "lock_position_flag", &lock_position_flag, 0)
        && lock_position_flag == attdef->lock_position_flag)
      pass ();
    else
      fail ("ATTDEF.lock_position_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", attdef->lock_position_flag, lock_position_flag);
    attdef->lock_position_flag--;
  }
  {
    BITCODE_H mtext_handles;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "mtext_handles", &mtext_handles, NULL)
        && !memcmp (&mtext_handles, &attdef->mtext_handles, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ATTDEF.mtext_handles [H]");
  }
  {
    BITCODE_RD oblique_angle;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "oblique_angle", &oblique_angle, NULL)
        && oblique_angle == attdef->oblique_angle)
      pass ();
    else
      fail ("ATTDEF.oblique_angle [RD] %g != %g", attdef->oblique_angle, oblique_angle);
    oblique_angle++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "oblique_angle", &oblique_angle, 0)
        && oblique_angle == attdef->oblique_angle)
      pass ();
    else
      fail ("ATTDEF.oblique_angle [RD] set+1 %g != %g", attdef->oblique_angle, oblique_angle);
    attdef->oblique_angle--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "parent", &parent, NULL)
        && !memcmp (&parent, &attdef->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ATTDEF.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_T prompt;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "prompt", &prompt, NULL)
        && prompt
           ? strEQ ((char *)prompt, (char *)attdef->prompt)
           : !attdef->prompt)
      pass ();
    else
      fail ("ATTDEF.prompt [T] '%s' <> '%s'", prompt, attdef->prompt);
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "rotation", &rotation, NULL)
        && rotation == attdef->rotation)
      pass ();
    else
      fail ("ATTDEF.rotation [RD] %g != %g", attdef->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "rotation", &rotation, 0)
        && rotation == attdef->rotation)
      pass ();
    else
      fail ("ATTDEF.rotation [RD] set+1 %g != %g", attdef->rotation, rotation);
    attdef->rotation--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "style", &style, NULL)
        && !memcmp (&style, &attdef->style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ATTDEF.style [H]");
  }
  {
    BITCODE_T tag;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "tag", &tag, NULL)
        && tag
           ? strEQ ((char *)tag, (char *)attdef->tag)
           : !attdef->tag)
      pass ();
    else
      fail ("ATTDEF.tag [T] '%s' <> '%s'", tag, attdef->tag);
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "thickness", &thickness, NULL)
        && thickness == attdef->thickness)
      pass ();
    else
      fail ("ATTDEF.thickness [RD] %g != %g", attdef->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "thickness", &thickness, 0)
        && thickness == attdef->thickness)
      pass ();
    else
      fail ("ATTDEF.thickness [RD] set+1 %g != %g", attdef->thickness, thickness);
    attdef->thickness--;
  }
  {
    BITCODE_RC type;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "type", &type, NULL)
        && type == attdef->type)
      pass ();
    else
      fail ("ATTDEF.type [RC] %u != %u", attdef->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "type", &type, 0)
        && type == attdef->type)
      pass ();
    else
      fail ("ATTDEF.type [RC] set+1 %u != %u", attdef->type, type);
    attdef->type--;
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "vert_alignment", &vert_alignment, NULL)
        && vert_alignment == attdef->vert_alignment)
      pass ();
    else
      fail ("ATTDEF.vert_alignment [BS] %hu != %hu", attdef->vert_alignment, vert_alignment);
    vert_alignment++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "vert_alignment", &vert_alignment, 0)
        && vert_alignment == attdef->vert_alignment)
      pass ();
    else
      fail ("ATTDEF.vert_alignment [BS] set+1 %hu != %hu", attdef->vert_alignment, vert_alignment);
    attdef->vert_alignment--;
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value (attdef, "ATTDEF", "width_factor", &width_factor, NULL)
        && width_factor == attdef->width_factor)
      pass ();
    else
      fail ("ATTDEF.width_factor [RD] %g != %g", attdef->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (attdef, "ATTDEF", "width_factor", &width_factor, 0)
        && width_factor == attdef->width_factor)
      pass ();
    else
      fail ("ATTDEF.width_factor [RD] set+1 %g != %g", attdef->width_factor, width_factor);
    attdef->width_factor--;
  }
  if (failed && (is_class_unstable ("ATTDEF") || is_class_debugging ("ATTDEF")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ATTDEF", failed);
      failed = 0;
    }
  return failed;
}
static int test_ATTRIB (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ATTRIB *restrict attrib = obj->tio.entity->tio.ATTRIB;
  failed = 0;
  if (!obj_obj || !attrib)
    {
      fail ("NULL ATTRIB");
      return 1;
    }
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &attrib->alignment_pt, sizeof (BITCODE_2DPOINT)))
        pass ();
    else
        fail ("ATTRIB.alignment_pt [2DPOINT]");
  }
  {
    BITCODE_H annotative_app;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "annotative_app", &annotative_app, NULL)
        && !memcmp (&annotative_app, &attrib->annotative_app, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ATTRIB.annotative_app [H]");
  }
  {
    BITCODE_RC annotative_data_bytes;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "annotative_data_bytes", &annotative_data_bytes, NULL)
        && annotative_data_bytes == attrib->annotative_data_bytes)
      pass ();
    else
      fail ("ATTRIB.annotative_data_bytes [RC] %u != %u", attrib->annotative_data_bytes, annotative_data_bytes);
    annotative_data_bytes++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "annotative_data_bytes", &annotative_data_bytes, 0)
        && annotative_data_bytes == attrib->annotative_data_bytes)
      pass ();
    else
      fail ("ATTRIB.annotative_data_bytes [RC] set+1 %u != %u", attrib->annotative_data_bytes, annotative_data_bytes);
    attrib->annotative_data_bytes--;
  }
  {
    BITCODE_BS annotative_data_size;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "annotative_data_size", &annotative_data_size, NULL)
        && annotative_data_size == attrib->annotative_data_size)
      pass ();
    else
      fail ("ATTRIB.annotative_data_size [BS] %hu != %hu", attrib->annotative_data_size, annotative_data_size);
    annotative_data_size++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "annotative_data_size", &annotative_data_size, 0)
        && annotative_data_size == attrib->annotative_data_size)
      pass ();
    else
      fail ("ATTRIB.annotative_data_size [BS] set+1 %hu != %hu", attrib->annotative_data_size, annotative_data_size);
    attrib->annotative_data_size--;
  }
  {
    BITCODE_BS annotative_short;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "annotative_short", &annotative_short, NULL)
        && annotative_short == attrib->annotative_short)
      pass ();
    else
      fail ("ATTRIB.annotative_short [BS] %hu != %hu", attrib->annotative_short, annotative_short);
    annotative_short++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "annotative_short", &annotative_short, 0)
        && annotative_short == attrib->annotative_short)
      pass ();
    else
      fail ("ATTRIB.annotative_short [BS] set+1 %hu != %hu", attrib->annotative_short, annotative_short);
    attrib->annotative_short--;
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "class_version", &class_version, NULL)
        && class_version == attrib->class_version)
      pass ();
    else
      fail ("ATTRIB.class_version [RC] %u != %u", attrib->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "class_version", &class_version, 0)
        && class_version == attrib->class_version)
      pass ();
    else
      fail ("ATTRIB.class_version [RC] set+1 %u != %u", attrib->class_version, class_version);
    attrib->class_version--;
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "dataflags", &dataflags, NULL)
        && dataflags == attrib->dataflags)
      pass ();
    else
      fail ("ATTRIB.dataflags [RC] %u != %u", attrib->dataflags, dataflags);
    dataflags++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "dataflags", &dataflags, 0)
        && dataflags == attrib->dataflags)
      pass ();
    else
      fail ("ATTRIB.dataflags [RC] set+1 %u != %u", attrib->dataflags, dataflags);
    attrib->dataflags--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "elevation", &elevation, NULL)
        && elevation == attrib->elevation)
      pass ();
    else
      fail ("ATTRIB.elevation [BD] %g != %g", attrib->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "elevation", &elevation, 0)
        && elevation == attrib->elevation)
      pass ();
    else
      fail ("ATTRIB.elevation [BD] set+1 %g != %g", attrib->elevation, elevation);
    attrib->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &attrib->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("ATTRIB.extrusion [BE]");
  }
  {
    BITCODE_BS field_length;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "field_length", &field_length, NULL)
        && field_length == attrib->field_length)
      pass ();
    else
      fail ("ATTRIB.field_length [BS] %hu != %hu", attrib->field_length, field_length);
    field_length++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "field_length", &field_length, 0)
        && field_length == attrib->field_length)
      pass ();
    else
      fail ("ATTRIB.field_length [BS] set+1 %hu != %hu", attrib->field_length, field_length);
    attrib->field_length--;
  }
  {
    BITCODE_RC flags;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "flags", &flags, NULL)
        && flags == attrib->flags)
      pass ();
    else
      fail ("ATTRIB.flags [RC] %u != %u", attrib->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "flags", &flags, 0)
        && flags == attrib->flags)
      pass ();
    else
      fail ("ATTRIB.flags [RC] set+1 %u != %u", attrib->flags, flags);
    attrib->flags--;
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "generation", &generation, NULL)
        && generation == attrib->generation)
      pass ();
    else
      fail ("ATTRIB.generation [BS] %hu != %hu", attrib->generation, generation);
    generation++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "generation", &generation, 0)
        && generation == attrib->generation)
      pass ();
    else
      fail ("ATTRIB.generation [BS] set+1 %hu != %hu", attrib->generation, generation);
    attrib->generation--;
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "height", &height, NULL)
        && height == attrib->height)
      pass ();
    else
      fail ("ATTRIB.height [RD] %g != %g", attrib->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "height", &height, 0)
        && height == attrib->height)
      pass ();
    else
      fail ("ATTRIB.height [RD] set+1 %g != %g", attrib->height, height);
    attrib->height--;
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "horiz_alignment", &horiz_alignment, NULL)
        && horiz_alignment == attrib->horiz_alignment)
      pass ();
    else
      fail ("ATTRIB.horiz_alignment [BS] %hu != %hu", attrib->horiz_alignment, horiz_alignment);
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "horiz_alignment", &horiz_alignment, 0)
        && horiz_alignment == attrib->horiz_alignment)
      pass ();
    else
      fail ("ATTRIB.horiz_alignment [BS] set+1 %hu != %hu", attrib->horiz_alignment, horiz_alignment);
    attrib->horiz_alignment--;
  }
  {
    BITCODE_2DPOINT ins_pt;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &attrib->ins_pt, sizeof (BITCODE_2DPOINT)))
        pass ();
    else
        fail ("ATTRIB.ins_pt [2DPOINT]");
  }
  {
    BITCODE_B lock_position_flag;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "lock_position_flag", &lock_position_flag, NULL)
        && lock_position_flag == attrib->lock_position_flag)
      pass ();
    else
      fail ("ATTRIB.lock_position_flag [B] " FORMAT_B " != " FORMAT_B "", attrib->lock_position_flag, lock_position_flag);
    lock_position_flag++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "lock_position_flag", &lock_position_flag, 0)
        && lock_position_flag == attrib->lock_position_flag)
      pass ();
    else
      fail ("ATTRIB.lock_position_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", attrib->lock_position_flag, lock_position_flag);
    attrib->lock_position_flag--;
  }
  {
    BITCODE_H mtext_handles;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "mtext_handles", &mtext_handles, NULL)
        && !memcmp (&mtext_handles, &attrib->mtext_handles, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ATTRIB.mtext_handles [H]");
  }
  {
    BITCODE_RD oblique_angle;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "oblique_angle", &oblique_angle, NULL)
        && oblique_angle == attrib->oblique_angle)
      pass ();
    else
      fail ("ATTRIB.oblique_angle [RD] %g != %g", attrib->oblique_angle, oblique_angle);
    oblique_angle++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "oblique_angle", &oblique_angle, 0)
        && oblique_angle == attrib->oblique_angle)
      pass ();
    else
      fail ("ATTRIB.oblique_angle [RD] set+1 %g != %g", attrib->oblique_angle, oblique_angle);
    attrib->oblique_angle--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "parent", &parent, NULL)
        && !memcmp (&parent, &attrib->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ATTRIB.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "rotation", &rotation, NULL)
        && rotation == attrib->rotation)
      pass ();
    else
      fail ("ATTRIB.rotation [RD] %g != %g", attrib->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "rotation", &rotation, 0)
        && rotation == attrib->rotation)
      pass ();
    else
      fail ("ATTRIB.rotation [RD] set+1 %g != %g", attrib->rotation, rotation);
    attrib->rotation--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "style", &style, NULL)
        && !memcmp (&style, &attrib->style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ATTRIB.style [H]");
  }
  {
    BITCODE_T tag;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "tag", &tag, NULL)
        && tag
           ? strEQ ((char *)tag, (char *)attrib->tag)
           : !attrib->tag)
      pass ();
    else
      fail ("ATTRIB.tag [T] '%s' <> '%s'", tag, attrib->tag);
  }
  {
    BITCODE_T text_value;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "text_value", &text_value, NULL)
        && text_value
           ? strEQ ((char *)text_value, (char *)attrib->text_value)
           : !attrib->text_value)
      pass ();
    else
      fail ("ATTRIB.text_value [T] '%s' <> '%s'", text_value, attrib->text_value);
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "thickness", &thickness, NULL)
        && thickness == attrib->thickness)
      pass ();
    else
      fail ("ATTRIB.thickness [RD] %g != %g", attrib->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "thickness", &thickness, 0)
        && thickness == attrib->thickness)
      pass ();
    else
      fail ("ATTRIB.thickness [RD] set+1 %g != %g", attrib->thickness, thickness);
    attrib->thickness--;
  }
  {
    BITCODE_RC type;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "type", &type, NULL)
        && type == attrib->type)
      pass ();
    else
      fail ("ATTRIB.type [RC] %u != %u", attrib->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "type", &type, 0)
        && type == attrib->type)
      pass ();
    else
      fail ("ATTRIB.type [RC] set+1 %u != %u", attrib->type, type);
    attrib->type--;
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "vert_alignment", &vert_alignment, NULL)
        && vert_alignment == attrib->vert_alignment)
      pass ();
    else
      fail ("ATTRIB.vert_alignment [BS] %hu != %hu", attrib->vert_alignment, vert_alignment);
    vert_alignment++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "vert_alignment", &vert_alignment, 0)
        && vert_alignment == attrib->vert_alignment)
      pass ();
    else
      fail ("ATTRIB.vert_alignment [BS] set+1 %hu != %hu", attrib->vert_alignment, vert_alignment);
    attrib->vert_alignment--;
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value (attrib, "ATTRIB", "width_factor", &width_factor, NULL)
        && width_factor == attrib->width_factor)
      pass ();
    else
      fail ("ATTRIB.width_factor [RD] %g != %g", attrib->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (attrib, "ATTRIB", "width_factor", &width_factor, 0)
        && width_factor == attrib->width_factor)
      pass ();
    else
      fail ("ATTRIB.width_factor [RD] set+1 %g != %g", attrib->width_factor, width_factor);
    attrib->width_factor--;
  }
  if (failed && (is_class_unstable ("ATTRIB") || is_class_debugging ("ATTRIB")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ATTRIB", failed);
      failed = 0;
    }
  return failed;
}
static int test_BASEPOINTPARAMETERENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_BASEPOINTPARAMETERENTITY *restrict basepointparameterentity = obj->tio.entity->tio.BASEPOINTPARAMETERENTITY;
  failed = 0;
  if (!obj_obj || !basepointparameterentity)
    {
      fail ("NULL BASEPOINTPARAMETERENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (basepointparameterentity, "BASEPOINTPARAMETERENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &basepointparameterentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("BASEPOINTPARAMETERENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("BASEPOINTPARAMETERENTITY") || is_class_debugging ("BASEPOINTPARAMETERENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BASEPOINTPARAMETERENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCK (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_BLOCK *restrict block = obj->tio.entity->tio.BLOCK;
  failed = 0;
  if (!obj_obj || !block)
    {
      fail ("NULL BLOCK");
      return 1;
    }
  {
    BITCODE_2RD base_pt;
    if (dwg_dynapi_entity_value (block, "BLOCK", "base_pt", &base_pt, NULL)
        && !memcmp (&base_pt, &block->base_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("BLOCK.base_pt [2RD]");
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (block, "BLOCK", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)block->name)
           : !block->name)
      pass ();
    else
      fail ("BLOCK.name [TV] '%s' <> '%s'", name, block->name);
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (block, "BLOCK", "parent", &parent, NULL)
        && !memcmp (&parent, &block->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("BLOCK.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_TV xref_pname;
    if (dwg_dynapi_entity_value (block, "BLOCK", "xref_pname", &xref_pname, NULL)
        && xref_pname
           ? strEQ ((char *)xref_pname, (char *)block->xref_pname)
           : !block->xref_pname)
      pass ();
    else
      fail ("BLOCK.xref_pname [TV] '%s' <> '%s'", xref_pname, block->xref_pname);
  }
  if (failed && (is_class_unstable ("BLOCK") || is_class_debugging ("BLOCK")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCK", failed);
      failed = 0;
    }
  return failed;
}
static int test_BODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_BODY *restrict body = obj->tio.entity->tio.BODY;
  failed = 0;
  if (!obj_obj || !body)
    {
      fail ("NULL BODY");
      return 1;
    }
  if (failed && (is_class_unstable ("BODY") || is_class_debugging ("BODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_CAMERA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_CAMERA *restrict camera = obj->tio.entity->tio.CAMERA;
  failed = 0;
  if (!obj_obj || !camera)
    {
      fail ("NULL CAMERA");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (camera, "CAMERA", "parent", &parent, NULL)
        && !memcmp (&parent, &camera->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("CAMERA.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H view;
    if (dwg_dynapi_entity_value (camera, "CAMERA", "view", &view, NULL)
        && !memcmp (&view, &camera->view, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("CAMERA.view [H]");
  }
  if (failed && (is_class_unstable ("CAMERA") || is_class_debugging ("CAMERA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CAMERA", failed);
      failed = 0;
    }
  return failed;
}
static int test_CIRCLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_CIRCLE *restrict circle = obj->tio.entity->tio.CIRCLE;
  failed = 0;
  if (!obj_obj || !circle)
    {
      fail ("NULL CIRCLE");
      return 1;
    }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "center", &center, NULL)
        && !memcmp (&center, &circle->center, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("CIRCLE.center [3BD]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &circle->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("CIRCLE.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "parent", &parent, NULL)
        && !memcmp (&parent, &circle->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("CIRCLE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "radius", &radius, NULL)
        && radius == circle->radius)
      pass ();
    else
      fail ("CIRCLE.radius [BD] %g != %g", circle->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (circle, "CIRCLE", "radius", &radius, 0)
        && radius == circle->radius)
      pass ();
    else
      fail ("CIRCLE.radius [BD] set+1 %g != %g", circle->radius, radius);
    circle->radius--;
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (circle, "CIRCLE", "thickness", &thickness, NULL)
        && thickness == circle->thickness)
      pass ();
    else
      fail ("CIRCLE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", circle->thickness, thickness);
    if (dwg_dynapi_entity_set_value (circle, "CIRCLE", "thickness", &thickness, 0)
        && thickness == circle->thickness)
      pass ();
    else
      fail ("CIRCLE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", circle->thickness, thickness);
    circle->thickness--;
  }
  if (failed && (is_class_unstable ("CIRCLE") || is_class_debugging ("CIRCLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CIRCLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DGNUNDERLAY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DGNUNDERLAY *restrict dgnunderlay = obj->tio.entity->tio.DGNUNDERLAY;
  failed = 0;
  if (!obj_obj || !dgnunderlay)
    {
      fail ("NULL DGNUNDERLAY");
      return 1;
    }
  if (failed && (is_class_unstable ("DGNUNDERLAY") || is_class_debugging ("DGNUNDERLAY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DGNUNDERLAY", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_ALIGNED (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_ALIGNED *restrict dimension_aligned = obj->tio.entity->tio.DIMENSION_ALIGNED;
  failed = 0;
  if (!obj_obj || !dimension_aligned)
    {
      fail ("NULL DIMENSION_ALIGNED");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_aligned->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.act_measurement [BD] %g != %g", dimension_aligned->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_aligned->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.act_measurement [BD] set+1 %g != %g", dimension_aligned->act_measurement, act_measurement);
    dimension_aligned->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "attachment", &attachment, NULL)
        && attachment == dimension_aligned->attachment)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.attachment [BS] %hu != %hu", dimension_aligned->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "attachment", &attachment, 0)
        && attachment == dimension_aligned->attachment)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.attachment [BS] set+1 %hu != %hu", dimension_aligned->attachment, attachment);
    dimension_aligned->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "block", &block, NULL)
        && !memcmp (&block, &dimension_aligned->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.block [H]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "class_version", &class_version, NULL)
        && class_version == dimension_aligned->class_version)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.class_version [RC] %u != %u", dimension_aligned->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "class_version", &class_version, 0)
        && class_version == dimension_aligned->class_version)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.class_version [RC] set+1 %u != %u", dimension_aligned->class_version, class_version);
    dimension_aligned->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_aligned->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_aligned->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_aligned->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "elevation", &elevation, NULL)
        && elevation == dimension_aligned->elevation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.elevation [BD] %g != %g", dimension_aligned->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "elevation", &elevation, 0)
        && elevation == dimension_aligned->elevation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.elevation [BD] set+1 %g != %g", dimension_aligned->elevation, elevation);
    dimension_aligned->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_aligned->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.extrusion [BE]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "flag", &flag, NULL)
        && flag == dimension_aligned->flag)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flag [RC] %u != %u", dimension_aligned->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "flag", &flag, 0)
        && flag == dimension_aligned->flag)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flag [RC] set+1 %u != %u", dimension_aligned->flag, flag);
    dimension_aligned->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "flag1", &flag1, NULL)
        && flag1 == dimension_aligned->flag1)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flag1 [RC] %u != %u", dimension_aligned->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "flag1", &flag1, 0)
        && flag1 == dimension_aligned->flag1)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flag1 [RC] set+1 %u != %u", dimension_aligned->flag1, flag1);
    dimension_aligned->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_aligned->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_aligned->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_aligned->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_aligned->flip_arrow1, flip_arrow1);
    dimension_aligned->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_aligned->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_aligned->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_aligned->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_aligned->flip_arrow2, flip_arrow2);
    dimension_aligned->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_aligned->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.horiz_dir [BD] %g != %g", dimension_aligned->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_aligned->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.horiz_dir [BD] set+1 %g != %g", dimension_aligned->horiz_dir, horiz_dir);
    dimension_aligned->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_aligned->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.ins_rotation [BD] %g != %g", dimension_aligned->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_aligned->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.ins_rotation [BD] set+1 %g != %g", dimension_aligned->ins_rotation, ins_rotation);
    dimension_aligned->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_aligned->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.ins_scale [3BD_1]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_aligned->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.lspace_factor [BD] %g != %g", dimension_aligned->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_aligned->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.lspace_factor [BD] set+1 %g != %g", dimension_aligned->lspace_factor, lspace_factor);
    dimension_aligned->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_aligned->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.lspace_style [BS] %hu != %hu", dimension_aligned->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_aligned->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.lspace_style [BS] set+1 %hu != %hu", dimension_aligned->lspace_style, lspace_style);
    dimension_aligned->lspace_style--;
  }
  {
    BITCODE_BD oblique_angle;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "oblique_angle", &oblique_angle, NULL)
        && oblique_angle == dimension_aligned->oblique_angle)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.oblique_angle [BD] %g != %g", dimension_aligned->oblique_angle, oblique_angle);
    oblique_angle++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "oblique_angle", &oblique_angle, 0)
        && oblique_angle == dimension_aligned->oblique_angle)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.oblique_angle [BD] set+1 %g != %g", dimension_aligned->oblique_angle, oblique_angle);
    dimension_aligned->oblique_angle--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_aligned->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_aligned->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_aligned->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.text_rotation [BD] %g != %g", dimension_aligned->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_aligned->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.text_rotation [BD] set+1 %g != %g", dimension_aligned->text_rotation, text_rotation);
    dimension_aligned->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "unknown", &unknown, NULL)
        && unknown == dimension_aligned->unknown)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_aligned->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_aligned, "DIMENSION_ALIGNED", "unknown", &unknown, 0)
        && unknown == dimension_aligned->unknown)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_aligned->unknown, unknown);
    dimension_aligned->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_aligned->user_text)
           : !dimension_aligned->user_text)
      pass ();
    else
      fail ("DIMENSION_ALIGNED.user_text [T] '%s' <> '%s'", user_text, dimension_aligned->user_text);
  }
  {
    BITCODE_3BD xline1_pt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "xline1_pt", &xline1_pt, NULL)
        && !memcmp (&xline1_pt, &dimension_aligned->xline1_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.xline1_pt [3BD]");
  }
  {
    BITCODE_3BD xline2_pt;
    if (dwg_dynapi_entity_value (dimension_aligned, "DIMENSION_ALIGNED", "xline2_pt", &xline2_pt, NULL)
        && !memcmp (&xline2_pt, &dimension_aligned->xline2_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ALIGNED.xline2_pt [3BD]");
  }
  if (failed && (is_class_unstable ("DIMENSION_ALIGNED") || is_class_debugging ("DIMENSION_ALIGNED")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_ALIGNED", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_ANG2LN (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_ANG2LN *restrict dimension_ang2ln = obj->tio.entity->tio.DIMENSION_ANG2LN;
  failed = 0;
  if (!obj_obj || !dimension_ang2ln)
    {
      fail ("NULL DIMENSION_ANG2LN");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_ang2ln->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.act_measurement [BD] %g != %g", dimension_ang2ln->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_ang2ln->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.act_measurement [BD] set+1 %g != %g", dimension_ang2ln->act_measurement, act_measurement);
    dimension_ang2ln->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "attachment", &attachment, NULL)
        && attachment == dimension_ang2ln->attachment)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.attachment [BS] %hu != %hu", dimension_ang2ln->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "attachment", &attachment, 0)
        && attachment == dimension_ang2ln->attachment)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.attachment [BS] set+1 %hu != %hu", dimension_ang2ln->attachment, attachment);
    dimension_ang2ln->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "block", &block, NULL)
        && !memcmp (&block, &dimension_ang2ln->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.block [H]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "class_version", &class_version, NULL)
        && class_version == dimension_ang2ln->class_version)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.class_version [RC] %u != %u", dimension_ang2ln->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "class_version", &class_version, 0)
        && class_version == dimension_ang2ln->class_version)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.class_version [RC] set+1 %u != %u", dimension_ang2ln->class_version, class_version);
    dimension_ang2ln->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_ang2ln->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_ang2ln->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_ang2ln->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "elevation", &elevation, NULL)
        && elevation == dimension_ang2ln->elevation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.elevation [BD] %g != %g", dimension_ang2ln->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "elevation", &elevation, 0)
        && elevation == dimension_ang2ln->elevation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.elevation [BD] set+1 %g != %g", dimension_ang2ln->elevation, elevation);
    dimension_ang2ln->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_ang2ln->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.extrusion [BE]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flag", &flag, NULL)
        && flag == dimension_ang2ln->flag)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flag [RC] %u != %u", dimension_ang2ln->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flag", &flag, 0)
        && flag == dimension_ang2ln->flag)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flag [RC] set+1 %u != %u", dimension_ang2ln->flag, flag);
    dimension_ang2ln->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flag1", &flag1, NULL)
        && flag1 == dimension_ang2ln->flag1)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flag1 [RC] %u != %u", dimension_ang2ln->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flag1", &flag1, 0)
        && flag1 == dimension_ang2ln->flag1)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flag1 [RC] set+1 %u != %u", dimension_ang2ln->flag1, flag1);
    dimension_ang2ln->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_ang2ln->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_ang2ln->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->flip_arrow1, flip_arrow1);
    dimension_ang2ln->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_ang2ln->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_ang2ln->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->flip_arrow2, flip_arrow2);
    dimension_ang2ln->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_ang2ln->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.horiz_dir [BD] %g != %g", dimension_ang2ln->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_ang2ln->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.horiz_dir [BD] set+1 %g != %g", dimension_ang2ln->horiz_dir, horiz_dir);
    dimension_ang2ln->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_ang2ln->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.ins_rotation [BD] %g != %g", dimension_ang2ln->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_ang2ln->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.ins_rotation [BD] set+1 %g != %g", dimension_ang2ln->ins_rotation, ins_rotation);
    dimension_ang2ln->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_ang2ln->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.ins_scale [3BD_1]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_ang2ln->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.lspace_factor [BD] %g != %g", dimension_ang2ln->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_ang2ln->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.lspace_factor [BD] set+1 %g != %g", dimension_ang2ln->lspace_factor, lspace_factor);
    dimension_ang2ln->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_ang2ln->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.lspace_style [BS] %hu != %hu", dimension_ang2ln->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_ang2ln->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.lspace_style [BS] set+1 %hu != %hu", dimension_ang2ln->lspace_style, lspace_style);
    dimension_ang2ln->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_ang2ln->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_ang2ln->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_ang2ln->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.text_rotation [BD] %g != %g", dimension_ang2ln->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_ang2ln->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.text_rotation [BD] set+1 %g != %g", dimension_ang2ln->text_rotation, text_rotation);
    dimension_ang2ln->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "unknown", &unknown, NULL)
        && unknown == dimension_ang2ln->unknown)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_ang2ln, "DIMENSION_ANG2LN", "unknown", &unknown, 0)
        && unknown == dimension_ang2ln->unknown)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang2ln->unknown, unknown);
    dimension_ang2ln->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_ang2ln->user_text)
           : !dimension_ang2ln->user_text)
      pass ();
    else
      fail ("DIMENSION_ANG2LN.user_text [T] '%s' <> '%s'", user_text, dimension_ang2ln->user_text);
  }
  {
    BITCODE_3BD xline1end_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "xline1end_pt", &xline1end_pt, NULL)
        && !memcmp (&xline1end_pt, &dimension_ang2ln->xline1end_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.xline1end_pt [3BD]");
  }
  {
    BITCODE_3BD xline1start_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "xline1start_pt", &xline1start_pt, NULL)
        && !memcmp (&xline1start_pt, &dimension_ang2ln->xline1start_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.xline1start_pt [3BD]");
  }
  {
    BITCODE_3BD xline2end_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "xline2end_pt", &xline2end_pt, NULL)
        && !memcmp (&xline2end_pt, &dimension_ang2ln->xline2end_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.xline2end_pt [3BD]");
  }
  {
    BITCODE_3BD xline2start_pt;
    if (dwg_dynapi_entity_value (dimension_ang2ln, "DIMENSION_ANG2LN", "xline2start_pt", &xline2start_pt, NULL)
        && !memcmp (&xline2start_pt, &dimension_ang2ln->xline2start_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG2LN.xline2start_pt [3BD]");
  }
  if (failed && (is_class_unstable ("DIMENSION_ANG2LN") || is_class_debugging ("DIMENSION_ANG2LN")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_ANG2LN", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_ANG3PT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_ANG3PT *restrict dimension_ang3pt = obj->tio.entity->tio.DIMENSION_ANG3PT;
  failed = 0;
  if (!obj_obj || !dimension_ang3pt)
    {
      fail ("NULL DIMENSION_ANG3PT");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_ang3pt->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.act_measurement [BD] %g != %g", dimension_ang3pt->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_ang3pt->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.act_measurement [BD] set+1 %g != %g", dimension_ang3pt->act_measurement, act_measurement);
    dimension_ang3pt->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "attachment", &attachment, NULL)
        && attachment == dimension_ang3pt->attachment)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.attachment [BS] %hu != %hu", dimension_ang3pt->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "attachment", &attachment, 0)
        && attachment == dimension_ang3pt->attachment)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.attachment [BS] set+1 %hu != %hu", dimension_ang3pt->attachment, attachment);
    dimension_ang3pt->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "block", &block, NULL)
        && !memcmp (&block, &dimension_ang3pt->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.block [H]");
  }
  {
    BITCODE_3BD center_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "center_pt", &center_pt, NULL)
        && !memcmp (&center_pt, &dimension_ang3pt->center_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.center_pt [3BD]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "class_version", &class_version, NULL)
        && class_version == dimension_ang3pt->class_version)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.class_version [RC] %u != %u", dimension_ang3pt->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "class_version", &class_version, 0)
        && class_version == dimension_ang3pt->class_version)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.class_version [RC] set+1 %u != %u", dimension_ang3pt->class_version, class_version);
    dimension_ang3pt->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_ang3pt->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_ang3pt->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_ang3pt->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "elevation", &elevation, NULL)
        && elevation == dimension_ang3pt->elevation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.elevation [BD] %g != %g", dimension_ang3pt->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "elevation", &elevation, 0)
        && elevation == dimension_ang3pt->elevation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.elevation [BD] set+1 %g != %g", dimension_ang3pt->elevation, elevation);
    dimension_ang3pt->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_ang3pt->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.extrusion [BE]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flag", &flag, NULL)
        && flag == dimension_ang3pt->flag)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flag [RC] %u != %u", dimension_ang3pt->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flag", &flag, 0)
        && flag == dimension_ang3pt->flag)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flag [RC] set+1 %u != %u", dimension_ang3pt->flag, flag);
    dimension_ang3pt->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flag1", &flag1, NULL)
        && flag1 == dimension_ang3pt->flag1)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flag1 [RC] %u != %u", dimension_ang3pt->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flag1", &flag1, 0)
        && flag1 == dimension_ang3pt->flag1)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flag1 [RC] set+1 %u != %u", dimension_ang3pt->flag1, flag1);
    dimension_ang3pt->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_ang3pt->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_ang3pt->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->flip_arrow1, flip_arrow1);
    dimension_ang3pt->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_ang3pt->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_ang3pt->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->flip_arrow2, flip_arrow2);
    dimension_ang3pt->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_ang3pt->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.horiz_dir [BD] %g != %g", dimension_ang3pt->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_ang3pt->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.horiz_dir [BD] set+1 %g != %g", dimension_ang3pt->horiz_dir, horiz_dir);
    dimension_ang3pt->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_ang3pt->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.ins_rotation [BD] %g != %g", dimension_ang3pt->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_ang3pt->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.ins_rotation [BD] set+1 %g != %g", dimension_ang3pt->ins_rotation, ins_rotation);
    dimension_ang3pt->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_ang3pt->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.ins_scale [3BD_1]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_ang3pt->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.lspace_factor [BD] %g != %g", dimension_ang3pt->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_ang3pt->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.lspace_factor [BD] set+1 %g != %g", dimension_ang3pt->lspace_factor, lspace_factor);
    dimension_ang3pt->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_ang3pt->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.lspace_style [BS] %hu != %hu", dimension_ang3pt->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_ang3pt->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.lspace_style [BS] set+1 %hu != %hu", dimension_ang3pt->lspace_style, lspace_style);
    dimension_ang3pt->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_ang3pt->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_ang3pt->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_ang3pt->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.text_rotation [BD] %g != %g", dimension_ang3pt->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_ang3pt->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.text_rotation [BD] set+1 %g != %g", dimension_ang3pt->text_rotation, text_rotation);
    dimension_ang3pt->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "unknown", &unknown, NULL)
        && unknown == dimension_ang3pt->unknown)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_ang3pt, "DIMENSION_ANG3PT", "unknown", &unknown, 0)
        && unknown == dimension_ang3pt->unknown)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ang3pt->unknown, unknown);
    dimension_ang3pt->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_ang3pt->user_text)
           : !dimension_ang3pt->user_text)
      pass ();
    else
      fail ("DIMENSION_ANG3PT.user_text [T] '%s' <> '%s'", user_text, dimension_ang3pt->user_text);
  }
  {
    BITCODE_3BD xline1_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "xline1_pt", &xline1_pt, NULL)
        && !memcmp (&xline1_pt, &dimension_ang3pt->xline1_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.xline1_pt [3BD]");
  }
  {
    BITCODE_3BD xline2_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "xline2_pt", &xline2_pt, NULL)
        && !memcmp (&xline2_pt, &dimension_ang3pt->xline2_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.xline2_pt [3BD]");
  }
  {
    BITCODE_3RD xline2end_pt;
    if (dwg_dynapi_entity_value (dimension_ang3pt, "DIMENSION_ANG3PT", "xline2end_pt", &xline2end_pt, NULL)
        && !memcmp (&xline2end_pt, &dimension_ang3pt->xline2end_pt, sizeof (BITCODE_3RD)))
        pass ();
    else
        fail ("DIMENSION_ANG3PT.xline2end_pt [3RD]");
  }
  if (failed && (is_class_unstable ("DIMENSION_ANG3PT") || is_class_debugging ("DIMENSION_ANG3PT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_ANG3PT", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_DIAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_DIAMETER *restrict dimension_diameter = obj->tio.entity->tio.DIMENSION_DIAMETER;
  failed = 0;
  if (!obj_obj || !dimension_diameter)
    {
      fail ("NULL DIMENSION_DIAMETER");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_diameter->act_measurement)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.act_measurement [BD] %g != %g", dimension_diameter->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_diameter->act_measurement)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.act_measurement [BD] set+1 %g != %g", dimension_diameter->act_measurement, act_measurement);
    dimension_diameter->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "attachment", &attachment, NULL)
        && attachment == dimension_diameter->attachment)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.attachment [BS] %hu != %hu", dimension_diameter->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "attachment", &attachment, 0)
        && attachment == dimension_diameter->attachment)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.attachment [BS] set+1 %hu != %hu", dimension_diameter->attachment, attachment);
    dimension_diameter->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "block", &block, NULL)
        && !memcmp (&block, &dimension_diameter->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.block [H]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "class_version", &class_version, NULL)
        && class_version == dimension_diameter->class_version)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.class_version [RC] %u != %u", dimension_diameter->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "class_version", &class_version, 0)
        && class_version == dimension_diameter->class_version)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.class_version [RC] set+1 %u != %u", dimension_diameter->class_version, class_version);
    dimension_diameter->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_diameter->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_diameter->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_diameter->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "elevation", &elevation, NULL)
        && elevation == dimension_diameter->elevation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.elevation [BD] %g != %g", dimension_diameter->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "elevation", &elevation, 0)
        && elevation == dimension_diameter->elevation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.elevation [BD] set+1 %g != %g", dimension_diameter->elevation, elevation);
    dimension_diameter->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_diameter->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.extrusion [BE]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &dimension_diameter->first_arc_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.first_arc_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "flag", &flag, NULL)
        && flag == dimension_diameter->flag)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flag [RC] %u != %u", dimension_diameter->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "flag", &flag, 0)
        && flag == dimension_diameter->flag)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flag [RC] set+1 %u != %u", dimension_diameter->flag, flag);
    dimension_diameter->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "flag1", &flag1, NULL)
        && flag1 == dimension_diameter->flag1)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flag1 [RC] %u != %u", dimension_diameter->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "flag1", &flag1, 0)
        && flag1 == dimension_diameter->flag1)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flag1 [RC] set+1 %u != %u", dimension_diameter->flag1, flag1);
    dimension_diameter->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_diameter->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_diameter->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_diameter->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_diameter->flip_arrow1, flip_arrow1);
    dimension_diameter->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_diameter->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_diameter->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_diameter->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_diameter->flip_arrow2, flip_arrow2);
    dimension_diameter->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_diameter->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.horiz_dir [BD] %g != %g", dimension_diameter->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_diameter->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.horiz_dir [BD] set+1 %g != %g", dimension_diameter->horiz_dir, horiz_dir);
    dimension_diameter->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_diameter->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.ins_rotation [BD] %g != %g", dimension_diameter->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_diameter->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.ins_rotation [BD] set+1 %g != %g", dimension_diameter->ins_rotation, ins_rotation);
    dimension_diameter->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_diameter->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.ins_scale [3BD_1]");
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "leader_len", &leader_len, NULL)
        && leader_len == dimension_diameter->leader_len)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.leader_len [BD] %g != %g", dimension_diameter->leader_len, leader_len);
    leader_len++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "leader_len", &leader_len, 0)
        && leader_len == dimension_diameter->leader_len)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.leader_len [BD] set+1 %g != %g", dimension_diameter->leader_len, leader_len);
    dimension_diameter->leader_len--;
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_diameter->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.lspace_factor [BD] %g != %g", dimension_diameter->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_diameter->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.lspace_factor [BD] set+1 %g != %g", dimension_diameter->lspace_factor, lspace_factor);
    dimension_diameter->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_diameter->lspace_style)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.lspace_style [BS] %hu != %hu", dimension_diameter->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_diameter->lspace_style)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.lspace_style [BS] set+1 %hu != %hu", dimension_diameter->lspace_style, lspace_style);
    dimension_diameter->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_diameter->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_diameter->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_DIAMETER.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_diameter->text_rotation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.text_rotation [BD] %g != %g", dimension_diameter->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_diameter->text_rotation)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.text_rotation [BD] set+1 %g != %g", dimension_diameter->text_rotation, text_rotation);
    dimension_diameter->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "unknown", &unknown, NULL)
        && unknown == dimension_diameter->unknown)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_diameter->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_diameter, "DIMENSION_DIAMETER", "unknown", &unknown, 0)
        && unknown == dimension_diameter->unknown)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_diameter->unknown, unknown);
    dimension_diameter->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (dimension_diameter, "DIMENSION_DIAMETER", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_diameter->user_text)
           : !dimension_diameter->user_text)
      pass ();
    else
      fail ("DIMENSION_DIAMETER.user_text [T] '%s' <> '%s'", user_text, dimension_diameter->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_DIAMETER") || is_class_debugging ("DIMENSION_DIAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_DIAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_LINEAR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_LINEAR *restrict dimension_linear = obj->tio.entity->tio.DIMENSION_LINEAR;
  failed = 0;
  if (!obj_obj || !dimension_linear)
    {
      fail ("NULL DIMENSION_LINEAR");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_linear->act_measurement)
      pass ();
    else
      fail ("DIMENSION_LINEAR.act_measurement [BD] %g != %g", dimension_linear->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_linear->act_measurement)
      pass ();
    else
      fail ("DIMENSION_LINEAR.act_measurement [BD] set+1 %g != %g", dimension_linear->act_measurement, act_measurement);
    dimension_linear->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "attachment", &attachment, NULL)
        && attachment == dimension_linear->attachment)
      pass ();
    else
      fail ("DIMENSION_LINEAR.attachment [BS] %hu != %hu", dimension_linear->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "attachment", &attachment, 0)
        && attachment == dimension_linear->attachment)
      pass ();
    else
      fail ("DIMENSION_LINEAR.attachment [BS] set+1 %hu != %hu", dimension_linear->attachment, attachment);
    dimension_linear->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "block", &block, NULL)
        && !memcmp (&block, &dimension_linear->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.block [H]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "class_version", &class_version, NULL)
        && class_version == dimension_linear->class_version)
      pass ();
    else
      fail ("DIMENSION_LINEAR.class_version [RC] %u != %u", dimension_linear->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "class_version", &class_version, 0)
        && class_version == dimension_linear->class_version)
      pass ();
    else
      fail ("DIMENSION_LINEAR.class_version [RC] set+1 %u != %u", dimension_linear->class_version, class_version);
    dimension_linear->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_linear->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_linear->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.def_pt [3BD]");
  }
  {
    BITCODE_BD dim_rotation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "dim_rotation", &dim_rotation, NULL)
        && dim_rotation == dimension_linear->dim_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.dim_rotation [BD] %g != %g", dimension_linear->dim_rotation, dim_rotation);
    dim_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "dim_rotation", &dim_rotation, 0)
        && dim_rotation == dimension_linear->dim_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.dim_rotation [BD] set+1 %g != %g", dimension_linear->dim_rotation, dim_rotation);
    dimension_linear->dim_rotation--;
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_linear->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "elevation", &elevation, NULL)
        && elevation == dimension_linear->elevation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.elevation [BD] %g != %g", dimension_linear->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "elevation", &elevation, 0)
        && elevation == dimension_linear->elevation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.elevation [BD] set+1 %g != %g", dimension_linear->elevation, elevation);
    dimension_linear->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_linear->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.extrusion [BE]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "flag", &flag, NULL)
        && flag == dimension_linear->flag)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flag [RC] %u != %u", dimension_linear->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "flag", &flag, 0)
        && flag == dimension_linear->flag)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flag [RC] set+1 %u != %u", dimension_linear->flag, flag);
    dimension_linear->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "flag1", &flag1, NULL)
        && flag1 == dimension_linear->flag1)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flag1 [RC] %u != %u", dimension_linear->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "flag1", &flag1, 0)
        && flag1 == dimension_linear->flag1)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flag1 [RC] set+1 %u != %u", dimension_linear->flag1, flag1);
    dimension_linear->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_linear->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_linear->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_linear->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_linear->flip_arrow1, flip_arrow1);
    dimension_linear->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_linear->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_linear->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_linear->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_LINEAR.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_linear->flip_arrow2, flip_arrow2);
    dimension_linear->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_linear->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_LINEAR.horiz_dir [BD] %g != %g", dimension_linear->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_linear->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_LINEAR.horiz_dir [BD] set+1 %g != %g", dimension_linear->horiz_dir, horiz_dir);
    dimension_linear->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_linear->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.ins_rotation [BD] %g != %g", dimension_linear->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_linear->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.ins_rotation [BD] set+1 %g != %g", dimension_linear->ins_rotation, ins_rotation);
    dimension_linear->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_linear->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.ins_scale [3BD_1]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_linear->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_LINEAR.lspace_factor [BD] %g != %g", dimension_linear->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_linear->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_LINEAR.lspace_factor [BD] set+1 %g != %g", dimension_linear->lspace_factor, lspace_factor);
    dimension_linear->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_linear->lspace_style)
      pass ();
    else
      fail ("DIMENSION_LINEAR.lspace_style [BS] %hu != %hu", dimension_linear->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_linear->lspace_style)
      pass ();
    else
      fail ("DIMENSION_LINEAR.lspace_style [BS] set+1 %hu != %hu", dimension_linear->lspace_style, lspace_style);
    dimension_linear->lspace_style--;
  }
  {
    BITCODE_BD oblique_angle;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "oblique_angle", &oblique_angle, NULL)
        && oblique_angle == dimension_linear->oblique_angle)
      pass ();
    else
      fail ("DIMENSION_LINEAR.oblique_angle [BD] %g != %g", dimension_linear->oblique_angle, oblique_angle);
    oblique_angle++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "oblique_angle", &oblique_angle, 0)
        && oblique_angle == dimension_linear->oblique_angle)
      pass ();
    else
      fail ("DIMENSION_LINEAR.oblique_angle [BD] set+1 %g != %g", dimension_linear->oblique_angle, oblique_angle);
    dimension_linear->oblique_angle--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_linear->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_linear->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_linear->text_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.text_rotation [BD] %g != %g", dimension_linear->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_linear->text_rotation)
      pass ();
    else
      fail ("DIMENSION_LINEAR.text_rotation [BD] set+1 %g != %g", dimension_linear->text_rotation, text_rotation);
    dimension_linear->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "unknown", &unknown, NULL)
        && unknown == dimension_linear->unknown)
      pass ();
    else
      fail ("DIMENSION_LINEAR.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_linear->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_linear, "DIMENSION_LINEAR", "unknown", &unknown, 0)
        && unknown == dimension_linear->unknown)
      pass ();
    else
      fail ("DIMENSION_LINEAR.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_linear->unknown, unknown);
    dimension_linear->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_linear->user_text)
           : !dimension_linear->user_text)
      pass ();
    else
      fail ("DIMENSION_LINEAR.user_text [T] '%s' <> '%s'", user_text, dimension_linear->user_text);
  }
  {
    BITCODE_3BD xline1_pt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "xline1_pt", &xline1_pt, NULL)
        && !memcmp (&xline1_pt, &dimension_linear->xline1_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.xline1_pt [3BD]");
  }
  {
    BITCODE_3BD xline2_pt;
    if (dwg_dynapi_entity_value (dimension_linear, "DIMENSION_LINEAR", "xline2_pt", &xline2_pt, NULL)
        && !memcmp (&xline2_pt, &dimension_linear->xline2_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_LINEAR.xline2_pt [3BD]");
  }
  if (failed && (is_class_unstable ("DIMENSION_LINEAR") || is_class_debugging ("DIMENSION_LINEAR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_LINEAR", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_ORDINATE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_ORDINATE *restrict dimension_ordinate = obj->tio.entity->tio.DIMENSION_ORDINATE;
  failed = 0;
  if (!obj_obj || !dimension_ordinate)
    {
      fail ("NULL DIMENSION_ORDINATE");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_ordinate->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.act_measurement [BD] %g != %g", dimension_ordinate->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_ordinate->act_measurement)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.act_measurement [BD] set+1 %g != %g", dimension_ordinate->act_measurement, act_measurement);
    dimension_ordinate->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "attachment", &attachment, NULL)
        && attachment == dimension_ordinate->attachment)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.attachment [BS] %hu != %hu", dimension_ordinate->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "attachment", &attachment, 0)
        && attachment == dimension_ordinate->attachment)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.attachment [BS] set+1 %hu != %hu", dimension_ordinate->attachment, attachment);
    dimension_ordinate->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "block", &block, NULL)
        && !memcmp (&block, &dimension_ordinate->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.block [H]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "class_version", &class_version, NULL)
        && class_version == dimension_ordinate->class_version)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.class_version [RC] %u != %u", dimension_ordinate->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "class_version", &class_version, 0)
        && class_version == dimension_ordinate->class_version)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.class_version [RC] set+1 %u != %u", dimension_ordinate->class_version, class_version);
    dimension_ordinate->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_ordinate->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_ordinate->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_ordinate->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "elevation", &elevation, NULL)
        && elevation == dimension_ordinate->elevation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.elevation [BD] %g != %g", dimension_ordinate->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "elevation", &elevation, 0)
        && elevation == dimension_ordinate->elevation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.elevation [BD] set+1 %g != %g", dimension_ordinate->elevation, elevation);
    dimension_ordinate->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_ordinate->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.extrusion [BE]");
  }
  {
    BITCODE_3BD feature_location_pt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "feature_location_pt", &feature_location_pt, NULL)
        && !memcmp (&feature_location_pt, &dimension_ordinate->feature_location_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.feature_location_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag", &flag, NULL)
        && flag == dimension_ordinate->flag)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag [RC] %u != %u", dimension_ordinate->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag", &flag, 0)
        && flag == dimension_ordinate->flag)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag [RC] set+1 %u != %u", dimension_ordinate->flag, flag);
    dimension_ordinate->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag1", &flag1, NULL)
        && flag1 == dimension_ordinate->flag1)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag1 [RC] %u != %u", dimension_ordinate->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag1", &flag1, 0)
        && flag1 == dimension_ordinate->flag1)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag1 [RC] set+1 %u != %u", dimension_ordinate->flag1, flag1);
    dimension_ordinate->flag1--;
  }
  {
    BITCODE_RC flag2;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag2", &flag2, NULL)
        && flag2 == dimension_ordinate->flag2)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag2 [RC] %u != %u", dimension_ordinate->flag2, flag2);
    flag2++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flag2", &flag2, 0)
        && flag2 == dimension_ordinate->flag2)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flag2 [RC] set+1 %u != %u", dimension_ordinate->flag2, flag2);
    dimension_ordinate->flag2--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_ordinate->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_ordinate->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_ordinate->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ordinate->flip_arrow1, flip_arrow1);
    dimension_ordinate->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_ordinate->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_ordinate->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_ordinate->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ordinate->flip_arrow2, flip_arrow2);
    dimension_ordinate->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_ordinate->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.horiz_dir [BD] %g != %g", dimension_ordinate->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_ordinate->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.horiz_dir [BD] set+1 %g != %g", dimension_ordinate->horiz_dir, horiz_dir);
    dimension_ordinate->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_ordinate->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.ins_rotation [BD] %g != %g", dimension_ordinate->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_ordinate->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.ins_rotation [BD] set+1 %g != %g", dimension_ordinate->ins_rotation, ins_rotation);
    dimension_ordinate->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_ordinate->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.ins_scale [3BD_1]");
  }
  {
    BITCODE_3BD leader_endpt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "leader_endpt", &leader_endpt, NULL)
        && !memcmp (&leader_endpt, &dimension_ordinate->leader_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.leader_endpt [3BD]");
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_ordinate->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.lspace_factor [BD] %g != %g", dimension_ordinate->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_ordinate->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.lspace_factor [BD] set+1 %g != %g", dimension_ordinate->lspace_factor, lspace_factor);
    dimension_ordinate->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_ordinate->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.lspace_style [BS] %hu != %hu", dimension_ordinate->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_ordinate->lspace_style)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.lspace_style [BS] set+1 %hu != %hu", dimension_ordinate->lspace_style, lspace_style);
    dimension_ordinate->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_ordinate->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_ordinate->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_ORDINATE.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_ordinate->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.text_rotation [BD] %g != %g", dimension_ordinate->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_ordinate->text_rotation)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.text_rotation [BD] set+1 %g != %g", dimension_ordinate->text_rotation, text_rotation);
    dimension_ordinate->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "unknown", &unknown, NULL)
        && unknown == dimension_ordinate->unknown)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_ordinate->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_ordinate, "DIMENSION_ORDINATE", "unknown", &unknown, 0)
        && unknown == dimension_ordinate->unknown)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_ordinate->unknown, unknown);
    dimension_ordinate->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (dimension_ordinate, "DIMENSION_ORDINATE", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_ordinate->user_text)
           : !dimension_ordinate->user_text)
      pass ();
    else
      fail ("DIMENSION_ORDINATE.user_text [T] '%s' <> '%s'", user_text, dimension_ordinate->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_ORDINATE") || is_class_debugging ("DIMENSION_ORDINATE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_ORDINATE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMENSION_RADIUS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DIMENSION_RADIUS *restrict dimension_radius = obj->tio.entity->tio.DIMENSION_RADIUS;
  failed = 0;
  if (!obj_obj || !dimension_radius)
    {
      fail ("NULL DIMENSION_RADIUS");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "act_measurement", &act_measurement, NULL)
        && act_measurement == dimension_radius->act_measurement)
      pass ();
    else
      fail ("DIMENSION_RADIUS.act_measurement [BD] %g != %g", dimension_radius->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "act_measurement", &act_measurement, 0)
        && act_measurement == dimension_radius->act_measurement)
      pass ();
    else
      fail ("DIMENSION_RADIUS.act_measurement [BD] set+1 %g != %g", dimension_radius->act_measurement, act_measurement);
    dimension_radius->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "attachment", &attachment, NULL)
        && attachment == dimension_radius->attachment)
      pass ();
    else
      fail ("DIMENSION_RADIUS.attachment [BS] %hu != %hu", dimension_radius->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "attachment", &attachment, 0)
        && attachment == dimension_radius->attachment)
      pass ();
    else
      fail ("DIMENSION_RADIUS.attachment [BS] set+1 %hu != %hu", dimension_radius->attachment, attachment);
    dimension_radius->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "block", &block, NULL)
        && !memcmp (&block, &dimension_radius->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.block [H]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "class_version", &class_version, NULL)
        && class_version == dimension_radius->class_version)
      pass ();
    else
      fail ("DIMENSION_RADIUS.class_version [RC] %u != %u", dimension_radius->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "class_version", &class_version, 0)
        && class_version == dimension_radius->class_version)
      pass ();
    else
      fail ("DIMENSION_RADIUS.class_version [RC] set+1 %u != %u", dimension_radius->class_version, class_version);
    dimension_radius->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &dimension_radius->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dimension_radius->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &dimension_radius->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "elevation", &elevation, NULL)
        && elevation == dimension_radius->elevation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.elevation [BD] %g != %g", dimension_radius->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "elevation", &elevation, 0)
        && elevation == dimension_radius->elevation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.elevation [BD] set+1 %g != %g", dimension_radius->elevation, elevation);
    dimension_radius->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &dimension_radius->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.extrusion [BE]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &dimension_radius->first_arc_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.first_arc_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "flag", &flag, NULL)
        && flag == dimension_radius->flag)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flag [RC] %u != %u", dimension_radius->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "flag", &flag, 0)
        && flag == dimension_radius->flag)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flag [RC] set+1 %u != %u", dimension_radius->flag, flag);
    dimension_radius->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "flag1", &flag1, NULL)
        && flag1 == dimension_radius->flag1)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flag1 [RC] %u != %u", dimension_radius->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "flag1", &flag1, 0)
        && flag1 == dimension_radius->flag1)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flag1 [RC] set+1 %u != %u", dimension_radius->flag1, flag1);
    dimension_radius->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == dimension_radius->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", dimension_radius->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == dimension_radius->flip_arrow1)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_radius->flip_arrow1, flip_arrow1);
    dimension_radius->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == dimension_radius->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", dimension_radius->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == dimension_radius->flip_arrow2)
      pass ();
    else
      fail ("DIMENSION_RADIUS.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_radius->flip_arrow2, flip_arrow2);
    dimension_radius->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == dimension_radius->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_RADIUS.horiz_dir [BD] %g != %g", dimension_radius->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == dimension_radius->horiz_dir)
      pass ();
    else
      fail ("DIMENSION_RADIUS.horiz_dir [BD] set+1 %g != %g", dimension_radius->horiz_dir, horiz_dir);
    dimension_radius->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == dimension_radius->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.ins_rotation [BD] %g != %g", dimension_radius->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == dimension_radius->ins_rotation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.ins_rotation [BD] set+1 %g != %g", dimension_radius->ins_rotation, ins_rotation);
    dimension_radius->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &dimension_radius->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.ins_scale [3BD_1]");
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "leader_len", &leader_len, NULL)
        && leader_len == dimension_radius->leader_len)
      pass ();
    else
      fail ("DIMENSION_RADIUS.leader_len [BD] %g != %g", dimension_radius->leader_len, leader_len);
    leader_len++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "leader_len", &leader_len, 0)
        && leader_len == dimension_radius->leader_len)
      pass ();
    else
      fail ("DIMENSION_RADIUS.leader_len [BD] set+1 %g != %g", dimension_radius->leader_len, leader_len);
    dimension_radius->leader_len--;
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == dimension_radius->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_RADIUS.lspace_factor [BD] %g != %g", dimension_radius->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == dimension_radius->lspace_factor)
      pass ();
    else
      fail ("DIMENSION_RADIUS.lspace_factor [BD] set+1 %g != %g", dimension_radius->lspace_factor, lspace_factor);
    dimension_radius->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "lspace_style", &lspace_style, NULL)
        && lspace_style == dimension_radius->lspace_style)
      pass ();
    else
      fail ("DIMENSION_RADIUS.lspace_style [BS] %hu != %hu", dimension_radius->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "lspace_style", &lspace_style, 0)
        && lspace_style == dimension_radius->lspace_style)
      pass ();
    else
      fail ("DIMENSION_RADIUS.lspace_style [BS] set+1 %hu != %hu", dimension_radius->lspace_style, lspace_style);
    dimension_radius->lspace_style--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "parent", &parent, NULL)
        && !memcmp (&parent, &dimension_radius->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &dimension_radius->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("DIMENSION_RADIUS.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "text_rotation", &text_rotation, NULL)
        && text_rotation == dimension_radius->text_rotation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.text_rotation [BD] %g != %g", dimension_radius->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "text_rotation", &text_rotation, 0)
        && text_rotation == dimension_radius->text_rotation)
      pass ();
    else
      fail ("DIMENSION_RADIUS.text_rotation [BD] set+1 %g != %g", dimension_radius->text_rotation, text_rotation);
    dimension_radius->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "unknown", &unknown, NULL)
        && unknown == dimension_radius->unknown)
      pass ();
    else
      fail ("DIMENSION_RADIUS.unknown [B] " FORMAT_B " != " FORMAT_B "", dimension_radius->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (dimension_radius, "DIMENSION_RADIUS", "unknown", &unknown, 0)
        && unknown == dimension_radius->unknown)
      pass ();
    else
      fail ("DIMENSION_RADIUS.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", dimension_radius->unknown, unknown);
    dimension_radius->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (dimension_radius, "DIMENSION_RADIUS", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)dimension_radius->user_text)
           : !dimension_radius->user_text)
      pass ();
    else
      fail ("DIMENSION_RADIUS.user_text [T] '%s' <> '%s'", user_text, dimension_radius->user_text);
  }
  if (failed && (is_class_unstable ("DIMENSION_RADIUS") || is_class_debugging ("DIMENSION_RADIUS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMENSION_RADIUS", failed);
      failed = 0;
    }
  return failed;
}
static int test_DWFUNDERLAY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_DWFUNDERLAY *restrict dwfunderlay = obj->tio.entity->tio.DWFUNDERLAY;
  failed = 0;
  if (!obj_obj || !dwfunderlay)
    {
      fail ("NULL DWFUNDERLAY");
      return 1;
    }
  if (failed && (is_class_unstable ("DWFUNDERLAY") || is_class_debugging ("DWFUNDERLAY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DWFUNDERLAY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ELLIPSE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ELLIPSE *restrict ellipse = obj->tio.entity->tio.ELLIPSE;
  failed = 0;
  if (!obj_obj || !ellipse)
    {
      fail ("NULL ELLIPSE");
      return 1;
    }
  {
    BITCODE_BD axis_ratio;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "axis_ratio", &axis_ratio, NULL)
        && axis_ratio == ellipse->axis_ratio)
      pass ();
    else
      fail ("ELLIPSE.axis_ratio [BD] %g != %g", ellipse->axis_ratio, axis_ratio);
    axis_ratio++;
    if (dwg_dynapi_entity_set_value (ellipse, "ELLIPSE", "axis_ratio", &axis_ratio, 0)
        && axis_ratio == ellipse->axis_ratio)
      pass ();
    else
      fail ("ELLIPSE.axis_ratio [BD] set+1 %g != %g", ellipse->axis_ratio, axis_ratio);
    ellipse->axis_ratio--;
  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "center", &center, NULL)
        && !memcmp (&center, &ellipse->center, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ELLIPSE.center [3BD]");
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "end_angle", &end_angle, NULL)
        && end_angle == ellipse->end_angle)
      pass ();
    else
      fail ("ELLIPSE.end_angle [BD] %g != %g", ellipse->end_angle, end_angle);
    end_angle++;
    if (dwg_dynapi_entity_set_value (ellipse, "ELLIPSE", "end_angle", &end_angle, 0)
        && end_angle == ellipse->end_angle)
      pass ();
    else
      fail ("ELLIPSE.end_angle [BD] set+1 %g != %g", ellipse->end_angle, end_angle);
    ellipse->end_angle--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &ellipse->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("ELLIPSE.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "parent", &parent, NULL)
        && !memcmp (&parent, &ellipse->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ELLIPSE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD sm_axis;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "sm_axis", &sm_axis, NULL)
        && !memcmp (&sm_axis, &ellipse->sm_axis, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ELLIPSE.sm_axis [3BD]");
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (ellipse, "ELLIPSE", "start_angle", &start_angle, NULL)
        && start_angle == ellipse->start_angle)
      pass ();
    else
      fail ("ELLIPSE.start_angle [BD] %g != %g", ellipse->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (ellipse, "ELLIPSE", "start_angle", &start_angle, 0)
        && start_angle == ellipse->start_angle)
      pass ();
    else
      fail ("ELLIPSE.start_angle [BD] set+1 %g != %g", ellipse->start_angle, start_angle);
    ellipse->start_angle--;
  }
  if (failed && (is_class_unstable ("ELLIPSE") || is_class_debugging ("ELLIPSE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ELLIPSE", failed);
      failed = 0;
    }
  return failed;
}
static int test_ENDBLK (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ENDBLK *restrict endblk = obj->tio.entity->tio.ENDBLK;
  failed = 0;
  if (!obj_obj || !endblk)
    {
      fail ("NULL ENDBLK");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (endblk, "ENDBLK", "parent", &parent, NULL)
        && !memcmp (&parent, &endblk->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ENDBLK.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("ENDBLK") || is_class_debugging ("ENDBLK")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ENDBLK", failed);
      failed = 0;
    }
  return failed;
}
static int test_ENDREP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ENDREP *restrict endrep = obj->tio.entity->tio.ENDREP;
  failed = 0;
  if (!obj_obj || !endrep)
    {
      fail ("NULL ENDREP");
      return 1;
    }
  {
    BITCODE_RD col_spacing;
    if (dwg_dynapi_entity_value (endrep, "ENDREP", "col_spacing", &col_spacing, NULL)
        && col_spacing == endrep->col_spacing)
      pass ();
    else
      fail ("ENDREP.col_spacing [RD] %g != %g", endrep->col_spacing, col_spacing);
    col_spacing++;
    if (dwg_dynapi_entity_set_value (endrep, "ENDREP", "col_spacing", &col_spacing, 0)
        && col_spacing == endrep->col_spacing)
      pass ();
    else
      fail ("ENDREP.col_spacing [RD] set+1 %g != %g", endrep->col_spacing, col_spacing);
    endrep->col_spacing--;
  }
  {
    BITCODE_RS num_cols;
    if (dwg_dynapi_entity_value (endrep, "ENDREP", "num_cols", &num_cols, NULL)
        && num_cols == endrep->num_cols)
      pass ();
    else
      fail ("ENDREP.num_cols [RS] %hu != %hu", endrep->num_cols, num_cols);
    num_cols++;
    if (dwg_dynapi_entity_set_value (endrep, "ENDREP", "num_cols", &num_cols, 0)
        && num_cols == endrep->num_cols)
      pass ();
    else
      fail ("ENDREP.num_cols [RS] set+1 %hu != %hu", endrep->num_cols, num_cols);
    endrep->num_cols--;
  }
  {
    BITCODE_RS num_rows;
    if (dwg_dynapi_entity_value (endrep, "ENDREP", "num_rows", &num_rows, NULL)
        && num_rows == endrep->num_rows)
      pass ();
    else
      fail ("ENDREP.num_rows [RS] %hu != %hu", endrep->num_rows, num_rows);
    num_rows++;
    if (dwg_dynapi_entity_set_value (endrep, "ENDREP", "num_rows", &num_rows, 0)
        && num_rows == endrep->num_rows)
      pass ();
    else
      fail ("ENDREP.num_rows [RS] set+1 %hu != %hu", endrep->num_rows, num_rows);
    endrep->num_rows--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (endrep, "ENDREP", "parent", &parent, NULL)
        && !memcmp (&parent, &endrep->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ENDREP.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_RD row_spacing;
    if (dwg_dynapi_entity_value (endrep, "ENDREP", "row_spacing", &row_spacing, NULL)
        && row_spacing == endrep->row_spacing)
      pass ();
    else
      fail ("ENDREP.row_spacing [RD] %g != %g", endrep->row_spacing, row_spacing);
    row_spacing++;
    if (dwg_dynapi_entity_set_value (endrep, "ENDREP", "row_spacing", &row_spacing, 0)
        && row_spacing == endrep->row_spacing)
      pass ();
    else
      fail ("ENDREP.row_spacing [RD] set+1 %g != %g", endrep->row_spacing, row_spacing);
    endrep->row_spacing--;
  }
  if (failed && (is_class_unstable ("ENDREP") || is_class_debugging ("ENDREP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ENDREP", failed);
      failed = 0;
    }
  return failed;
}
static int test_EXTRUDEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_EXTRUDEDSURFACE *restrict extrudedsurface = obj->tio.entity->tio.EXTRUDEDSURFACE;
  failed = 0;
  if (!obj_obj || !extrudedsurface)
    {
      fail ("NULL EXTRUDEDSURFACE");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == extrudedsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("EXTRUDEDSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == extrudedsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("EXTRUDEDSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->_dxf_sab_converted, _dxf_sab_converted);
    extrudedsurface->_dxf_sab_converted--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)extrudedsurface->acis_data)
           : !extrudedsurface->acis_data)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, extrudedsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == extrudedsurface->acis_empty)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == extrudedsurface->acis_empty)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty, acis_empty);
    extrudedsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == extrudedsurface->acis_empty2)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == extrudedsurface->acis_empty2)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty2, acis_empty2);
    extrudedsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == extrudedsurface->acis_empty_bit)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == extrudedsurface->acis_empty_bit)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty_bit, acis_empty_bit);
    extrudedsurface->acis_empty_bit--;
  }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle, NULL)
        && align_angle == extrudedsurface->align_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.align_angle [BD] %g != %g", extrudedsurface->align_angle, align_angle);
    align_angle++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle, 0)
        && align_angle == extrudedsurface->align_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.align_angle [BD] set+1 %g != %g", extrudedsurface->align_angle, align_angle);
    extrudedsurface->align_angle--;
  }
  {
    BITCODE_B align_start;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start, NULL)
        && align_start == extrudedsurface->align_start)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start);
    align_start++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start, 0)
        && align_start == extrudedsurface->align_start)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start);
    extrudedsurface->align_start--;
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank, NULL)
        && bank == extrudedsurface->bank)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank);
    bank++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank, 0)
        && bank == extrudedsurface->bank)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank);
    extrudedsurface->bank--;
  }
  {
    BITCODE_B base_point_set;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set, NULL)
        && base_point_set == extrudedsurface->base_point_set)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set);
    base_point_set++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set, 0)
        && base_point_set == extrudedsurface->base_point_set)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.base_point_set [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set);
    extrudedsurface->base_point_set--;
  }
  {
    BITCODE_TF bindata;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata", &bindata, NULL)
        && !memcmp (&bindata, &extrudedsurface->bindata, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.bindata [TF]");
  }
  {
    BITCODE_BL bindata_size;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata_size", &bindata_size, NULL)
        && bindata_size == extrudedsurface->bindata_size)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.bindata_size [BL] %u != %u", extrudedsurface->bindata_size, bindata_size);
    bindata_size++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata_size", &bindata_size, 0)
        && bindata_size == extrudedsurface->bindata_size)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.bindata_size [BL] set+1 %u != %u", extrudedsurface->bindata_size, bindata_size);
    extrudedsurface->bindata_size--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &extrudedsurface->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version, NULL)
        && class_version == extrudedsurface->class_version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.class_version [BL] %u != %u", extrudedsurface->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version, 0)
        && class_version == extrudedsurface->class_version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.class_version [BL] set+1 %u != %u", extrudedsurface->class_version, class_version);
    extrudedsurface->class_version--;
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle, NULL)
        && draft_angle == extrudedsurface->draft_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_angle [BD] %g != %g", extrudedsurface->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle, 0)
        && draft_angle == extrudedsurface->draft_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_angle [BD] set+1 %g != %g", extrudedsurface->draft_angle, draft_angle);
    extrudedsurface->draft_angle--;
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance, NULL)
        && draft_end_distance == extrudedsurface->draft_end_distance)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_end_distance [BD] %g != %g", extrudedsurface->draft_end_distance, draft_end_distance);
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance, 0)
        && draft_end_distance == extrudedsurface->draft_end_distance)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_end_distance [BD] set+1 %g != %g", extrudedsurface->draft_end_distance, draft_end_distance);
    extrudedsurface->draft_end_distance--;
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance, NULL)
        && draft_start_distance == extrudedsurface->draft_start_distance)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_start_distance [BD] %g != %g", extrudedsurface->draft_start_distance, draft_start_distance);
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance, 0)
        && draft_start_distance == extrudedsurface->draft_start_distance)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.draft_start_distance [BD] set+1 %g != %g", extrudedsurface->draft_start_distance, draft_start_distance);
    extrudedsurface->draft_start_distance--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &extrudedsurface->encr_sat_data, sizeof (extrudedsurface->encr_sat_data)))
      pass ();
    else
      fail ("EXTRUDEDSURFACE.encr_sat_data [char **]");
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "end_marker", &end_marker, NULL)
        && end_marker == extrudedsurface->end_marker)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.end_marker [BL] %u != %u", extrudedsurface->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "end_marker", &end_marker, 0)
        && end_marker == extrudedsurface->end_marker)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.end_marker [BL] set+1 %u != %u", extrudedsurface->end_marker, end_marker);
    extrudedsurface->end_marker--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &extrudedsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == extrudedsurface->has_revision_guid)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == extrudedsurface->has_revision_guid)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->has_revision_guid, has_revision_guid);
    extrudedsurface->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &extrudedsurface->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.history_id [H]");
  }
  {
    BITCODE_B is_solid;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "is_solid", &is_solid, NULL)
        && is_solid == extrudedsurface->is_solid)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.is_solid [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->is_solid, is_solid);
    is_solid++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "is_solid", &is_solid, 0)
        && is_solid == extrudedsurface->is_solid)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.is_solid [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->is_solid, is_solid);
    extrudedsurface->is_solid--;
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == extrudedsurface->isoline_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == extrudedsurface->isoline_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->isoline_present, isoline_present);
    extrudedsurface->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "isolines", &isolines, NULL)
        && isolines == extrudedsurface->isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.isolines [BL] %u != %u", extrudedsurface->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "isolines", &isolines, 0)
        && isolines == extrudedsurface->isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.isolines [BL] set+1 %u != %u", extrudedsurface->isolines, isolines);
    extrudedsurface->isolines--;
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "materials", &materials, NULL)
        && materials == extrudedsurface->materials)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == extrudedsurface->modeler_format_version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.modeler_format_version [BS] %hu != %hu", extrudedsurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == extrudedsurface->modeler_format_version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", extrudedsurface->modeler_format_version, modeler_format_version);
    extrudedsurface->modeler_format_version--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == extrudedsurface->num_blocks)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_blocks [BL] %u != %u", extrudedsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == extrudedsurface->num_blocks)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_blocks [BL] set+1 %u != %u", extrudedsurface->num_blocks, num_blocks);
    extrudedsurface->num_blocks--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_materials", &num_materials, NULL)
        && num_materials == extrudedsurface->num_materials)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_materials [BL] %u != %u", extrudedsurface->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_materials", &num_materials, 0)
        && num_materials == extrudedsurface->num_materials)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_materials [BL] set+1 %u != %u", extrudedsurface->num_materials, num_materials);
    extrudedsurface->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == extrudedsurface->num_silhouettes)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_silhouettes [BL] %u != %u", extrudedsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == extrudedsurface->num_silhouettes)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_silhouettes [BL] set+1 %u != %u", extrudedsurface->num_silhouettes, num_silhouettes);
    extrudedsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == extrudedsurface->num_wires)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_wires [BL] %u != %u", extrudedsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires, 0)
        && num_wires == extrudedsurface->num_wires)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.num_wires [BL] set+1 %u != %u", extrudedsurface->num_wires, num_wires);
    extrudedsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &extrudedsurface->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H path_entity;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity", &path_entity, NULL)
        && !memcmp (&path_entity, &extrudedsurface->path_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.path_entity [H]");
  }
  {
    BITCODE_B path_entity_transform_computed;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL)
        && path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed);
    path_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, 0)
        && path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed);
    extrudedsurface->path_entity_transform_computed--;
  }
  {
    BITCODE_BD* path_entity_transmatrix;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
        && !memcmp (&path_entity_transmatrix, &extrudedsurface->path_entity_transmatrix, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.path_entity_transmatrix [BD*]");
  }
  {
    BITCODE_BS path_flags;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_flags", &path_flags, NULL)
        && path_flags == extrudedsurface->path_flags)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.path_flags [BS] %hu != %hu", extrudedsurface->path_flags, path_flags);
    path_flags++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "path_flags", &path_flags, 0)
        && path_flags == extrudedsurface->path_flags)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.path_flags [BS] set+1 %hu != %hu", extrudedsurface->path_flags, path_flags);
    extrudedsurface->path_flags--;
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "point", &point, NULL)
        && !memcmp (&point, &extrudedsurface->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present, NULL)
        && point_present == extrudedsurface->point_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present, 0)
        && point_present == extrudedsurface->point_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->point_present, point_present);
    extrudedsurface->point_present--;
  }
  {
    BITCODE_3BD reference_vector_for_controlling_twist;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
        && !memcmp (&reference_vector_for_controlling_twist, &extrudedsurface->reference_vector_for_controlling_twist, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.reference_vector_for_controlling_twist [3BD]");
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &extrudedsurface->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &extrudedsurface->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_major", &revision_major, NULL)
        && revision_major == extrudedsurface->revision_major)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.revision_major [BL] %u != %u", extrudedsurface->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_major", &revision_major, 0)
        && revision_major == extrudedsurface->revision_major)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.revision_major [BL] set+1 %u != %u", extrudedsurface->revision_major, revision_major);
    extrudedsurface->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == extrudedsurface->revision_minor1)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.revision_minor1 [BS] %hu != %hu", extrudedsurface->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == extrudedsurface->revision_minor1)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.revision_minor1 [BS] set+1 %hu != %hu", extrudedsurface->revision_minor1, revision_minor1);
    extrudedsurface->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == extrudedsurface->revision_minor2)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.revision_minor2 [BS] %hu != %hu", extrudedsurface->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == extrudedsurface->revision_minor2)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.revision_minor2 [BS] set+1 %hu != %hu", extrudedsurface->revision_minor2, revision_minor2);
    extrudedsurface->revision_minor2--;
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sab_size", &sab_size, NULL)
        && sab_size == extrudedsurface->sab_size)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sab_size [BL] %u != %u", extrudedsurface->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "sab_size", &sab_size, 0)
        && sab_size == extrudedsurface->sab_size)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sab_size [BL] set+1 %u != %u", extrudedsurface->sab_size, sab_size);
    extrudedsurface->sab_size--;
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor, NULL)
        && scale_factor == extrudedsurface->scale_factor)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.scale_factor [BD] %g != %g", extrudedsurface->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor, 0)
        && scale_factor == extrudedsurface->scale_factor)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.scale_factor [BD] set+1 %g != %g", extrudedsurface->scale_factor, scale_factor);
    extrudedsurface->scale_factor--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == extrudedsurface->silhouettes)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_BS sweep_alignment_flags;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, NULL)
        && sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] %hu != %hu", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags);
    sweep_alignment_flags++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, 0)
        && sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] set+1 %hu != %hu", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags);
    extrudedsurface->sweep_alignment_flags--;
  }
  {
    BITCODE_H sweep_entity;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity", &sweep_entity, NULL)
        && !memcmp (&sweep_entity, &extrudedsurface->sweep_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.sweep_entity [H]");
  }
  {
    BITCODE_B sweep_entity_transform_computed;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL)
        && sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
    sweep_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, 0)
        && sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
    extrudedsurface->sweep_entity_transform_computed--;
  }
  {
    BITCODE_BD* sweep_entity_transmatrix;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
        && !memcmp (&sweep_entity_transmatrix, &extrudedsurface->sweep_entity_transmatrix, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.sweep_entity_transmatrix [BD*]");
  }
  {
    BITCODE_BD* sweep_transmatrix;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_transmatrix", &sweep_transmatrix, NULL)
        && !memcmp (&sweep_transmatrix, &extrudedsurface->sweep_transmatrix, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.sweep_transmatrix [BD*]");
  }
  {
    BITCODE_3BD sweep_vector;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_vector", &sweep_vector, NULL)
        && !memcmp (&sweep_vector, &extrudedsurface->sweep_vector, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("EXTRUDEDSURFACE.sweep_vector [3BD]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle, NULL)
        && twist_angle == extrudedsurface->twist_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.twist_angle [BD] %g != %g", extrudedsurface->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle, 0)
        && twist_angle == extrudedsurface->twist_angle)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.twist_angle [BD] set+1 %g != %g", extrudedsurface->twist_angle, twist_angle);
    extrudedsurface->twist_angle--;
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == extrudedsurface->u_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.u_isolines [BS] %hu != %hu", extrudedsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == extrudedsurface->u_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.u_isolines [BS] set+1 %hu != %hu", extrudedsurface->u_isolines, u_isolines);
    extrudedsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown, NULL)
        && unknown == extrudedsurface->unknown)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown, 0)
        && unknown == extrudedsurface->unknown)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->unknown, unknown);
    extrudedsurface->unknown--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == extrudedsurface->v_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.v_isolines [BS] %hu != %hu", extrudedsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == extrudedsurface->v_isolines)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.v_isolines [BS] set+1 %hu != %hu", extrudedsurface->v_isolines, v_isolines);
    extrudedsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "version", &version, NULL)
        && version == extrudedsurface->version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.version [BS] %hu != %hu", extrudedsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "version", &version, 0)
        && version == extrudedsurface->version)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.version [BS] set+1 %hu != %hu", extrudedsurface->version, version);
    extrudedsurface->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == extrudedsurface->wireframe_data_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == extrudedsurface->wireframe_data_present)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->wireframe_data_present, wireframe_data_present);
    extrudedsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "wires", &wires, NULL)
        && wires == extrudedsurface->wires)
      pass ();
    else
      fail ("EXTRUDEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("EXTRUDEDSURFACE") || is_class_debugging ("EXTRUDEDSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "EXTRUDEDSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_FLIPGRIPENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_FLIPGRIPENTITY *restrict flipgripentity = obj->tio.entity->tio.FLIPGRIPENTITY;
  failed = 0;
  if (!obj_obj || !flipgripentity)
    {
      fail ("NULL FLIPGRIPENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (flipgripentity, "FLIPGRIPENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &flipgripentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("FLIPGRIPENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("FLIPGRIPENTITY") || is_class_debugging ("FLIPGRIPENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "FLIPGRIPENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_FLIPPARAMETERENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_FLIPPARAMETERENTITY *restrict flipparameterentity = obj->tio.entity->tio.FLIPPARAMETERENTITY;
  failed = 0;
  if (!obj_obj || !flipparameterentity)
    {
      fail ("NULL FLIPPARAMETERENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (flipparameterentity, "FLIPPARAMETERENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &flipparameterentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("FLIPPARAMETERENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("FLIPPARAMETERENTITY") || is_class_debugging ("FLIPPARAMETERENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "FLIPPARAMETERENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_GEOPOSITIONMARKER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_GEOPOSITIONMARKER *restrict geopositionmarker = obj->tio.entity->tio.GEOPOSITIONMARKER;
  failed = 0;
  if (!obj_obj || !geopositionmarker)
    {
      fail ("NULL GEOPOSITIONMARKER");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "class_version", &class_version, NULL)
        && class_version == geopositionmarker->class_version)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.class_version [BS] %hu != %hu", geopositionmarker->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "class_version", &class_version, 0)
        && class_version == geopositionmarker->class_version)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.class_version [BS] set+1 %hu != %hu", geopositionmarker->class_version, class_version);
    geopositionmarker->class_version--;
  }
  {
    BITCODE_B enable_frame_text;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "enable_frame_text", &enable_frame_text, NULL)
        && enable_frame_text == geopositionmarker->enable_frame_text)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.enable_frame_text [B] " FORMAT_B " != " FORMAT_B "", geopositionmarker->enable_frame_text, enable_frame_text);
    enable_frame_text++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "enable_frame_text", &enable_frame_text, 0)
        && enable_frame_text == geopositionmarker->enable_frame_text)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.enable_frame_text [B] set+1 " FORMAT_B " != " FORMAT_B "", geopositionmarker->enable_frame_text, enable_frame_text);
    geopositionmarker->enable_frame_text--;
  }
  {
    BITCODE_BD landing_gap;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "landing_gap", &landing_gap, NULL)
        && landing_gap == geopositionmarker->landing_gap)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.landing_gap [BD] %g != %g", geopositionmarker->landing_gap, landing_gap);
    landing_gap++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "landing_gap", &landing_gap, 0)
        && landing_gap == geopositionmarker->landing_gap)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.landing_gap [BD] set+1 %g != %g", geopositionmarker->landing_gap, landing_gap);
    geopositionmarker->landing_gap--;
  }
  {
    struct _dwg_object* mtext;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "num_mtext", &count, NULL)
        && dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "mtext", &mtext, NULL)
        && mtext == geopositionmarker->mtext)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.mtext [struct _dwg_object*] * %u num_mtext", count);
  }
  {
    BITCODE_B mtext_visible;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "mtext_visible", &mtext_visible, NULL)
        && mtext_visible == geopositionmarker->mtext_visible)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.mtext_visible [B] " FORMAT_B " != " FORMAT_B "", geopositionmarker->mtext_visible, mtext_visible);
    mtext_visible++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "mtext_visible", &mtext_visible, 0)
        && mtext_visible == geopositionmarker->mtext_visible)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.mtext_visible [B] set+1 " FORMAT_B " != " FORMAT_B "", geopositionmarker->mtext_visible, mtext_visible);
    geopositionmarker->mtext_visible--;
  }
  {
    BITCODE_T notes;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "notes", &notes, NULL)
        && notes
           ? strEQ ((char *)notes, (char *)geopositionmarker->notes)
           : !geopositionmarker->notes)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.notes [T] '%s' <> '%s'", notes, geopositionmarker->notes);
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "parent", &parent, NULL)
        && !memcmp (&parent, &geopositionmarker->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("GEOPOSITIONMARKER.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD position;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "position", &position, NULL)
        && !memcmp (&position, &geopositionmarker->position, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEOPOSITIONMARKER.position [3BD]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "radius", &radius, NULL)
        && radius == geopositionmarker->radius)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.radius [BD] %g != %g", geopositionmarker->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "radius", &radius, 0)
        && radius == geopositionmarker->radius)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.radius [BD] set+1 %g != %g", geopositionmarker->radius, radius);
    geopositionmarker->radius--;
  }
  {
    BITCODE_RC text_alignment;
    if (dwg_dynapi_entity_value (geopositionmarker, "GEOPOSITIONMARKER", "text_alignment", &text_alignment, NULL)
        && text_alignment == geopositionmarker->text_alignment)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.text_alignment [RC] %u != %u", geopositionmarker->text_alignment, text_alignment);
    text_alignment++;
    if (dwg_dynapi_entity_set_value (geopositionmarker, "GEOPOSITIONMARKER", "text_alignment", &text_alignment, 0)
        && text_alignment == geopositionmarker->text_alignment)
      pass ();
    else
      fail ("GEOPOSITIONMARKER.text_alignment [RC] set+1 %u != %u", geopositionmarker->text_alignment, text_alignment);
    geopositionmarker->text_alignment--;
  }
  if (failed && (is_class_unstable ("GEOPOSITIONMARKER") || is_class_debugging ("GEOPOSITIONMARKER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GEOPOSITIONMARKER", failed);
      failed = 0;
    }
  return failed;
}
static int test_HATCH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_HATCH *restrict hatch = obj->tio.entity->tio.HATCH;
  failed = 0;
  if (!obj_obj || !hatch)
    {
      fail ("NULL HATCH");
      return 1;
    }
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "angle", &angle, NULL)
        && angle == hatch->angle)
      pass ();
    else
      fail ("HATCH.angle [BD] %g != %g", hatch->angle, angle);
    angle++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "angle", &angle, 0)
        && angle == hatch->angle)
      pass ();
    else
      fail ("HATCH.angle [BD] set+1 %g != %g", hatch->angle, angle);
    hatch->angle--;
  }
  {
    Dwg_HATCH_Color* colors;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_colors", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "colors", &colors, NULL)
        && colors == hatch->colors)
      pass ();
    else
      fail ("HATCH.colors [Dwg_HATCH_Color*] * %u num_colors", count);
  }
  {
    Dwg_HATCH_DefLine* deflines;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_deflines", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "deflines", &deflines, NULL)
        && deflines == hatch->deflines)
      pass ();
    else
      fail ("HATCH.deflines [Dwg_HATCH_DefLine*] * %u num_deflines", count);
  }
  {
    BITCODE_B double_flag;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "double_flag", &double_flag, NULL)
        && double_flag == hatch->double_flag)
      pass ();
    else
      fail ("HATCH.double_flag [B] " FORMAT_B " != " FORMAT_B "", hatch->double_flag, double_flag);
    double_flag++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "double_flag", &double_flag, 0)
        && double_flag == hatch->double_flag)
      pass ();
    else
      fail ("HATCH.double_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->double_flag, double_flag);
    hatch->double_flag--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "elevation", &elevation, NULL)
        && elevation == hatch->elevation)
      pass ();
    else
      fail ("HATCH.elevation [BD] %g != %g", hatch->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "elevation", &elevation, 0)
        && elevation == hatch->elevation)
      pass ();
    else
      fail ("HATCH.elevation [BD] set+1 %g != %g", hatch->elevation, elevation);
    hatch->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &hatch->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("HATCH.extrusion [BE]");
  }
  {
    BITCODE_BD gradient_angle;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "gradient_angle", &gradient_angle, NULL)
        && gradient_angle == hatch->gradient_angle)
      pass ();
    else
      fail ("HATCH.gradient_angle [BD] %g != %g", hatch->gradient_angle, gradient_angle);
    gradient_angle++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "gradient_angle", &gradient_angle, 0)
        && gradient_angle == hatch->gradient_angle)
      pass ();
    else
      fail ("HATCH.gradient_angle [BD] set+1 %g != %g", hatch->gradient_angle, gradient_angle);
    hatch->gradient_angle--;
  }
  {
    BITCODE_T gradient_name;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "gradient_name", &gradient_name, NULL)
        && gradient_name
           ? strEQ ((char *)gradient_name, (char *)hatch->gradient_name)
           : !hatch->gradient_name)
      pass ();
    else
      fail ("HATCH.gradient_name [T] '%s' <> '%s'", gradient_name, hatch->gradient_name);
  }
  {
    BITCODE_BD gradient_shift;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "gradient_shift", &gradient_shift, NULL)
        && gradient_shift == hatch->gradient_shift)
      pass ();
    else
      fail ("HATCH.gradient_shift [BD] %g != %g", hatch->gradient_shift, gradient_shift);
    gradient_shift++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "gradient_shift", &gradient_shift, 0)
        && gradient_shift == hatch->gradient_shift)
      pass ();
    else
      fail ("HATCH.gradient_shift [BD] set+1 %g != %g", hatch->gradient_shift, gradient_shift);
    hatch->gradient_shift--;
  }
  {
    BITCODE_BD gradient_tint;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "gradient_tint", &gradient_tint, NULL)
        && gradient_tint == hatch->gradient_tint)
      pass ();
    else
      fail ("HATCH.gradient_tint [BD] %g != %g", hatch->gradient_tint, gradient_tint);
    gradient_tint++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "gradient_tint", &gradient_tint, 0)
        && gradient_tint == hatch->gradient_tint)
      pass ();
    else
      fail ("HATCH.gradient_tint [BD] set+1 %g != %g", hatch->gradient_tint, gradient_tint);
    hatch->gradient_tint--;
  }
  {
    BITCODE_B has_derived;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "has_derived", &has_derived, NULL)
        && has_derived == hatch->has_derived)
      pass ();
    else
      fail ("HATCH.has_derived [B] " FORMAT_B " != " FORMAT_B "", hatch->has_derived, has_derived);
    has_derived++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "has_derived", &has_derived, 0)
        && has_derived == hatch->has_derived)
      pass ();
    else
      fail ("HATCH.has_derived [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->has_derived, has_derived);
    hatch->has_derived--;
  }
  {
    BITCODE_B is_associative;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "is_associative", &is_associative, NULL)
        && is_associative == hatch->is_associative)
      pass ();
    else
      fail ("HATCH.is_associative [B] " FORMAT_B " != " FORMAT_B "", hatch->is_associative, is_associative);
    is_associative++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "is_associative", &is_associative, 0)
        && is_associative == hatch->is_associative)
      pass ();
    else
      fail ("HATCH.is_associative [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->is_associative, is_associative);
    hatch->is_associative--;
  }
  {
    BITCODE_BL is_gradient_fill;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "is_gradient_fill", &is_gradient_fill, NULL)
        && is_gradient_fill == hatch->is_gradient_fill)
      pass ();
    else
      fail ("HATCH.is_gradient_fill [BL] %u != %u", hatch->is_gradient_fill, is_gradient_fill);
    is_gradient_fill++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "is_gradient_fill", &is_gradient_fill, 0)
        && is_gradient_fill == hatch->is_gradient_fill)
      pass ();
    else
      fail ("HATCH.is_gradient_fill [BL] set+1 %u != %u", hatch->is_gradient_fill, is_gradient_fill);
    hatch->is_gradient_fill--;
  }
  {
    BITCODE_B is_solid_fill;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "is_solid_fill", &is_solid_fill, NULL)
        && is_solid_fill == hatch->is_solid_fill)
      pass ();
    else
      fail ("HATCH.is_solid_fill [B] " FORMAT_B " != " FORMAT_B "", hatch->is_solid_fill, is_solid_fill);
    is_solid_fill++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "is_solid_fill", &is_solid_fill, 0)
        && is_solid_fill == hatch->is_solid_fill)
      pass ();
    else
      fail ("HATCH.is_solid_fill [B] set+1 " FORMAT_B " != " FORMAT_B "", hatch->is_solid_fill, is_solid_fill);
    hatch->is_solid_fill--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)hatch->name)
           : !hatch->name)
      pass ();
    else
      fail ("HATCH.name [T] '%s' <> '%s'", name, hatch->name);
  }
  {
    BITCODE_BL num_colors;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_colors", &num_colors, NULL)
        && num_colors == hatch->num_colors)
      pass ();
    else
      fail ("HATCH.num_colors [BL] %u != %u", hatch->num_colors, num_colors);
    num_colors++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_colors", &num_colors, 0)
        && num_colors == hatch->num_colors)
      pass ();
    else
      fail ("HATCH.num_colors [BL] set+1 %u != %u", hatch->num_colors, num_colors);
    hatch->num_colors--;
  }
  {
    BITCODE_BS num_deflines;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_deflines", &num_deflines, NULL)
        && num_deflines == hatch->num_deflines)
      pass ();
    else
      fail ("HATCH.num_deflines [BS] %hu != %hu", hatch->num_deflines, num_deflines);
    num_deflines++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_deflines", &num_deflines, 0)
        && num_deflines == hatch->num_deflines)
      pass ();
    else
      fail ("HATCH.num_deflines [BS] set+1 %hu != %hu", hatch->num_deflines, num_deflines);
    hatch->num_deflines--;
  }
  {
    BITCODE_BL num_paths;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_paths", &num_paths, NULL)
        && num_paths == hatch->num_paths)
      pass ();
    else
      fail ("HATCH.num_paths [BL] %u != %u", hatch->num_paths, num_paths);
    num_paths++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_paths", &num_paths, 0)
        && num_paths == hatch->num_paths)
      pass ();
    else
      fail ("HATCH.num_paths [BL] set+1 %u != %u", hatch->num_paths, num_paths);
    hatch->num_paths--;
  }
  {
    BITCODE_BL num_seeds;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_seeds", &num_seeds, NULL)
        && num_seeds == hatch->num_seeds)
      pass ();
    else
      fail ("HATCH.num_seeds [BL] %u != %u", hatch->num_seeds, num_seeds);
    num_seeds++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "num_seeds", &num_seeds, 0)
        && num_seeds == hatch->num_seeds)
      pass ();
    else
      fail ("HATCH.num_seeds [BL] set+1 %u != %u", hatch->num_seeds, num_seeds);
    hatch->num_seeds--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "parent", &parent, NULL)
        && !memcmp (&parent, &hatch->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("HATCH.parent [struct _dwg_object_entity*]");
  }
  {
    Dwg_HATCH_Path* paths;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_paths", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "paths", &paths, NULL)
        && paths == hatch->paths)
      pass ();
    else
      fail ("HATCH.paths [Dwg_HATCH_Path*] * %u num_paths", count);
  }
  {
    BITCODE_BS pattern_type;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "pattern_type", &pattern_type, NULL)
        && pattern_type == hatch->pattern_type)
      pass ();
    else
      fail ("HATCH.pattern_type [BS] %hu != %hu", hatch->pattern_type, pattern_type);
    pattern_type++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "pattern_type", &pattern_type, 0)
        && pattern_type == hatch->pattern_type)
      pass ();
    else
      fail ("HATCH.pattern_type [BS] set+1 %hu != %hu", hatch->pattern_type, pattern_type);
    hatch->pattern_type--;
  }
  {
    BITCODE_BD pixel_size;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "pixel_size", &pixel_size, NULL)
        && pixel_size == hatch->pixel_size)
      pass ();
    else
      fail ("HATCH.pixel_size [BD] %g != %g", hatch->pixel_size, pixel_size);
    pixel_size++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "pixel_size", &pixel_size, 0)
        && pixel_size == hatch->pixel_size)
      pass ();
    else
      fail ("HATCH.pixel_size [BD] set+1 %g != %g", hatch->pixel_size, pixel_size);
    hatch->pixel_size--;
  }
  {
    BITCODE_BL reserved;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "reserved", &reserved, NULL)
        && reserved == hatch->reserved)
      pass ();
    else
      fail ("HATCH.reserved [BL] %u != %u", hatch->reserved, reserved);
    reserved++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "reserved", &reserved, 0)
        && reserved == hatch->reserved)
      pass ();
    else
      fail ("HATCH.reserved [BL] set+1 %u != %u", hatch->reserved, reserved);
    hatch->reserved--;
  }
  {
    BITCODE_BD scale_spacing;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "scale_spacing", &scale_spacing, NULL)
        && scale_spacing == hatch->scale_spacing)
      pass ();
    else
      fail ("HATCH.scale_spacing [BD] %g != %g", hatch->scale_spacing, scale_spacing);
    scale_spacing++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "scale_spacing", &scale_spacing, 0)
        && scale_spacing == hatch->scale_spacing)
      pass ();
    else
      fail ("HATCH.scale_spacing [BD] set+1 %g != %g", hatch->scale_spacing, scale_spacing);
    hatch->scale_spacing--;
  }
  {
    BITCODE_2RD* seeds;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "num_seeds", &count, NULL)
        && dwg_dynapi_entity_value (hatch, "HATCH", "seeds", &seeds, NULL)
        && seeds == hatch->seeds)
      pass ();
    else
      fail ("HATCH.seeds [2RD*] * %u num_seeds", count);
  }
  {
    BITCODE_BL single_color_gradient;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "single_color_gradient", &single_color_gradient, NULL)
        && single_color_gradient == hatch->single_color_gradient)
      pass ();
    else
      fail ("HATCH.single_color_gradient [BL] %u != %u", hatch->single_color_gradient, single_color_gradient);
    single_color_gradient++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "single_color_gradient", &single_color_gradient, 0)
        && single_color_gradient == hatch->single_color_gradient)
      pass ();
    else
      fail ("HATCH.single_color_gradient [BL] set+1 %u != %u", hatch->single_color_gradient, single_color_gradient);
    hatch->single_color_gradient--;
  }
  {
    BITCODE_BS style;
    if (dwg_dynapi_entity_value (hatch, "HATCH", "style", &style, NULL)
        && style == hatch->style)
      pass ();
    else
      fail ("HATCH.style [BS] %hu != %hu", hatch->style, style);
    style++;
    if (dwg_dynapi_entity_set_value (hatch, "HATCH", "style", &style, 0)
        && style == hatch->style)
      pass ();
    else
      fail ("HATCH.style [BS] set+1 %hu != %hu", hatch->style, style);
    hatch->style--;
  }
  if (failed && (is_class_unstable ("HATCH") || is_class_debugging ("HATCH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "HATCH", failed);
      failed = 0;
    }
  return failed;
}
static int test_HELIX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_HELIX *restrict helix = obj->tio.entity->tio.HELIX;
  failed = 0;
  if (!obj_obj || !helix)
    {
      fail ("NULL HELIX");
      return 1;
    }
  {
    BITCODE_3BD axis_base_pt;
    if (dwg_dynapi_entity_value (helix, "HELIX", "axis_base_pt", &axis_base_pt, NULL)
        && !memcmp (&axis_base_pt, &helix->axis_base_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("HELIX.axis_base_pt [3BD]");
  }
  {
    BITCODE_3BD axis_vector;
    if (dwg_dynapi_entity_value (helix, "HELIX", "axis_vector", &axis_vector, NULL)
        && !memcmp (&axis_vector, &helix->axis_vector, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("HELIX.axis_vector [3BD]");
  }
  {
    BITCODE_3BD beg_tan_vec;
    if (dwg_dynapi_entity_value (helix, "HELIX", "beg_tan_vec", &beg_tan_vec, NULL)
        && !memcmp (&beg_tan_vec, &helix->beg_tan_vec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("HELIX.beg_tan_vec [3BD]");
  }
  {
    BITCODE_B closed_b;
    if (dwg_dynapi_entity_value (helix, "HELIX", "closed_b", &closed_b, NULL)
        && closed_b == helix->closed_b)
      pass ();
    else
      fail ("HELIX.closed_b [B] " FORMAT_B " != " FORMAT_B "", helix->closed_b, closed_b);
    closed_b++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "closed_b", &closed_b, 0)
        && closed_b == helix->closed_b)
      pass ();
    else
      fail ("HELIX.closed_b [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->closed_b, closed_b);
    helix->closed_b--;
  }
  {
    BITCODE_RC constraint_type;
    if (dwg_dynapi_entity_value (helix, "HELIX", "constraint_type", &constraint_type, NULL)
        && constraint_type == helix->constraint_type)
      pass ();
    else
      fail ("HELIX.constraint_type [RC] %u != %u", helix->constraint_type, constraint_type);
    constraint_type++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "constraint_type", &constraint_type, 0)
        && constraint_type == helix->constraint_type)
      pass ();
    else
      fail ("HELIX.constraint_type [RC] set+1 %u != %u", helix->constraint_type, constraint_type);
    helix->constraint_type--;
  }
  {
    Dwg_SPLINE_control_point* ctrl_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_ctrl_pts", &count, NULL)
        && dwg_dynapi_entity_value (helix, "HELIX", "ctrl_pts", &ctrl_pts, NULL)
        && ctrl_pts == helix->ctrl_pts)
      pass ();
    else
      fail ("HELIX.ctrl_pts [Dwg_SPLINE_control_point*] * %u num_ctrl_pts", count);
  }
  {
    BITCODE_BD ctrl_tol;
    if (dwg_dynapi_entity_value (helix, "HELIX", "ctrl_tol", &ctrl_tol, NULL)
        && ctrl_tol == helix->ctrl_tol)
      pass ();
    else
      fail ("HELIX.ctrl_tol [BD] %g != %g", helix->ctrl_tol, ctrl_tol);
    ctrl_tol++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "ctrl_tol", &ctrl_tol, 0)
        && ctrl_tol == helix->ctrl_tol)
      pass ();
    else
      fail ("HELIX.ctrl_tol [BD] set+1 %g != %g", helix->ctrl_tol, ctrl_tol);
    helix->ctrl_tol--;
  }
  {
    BITCODE_BS degree;
    if (dwg_dynapi_entity_value (helix, "HELIX", "degree", &degree, NULL)
        && degree == helix->degree)
      pass ();
    else
      fail ("HELIX.degree [BS] %hu != %hu", helix->degree, degree);
    degree++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "degree", &degree, 0)
        && degree == helix->degree)
      pass ();
    else
      fail ("HELIX.degree [BS] set+1 %hu != %hu", helix->degree, degree);
    helix->degree--;
  }
  {
    BITCODE_3BD end_tan_vec;
    if (dwg_dynapi_entity_value (helix, "HELIX", "end_tan_vec", &end_tan_vec, NULL)
        && !memcmp (&end_tan_vec, &helix->end_tan_vec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("HELIX.end_tan_vec [3BD]");
  }
  {
    BITCODE_3DPOINT* fit_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_fit_pts", &count, NULL)
        && dwg_dynapi_entity_value (helix, "HELIX", "fit_pts", &fit_pts, NULL)
        && fit_pts == helix->fit_pts)
      pass ();
    else
      fail ("HELIX.fit_pts [3DPOINT*] * %u num_fit_pts", count);
  }
  {
    BITCODE_BD fit_tol;
    if (dwg_dynapi_entity_value (helix, "HELIX", "fit_tol", &fit_tol, NULL)
        && fit_tol == helix->fit_tol)
      pass ();
    else
      fail ("HELIX.fit_tol [BD] %g != %g", helix->fit_tol, fit_tol);
    fit_tol++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "fit_tol", &fit_tol, 0)
        && fit_tol == helix->fit_tol)
      pass ();
    else
      fail ("HELIX.fit_tol [BD] set+1 %g != %g", helix->fit_tol, fit_tol);
    helix->fit_tol--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (helix, "HELIX", "flag", &flag, NULL)
        && flag == helix->flag)
      pass ();
    else
      fail ("HELIX.flag [BS] %hu != %hu", helix->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "flag", &flag, 0)
        && flag == helix->flag)
      pass ();
    else
      fail ("HELIX.flag [BS] set+1 %hu != %hu", helix->flag, flag);
    helix->flag--;
  }
  {
    BITCODE_B handedness;
    if (dwg_dynapi_entity_value (helix, "HELIX", "handedness", &handedness, NULL)
        && handedness == helix->handedness)
      pass ();
    else
      fail ("HELIX.handedness [B] " FORMAT_B " != " FORMAT_B "", helix->handedness, handedness);
    handedness++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "handedness", &handedness, 0)
        && handedness == helix->handedness)
      pass ();
    else
      fail ("HELIX.handedness [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->handedness, handedness);
    helix->handedness--;
  }
  {
    BITCODE_BD knot_tol;
    if (dwg_dynapi_entity_value (helix, "HELIX", "knot_tol", &knot_tol, NULL)
        && knot_tol == helix->knot_tol)
      pass ();
    else
      fail ("HELIX.knot_tol [BD] %g != %g", helix->knot_tol, knot_tol);
    knot_tol++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "knot_tol", &knot_tol, 0)
        && knot_tol == helix->knot_tol)
      pass ();
    else
      fail ("HELIX.knot_tol [BD] set+1 %g != %g", helix->knot_tol, knot_tol);
    helix->knot_tol--;
  }
  {
    BITCODE_BL knotparam;
    if (dwg_dynapi_entity_value (helix, "HELIX", "knotparam", &knotparam, NULL)
        && knotparam == helix->knotparam)
      pass ();
    else
      fail ("HELIX.knotparam [BL] %u != %u", helix->knotparam, knotparam);
    knotparam++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "knotparam", &knotparam, 0)
        && knotparam == helix->knotparam)
      pass ();
    else
      fail ("HELIX.knotparam [BL] set+1 %u != %u", helix->knotparam, knotparam);
    helix->knotparam--;
  }
  {
    BITCODE_BD* knots;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_knots", &count, NULL)
        && dwg_dynapi_entity_value (helix, "HELIX", "knots", &knots, NULL)
        && knots == helix->knots)
      pass ();
    else
      fail ("HELIX.knots [BD*] * %u num_knots", count);
  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value (helix, "HELIX", "maint_version", &maint_version, NULL)
        && maint_version == helix->maint_version)
      pass ();
    else
      fail ("HELIX.maint_version [BL] %u != %u", helix->maint_version, maint_version);
    maint_version++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "maint_version", &maint_version, 0)
        && maint_version == helix->maint_version)
      pass ();
    else
      fail ("HELIX.maint_version [BL] set+1 %u != %u", helix->maint_version, maint_version);
    helix->maint_version--;
  }
  {
    BITCODE_BL major_version;
    if (dwg_dynapi_entity_value (helix, "HELIX", "major_version", &major_version, NULL)
        && major_version == helix->major_version)
      pass ();
    else
      fail ("HELIX.major_version [BL] %u != %u", helix->major_version, major_version);
    major_version++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "major_version", &major_version, 0)
        && major_version == helix->major_version)
      pass ();
    else
      fail ("HELIX.major_version [BL] set+1 %u != %u", helix->major_version, major_version);
    helix->major_version--;
  }
  {
    BITCODE_BL num_ctrl_pts;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_ctrl_pts", &num_ctrl_pts, NULL)
        && num_ctrl_pts == helix->num_ctrl_pts)
      pass ();
    else
      fail ("HELIX.num_ctrl_pts [BL] %u != %u", helix->num_ctrl_pts, num_ctrl_pts);
    num_ctrl_pts++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "num_ctrl_pts", &num_ctrl_pts, 0)
        && num_ctrl_pts == helix->num_ctrl_pts)
      pass ();
    else
      fail ("HELIX.num_ctrl_pts [BL] set+1 %u != %u", helix->num_ctrl_pts, num_ctrl_pts);
    helix->num_ctrl_pts--;
  }
  {
    BITCODE_BS num_fit_pts;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_fit_pts", &num_fit_pts, NULL)
        && num_fit_pts == helix->num_fit_pts)
      pass ();
    else
      fail ("HELIX.num_fit_pts [BS] %hu != %hu", helix->num_fit_pts, num_fit_pts);
    num_fit_pts++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "num_fit_pts", &num_fit_pts, 0)
        && num_fit_pts == helix->num_fit_pts)
      pass ();
    else
      fail ("HELIX.num_fit_pts [BS] set+1 %hu != %hu", helix->num_fit_pts, num_fit_pts);
    helix->num_fit_pts--;
  }
  {
    BITCODE_BL num_knots;
    if (dwg_dynapi_entity_value (helix, "HELIX", "num_knots", &num_knots, NULL)
        && num_knots == helix->num_knots)
      pass ();
    else
      fail ("HELIX.num_knots [BL] %u != %u", helix->num_knots, num_knots);
    num_knots++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "num_knots", &num_knots, 0)
        && num_knots == helix->num_knots)
      pass ();
    else
      fail ("HELIX.num_knots [BL] set+1 %u != %u", helix->num_knots, num_knots);
    helix->num_knots--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (helix, "HELIX", "parent", &parent, NULL)
        && !memcmp (&parent, &helix->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("HELIX.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_B periodic;
    if (dwg_dynapi_entity_value (helix, "HELIX", "periodic", &periodic, NULL)
        && periodic == helix->periodic)
      pass ();
    else
      fail ("HELIX.periodic [B] " FORMAT_B " != " FORMAT_B "", helix->periodic, periodic);
    periodic++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "periodic", &periodic, 0)
        && periodic == helix->periodic)
      pass ();
    else
      fail ("HELIX.periodic [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->periodic, periodic);
    helix->periodic--;
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (helix, "HELIX", "radius", &radius, NULL)
        && radius == helix->radius)
      pass ();
    else
      fail ("HELIX.radius [BD] %g != %g", helix->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "radius", &radius, 0)
        && radius == helix->radius)
      pass ();
    else
      fail ("HELIX.radius [BD] set+1 %g != %g", helix->radius, radius);
    helix->radius--;
  }
  {
    BITCODE_B rational;
    if (dwg_dynapi_entity_value (helix, "HELIX", "rational", &rational, NULL)
        && rational == helix->rational)
      pass ();
    else
      fail ("HELIX.rational [B] " FORMAT_B " != " FORMAT_B "", helix->rational, rational);
    rational++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "rational", &rational, 0)
        && rational == helix->rational)
      pass ();
    else
      fail ("HELIX.rational [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->rational, rational);
    helix->rational--;
  }
  {
    BITCODE_BS scenario;
    if (dwg_dynapi_entity_value (helix, "HELIX", "scenario", &scenario, NULL)
        && scenario == helix->scenario)
      pass ();
    else
      fail ("HELIX.scenario [BS] %hu != %hu", helix->scenario, scenario);
    scenario++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "scenario", &scenario, 0)
        && scenario == helix->scenario)
      pass ();
    else
      fail ("HELIX.scenario [BS] set+1 %hu != %hu", helix->scenario, scenario);
    helix->scenario--;
  }
  {
    BITCODE_BL splineflags;
    if (dwg_dynapi_entity_value (helix, "HELIX", "splineflags", &splineflags, NULL)
        && splineflags == helix->splineflags)
      pass ();
    else
      fail ("HELIX.splineflags [BL] %u != %u", helix->splineflags, splineflags);
    splineflags++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "splineflags", &splineflags, 0)
        && splineflags == helix->splineflags)
      pass ();
    else
      fail ("HELIX.splineflags [BL] set+1 %u != %u", helix->splineflags, splineflags);
    helix->splineflags--;
  }
  {
    BITCODE_3BD start_pt;
    if (dwg_dynapi_entity_value (helix, "HELIX", "start_pt", &start_pt, NULL)
        && !memcmp (&start_pt, &helix->start_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("HELIX.start_pt [3BD]");
  }
  {
    BITCODE_BD turn_height;
    if (dwg_dynapi_entity_value (helix, "HELIX", "turn_height", &turn_height, NULL)
        && turn_height == helix->turn_height)
      pass ();
    else
      fail ("HELIX.turn_height [BD] %g != %g", helix->turn_height, turn_height);
    turn_height++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "turn_height", &turn_height, 0)
        && turn_height == helix->turn_height)
      pass ();
    else
      fail ("HELIX.turn_height [BD] set+1 %g != %g", helix->turn_height, turn_height);
    helix->turn_height--;
  }
  {
    BITCODE_BD turns;
    if (dwg_dynapi_entity_value (helix, "HELIX", "turns", &turns, NULL)
        && turns == helix->turns)
      pass ();
    else
      fail ("HELIX.turns [BD] %g != %g", helix->turns, turns);
    turns++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "turns", &turns, 0)
        && turns == helix->turns)
      pass ();
    else
      fail ("HELIX.turns [BD] set+1 %g != %g", helix->turns, turns);
    helix->turns--;
  }
  {
    BITCODE_B weighted;
    if (dwg_dynapi_entity_value (helix, "HELIX", "weighted", &weighted, NULL)
        && weighted == helix->weighted)
      pass ();
    else
      fail ("HELIX.weighted [B] " FORMAT_B " != " FORMAT_B "", helix->weighted, weighted);
    weighted++;
    if (dwg_dynapi_entity_set_value (helix, "HELIX", "weighted", &weighted, 0)
        && weighted == helix->weighted)
      pass ();
    else
      fail ("HELIX.weighted [B] set+1 " FORMAT_B " != " FORMAT_B "", helix->weighted, weighted);
    helix->weighted--;
  }
  if (failed && (is_class_unstable ("HELIX") || is_class_debugging ("HELIX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "HELIX", failed);
      failed = 0;
    }
  return failed;
}
static int test_IMAGE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_IMAGE *restrict image = obj->tio.entity->tio.IMAGE;
  failed = 0;
  if (!obj_obj || !image)
    {
      fail ("NULL IMAGE");
      return 1;
    }
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value (image, "IMAGE", "brightness", &brightness, NULL)
        && brightness == image->brightness)
      pass ();
    else
      fail ("IMAGE.brightness [RC] %u != %u", image->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "brightness", &brightness, 0)
        && brightness == image->brightness)
      pass ();
    else
      fail ("IMAGE.brightness [RC] set+1 %u != %u", image->brightness, brightness);
    image->brightness--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (image, "IMAGE", "class_version", &class_version, NULL)
        && class_version == image->class_version)
      pass ();
    else
      fail ("IMAGE.class_version [BL] %u != %u", image->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "class_version", &class_version, 0)
        && class_version == image->class_version)
      pass ();
    else
      fail ("IMAGE.class_version [BL] set+1 %u != %u", image->class_version, class_version);
    image->class_version--;
  }
  {
    BITCODE_BS clip_boundary_type;
    if (dwg_dynapi_entity_value (image, "IMAGE", "clip_boundary_type", &clip_boundary_type, NULL)
        && clip_boundary_type == image->clip_boundary_type)
      pass ();
    else
      fail ("IMAGE.clip_boundary_type [BS] %hu != %hu", image->clip_boundary_type, clip_boundary_type);
    clip_boundary_type++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "clip_boundary_type", &clip_boundary_type, 0)
        && clip_boundary_type == image->clip_boundary_type)
      pass ();
    else
      fail ("IMAGE.clip_boundary_type [BS] set+1 %hu != %hu", image->clip_boundary_type, clip_boundary_type);
    image->clip_boundary_type--;
  }
  {
    BITCODE_B clip_mode;
    if (dwg_dynapi_entity_value (image, "IMAGE", "clip_mode", &clip_mode, NULL)
        && clip_mode == image->clip_mode)
      pass ();
    else
      fail ("IMAGE.clip_mode [B] " FORMAT_B " != " FORMAT_B "", image->clip_mode, clip_mode);
    clip_mode++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "clip_mode", &clip_mode, 0)
        && clip_mode == image->clip_mode)
      pass ();
    else
      fail ("IMAGE.clip_mode [B] set+1 " FORMAT_B " != " FORMAT_B "", image->clip_mode, clip_mode);
    image->clip_mode--;
  }
  {
    BITCODE_2RD* clip_verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (image, "IMAGE", "num_clip_verts", &count, NULL)
        && dwg_dynapi_entity_value (image, "IMAGE", "clip_verts", &clip_verts, NULL)
        && clip_verts == image->clip_verts)
      pass ();
    else
      fail ("IMAGE.clip_verts [2RD*] * %u num_clip_verts", count);
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value (image, "IMAGE", "clipping", &clipping, NULL)
        && clipping == image->clipping)
      pass ();
    else
      fail ("IMAGE.clipping [B] " FORMAT_B " != " FORMAT_B "", image->clipping, clipping);
    clipping++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "clipping", &clipping, 0)
        && clipping == image->clipping)
      pass ();
    else
      fail ("IMAGE.clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", image->clipping, clipping);
    image->clipping--;
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value (image, "IMAGE", "contrast", &contrast, NULL)
        && contrast == image->contrast)
      pass ();
    else
      fail ("IMAGE.contrast [RC] %u != %u", image->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "contrast", &contrast, 0)
        && contrast == image->contrast)
      pass ();
    else
      fail ("IMAGE.contrast [RC] set+1 %u != %u", image->contrast, contrast);
    image->contrast--;
  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value (image, "IMAGE", "display_props", &display_props, NULL)
        && display_props == image->display_props)
      pass ();
    else
      fail ("IMAGE.display_props [BS] %hu != %hu", image->display_props, display_props);
    display_props++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "display_props", &display_props, 0)
        && display_props == image->display_props)
      pass ();
    else
      fail ("IMAGE.display_props [BS] set+1 %hu != %hu", image->display_props, display_props);
    image->display_props--;
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value (image, "IMAGE", "fade", &fade, NULL)
        && fade == image->fade)
      pass ();
    else
      fail ("IMAGE.fade [RC] %u != %u", image->fade, fade);
    fade++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "fade", &fade, 0)
        && fade == image->fade)
      pass ();
    else
      fail ("IMAGE.fade [RC] set+1 %u != %u", image->fade, fade);
    image->fade--;
  }
  {
    BITCODE_H imagedef;
    if (dwg_dynapi_entity_value (image, "IMAGE", "imagedef", &imagedef, NULL)
        && !memcmp (&imagedef, &image->imagedef, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("IMAGE.imagedef [H]");
  }
  {
    BITCODE_H imagedefreactor;
    if (dwg_dynapi_entity_value (image, "IMAGE", "imagedefreactor", &imagedefreactor, NULL)
        && !memcmp (&imagedefreactor, &image->imagedefreactor, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("IMAGE.imagedefreactor [H]");
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value (image, "IMAGE", "num_clip_verts", &num_clip_verts, NULL)
        && num_clip_verts == image->num_clip_verts)
      pass ();
    else
      fail ("IMAGE.num_clip_verts [BL] %u != %u", image->num_clip_verts, num_clip_verts);
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value (image, "IMAGE", "num_clip_verts", &num_clip_verts, 0)
        && num_clip_verts == image->num_clip_verts)
      pass ();
    else
      fail ("IMAGE.num_clip_verts [BL] set+1 %u != %u", image->num_clip_verts, num_clip_verts);
    image->num_clip_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (image, "IMAGE", "parent", &parent, NULL)
        && !memcmp (&parent, &image->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("IMAGE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value (image, "IMAGE", "pt0", &pt0, NULL)
        && !memcmp (&pt0, &image->pt0, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("IMAGE.pt0 [3BD]");
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value (image, "IMAGE", "size", &size, NULL)
        && !memcmp (&size, &image->size, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("IMAGE.size [2RD]");
  }
  {
    BITCODE_3BD uvec;
    if (dwg_dynapi_entity_value (image, "IMAGE", "uvec", &uvec, NULL)
        && !memcmp (&uvec, &image->uvec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("IMAGE.uvec [3BD]");
  }
  {
    BITCODE_3BD vvec;
    if (dwg_dynapi_entity_value (image, "IMAGE", "vvec", &vvec, NULL)
        && !memcmp (&vvec, &image->vvec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("IMAGE.vvec [3BD]");
  }
  if (failed && (is_class_unstable ("IMAGE") || is_class_debugging ("IMAGE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IMAGE", failed);
      failed = 0;
    }
  return failed;
}
static int test_INSERT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_INSERT *restrict insert = obj->tio.entity->tio.INSERT;
  failed = 0;
  if (!obj_obj || !insert)
    {
      fail ("NULL INSERT");
      return 1;
    }
  {
    BITCODE_H* attribs;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (insert, "INSERT", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (insert, "INSERT", "attribs", &attribs, NULL)
        && attribs == insert->attribs)
      pass ();
    else
      fail ("INSERT.attribs [H*] * %u num_owned", count);
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value (insert, "INSERT", "block_header", &block_header, NULL)
        && !memcmp (&block_header, &insert->block_header, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("INSERT.block_header [H]");
  }
  {
    BITCODE_TV block_name;
    if (dwg_dynapi_entity_value (insert, "INSERT", "block_name", &block_name, NULL)
        && block_name
           ? strEQ ((char *)block_name, (char *)insert->block_name)
           : !insert->block_name)
      pass ();
    else
      fail ("INSERT.block_name [TV] '%s' <> '%s'", block_name, insert->block_name);
  }
  {
    BITCODE_RD col_spacing;
    if (dwg_dynapi_entity_value (insert, "INSERT", "col_spacing", &col_spacing, NULL)
        && col_spacing == insert->col_spacing)
      pass ();
    else
      fail ("INSERT.col_spacing [RD] %g != %g", insert->col_spacing, col_spacing);
    col_spacing++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "col_spacing", &col_spacing, 0)
        && col_spacing == insert->col_spacing)
      pass ();
    else
      fail ("INSERT.col_spacing [RD] set+1 %g != %g", insert->col_spacing, col_spacing);
    insert->col_spacing--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (insert, "INSERT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &insert->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("INSERT.extrusion [BE]");
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value (insert, "INSERT", "first_attrib", &first_attrib, NULL)
        && !memcmp (&first_attrib, &insert->first_attrib, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("INSERT.first_attrib [H]");
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value (insert, "INSERT", "has_attribs", &has_attribs, NULL)
        && has_attribs == insert->has_attribs)
      pass ();
    else
      fail ("INSERT.has_attribs [B] " FORMAT_B " != " FORMAT_B "", insert->has_attribs, has_attribs);
    has_attribs++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "has_attribs", &has_attribs, 0)
        && has_attribs == insert->has_attribs)
      pass ();
    else
      fail ("INSERT.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", insert->has_attribs, has_attribs);
    insert->has_attribs--;
  }
  {
    BITCODE_3DPOINT ins_pt;
    if (dwg_dynapi_entity_value (insert, "INSERT", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &insert->ins_pt, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("INSERT.ins_pt [3DPOINT]");
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value (insert, "INSERT", "last_attrib", &last_attrib, NULL)
        && !memcmp (&last_attrib, &insert->last_attrib, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("INSERT.last_attrib [H]");
  }
  {
    BITCODE_RS num_cols;
    if (dwg_dynapi_entity_value (insert, "INSERT", "num_cols", &num_cols, NULL)
        && num_cols == insert->num_cols)
      pass ();
    else
      fail ("INSERT.num_cols [RS] %hu != %hu", insert->num_cols, num_cols);
    num_cols++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "num_cols", &num_cols, 0)
        && num_cols == insert->num_cols)
      pass ();
    else
      fail ("INSERT.num_cols [RS] set+1 %hu != %hu", insert->num_cols, num_cols);
    insert->num_cols--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (insert, "INSERT", "num_owned", &num_owned, NULL)
        && num_owned == insert->num_owned)
      pass ();
    else
      fail ("INSERT.num_owned [BL] %u != %u", insert->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "num_owned", &num_owned, 0)
        && num_owned == insert->num_owned)
      pass ();
    else
      fail ("INSERT.num_owned [BL] set+1 %u != %u", insert->num_owned, num_owned);
    insert->num_owned--;
  }
  {
    BITCODE_RS num_rows;
    if (dwg_dynapi_entity_value (insert, "INSERT", "num_rows", &num_rows, NULL)
        && num_rows == insert->num_rows)
      pass ();
    else
      fail ("INSERT.num_rows [RS] %hu != %hu", insert->num_rows, num_rows);
    num_rows++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "num_rows", &num_rows, 0)
        && num_rows == insert->num_rows)
      pass ();
    else
      fail ("INSERT.num_rows [RS] set+1 %hu != %hu", insert->num_rows, num_rows);
    insert->num_rows--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (insert, "INSERT", "parent", &parent, NULL)
        && !memcmp (&parent, &insert->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("INSERT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (insert, "INSERT", "rotation", &rotation, NULL)
        && rotation == insert->rotation)
      pass ();
    else
      fail ("INSERT.rotation [BD] %g != %g", insert->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "rotation", &rotation, 0)
        && rotation == insert->rotation)
      pass ();
    else
      fail ("INSERT.rotation [BD] set+1 %g != %g", insert->rotation, rotation);
    insert->rotation--;
  }
  {
    BITCODE_RD row_spacing;
    if (dwg_dynapi_entity_value (insert, "INSERT", "row_spacing", &row_spacing, NULL)
        && row_spacing == insert->row_spacing)
      pass ();
    else
      fail ("INSERT.row_spacing [RD] %g != %g", insert->row_spacing, row_spacing);
    row_spacing++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "row_spacing", &row_spacing, 0)
        && row_spacing == insert->row_spacing)
      pass ();
    else
      fail ("INSERT.row_spacing [RD] set+1 %g != %g", insert->row_spacing, row_spacing);
    insert->row_spacing--;
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value (insert, "INSERT", "scale", &scale, NULL)
        && !memcmp (&scale, &insert->scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("INSERT.scale [3BD_1]");
  }
  {
    BITCODE_BB scale_flag;
    if (dwg_dynapi_entity_value (insert, "INSERT", "scale_flag", &scale_flag, NULL)
        && scale_flag == insert->scale_flag)
      pass ();
    else
      fail ("INSERT.scale_flag [BB] " FORMAT_BB " != " FORMAT_BB "", insert->scale_flag, scale_flag);
    scale_flag++;
    if (dwg_dynapi_entity_set_value (insert, "INSERT", "scale_flag", &scale_flag, 0)
        && scale_flag == insert->scale_flag)
      pass ();
    else
      fail ("INSERT.scale_flag [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", insert->scale_flag, scale_flag);
    insert->scale_flag--;
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (insert, "INSERT", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &insert->seqend, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("INSERT.seqend [H]");
  }
  if (failed && (is_class_unstable ("INSERT") || is_class_debugging ("INSERT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "INSERT", failed);
      failed = 0;
    }
  return failed;
}
static int test_JUMP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_JUMP *restrict jump = obj->tio.entity->tio.JUMP;
  failed = 0;
  if (!obj_obj || !jump)
    {
      fail ("NULL JUMP");
      return 1;
    }
  {
    BITCODE_RL jump_address;
    if (dwg_dynapi_entity_value (jump, "JUMP", "jump_address", &jump_address, NULL)
        && jump_address == jump->jump_address)
      pass ();
    else
      fail ("JUMP.jump_address [RL] %u != %u", jump->jump_address, jump_address);
    jump_address++;
    if (dwg_dynapi_entity_set_value (jump, "JUMP", "jump_address", &jump_address, 0)
        && jump_address == jump->jump_address)
      pass ();
    else
      fail ("JUMP.jump_address [RL] set+1 %u != %u", jump->jump_address, jump_address);
    jump->jump_address--;
  }
  {
    BITCODE_RL jump_address_raw;
    if (dwg_dynapi_entity_value (jump, "JUMP", "jump_address_raw", &jump_address_raw, NULL)
        && jump_address_raw == jump->jump_address_raw)
      pass ();
    else
      fail ("JUMP.jump_address_raw [RL] %u != %u", jump->jump_address_raw, jump_address_raw);
    jump_address_raw++;
    if (dwg_dynapi_entity_set_value (jump, "JUMP", "jump_address_raw", &jump_address_raw, 0)
        && jump_address_raw == jump->jump_address_raw)
      pass ();
    else
      fail ("JUMP.jump_address_raw [RL] set+1 %u != %u", jump->jump_address_raw, jump_address_raw);
    jump->jump_address_raw--;
  }
  {
    Dwg_Entity_Sections jump_entity_section;
    if (dwg_dynapi_entity_value (jump, "JUMP", "jump_entity_section", &jump_entity_section, NULL)
        && !memcmp (&jump_entity_section, &jump->jump_entity_section, sizeof (Dwg_Entity_Sections)))
        pass ();
    else
        fail ("JUMP.jump_entity_section [Dwg_Entity_Sections]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (jump, "JUMP", "parent", &parent, NULL)
        && !memcmp (&parent, &jump->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("JUMP.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("JUMP") || is_class_debugging ("JUMP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "JUMP", failed);
      failed = 0;
    }
  return failed;
}
static int test_LARGE_RADIAL_DIMENSION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LARGE_RADIAL_DIMENSION *restrict large_radial_dimension = obj->tio.entity->tio.LARGE_RADIAL_DIMENSION;
  failed = 0;
  if (!obj_obj || !large_radial_dimension)
    {
      fail ("NULL LARGE_RADIAL_DIMENSION");
      return 1;
    }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "act_measurement", &act_measurement, NULL)
        && act_measurement == large_radial_dimension->act_measurement)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.act_measurement [BD] %g != %g", large_radial_dimension->act_measurement, act_measurement);
    act_measurement++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "act_measurement", &act_measurement, 0)
        && act_measurement == large_radial_dimension->act_measurement)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.act_measurement [BD] set+1 %g != %g", large_radial_dimension->act_measurement, act_measurement);
    large_radial_dimension->act_measurement--;
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "attachment", &attachment, NULL)
        && attachment == large_radial_dimension->attachment)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.attachment [BS] %hu != %hu", large_radial_dimension->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "attachment", &attachment, 0)
        && attachment == large_radial_dimension->attachment)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.attachment [BS] set+1 %hu != %hu", large_radial_dimension->attachment, attachment);
    large_radial_dimension->attachment--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "block", &block, NULL)
        && !memcmp (&block, &large_radial_dimension->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.block [H]");
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "class_version", &class_version, NULL)
        && class_version == large_radial_dimension->class_version)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.class_version [RC] %u != %u", large_radial_dimension->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "class_version", &class_version, 0)
        && class_version == large_radial_dimension->class_version)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.class_version [RC] set+1 %u != %u", large_radial_dimension->class_version, class_version);
    large_radial_dimension->class_version--;
  }
  {
    BITCODE_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp (&clone_ins_pt, &large_radial_dimension->clone_ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.clone_ins_pt [2RD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &large_radial_dimension->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.def_pt [3BD]");
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &large_radial_dimension->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.dimstyle [H]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "elevation", &elevation, NULL)
        && elevation == large_radial_dimension->elevation)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.elevation [BD] %g != %g", large_radial_dimension->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "elevation", &elevation, 0)
        && elevation == large_radial_dimension->elevation)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.elevation [BD] set+1 %g != %g", large_radial_dimension->elevation, elevation);
    large_radial_dimension->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &large_radial_dimension->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.extrusion [BE]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &large_radial_dimension->first_arc_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.first_arc_pt [3BD]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "flag", &flag, NULL)
        && flag == large_radial_dimension->flag)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.flag [RC] %u != %u", large_radial_dimension->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "flag", &flag, 0)
        && flag == large_radial_dimension->flag)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.flag [RC] set+1 %u != %u", large_radial_dimension->flag, flag);
    large_radial_dimension->flag--;
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "flag1", &flag1, NULL)
        && flag1 == large_radial_dimension->flag1)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.flag1 [RC] %u != %u", large_radial_dimension->flag1, flag1);
    flag1++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "flag1", &flag1, 0)
        && flag1 == large_radial_dimension->flag1)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.flag1 [RC] set+1 %u != %u", large_radial_dimension->flag1, flag1);
    large_radial_dimension->flag1--;
  }
  {
    BITCODE_B flip_arrow1;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "flip_arrow1", &flip_arrow1, NULL)
        && flip_arrow1 == large_radial_dimension->flip_arrow1)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.flip_arrow1 [B] " FORMAT_B " != " FORMAT_B "", large_radial_dimension->flip_arrow1, flip_arrow1);
    flip_arrow1++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "flip_arrow1", &flip_arrow1, 0)
        && flip_arrow1 == large_radial_dimension->flip_arrow1)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.flip_arrow1 [B] set+1 " FORMAT_B " != " FORMAT_B "", large_radial_dimension->flip_arrow1, flip_arrow1);
    large_radial_dimension->flip_arrow1--;
  }
  {
    BITCODE_B flip_arrow2;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "flip_arrow2", &flip_arrow2, NULL)
        && flip_arrow2 == large_radial_dimension->flip_arrow2)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.flip_arrow2 [B] " FORMAT_B " != " FORMAT_B "", large_radial_dimension->flip_arrow2, flip_arrow2);
    flip_arrow2++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "flip_arrow2", &flip_arrow2, 0)
        && flip_arrow2 == large_radial_dimension->flip_arrow2)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.flip_arrow2 [B] set+1 " FORMAT_B " != " FORMAT_B "", large_radial_dimension->flip_arrow2, flip_arrow2);
    large_radial_dimension->flip_arrow2--;
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "horiz_dir", &horiz_dir, NULL)
        && horiz_dir == large_radial_dimension->horiz_dir)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.horiz_dir [BD] %g != %g", large_radial_dimension->horiz_dir, horiz_dir);
    horiz_dir++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "horiz_dir", &horiz_dir, 0)
        && horiz_dir == large_radial_dimension->horiz_dir)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.horiz_dir [BD] set+1 %g != %g", large_radial_dimension->horiz_dir, horiz_dir);
    large_radial_dimension->horiz_dir--;
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "ins_rotation", &ins_rotation, NULL)
        && ins_rotation == large_radial_dimension->ins_rotation)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.ins_rotation [BD] %g != %g", large_radial_dimension->ins_rotation, ins_rotation);
    ins_rotation++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "ins_rotation", &ins_rotation, 0)
        && ins_rotation == large_radial_dimension->ins_rotation)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.ins_rotation [BD] set+1 %g != %g", large_radial_dimension->ins_rotation, ins_rotation);
    large_radial_dimension->ins_rotation--;
  }
  {
    BITCODE_3BD ins_scale;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "ins_scale", &ins_scale, NULL)
        && !memcmp (&ins_scale, &large_radial_dimension->ins_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.ins_scale [3BD_1]");
  }
  {
    BITCODE_3BD jog_point;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "jog_point", &jog_point, NULL)
        && !memcmp (&jog_point, &large_radial_dimension->jog_point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.jog_point [3BD]");
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "leader_len", &leader_len, NULL)
        && leader_len == large_radial_dimension->leader_len)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.leader_len [BD] %g != %g", large_radial_dimension->leader_len, leader_len);
    leader_len++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "leader_len", &leader_len, 0)
        && leader_len == large_radial_dimension->leader_len)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.leader_len [BD] set+1 %g != %g", large_radial_dimension->leader_len, leader_len);
    large_radial_dimension->leader_len--;
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "lspace_factor", &lspace_factor, NULL)
        && lspace_factor == large_radial_dimension->lspace_factor)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.lspace_factor [BD] %g != %g", large_radial_dimension->lspace_factor, lspace_factor);
    lspace_factor++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "lspace_factor", &lspace_factor, 0)
        && lspace_factor == large_radial_dimension->lspace_factor)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.lspace_factor [BD] set+1 %g != %g", large_radial_dimension->lspace_factor, lspace_factor);
    large_radial_dimension->lspace_factor--;
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "lspace_style", &lspace_style, NULL)
        && lspace_style == large_radial_dimension->lspace_style)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.lspace_style [BS] %hu != %hu", large_radial_dimension->lspace_style, lspace_style);
    lspace_style++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "lspace_style", &lspace_style, 0)
        && lspace_style == large_radial_dimension->lspace_style)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.lspace_style [BS] set+1 %hu != %hu", large_radial_dimension->lspace_style, lspace_style);
    large_radial_dimension->lspace_style--;
  }
  {
    BITCODE_3BD ovr_center;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "ovr_center", &ovr_center, NULL)
        && !memcmp (&ovr_center, &large_radial_dimension->ovr_center, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.ovr_center [3BD]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "parent", &parent, NULL)
        && !memcmp (&parent, &large_radial_dimension->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD text_midpt;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "text_midpt", &text_midpt, NULL)
        && !memcmp (&text_midpt, &large_radial_dimension->text_midpt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("LARGE_RADIAL_DIMENSION.text_midpt [2RD]");
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "text_rotation", &text_rotation, NULL)
        && text_rotation == large_radial_dimension->text_rotation)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.text_rotation [BD] %g != %g", large_radial_dimension->text_rotation, text_rotation);
    text_rotation++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "text_rotation", &text_rotation, 0)
        && text_rotation == large_radial_dimension->text_rotation)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.text_rotation [BD] set+1 %g != %g", large_radial_dimension->text_rotation, text_rotation);
    large_radial_dimension->text_rotation--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "unknown", &unknown, NULL)
        && unknown == large_radial_dimension->unknown)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.unknown [B] " FORMAT_B " != " FORMAT_B "", large_radial_dimension->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "unknown", &unknown, 0)
        && unknown == large_radial_dimension->unknown)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", large_radial_dimension->unknown, unknown);
    large_radial_dimension->unknown--;
  }
  {
    BITCODE_T user_text;
    if (dwg_dynapi_entity_value (large_radial_dimension, "LARGE_RADIAL_DIMENSION", "user_text", &user_text, NULL)
        && user_text
           ? strEQ ((char *)user_text, (char *)large_radial_dimension->user_text)
           : !large_radial_dimension->user_text)
      pass ();
    else
      fail ("LARGE_RADIAL_DIMENSION.user_text [T] '%s' <> '%s'", user_text, large_radial_dimension->user_text);
  }
  if (failed && (is_class_unstable ("LARGE_RADIAL_DIMENSION") || is_class_debugging ("LARGE_RADIAL_DIMENSION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LARGE_RADIAL_DIMENSION", failed);
      failed = 0;
    }
  return failed;
}
static int test_LEADER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LEADER *restrict leader = obj->tio.entity->tio.LEADER;
  failed = 0;
  if (!obj_obj || !leader)
    {
      fail ("NULL LEADER");
      return 1;
    }
  {
    BITCODE_BS annot_type;
    if (dwg_dynapi_entity_value (leader, "LEADER", "annot_type", &annot_type, NULL)
        && annot_type == leader->annot_type)
      pass ();
    else
      fail ("LEADER.annot_type [BS] %hu != %hu", leader->annot_type, annot_type);
    annot_type++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "annot_type", &annot_type, 0)
        && annot_type == leader->annot_type)
      pass ();
    else
      fail ("LEADER.annot_type [BS] set+1 %hu != %hu", leader->annot_type, annot_type);
    leader->annot_type--;
  }
  {
    BITCODE_B arrowhead_on;
    if (dwg_dynapi_entity_value (leader, "LEADER", "arrowhead_on", &arrowhead_on, NULL)
        && arrowhead_on == leader->arrowhead_on)
      pass ();
    else
      fail ("LEADER.arrowhead_on [B] " FORMAT_B " != " FORMAT_B "", leader->arrowhead_on, arrowhead_on);
    arrowhead_on++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "arrowhead_on", &arrowhead_on, 0)
        && arrowhead_on == leader->arrowhead_on)
      pass ();
    else
      fail ("LEADER.arrowhead_on [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->arrowhead_on, arrowhead_on);
    leader->arrowhead_on--;
  }
  {
    BITCODE_BS arrowhead_type;
    if (dwg_dynapi_entity_value (leader, "LEADER", "arrowhead_type", &arrowhead_type, NULL)
        && arrowhead_type == leader->arrowhead_type)
      pass ();
    else
      fail ("LEADER.arrowhead_type [BS] %hu != %hu", leader->arrowhead_type, arrowhead_type);
    arrowhead_type++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "arrowhead_type", &arrowhead_type, 0)
        && arrowhead_type == leader->arrowhead_type)
      pass ();
    else
      fail ("LEADER.arrowhead_type [BS] set+1 %hu != %hu", leader->arrowhead_type, arrowhead_type);
    leader->arrowhead_type--;
  }
  {
    BITCODE_H associated_annotation;
    if (dwg_dynapi_entity_value (leader, "LEADER", "associated_annotation", &associated_annotation, NULL)
        && !memcmp (&associated_annotation, &leader->associated_annotation, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LEADER.associated_annotation [H]");
  }
  {
    BITCODE_BD box_height;
    if (dwg_dynapi_entity_value (leader, "LEADER", "box_height", &box_height, NULL)
        && box_height == leader->box_height)
      pass ();
    else
      fail ("LEADER.box_height [BD] %g != %g", leader->box_height, box_height);
    box_height++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "box_height", &box_height, 0)
        && box_height == leader->box_height)
      pass ();
    else
      fail ("LEADER.box_height [BD] set+1 %g != %g", leader->box_height, box_height);
    leader->box_height--;
  }
  {
    BITCODE_BD box_width;
    if (dwg_dynapi_entity_value (leader, "LEADER", "box_width", &box_width, NULL)
        && box_width == leader->box_width)
      pass ();
    else
      fail ("LEADER.box_width [BD] %g != %g", leader->box_width, box_width);
    box_width++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "box_width", &box_width, 0)
        && box_width == leader->box_width)
      pass ();
    else
      fail ("LEADER.box_width [BD] set+1 %g != %g", leader->box_width, box_width);
    leader->box_width--;
  }
  {
    BITCODE_BS byblock_color;
    if (dwg_dynapi_entity_value (leader, "LEADER", "byblock_color", &byblock_color, NULL)
        && byblock_color == leader->byblock_color)
      pass ();
    else
      fail ("LEADER.byblock_color [BS] %hu != %hu", leader->byblock_color, byblock_color);
    byblock_color++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "byblock_color", &byblock_color, 0)
        && byblock_color == leader->byblock_color)
      pass ();
    else
      fail ("LEADER.byblock_color [BS] set+1 %hu != %hu", leader->byblock_color, byblock_color);
    leader->byblock_color--;
  }
  {
    BITCODE_BD dimasz;
    if (dwg_dynapi_entity_value (leader, "LEADER", "dimasz", &dimasz, NULL)
        && dimasz == leader->dimasz)
      pass ();
    else
      fail ("LEADER.dimasz [BD] %g != %g", leader->dimasz, dimasz);
    dimasz++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "dimasz", &dimasz, 0)
        && dimasz == leader->dimasz)
      pass ();
    else
      fail ("LEADER.dimasz [BD] set+1 %g != %g", leader->dimasz, dimasz);
    leader->dimasz--;
  }
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_entity_value (leader, "LEADER", "dimgap", &dimgap, NULL)
        && dimgap == leader->dimgap)
      pass ();
    else
      fail ("LEADER.dimgap [BD] %g != %g", leader->dimgap, dimgap);
    dimgap++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "dimgap", &dimgap, 0)
        && dimgap == leader->dimgap)
      pass ();
    else
      fail ("LEADER.dimgap [BD] set+1 %g != %g", leader->dimgap, dimgap);
    leader->dimgap--;
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (leader, "LEADER", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &leader->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LEADER.dimstyle [H]");
  }
  {
    BITCODE_3DPOINT endptproj;
    if (dwg_dynapi_entity_value (leader, "LEADER", "endptproj", &endptproj, NULL)
        && !memcmp (&endptproj, &leader->endptproj, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LEADER.endptproj [3DPOINT]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (leader, "LEADER", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &leader->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("LEADER.extrusion [BE]");
  }
  {
    BITCODE_B hookline_dir;
    if (dwg_dynapi_entity_value (leader, "LEADER", "hookline_dir", &hookline_dir, NULL)
        && hookline_dir == leader->hookline_dir)
      pass ();
    else
      fail ("LEADER.hookline_dir [B] " FORMAT_B " != " FORMAT_B "", leader->hookline_dir, hookline_dir);
    hookline_dir++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "hookline_dir", &hookline_dir, 0)
        && hookline_dir == leader->hookline_dir)
      pass ();
    else
      fail ("LEADER.hookline_dir [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->hookline_dir, hookline_dir);
    leader->hookline_dir--;
  }
  {
    BITCODE_B hookline_on;
    if (dwg_dynapi_entity_value (leader, "LEADER", "hookline_on", &hookline_on, NULL)
        && hookline_on == leader->hookline_on)
      pass ();
    else
      fail ("LEADER.hookline_on [B] " FORMAT_B " != " FORMAT_B "", leader->hookline_on, hookline_on);
    hookline_on++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "hookline_on", &hookline_on, 0)
        && hookline_on == leader->hookline_on)
      pass ();
    else
      fail ("LEADER.hookline_on [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->hookline_on, hookline_on);
    leader->hookline_on--;
  }
  {
    BITCODE_3DPOINT inspt_offset;
    if (dwg_dynapi_entity_value (leader, "LEADER", "inspt_offset", &inspt_offset, NULL)
        && !memcmp (&inspt_offset, &leader->inspt_offset, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LEADER.inspt_offset [3DPOINT]");
  }
  {
    BITCODE_BL num_points;
    if (dwg_dynapi_entity_value (leader, "LEADER", "num_points", &num_points, NULL)
        && num_points == leader->num_points)
      pass ();
    else
      fail ("LEADER.num_points [BL] %u != %u", leader->num_points, num_points);
    num_points++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "num_points", &num_points, 0)
        && num_points == leader->num_points)
      pass ();
    else
      fail ("LEADER.num_points [BL] set+1 %u != %u", leader->num_points, num_points);
    leader->num_points--;
  }
  {
    BITCODE_3DPOINT origin;
    if (dwg_dynapi_entity_value (leader, "LEADER", "origin", &origin, NULL)
        && !memcmp (&origin, &leader->origin, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LEADER.origin [3DPOINT]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (leader, "LEADER", "parent", &parent, NULL)
        && !memcmp (&parent, &leader->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LEADER.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BS path_type;
    if (dwg_dynapi_entity_value (leader, "LEADER", "path_type", &path_type, NULL)
        && path_type == leader->path_type)
      pass ();
    else
      fail ("LEADER.path_type [BS] %hu != %hu", leader->path_type, path_type);
    path_type++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "path_type", &path_type, 0)
        && path_type == leader->path_type)
      pass ();
    else
      fail ("LEADER.path_type [BS] set+1 %hu != %hu", leader->path_type, path_type);
    leader->path_type--;
  }
  {
    BITCODE_3DPOINT* points;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (leader, "LEADER", "num_points", &count, NULL)
        && dwg_dynapi_entity_value (leader, "LEADER", "points", &points, NULL)
        && points == leader->points)
      pass ();
    else
      fail ("LEADER.points [3DPOINT*] * %u num_points", count);
  }
  {
    BITCODE_B unknown_bit_1;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_1", &unknown_bit_1, NULL)
        && unknown_bit_1 == leader->unknown_bit_1)
      pass ();
    else
      fail ("LEADER.unknown_bit_1 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_1, unknown_bit_1);
    unknown_bit_1++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_1", &unknown_bit_1, 0)
        && unknown_bit_1 == leader->unknown_bit_1)
      pass ();
    else
      fail ("LEADER.unknown_bit_1 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_1, unknown_bit_1);
    leader->unknown_bit_1--;
  }
  {
    BITCODE_B unknown_bit_2;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_2", &unknown_bit_2, NULL)
        && unknown_bit_2 == leader->unknown_bit_2)
      pass ();
    else
      fail ("LEADER.unknown_bit_2 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_2, unknown_bit_2);
    unknown_bit_2++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_2", &unknown_bit_2, 0)
        && unknown_bit_2 == leader->unknown_bit_2)
      pass ();
    else
      fail ("LEADER.unknown_bit_2 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_2, unknown_bit_2);
    leader->unknown_bit_2--;
  }
  {
    BITCODE_B unknown_bit_3;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_3", &unknown_bit_3, NULL)
        && unknown_bit_3 == leader->unknown_bit_3)
      pass ();
    else
      fail ("LEADER.unknown_bit_3 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_3, unknown_bit_3);
    unknown_bit_3++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_3", &unknown_bit_3, 0)
        && unknown_bit_3 == leader->unknown_bit_3)
      pass ();
    else
      fail ("LEADER.unknown_bit_3 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_3, unknown_bit_3);
    leader->unknown_bit_3--;
  }
  {
    BITCODE_B unknown_bit_4;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_4", &unknown_bit_4, NULL)
        && unknown_bit_4 == leader->unknown_bit_4)
      pass ();
    else
      fail ("LEADER.unknown_bit_4 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_4, unknown_bit_4);
    unknown_bit_4++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_4", &unknown_bit_4, 0)
        && unknown_bit_4 == leader->unknown_bit_4)
      pass ();
    else
      fail ("LEADER.unknown_bit_4 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_4, unknown_bit_4);
    leader->unknown_bit_4--;
  }
  {
    BITCODE_B unknown_bit_5;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_bit_5", &unknown_bit_5, NULL)
        && unknown_bit_5 == leader->unknown_bit_5)
      pass ();
    else
      fail ("LEADER.unknown_bit_5 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_5, unknown_bit_5);
    unknown_bit_5++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_bit_5", &unknown_bit_5, 0)
        && unknown_bit_5 == leader->unknown_bit_5)
      pass ();
    else
      fail ("LEADER.unknown_bit_5 [B] set+1 " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_5, unknown_bit_5);
    leader->unknown_bit_5--;
  }
  {
    BITCODE_BS unknown_short_1;
    if (dwg_dynapi_entity_value (leader, "LEADER", "unknown_short_1", &unknown_short_1, NULL)
        && unknown_short_1 == leader->unknown_short_1)
      pass ();
    else
      fail ("LEADER.unknown_short_1 [BS] %hu != %hu", leader->unknown_short_1, unknown_short_1);
    unknown_short_1++;
    if (dwg_dynapi_entity_set_value (leader, "LEADER", "unknown_short_1", &unknown_short_1, 0)
        && unknown_short_1 == leader->unknown_short_1)
      pass ();
    else
      fail ("LEADER.unknown_short_1 [BS] set+1 %hu != %hu", leader->unknown_short_1, unknown_short_1);
    leader->unknown_short_1--;
  }
  {
    BITCODE_3DPOINT x_direction;
    if (dwg_dynapi_entity_value (leader, "LEADER", "x_direction", &x_direction, NULL)
        && !memcmp (&x_direction, &leader->x_direction, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LEADER.x_direction [3DPOINT]");
  }
  if (failed && (is_class_unstable ("LEADER") || is_class_debugging ("LEADER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LEADER", failed);
      failed = 0;
    }
  return failed;
}
static int test_LIGHT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LIGHT *restrict light = obj->tio.entity->tio.LIGHT;
  failed = 0;
  if (!obj_obj || !light)
    {
      fail ("NULL LIGHT");
      return 1;
    }
  {
    BITCODE_BD attenuation_end_limit;
    if (dwg_dynapi_entity_value (light, "LIGHT", "attenuation_end_limit", &attenuation_end_limit, NULL)
        && attenuation_end_limit == light->attenuation_end_limit)
      pass ();
    else
      fail ("LIGHT.attenuation_end_limit [BD] %g != %g", light->attenuation_end_limit, attenuation_end_limit);
    attenuation_end_limit++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "attenuation_end_limit", &attenuation_end_limit, 0)
        && attenuation_end_limit == light->attenuation_end_limit)
      pass ();
    else
      fail ("LIGHT.attenuation_end_limit [BD] set+1 %g != %g", light->attenuation_end_limit, attenuation_end_limit);
    light->attenuation_end_limit--;
  }
  {
    BITCODE_BD attenuation_start_limit;
    if (dwg_dynapi_entity_value (light, "LIGHT", "attenuation_start_limit", &attenuation_start_limit, NULL)
        && attenuation_start_limit == light->attenuation_start_limit)
      pass ();
    else
      fail ("LIGHT.attenuation_start_limit [BD] %g != %g", light->attenuation_start_limit, attenuation_start_limit);
    attenuation_start_limit++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "attenuation_start_limit", &attenuation_start_limit, 0)
        && attenuation_start_limit == light->attenuation_start_limit)
      pass ();
    else
      fail ("LIGHT.attenuation_start_limit [BD] set+1 %g != %g", light->attenuation_start_limit, attenuation_start_limit);
    light->attenuation_start_limit--;
  }
  {
    BITCODE_BL attenuation_type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "attenuation_type", &attenuation_type, NULL)
        && attenuation_type == light->attenuation_type)
      pass ();
    else
      fail ("LIGHT.attenuation_type [BL] %u != %u", light->attenuation_type, attenuation_type);
    attenuation_type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "attenuation_type", &attenuation_type, 0)
        && attenuation_type == light->attenuation_type)
      pass ();
    else
      fail ("LIGHT.attenuation_type [BL] set+1 %u != %u", light->attenuation_type, attenuation_type);
    light->attenuation_type--;
  }
  {
    BITCODE_B cast_shadows;
    if (dwg_dynapi_entity_value (light, "LIGHT", "cast_shadows", &cast_shadows, NULL)
        && cast_shadows == light->cast_shadows)
      pass ();
    else
      fail ("LIGHT.cast_shadows [B] " FORMAT_B " != " FORMAT_B "", light->cast_shadows, cast_shadows);
    cast_shadows++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "cast_shadows", &cast_shadows, 0)
        && cast_shadows == light->cast_shadows)
      pass ();
    else
      fail ("LIGHT.cast_shadows [B] set+1 " FORMAT_B " != " FORMAT_B "", light->cast_shadows, cast_shadows);
    light->cast_shadows--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (light, "LIGHT", "class_version", &class_version, NULL)
        && class_version == light->class_version)
      pass ();
    else
      fail ("LIGHT.class_version [BL] %u != %u", light->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "class_version", &class_version, 0)
        && class_version == light->class_version)
      pass ();
    else
      fail ("LIGHT.class_version [BL] set+1 %u != %u", light->class_version, class_version);
    light->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (light, "LIGHT", "color", &color, NULL)
        && !memcmp (&color, &light->color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("LIGHT.color [CMC]");
  }
  {
    BITCODE_BD extlight_length;
    if (dwg_dynapi_entity_value (light, "LIGHT", "extlight_length", &extlight_length, NULL)
        && extlight_length == light->extlight_length)
      pass ();
    else
      fail ("LIGHT.extlight_length [BD] %g != %g", light->extlight_length, extlight_length);
    extlight_length++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "extlight_length", &extlight_length, 0)
        && extlight_length == light->extlight_length)
      pass ();
    else
      fail ("LIGHT.extlight_length [BD] set+1 %g != %g", light->extlight_length, extlight_length);
    light->extlight_length--;
  }
  {
    BITCODE_BD extlight_radius;
    if (dwg_dynapi_entity_value (light, "LIGHT", "extlight_radius", &extlight_radius, NULL)
        && extlight_radius == light->extlight_radius)
      pass ();
    else
      fail ("LIGHT.extlight_radius [BD] %g != %g", light->extlight_radius, extlight_radius);
    extlight_radius++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "extlight_radius", &extlight_radius, 0)
        && extlight_radius == light->extlight_radius)
      pass ();
    else
      fail ("LIGHT.extlight_radius [BD] set+1 %g != %g", light->extlight_radius, extlight_radius);
    light->extlight_radius--;
  }
  {
    BITCODE_BS extlight_shape;
    if (dwg_dynapi_entity_value (light, "LIGHT", "extlight_shape", &extlight_shape, NULL)
        && extlight_shape == light->extlight_shape)
      pass ();
    else
      fail ("LIGHT.extlight_shape [BS] %hu != %hu", light->extlight_shape, extlight_shape);
    extlight_shape++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "extlight_shape", &extlight_shape, 0)
        && extlight_shape == light->extlight_shape)
      pass ();
    else
      fail ("LIGHT.extlight_shape [BS] set+1 %hu != %hu", light->extlight_shape, extlight_shape);
    light->extlight_shape--;
  }
  {
    BITCODE_BD extlight_width;
    if (dwg_dynapi_entity_value (light, "LIGHT", "extlight_width", &extlight_width, NULL)
        && extlight_width == light->extlight_width)
      pass ();
    else
      fail ("LIGHT.extlight_width [BD] %g != %g", light->extlight_width, extlight_width);
    extlight_width++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "extlight_width", &extlight_width, 0)
        && extlight_width == light->extlight_width)
      pass ();
    else
      fail ("LIGHT.extlight_width [BD] set+1 %g != %g", light->extlight_width, extlight_width);
    light->extlight_width--;
  }
  {
    BITCODE_BD falloff_angle;
    if (dwg_dynapi_entity_value (light, "LIGHT", "falloff_angle", &falloff_angle, NULL)
        && falloff_angle == light->falloff_angle)
      pass ();
    else
      fail ("LIGHT.falloff_angle [BD] %g != %g", light->falloff_angle, falloff_angle);
    falloff_angle++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "falloff_angle", &falloff_angle, 0)
        && falloff_angle == light->falloff_angle)
      pass ();
    else
      fail ("LIGHT.falloff_angle [BD] set+1 %g != %g", light->falloff_angle, falloff_angle);
    light->falloff_angle--;
  }
  {
    BITCODE_BS glyph_display_type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "glyph_display_type", &glyph_display_type, NULL)
        && glyph_display_type == light->glyph_display_type)
      pass ();
    else
      fail ("LIGHT.glyph_display_type [BS] %hu != %hu", light->glyph_display_type, glyph_display_type);
    glyph_display_type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "glyph_display_type", &glyph_display_type, 0)
        && glyph_display_type == light->glyph_display_type)
      pass ();
    else
      fail ("LIGHT.glyph_display_type [BS] set+1 %hu != %hu", light->glyph_display_type, glyph_display_type);
    light->glyph_display_type--;
  }
  {
    BITCODE_B has_photometric_data;
    if (dwg_dynapi_entity_value (light, "LIGHT", "has_photometric_data", &has_photometric_data, NULL)
        && has_photometric_data == light->has_photometric_data)
      pass ();
    else
      fail ("LIGHT.has_photometric_data [B] " FORMAT_B " != " FORMAT_B "", light->has_photometric_data, has_photometric_data);
    has_photometric_data++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "has_photometric_data", &has_photometric_data, 0)
        && has_photometric_data == light->has_photometric_data)
      pass ();
    else
      fail ("LIGHT.has_photometric_data [B] set+1 " FORMAT_B " != " FORMAT_B "", light->has_photometric_data, has_photometric_data);
    light->has_photometric_data--;
  }
  {
    BITCODE_BS has_target_grip;
    if (dwg_dynapi_entity_value (light, "LIGHT", "has_target_grip", &has_target_grip, NULL)
        && has_target_grip == light->has_target_grip)
      pass ();
    else
      fail ("LIGHT.has_target_grip [BS] %hu != %hu", light->has_target_grip, has_target_grip);
    has_target_grip++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "has_target_grip", &has_target_grip, 0)
        && has_target_grip == light->has_target_grip)
      pass ();
    else
      fail ("LIGHT.has_target_grip [BS] set+1 %hu != %hu", light->has_target_grip, has_target_grip);
    light->has_target_grip--;
  }
  {
    BITCODE_B has_webfile;
    if (dwg_dynapi_entity_value (light, "LIGHT", "has_webfile", &has_webfile, NULL)
        && has_webfile == light->has_webfile)
      pass ();
    else
      fail ("LIGHT.has_webfile [B] " FORMAT_B " != " FORMAT_B "", light->has_webfile, has_webfile);
    has_webfile++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "has_webfile", &has_webfile, 0)
        && has_webfile == light->has_webfile)
      pass ();
    else
      fail ("LIGHT.has_webfile [B] set+1 " FORMAT_B " != " FORMAT_B "", light->has_webfile, has_webfile);
    light->has_webfile--;
  }
  {
    BITCODE_BD hotspot_angle;
    if (dwg_dynapi_entity_value (light, "LIGHT", "hotspot_angle", &hotspot_angle, NULL)
        && hotspot_angle == light->hotspot_angle)
      pass ();
    else
      fail ("LIGHT.hotspot_angle [BD] %g != %g", light->hotspot_angle, hotspot_angle);
    hotspot_angle++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "hotspot_angle", &hotspot_angle, 0)
        && hotspot_angle == light->hotspot_angle)
      pass ();
    else
      fail ("LIGHT.hotspot_angle [BD] set+1 %g != %g", light->hotspot_angle, hotspot_angle);
    light->hotspot_angle--;
  }
  {
    BITCODE_BD illuminance_dist;
    if (dwg_dynapi_entity_value (light, "LIGHT", "illuminance_dist", &illuminance_dist, NULL)
        && illuminance_dist == light->illuminance_dist)
      pass ();
    else
      fail ("LIGHT.illuminance_dist [BD] %g != %g", light->illuminance_dist, illuminance_dist);
    illuminance_dist++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "illuminance_dist", &illuminance_dist, 0)
        && illuminance_dist == light->illuminance_dist)
      pass ();
    else
      fail ("LIGHT.illuminance_dist [BD] set+1 %g != %g", light->illuminance_dist, illuminance_dist);
    light->illuminance_dist--;
  }
  {
    BITCODE_BD intensity;
    if (dwg_dynapi_entity_value (light, "LIGHT", "intensity", &intensity, NULL)
        && intensity == light->intensity)
      pass ();
    else
      fail ("LIGHT.intensity [BD] %g != %g", light->intensity, intensity);
    intensity++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "intensity", &intensity, 0)
        && intensity == light->intensity)
      pass ();
    else
      fail ("LIGHT.intensity [BD] set+1 %g != %g", light->intensity, intensity);
    light->intensity--;
  }
  {
    BITCODE_B is_photometric;
    if (dwg_dynapi_entity_value (light, "LIGHT", "is_photometric", &is_photometric, NULL)
        && is_photometric == light->is_photometric)
      pass ();
    else
      fail ("LIGHT.is_photometric [B] " FORMAT_B " != " FORMAT_B "", light->is_photometric, is_photometric);
    is_photometric++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "is_photometric", &is_photometric, 0)
        && is_photometric == light->is_photometric)
      pass ();
    else
      fail ("LIGHT.is_photometric [B] set+1 " FORMAT_B " != " FORMAT_B "", light->is_photometric, is_photometric);
    light->is_photometric--;
  }
  {
    BITCODE_BS lamp_color_preset;
    if (dwg_dynapi_entity_value (light, "LIGHT", "lamp_color_preset", &lamp_color_preset, NULL)
        && lamp_color_preset == light->lamp_color_preset)
      pass ();
    else
      fail ("LIGHT.lamp_color_preset [BS] %hu != %hu", light->lamp_color_preset, lamp_color_preset);
    lamp_color_preset++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "lamp_color_preset", &lamp_color_preset, 0)
        && lamp_color_preset == light->lamp_color_preset)
      pass ();
    else
      fail ("LIGHT.lamp_color_preset [BS] set+1 %hu != %hu", light->lamp_color_preset, lamp_color_preset);
    light->lamp_color_preset--;
  }
  {
    BITCODE_BL lamp_color_rgb;
    if (dwg_dynapi_entity_value (light, "LIGHT", "lamp_color_rgb", &lamp_color_rgb, NULL)
        && lamp_color_rgb == light->lamp_color_rgb)
      pass ();
    else
      fail ("LIGHT.lamp_color_rgb [BL] %u != %u", light->lamp_color_rgb, lamp_color_rgb);
    lamp_color_rgb++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "lamp_color_rgb", &lamp_color_rgb, 0)
        && lamp_color_rgb == light->lamp_color_rgb)
      pass ();
    else
      fail ("LIGHT.lamp_color_rgb [BL] set+1 %u != %u", light->lamp_color_rgb, lamp_color_rgb);
    light->lamp_color_rgb--;
  }
  {
    BITCODE_BD lamp_color_temp;
    if (dwg_dynapi_entity_value (light, "LIGHT", "lamp_color_temp", &lamp_color_temp, NULL)
        && lamp_color_temp == light->lamp_color_temp)
      pass ();
    else
      fail ("LIGHT.lamp_color_temp [BD] %g != %g", light->lamp_color_temp, lamp_color_temp);
    lamp_color_temp++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "lamp_color_temp", &lamp_color_temp, 0)
        && lamp_color_temp == light->lamp_color_temp)
      pass ();
    else
      fail ("LIGHT.lamp_color_temp [BD] set+1 %g != %g", light->lamp_color_temp, lamp_color_temp);
    light->lamp_color_temp--;
  }
  {
    BITCODE_BS lamp_color_type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "lamp_color_type", &lamp_color_type, NULL)
        && lamp_color_type == light->lamp_color_type)
      pass ();
    else
      fail ("LIGHT.lamp_color_type [BS] %hu != %hu", light->lamp_color_type, lamp_color_type);
    lamp_color_type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "lamp_color_type", &lamp_color_type, 0)
        && lamp_color_type == light->lamp_color_type)
      pass ();
    else
      fail ("LIGHT.lamp_color_type [BS] set+1 %hu != %hu", light->lamp_color_type, lamp_color_type);
    light->lamp_color_type--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (light, "LIGHT", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)light->name)
           : !light->name)
      pass ();
    else
      fail ("LIGHT.name [T] '%s' <> '%s'", name, light->name);
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (light, "LIGHT", "parent", &parent, NULL)
        && !memcmp (&parent, &light->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LIGHT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD physical_intensity;
    if (dwg_dynapi_entity_value (light, "LIGHT", "physical_intensity", &physical_intensity, NULL)
        && physical_intensity == light->physical_intensity)
      pass ();
    else
      fail ("LIGHT.physical_intensity [BD] %g != %g", light->physical_intensity, physical_intensity);
    physical_intensity++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "physical_intensity", &physical_intensity, 0)
        && physical_intensity == light->physical_intensity)
      pass ();
    else
      fail ("LIGHT.physical_intensity [BD] set+1 %g != %g", light->physical_intensity, physical_intensity);
    light->physical_intensity--;
  }
  {
    BITCODE_BS physical_intensity_method;
    if (dwg_dynapi_entity_value (light, "LIGHT", "physical_intensity_method", &physical_intensity_method, NULL)
        && physical_intensity_method == light->physical_intensity_method)
      pass ();
    else
      fail ("LIGHT.physical_intensity_method [BS] %hu != %hu", light->physical_intensity_method, physical_intensity_method);
    physical_intensity_method++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "physical_intensity_method", &physical_intensity_method, 0)
        && physical_intensity_method == light->physical_intensity_method)
      pass ();
    else
      fail ("LIGHT.physical_intensity_method [BS] set+1 %hu != %hu", light->physical_intensity_method, physical_intensity_method);
    light->physical_intensity_method--;
  }
  {
    BITCODE_B plot_glyph;
    if (dwg_dynapi_entity_value (light, "LIGHT", "plot_glyph", &plot_glyph, NULL)
        && plot_glyph == light->plot_glyph)
      pass ();
    else
      fail ("LIGHT.plot_glyph [B] " FORMAT_B " != " FORMAT_B "", light->plot_glyph, plot_glyph);
    plot_glyph++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "plot_glyph", &plot_glyph, 0)
        && plot_glyph == light->plot_glyph)
      pass ();
    else
      fail ("LIGHT.plot_glyph [B] set+1 " FORMAT_B " != " FORMAT_B "", light->plot_glyph, plot_glyph);
    light->plot_glyph--;
  }
  {
    BITCODE_3BD position;
    if (dwg_dynapi_entity_value (light, "LIGHT", "position", &position, NULL)
        && !memcmp (&position, &light->position, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LIGHT.position [3BD]");
  }
  {
    BITCODE_BS shadow_map_size;
    if (dwg_dynapi_entity_value (light, "LIGHT", "shadow_map_size", &shadow_map_size, NULL)
        && shadow_map_size == light->shadow_map_size)
      pass ();
    else
      fail ("LIGHT.shadow_map_size [BS] %hu != %hu", light->shadow_map_size, shadow_map_size);
    shadow_map_size++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "shadow_map_size", &shadow_map_size, 0)
        && shadow_map_size == light->shadow_map_size)
      pass ();
    else
      fail ("LIGHT.shadow_map_size [BS] set+1 %hu != %hu", light->shadow_map_size, shadow_map_size);
    light->shadow_map_size--;
  }
  {
    BITCODE_RC shadow_map_softness;
    if (dwg_dynapi_entity_value (light, "LIGHT", "shadow_map_softness", &shadow_map_softness, NULL)
        && shadow_map_softness == light->shadow_map_softness)
      pass ();
    else
      fail ("LIGHT.shadow_map_softness [RC] %u != %u", light->shadow_map_softness, shadow_map_softness);
    shadow_map_softness++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "shadow_map_softness", &shadow_map_softness, 0)
        && shadow_map_softness == light->shadow_map_softness)
      pass ();
    else
      fail ("LIGHT.shadow_map_softness [RC] set+1 %u != %u", light->shadow_map_softness, shadow_map_softness);
    light->shadow_map_softness--;
  }
  {
    BITCODE_BL shadow_type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "shadow_type", &shadow_type, NULL)
        && shadow_type == light->shadow_type)
      pass ();
    else
      fail ("LIGHT.shadow_type [BL] %u != %u", light->shadow_type, shadow_type);
    shadow_type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "shadow_type", &shadow_type, 0)
        && shadow_type == light->shadow_type)
      pass ();
    else
      fail ("LIGHT.shadow_type [BL] set+1 %u != %u", light->shadow_type, shadow_type);
    light->shadow_type--;
  }
  {
    BITCODE_B status;
    if (dwg_dynapi_entity_value (light, "LIGHT", "status", &status, NULL)
        && status == light->status)
      pass ();
    else
      fail ("LIGHT.status [B] " FORMAT_B " != " FORMAT_B "", light->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "status", &status, 0)
        && status == light->status)
      pass ();
    else
      fail ("LIGHT.status [B] set+1 " FORMAT_B " != " FORMAT_B "", light->status, status);
    light->status--;
  }
  {
    BITCODE_3BD target;
    if (dwg_dynapi_entity_value (light, "LIGHT", "target", &target, NULL)
        && !memcmp (&target, &light->target, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LIGHT.target [3BD]");
  }
  {
    BITCODE_BL type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "type", &type, NULL)
        && type == light->type)
      pass ();
    else
      fail ("LIGHT.type [BL] %u != %u", light->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "type", &type, 0)
        && type == light->type)
      pass ();
    else
      fail ("LIGHT.type [BL] set+1 %u != %u", light->type, type);
    light->type--;
  }
  {
    BITCODE_B use_attenuation_limits;
    if (dwg_dynapi_entity_value (light, "LIGHT", "use_attenuation_limits", &use_attenuation_limits, NULL)
        && use_attenuation_limits == light->use_attenuation_limits)
      pass ();
    else
      fail ("LIGHT.use_attenuation_limits [B] " FORMAT_B " != " FORMAT_B "", light->use_attenuation_limits, use_attenuation_limits);
    use_attenuation_limits++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "use_attenuation_limits", &use_attenuation_limits, 0)
        && use_attenuation_limits == light->use_attenuation_limits)
      pass ();
    else
      fail ("LIGHT.use_attenuation_limits [B] set+1 " FORMAT_B " != " FORMAT_B "", light->use_attenuation_limits, use_attenuation_limits);
    light->use_attenuation_limits--;
  }
  {
    BITCODE_BD web_angle1;
    if (dwg_dynapi_entity_value (light, "LIGHT", "web_angle1", &web_angle1, NULL)
        && web_angle1 == light->web_angle1)
      pass ();
    else
      fail ("LIGHT.web_angle1 [BD] %g != %g", light->web_angle1, web_angle1);
    web_angle1++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "web_angle1", &web_angle1, 0)
        && web_angle1 == light->web_angle1)
      pass ();
    else
      fail ("LIGHT.web_angle1 [BD] set+1 %g != %g", light->web_angle1, web_angle1);
    light->web_angle1--;
  }
  {
    BITCODE_BD web_angle2;
    if (dwg_dynapi_entity_value (light, "LIGHT", "web_angle2", &web_angle2, NULL)
        && web_angle2 == light->web_angle2)
      pass ();
    else
      fail ("LIGHT.web_angle2 [BD] %g != %g", light->web_angle2, web_angle2);
    web_angle2++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "web_angle2", &web_angle2, 0)
        && web_angle2 == light->web_angle2)
      pass ();
    else
      fail ("LIGHT.web_angle2 [BD] set+1 %g != %g", light->web_angle2, web_angle2);
    light->web_angle2--;
  }
  {
    BITCODE_BD web_angle3;
    if (dwg_dynapi_entity_value (light, "LIGHT", "web_angle3", &web_angle3, NULL)
        && web_angle3 == light->web_angle3)
      pass ();
    else
      fail ("LIGHT.web_angle3 [BD] %g != %g", light->web_angle3, web_angle3);
    web_angle3++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "web_angle3", &web_angle3, 0)
        && web_angle3 == light->web_angle3)
      pass ();
    else
      fail ("LIGHT.web_angle3 [BD] set+1 %g != %g", light->web_angle3, web_angle3);
    light->web_angle3--;
  }
  {
    BITCODE_BD web_angle4;
    if (dwg_dynapi_entity_value (light, "LIGHT", "web_angle4", &web_angle4, NULL)
        && web_angle4 == light->web_angle4)
      pass ();
    else
      fail ("LIGHT.web_angle4 [BD] %g != %g", light->web_angle4, web_angle4);
    web_angle4++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "web_angle4", &web_angle4, 0)
        && web_angle4 == light->web_angle4)
      pass ();
    else
      fail ("LIGHT.web_angle4 [BD] set+1 %g != %g", light->web_angle4, web_angle4);
    light->web_angle4--;
  }
  {
    BITCODE_BD web_angle5;
    if (dwg_dynapi_entity_value (light, "LIGHT", "web_angle5", &web_angle5, NULL)
        && web_angle5 == light->web_angle5)
      pass ();
    else
      fail ("LIGHT.web_angle5 [BD] %g != %g", light->web_angle5, web_angle5);
    web_angle5++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "web_angle5", &web_angle5, 0)
        && web_angle5 == light->web_angle5)
      pass ();
    else
      fail ("LIGHT.web_angle5 [BD] set+1 %g != %g", light->web_angle5, web_angle5);
    light->web_angle5--;
  }
  {
    BITCODE_BD web_flux;
    if (dwg_dynapi_entity_value (light, "LIGHT", "web_flux", &web_flux, NULL)
        && web_flux == light->web_flux)
      pass ();
    else
      fail ("LIGHT.web_flux [BD] %g != %g", light->web_flux, web_flux);
    web_flux++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "web_flux", &web_flux, 0)
        && web_flux == light->web_flux)
      pass ();
    else
      fail ("LIGHT.web_flux [BD] set+1 %g != %g", light->web_flux, web_flux);
    light->web_flux--;
  }
  {
    BITCODE_3BD web_rotation;
    if (dwg_dynapi_entity_value (light, "LIGHT", "web_rotation", &web_rotation, NULL)
        && !memcmp (&web_rotation, &light->web_rotation, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LIGHT.web_rotation [3BD_1]");
  }
  {
    BITCODE_BS web_symetry;
    if (dwg_dynapi_entity_value (light, "LIGHT", "web_symetry", &web_symetry, NULL)
        && web_symetry == light->web_symetry)
      pass ();
    else
      fail ("LIGHT.web_symetry [BS] %hu != %hu", light->web_symetry, web_symetry);
    web_symetry++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "web_symetry", &web_symetry, 0)
        && web_symetry == light->web_symetry)
      pass ();
    else
      fail ("LIGHT.web_symetry [BS] set+1 %hu != %hu", light->web_symetry, web_symetry);
    light->web_symetry--;
  }
  {
    BITCODE_T webfile;
    if (dwg_dynapi_entity_value (light, "LIGHT", "webfile", &webfile, NULL)
        && webfile
           ? strEQ ((char *)webfile, (char *)light->webfile)
           : !light->webfile)
      pass ();
    else
      fail ("LIGHT.webfile [T] '%s' <> '%s'", webfile, light->webfile);
  }
  {
    BITCODE_BS webfile_type;
    if (dwg_dynapi_entity_value (light, "LIGHT", "webfile_type", &webfile_type, NULL)
        && webfile_type == light->webfile_type)
      pass ();
    else
      fail ("LIGHT.webfile_type [BS] %hu != %hu", light->webfile_type, webfile_type);
    webfile_type++;
    if (dwg_dynapi_entity_set_value (light, "LIGHT", "webfile_type", &webfile_type, 0)
        && webfile_type == light->webfile_type)
      pass ();
    else
      fail ("LIGHT.webfile_type [BS] set+1 %hu != %hu", light->webfile_type, webfile_type);
    light->webfile_type--;
  }
  if (failed && (is_class_unstable ("LIGHT") || is_class_debugging ("LIGHT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LIGHT", failed);
      failed = 0;
    }
  return failed;
}
static int test_LINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LINE *restrict line = obj->tio.entity->tio.LINE;
  failed = 0;
  if (!obj_obj || !line)
    {
      fail ("NULL LINE");
      return 1;
    }
  {
    BITCODE_3BD end;
    if (dwg_dynapi_entity_value (line, "LINE", "end", &end, NULL)
        && !memcmp (&end, &line->end, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LINE.end [3BD]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (line, "LINE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &line->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("LINE.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (line, "LINE", "parent", &parent, NULL)
        && !memcmp (&parent, &line->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD start;
    if (dwg_dynapi_entity_value (line, "LINE", "start", &start, NULL)
        && !memcmp (&start, &line->start, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LINE.start [3BD]");
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (line, "LINE", "thickness", &thickness, NULL)
        && thickness == line->thickness)
      pass ();
    else
      fail ("LINE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", line->thickness, thickness);
    if (dwg_dynapi_entity_set_value (line, "LINE", "thickness", &thickness, 0)
        && thickness == line->thickness)
      pass ();
    else
      fail ("LINE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", line->thickness, thickness);
    line->thickness--;
  }
  {
    BITCODE_2RD unknown_r11;
    if (dwg_dynapi_entity_value (line, "LINE", "unknown_r11", &unknown_r11, NULL)
        && !memcmp (&unknown_r11, &line->unknown_r11, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("LINE.unknown_r11 [2RD]");
  }
  {
    BITCODE_RC z_is_zero;
    if (dwg_dynapi_entity_value (line, "LINE", "z_is_zero", &z_is_zero, NULL)
        && z_is_zero == line->z_is_zero)
      pass ();
    else
      fail ("LINE.z_is_zero [RC] %u != %u", line->z_is_zero, z_is_zero);
    z_is_zero++;
    if (dwg_dynapi_entity_set_value (line, "LINE", "z_is_zero", &z_is_zero, 0)
        && z_is_zero == line->z_is_zero)
      pass ();
    else
      fail ("LINE.z_is_zero [RC] set+1 %u != %u", line->z_is_zero, z_is_zero);
    line->z_is_zero--;
  }
  if (failed && (is_class_unstable ("LINE") || is_class_debugging ("LINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_LINEARGRIPENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LINEARGRIPENTITY *restrict lineargripentity = obj->tio.entity->tio.LINEARGRIPENTITY;
  failed = 0;
  if (!obj_obj || !lineargripentity)
    {
      fail ("NULL LINEARGRIPENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (lineargripentity, "LINEARGRIPENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &lineargripentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LINEARGRIPENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("LINEARGRIPENTITY") || is_class_debugging ("LINEARGRIPENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LINEARGRIPENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_LINEARPARAMETERENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LINEARPARAMETERENTITY *restrict linearparameterentity = obj->tio.entity->tio.LINEARPARAMETERENTITY;
  failed = 0;
  if (!obj_obj || !linearparameterentity)
    {
      fail ("NULL LINEARPARAMETERENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (linearparameterentity, "LINEARPARAMETERENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &linearparameterentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LINEARPARAMETERENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("LINEARPARAMETERENTITY") || is_class_debugging ("LINEARPARAMETERENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LINEARPARAMETERENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_LOAD (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LOAD *restrict load = obj->tio.entity->tio.LOAD;
  failed = 0;
  if (!obj_obj || !load)
    {
      fail ("NULL LOAD");
      return 1;
    }
  {
    BITCODE_TV file_name;
    if (dwg_dynapi_entity_value (load, "LOAD", "file_name", &file_name, NULL)
        && file_name
           ? strEQ ((char *)file_name, (char *)load->file_name)
           : !load->file_name)
      pass ();
    else
      fail ("LOAD.file_name [TV] '%s' <> '%s'", file_name, load->file_name);
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (load, "LOAD", "parent", &parent, NULL)
        && !memcmp (&parent, &load->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LOAD.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("LOAD") || is_class_debugging ("LOAD")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LOAD", failed);
      failed = 0;
    }
  return failed;
}
static int test_LOFTEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LOFTEDSURFACE *restrict loftedsurface = obj->tio.entity->tio.LOFTEDSURFACE;
  failed = 0;
  if (!obj_obj || !loftedsurface)
    {
      fail ("NULL LOFTEDSURFACE");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == loftedsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("LOFTEDSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == loftedsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("LOFTEDSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->_dxf_sab_converted, _dxf_sab_converted);
    loftedsurface->_dxf_sab_converted--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)loftedsurface->acis_data)
           : !loftedsurface->acis_data)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, loftedsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == loftedsurface->acis_empty)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == loftedsurface->acis_empty)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty, acis_empty);
    loftedsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == loftedsurface->acis_empty2)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == loftedsurface->acis_empty2)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty2, acis_empty2);
    loftedsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == loftedsurface->acis_empty_bit)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == loftedsurface->acis_empty_bit)
      pass ();
    else
      fail ("LOFTEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty_bit, acis_empty_bit);
    loftedsurface->acis_empty_bit--;
  }
  {
    BITCODE_B align_direction;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction, NULL)
        && align_direction == loftedsurface->align_direction)
      pass ();
    else
      fail ("LOFTEDSURFACE.align_direction [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction);
    align_direction++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction, 0)
        && align_direction == loftedsurface->align_direction)
      pass ();
    else
      fail ("LOFTEDSURFACE.align_direction [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction);
    loftedsurface->align_direction--;
  }
  {
    BITCODE_B arc_length_parameterization;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization, NULL)
        && arc_length_parameterization == loftedsurface->arc_length_parameterization)
      pass ();
    else
      fail ("LOFTEDSURFACE.arc_length_parameterization [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization);
    arc_length_parameterization++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization, 0)
        && arc_length_parameterization == loftedsurface->arc_length_parameterization)
      pass ();
    else
      fail ("LOFTEDSURFACE.arc_length_parameterization [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization);
    loftedsurface->arc_length_parameterization--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &loftedsurface->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("LOFTEDSURFACE.block_size [BL*]");
  }
  {
    BITCODE_B closed_surfaces;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces, NULL)
        && closed_surfaces == loftedsurface->closed_surfaces)
      pass ();
    else
      fail ("LOFTEDSURFACE.closed_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces);
    closed_surfaces++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces, 0)
        && closed_surfaces == loftedsurface->closed_surfaces)
      pass ();
    else
      fail ("LOFTEDSURFACE.closed_surfaces [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces);
    loftedsurface->closed_surfaces--;
  }
  {
    BITCODE_H* cross_sections;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "cross_sections", &cross_sections, NULL)
        && cross_sections == loftedsurface->cross_sections)
      pass ();
    else
      fail ("LOFTEDSURFACE.cross_sections [H*] * %u num_cross_sections", count);
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &loftedsurface->encr_sat_data, sizeof (loftedsurface->encr_sat_data)))
      pass ();
    else
      fail ("LOFTEDSURFACE.encr_sat_data [char **]");
  }
  {
    BITCODE_BD end_draft_angle;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle, NULL)
        && end_draft_angle == loftedsurface->end_draft_angle)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_draft_angle [BD] %g != %g", loftedsurface->end_draft_angle, end_draft_angle);
    end_draft_angle++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle, 0)
        && end_draft_angle == loftedsurface->end_draft_angle)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_draft_angle [BD] set+1 %g != %g", loftedsurface->end_draft_angle, end_draft_angle);
    loftedsurface->end_draft_angle--;
  }
  {
    BITCODE_BD end_draft_magnitude;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude, NULL)
        && end_draft_magnitude == loftedsurface->end_draft_magnitude)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_draft_magnitude [BD] %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude);
    end_draft_magnitude++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude, 0)
        && end_draft_magnitude == loftedsurface->end_draft_magnitude)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_draft_magnitude [BD] set+1 %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude);
    loftedsurface->end_draft_magnitude--;
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "end_marker", &end_marker, NULL)
        && end_marker == loftedsurface->end_marker)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_marker [BL] %u != %u", loftedsurface->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "end_marker", &end_marker, 0)
        && end_marker == loftedsurface->end_marker)
      pass ();
    else
      fail ("LOFTEDSURFACE.end_marker [BL] set+1 %u != %u", loftedsurface->end_marker, end_marker);
    loftedsurface->end_marker--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &loftedsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("LOFTEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_H* guide_curves;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "guide_curves", &guide_curves, NULL)
        && guide_curves == loftedsurface->guide_curves)
      pass ();
    else
      fail ("LOFTEDSURFACE.guide_curves [H*] * %u num_guide_curves", count);
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == loftedsurface->has_revision_guid)
      pass ();
    else
      fail ("LOFTEDSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == loftedsurface->has_revision_guid)
      pass ();
    else
      fail ("LOFTEDSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->has_revision_guid, has_revision_guid);
    loftedsurface->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &loftedsurface->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LOFTEDSURFACE.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == loftedsurface->isoline_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == loftedsurface->isoline_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->isoline_present, isoline_present);
    loftedsurface->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "isolines", &isolines, NULL)
        && isolines == loftedsurface->isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.isolines [BL] %u != %u", loftedsurface->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "isolines", &isolines, 0)
        && isolines == loftedsurface->isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.isolines [BL] set+1 %u != %u", loftedsurface->isolines, isolines);
    loftedsurface->isolines--;
  }
  {
    BITCODE_BD* loft_entity_transmatrix;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "loft_entity_transmatrix", &loft_entity_transmatrix, NULL)
        && !memcmp (&loft_entity_transmatrix, &loftedsurface->loft_entity_transmatrix, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("LOFTEDSURFACE.loft_entity_transmatrix [BD*]");
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "materials", &materials, NULL)
        && materials == loftedsurface->materials)
      pass ();
    else
      fail ("LOFTEDSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == loftedsurface->modeler_format_version)
      pass ();
    else
      fail ("LOFTEDSURFACE.modeler_format_version [BS] %hu != %hu", loftedsurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == loftedsurface->modeler_format_version)
      pass ();
    else
      fail ("LOFTEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", loftedsurface->modeler_format_version, modeler_format_version);
    loftedsurface->modeler_format_version--;
  }
  {
    BITCODE_B no_twist;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist, NULL)
        && no_twist == loftedsurface->no_twist)
      pass ();
    else
      fail ("LOFTEDSURFACE.no_twist [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist);
    no_twist++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist, 0)
        && no_twist == loftedsurface->no_twist)
      pass ();
    else
      fail ("LOFTEDSURFACE.no_twist [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist);
    loftedsurface->no_twist--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == loftedsurface->num_blocks)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_blocks [BL] %u != %u", loftedsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == loftedsurface->num_blocks)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_blocks [BL] set+1 %u != %u", loftedsurface->num_blocks, num_blocks);
    loftedsurface->num_blocks--;
  }
  {
    BITCODE_BS num_cross_sections;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections, NULL)
        && num_cross_sections == loftedsurface->num_cross_sections)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_cross_sections [BS] %hu != %hu", loftedsurface->num_cross_sections, num_cross_sections);
    num_cross_sections++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections, 0)
        && num_cross_sections == loftedsurface->num_cross_sections)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_cross_sections [BS] set+1 %hu != %hu", loftedsurface->num_cross_sections, num_cross_sections);
    loftedsurface->num_cross_sections--;
  }
  {
    BITCODE_BS num_guide_curves;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves, NULL)
        && num_guide_curves == loftedsurface->num_guide_curves)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_guide_curves [BS] %hu != %hu", loftedsurface->num_guide_curves, num_guide_curves);
    num_guide_curves++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves, 0)
        && num_guide_curves == loftedsurface->num_guide_curves)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_guide_curves [BS] set+1 %hu != %hu", loftedsurface->num_guide_curves, num_guide_curves);
    loftedsurface->num_guide_curves--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_materials", &num_materials, NULL)
        && num_materials == loftedsurface->num_materials)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_materials [BL] %u != %u", loftedsurface->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_materials", &num_materials, 0)
        && num_materials == loftedsurface->num_materials)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_materials [BL] set+1 %u != %u", loftedsurface->num_materials, num_materials);
    loftedsurface->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == loftedsurface->num_silhouettes)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_silhouettes [BL] %u != %u", loftedsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == loftedsurface->num_silhouettes)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_silhouettes [BL] set+1 %u != %u", loftedsurface->num_silhouettes, num_silhouettes);
    loftedsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == loftedsurface->num_wires)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_wires [BL] %u != %u", loftedsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires, 0)
        && num_wires == loftedsurface->num_wires)
      pass ();
    else
      fail ("LOFTEDSURFACE.num_wires [BL] set+1 %u != %u", loftedsurface->num_wires, num_wires);
    loftedsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &loftedsurface->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LOFTEDSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H path_curve;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "path_curve", &path_curve, NULL)
        && !memcmp (&path_curve, &loftedsurface->path_curve, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LOFTEDSURFACE.path_curve [H]");
  }
  {
    BITCODE_BL plane_normal_lofting_type;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type, NULL)
        && plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
      pass ();
    else
      fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type);
    plane_normal_lofting_type++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type, 0)
        && plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
      pass ();
    else
      fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] set+1 %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type);
    loftedsurface->plane_normal_lofting_type--;
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "point", &point, NULL)
        && !memcmp (&point, &loftedsurface->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("LOFTEDSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "point_present", &point_present, NULL)
        && point_present == loftedsurface->point_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "point_present", &point_present, 0)
        && point_present == loftedsurface->point_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->point_present, point_present);
    loftedsurface->point_present--;
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &loftedsurface->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("LOFTEDSURFACE.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &loftedsurface->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("LOFTEDSURFACE.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_major", &revision_major, NULL)
        && revision_major == loftedsurface->revision_major)
      pass ();
    else
      fail ("LOFTEDSURFACE.revision_major [BL] %u != %u", loftedsurface->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "revision_major", &revision_major, 0)
        && revision_major == loftedsurface->revision_major)
      pass ();
    else
      fail ("LOFTEDSURFACE.revision_major [BL] set+1 %u != %u", loftedsurface->revision_major, revision_major);
    loftedsurface->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == loftedsurface->revision_minor1)
      pass ();
    else
      fail ("LOFTEDSURFACE.revision_minor1 [BS] %hu != %hu", loftedsurface->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == loftedsurface->revision_minor1)
      pass ();
    else
      fail ("LOFTEDSURFACE.revision_minor1 [BS] set+1 %hu != %hu", loftedsurface->revision_minor1, revision_minor1);
    loftedsurface->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == loftedsurface->revision_minor2)
      pass ();
    else
      fail ("LOFTEDSURFACE.revision_minor2 [BS] %hu != %hu", loftedsurface->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == loftedsurface->revision_minor2)
      pass ();
    else
      fail ("LOFTEDSURFACE.revision_minor2 [BS] set+1 %hu != %hu", loftedsurface->revision_minor2, revision_minor2);
    loftedsurface->revision_minor2--;
  }
  {
    BITCODE_B ruled_surface;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface, NULL)
        && ruled_surface == loftedsurface->ruled_surface)
      pass ();
    else
      fail ("LOFTEDSURFACE.ruled_surface [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface);
    ruled_surface++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface, 0)
        && ruled_surface == loftedsurface->ruled_surface)
      pass ();
    else
      fail ("LOFTEDSURFACE.ruled_surface [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface);
    loftedsurface->ruled_surface--;
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "sab_size", &sab_size, NULL)
        && sab_size == loftedsurface->sab_size)
      pass ();
    else
      fail ("LOFTEDSURFACE.sab_size [BL] %u != %u", loftedsurface->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "sab_size", &sab_size, 0)
        && sab_size == loftedsurface->sab_size)
      pass ();
    else
      fail ("LOFTEDSURFACE.sab_size [BL] set+1 %u != %u", loftedsurface->sab_size, sab_size);
    loftedsurface->sab_size--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == loftedsurface->silhouettes)
      pass ();
    else
      fail ("LOFTEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B simple_surfaces;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces, NULL)
        && simple_surfaces == loftedsurface->simple_surfaces)
      pass ();
    else
      fail ("LOFTEDSURFACE.simple_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces);
    simple_surfaces++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces, 0)
        && simple_surfaces == loftedsurface->simple_surfaces)
      pass ();
    else
      fail ("LOFTEDSURFACE.simple_surfaces [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces);
    loftedsurface->simple_surfaces--;
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "solid", &solid, NULL)
        && solid == loftedsurface->solid)
      pass ();
    else
      fail ("LOFTEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid);
    solid++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "solid", &solid, 0)
        && solid == loftedsurface->solid)
      pass ();
    else
      fail ("LOFTEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid);
    loftedsurface->solid--;
  }
  {
    BITCODE_BD start_draft_angle;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle, NULL)
        && start_draft_angle == loftedsurface->start_draft_angle)
      pass ();
    else
      fail ("LOFTEDSURFACE.start_draft_angle [BD] %g != %g", loftedsurface->start_draft_angle, start_draft_angle);
    start_draft_angle++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle, 0)
        && start_draft_angle == loftedsurface->start_draft_angle)
      pass ();
    else
      fail ("LOFTEDSURFACE.start_draft_angle [BD] set+1 %g != %g", loftedsurface->start_draft_angle, start_draft_angle);
    loftedsurface->start_draft_angle--;
  }
  {
    BITCODE_BD start_draft_magnitude;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude, NULL)
        && start_draft_magnitude == loftedsurface->start_draft_magnitude)
      pass ();
    else
      fail ("LOFTEDSURFACE.start_draft_magnitude [BD] %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude);
    start_draft_magnitude++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude, 0)
        && start_draft_magnitude == loftedsurface->start_draft_magnitude)
      pass ();
    else
      fail ("LOFTEDSURFACE.start_draft_magnitude [BD] set+1 %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude);
    loftedsurface->start_draft_magnitude--;
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == loftedsurface->u_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.u_isolines [BS] %hu != %hu", loftedsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == loftedsurface->u_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.u_isolines [BS] set+1 %hu != %hu", loftedsurface->u_isolines, u_isolines);
    loftedsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "unknown", &unknown, NULL)
        && unknown == loftedsurface->unknown)
      pass ();
    else
      fail ("LOFTEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "unknown", &unknown, 0)
        && unknown == loftedsurface->unknown)
      pass ();
    else
      fail ("LOFTEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->unknown, unknown);
    loftedsurface->unknown--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == loftedsurface->v_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.v_isolines [BS] %hu != %hu", loftedsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == loftedsurface->v_isolines)
      pass ();
    else
      fail ("LOFTEDSURFACE.v_isolines [BS] set+1 %hu != %hu", loftedsurface->v_isolines, v_isolines);
    loftedsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "version", &version, NULL)
        && version == loftedsurface->version)
      pass ();
    else
      fail ("LOFTEDSURFACE.version [BS] %hu != %hu", loftedsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "version", &version, 0)
        && version == loftedsurface->version)
      pass ();
    else
      fail ("LOFTEDSURFACE.version [BS] set+1 %hu != %hu", loftedsurface->version, version);
    loftedsurface->version--;
  }
  {
    BITCODE_B virtual_guide;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide, NULL)
        && virtual_guide == loftedsurface->virtual_guide)
      pass ();
    else
      fail ("LOFTEDSURFACE.virtual_guide [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide);
    virtual_guide++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide, 0)
        && virtual_guide == loftedsurface->virtual_guide)
      pass ();
    else
      fail ("LOFTEDSURFACE.virtual_guide [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide);
    loftedsurface->virtual_guide--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == loftedsurface->wireframe_data_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == loftedsurface->wireframe_data_present)
      pass ();
    else
      fail ("LOFTEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->wireframe_data_present, wireframe_data_present);
    loftedsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "wires", &wires, NULL)
        && wires == loftedsurface->wires)
      pass ();
    else
      fail ("LOFTEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("LOFTEDSURFACE") || is_class_debugging ("LOFTEDSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LOFTEDSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_LWPOLYLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_LWPOLYLINE *restrict lwpolyline = obj->tio.entity->tio.LWPOLYLINE;
  failed = 0;
  if (!obj_obj || !lwpolyline)
    {
      fail ("NULL LWPOLYLINE");
      return 1;
    }
  {
    BITCODE_BD* bulges;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_bulges", &count, NULL)
        && dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "bulges", &bulges, NULL)
        && bulges == lwpolyline->bulges)
      pass ();
    else
      fail ("LWPOLYLINE.bulges [BD*] * %u num_bulges", count);
  }
  {
    BITCODE_BD const_width;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "const_width", &const_width, NULL)
        && const_width == lwpolyline->const_width)
      pass ();
    else
      fail ("LWPOLYLINE.const_width [BD] %g != %g", lwpolyline->const_width, const_width);
    const_width++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "const_width", &const_width, 0)
        && const_width == lwpolyline->const_width)
      pass ();
    else
      fail ("LWPOLYLINE.const_width [BD] set+1 %g != %g", lwpolyline->const_width, const_width);
    lwpolyline->const_width--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "elevation", &elevation, NULL)
        && elevation == lwpolyline->elevation)
      pass ();
    else
      fail ("LWPOLYLINE.elevation [BD] %g != %g", lwpolyline->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "elevation", &elevation, 0)
        && elevation == lwpolyline->elevation)
      pass ();
    else
      fail ("LWPOLYLINE.elevation [BD] set+1 %g != %g", lwpolyline->elevation, elevation);
    lwpolyline->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &lwpolyline->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("LWPOLYLINE.extrusion [BE]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "flag", &flag, NULL)
        && flag == lwpolyline->flag)
      pass ();
    else
      fail ("LWPOLYLINE.flag [BS] %hu != %hu", lwpolyline->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "flag", &flag, 0)
        && flag == lwpolyline->flag)
      pass ();
    else
      fail ("LWPOLYLINE.flag [BS] set+1 %hu != %hu", lwpolyline->flag, flag);
    lwpolyline->flag--;
  }
  {
    BITCODE_BL num_bulges;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_bulges", &num_bulges, NULL)
        && num_bulges == lwpolyline->num_bulges)
      pass ();
    else
      fail ("LWPOLYLINE.num_bulges [BL] %u != %u", lwpolyline->num_bulges, num_bulges);
    num_bulges++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "num_bulges", &num_bulges, 0)
        && num_bulges == lwpolyline->num_bulges)
      pass ();
    else
      fail ("LWPOLYLINE.num_bulges [BL] set+1 %u != %u", lwpolyline->num_bulges, num_bulges);
    lwpolyline->num_bulges--;
  }
  {
    BITCODE_BL num_points;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_points", &num_points, NULL)
        && num_points == lwpolyline->num_points)
      pass ();
    else
      fail ("LWPOLYLINE.num_points [BL] %u != %u", lwpolyline->num_points, num_points);
    num_points++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "num_points", &num_points, 0)
        && num_points == lwpolyline->num_points)
      pass ();
    else
      fail ("LWPOLYLINE.num_points [BL] set+1 %u != %u", lwpolyline->num_points, num_points);
    lwpolyline->num_points--;
  }
  {
    BITCODE_BL num_vertexids;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_vertexids", &num_vertexids, NULL)
        && num_vertexids == lwpolyline->num_vertexids)
      pass ();
    else
      fail ("LWPOLYLINE.num_vertexids [BL] %u != %u", lwpolyline->num_vertexids, num_vertexids);
    num_vertexids++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "num_vertexids", &num_vertexids, 0)
        && num_vertexids == lwpolyline->num_vertexids)
      pass ();
    else
      fail ("LWPOLYLINE.num_vertexids [BL] set+1 %u != %u", lwpolyline->num_vertexids, num_vertexids);
    lwpolyline->num_vertexids--;
  }
  {
    BITCODE_BL num_widths;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_widths", &num_widths, NULL)
        && num_widths == lwpolyline->num_widths)
      pass ();
    else
      fail ("LWPOLYLINE.num_widths [BL] %u != %u", lwpolyline->num_widths, num_widths);
    num_widths++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "num_widths", &num_widths, 0)
        && num_widths == lwpolyline->num_widths)
      pass ();
    else
      fail ("LWPOLYLINE.num_widths [BL] set+1 %u != %u", lwpolyline->num_widths, num_widths);
    lwpolyline->num_widths--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "parent", &parent, NULL)
        && !memcmp (&parent, &lwpolyline->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("LWPOLYLINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD* points;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_points", &count, NULL)
        && dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "points", &points, NULL)
        && points == lwpolyline->points)
      pass ();
    else
      fail ("LWPOLYLINE.points [2RD*] * %u num_points", count);
  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "thickness", &thickness, NULL)
        && thickness == lwpolyline->thickness)
      pass ();
    else
      fail ("LWPOLYLINE.thickness [BD] %g != %g", lwpolyline->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (lwpolyline, "LWPOLYLINE", "thickness", &thickness, 0)
        && thickness == lwpolyline->thickness)
      pass ();
    else
      fail ("LWPOLYLINE.thickness [BD] set+1 %g != %g", lwpolyline->thickness, thickness);
    lwpolyline->thickness--;
  }
  {
    BITCODE_BL* vertexids;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_vertexids", &count, NULL)
        && dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "vertexids", &vertexids, NULL)
        && vertexids == lwpolyline->vertexids)
      pass ();
    else
      fail ("LWPOLYLINE.vertexids [BL*] * %u num_vertexids", count);
  }
  {
    Dwg_LWPOLYLINE_width* widths;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "num_widths", &count, NULL)
        && dwg_dynapi_entity_value (lwpolyline, "LWPOLYLINE", "widths", &widths, NULL)
        && widths == lwpolyline->widths)
      pass ();
    else
      fail ("LWPOLYLINE.widths [Dwg_LWPOLYLINE_width*] * %u num_widths", count);
  }
  if (failed && (is_class_unstable ("LWPOLYLINE") || is_class_debugging ("LWPOLYLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LWPOLYLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_MESH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MESH *restrict mesh = obj->tio.entity->tio.MESH;
  failed = 0;
  if (!obj_obj || !mesh)
    {
      fail ("NULL MESH");
      return 1;
    }
  {
    BITCODE_BD* crease;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_crease", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "crease", &crease, NULL)
        && crease == mesh->crease)
      pass ();
    else
      fail ("MESH.crease [BD*] * %u num_crease", count);
  }
  {
    BITCODE_BS dlevel;
    if (dwg_dynapi_entity_value (mesh, "MESH", "dlevel", &dlevel, NULL)
        && dlevel == mesh->dlevel)
      pass ();
    else
      fail ("MESH.dlevel [BS] %hu != %hu", mesh->dlevel, dlevel);
    dlevel++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "dlevel", &dlevel, 0)
        && dlevel == mesh->dlevel)
      pass ();
    else
      fail ("MESH.dlevel [BS] set+1 %hu != %hu", mesh->dlevel, dlevel);
    mesh->dlevel--;
  }
  {
    Dwg_MESH_edge* edges;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_edges", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "edges", &edges, NULL)
        && edges == mesh->edges)
      pass ();
    else
      fail ("MESH.edges [Dwg_MESH_edge*] * %u num_edges", count);
  }
  {
    BITCODE_BL* faces;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_faces", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "faces", &faces, NULL)
        && faces == mesh->faces)
      pass ();
    else
      fail ("MESH.faces [BL*] * %u num_faces", count);
  }
  {
    BITCODE_B is_watertight;
    if (dwg_dynapi_entity_value (mesh, "MESH", "is_watertight", &is_watertight, NULL)
        && is_watertight == mesh->is_watertight)
      pass ();
    else
      fail ("MESH.is_watertight [B] " FORMAT_B " != " FORMAT_B "", mesh->is_watertight, is_watertight);
    is_watertight++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "is_watertight", &is_watertight, 0)
        && is_watertight == mesh->is_watertight)
      pass ();
    else
      fail ("MESH.is_watertight [B] set+1 " FORMAT_B " != " FORMAT_B "", mesh->is_watertight, is_watertight);
    mesh->is_watertight--;
  }
  {
    BITCODE_BL num_crease;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_crease", &num_crease, NULL)
        && num_crease == mesh->num_crease)
      pass ();
    else
      fail ("MESH.num_crease [BL] %u != %u", mesh->num_crease, num_crease);
    num_crease++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_crease", &num_crease, 0)
        && num_crease == mesh->num_crease)
      pass ();
    else
      fail ("MESH.num_crease [BL] set+1 %u != %u", mesh->num_crease, num_crease);
    mesh->num_crease--;
  }
  {
    BITCODE_BL num_edges;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_edges", &num_edges, NULL)
        && num_edges == mesh->num_edges)
      pass ();
    else
      fail ("MESH.num_edges [BL] %u != %u", mesh->num_edges, num_edges);
    num_edges++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_edges", &num_edges, 0)
        && num_edges == mesh->num_edges)
      pass ();
    else
      fail ("MESH.num_edges [BL] set+1 %u != %u", mesh->num_edges, num_edges);
    mesh->num_edges--;
  }
  {
    BITCODE_BL num_faces;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_faces", &num_faces, NULL)
        && num_faces == mesh->num_faces)
      pass ();
    else
      fail ("MESH.num_faces [BL] %u != %u", mesh->num_faces, num_faces);
    num_faces++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_faces", &num_faces, 0)
        && num_faces == mesh->num_faces)
      pass ();
    else
      fail ("MESH.num_faces [BL] set+1 %u != %u", mesh->num_faces, num_faces);
    mesh->num_faces--;
  }
  {
    BITCODE_BL num_subdiv_vertex;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_subdiv_vertex", &num_subdiv_vertex, NULL)
        && num_subdiv_vertex == mesh->num_subdiv_vertex)
      pass ();
    else
      fail ("MESH.num_subdiv_vertex [BL] %u != %u", mesh->num_subdiv_vertex, num_subdiv_vertex);
    num_subdiv_vertex++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_subdiv_vertex", &num_subdiv_vertex, 0)
        && num_subdiv_vertex == mesh->num_subdiv_vertex)
      pass ();
    else
      fail ("MESH.num_subdiv_vertex [BL] set+1 %u != %u", mesh->num_subdiv_vertex, num_subdiv_vertex);
    mesh->num_subdiv_vertex--;
  }
  {
    BITCODE_BL num_vertex;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_vertex", &num_vertex, NULL)
        && num_vertex == mesh->num_vertex)
      pass ();
    else
      fail ("MESH.num_vertex [BL] %u != %u", mesh->num_vertex, num_vertex);
    num_vertex++;
    if (dwg_dynapi_entity_set_value (mesh, "MESH", "num_vertex", &num_vertex, 0)
        && num_vertex == mesh->num_vertex)
      pass ();
    else
      fail ("MESH.num_vertex [BL] set+1 %u != %u", mesh->num_vertex, num_vertex);
    mesh->num_vertex--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (mesh, "MESH", "parent", &parent, NULL)
        && !memcmp (&parent, &mesh->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("MESH.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3DPOINT* subdiv_vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_subdiv_vertex", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "subdiv_vertex", &subdiv_vertex, NULL)
        && subdiv_vertex == mesh->subdiv_vertex)
      pass ();
    else
      fail ("MESH.subdiv_vertex [3DPOINT*] * %u num_subdiv_vertex", count);
  }
  {
    BITCODE_3DPOINT* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mesh, "MESH", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (mesh, "MESH", "vertex", &vertex, NULL)
        && vertex == mesh->vertex)
      pass ();
    else
      fail ("MESH.vertex [3DPOINT*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("MESH") || is_class_debugging ("MESH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MESH", failed);
      failed = 0;
    }
  return failed;
}
static int test_MINSERT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MINSERT *restrict minsert = obj->tio.entity->tio.MINSERT;
  failed = 0;
  if (!obj_obj || !minsert)
    {
      fail ("NULL MINSERT");
      return 1;
    }
  {
    BITCODE_H* attribs;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (minsert, "MINSERT", "attribs", &attribs, NULL)
        && attribs == minsert->attribs)
      pass ();
    else
      fail ("MINSERT.attribs [H*] * %u num_owned", count);
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "block_header", &block_header, NULL)
        && !memcmp (&block_header, &minsert->block_header, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MINSERT.block_header [H]");
  }
  {
    BITCODE_BD col_spacing;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "col_spacing", &col_spacing, NULL)
        && col_spacing == minsert->col_spacing)
      pass ();
    else
      fail ("MINSERT.col_spacing [BD] %g != %g", minsert->col_spacing, col_spacing);
    col_spacing++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "col_spacing", &col_spacing, 0)
        && col_spacing == minsert->col_spacing)
      pass ();
    else
      fail ("MINSERT.col_spacing [BD] set+1 %g != %g", minsert->col_spacing, col_spacing);
    minsert->col_spacing--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &minsert->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("MINSERT.extrusion [BE]");
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "first_attrib", &first_attrib, NULL)
        && !memcmp (&first_attrib, &minsert->first_attrib, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MINSERT.first_attrib [H]");
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "has_attribs", &has_attribs, NULL)
        && has_attribs == minsert->has_attribs)
      pass ();
    else
      fail ("MINSERT.has_attribs [B] " FORMAT_B " != " FORMAT_B "", minsert->has_attribs, has_attribs);
    has_attribs++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "has_attribs", &has_attribs, 0)
        && has_attribs == minsert->has_attribs)
      pass ();
    else
      fail ("MINSERT.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", minsert->has_attribs, has_attribs);
    minsert->has_attribs--;
  }
  {
    BITCODE_3DPOINT ins_pt;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &minsert->ins_pt, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("MINSERT.ins_pt [3DPOINT]");
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "last_attrib", &last_attrib, NULL)
        && !memcmp (&last_attrib, &minsert->last_attrib, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MINSERT.last_attrib [H]");
  }
  {
    BITCODE_BS num_cols;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "num_cols", &num_cols, NULL)
        && num_cols == minsert->num_cols)
      pass ();
    else
      fail ("MINSERT.num_cols [BS] %hu != %hu", minsert->num_cols, num_cols);
    num_cols++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "num_cols", &num_cols, 0)
        && num_cols == minsert->num_cols)
      pass ();
    else
      fail ("MINSERT.num_cols [BS] set+1 %hu != %hu", minsert->num_cols, num_cols);
    minsert->num_cols--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "num_owned", &num_owned, NULL)
        && num_owned == minsert->num_owned)
      pass ();
    else
      fail ("MINSERT.num_owned [BL] %u != %u", minsert->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "num_owned", &num_owned, 0)
        && num_owned == minsert->num_owned)
      pass ();
    else
      fail ("MINSERT.num_owned [BL] set+1 %u != %u", minsert->num_owned, num_owned);
    minsert->num_owned--;
  }
  {
    BITCODE_BS num_rows;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "num_rows", &num_rows, NULL)
        && num_rows == minsert->num_rows)
      pass ();
    else
      fail ("MINSERT.num_rows [BS] %hu != %hu", minsert->num_rows, num_rows);
    num_rows++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "num_rows", &num_rows, 0)
        && num_rows == minsert->num_rows)
      pass ();
    else
      fail ("MINSERT.num_rows [BS] set+1 %hu != %hu", minsert->num_rows, num_rows);
    minsert->num_rows--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "parent", &parent, NULL)
        && !memcmp (&parent, &minsert->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("MINSERT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "rotation", &rotation, NULL)
        && rotation == minsert->rotation)
      pass ();
    else
      fail ("MINSERT.rotation [BD] %g != %g", minsert->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "rotation", &rotation, 0)
        && rotation == minsert->rotation)
      pass ();
    else
      fail ("MINSERT.rotation [BD] set+1 %g != %g", minsert->rotation, rotation);
    minsert->rotation--;
  }
  {
    BITCODE_BD row_spacing;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "row_spacing", &row_spacing, NULL)
        && row_spacing == minsert->row_spacing)
      pass ();
    else
      fail ("MINSERT.row_spacing [BD] %g != %g", minsert->row_spacing, row_spacing);
    row_spacing++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "row_spacing", &row_spacing, 0)
        && row_spacing == minsert->row_spacing)
      pass ();
    else
      fail ("MINSERT.row_spacing [BD] set+1 %g != %g", minsert->row_spacing, row_spacing);
    minsert->row_spacing--;
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "scale", &scale, NULL)
        && !memcmp (&scale, &minsert->scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("MINSERT.scale [3BD_1]");
  }
  {
    BITCODE_BB scale_flag;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "scale_flag", &scale_flag, NULL)
        && scale_flag == minsert->scale_flag)
      pass ();
    else
      fail ("MINSERT.scale_flag [BB] " FORMAT_BB " != " FORMAT_BB "", minsert->scale_flag, scale_flag);
    scale_flag++;
    if (dwg_dynapi_entity_set_value (minsert, "MINSERT", "scale_flag", &scale_flag, 0)
        && scale_flag == minsert->scale_flag)
      pass ();
    else
      fail ("MINSERT.scale_flag [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", minsert->scale_flag, scale_flag);
    minsert->scale_flag--;
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (minsert, "MINSERT", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &minsert->seqend, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MINSERT.seqend [H]");
  }
  if (failed && (is_class_unstable ("MINSERT") || is_class_debugging ("MINSERT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MINSERT", failed);
      failed = 0;
    }
  return failed;
}
static int test_MLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MLINE *restrict mline = obj->tio.entity->tio.MLINE;
  failed = 0;
  if (!obj_obj || !mline)
    {
      fail ("NULL MLINE");
      return 1;
    }
  {
    BITCODE_3BD base_point;
    if (dwg_dynapi_entity_value (mline, "MLINE", "base_point", &base_point, NULL)
        && !memcmp (&base_point, &mline->base_point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("MLINE.base_point [3BD]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (mline, "MLINE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &mline->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("MLINE.extrusion [BE]");
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value (mline, "MLINE", "flags", &flags, NULL)
        && flags == mline->flags)
      pass ();
    else
      fail ("MLINE.flags [BS] %hu != %hu", mline->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "flags", &flags, 0)
        && flags == mline->flags)
      pass ();
    else
      fail ("MLINE.flags [BS] set+1 %hu != %hu", mline->flags, flags);
    mline->flags--;
  }
  {
    BITCODE_RC justification;
    if (dwg_dynapi_entity_value (mline, "MLINE", "justification", &justification, NULL)
        && justification == mline->justification)
      pass ();
    else
      fail ("MLINE.justification [RC] %u != %u", mline->justification, justification);
    justification++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "justification", &justification, 0)
        && justification == mline->justification)
      pass ();
    else
      fail ("MLINE.justification [RC] set+1 %u != %u", mline->justification, justification);
    mline->justification--;
  }
  {
    BITCODE_H mlinestyle;
    if (dwg_dynapi_entity_value (mline, "MLINE", "mlinestyle", &mlinestyle, NULL)
        && !memcmp (&mlinestyle, &mline->mlinestyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MLINE.mlinestyle [H]");
  }
  {
    BITCODE_RC num_lines;
    if (dwg_dynapi_entity_value (mline, "MLINE", "num_lines", &num_lines, NULL)
        && num_lines == mline->num_lines)
      pass ();
    else
      fail ("MLINE.num_lines [RC] %u != %u", mline->num_lines, num_lines);
    num_lines++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "num_lines", &num_lines, 0)
        && num_lines == mline->num_lines)
      pass ();
    else
      fail ("MLINE.num_lines [RC] set+1 %u != %u", mline->num_lines, num_lines);
    mline->num_lines--;
  }
  {
    BITCODE_BS num_verts;
    if (dwg_dynapi_entity_value (mline, "MLINE", "num_verts", &num_verts, NULL)
        && num_verts == mline->num_verts)
      pass ();
    else
      fail ("MLINE.num_verts [BS] %hu != %hu", mline->num_verts, num_verts);
    num_verts++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "num_verts", &num_verts, 0)
        && num_verts == mline->num_verts)
      pass ();
    else
      fail ("MLINE.num_verts [BS] set+1 %hu != %hu", mline->num_verts, num_verts);
    mline->num_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (mline, "MLINE", "parent", &parent, NULL)
        && !memcmp (&parent, &mline->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("MLINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value (mline, "MLINE", "scale", &scale, NULL)
        && scale == mline->scale)
      pass ();
    else
      fail ("MLINE.scale [BD] %g != %g", mline->scale, scale);
    scale++;
    if (dwg_dynapi_entity_set_value (mline, "MLINE", "scale", &scale, 0)
        && scale == mline->scale)
      pass ();
    else
      fail ("MLINE.scale [BD] set+1 %g != %g", mline->scale, scale);
    mline->scale--;
  }
  {
    Dwg_MLINE_vertex* verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mline, "MLINE", "num_verts", &count, NULL)
        && dwg_dynapi_entity_value (mline, "MLINE", "verts", &verts, NULL)
        && verts == mline->verts)
      pass ();
    else
      fail ("MLINE.verts [Dwg_MLINE_vertex*] * %u num_verts", count);
  }
  if (failed && (is_class_unstable ("MLINE") || is_class_debugging ("MLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_MPOLYGON (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MPOLYGON *restrict mpolygon = obj->tio.entity->tio.MPOLYGON;
  failed = 0;
  if (!obj_obj || !mpolygon)
    {
      fail ("NULL MPOLYGON");
      return 1;
    }
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "angle", &angle, NULL)
        && angle == mpolygon->angle)
      pass ();
    else
      fail ("MPOLYGON.angle [BD] %g != %g", mpolygon->angle, angle);
    angle++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "angle", &angle, 0)
        && angle == mpolygon->angle)
      pass ();
    else
      fail ("MPOLYGON.angle [BD] set+1 %g != %g", mpolygon->angle, angle);
    mpolygon->angle--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "color", &color, NULL)
        && !memcmp (&color, &mpolygon->color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MPOLYGON.color [CMC]");
  }
  {
    Dwg_HATCH_Color* colors;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "num_colors", &count, NULL)
        && dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "colors", &colors, NULL)
        && colors == mpolygon->colors)
      pass ();
    else
      fail ("MPOLYGON.colors [Dwg_HATCH_Color*] * %u num_colors", count);
  }
  {
    Dwg_HATCH_DefLine* deflines;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "num_deflines", &count, NULL)
        && dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "deflines", &deflines, NULL)
        && deflines == mpolygon->deflines)
      pass ();
    else
      fail ("MPOLYGON.deflines [Dwg_HATCH_DefLine*] * %u num_deflines", count);
  }
  {
    BITCODE_B double_flag;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "double_flag", &double_flag, NULL)
        && double_flag == mpolygon->double_flag)
      pass ();
    else
      fail ("MPOLYGON.double_flag [B] " FORMAT_B " != " FORMAT_B "", mpolygon->double_flag, double_flag);
    double_flag++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "double_flag", &double_flag, 0)
        && double_flag == mpolygon->double_flag)
      pass ();
    else
      fail ("MPOLYGON.double_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", mpolygon->double_flag, double_flag);
    mpolygon->double_flag--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "elevation", &elevation, NULL)
        && elevation == mpolygon->elevation)
      pass ();
    else
      fail ("MPOLYGON.elevation [BD] %g != %g", mpolygon->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "elevation", &elevation, 0)
        && elevation == mpolygon->elevation)
      pass ();
    else
      fail ("MPOLYGON.elevation [BD] set+1 %g != %g", mpolygon->elevation, elevation);
    mpolygon->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &mpolygon->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("MPOLYGON.extrusion [BE]");
  }
  {
    BITCODE_BD gradient_angle;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "gradient_angle", &gradient_angle, NULL)
        && gradient_angle == mpolygon->gradient_angle)
      pass ();
    else
      fail ("MPOLYGON.gradient_angle [BD] %g != %g", mpolygon->gradient_angle, gradient_angle);
    gradient_angle++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "gradient_angle", &gradient_angle, 0)
        && gradient_angle == mpolygon->gradient_angle)
      pass ();
    else
      fail ("MPOLYGON.gradient_angle [BD] set+1 %g != %g", mpolygon->gradient_angle, gradient_angle);
    mpolygon->gradient_angle--;
  }
  {
    BITCODE_T gradient_name;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "gradient_name", &gradient_name, NULL)
        && gradient_name
           ? strEQ ((char *)gradient_name, (char *)mpolygon->gradient_name)
           : !mpolygon->gradient_name)
      pass ();
    else
      fail ("MPOLYGON.gradient_name [T] '%s' <> '%s'", gradient_name, mpolygon->gradient_name);
  }
  {
    BITCODE_BD gradient_shift;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "gradient_shift", &gradient_shift, NULL)
        && gradient_shift == mpolygon->gradient_shift)
      pass ();
    else
      fail ("MPOLYGON.gradient_shift [BD] %g != %g", mpolygon->gradient_shift, gradient_shift);
    gradient_shift++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "gradient_shift", &gradient_shift, 0)
        && gradient_shift == mpolygon->gradient_shift)
      pass ();
    else
      fail ("MPOLYGON.gradient_shift [BD] set+1 %g != %g", mpolygon->gradient_shift, gradient_shift);
    mpolygon->gradient_shift--;
  }
  {
    BITCODE_BD gradient_tint;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "gradient_tint", &gradient_tint, NULL)
        && gradient_tint == mpolygon->gradient_tint)
      pass ();
    else
      fail ("MPOLYGON.gradient_tint [BD] %g != %g", mpolygon->gradient_tint, gradient_tint);
    gradient_tint++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "gradient_tint", &gradient_tint, 0)
        && gradient_tint == mpolygon->gradient_tint)
      pass ();
    else
      fail ("MPOLYGON.gradient_tint [BD] set+1 %g != %g", mpolygon->gradient_tint, gradient_tint);
    mpolygon->gradient_tint--;
  }
  {
    BITCODE_B is_associative;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "is_associative", &is_associative, NULL)
        && is_associative == mpolygon->is_associative)
      pass ();
    else
      fail ("MPOLYGON.is_associative [B] " FORMAT_B " != " FORMAT_B "", mpolygon->is_associative, is_associative);
    is_associative++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "is_associative", &is_associative, 0)
        && is_associative == mpolygon->is_associative)
      pass ();
    else
      fail ("MPOLYGON.is_associative [B] set+1 " FORMAT_B " != " FORMAT_B "", mpolygon->is_associative, is_associative);
    mpolygon->is_associative--;
  }
  {
    BITCODE_BL is_gradient_fill;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "is_gradient_fill", &is_gradient_fill, NULL)
        && is_gradient_fill == mpolygon->is_gradient_fill)
      pass ();
    else
      fail ("MPOLYGON.is_gradient_fill [BL] %u != %u", mpolygon->is_gradient_fill, is_gradient_fill);
    is_gradient_fill++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "is_gradient_fill", &is_gradient_fill, 0)
        && is_gradient_fill == mpolygon->is_gradient_fill)
      pass ();
    else
      fail ("MPOLYGON.is_gradient_fill [BL] set+1 %u != %u", mpolygon->is_gradient_fill, is_gradient_fill);
    mpolygon->is_gradient_fill--;
  }
  {
    BITCODE_B is_solid_fill;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "is_solid_fill", &is_solid_fill, NULL)
        && is_solid_fill == mpolygon->is_solid_fill)
      pass ();
    else
      fail ("MPOLYGON.is_solid_fill [B] " FORMAT_B " != " FORMAT_B "", mpolygon->is_solid_fill, is_solid_fill);
    is_solid_fill++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "is_solid_fill", &is_solid_fill, 0)
        && is_solid_fill == mpolygon->is_solid_fill)
      pass ();
    else
      fail ("MPOLYGON.is_solid_fill [B] set+1 " FORMAT_B " != " FORMAT_B "", mpolygon->is_solid_fill, is_solid_fill);
    mpolygon->is_solid_fill--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)mpolygon->name)
           : !mpolygon->name)
      pass ();
    else
      fail ("MPOLYGON.name [T] '%s' <> '%s'", name, mpolygon->name);
  }
  {
    BITCODE_BL num_boundary_handles;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "num_boundary_handles", &num_boundary_handles, NULL)
        && num_boundary_handles == mpolygon->num_boundary_handles)
      pass ();
    else
      fail ("MPOLYGON.num_boundary_handles [BL] %u != %u", mpolygon->num_boundary_handles, num_boundary_handles);
    num_boundary_handles++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "num_boundary_handles", &num_boundary_handles, 0)
        && num_boundary_handles == mpolygon->num_boundary_handles)
      pass ();
    else
      fail ("MPOLYGON.num_boundary_handles [BL] set+1 %u != %u", mpolygon->num_boundary_handles, num_boundary_handles);
    mpolygon->num_boundary_handles--;
  }
  {
    BITCODE_BL num_colors;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "num_colors", &num_colors, NULL)
        && num_colors == mpolygon->num_colors)
      pass ();
    else
      fail ("MPOLYGON.num_colors [BL] %u != %u", mpolygon->num_colors, num_colors);
    num_colors++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "num_colors", &num_colors, 0)
        && num_colors == mpolygon->num_colors)
      pass ();
    else
      fail ("MPOLYGON.num_colors [BL] set+1 %u != %u", mpolygon->num_colors, num_colors);
    mpolygon->num_colors--;
  }
  {
    BITCODE_BS num_deflines;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "num_deflines", &num_deflines, NULL)
        && num_deflines == mpolygon->num_deflines)
      pass ();
    else
      fail ("MPOLYGON.num_deflines [BS] %hu != %hu", mpolygon->num_deflines, num_deflines);
    num_deflines++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "num_deflines", &num_deflines, 0)
        && num_deflines == mpolygon->num_deflines)
      pass ();
    else
      fail ("MPOLYGON.num_deflines [BS] set+1 %hu != %hu", mpolygon->num_deflines, num_deflines);
    mpolygon->num_deflines--;
  }
  {
    BITCODE_BL num_paths;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "num_paths", &num_paths, NULL)
        && num_paths == mpolygon->num_paths)
      pass ();
    else
      fail ("MPOLYGON.num_paths [BL] %u != %u", mpolygon->num_paths, num_paths);
    num_paths++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "num_paths", &num_paths, 0)
        && num_paths == mpolygon->num_paths)
      pass ();
    else
      fail ("MPOLYGON.num_paths [BL] set+1 %u != %u", mpolygon->num_paths, num_paths);
    mpolygon->num_paths--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "parent", &parent, NULL)
        && !memcmp (&parent, &mpolygon->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("MPOLYGON.parent [struct _dwg_object_entity*]");
  }
  {
    Dwg_HATCH_Path* paths;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "num_paths", &count, NULL)
        && dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "paths", &paths, NULL)
        && paths == mpolygon->paths)
      pass ();
    else
      fail ("MPOLYGON.paths [Dwg_HATCH_Path*] * %u num_paths", count);
  }
  {
    BITCODE_BS pattern_type;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "pattern_type", &pattern_type, NULL)
        && pattern_type == mpolygon->pattern_type)
      pass ();
    else
      fail ("MPOLYGON.pattern_type [BS] %hu != %hu", mpolygon->pattern_type, pattern_type);
    pattern_type++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "pattern_type", &pattern_type, 0)
        && pattern_type == mpolygon->pattern_type)
      pass ();
    else
      fail ("MPOLYGON.pattern_type [BS] set+1 %hu != %hu", mpolygon->pattern_type, pattern_type);
    mpolygon->pattern_type--;
  }
  {
    BITCODE_BL reserved;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "reserved", &reserved, NULL)
        && reserved == mpolygon->reserved)
      pass ();
    else
      fail ("MPOLYGON.reserved [BL] %u != %u", mpolygon->reserved, reserved);
    reserved++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "reserved", &reserved, 0)
        && reserved == mpolygon->reserved)
      pass ();
    else
      fail ("MPOLYGON.reserved [BL] set+1 %u != %u", mpolygon->reserved, reserved);
    mpolygon->reserved--;
  }
  {
    BITCODE_BD scale_spacing;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "scale_spacing", &scale_spacing, NULL)
        && scale_spacing == mpolygon->scale_spacing)
      pass ();
    else
      fail ("MPOLYGON.scale_spacing [BD] %g != %g", mpolygon->scale_spacing, scale_spacing);
    scale_spacing++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "scale_spacing", &scale_spacing, 0)
        && scale_spacing == mpolygon->scale_spacing)
      pass ();
    else
      fail ("MPOLYGON.scale_spacing [BD] set+1 %g != %g", mpolygon->scale_spacing, scale_spacing);
    mpolygon->scale_spacing--;
  }
  {
    BITCODE_BL single_color_gradient;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "single_color_gradient", &single_color_gradient, NULL)
        && single_color_gradient == mpolygon->single_color_gradient)
      pass ();
    else
      fail ("MPOLYGON.single_color_gradient [BL] %u != %u", mpolygon->single_color_gradient, single_color_gradient);
    single_color_gradient++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "single_color_gradient", &single_color_gradient, 0)
        && single_color_gradient == mpolygon->single_color_gradient)
      pass ();
    else
      fail ("MPOLYGON.single_color_gradient [BL] set+1 %u != %u", mpolygon->single_color_gradient, single_color_gradient);
    mpolygon->single_color_gradient--;
  }
  {
    BITCODE_BS style;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "style", &style, NULL)
        && style == mpolygon->style)
      pass ();
    else
      fail ("MPOLYGON.style [BS] %hu != %hu", mpolygon->style, style);
    style++;
    if (dwg_dynapi_entity_set_value (mpolygon, "MPOLYGON", "style", &style, 0)
        && style == mpolygon->style)
      pass ();
    else
      fail ("MPOLYGON.style [BS] set+1 %hu != %hu", mpolygon->style, style);
    mpolygon->style--;
  }
  {
    BITCODE_2RD x_dir;
    if (dwg_dynapi_entity_value (mpolygon, "MPOLYGON", "x_dir", &x_dir, NULL)
        && !memcmp (&x_dir, &mpolygon->x_dir, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("MPOLYGON.x_dir [2RD]");
  }
  if (failed && (is_class_unstable ("MPOLYGON") || is_class_debugging ("MPOLYGON")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MPOLYGON", failed);
      failed = 0;
    }
  return failed;
}
static int test_MTEXT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MTEXT *restrict mtext = obj->tio.entity->tio.MTEXT;
  failed = 0;
  if (!obj_obj || !mtext)
    {
      fail ("NULL MTEXT");
      return 1;
    }
  {
    BITCODE_H appid;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "appid", &appid, NULL)
        && !memcmp (&appid, &mtext->appid, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MTEXT.appid [H]");
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "attachment", &attachment, NULL)
        && attachment == mtext->attachment)
      pass ();
    else
      fail ("MTEXT.attachment [BS] %hu != %hu", mtext->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "attachment", &attachment, 0)
        && attachment == mtext->attachment)
      pass ();
    else
      fail ("MTEXT.attachment [BS] set+1 %hu != %hu", mtext->attachment, attachment);
    mtext->attachment--;
  }
  {
    BITCODE_B auto_height;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "auto_height", &auto_height, NULL)
        && auto_height == mtext->auto_height)
      pass ();
    else
      fail ("MTEXT.auto_height [B] " FORMAT_B " != " FORMAT_B "", mtext->auto_height, auto_height);
    auto_height++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "auto_height", &auto_height, 0)
        && auto_height == mtext->auto_height)
      pass ();
    else
      fail ("MTEXT.auto_height [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->auto_height, auto_height);
    mtext->auto_height--;
  }
  {
    BITCODE_CMC bg_fill_color;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "bg_fill_color", &bg_fill_color, NULL)
        && !memcmp (&bg_fill_color, &mtext->bg_fill_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MTEXT.bg_fill_color [CMC]");
  }
  {
    BITCODE_BL bg_fill_flag;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "bg_fill_flag", &bg_fill_flag, NULL)
        && bg_fill_flag == mtext->bg_fill_flag)
      pass ();
    else
      fail ("MTEXT.bg_fill_flag [BL] %u != %u", mtext->bg_fill_flag, bg_fill_flag);
    bg_fill_flag++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "bg_fill_flag", &bg_fill_flag, 0)
        && bg_fill_flag == mtext->bg_fill_flag)
      pass ();
    else
      fail ("MTEXT.bg_fill_flag [BL] set+1 %u != %u", mtext->bg_fill_flag, bg_fill_flag);
    mtext->bg_fill_flag--;
  }
  {
    BITCODE_BL bg_fill_scale;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "bg_fill_scale", &bg_fill_scale, NULL)
        && bg_fill_scale == mtext->bg_fill_scale)
      pass ();
    else
      fail ("MTEXT.bg_fill_scale [BL] %u != %u", mtext->bg_fill_scale, bg_fill_scale);
    bg_fill_scale++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "bg_fill_scale", &bg_fill_scale, 0)
        && bg_fill_scale == mtext->bg_fill_scale)
      pass ();
    else
      fail ("MTEXT.bg_fill_scale [BL] set+1 %u != %u", mtext->bg_fill_scale, bg_fill_scale);
    mtext->bg_fill_scale--;
  }
  {
    BITCODE_BL bg_fill_trans;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "bg_fill_trans", &bg_fill_trans, NULL)
        && bg_fill_trans == mtext->bg_fill_trans)
      pass ();
    else
      fail ("MTEXT.bg_fill_trans [BL] %u != %u", mtext->bg_fill_trans, bg_fill_trans);
    bg_fill_trans++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "bg_fill_trans", &bg_fill_trans, 0)
        && bg_fill_trans == mtext->bg_fill_trans)
      pass ();
    else
      fail ("MTEXT.bg_fill_trans [BL] set+1 %u != %u", mtext->bg_fill_trans, bg_fill_trans);
    mtext->bg_fill_trans--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "class_version", &class_version, NULL)
        && class_version == mtext->class_version)
      pass ();
    else
      fail ("MTEXT.class_version [BS] %hu != %hu", mtext->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "class_version", &class_version, 0)
        && class_version == mtext->class_version)
      pass ();
    else
      fail ("MTEXT.class_version [BS] set+1 %hu != %hu", mtext->class_version, class_version);
    mtext->class_version--;
  }
  {
    BITCODE_BD* column_heights;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "num_column_heights", &count, NULL)
        && dwg_dynapi_entity_value (mtext, "MTEXT", "column_heights", &column_heights, NULL)
        && column_heights == mtext->column_heights)
      pass ();
    else
      fail ("MTEXT.column_heights [BD*] * %u num_column_heights", count);
  }
  {
    BITCODE_BS column_type;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "column_type", &column_type, NULL)
        && column_type == mtext->column_type)
      pass ();
    else
      fail ("MTEXT.column_type [BS] %hu != %hu", mtext->column_type, column_type);
    column_type++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "column_type", &column_type, 0)
        && column_type == mtext->column_type)
      pass ();
    else
      fail ("MTEXT.column_type [BS] set+1 %hu != %hu", mtext->column_type, column_type);
    mtext->column_type--;
  }
  {
    BITCODE_BD column_width;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "column_width", &column_width, NULL)
        && column_width == mtext->column_width)
      pass ();
    else
      fail ("MTEXT.column_width [BD] %g != %g", mtext->column_width, column_width);
    column_width++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "column_width", &column_width, 0)
        && column_width == mtext->column_width)
      pass ();
    else
      fail ("MTEXT.column_width [BD] set+1 %g != %g", mtext->column_width, column_width);
    mtext->column_width--;
  }
  {
    BITCODE_B default_flag;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "default_flag", &default_flag, NULL)
        && default_flag == mtext->default_flag)
      pass ();
    else
      fail ("MTEXT.default_flag [B] " FORMAT_B " != " FORMAT_B "", mtext->default_flag, default_flag);
    default_flag++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "default_flag", &default_flag, 0)
        && default_flag == mtext->default_flag)
      pass ();
    else
      fail ("MTEXT.default_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->default_flag, default_flag);
    mtext->default_flag--;
  }
  {
    BITCODE_BD extents_height;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "extents_height", &extents_height, NULL)
        && extents_height == mtext->extents_height)
      pass ();
    else
      fail ("MTEXT.extents_height [BD] %g != %g", mtext->extents_height, extents_height);
    extents_height++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "extents_height", &extents_height, 0)
        && extents_height == mtext->extents_height)
      pass ();
    else
      fail ("MTEXT.extents_height [BD] set+1 %g != %g", mtext->extents_height, extents_height);
    mtext->extents_height--;
  }
  {
    BITCODE_BD extents_width;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "extents_width", &extents_width, NULL)
        && extents_width == mtext->extents_width)
      pass ();
    else
      fail ("MTEXT.extents_width [BD] %g != %g", mtext->extents_width, extents_width);
    extents_width++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "extents_width", &extents_width, 0)
        && extents_width == mtext->extents_width)
      pass ();
    else
      fail ("MTEXT.extents_width [BD] set+1 %g != %g", mtext->extents_width, extents_width);
    mtext->extents_width--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &mtext->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("MTEXT.extrusion [BE]");
  }
  {
    BITCODE_BS flow_dir;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "flow_dir", &flow_dir, NULL)
        && flow_dir == mtext->flow_dir)
      pass ();
    else
      fail ("MTEXT.flow_dir [BS] %hu != %hu", mtext->flow_dir, flow_dir);
    flow_dir++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "flow_dir", &flow_dir, 0)
        && flow_dir == mtext->flow_dir)
      pass ();
    else
      fail ("MTEXT.flow_dir [BS] set+1 %hu != %hu", mtext->flow_dir, flow_dir);
    mtext->flow_dir--;
  }
  {
    BITCODE_B flow_reversed;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "flow_reversed", &flow_reversed, NULL)
        && flow_reversed == mtext->flow_reversed)
      pass ();
    else
      fail ("MTEXT.flow_reversed [B] " FORMAT_B " != " FORMAT_B "", mtext->flow_reversed, flow_reversed);
    flow_reversed++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "flow_reversed", &flow_reversed, 0)
        && flow_reversed == mtext->flow_reversed)
      pass ();
    else
      fail ("MTEXT.flow_reversed [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->flow_reversed, flow_reversed);
    mtext->flow_reversed--;
  }
  {
    BITCODE_BD gutter;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "gutter", &gutter, NULL)
        && gutter == mtext->gutter)
      pass ();
    else
      fail ("MTEXT.gutter [BD] %g != %g", mtext->gutter, gutter);
    gutter++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "gutter", &gutter, 0)
        && gutter == mtext->gutter)
      pass ();
    else
      fail ("MTEXT.gutter [BD] set+1 %g != %g", mtext->gutter, gutter);
    mtext->gutter--;
  }
  {
    BITCODE_BL ignore_attachment;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "ignore_attachment", &ignore_attachment, NULL)
        && ignore_attachment == mtext->ignore_attachment)
      pass ();
    else
      fail ("MTEXT.ignore_attachment [BL] %u != %u", mtext->ignore_attachment, ignore_attachment);
    ignore_attachment++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "ignore_attachment", &ignore_attachment, 0)
        && ignore_attachment == mtext->ignore_attachment)
      pass ();
    else
      fail ("MTEXT.ignore_attachment [BL] set+1 %u != %u", mtext->ignore_attachment, ignore_attachment);
    mtext->ignore_attachment--;
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &mtext->ins_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("MTEXT.ins_pt [3BD]");
  }
  {
    BITCODE_B is_not_annotative;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "is_not_annotative", &is_not_annotative, NULL)
        && is_not_annotative == mtext->is_not_annotative)
      pass ();
    else
      fail ("MTEXT.is_not_annotative [B] " FORMAT_B " != " FORMAT_B "", mtext->is_not_annotative, is_not_annotative);
    is_not_annotative++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "is_not_annotative", &is_not_annotative, 0)
        && is_not_annotative == mtext->is_not_annotative)
      pass ();
    else
      fail ("MTEXT.is_not_annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->is_not_annotative, is_not_annotative);
    mtext->is_not_annotative--;
  }
  {
    BITCODE_BD linespace_factor;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "linespace_factor", &linespace_factor, NULL)
        && linespace_factor == mtext->linespace_factor)
      pass ();
    else
      fail ("MTEXT.linespace_factor [BD] %g != %g", mtext->linespace_factor, linespace_factor);
    linespace_factor++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "linespace_factor", &linespace_factor, 0)
        && linespace_factor == mtext->linespace_factor)
      pass ();
    else
      fail ("MTEXT.linespace_factor [BD] set+1 %g != %g", mtext->linespace_factor, linespace_factor);
    mtext->linespace_factor--;
  }
  {
    BITCODE_BS linespace_style;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "linespace_style", &linespace_style, NULL)
        && linespace_style == mtext->linespace_style)
      pass ();
    else
      fail ("MTEXT.linespace_style [BS] %hu != %hu", mtext->linespace_style, linespace_style);
    linespace_style++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "linespace_style", &linespace_style, 0)
        && linespace_style == mtext->linespace_style)
      pass ();
    else
      fail ("MTEXT.linespace_style [BS] set+1 %hu != %hu", mtext->linespace_style, linespace_style);
    mtext->linespace_style--;
  }
  {
    BITCODE_BL num_column_heights;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "num_column_heights", &num_column_heights, NULL)
        && num_column_heights == mtext->num_column_heights)
      pass ();
    else
      fail ("MTEXT.num_column_heights [BL] %u != %u", mtext->num_column_heights, num_column_heights);
    num_column_heights++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "num_column_heights", &num_column_heights, 0)
        && num_column_heights == mtext->num_column_heights)
      pass ();
    else
      fail ("MTEXT.num_column_heights [BL] set+1 %u != %u", mtext->num_column_heights, num_column_heights);
    mtext->num_column_heights--;
  }
  {
    BITCODE_BL numfragments;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "numfragments", &numfragments, NULL)
        && numfragments == mtext->numfragments)
      pass ();
    else
      fail ("MTEXT.numfragments [BL] %u != %u", mtext->numfragments, numfragments);
    numfragments++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "numfragments", &numfragments, 0)
        && numfragments == mtext->numfragments)
      pass ();
    else
      fail ("MTEXT.numfragments [BL] set+1 %u != %u", mtext->numfragments, numfragments);
    mtext->numfragments--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "parent", &parent, NULL)
        && !memcmp (&parent, &mtext->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("MTEXT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rect_height;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "rect_height", &rect_height, NULL)
        && rect_height == mtext->rect_height)
      pass ();
    else
      fail ("MTEXT.rect_height [BD] %g != %g", mtext->rect_height, rect_height);
    rect_height++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "rect_height", &rect_height, 0)
        && rect_height == mtext->rect_height)
      pass ();
    else
      fail ("MTEXT.rect_height [BD] set+1 %g != %g", mtext->rect_height, rect_height);
    mtext->rect_height--;
  }
  {
    BITCODE_BD rect_width;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "rect_width", &rect_width, NULL)
        && rect_width == mtext->rect_width)
      pass ();
    else
      fail ("MTEXT.rect_width [BD] %g != %g", mtext->rect_width, rect_width);
    rect_width++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "rect_width", &rect_width, 0)
        && rect_width == mtext->rect_width)
      pass ();
    else
      fail ("MTEXT.rect_width [BD] set+1 %g != %g", mtext->rect_width, rect_width);
    mtext->rect_width--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "style", &style, NULL)
        && !memcmp (&style, &mtext->style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MTEXT.style [H]");
  }
  {
    BITCODE_T text;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "text", &text, NULL)
        && text
           ? strEQ ((char *)text, (char *)mtext->text)
           : !mtext->text)
      pass ();
    else
      fail ("MTEXT.text [T] '%s' <> '%s'", text, mtext->text);
  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "text_height", &text_height, NULL)
        && text_height == mtext->text_height)
      pass ();
    else
      fail ("MTEXT.text_height [BD] %g != %g", mtext->text_height, text_height);
    text_height++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "text_height", &text_height, 0)
        && text_height == mtext->text_height)
      pass ();
    else
      fail ("MTEXT.text_height [BD] set+1 %g != %g", mtext->text_height, text_height);
    mtext->text_height--;
  }
  {
    BITCODE_B unknown_b0;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "unknown_b0", &unknown_b0, NULL)
        && unknown_b0 == mtext->unknown_b0)
      pass ();
    else
      fail ("MTEXT.unknown_b0 [B] " FORMAT_B " != " FORMAT_B "", mtext->unknown_b0, unknown_b0);
    unknown_b0++;
    if (dwg_dynapi_entity_set_value (mtext, "MTEXT", "unknown_b0", &unknown_b0, 0)
        && unknown_b0 == mtext->unknown_b0)
      pass ();
    else
      fail ("MTEXT.unknown_b0 [B] set+1 " FORMAT_B " != " FORMAT_B "", mtext->unknown_b0, unknown_b0);
    mtext->unknown_b0--;
  }
  {
    BITCODE_3BD x_axis_dir;
    if (dwg_dynapi_entity_value (mtext, "MTEXT", "x_axis_dir", &x_axis_dir, NULL)
        && !memcmp (&x_axis_dir, &mtext->x_axis_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("MTEXT.x_axis_dir [3BD]");
  }
  if (failed && (is_class_unstable ("MTEXT") || is_class_debugging ("MTEXT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MTEXT", failed);
      failed = 0;
    }
  return failed;
}
static int test_MULTILEADER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_MULTILEADER *restrict multileader = obj->tio.entity->tio.MULTILEADER;
  failed = 0;
  if (!obj_obj || !multileader)
    {
      fail ("NULL MULTILEADER");
      return 1;
    }
  {
    BITCODE_H arrow_handle;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "arrow_handle", &arrow_handle, NULL)
        && !memcmp (&arrow_handle, &multileader->arrow_handle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MULTILEADER.arrow_handle [H]");
  }
  {
    BITCODE_BD arrow_size;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "arrow_size", &arrow_size, NULL)
        && arrow_size == multileader->arrow_size)
      pass ();
    else
      fail ("MULTILEADER.arrow_size [BD] %g != %g", multileader->arrow_size, arrow_size);
    arrow_size++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "arrow_size", &arrow_size, 0)
        && arrow_size == multileader->arrow_size)
      pass ();
    else
      fail ("MULTILEADER.arrow_size [BD] set+1 %g != %g", multileader->arrow_size, arrow_size);
    multileader->arrow_size--;
  }
  {
    Dwg_LEADER_ArrowHead* arrowheads;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "num_arrowheads", &count, NULL)
        && dwg_dynapi_entity_value (multileader, "MULTILEADER", "arrowheads", &arrowheads, NULL)
        && arrowheads == multileader->arrowheads)
      pass ();
    else
      fail ("MULTILEADER.arrowheads [Dwg_LEADER_ArrowHead*] * %u num_arrowheads", count);
  }
  {
    BITCODE_BS attach_bottom;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "attach_bottom", &attach_bottom, NULL)
        && attach_bottom == multileader->attach_bottom)
      pass ();
    else
      fail ("MULTILEADER.attach_bottom [BS] %hu != %hu", multileader->attach_bottom, attach_bottom);
    attach_bottom++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "attach_bottom", &attach_bottom, 0)
        && attach_bottom == multileader->attach_bottom)
      pass ();
    else
      fail ("MULTILEADER.attach_bottom [BS] set+1 %hu != %hu", multileader->attach_bottom, attach_bottom);
    multileader->attach_bottom--;
  }
  {
    BITCODE_BS attach_dir;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "attach_dir", &attach_dir, NULL)
        && attach_dir == multileader->attach_dir)
      pass ();
    else
      fail ("MULTILEADER.attach_dir [BS] %hu != %hu", multileader->attach_dir, attach_dir);
    attach_dir++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "attach_dir", &attach_dir, 0)
        && attach_dir == multileader->attach_dir)
      pass ();
    else
      fail ("MULTILEADER.attach_dir [BS] set+1 %hu != %hu", multileader->attach_dir, attach_dir);
    multileader->attach_dir--;
  }
  {
    BITCODE_BS attach_top;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "attach_top", &attach_top, NULL)
        && attach_top == multileader->attach_top)
      pass ();
    else
      fail ("MULTILEADER.attach_top [BS] %hu != %hu", multileader->attach_top, attach_top);
    attach_top++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "attach_top", &attach_top, 0)
        && attach_top == multileader->attach_top)
      pass ();
    else
      fail ("MULTILEADER.attach_top [BS] set+1 %hu != %hu", multileader->attach_top, attach_top);
    multileader->attach_top--;
  }
  {
    BITCODE_CMC block_color;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "block_color", &block_color, NULL)
        && !memcmp (&block_color, &multileader->block_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MULTILEADER.block_color [CMC]");
  }
  {
    BITCODE_BD block_rotation;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "block_rotation", &block_rotation, NULL)
        && block_rotation == multileader->block_rotation)
      pass ();
    else
      fail ("MULTILEADER.block_rotation [BD] %g != %g", multileader->block_rotation, block_rotation);
    block_rotation++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "block_rotation", &block_rotation, 0)
        && block_rotation == multileader->block_rotation)
      pass ();
    else
      fail ("MULTILEADER.block_rotation [BD] set+1 %g != %g", multileader->block_rotation, block_rotation);
    multileader->block_rotation--;
  }
  {
    BITCODE_3BD block_scale;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "block_scale", &block_scale, NULL)
        && !memcmp (&block_scale, &multileader->block_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("MULTILEADER.block_scale [3BD]");
  }
  {
    BITCODE_H block_style;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "block_style", &block_style, NULL)
        && !memcmp (&block_style, &multileader->block_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MULTILEADER.block_style [H]");
  }
  {
    Dwg_LEADER_BlockLabel* blocklabels;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "num_blocklabels", &count, NULL)
        && dwg_dynapi_entity_value (multileader, "MULTILEADER", "blocklabels", &blocklabels, NULL)
        && blocklabels == multileader->blocklabels)
      pass ();
    else
      fail ("MULTILEADER.blocklabels [Dwg_LEADER_BlockLabel*] * %u num_blocklabels", count);
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "class_version", &class_version, NULL)
        && class_version == multileader->class_version)
      pass ();
    else
      fail ("MULTILEADER.class_version [BS] %hu != %hu", multileader->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "class_version", &class_version, 0)
        && class_version == multileader->class_version)
      pass ();
    else
      fail ("MULTILEADER.class_version [BS] set+1 %hu != %hu", multileader->class_version, class_version);
    multileader->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "color", &color, NULL)
        && !memcmp (&color, &multileader->color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MULTILEADER.color [CMC]");
  }
  {
    Dwg_MLEADER_AnnotContext ctx;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "ctx", &ctx, NULL)
        && !memcmp (&ctx, &multileader->ctx, sizeof (Dwg_MLEADER_AnnotContext)))
        pass ();
    else
        fail ("MULTILEADER.ctx [Dwg_MLEADER_AnnotContext]");
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "flags", &flags, NULL)
        && flags == multileader->flags)
      pass ();
    else
      fail ("MULTILEADER.flags [BL] %u != %u", multileader->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "flags", &flags, 0)
        && flags == multileader->flags)
      pass ();
    else
      fail ("MULTILEADER.flags [BL] set+1 %u != %u", multileader->flags, flags);
    multileader->flags--;
  }
  {
    BITCODE_B has_dogleg;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "has_dogleg", &has_dogleg, NULL)
        && has_dogleg == multileader->has_dogleg)
      pass ();
    else
      fail ("MULTILEADER.has_dogleg [B] " FORMAT_B " != " FORMAT_B "", multileader->has_dogleg, has_dogleg);
    has_dogleg++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "has_dogleg", &has_dogleg, 0)
        && has_dogleg == multileader->has_dogleg)
      pass ();
    else
      fail ("MULTILEADER.has_dogleg [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_dogleg, has_dogleg);
    multileader->has_dogleg--;
  }
  {
    BITCODE_B has_landing;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "has_landing", &has_landing, NULL)
        && has_landing == multileader->has_landing)
      pass ();
    else
      fail ("MULTILEADER.has_landing [B] " FORMAT_B " != " FORMAT_B "", multileader->has_landing, has_landing);
    has_landing++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "has_landing", &has_landing, 0)
        && has_landing == multileader->has_landing)
      pass ();
    else
      fail ("MULTILEADER.has_landing [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_landing, has_landing);
    multileader->has_landing--;
  }
  {
    BITCODE_B has_text_frame;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "has_text_frame", &has_text_frame, NULL)
        && has_text_frame == multileader->has_text_frame)
      pass ();
    else
      fail ("MULTILEADER.has_text_frame [B] " FORMAT_B " != " FORMAT_B "", multileader->has_text_frame, has_text_frame);
    has_text_frame++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "has_text_frame", &has_text_frame, 0)
        && has_text_frame == multileader->has_text_frame)
      pass ();
    else
      fail ("MULTILEADER.has_text_frame [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->has_text_frame, has_text_frame);
    multileader->has_text_frame--;
  }
  {
    BITCODE_BS ipe_alignment;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "ipe_alignment", &ipe_alignment, NULL)
        && ipe_alignment == multileader->ipe_alignment)
      pass ();
    else
      fail ("MULTILEADER.ipe_alignment [BS] %hu != %hu", multileader->ipe_alignment, ipe_alignment);
    ipe_alignment++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "ipe_alignment", &ipe_alignment, 0)
        && ipe_alignment == multileader->ipe_alignment)
      pass ();
    else
      fail ("MULTILEADER.ipe_alignment [BS] set+1 %hu != %hu", multileader->ipe_alignment, ipe_alignment);
    multileader->ipe_alignment--;
  }
  {
    BITCODE_B is_annotative;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "is_annotative", &is_annotative, NULL)
        && is_annotative == multileader->is_annotative)
      pass ();
    else
      fail ("MULTILEADER.is_annotative [B] " FORMAT_B " != " FORMAT_B "", multileader->is_annotative, is_annotative);
    is_annotative++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "is_annotative", &is_annotative, 0)
        && is_annotative == multileader->is_annotative)
      pass ();
    else
      fail ("MULTILEADER.is_annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->is_annotative, is_annotative);
    multileader->is_annotative--;
  }
  {
    BITCODE_B is_neg_textdir;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "is_neg_textdir", &is_neg_textdir, NULL)
        && is_neg_textdir == multileader->is_neg_textdir)
      pass ();
    else
      fail ("MULTILEADER.is_neg_textdir [B] " FORMAT_B " != " FORMAT_B "", multileader->is_neg_textdir, is_neg_textdir);
    is_neg_textdir++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "is_neg_textdir", &is_neg_textdir, 0)
        && is_neg_textdir == multileader->is_neg_textdir)
      pass ();
    else
      fail ("MULTILEADER.is_neg_textdir [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->is_neg_textdir, is_neg_textdir);
    multileader->is_neg_textdir--;
  }
  {
    BITCODE_B is_text_extended;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "is_text_extended", &is_text_extended, NULL)
        && is_text_extended == multileader->is_text_extended)
      pass ();
    else
      fail ("MULTILEADER.is_text_extended [B] " FORMAT_B " != " FORMAT_B "", multileader->is_text_extended, is_text_extended);
    is_text_extended++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "is_text_extended", &is_text_extended, 0)
        && is_text_extended == multileader->is_text_extended)
      pass ();
    else
      fail ("MULTILEADER.is_text_extended [B] set+1 " FORMAT_B " != " FORMAT_B "", multileader->is_text_extended, is_text_extended);
    multileader->is_text_extended--;
  }
  {
    BITCODE_BS justification;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "justification", &justification, NULL)
        && justification == multileader->justification)
      pass ();
    else
      fail ("MULTILEADER.justification [BS] %hu != %hu", multileader->justification, justification);
    justification++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "justification", &justification, 0)
        && justification == multileader->justification)
      pass ();
    else
      fail ("MULTILEADER.justification [BS] set+1 %hu != %hu", multileader->justification, justification);
    multileader->justification--;
  }
  {
    BITCODE_BD landing_dist;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "landing_dist", &landing_dist, NULL)
        && landing_dist == multileader->landing_dist)
      pass ();
    else
      fail ("MULTILEADER.landing_dist [BD] %g != %g", multileader->landing_dist, landing_dist);
    landing_dist++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "landing_dist", &landing_dist, 0)
        && landing_dist == multileader->landing_dist)
      pass ();
    else
      fail ("MULTILEADER.landing_dist [BD] set+1 %g != %g", multileader->landing_dist, landing_dist);
    multileader->landing_dist--;
  }
  {
    BITCODE_BLd linewt;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "linewt", &linewt, NULL)
        && linewt == multileader->linewt)
      pass ();
    else
      fail ("MULTILEADER.linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", multileader->linewt, linewt);
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "linewt", &linewt, 0)
        && linewt == multileader->linewt)
      pass ();
    else
      fail ("MULTILEADER.linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", multileader->linewt, linewt);
    multileader->linewt--;
  }
  {
    BITCODE_H ltype;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "ltype", &ltype, NULL)
        && !memcmp (&ltype, &multileader->ltype, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MULTILEADER.ltype [H]");
  }
  {
    BITCODE_H mleaderstyle;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "mleaderstyle", &mleaderstyle, NULL)
        && !memcmp (&mleaderstyle, &multileader->mleaderstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MULTILEADER.mleaderstyle [H]");
  }
  {
    BITCODE_BL num_arrowheads;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "num_arrowheads", &num_arrowheads, NULL)
        && num_arrowheads == multileader->num_arrowheads)
      pass ();
    else
      fail ("MULTILEADER.num_arrowheads [BL] %u != %u", multileader->num_arrowheads, num_arrowheads);
    num_arrowheads++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "num_arrowheads", &num_arrowheads, 0)
        && num_arrowheads == multileader->num_arrowheads)
      pass ();
    else
      fail ("MULTILEADER.num_arrowheads [BL] set+1 %u != %u", multileader->num_arrowheads, num_arrowheads);
    multileader->num_arrowheads--;
  }
  {
    BITCODE_BL num_blocklabels;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "num_blocklabels", &num_blocklabels, NULL)
        && num_blocklabels == multileader->num_blocklabels)
      pass ();
    else
      fail ("MULTILEADER.num_blocklabels [BL] %u != %u", multileader->num_blocklabels, num_blocklabels);
    num_blocklabels++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "num_blocklabels", &num_blocklabels, 0)
        && num_blocklabels == multileader->num_blocklabels)
      pass ();
    else
      fail ("MULTILEADER.num_blocklabels [BL] set+1 %u != %u", multileader->num_blocklabels, num_blocklabels);
    multileader->num_blocklabels--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "parent", &parent, NULL)
        && !memcmp (&parent, &multileader->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("MULTILEADER.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "scale_factor", &scale_factor, NULL)
        && scale_factor == multileader->scale_factor)
      pass ();
    else
      fail ("MULTILEADER.scale_factor [BD] %g != %g", multileader->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "scale_factor", &scale_factor, 0)
        && scale_factor == multileader->scale_factor)
      pass ();
    else
      fail ("MULTILEADER.scale_factor [BD] set+1 %g != %g", multileader->scale_factor, scale_factor);
    multileader->scale_factor--;
  }
  {
    BITCODE_BS style_attachment;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "style_attachment", &style_attachment, NULL)
        && style_attachment == multileader->style_attachment)
      pass ();
    else
      fail ("MULTILEADER.style_attachment [BS] %hu != %hu", multileader->style_attachment, style_attachment);
    style_attachment++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "style_attachment", &style_attachment, 0)
        && style_attachment == multileader->style_attachment)
      pass ();
    else
      fail ("MULTILEADER.style_attachment [BS] set+1 %hu != %hu", multileader->style_attachment, style_attachment);
    multileader->style_attachment--;
  }
  {
    BITCODE_BS style_content;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "style_content", &style_content, NULL)
        && style_content == multileader->style_content)
      pass ();
    else
      fail ("MULTILEADER.style_content [BS] %hu != %hu", multileader->style_content, style_content);
    style_content++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "style_content", &style_content, 0)
        && style_content == multileader->style_content)
      pass ();
    else
      fail ("MULTILEADER.style_content [BS] set+1 %hu != %hu", multileader->style_content, style_content);
    multileader->style_content--;
  }
  {
    BITCODE_BS text_alignment;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_alignment", &text_alignment, NULL)
        && text_alignment == multileader->text_alignment)
      pass ();
    else
      fail ("MULTILEADER.text_alignment [BS] %hu != %hu", multileader->text_alignment, text_alignment);
    text_alignment++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "text_alignment", &text_alignment, 0)
        && text_alignment == multileader->text_alignment)
      pass ();
    else
      fail ("MULTILEADER.text_alignment [BS] set+1 %hu != %hu", multileader->text_alignment, text_alignment);
    multileader->text_alignment--;
  }
  {
    BITCODE_BS text_angletype;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_angletype", &text_angletype, NULL)
        && text_angletype == multileader->text_angletype)
      pass ();
    else
      fail ("MULTILEADER.text_angletype [BS] %hu != %hu", multileader->text_angletype, text_angletype);
    text_angletype++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "text_angletype", &text_angletype, 0)
        && text_angletype == multileader->text_angletype)
      pass ();
    else
      fail ("MULTILEADER.text_angletype [BS] set+1 %hu != %hu", multileader->text_angletype, text_angletype);
    multileader->text_angletype--;
  }
  {
    BITCODE_CMC text_color;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_color", &text_color, NULL)
        && !memcmp (&text_color, &multileader->text_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MULTILEADER.text_color [CMC]");
  }
  {
    BITCODE_BS text_left;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_left", &text_left, NULL)
        && text_left == multileader->text_left)
      pass ();
    else
      fail ("MULTILEADER.text_left [BS] %hu != %hu", multileader->text_left, text_left);
    text_left++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "text_left", &text_left, 0)
        && text_left == multileader->text_left)
      pass ();
    else
      fail ("MULTILEADER.text_left [BS] set+1 %hu != %hu", multileader->text_left, text_left);
    multileader->text_left--;
  }
  {
    BITCODE_BS text_right;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_right", &text_right, NULL)
        && text_right == multileader->text_right)
      pass ();
    else
      fail ("MULTILEADER.text_right [BS] %hu != %hu", multileader->text_right, text_right);
    text_right++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "text_right", &text_right, 0)
        && text_right == multileader->text_right)
      pass ();
    else
      fail ("MULTILEADER.text_right [BS] set+1 %hu != %hu", multileader->text_right, text_right);
    multileader->text_right--;
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "text_style", &text_style, NULL)
        && !memcmp (&text_style, &multileader->text_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MULTILEADER.text_style [H]");
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (multileader, "MULTILEADER", "type", &type, NULL)
        && type == multileader->type)
      pass ();
    else
      fail ("MULTILEADER.type [BS] %hu != %hu", multileader->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (multileader, "MULTILEADER", "type", &type, 0)
        && type == multileader->type)
      pass ();
    else
      fail ("MULTILEADER.type [BS] set+1 %hu != %hu", multileader->type, type);
    multileader->type--;
  }
  if (failed && (is_class_unstable ("MULTILEADER") || is_class_debugging ("MULTILEADER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MULTILEADER", failed);
      failed = 0;
    }
  return failed;
}
static int test_NAVISWORKSMODEL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_NAVISWORKSMODEL *restrict navisworksmodel = obj->tio.entity->tio.NAVISWORKSMODEL;
  failed = 0;
  if (!obj_obj || !navisworksmodel)
    {
      fail ("NULL NAVISWORKSMODEL");
      return 1;
    }
  {
    BITCODE_H definition;
    if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "definition", &definition, NULL)
        && !memcmp (&definition, &navisworksmodel->definition, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("NAVISWORKSMODEL.definition [H]");
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "flags", &flags, NULL)
        && flags == navisworksmodel->flags)
      pass ();
    else
      fail ("NAVISWORKSMODEL.flags [BS] %hu != %hu", navisworksmodel->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (navisworksmodel, "NAVISWORKSMODEL", "flags", &flags, 0)
        && flags == navisworksmodel->flags)
      pass ();
    else
      fail ("NAVISWORKSMODEL.flags [BS] set+1 %hu != %hu", navisworksmodel->flags, flags);
    navisworksmodel->flags--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "parent", &parent, NULL)
        && !memcmp (&parent, &navisworksmodel->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("NAVISWORKSMODEL.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD* transmatrix;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "num_transmatrix", &count, NULL)
        && dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "transmatrix", &transmatrix, NULL)
        && transmatrix == navisworksmodel->transmatrix)
      pass ();
    else
      fail ("NAVISWORKSMODEL.transmatrix [BD*] * %u num_transmatrix", count);
  }
  {
    BITCODE_BD unitfactor;
    if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "unitfactor", &unitfactor, NULL)
        && unitfactor == navisworksmodel->unitfactor)
      pass ();
    else
      fail ("NAVISWORKSMODEL.unitfactor [BD] %g != %g", navisworksmodel->unitfactor, unitfactor);
    unitfactor++;
    if (dwg_dynapi_entity_set_value (navisworksmodel, "NAVISWORKSMODEL", "unitfactor", &unitfactor, 0)
        && unitfactor == navisworksmodel->unitfactor)
      pass ();
    else
      fail ("NAVISWORKSMODEL.unitfactor [BD] set+1 %g != %g", navisworksmodel->unitfactor, unitfactor);
    navisworksmodel->unitfactor--;
  }
  if (failed && (is_class_unstable ("NAVISWORKSMODEL") || is_class_debugging ("NAVISWORKSMODEL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "NAVISWORKSMODEL", failed);
      failed = 0;
    }
  return failed;
}
static int test_NURBSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_NURBSURFACE *restrict nurbsurface = obj->tio.entity->tio.NURBSURFACE;
  failed = 0;
  if (!obj_obj || !nurbsurface)
    {
      fail ("NULL NURBSURFACE");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == nurbsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("NURBSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == nurbsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("NURBSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->_dxf_sab_converted, _dxf_sab_converted);
    nurbsurface->_dxf_sab_converted--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)nurbsurface->acis_data)
           : !nurbsurface->acis_data)
      pass ();
    else
      fail ("NURBSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, nurbsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == nurbsurface->acis_empty)
      pass ();
    else
      fail ("NURBSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == nurbsurface->acis_empty)
      pass ();
    else
      fail ("NURBSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty, acis_empty);
    nurbsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == nurbsurface->acis_empty2)
      pass ();
    else
      fail ("NURBSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == nurbsurface->acis_empty2)
      pass ();
    else
      fail ("NURBSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty2, acis_empty2);
    nurbsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == nurbsurface->acis_empty_bit)
      pass ();
    else
      fail ("NURBSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == nurbsurface->acis_empty_bit)
      pass ();
    else
      fail ("NURBSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty_bit, acis_empty_bit);
    nurbsurface->acis_empty_bit--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &nurbsurface->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("NURBSURFACE.block_size [BL*]");
  }
  {
    BITCODE_B cv_hull_display;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "cv_hull_display", &cv_hull_display, NULL)
        && cv_hull_display == nurbsurface->cv_hull_display)
      pass ();
    else
      fail ("NURBSURFACE.cv_hull_display [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->cv_hull_display, cv_hull_display);
    cv_hull_display++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "cv_hull_display", &cv_hull_display, 0)
        && cv_hull_display == nurbsurface->cv_hull_display)
      pass ();
    else
      fail ("NURBSURFACE.cv_hull_display [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->cv_hull_display, cv_hull_display);
    nurbsurface->cv_hull_display--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &nurbsurface->encr_sat_data, sizeof (nurbsurface->encr_sat_data)))
      pass ();
    else
      fail ("NURBSURFACE.encr_sat_data [char **]");
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "end_marker", &end_marker, NULL)
        && end_marker == nurbsurface->end_marker)
      pass ();
    else
      fail ("NURBSURFACE.end_marker [BL] %u != %u", nurbsurface->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "end_marker", &end_marker, 0)
        && end_marker == nurbsurface->end_marker)
      pass ();
    else
      fail ("NURBSURFACE.end_marker [BL] set+1 %u != %u", nurbsurface->end_marker, end_marker);
    nurbsurface->end_marker--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &nurbsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("NURBSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == nurbsurface->has_revision_guid)
      pass ();
    else
      fail ("NURBSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == nurbsurface->has_revision_guid)
      pass ();
    else
      fail ("NURBSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->has_revision_guid, has_revision_guid);
    nurbsurface->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &nurbsurface->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("NURBSURFACE.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == nurbsurface->isoline_present)
      pass ();
    else
      fail ("NURBSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == nurbsurface->isoline_present)
      pass ();
    else
      fail ("NURBSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->isoline_present, isoline_present);
    nurbsurface->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "isolines", &isolines, NULL)
        && isolines == nurbsurface->isolines)
      pass ();
    else
      fail ("NURBSURFACE.isolines [BL] %u != %u", nurbsurface->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "isolines", &isolines, 0)
        && isolines == nurbsurface->isolines)
      pass ();
    else
      fail ("NURBSURFACE.isolines [BL] set+1 %u != %u", nurbsurface->isolines, isolines);
    nurbsurface->isolines--;
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "materials", &materials, NULL)
        && materials == nurbsurface->materials)
      pass ();
    else
      fail ("NURBSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == nurbsurface->num_blocks)
      pass ();
    else
      fail ("NURBSURFACE.num_blocks [BL] %u != %u", nurbsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == nurbsurface->num_blocks)
      pass ();
    else
      fail ("NURBSURFACE.num_blocks [BL] set+1 %u != %u", nurbsurface->num_blocks, num_blocks);
    nurbsurface->num_blocks--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_materials", &num_materials, NULL)
        && num_materials == nurbsurface->num_materials)
      pass ();
    else
      fail ("NURBSURFACE.num_materials [BL] %u != %u", nurbsurface->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "num_materials", &num_materials, 0)
        && num_materials == nurbsurface->num_materials)
      pass ();
    else
      fail ("NURBSURFACE.num_materials [BL] set+1 %u != %u", nurbsurface->num_materials, num_materials);
    nurbsurface->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == nurbsurface->num_silhouettes)
      pass ();
    else
      fail ("NURBSURFACE.num_silhouettes [BL] %u != %u", nurbsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == nurbsurface->num_silhouettes)
      pass ();
    else
      fail ("NURBSURFACE.num_silhouettes [BL] set+1 %u != %u", nurbsurface->num_silhouettes, num_silhouettes);
    nurbsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == nurbsurface->num_wires)
      pass ();
    else
      fail ("NURBSURFACE.num_wires [BL] %u != %u", nurbsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "num_wires", &num_wires, 0)
        && num_wires == nurbsurface->num_wires)
      pass ();
    else
      fail ("NURBSURFACE.num_wires [BL] set+1 %u != %u", nurbsurface->num_wires, num_wires);
    nurbsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &nurbsurface->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("NURBSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "point", &point, NULL)
        && !memcmp (&point, &nurbsurface->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("NURBSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "point_present", &point_present, NULL)
        && point_present == nurbsurface->point_present)
      pass ();
    else
      fail ("NURBSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "point_present", &point_present, 0)
        && point_present == nurbsurface->point_present)
      pass ();
    else
      fail ("NURBSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->point_present, point_present);
    nurbsurface->point_present--;
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &nurbsurface->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("NURBSURFACE.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &nurbsurface->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("NURBSURFACE.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_major", &revision_major, NULL)
        && revision_major == nurbsurface->revision_major)
      pass ();
    else
      fail ("NURBSURFACE.revision_major [BL] %u != %u", nurbsurface->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "revision_major", &revision_major, 0)
        && revision_major == nurbsurface->revision_major)
      pass ();
    else
      fail ("NURBSURFACE.revision_major [BL] set+1 %u != %u", nurbsurface->revision_major, revision_major);
    nurbsurface->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == nurbsurface->revision_minor1)
      pass ();
    else
      fail ("NURBSURFACE.revision_minor1 [BS] %hu != %hu", nurbsurface->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == nurbsurface->revision_minor1)
      pass ();
    else
      fail ("NURBSURFACE.revision_minor1 [BS] set+1 %hu != %hu", nurbsurface->revision_minor1, revision_minor1);
    nurbsurface->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == nurbsurface->revision_minor2)
      pass ();
    else
      fail ("NURBSURFACE.revision_minor2 [BS] %hu != %hu", nurbsurface->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == nurbsurface->revision_minor2)
      pass ();
    else
      fail ("NURBSURFACE.revision_minor2 [BS] set+1 %hu != %hu", nurbsurface->revision_minor2, revision_minor2);
    nurbsurface->revision_minor2--;
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "sab_size", &sab_size, NULL)
        && sab_size == nurbsurface->sab_size)
      pass ();
    else
      fail ("NURBSURFACE.sab_size [BL] %u != %u", nurbsurface->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "sab_size", &sab_size, 0)
        && sab_size == nurbsurface->sab_size)
      pass ();
    else
      fail ("NURBSURFACE.sab_size [BL] set+1 %u != %u", nurbsurface->sab_size, sab_size);
    nurbsurface->sab_size--;
  }
  {
    BITCODE_BS short170;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "short170", &short170, NULL)
        && short170 == nurbsurface->short170)
      pass ();
    else
      fail ("NURBSURFACE.short170 [BS] %hu != %hu", nurbsurface->short170, short170);
    short170++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "short170", &short170, 0)
        && short170 == nurbsurface->short170)
      pass ();
    else
      fail ("NURBSURFACE.short170 [BS] set+1 %hu != %hu", nurbsurface->short170, short170);
    nurbsurface->short170--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == nurbsurface->silhouettes)
      pass ();
    else
      fail ("NURBSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == nurbsurface->u_isolines)
      pass ();
    else
      fail ("NURBSURFACE.u_isolines [BS] %hu != %hu", nurbsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == nurbsurface->u_isolines)
      pass ();
    else
      fail ("NURBSURFACE.u_isolines [BS] set+1 %hu != %hu", nurbsurface->u_isolines, u_isolines);
    nurbsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "unknown", &unknown, NULL)
        && unknown == nurbsurface->unknown)
      pass ();
    else
      fail ("NURBSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "unknown", &unknown, 0)
        && unknown == nurbsurface->unknown)
      pass ();
    else
      fail ("NURBSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->unknown, unknown);
    nurbsurface->unknown--;
  }
  {
    BITCODE_3BD uvec1;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "uvec1", &uvec1, NULL)
        && !memcmp (&uvec1, &nurbsurface->uvec1, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("NURBSURFACE.uvec1 [3BD]");
  }
  {
    BITCODE_3BD uvec2;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "uvec2", &uvec2, NULL)
        && !memcmp (&uvec2, &nurbsurface->uvec2, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("NURBSURFACE.uvec2 [3BD]");
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == nurbsurface->v_isolines)
      pass ();
    else
      fail ("NURBSURFACE.v_isolines [BS] %hu != %hu", nurbsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == nurbsurface->v_isolines)
      pass ();
    else
      fail ("NURBSURFACE.v_isolines [BS] set+1 %hu != %hu", nurbsurface->v_isolines, v_isolines);
    nurbsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "version", &version, NULL)
        && version == nurbsurface->version)
      pass ();
    else
      fail ("NURBSURFACE.version [BS] %hu != %hu", nurbsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "version", &version, 0)
        && version == nurbsurface->version)
      pass ();
    else
      fail ("NURBSURFACE.version [BS] set+1 %hu != %hu", nurbsurface->version, version);
    nurbsurface->version--;
  }
  {
    BITCODE_3BD vvec1;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "vvec1", &vvec1, NULL)
        && !memcmp (&vvec1, &nurbsurface->vvec1, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("NURBSURFACE.vvec1 [3BD]");
  }
  {
    BITCODE_3BD vvec2;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "vvec2", &vvec2, NULL)
        && !memcmp (&vvec2, &nurbsurface->vvec2, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("NURBSURFACE.vvec2 [3BD]");
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == nurbsurface->wireframe_data_present)
      pass ();
    else
      fail ("NURBSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == nurbsurface->wireframe_data_present)
      pass ();
    else
      fail ("NURBSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->wireframe_data_present, wireframe_data_present);
    nurbsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "wires", &wires, NULL)
        && wires == nurbsurface->wires)
      pass ();
    else
      fail ("NURBSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("NURBSURFACE") || is_class_debugging ("NURBSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "NURBSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_OLE2FRAME (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_OLE2FRAME *restrict ole2frame = obj->tio.entity->tio.OLE2FRAME;
  failed = 0;
  if (!obj_obj || !ole2frame)
    {
      fail ("NULL OLE2FRAME");
      return 1;
    }
  {
    BITCODE_TF data;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "data", &data, NULL)
        && !memcmp (&data, &ole2frame->data, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("OLE2FRAME.data [TF]");
  }
  {
    BITCODE_BL data_size;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "data_size", &data_size, NULL)
        && data_size == ole2frame->data_size)
      pass ();
    else
      fail ("OLE2FRAME.data_size [BL] %u != %u", ole2frame->data_size, data_size);
    data_size++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "data_size", &data_size, 0)
        && data_size == ole2frame->data_size)
      pass ();
    else
      fail ("OLE2FRAME.data_size [BL] set+1 %u != %u", ole2frame->data_size, data_size);
    ole2frame->data_size--;
  }
  {
    BITCODE_RC lock_aspect;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "lock_aspect", &lock_aspect, NULL)
        && lock_aspect == ole2frame->lock_aspect)
      pass ();
    else
      fail ("OLE2FRAME.lock_aspect [RC] %u != %u", ole2frame->lock_aspect, lock_aspect);
    lock_aspect++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "lock_aspect", &lock_aspect, 0)
        && lock_aspect == ole2frame->lock_aspect)
      pass ();
    else
      fail ("OLE2FRAME.lock_aspect [RC] set+1 %u != %u", ole2frame->lock_aspect, lock_aspect);
    ole2frame->lock_aspect--;
  }
  {
    BITCODE_BS mode;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "mode", &mode, NULL)
        && mode == ole2frame->mode)
      pass ();
    else
      fail ("OLE2FRAME.mode [BS] %hu != %hu", ole2frame->mode, mode);
    mode++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "mode", &mode, 0)
        && mode == ole2frame->mode)
      pass ();
    else
      fail ("OLE2FRAME.mode [BS] set+1 %hu != %hu", ole2frame->mode, mode);
    ole2frame->mode--;
  }
  {
    BITCODE_TF oleclient;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "oleclient", &oleclient, NULL)
        && !memcmp (&oleclient, &ole2frame->oleclient, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("OLE2FRAME.oleclient [TF]");
  }
  {
    BITCODE_BS oleversion;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "oleversion", &oleversion, NULL)
        && oleversion == ole2frame->oleversion)
      pass ();
    else
      fail ("OLE2FRAME.oleversion [BS] %hu != %hu", ole2frame->oleversion, oleversion);
    oleversion++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "oleversion", &oleversion, 0)
        && oleversion == ole2frame->oleversion)
      pass ();
    else
      fail ("OLE2FRAME.oleversion [BS] set+1 %hu != %hu", ole2frame->oleversion, oleversion);
    ole2frame->oleversion--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "parent", &parent, NULL)
        && !memcmp (&parent, &ole2frame->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("OLE2FRAME.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD pt1;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "pt1", &pt1, NULL)
        && !memcmp (&pt1, &ole2frame->pt1, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("OLE2FRAME.pt1 [3BD]");
  }
  {
    BITCODE_3BD pt2;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "pt2", &pt2, NULL)
        && !memcmp (&pt2, &ole2frame->pt2, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("OLE2FRAME.pt2 [3BD]");
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (ole2frame, "OLE2FRAME", "type", &type, NULL)
        && type == ole2frame->type)
      pass ();
    else
      fail ("OLE2FRAME.type [BS] %hu != %hu", ole2frame->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (ole2frame, "OLE2FRAME", "type", &type, 0)
        && type == ole2frame->type)
      pass ();
    else
      fail ("OLE2FRAME.type [BS] set+1 %hu != %hu", ole2frame->type, type);
    ole2frame->type--;
  }
  if (failed && (is_class_unstable ("OLE2FRAME") || is_class_debugging ("OLE2FRAME")))
    {
      ok ("%s failed %d tests (TODO unstable)", "OLE2FRAME", failed);
      failed = 0;
    }
  return failed;
}
static int test_OLEFRAME (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_OLEFRAME *restrict oleframe = obj->tio.entity->tio.OLEFRAME;
  failed = 0;
  if (!obj_obj || !oleframe)
    {
      fail ("NULL OLEFRAME");
      return 1;
    }
  {
    BITCODE_TF data;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "data", &data, NULL)
        && !memcmp (&data, &oleframe->data, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("OLEFRAME.data [TF]");
  }
  {
    BITCODE_BL data_size;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "data_size", &data_size, NULL)
        && data_size == oleframe->data_size)
      pass ();
    else
      fail ("OLEFRAME.data_size [BL] %u != %u", oleframe->data_size, data_size);
    data_size++;
    if (dwg_dynapi_entity_set_value (oleframe, "OLEFRAME", "data_size", &data_size, 0)
        && data_size == oleframe->data_size)
      pass ();
    else
      fail ("OLEFRAME.data_size [BL] set+1 %u != %u", oleframe->data_size, data_size);
    oleframe->data_size--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "flag", &flag, NULL)
        && flag == oleframe->flag)
      pass ();
    else
      fail ("OLEFRAME.flag [BS] %hu != %hu", oleframe->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (oleframe, "OLEFRAME", "flag", &flag, 0)
        && flag == oleframe->flag)
      pass ();
    else
      fail ("OLEFRAME.flag [BS] set+1 %hu != %hu", oleframe->flag, flag);
    oleframe->flag--;
  }
  {
    BITCODE_BS mode;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "mode", &mode, NULL)
        && mode == oleframe->mode)
      pass ();
    else
      fail ("OLEFRAME.mode [BS] %hu != %hu", oleframe->mode, mode);
    mode++;
    if (dwg_dynapi_entity_set_value (oleframe, "OLEFRAME", "mode", &mode, 0)
        && mode == oleframe->mode)
      pass ();
    else
      fail ("OLEFRAME.mode [BS] set+1 %hu != %hu", oleframe->mode, mode);
    oleframe->mode--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (oleframe, "OLEFRAME", "parent", &parent, NULL)
        && !memcmp (&parent, &oleframe->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("OLEFRAME.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("OLEFRAME") || is_class_debugging ("OLEFRAME")))
    {
      ok ("%s failed %d tests (TODO unstable)", "OLEFRAME", failed);
      failed = 0;
    }
  return failed;
}
static int test_PDFUNDERLAY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_PDFUNDERLAY *restrict pdfunderlay = obj->tio.entity->tio.PDFUNDERLAY;
  failed = 0;
  if (!obj_obj || !pdfunderlay)
    {
      fail ("NULL PDFUNDERLAY");
      return 1;
    }
  if (failed && (is_class_unstable ("PDFUNDERLAY") || is_class_debugging ("PDFUNDERLAY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PDFUNDERLAY", failed);
      failed = 0;
    }
  return failed;
}
static int test_PLANESURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_PLANESURFACE *restrict planesurface = obj->tio.entity->tio.PLANESURFACE;
  failed = 0;
  if (!obj_obj || !planesurface)
    {
      fail ("NULL PLANESURFACE");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == planesurface->_dxf_sab_converted)
      pass ();
    else
      fail ("PLANESURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", planesurface->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == planesurface->_dxf_sab_converted)
      pass ();
    else
      fail ("PLANESURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->_dxf_sab_converted, _dxf_sab_converted);
    planesurface->_dxf_sab_converted--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)planesurface->acis_data)
           : !planesurface->acis_data)
      pass ();
    else
      fail ("PLANESURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, planesurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == planesurface->acis_empty)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == planesurface->acis_empty)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty, acis_empty);
    planesurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == planesurface->acis_empty2)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == planesurface->acis_empty2)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty2, acis_empty2);
    planesurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == planesurface->acis_empty_bit)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == planesurface->acis_empty_bit)
      pass ();
    else
      fail ("PLANESURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty_bit, acis_empty_bit);
    planesurface->acis_empty_bit--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &planesurface->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("PLANESURFACE.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "class_version", &class_version, NULL)
        && class_version == planesurface->class_version)
      pass ();
    else
      fail ("PLANESURFACE.class_version [BL] %u != %u", planesurface->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "class_version", &class_version, 0)
        && class_version == planesurface->class_version)
      pass ();
    else
      fail ("PLANESURFACE.class_version [BL] set+1 %u != %u", planesurface->class_version, class_version);
    planesurface->class_version--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &planesurface->encr_sat_data, sizeof (planesurface->encr_sat_data)))
      pass ();
    else
      fail ("PLANESURFACE.encr_sat_data [char **]");
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "end_marker", &end_marker, NULL)
        && end_marker == planesurface->end_marker)
      pass ();
    else
      fail ("PLANESURFACE.end_marker [BL] %u != %u", planesurface->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "end_marker", &end_marker, 0)
        && end_marker == planesurface->end_marker)
      pass ();
    else
      fail ("PLANESURFACE.end_marker [BL] set+1 %u != %u", planesurface->end_marker, end_marker);
    planesurface->end_marker--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &planesurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("PLANESURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == planesurface->has_revision_guid)
      pass ();
    else
      fail ("PLANESURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", planesurface->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == planesurface->has_revision_guid)
      pass ();
    else
      fail ("PLANESURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->has_revision_guid, has_revision_guid);
    planesurface->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &planesurface->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("PLANESURFACE.history_id [H]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == planesurface->isoline_present)
      pass ();
    else
      fail ("PLANESURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == planesurface->isoline_present)
      pass ();
    else
      fail ("PLANESURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->isoline_present, isoline_present);
    planesurface->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "isolines", &isolines, NULL)
        && isolines == planesurface->isolines)
      pass ();
    else
      fail ("PLANESURFACE.isolines [BL] %u != %u", planesurface->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "isolines", &isolines, 0)
        && isolines == planesurface->isolines)
      pass ();
    else
      fail ("PLANESURFACE.isolines [BL] set+1 %u != %u", planesurface->isolines, isolines);
    planesurface->isolines--;
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "materials", &materials, NULL)
        && materials == planesurface->materials)
      pass ();
    else
      fail ("PLANESURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == planesurface->modeler_format_version)
      pass ();
    else
      fail ("PLANESURFACE.modeler_format_version [BS] %hu != %hu", planesurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == planesurface->modeler_format_version)
      pass ();
    else
      fail ("PLANESURFACE.modeler_format_version [BS] set+1 %hu != %hu", planesurface->modeler_format_version, modeler_format_version);
    planesurface->modeler_format_version--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == planesurface->num_blocks)
      pass ();
    else
      fail ("PLANESURFACE.num_blocks [BL] %u != %u", planesurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == planesurface->num_blocks)
      pass ();
    else
      fail ("PLANESURFACE.num_blocks [BL] set+1 %u != %u", planesurface->num_blocks, num_blocks);
    planesurface->num_blocks--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_materials", &num_materials, NULL)
        && num_materials == planesurface->num_materials)
      pass ();
    else
      fail ("PLANESURFACE.num_materials [BL] %u != %u", planesurface->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_materials", &num_materials, 0)
        && num_materials == planesurface->num_materials)
      pass ();
    else
      fail ("PLANESURFACE.num_materials [BL] set+1 %u != %u", planesurface->num_materials, num_materials);
    planesurface->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == planesurface->num_silhouettes)
      pass ();
    else
      fail ("PLANESURFACE.num_silhouettes [BL] %u != %u", planesurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == planesurface->num_silhouettes)
      pass ();
    else
      fail ("PLANESURFACE.num_silhouettes [BL] set+1 %u != %u", planesurface->num_silhouettes, num_silhouettes);
    planesurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_wires", &num_wires, NULL)
        && num_wires == planesurface->num_wires)
      pass ();
    else
      fail ("PLANESURFACE.num_wires [BL] %u != %u", planesurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_wires", &num_wires, 0)
        && num_wires == planesurface->num_wires)
      pass ();
    else
      fail ("PLANESURFACE.num_wires [BL] set+1 %u != %u", planesurface->num_wires, num_wires);
    planesurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &planesurface->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("PLANESURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "point", &point, NULL)
        && !memcmp (&point, &planesurface->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("PLANESURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "point_present", &point_present, NULL)
        && point_present == planesurface->point_present)
      pass ();
    else
      fail ("PLANESURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "point_present", &point_present, 0)
        && point_present == planesurface->point_present)
      pass ();
    else
      fail ("PLANESURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->point_present, point_present);
    planesurface->point_present--;
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &planesurface->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("PLANESURFACE.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &planesurface->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("PLANESURFACE.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_major", &revision_major, NULL)
        && revision_major == planesurface->revision_major)
      pass ();
    else
      fail ("PLANESURFACE.revision_major [BL] %u != %u", planesurface->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "revision_major", &revision_major, 0)
        && revision_major == planesurface->revision_major)
      pass ();
    else
      fail ("PLANESURFACE.revision_major [BL] set+1 %u != %u", planesurface->revision_major, revision_major);
    planesurface->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == planesurface->revision_minor1)
      pass ();
    else
      fail ("PLANESURFACE.revision_minor1 [BS] %hu != %hu", planesurface->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == planesurface->revision_minor1)
      pass ();
    else
      fail ("PLANESURFACE.revision_minor1 [BS] set+1 %hu != %hu", planesurface->revision_minor1, revision_minor1);
    planesurface->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == planesurface->revision_minor2)
      pass ();
    else
      fail ("PLANESURFACE.revision_minor2 [BS] %hu != %hu", planesurface->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == planesurface->revision_minor2)
      pass ();
    else
      fail ("PLANESURFACE.revision_minor2 [BS] set+1 %hu != %hu", planesurface->revision_minor2, revision_minor2);
    planesurface->revision_minor2--;
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "sab_size", &sab_size, NULL)
        && sab_size == planesurface->sab_size)
      pass ();
    else
      fail ("PLANESURFACE.sab_size [BL] %u != %u", planesurface->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "sab_size", &sab_size, 0)
        && sab_size == planesurface->sab_size)
      pass ();
    else
      fail ("PLANESURFACE.sab_size [BL] set+1 %u != %u", planesurface->sab_size, sab_size);
    planesurface->sab_size--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == planesurface->silhouettes)
      pass ();
    else
      fail ("PLANESURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == planesurface->u_isolines)
      pass ();
    else
      fail ("PLANESURFACE.u_isolines [BS] %hu != %hu", planesurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == planesurface->u_isolines)
      pass ();
    else
      fail ("PLANESURFACE.u_isolines [BS] set+1 %hu != %hu", planesurface->u_isolines, u_isolines);
    planesurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "unknown", &unknown, NULL)
        && unknown == planesurface->unknown)
      pass ();
    else
      fail ("PLANESURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", planesurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "unknown", &unknown, 0)
        && unknown == planesurface->unknown)
      pass ();
    else
      fail ("PLANESURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->unknown, unknown);
    planesurface->unknown--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == planesurface->v_isolines)
      pass ();
    else
      fail ("PLANESURFACE.v_isolines [BS] %hu != %hu", planesurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == planesurface->v_isolines)
      pass ();
    else
      fail ("PLANESURFACE.v_isolines [BS] set+1 %hu != %hu", planesurface->v_isolines, v_isolines);
    planesurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "version", &version, NULL)
        && version == planesurface->version)
      pass ();
    else
      fail ("PLANESURFACE.version [BS] %hu != %hu", planesurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "version", &version, 0)
        && version == planesurface->version)
      pass ();
    else
      fail ("PLANESURFACE.version [BS] set+1 %hu != %hu", planesurface->version, version);
    planesurface->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == planesurface->wireframe_data_present)
      pass ();
    else
      fail ("PLANESURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == planesurface->wireframe_data_present)
      pass ();
    else
      fail ("PLANESURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->wireframe_data_present, wireframe_data_present);
    planesurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "wires", &wires, NULL)
        && wires == planesurface->wires)
      pass ();
    else
      fail ("PLANESURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("PLANESURFACE") || is_class_debugging ("PLANESURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PLANESURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POINT *restrict point = obj->tio.entity->tio.POINT;
  failed = 0;
  if (!obj_obj || !point)
    {
      fail ("NULL POINT");
      return 1;
    }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (point, "POINT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &point->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("POINT.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (point, "POINT", "parent", &parent, NULL)
        && !memcmp (&parent, &point->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POINT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (point, "POINT", "thickness", &thickness, NULL)
        && thickness == point->thickness)
      pass ();
    else
      fail ("POINT.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", point->thickness, thickness);
    if (dwg_dynapi_entity_set_value (point, "POINT", "thickness", &thickness, 0)
        && thickness == point->thickness)
      pass ();
    else
      fail ("POINT.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", point->thickness, thickness);
    point->thickness--;
  }
  {
    BITCODE_BD x;
    if (dwg_dynapi_entity_value (point, "POINT", "x", &x, NULL)
        && x == point->x)
      pass ();
    else
      fail ("POINT.x [BD] %g != %g", point->x, x);
    x++;
    if (dwg_dynapi_entity_set_value (point, "POINT", "x", &x, 0)
        && x == point->x)
      pass ();
    else
      fail ("POINT.x [BD] set+1 %g != %g", point->x, x);
    point->x--;
  }
  {
    BITCODE_BD x_ang;
    if (dwg_dynapi_entity_value (point, "POINT", "x_ang", &x_ang, NULL)
        && x_ang == point->x_ang)
      pass ();
    else
      fail ("POINT.x_ang [BD] %g != %g", point->x_ang, x_ang);
    x_ang++;
    if (dwg_dynapi_entity_set_value (point, "POINT", "x_ang", &x_ang, 0)
        && x_ang == point->x_ang)
      pass ();
    else
      fail ("POINT.x_ang [BD] set+1 %g != %g", point->x_ang, x_ang);
    point->x_ang--;
  }
  {
    BITCODE_BD y;
    if (dwg_dynapi_entity_value (point, "POINT", "y", &y, NULL)
        && y == point->y)
      pass ();
    else
      fail ("POINT.y [BD] %g != %g", point->y, y);
    y++;
    if (dwg_dynapi_entity_set_value (point, "POINT", "y", &y, 0)
        && y == point->y)
      pass ();
    else
      fail ("POINT.y [BD] set+1 %g != %g", point->y, y);
    point->y--;
  }
  {
    BITCODE_BD z;
    if (dwg_dynapi_entity_value (point, "POINT", "z", &z, NULL)
        && z == point->z)
      pass ();
    else
      fail ("POINT.z [BD] %g != %g", point->z, z);
    z++;
    if (dwg_dynapi_entity_set_value (point, "POINT", "z", &z, 0)
        && z == point->z)
      pass ();
    else
      fail ("POINT.z [BD] set+1 %g != %g", point->z, z);
    point->z--;
  }
  if (failed && (is_class_unstable ("POINT") || is_class_debugging ("POINT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINT", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTCLOUD (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POINTCLOUD *restrict pointcloud = obj->tio.entity->tio.POINTCLOUD;
  failed = 0;
  if (!obj_obj || !pointcloud)
    {
      fail ("NULL POINTCLOUD");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "class_version", &class_version, NULL)
        && class_version == pointcloud->class_version)
      pass ();
    else
      fail ("POINTCLOUD.class_version [BS] %hu != %hu", pointcloud->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (pointcloud, "POINTCLOUD", "class_version", &class_version, 0)
        && class_version == pointcloud->class_version)
      pass ();
    else
      fail ("POINTCLOUD.class_version [BS] set+1 %hu != %hu", pointcloud->class_version, class_version);
    pointcloud->class_version--;
  }
  {
    Dwg_POINTCLOUD_Clippings* clippings;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "num_clippings", &count, NULL)
        && dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "clippings", &clippings, NULL)
        && clippings == pointcloud->clippings)
      pass ();
    else
      fail ("POINTCLOUD.clippings [Dwg_POINTCLOUD_Clippings*] * %u num_clippings", count);
  }
  {
    BITCODE_3BD extents_max;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "extents_max", &extents_max, NULL)
        && !memcmp (&extents_max, &pointcloud->extents_max, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUD.extents_max [3BD]");
  }
  {
    BITCODE_3BD extents_min;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "extents_min", &extents_min, NULL)
        && !memcmp (&extents_min, &pointcloud->extents_min, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUD.extents_min [3BD]");
  }
  {
    BITCODE_BS intensity_scheme;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "intensity_scheme", &intensity_scheme, NULL)
        && intensity_scheme == pointcloud->intensity_scheme)
      pass ();
    else
      fail ("POINTCLOUD.intensity_scheme [BS] %hu != %hu", pointcloud->intensity_scheme, intensity_scheme);
    intensity_scheme++;
    if (dwg_dynapi_entity_set_value (pointcloud, "POINTCLOUD", "intensity_scheme", &intensity_scheme, 0)
        && intensity_scheme == pointcloud->intensity_scheme)
      pass ();
    else
      fail ("POINTCLOUD.intensity_scheme [BS] set+1 %hu != %hu", pointcloud->intensity_scheme, intensity_scheme);
    pointcloud->intensity_scheme--;
  }
  {
    Dwg_POINTCLOUD_IntensityStyle intensity_style;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "intensity_style", &intensity_style, NULL)
        && !memcmp (&intensity_style, &pointcloud->intensity_style, sizeof (Dwg_POINTCLOUD_IntensityStyle)))
        pass ();
    else
        fail ("POINTCLOUD.intensity_style [Dwg_POINTCLOUD_IntensityStyle]");
  }
  {
    BITCODE_BL num_clippings;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "num_clippings", &num_clippings, NULL)
        && num_clippings == pointcloud->num_clippings)
      pass ();
    else
      fail ("POINTCLOUD.num_clippings [BL] %u != %u", pointcloud->num_clippings, num_clippings);
    num_clippings++;
    if (dwg_dynapi_entity_set_value (pointcloud, "POINTCLOUD", "num_clippings", &num_clippings, 0)
        && num_clippings == pointcloud->num_clippings)
      pass ();
    else
      fail ("POINTCLOUD.num_clippings [BL] set+1 %u != %u", pointcloud->num_clippings, num_clippings);
    pointcloud->num_clippings--;
  }
  {
    BITCODE_BL num_source_files;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "num_source_files", &num_source_files, NULL)
        && num_source_files == pointcloud->num_source_files)
      pass ();
    else
      fail ("POINTCLOUD.num_source_files [BL] %u != %u", pointcloud->num_source_files, num_source_files);
    num_source_files++;
    if (dwg_dynapi_entity_set_value (pointcloud, "POINTCLOUD", "num_source_files", &num_source_files, 0)
        && num_source_files == pointcloud->num_source_files)
      pass ();
    else
      fail ("POINTCLOUD.num_source_files [BL] set+1 %u != %u", pointcloud->num_source_files, num_source_files);
    pointcloud->num_source_files--;
  }
  {
    BITCODE_RLL numpoints;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "numpoints", &numpoints, NULL)
        && numpoints == pointcloud->numpoints)
      pass ();
    else
      fail ("POINTCLOUD.numpoints [RLL] " FORMAT_RLL " != " FORMAT_RLL "", pointcloud->numpoints, numpoints);
    numpoints++;
    if (dwg_dynapi_entity_set_value (pointcloud, "POINTCLOUD", "numpoints", &numpoints, 0)
        && numpoints == pointcloud->numpoints)
      pass ();
    else
      fail ("POINTCLOUD.numpoints [RLL] set+1 " FORMAT_RLL " != " FORMAT_RLL "", pointcloud->numpoints, numpoints);
    pointcloud->numpoints--;
  }
  {
    BITCODE_3BD origin;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "origin", &origin, NULL)
        && !memcmp (&origin, &pointcloud->origin, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUD.origin [3BD]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "parent", &parent, NULL)
        && !memcmp (&parent, &pointcloud->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POINTCLOUD.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H pointclouddef;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "pointclouddef", &pointclouddef, NULL)
        && !memcmp (&pointclouddef, &pointcloud->pointclouddef, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POINTCLOUD.pointclouddef [H]");
  }
  {
    BITCODE_H reactor;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "reactor", &reactor, NULL)
        && !memcmp (&reactor, &pointcloud->reactor, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POINTCLOUD.reactor [H]");
  }
  {
    BITCODE_T saved_filename;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "saved_filename", &saved_filename, NULL)
        && saved_filename
           ? strEQ ((char *)saved_filename, (char *)pointcloud->saved_filename)
           : !pointcloud->saved_filename)
      pass ();
    else
      fail ("POINTCLOUD.saved_filename [T] '%s' <> '%s'", saved_filename, pointcloud->saved_filename);
  }
  {
    BITCODE_B show_clipping;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "show_clipping", &show_clipping, NULL)
        && show_clipping == pointcloud->show_clipping)
      pass ();
    else
      fail ("POINTCLOUD.show_clipping [B] " FORMAT_B " != " FORMAT_B "", pointcloud->show_clipping, show_clipping);
    show_clipping++;
    if (dwg_dynapi_entity_set_value (pointcloud, "POINTCLOUD", "show_clipping", &show_clipping, 0)
        && show_clipping == pointcloud->show_clipping)
      pass ();
    else
      fail ("POINTCLOUD.show_clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", pointcloud->show_clipping, show_clipping);
    pointcloud->show_clipping--;
  }
  {
    BITCODE_B show_intensity;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "show_intensity", &show_intensity, NULL)
        && show_intensity == pointcloud->show_intensity)
      pass ();
    else
      fail ("POINTCLOUD.show_intensity [B] " FORMAT_B " != " FORMAT_B "", pointcloud->show_intensity, show_intensity);
    show_intensity++;
    if (dwg_dynapi_entity_set_value (pointcloud, "POINTCLOUD", "show_intensity", &show_intensity, 0)
        && show_intensity == pointcloud->show_intensity)
      pass ();
    else
      fail ("POINTCLOUD.show_intensity [B] set+1 " FORMAT_B " != " FORMAT_B "", pointcloud->show_intensity, show_intensity);
    pointcloud->show_intensity--;
  }
  {
    BITCODE_TV* source_files;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "num_source_files", &count, NULL)
        && dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "source_files", &source_files, NULL)
        && source_files == pointcloud->source_files)
      pass ();
    else
      fail ("POINTCLOUD.source_files [TV*] * %u num_source_files", count);
  }
  {
    BITCODE_T ucs_name;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "ucs_name", &ucs_name, NULL)
        && ucs_name
           ? strEQ ((char *)ucs_name, (char *)pointcloud->ucs_name)
           : !pointcloud->ucs_name)
      pass ();
    else
      fail ("POINTCLOUD.ucs_name [T] '%s' <> '%s'", ucs_name, pointcloud->ucs_name);
  }
  {
    BITCODE_3BD ucs_origin;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "ucs_origin", &ucs_origin, NULL)
        && !memcmp (&ucs_origin, &pointcloud->ucs_origin, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUD.ucs_origin [3BD]");
  }
  {
    BITCODE_3BD ucs_x_dir;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "ucs_x_dir", &ucs_x_dir, NULL)
        && !memcmp (&ucs_x_dir, &pointcloud->ucs_x_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUD.ucs_x_dir [3BD]");
  }
  {
    BITCODE_3BD ucs_y_dir;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "ucs_y_dir", &ucs_y_dir, NULL)
        && !memcmp (&ucs_y_dir, &pointcloud->ucs_y_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUD.ucs_y_dir [3BD]");
  }
  {
    BITCODE_3BD ucs_z_dir;
    if (dwg_dynapi_entity_value (pointcloud, "POINTCLOUD", "ucs_z_dir", &ucs_z_dir, NULL)
        && !memcmp (&ucs_z_dir, &pointcloud->ucs_z_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUD.ucs_z_dir [3BD]");
  }
  if (failed && (is_class_unstable ("POINTCLOUD") || is_class_debugging ("POINTCLOUD")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTCLOUD", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTCLOUDEX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POINTCLOUDEX *restrict pointcloudex = obj->tio.entity->tio.POINTCLOUDEX;
  failed = 0;
  if (!obj_obj || !pointcloudex)
    {
      fail ("NULL POINTCLOUDEX");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "class_version", &class_version, NULL)
        && class_version == pointcloudex->class_version)
      pass ();
    else
      fail ("POINTCLOUDEX.class_version [BS] %hu != %hu", pointcloudex->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "class_version", &class_version, 0)
        && class_version == pointcloudex->class_version)
      pass ();
    else
      fail ("POINTCLOUDEX.class_version [BS] set+1 %hu != %hu", pointcloudex->class_version, class_version);
    pointcloudex->class_version--;
  }
  {
    BITCODE_T classification_colorscheme;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "classification_colorscheme", &classification_colorscheme, NULL)
        && classification_colorscheme
           ? strEQ ((char *)classification_colorscheme, (char *)pointcloudex->classification_colorscheme)
           : !pointcloudex->classification_colorscheme)
      pass ();
    else
      fail ("POINTCLOUDEX.classification_colorscheme [T] '%s' <> '%s'", classification_colorscheme, pointcloudex->classification_colorscheme);
  }
  {
    Dwg_POINTCLOUDEX_Croppings* croppings;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "num_croppings", &count, NULL)
        && dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "croppings", &croppings, NULL)
        && croppings == pointcloudex->croppings)
      pass ();
    else
      fail ("POINTCLOUDEX.croppings [Dwg_POINTCLOUDEX_Croppings*] * %u num_croppings", count);
  }
  {
    BITCODE_T cur_colorscheme;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "cur_colorscheme", &cur_colorscheme, NULL)
        && cur_colorscheme
           ? strEQ ((char *)cur_colorscheme, (char *)pointcloudex->cur_colorscheme)
           : !pointcloudex->cur_colorscheme)
      pass ();
    else
      fail ("POINTCLOUDEX.cur_colorscheme [T] '%s' <> '%s'", cur_colorscheme, pointcloudex->cur_colorscheme);
  }
  {
    BITCODE_B elevation_apply_to_fixed_range;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "elevation_apply_to_fixed_range", &elevation_apply_to_fixed_range, NULL)
        && elevation_apply_to_fixed_range == pointcloudex->elevation_apply_to_fixed_range)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_apply_to_fixed_range [B] " FORMAT_B " != " FORMAT_B "", pointcloudex->elevation_apply_to_fixed_range, elevation_apply_to_fixed_range);
    elevation_apply_to_fixed_range++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "elevation_apply_to_fixed_range", &elevation_apply_to_fixed_range, 0)
        && elevation_apply_to_fixed_range == pointcloudex->elevation_apply_to_fixed_range)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_apply_to_fixed_range [B] set+1 " FORMAT_B " != " FORMAT_B "", pointcloudex->elevation_apply_to_fixed_range, elevation_apply_to_fixed_range);
    pointcloudex->elevation_apply_to_fixed_range--;
  }
  {
    BITCODE_B elevation_as_gradient;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "elevation_as_gradient", &elevation_as_gradient, NULL)
        && elevation_as_gradient == pointcloudex->elevation_as_gradient)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_as_gradient [B] " FORMAT_B " != " FORMAT_B "", pointcloudex->elevation_as_gradient, elevation_as_gradient);
    elevation_as_gradient++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "elevation_as_gradient", &elevation_as_gradient, 0)
        && elevation_as_gradient == pointcloudex->elevation_as_gradient)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_as_gradient [B] set+1 " FORMAT_B " != " FORMAT_B "", pointcloudex->elevation_as_gradient, elevation_as_gradient);
    pointcloudex->elevation_as_gradient--;
  }
  {
    BITCODE_BD elevation_max;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "elevation_max", &elevation_max, NULL)
        && elevation_max == pointcloudex->elevation_max)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_max [BD] %g != %g", pointcloudex->elevation_max, elevation_max);
    elevation_max++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "elevation_max", &elevation_max, 0)
        && elevation_max == pointcloudex->elevation_max)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_max [BD] set+1 %g != %g", pointcloudex->elevation_max, elevation_max);
    pointcloudex->elevation_max--;
  }
  {
    BITCODE_BD elevation_min;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "elevation_min", &elevation_min, NULL)
        && elevation_min == pointcloudex->elevation_min)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_min [BD] %g != %g", pointcloudex->elevation_min, elevation_min);
    elevation_min++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "elevation_min", &elevation_min, 0)
        && elevation_min == pointcloudex->elevation_min)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_min [BD] set+1 %g != %g", pointcloudex->elevation_min, elevation_min);
    pointcloudex->elevation_min--;
  }
  {
    BITCODE_BS elevation_out_of_range_behavior;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "elevation_out_of_range_behavior", &elevation_out_of_range_behavior, NULL)
        && elevation_out_of_range_behavior == pointcloudex->elevation_out_of_range_behavior)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_out_of_range_behavior [BS] %hu != %hu", pointcloudex->elevation_out_of_range_behavior, elevation_out_of_range_behavior);
    elevation_out_of_range_behavior++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "elevation_out_of_range_behavior", &elevation_out_of_range_behavior, 0)
        && elevation_out_of_range_behavior == pointcloudex->elevation_out_of_range_behavior)
      pass ();
    else
      fail ("POINTCLOUDEX.elevation_out_of_range_behavior [BS] set+1 %hu != %hu", pointcloudex->elevation_out_of_range_behavior, elevation_out_of_range_behavior);
    pointcloudex->elevation_out_of_range_behavior--;
  }
  {
    BITCODE_3BD extents_max;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "extents_max", &extents_max, NULL)
        && !memcmp (&extents_max, &pointcloudex->extents_max, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDEX.extents_max [3BD]");
  }
  {
    BITCODE_3BD extents_min;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "extents_min", &extents_min, NULL)
        && !memcmp (&extents_min, &pointcloudex->extents_min, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDEX.extents_min [3BD]");
  }
  {
    BITCODE_B intensity_as_gradient;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "intensity_as_gradient", &intensity_as_gradient, NULL)
        && intensity_as_gradient == pointcloudex->intensity_as_gradient)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_as_gradient [B] " FORMAT_B " != " FORMAT_B "", pointcloudex->intensity_as_gradient, intensity_as_gradient);
    intensity_as_gradient++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "intensity_as_gradient", &intensity_as_gradient, 0)
        && intensity_as_gradient == pointcloudex->intensity_as_gradient)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_as_gradient [B] set+1 " FORMAT_B " != " FORMAT_B "", pointcloudex->intensity_as_gradient, intensity_as_gradient);
    pointcloudex->intensity_as_gradient--;
  }
  {
    BITCODE_T intensity_colorscheme;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "intensity_colorscheme", &intensity_colorscheme, NULL)
        && intensity_colorscheme
           ? strEQ ((char *)intensity_colorscheme, (char *)pointcloudex->intensity_colorscheme)
           : !pointcloudex->intensity_colorscheme)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_colorscheme [T] '%s' <> '%s'", intensity_colorscheme, pointcloudex->intensity_colorscheme);
  }
  {
    BITCODE_BL intensity_max;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "intensity_max", &intensity_max, NULL)
        && intensity_max == pointcloudex->intensity_max)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_max [BL] %u != %u", pointcloudex->intensity_max, intensity_max);
    intensity_max++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "intensity_max", &intensity_max, 0)
        && intensity_max == pointcloudex->intensity_max)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_max [BL] set+1 %u != %u", pointcloudex->intensity_max, intensity_max);
    pointcloudex->intensity_max--;
  }
  {
    BITCODE_BL intensity_min;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "intensity_min", &intensity_min, NULL)
        && intensity_min == pointcloudex->intensity_min)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_min [BL] %u != %u", pointcloudex->intensity_min, intensity_min);
    intensity_min++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "intensity_min", &intensity_min, 0)
        && intensity_min == pointcloudex->intensity_min)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_min [BL] set+1 %u != %u", pointcloudex->intensity_min, intensity_min);
    pointcloudex->intensity_min--;
  }
  {
    BITCODE_BS intensity_out_of_range_behavior;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "intensity_out_of_range_behavior", &intensity_out_of_range_behavior, NULL)
        && intensity_out_of_range_behavior == pointcloudex->intensity_out_of_range_behavior)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_out_of_range_behavior [BS] %hu != %hu", pointcloudex->intensity_out_of_range_behavior, intensity_out_of_range_behavior);
    intensity_out_of_range_behavior++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "intensity_out_of_range_behavior", &intensity_out_of_range_behavior, 0)
        && intensity_out_of_range_behavior == pointcloudex->intensity_out_of_range_behavior)
      pass ();
    else
      fail ("POINTCLOUDEX.intensity_out_of_range_behavior [BS] set+1 %hu != %hu", pointcloudex->intensity_out_of_range_behavior, intensity_out_of_range_behavior);
    pointcloudex->intensity_out_of_range_behavior--;
  }
  {
    BITCODE_B is_locked;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "is_locked", &is_locked, NULL)
        && is_locked == pointcloudex->is_locked)
      pass ();
    else
      fail ("POINTCLOUDEX.is_locked [B] " FORMAT_B " != " FORMAT_B "", pointcloudex->is_locked, is_locked);
    is_locked++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "is_locked", &is_locked, 0)
        && is_locked == pointcloudex->is_locked)
      pass ();
    else
      fail ("POINTCLOUDEX.is_locked [B] set+1 " FORMAT_B " != " FORMAT_B "", pointcloudex->is_locked, is_locked);
    pointcloudex->is_locked--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)pointcloudex->name)
           : !pointcloudex->name)
      pass ();
    else
      fail ("POINTCLOUDEX.name [T] '%s' <> '%s'", name, pointcloudex->name);
  }
  {
    BITCODE_BL num_croppings;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "num_croppings", &num_croppings, NULL)
        && num_croppings == pointcloudex->num_croppings)
      pass ();
    else
      fail ("POINTCLOUDEX.num_croppings [BL] %u != %u", pointcloudex->num_croppings, num_croppings);
    num_croppings++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "num_croppings", &num_croppings, 0)
        && num_croppings == pointcloudex->num_croppings)
      pass ();
    else
      fail ("POINTCLOUDEX.num_croppings [BL] set+1 %u != %u", pointcloudex->num_croppings, num_croppings);
    pointcloudex->num_croppings--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "parent", &parent, NULL)
        && !memcmp (&parent, &pointcloudex->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POINTCLOUDEX.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H pointclouddefex;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "pointclouddefex", &pointclouddefex, NULL)
        && !memcmp (&pointclouddefex, &pointcloudex->pointclouddefex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POINTCLOUDEX.pointclouddefex [H]");
  }
  {
    BITCODE_H reactor;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "reactor", &reactor, NULL)
        && !memcmp (&reactor, &pointcloudex->reactor, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POINTCLOUDEX.reactor [H]");
  }
  {
    BITCODE_B show_cropping;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "show_cropping", &show_cropping, NULL)
        && show_cropping == pointcloudex->show_cropping)
      pass ();
    else
      fail ("POINTCLOUDEX.show_cropping [B] " FORMAT_B " != " FORMAT_B "", pointcloudex->show_cropping, show_cropping);
    show_cropping++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "show_cropping", &show_cropping, 0)
        && show_cropping == pointcloudex->show_cropping)
      pass ();
    else
      fail ("POINTCLOUDEX.show_cropping [B] set+1 " FORMAT_B " != " FORMAT_B "", pointcloudex->show_cropping, show_cropping);
    pointcloudex->show_cropping--;
  }
  {
    BITCODE_B show_intensity;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "show_intensity", &show_intensity, NULL)
        && show_intensity == pointcloudex->show_intensity)
      pass ();
    else
      fail ("POINTCLOUDEX.show_intensity [B] " FORMAT_B " != " FORMAT_B "", pointcloudex->show_intensity, show_intensity);
    show_intensity++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "show_intensity", &show_intensity, 0)
        && show_intensity == pointcloudex->show_intensity)
      pass ();
    else
      fail ("POINTCLOUDEX.show_intensity [B] set+1 " FORMAT_B " != " FORMAT_B "", pointcloudex->show_intensity, show_intensity);
    pointcloudex->show_intensity--;
  }
  {
    BITCODE_BS stylization_type;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "stylization_type", &stylization_type, NULL)
        && stylization_type == pointcloudex->stylization_type)
      pass ();
    else
      fail ("POINTCLOUDEX.stylization_type [BS] %hu != %hu", pointcloudex->stylization_type, stylization_type);
    stylization_type++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "stylization_type", &stylization_type, 0)
        && stylization_type == pointcloudex->stylization_type)
      pass ();
    else
      fail ("POINTCLOUDEX.stylization_type [BS] set+1 %hu != %hu", pointcloudex->stylization_type, stylization_type);
    pointcloudex->stylization_type--;
  }
  {
    BITCODE_3BD ucs_origin;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "ucs_origin", &ucs_origin, NULL)
        && !memcmp (&ucs_origin, &pointcloudex->ucs_origin, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDEX.ucs_origin [3BD]");
  }
  {
    BITCODE_3BD ucs_x_dir;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "ucs_x_dir", &ucs_x_dir, NULL)
        && !memcmp (&ucs_x_dir, &pointcloudex->ucs_x_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDEX.ucs_x_dir [3BD]");
  }
  {
    BITCODE_3BD ucs_y_dir;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "ucs_y_dir", &ucs_y_dir, NULL)
        && !memcmp (&ucs_y_dir, &pointcloudex->ucs_y_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDEX.ucs_y_dir [3BD]");
  }
  {
    BITCODE_3BD ucs_z_dir;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "ucs_z_dir", &ucs_z_dir, NULL)
        && !memcmp (&ucs_z_dir, &pointcloudex->ucs_z_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDEX.ucs_z_dir [3BD]");
  }
  {
    BITCODE_BL unknown_bl0;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "unknown_bl0", &unknown_bl0, NULL)
        && unknown_bl0 == pointcloudex->unknown_bl0)
      pass ();
    else
      fail ("POINTCLOUDEX.unknown_bl0 [BL] %u != %u", pointcloudex->unknown_bl0, unknown_bl0);
    unknown_bl0++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "unknown_bl0", &unknown_bl0, 0)
        && unknown_bl0 == pointcloudex->unknown_bl0)
      pass ();
    else
      fail ("POINTCLOUDEX.unknown_bl0 [BL] set+1 %u != %u", pointcloudex->unknown_bl0, unknown_bl0);
    pointcloudex->unknown_bl0--;
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value (pointcloudex, "POINTCLOUDEX", "unknown_bl1", &unknown_bl1, NULL)
        && unknown_bl1 == pointcloudex->unknown_bl1)
      pass ();
    else
      fail ("POINTCLOUDEX.unknown_bl1 [BL] %u != %u", pointcloudex->unknown_bl1, unknown_bl1);
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value (pointcloudex, "POINTCLOUDEX", "unknown_bl1", &unknown_bl1, 0)
        && unknown_bl1 == pointcloudex->unknown_bl1)
      pass ();
    else
      fail ("POINTCLOUDEX.unknown_bl1 [BL] set+1 %u != %u", pointcloudex->unknown_bl1, unknown_bl1);
    pointcloudex->unknown_bl1--;
  }
  if (failed && (is_class_unstable ("POINTCLOUDEX") || is_class_debugging ("POINTCLOUDEX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTCLOUDEX", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTPARAMETERENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POINTPARAMETERENTITY *restrict pointparameterentity = obj->tio.entity->tio.POINTPARAMETERENTITY;
  failed = 0;
  if (!obj_obj || !pointparameterentity)
    {
      fail ("NULL POINTPARAMETERENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (pointparameterentity, "POINTPARAMETERENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &pointparameterentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POINTPARAMETERENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("POINTPARAMETERENTITY") || is_class_debugging ("POINTPARAMETERENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTPARAMETERENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLARGRIPENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLARGRIPENTITY *restrict polargripentity = obj->tio.entity->tio.POLARGRIPENTITY;
  failed = 0;
  if (!obj_obj || !polargripentity)
    {
      fail ("NULL POLARGRIPENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polargripentity, "POLARGRIPENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &polargripentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POLARGRIPENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("POLARGRIPENTITY") || is_class_debugging ("POLARGRIPENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLARGRIPENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_2D (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_2D *restrict polyline_2d = obj->tio.entity->tio.POLYLINE_2D;
  failed = 0;
  if (!obj_obj || !polyline_2d)
    {
      fail ("NULL POLYLINE_2D");
      return 1;
    }
  {
    BITCODE_BS curve_type;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "curve_type", &curve_type, NULL)
        && curve_type == polyline_2d->curve_type)
      pass ();
    else
      fail ("POLYLINE_2D.curve_type [BS] %hu != %hu", polyline_2d->curve_type, curve_type);
    curve_type++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "curve_type", &curve_type, 0)
        && curve_type == polyline_2d->curve_type)
      pass ();
    else
      fail ("POLYLINE_2D.curve_type [BS] set+1 %hu != %hu", polyline_2d->curve_type, curve_type);
    polyline_2d->curve_type--;
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "elevation", &elevation, NULL)
        && elevation == polyline_2d->elevation)
      pass ();
    else
      fail ("POLYLINE_2D.elevation [BD] %g != %g", polyline_2d->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "elevation", &elevation, 0)
        && elevation == polyline_2d->elevation)
      pass ();
    else
      fail ("POLYLINE_2D.elevation [BD] set+1 %g != %g", polyline_2d->elevation, elevation);
    polyline_2d->elevation--;
  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "end_width", &end_width, NULL)
        && end_width == polyline_2d->end_width)
      pass ();
    else
      fail ("POLYLINE_2D.end_width [BD] %g != %g", polyline_2d->end_width, end_width);
    end_width++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "end_width", &end_width, 0)
        && end_width == polyline_2d->end_width)
      pass ();
    else
      fail ("POLYLINE_2D.end_width [BD] set+1 %g != %g", polyline_2d->end_width, end_width);
    polyline_2d->end_width--;
  }
  {
    BITCODE_BL extra_r11_size;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "extra_r11_size", &extra_r11_size, NULL)
        && extra_r11_size == polyline_2d->extra_r11_size)
      pass ();
    else
      fail ("POLYLINE_2D.extra_r11_size [BL] %u != %u", polyline_2d->extra_r11_size, extra_r11_size);
    extra_r11_size++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "extra_r11_size", &extra_r11_size, 0)
        && extra_r11_size == polyline_2d->extra_r11_size)
      pass ();
    else
      fail ("POLYLINE_2D.extra_r11_size [BL] set+1 %u != %u", polyline_2d->extra_r11_size, extra_r11_size);
    polyline_2d->extra_r11_size--;
  }
  {
    BITCODE_TV extra_r11_text;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "extra_r11_text", &extra_r11_text, NULL)
        && extra_r11_text
           ? strEQ ((char *)extra_r11_text, (char *)polyline_2d->extra_r11_text)
           : !polyline_2d->extra_r11_text)
      pass ();
    else
      fail ("POLYLINE_2D.extra_r11_text [TV] '%s' <> '%s'", extra_r11_text, polyline_2d->extra_r11_text);
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &polyline_2d->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("POLYLINE_2D.extrusion [BE]");
  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "first_vertex", &first_vertex, NULL)
        && !memcmp (&first_vertex, &polyline_2d->first_vertex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_2D.first_vertex [H]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "flag", &flag, NULL)
        && flag == polyline_2d->flag)
      pass ();
    else
      fail ("POLYLINE_2D.flag [BS] %hu != %hu", polyline_2d->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "flag", &flag, 0)
        && flag == polyline_2d->flag)
      pass ();
    else
      fail ("POLYLINE_2D.flag [BS] set+1 %hu != %hu", polyline_2d->flag, flag);
    polyline_2d->flag--;
  }
  {
    BITCODE_B has_vertex;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "has_vertex", &has_vertex, NULL)
        && has_vertex == polyline_2d->has_vertex)
      pass ();
    else
      fail ("POLYLINE_2D.has_vertex [B] " FORMAT_B " != " FORMAT_B "", polyline_2d->has_vertex, has_vertex);
    has_vertex++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "has_vertex", &has_vertex, 0)
        && has_vertex == polyline_2d->has_vertex)
      pass ();
    else
      fail ("POLYLINE_2D.has_vertex [B] set+1 " FORMAT_B " != " FORMAT_B "", polyline_2d->has_vertex, has_vertex);
    polyline_2d->has_vertex--;
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "last_vertex", &last_vertex, NULL)
        && !memcmp (&last_vertex, &polyline_2d->last_vertex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_2D.last_vertex [H]");
  }
  {
    BITCODE_BS num_m_verts;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "num_m_verts", &num_m_verts, NULL)
        && num_m_verts == polyline_2d->num_m_verts)
      pass ();
    else
      fail ("POLYLINE_2D.num_m_verts [BS] %hu != %hu", polyline_2d->num_m_verts, num_m_verts);
    num_m_verts++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "num_m_verts", &num_m_verts, 0)
        && num_m_verts == polyline_2d->num_m_verts)
      pass ();
    else
      fail ("POLYLINE_2D.num_m_verts [BS] set+1 %hu != %hu", polyline_2d->num_m_verts, num_m_verts);
    polyline_2d->num_m_verts--;
  }
  {
    BITCODE_BS num_n_verts;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "num_n_verts", &num_n_verts, NULL)
        && num_n_verts == polyline_2d->num_n_verts)
      pass ();
    else
      fail ("POLYLINE_2D.num_n_verts [BS] %hu != %hu", polyline_2d->num_n_verts, num_n_verts);
    num_n_verts++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "num_n_verts", &num_n_verts, 0)
        && num_n_verts == polyline_2d->num_n_verts)
      pass ();
    else
      fail ("POLYLINE_2D.num_n_verts [BS] set+1 %hu != %hu", polyline_2d->num_n_verts, num_n_verts);
    polyline_2d->num_n_verts--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "num_owned", &num_owned, NULL)
        && num_owned == polyline_2d->num_owned)
      pass ();
    else
      fail ("POLYLINE_2D.num_owned [BL] %u != %u", polyline_2d->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "num_owned", &num_owned, 0)
        && num_owned == polyline_2d->num_owned)
      pass ();
    else
      fail ("POLYLINE_2D.num_owned [BL] set+1 %u != %u", polyline_2d->num_owned, num_owned);
    polyline_2d->num_owned--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_2d->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POLYLINE_2D.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &polyline_2d->seqend, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_2D.seqend [H]");
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "start_width", &start_width, NULL)
        && start_width == polyline_2d->start_width)
      pass ();
    else
      fail ("POLYLINE_2D.start_width [BD] %g != %g", polyline_2d->start_width, start_width);
    start_width++;
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "start_width", &start_width, 0)
        && start_width == polyline_2d->start_width)
      pass ();
    else
      fail ("POLYLINE_2D.start_width [BD] set+1 %g != %g", polyline_2d->start_width, start_width);
    polyline_2d->start_width--;
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "thickness", &thickness, NULL)
        && thickness == polyline_2d->thickness)
      pass ();
    else
      fail ("POLYLINE_2D.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", polyline_2d->thickness, thickness);
    if (dwg_dynapi_entity_set_value (polyline_2d, "POLYLINE_2D", "thickness", &thickness, 0)
        && thickness == polyline_2d->thickness)
      pass ();
    else
      fail ("POLYLINE_2D.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", polyline_2d->thickness, thickness);
    polyline_2d->thickness--;
  }
  {
    BITCODE_H* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (polyline_2d, "POLYLINE_2D", "vertex", &vertex, NULL)
        && vertex == polyline_2d->vertex)
      pass ();
    else
      fail ("POLYLINE_2D.vertex [H*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("POLYLINE_2D") || is_class_debugging ("POLYLINE_2D")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_2D", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_3D (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_3D *restrict polyline_3d = obj->tio.entity->tio.POLYLINE_3D;
  failed = 0;
  if (!obj_obj || !polyline_3d)
    {
      fail ("NULL POLYLINE_3D");
      return 1;
    }
  {
    BITCODE_RC curve_type;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "curve_type", &curve_type, NULL)
        && curve_type == polyline_3d->curve_type)
      pass ();
    else
      fail ("POLYLINE_3D.curve_type [RC] %u != %u", polyline_3d->curve_type, curve_type);
    curve_type++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "curve_type", &curve_type, 0)
        && curve_type == polyline_3d->curve_type)
      pass ();
    else
      fail ("POLYLINE_3D.curve_type [RC] set+1 %u != %u", polyline_3d->curve_type, curve_type);
    polyline_3d->curve_type--;
  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "end_width", &end_width, NULL)
        && end_width == polyline_3d->end_width)
      pass ();
    else
      fail ("POLYLINE_3D.end_width [BD] %g != %g", polyline_3d->end_width, end_width);
    end_width++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "end_width", &end_width, 0)
        && end_width == polyline_3d->end_width)
      pass ();
    else
      fail ("POLYLINE_3D.end_width [BD] set+1 %g != %g", polyline_3d->end_width, end_width);
    polyline_3d->end_width--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &polyline_3d->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("POLYLINE_3D.extrusion [BE]");
  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "first_vertex", &first_vertex, NULL)
        && !memcmp (&first_vertex, &polyline_3d->first_vertex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_3D.first_vertex [H]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "flag", &flag, NULL)
        && flag == polyline_3d->flag)
      pass ();
    else
      fail ("POLYLINE_3D.flag [RC] %u != %u", polyline_3d->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "flag", &flag, 0)
        && flag == polyline_3d->flag)
      pass ();
    else
      fail ("POLYLINE_3D.flag [RC] set+1 %u != %u", polyline_3d->flag, flag);
    polyline_3d->flag--;
  }
  {
    BITCODE_B has_vertex;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "has_vertex", &has_vertex, NULL)
        && has_vertex == polyline_3d->has_vertex)
      pass ();
    else
      fail ("POLYLINE_3D.has_vertex [B] " FORMAT_B " != " FORMAT_B "", polyline_3d->has_vertex, has_vertex);
    has_vertex++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "has_vertex", &has_vertex, 0)
        && has_vertex == polyline_3d->has_vertex)
      pass ();
    else
      fail ("POLYLINE_3D.has_vertex [B] set+1 " FORMAT_B " != " FORMAT_B "", polyline_3d->has_vertex, has_vertex);
    polyline_3d->has_vertex--;
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "last_vertex", &last_vertex, NULL)
        && !memcmp (&last_vertex, &polyline_3d->last_vertex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_3D.last_vertex [H]");
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "num_owned", &num_owned, NULL)
        && num_owned == polyline_3d->num_owned)
      pass ();
    else
      fail ("POLYLINE_3D.num_owned [BL] %u != %u", polyline_3d->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "num_owned", &num_owned, 0)
        && num_owned == polyline_3d->num_owned)
      pass ();
    else
      fail ("POLYLINE_3D.num_owned [BL] set+1 %u != %u", polyline_3d->num_owned, num_owned);
    polyline_3d->num_owned--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_3d->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POLYLINE_3D.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &polyline_3d->seqend, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_3D.seqend [H]");
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "start_width", &start_width, NULL)
        && start_width == polyline_3d->start_width)
      pass ();
    else
      fail ("POLYLINE_3D.start_width [BD] %g != %g", polyline_3d->start_width, start_width);
    start_width++;
    if (dwg_dynapi_entity_set_value (polyline_3d, "POLYLINE_3D", "start_width", &start_width, 0)
        && start_width == polyline_3d->start_width)
      pass ();
    else
      fail ("POLYLINE_3D.start_width [BD] set+1 %g != %g", polyline_3d->start_width, start_width);
    polyline_3d->start_width--;
  }
  {
    BITCODE_H* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (polyline_3d, "POLYLINE_3D", "vertex", &vertex, NULL)
        && vertex == polyline_3d->vertex)
      pass ();
    else
      fail ("POLYLINE_3D.vertex [H*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("POLYLINE_3D") || is_class_debugging ("POLYLINE_3D")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_3D", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_MESH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_MESH *restrict polyline_mesh = obj->tio.entity->tio.POLYLINE_MESH;
  failed = 0;
  if (!obj_obj || !polyline_mesh)
    {
      fail ("NULL POLYLINE_MESH");
      return 1;
    }
  {
    BITCODE_BS curve_type;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "curve_type", &curve_type, NULL)
        && curve_type == polyline_mesh->curve_type)
      pass ();
    else
      fail ("POLYLINE_MESH.curve_type [BS] %hu != %hu", polyline_mesh->curve_type, curve_type);
    curve_type++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "curve_type", &curve_type, 0)
        && curve_type == polyline_mesh->curve_type)
      pass ();
    else
      fail ("POLYLINE_MESH.curve_type [BS] set+1 %hu != %hu", polyline_mesh->curve_type, curve_type);
    polyline_mesh->curve_type--;
  }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "first_vertex", &first_vertex, NULL)
        && !memcmp (&first_vertex, &polyline_mesh->first_vertex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_MESH.first_vertex [H]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "flag", &flag, NULL)
        && flag == polyline_mesh->flag)
      pass ();
    else
      fail ("POLYLINE_MESH.flag [BS] %hu != %hu", polyline_mesh->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "flag", &flag, 0)
        && flag == polyline_mesh->flag)
      pass ();
    else
      fail ("POLYLINE_MESH.flag [BS] set+1 %hu != %hu", polyline_mesh->flag, flag);
    polyline_mesh->flag--;
  }
  {
    BITCODE_B has_vertex;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "has_vertex", &has_vertex, NULL)
        && has_vertex == polyline_mesh->has_vertex)
      pass ();
    else
      fail ("POLYLINE_MESH.has_vertex [B] " FORMAT_B " != " FORMAT_B "", polyline_mesh->has_vertex, has_vertex);
    has_vertex++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "has_vertex", &has_vertex, 0)
        && has_vertex == polyline_mesh->has_vertex)
      pass ();
    else
      fail ("POLYLINE_MESH.has_vertex [B] set+1 " FORMAT_B " != " FORMAT_B "", polyline_mesh->has_vertex, has_vertex);
    polyline_mesh->has_vertex--;
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "last_vertex", &last_vertex, NULL)
        && !memcmp (&last_vertex, &polyline_mesh->last_vertex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_MESH.last_vertex [H]");
  }
  {
    BITCODE_BS m_density;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "m_density", &m_density, NULL)
        && m_density == polyline_mesh->m_density)
      pass ();
    else
      fail ("POLYLINE_MESH.m_density [BS] %hu != %hu", polyline_mesh->m_density, m_density);
    m_density++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "m_density", &m_density, 0)
        && m_density == polyline_mesh->m_density)
      pass ();
    else
      fail ("POLYLINE_MESH.m_density [BS] set+1 %hu != %hu", polyline_mesh->m_density, m_density);
    polyline_mesh->m_density--;
  }
  {
    BITCODE_BS n_density;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "n_density", &n_density, NULL)
        && n_density == polyline_mesh->n_density)
      pass ();
    else
      fail ("POLYLINE_MESH.n_density [BS] %hu != %hu", polyline_mesh->n_density, n_density);
    n_density++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "n_density", &n_density, 0)
        && n_density == polyline_mesh->n_density)
      pass ();
    else
      fail ("POLYLINE_MESH.n_density [BS] set+1 %hu != %hu", polyline_mesh->n_density, n_density);
    polyline_mesh->n_density--;
  }
  {
    BITCODE_BS num_m_verts;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "num_m_verts", &num_m_verts, NULL)
        && num_m_verts == polyline_mesh->num_m_verts)
      pass ();
    else
      fail ("POLYLINE_MESH.num_m_verts [BS] %hu != %hu", polyline_mesh->num_m_verts, num_m_verts);
    num_m_verts++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "num_m_verts", &num_m_verts, 0)
        && num_m_verts == polyline_mesh->num_m_verts)
      pass ();
    else
      fail ("POLYLINE_MESH.num_m_verts [BS] set+1 %hu != %hu", polyline_mesh->num_m_verts, num_m_verts);
    polyline_mesh->num_m_verts--;
  }
  {
    BITCODE_BS num_n_verts;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "num_n_verts", &num_n_verts, NULL)
        && num_n_verts == polyline_mesh->num_n_verts)
      pass ();
    else
      fail ("POLYLINE_MESH.num_n_verts [BS] %hu != %hu", polyline_mesh->num_n_verts, num_n_verts);
    num_n_verts++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "num_n_verts", &num_n_verts, 0)
        && num_n_verts == polyline_mesh->num_n_verts)
      pass ();
    else
      fail ("POLYLINE_MESH.num_n_verts [BS] set+1 %hu != %hu", polyline_mesh->num_n_verts, num_n_verts);
    polyline_mesh->num_n_verts--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "num_owned", &num_owned, NULL)
        && num_owned == polyline_mesh->num_owned)
      pass ();
    else
      fail ("POLYLINE_MESH.num_owned [BL] %u != %u", polyline_mesh->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (polyline_mesh, "POLYLINE_MESH", "num_owned", &num_owned, 0)
        && num_owned == polyline_mesh->num_owned)
      pass ();
    else
      fail ("POLYLINE_MESH.num_owned [BL] set+1 %u != %u", polyline_mesh->num_owned, num_owned);
    polyline_mesh->num_owned--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_mesh->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POLYLINE_MESH.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &polyline_mesh->seqend, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_MESH.seqend [H]");
  }
  {
    BITCODE_H* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (polyline_mesh, "POLYLINE_MESH", "vertex", &vertex, NULL)
        && vertex == polyline_mesh->vertex)
      pass ();
    else
      fail ("POLYLINE_MESH.vertex [H*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("POLYLINE_MESH") || is_class_debugging ("POLYLINE_MESH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_MESH", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_PFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_PFACE *restrict polyline_pface = obj->tio.entity->tio.POLYLINE_PFACE;
  failed = 0;
  if (!obj_obj || !polyline_pface)
    {
      fail ("NULL POLYLINE_PFACE");
      return 1;
    }
  {
    BITCODE_H first_vertex;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "first_vertex", &first_vertex, NULL)
        && !memcmp (&first_vertex, &polyline_pface->first_vertex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_PFACE.first_vertex [H]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "flag", &flag, NULL)
        && flag == polyline_pface->flag)
      pass ();
    else
      fail ("POLYLINE_PFACE.flag [BS] %hu != %hu", polyline_pface->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "flag", &flag, 0)
        && flag == polyline_pface->flag)
      pass ();
    else
      fail ("POLYLINE_PFACE.flag [BS] set+1 %hu != %hu", polyline_pface->flag, flag);
    polyline_pface->flag--;
  }
  {
    BITCODE_B has_vertex;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "has_vertex", &has_vertex, NULL)
        && has_vertex == polyline_pface->has_vertex)
      pass ();
    else
      fail ("POLYLINE_PFACE.has_vertex [B] " FORMAT_B " != " FORMAT_B "", polyline_pface->has_vertex, has_vertex);
    has_vertex++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "has_vertex", &has_vertex, 0)
        && has_vertex == polyline_pface->has_vertex)
      pass ();
    else
      fail ("POLYLINE_PFACE.has_vertex [B] set+1 " FORMAT_B " != " FORMAT_B "", polyline_pface->has_vertex, has_vertex);
    polyline_pface->has_vertex--;
  }
  {
    BITCODE_H last_vertex;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "last_vertex", &last_vertex, NULL)
        && !memcmp (&last_vertex, &polyline_pface->last_vertex, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_PFACE.last_vertex [H]");
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "num_owned", &num_owned, NULL)
        && num_owned == polyline_pface->num_owned)
      pass ();
    else
      fail ("POLYLINE_PFACE.num_owned [BL] %u != %u", polyline_pface->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "num_owned", &num_owned, 0)
        && num_owned == polyline_pface->num_owned)
      pass ();
    else
      fail ("POLYLINE_PFACE.num_owned [BL] set+1 %u != %u", polyline_pface->num_owned, num_owned);
    polyline_pface->num_owned--;
  }
  {
    BITCODE_BS numfaces;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "numfaces", &numfaces, NULL)
        && numfaces == polyline_pface->numfaces)
      pass ();
    else
      fail ("POLYLINE_PFACE.numfaces [BS] %hu != %hu", polyline_pface->numfaces, numfaces);
    numfaces++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "numfaces", &numfaces, 0)
        && numfaces == polyline_pface->numfaces)
      pass ();
    else
      fail ("POLYLINE_PFACE.numfaces [BS] set+1 %hu != %hu", polyline_pface->numfaces, numfaces);
    polyline_pface->numfaces--;
  }
  {
    BITCODE_BS numverts;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "numverts", &numverts, NULL)
        && numverts == polyline_pface->numverts)
      pass ();
    else
      fail ("POLYLINE_PFACE.numverts [BS] %hu != %hu", polyline_pface->numverts, numverts);
    numverts++;
    if (dwg_dynapi_entity_set_value (polyline_pface, "POLYLINE_PFACE", "numverts", &numverts, 0)
        && numverts == polyline_pface->numverts)
      pass ();
    else
      fail ("POLYLINE_PFACE.numverts [BS] set+1 %hu != %hu", polyline_pface->numverts, numverts);
    polyline_pface->numverts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_pface->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POLYLINE_PFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &polyline_pface->seqend, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("POLYLINE_PFACE.seqend [H]");
  }
  {
    BITCODE_H* vertex;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (polyline_pface, "POLYLINE_PFACE", "vertex", &vertex, NULL)
        && vertex == polyline_pface->vertex)
      pass ();
    else
      fail ("POLYLINE_PFACE.vertex [H*] * %u num_owned", count);
  }
  if (failed && (is_class_unstable ("POLYLINE_PFACE") || is_class_debugging ("POLYLINE_PFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_PFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_POLYLINE_R11 (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_POLYLINE_R11 *restrict polyline_r11 = obj->tio.entity->tio.POLYLINE_R11;
  failed = 0;
  if (!obj_obj || !polyline_r11)
    {
      fail ("NULL POLYLINE_R11");
      return 1;
    }
  {
    BITCODE_RS curve_type;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "curve_type", &curve_type, NULL)
        && curve_type == polyline_r11->curve_type)
      pass ();
    else
      fail ("POLYLINE_R11.curve_type [RS] %hu != %hu", polyline_r11->curve_type, curve_type);
    curve_type++;
    if (dwg_dynapi_entity_set_value (polyline_r11, "POLYLINE_R11", "curve_type", &curve_type, 0)
        && curve_type == polyline_r11->curve_type)
      pass ();
    else
      fail ("POLYLINE_R11.curve_type [RS] set+1 %hu != %hu", polyline_r11->curve_type, curve_type);
    polyline_r11->curve_type--;
  }
  {
    BITCODE_RD end_width;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "end_width", &end_width, NULL)
        && end_width == polyline_r11->end_width)
      pass ();
    else
      fail ("POLYLINE_R11.end_width [RD] %g != %g", polyline_r11->end_width, end_width);
    end_width++;
    if (dwg_dynapi_entity_set_value (polyline_r11, "POLYLINE_R11", "end_width", &end_width, 0)
        && end_width == polyline_r11->end_width)
      pass ();
    else
      fail ("POLYLINE_R11.end_width [RD] set+1 %g != %g", polyline_r11->end_width, end_width);
    polyline_r11->end_width--;
  }
  {
    BITCODE_3RD extrusion;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &polyline_r11->extrusion, sizeof (BITCODE_3RD)))
        pass ();
    else
        fail ("POLYLINE_R11.extrusion [3RD]");
  }
  {
    BITCODE_RS flag;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "flag", &flag, NULL)
        && flag == polyline_r11->flag)
      pass ();
    else
      fail ("POLYLINE_R11.flag [RS] %hu != %hu", polyline_r11->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (polyline_r11, "POLYLINE_R11", "flag", &flag, 0)
        && flag == polyline_r11->flag)
      pass ();
    else
      fail ("POLYLINE_R11.flag [RS] set+1 %hu != %hu", polyline_r11->flag, flag);
    polyline_r11->flag--;
  }
  {
    BITCODE_RS m_density;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "m_density", &m_density, NULL)
        && m_density == polyline_r11->m_density)
      pass ();
    else
      fail ("POLYLINE_R11.m_density [RS] %hu != %hu", polyline_r11->m_density, m_density);
    m_density++;
    if (dwg_dynapi_entity_set_value (polyline_r11, "POLYLINE_R11", "m_density", &m_density, 0)
        && m_density == polyline_r11->m_density)
      pass ();
    else
      fail ("POLYLINE_R11.m_density [RS] set+1 %hu != %hu", polyline_r11->m_density, m_density);
    polyline_r11->m_density--;
  }
  {
    BITCODE_RS n_density;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "n_density", &n_density, NULL)
        && n_density == polyline_r11->n_density)
      pass ();
    else
      fail ("POLYLINE_R11.n_density [RS] %hu != %hu", polyline_r11->n_density, n_density);
    n_density++;
    if (dwg_dynapi_entity_set_value (polyline_r11, "POLYLINE_R11", "n_density", &n_density, 0)
        && n_density == polyline_r11->n_density)
      pass ();
    else
      fail ("POLYLINE_R11.n_density [RS] set+1 %hu != %hu", polyline_r11->n_density, n_density);
    polyline_r11->n_density--;
  }
  {
    BITCODE_RS num_m_verts;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "num_m_verts", &num_m_verts, NULL)
        && num_m_verts == polyline_r11->num_m_verts)
      pass ();
    else
      fail ("POLYLINE_R11.num_m_verts [RS] %hu != %hu", polyline_r11->num_m_verts, num_m_verts);
    num_m_verts++;
    if (dwg_dynapi_entity_set_value (polyline_r11, "POLYLINE_R11", "num_m_verts", &num_m_verts, 0)
        && num_m_verts == polyline_r11->num_m_verts)
      pass ();
    else
      fail ("POLYLINE_R11.num_m_verts [RS] set+1 %hu != %hu", polyline_r11->num_m_verts, num_m_verts);
    polyline_r11->num_m_verts--;
  }
  {
    BITCODE_RS num_n_verts;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "num_n_verts", &num_n_verts, NULL)
        && num_n_verts == polyline_r11->num_n_verts)
      pass ();
    else
      fail ("POLYLINE_R11.num_n_verts [RS] %hu != %hu", polyline_r11->num_n_verts, num_n_verts);
    num_n_verts++;
    if (dwg_dynapi_entity_set_value (polyline_r11, "POLYLINE_R11", "num_n_verts", &num_n_verts, 0)
        && num_n_verts == polyline_r11->num_n_verts)
      pass ();
    else
      fail ("POLYLINE_R11.num_n_verts [RS] set+1 %hu != %hu", polyline_r11->num_n_verts, num_n_verts);
    polyline_r11->num_n_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "parent", &parent, NULL)
        && !memcmp (&parent, &polyline_r11->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("POLYLINE_R11.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_RD start_width;
    if (dwg_dynapi_entity_value (polyline_r11, "POLYLINE_R11", "start_width", &start_width, NULL)
        && start_width == polyline_r11->start_width)
      pass ();
    else
      fail ("POLYLINE_R11.start_width [RD] %g != %g", polyline_r11->start_width, start_width);
    start_width++;
    if (dwg_dynapi_entity_set_value (polyline_r11, "POLYLINE_R11", "start_width", &start_width, 0)
        && start_width == polyline_r11->start_width)
      pass ();
    else
      fail ("POLYLINE_R11.start_width [RD] set+1 %g != %g", polyline_r11->start_width, start_width);
    polyline_r11->start_width--;
  }
  if (failed && (is_class_unstable ("POLYLINE_R11") || is_class_debugging ("POLYLINE_R11")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POLYLINE_R11", failed);
      failed = 0;
    }
  return failed;
}
static int test_PROXY_ENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_PROXY_ENTITY *restrict proxy_entity = obj->tio.entity->tio.PROXY_ENTITY;
  failed = 0;
  if (!obj_obj || !proxy_entity)
    {
      fail ("NULL PROXY_ENTITY");
      return 1;
    }
  {
    BITCODE_BL class_id;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "class_id", &class_id, NULL)
        && class_id == proxy_entity->class_id)
      pass ();
    else
      fail ("PROXY_ENTITY.class_id [BL] %u != %u", proxy_entity->class_id, class_id);
    class_id++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "class_id", &class_id, 0)
        && class_id == proxy_entity->class_id)
      pass ();
    else
      fail ("PROXY_ENTITY.class_id [BL] set+1 %u != %u", proxy_entity->class_id, class_id);
    proxy_entity->class_id--;
  }
  {
    BITCODE_TF data;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "data", &data, NULL)
        && !memcmp (&data, &proxy_entity->data, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("PROXY_ENTITY.data [TF]");
  }
  {
    BITCODE_BL data_numbits;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "data_numbits", &data_numbits, NULL)
        && data_numbits == proxy_entity->data_numbits)
      pass ();
    else
      fail ("PROXY_ENTITY.data_numbits [BL] %u != %u", proxy_entity->data_numbits, data_numbits);
    data_numbits++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "data_numbits", &data_numbits, 0)
        && data_numbits == proxy_entity->data_numbits)
      pass ();
    else
      fail ("PROXY_ENTITY.data_numbits [BL] set+1 %u != %u", proxy_entity->data_numbits, data_numbits);
    proxy_entity->data_numbits--;
  }
  {
    BITCODE_BL data_size;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "data_size", &data_size, NULL)
        && data_size == proxy_entity->data_size)
      pass ();
    else
      fail ("PROXY_ENTITY.data_size [BL] %u != %u", proxy_entity->data_size, data_size);
    data_size++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "data_size", &data_size, 0)
        && data_size == proxy_entity->data_size)
      pass ();
    else
      fail ("PROXY_ENTITY.data_size [BL] set+1 %u != %u", proxy_entity->data_size, data_size);
    proxy_entity->data_size--;
  }
  {
    BITCODE_B from_dxf;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "from_dxf", &from_dxf, NULL)
        && from_dxf == proxy_entity->from_dxf)
      pass ();
    else
      fail ("PROXY_ENTITY.from_dxf [B] " FORMAT_B " != " FORMAT_B "", proxy_entity->from_dxf, from_dxf);
    from_dxf++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "from_dxf", &from_dxf, 0)
        && from_dxf == proxy_entity->from_dxf)
      pass ();
    else
      fail ("PROXY_ENTITY.from_dxf [B] set+1 " FORMAT_B " != " FORMAT_B "", proxy_entity->from_dxf, from_dxf);
    proxy_entity->from_dxf--;
  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "maint_version", &maint_version, NULL)
        && maint_version == proxy_entity->maint_version)
      pass ();
    else
      fail ("PROXY_ENTITY.maint_version [BL] %u != %u", proxy_entity->maint_version, maint_version);
    maint_version++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "maint_version", &maint_version, 0)
        && maint_version == proxy_entity->maint_version)
      pass ();
    else
      fail ("PROXY_ENTITY.maint_version [BL] set+1 %u != %u", proxy_entity->maint_version, maint_version);
    proxy_entity->maint_version--;
  }
  {
    BITCODE_BL num_objids;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "num_objids", &num_objids, NULL)
        && num_objids == proxy_entity->num_objids)
      pass ();
    else
      fail ("PROXY_ENTITY.num_objids [BL] %u != %u", proxy_entity->num_objids, num_objids);
    num_objids++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "num_objids", &num_objids, 0)
        && num_objids == proxy_entity->num_objids)
      pass ();
    else
      fail ("PROXY_ENTITY.num_objids [BL] set+1 %u != %u", proxy_entity->num_objids, num_objids);
    proxy_entity->num_objids--;
  }
  {
    BITCODE_H* objids;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "num_objids", &count, NULL)
        && dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "objids", &objids, NULL)
        && objids == proxy_entity->objids)
      pass ();
    else
      fail ("PROXY_ENTITY.objids [H*] * %u num_objids", count);
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &proxy_entity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("PROXY_ENTITY.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value (proxy_entity, "PROXY_ENTITY", "version", &version, NULL)
        && version == proxy_entity->version)
      pass ();
    else
      fail ("PROXY_ENTITY.version [BL] %u != %u", proxy_entity->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (proxy_entity, "PROXY_ENTITY", "version", &version, 0)
        && version == proxy_entity->version)
      pass ();
    else
      fail ("PROXY_ENTITY.version [BL] set+1 %u != %u", proxy_entity->version, version);
    proxy_entity->version--;
  }
  if (failed && (is_class_unstable ("PROXY_ENTITY") || is_class_debugging ("PROXY_ENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PROXY_ENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_RAY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_RAY *restrict ray = obj->tio.entity->tio.RAY;
  failed = 0;
  if (!obj_obj || !ray)
    {
      fail ("NULL RAY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (ray, "RAY", "parent", &parent, NULL)
        && !memcmp (&parent, &ray->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("RAY.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (ray, "RAY", "point", &point, NULL)
        && !memcmp (&point, &ray->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("RAY.point [3BD]");
  }
  {
    BITCODE_3BD vector;
    if (dwg_dynapi_entity_value (ray, "RAY", "vector", &vector, NULL)
        && !memcmp (&vector, &ray->vector, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("RAY.vector [3BD]");
  }
  if (failed && (is_class_unstable ("RAY") || is_class_debugging ("RAY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RAY", failed);
      failed = 0;
    }
  return failed;
}
static int test_REGION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_REGION *restrict region = obj->tio.entity->tio.REGION;
  failed = 0;
  if (!obj_obj || !region)
    {
      fail ("NULL REGION");
      return 1;
    }
  if (failed && (is_class_unstable ("REGION") || is_class_debugging ("REGION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "REGION", failed);
      failed = 0;
    }
  return failed;
}
static int test_REPEAT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_REPEAT *restrict repeat = obj->tio.entity->tio.REPEAT;
  failed = 0;
  if (!obj_obj || !repeat)
    {
      fail ("NULL REPEAT");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (repeat, "REPEAT", "parent", &parent, NULL)
        && !memcmp (&parent, &repeat->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("REPEAT.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("REPEAT") || is_class_debugging ("REPEAT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "REPEAT", failed);
      failed = 0;
    }
  return failed;
}
static int test_REVOLVEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_REVOLVEDSURFACE *restrict revolvedsurface = obj->tio.entity->tio.REVOLVEDSURFACE;
  failed = 0;
  if (!obj_obj || !revolvedsurface)
    {
      fail ("NULL REVOLVEDSURFACE");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == revolvedsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("REVOLVEDSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == revolvedsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("REVOLVEDSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->_dxf_sab_converted, _dxf_sab_converted);
    revolvedsurface->_dxf_sab_converted--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)revolvedsurface->acis_data)
           : !revolvedsurface->acis_data)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, revolvedsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == revolvedsurface->acis_empty)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == revolvedsurface->acis_empty)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty, acis_empty);
    revolvedsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == revolvedsurface->acis_empty2)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == revolvedsurface->acis_empty2)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty2, acis_empty2);
    revolvedsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == revolvedsurface->acis_empty_bit)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == revolvedsurface->acis_empty_bit)
      pass ();
    else
      fail ("REVOLVEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty_bit, acis_empty_bit);
    revolvedsurface->acis_empty_bit--;
  }
  {
    BITCODE_3BD axis_point;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "axis_point", &axis_point, NULL)
        && !memcmp (&axis_point, &revolvedsurface->axis_point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.axis_point [3BD]");
  }
  {
    BITCODE_3BD axis_vector;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "axis_vector", &axis_vector, NULL)
        && !memcmp (&axis_vector, &revolvedsurface->axis_vector, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.axis_vector [3BD]");
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &revolvedsurface->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version, NULL)
        && class_version == revolvedsurface->class_version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.class_version [BL] %u != %u", revolvedsurface->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version, 0)
        && class_version == revolvedsurface->class_version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.class_version [BL] set+1 %u != %u", revolvedsurface->class_version, class_version);
    revolvedsurface->class_version--;
  }
  {
    BITCODE_B close_to_axis;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis, NULL)
        && close_to_axis == revolvedsurface->close_to_axis)
      pass ();
    else
      fail ("REVOLVEDSURFACE.close_to_axis [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis);
    close_to_axis++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis, 0)
        && close_to_axis == revolvedsurface->close_to_axis)
      pass ();
    else
      fail ("REVOLVEDSURFACE.close_to_axis [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis);
    revolvedsurface->close_to_axis--;
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle, NULL)
        && draft_angle == revolvedsurface->draft_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_angle [BD] %g != %g", revolvedsurface->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle, 0)
        && draft_angle == revolvedsurface->draft_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_angle [BD] set+1 %g != %g", revolvedsurface->draft_angle, draft_angle);
    revolvedsurface->draft_angle--;
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance, NULL)
        && draft_end_distance == revolvedsurface->draft_end_distance)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_end_distance [BD] %g != %g", revolvedsurface->draft_end_distance, draft_end_distance);
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance, 0)
        && draft_end_distance == revolvedsurface->draft_end_distance)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_end_distance [BD] set+1 %g != %g", revolvedsurface->draft_end_distance, draft_end_distance);
    revolvedsurface->draft_end_distance--;
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance, NULL)
        && draft_start_distance == revolvedsurface->draft_start_distance)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_start_distance [BD] %g != %g", revolvedsurface->draft_start_distance, draft_start_distance);
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance, 0)
        && draft_start_distance == revolvedsurface->draft_start_distance)
      pass ();
    else
      fail ("REVOLVEDSURFACE.draft_start_distance [BD] set+1 %g != %g", revolvedsurface->draft_start_distance, draft_start_distance);
    revolvedsurface->draft_start_distance--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &revolvedsurface->encr_sat_data, sizeof (revolvedsurface->encr_sat_data)))
      pass ();
    else
      fail ("REVOLVEDSURFACE.encr_sat_data [char **]");
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "end_marker", &end_marker, NULL)
        && end_marker == revolvedsurface->end_marker)
      pass ();
    else
      fail ("REVOLVEDSURFACE.end_marker [BL] %u != %u", revolvedsurface->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "end_marker", &end_marker, 0)
        && end_marker == revolvedsurface->end_marker)
      pass ();
    else
      fail ("REVOLVEDSURFACE.end_marker [BL] set+1 %u != %u", revolvedsurface->end_marker, end_marker);
    revolvedsurface->end_marker--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &revolvedsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == revolvedsurface->has_revision_guid)
      pass ();
    else
      fail ("REVOLVEDSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == revolvedsurface->has_revision_guid)
      pass ();
    else
      fail ("REVOLVEDSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->has_revision_guid, has_revision_guid);
    revolvedsurface->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &revolvedsurface->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.history_id [H]");
  }
  {
    BITCODE_BL id;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "id", &id, NULL)
        && id == revolvedsurface->id)
      pass ();
    else
      fail ("REVOLVEDSURFACE.id [BL] %u != %u", revolvedsurface->id, id);
    id++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "id", &id, 0)
        && id == revolvedsurface->id)
      pass ();
    else
      fail ("REVOLVEDSURFACE.id [BL] set+1 %u != %u", revolvedsurface->id, id);
    revolvedsurface->id--;
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == revolvedsurface->isoline_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == revolvedsurface->isoline_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->isoline_present, isoline_present);
    revolvedsurface->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "isolines", &isolines, NULL)
        && isolines == revolvedsurface->isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.isolines [BL] %u != %u", revolvedsurface->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "isolines", &isolines, 0)
        && isolines == revolvedsurface->isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.isolines [BL] set+1 %u != %u", revolvedsurface->isolines, isolines);
    revolvedsurface->isolines--;
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "materials", &materials, NULL)
        && materials == revolvedsurface->materials)
      pass ();
    else
      fail ("REVOLVEDSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == revolvedsurface->modeler_format_version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.modeler_format_version [BS] %hu != %hu", revolvedsurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == revolvedsurface->modeler_format_version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", revolvedsurface->modeler_format_version, modeler_format_version);
    revolvedsurface->modeler_format_version--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == revolvedsurface->num_blocks)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_blocks [BL] %u != %u", revolvedsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == revolvedsurface->num_blocks)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_blocks [BL] set+1 %u != %u", revolvedsurface->num_blocks, num_blocks);
    revolvedsurface->num_blocks--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_materials", &num_materials, NULL)
        && num_materials == revolvedsurface->num_materials)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_materials [BL] %u != %u", revolvedsurface->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_materials", &num_materials, 0)
        && num_materials == revolvedsurface->num_materials)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_materials [BL] set+1 %u != %u", revolvedsurface->num_materials, num_materials);
    revolvedsurface->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == revolvedsurface->num_silhouettes)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_silhouettes [BL] %u != %u", revolvedsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == revolvedsurface->num_silhouettes)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_silhouettes [BL] set+1 %u != %u", revolvedsurface->num_silhouettes, num_silhouettes);
    revolvedsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == revolvedsurface->num_wires)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_wires [BL] %u != %u", revolvedsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires, 0)
        && num_wires == revolvedsurface->num_wires)
      pass ();
    else
      fail ("REVOLVEDSURFACE.num_wires [BL] set+1 %u != %u", revolvedsurface->num_wires, num_wires);
    revolvedsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &revolvedsurface->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "point", &point, NULL)
        && !memcmp (&point, &revolvedsurface->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present, NULL)
        && point_present == revolvedsurface->point_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present, 0)
        && point_present == revolvedsurface->point_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->point_present, point_present);
    revolvedsurface->point_present--;
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &revolvedsurface->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &revolvedsurface->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_major", &revision_major, NULL)
        && revision_major == revolvedsurface->revision_major)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revision_major [BL] %u != %u", revolvedsurface->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revision_major", &revision_major, 0)
        && revision_major == revolvedsurface->revision_major)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revision_major [BL] set+1 %u != %u", revolvedsurface->revision_major, revision_major);
    revolvedsurface->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == revolvedsurface->revision_minor1)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revision_minor1 [BS] %hu != %hu", revolvedsurface->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == revolvedsurface->revision_minor1)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revision_minor1 [BS] set+1 %hu != %hu", revolvedsurface->revision_minor1, revision_minor1);
    revolvedsurface->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == revolvedsurface->revision_minor2)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revision_minor2 [BS] %hu != %hu", revolvedsurface->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == revolvedsurface->revision_minor2)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revision_minor2 [BS] set+1 %hu != %hu", revolvedsurface->revision_minor2, revision_minor2);
    revolvedsurface->revision_minor2--;
  }
  {
    BITCODE_BD revolve_angle;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle, NULL)
        && revolve_angle == revolvedsurface->revolve_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revolve_angle [BD] %g != %g", revolvedsurface->revolve_angle, revolve_angle);
    revolve_angle++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle, 0)
        && revolve_angle == revolvedsurface->revolve_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.revolve_angle [BD] set+1 %g != %g", revolvedsurface->revolve_angle, revolve_angle);
    revolvedsurface->revolve_angle--;
  }
  {
    BITCODE_BD* revolved_entity_transmatrix;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revolved_entity_transmatrix", &revolved_entity_transmatrix, NULL)
        && !memcmp (&revolved_entity_transmatrix, &revolvedsurface->revolved_entity_transmatrix, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("REVOLVEDSURFACE.revolved_entity_transmatrix [BD*]");
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "sab_size", &sab_size, NULL)
        && sab_size == revolvedsurface->sab_size)
      pass ();
    else
      fail ("REVOLVEDSURFACE.sab_size [BL] %u != %u", revolvedsurface->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "sab_size", &sab_size, 0)
        && sab_size == revolvedsurface->sab_size)
      pass ();
    else
      fail ("REVOLVEDSURFACE.sab_size [BL] set+1 %u != %u", revolvedsurface->sab_size, sab_size);
    revolvedsurface->sab_size--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == revolvedsurface->silhouettes)
      pass ();
    else
      fail ("REVOLVEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "solid", &solid, NULL)
        && solid == revolvedsurface->solid)
      pass ();
    else
      fail ("REVOLVEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid);
    solid++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "solid", &solid, 0)
        && solid == revolvedsurface->solid)
      pass ();
    else
      fail ("REVOLVEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid);
    revolvedsurface->solid--;
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle, NULL)
        && start_angle == revolvedsurface->start_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.start_angle [BD] %g != %g", revolvedsurface->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle, 0)
        && start_angle == revolvedsurface->start_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.start_angle [BD] set+1 %g != %g", revolvedsurface->start_angle, start_angle);
    revolvedsurface->start_angle--;
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle, NULL)
        && twist_angle == revolvedsurface->twist_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.twist_angle [BD] %g != %g", revolvedsurface->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle, 0)
        && twist_angle == revolvedsurface->twist_angle)
      pass ();
    else
      fail ("REVOLVEDSURFACE.twist_angle [BD] set+1 %g != %g", revolvedsurface->twist_angle, twist_angle);
    revolvedsurface->twist_angle--;
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == revolvedsurface->u_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.u_isolines [BS] %hu != %hu", revolvedsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == revolvedsurface->u_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.u_isolines [BS] set+1 %hu != %hu", revolvedsurface->u_isolines, u_isolines);
    revolvedsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown, NULL)
        && unknown == revolvedsurface->unknown)
      pass ();
    else
      fail ("REVOLVEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown, 0)
        && unknown == revolvedsurface->unknown)
      pass ();
    else
      fail ("REVOLVEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->unknown, unknown);
    revolvedsurface->unknown--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == revolvedsurface->v_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.v_isolines [BS] %hu != %hu", revolvedsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == revolvedsurface->v_isolines)
      pass ();
    else
      fail ("REVOLVEDSURFACE.v_isolines [BS] set+1 %hu != %hu", revolvedsurface->v_isolines, v_isolines);
    revolvedsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "version", &version, NULL)
        && version == revolvedsurface->version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.version [BS] %hu != %hu", revolvedsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "version", &version, 0)
        && version == revolvedsurface->version)
      pass ();
    else
      fail ("REVOLVEDSURFACE.version [BS] set+1 %hu != %hu", revolvedsurface->version, version);
    revolvedsurface->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == revolvedsurface->wireframe_data_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == revolvedsurface->wireframe_data_present)
      pass ();
    else
      fail ("REVOLVEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->wireframe_data_present, wireframe_data_present);
    revolvedsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "wires", &wires, NULL)
        && wires == revolvedsurface->wires)
      pass ();
    else
      fail ("REVOLVEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("REVOLVEDSURFACE") || is_class_debugging ("REVOLVEDSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "REVOLVEDSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_ROTATIONGRIPENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ROTATIONGRIPENTITY *restrict rotationgripentity = obj->tio.entity->tio.ROTATIONGRIPENTITY;
  failed = 0;
  if (!obj_obj || !rotationgripentity)
    {
      fail ("NULL ROTATIONGRIPENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (rotationgripentity, "ROTATIONGRIPENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &rotationgripentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ROTATIONGRIPENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("ROTATIONGRIPENTITY") || is_class_debugging ("ROTATIONGRIPENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ROTATIONGRIPENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ROTATIONPARAMETERENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_ROTATIONPARAMETERENTITY *restrict rotationparameterentity = obj->tio.entity->tio.ROTATIONPARAMETERENTITY;
  failed = 0;
  if (!obj_obj || !rotationparameterentity)
    {
      fail ("NULL ROTATIONPARAMETERENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (rotationparameterentity, "ROTATIONPARAMETERENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &rotationparameterentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("ROTATIONPARAMETERENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("ROTATIONPARAMETERENTITY") || is_class_debugging ("ROTATIONPARAMETERENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ROTATIONPARAMETERENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_RTEXT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_RTEXT *restrict rtext = obj->tio.entity->tio.RTEXT;
  failed = 0;
  if (!obj_obj || !rtext)
    {
      fail ("NULL RTEXT");
      return 1;
    }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (rtext, "RTEXT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &rtext->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("RTEXT.extrusion [BE]");
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value (rtext, "RTEXT", "flags", &flags, NULL)
        && flags == rtext->flags)
      pass ();
    else
      fail ("RTEXT.flags [BS] %hu != %hu", rtext->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (rtext, "RTEXT", "flags", &flags, 0)
        && flags == rtext->flags)
      pass ();
    else
      fail ("RTEXT.flags [BS] set+1 %hu != %hu", rtext->flags, flags);
    rtext->flags--;
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (rtext, "RTEXT", "height", &height, NULL)
        && height == rtext->height)
      pass ();
    else
      fail ("RTEXT.height [BD] %g != %g", rtext->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (rtext, "RTEXT", "height", &height, 0)
        && height == rtext->height)
      pass ();
    else
      fail ("RTEXT.height [BD] set+1 %g != %g", rtext->height, height);
    rtext->height--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (rtext, "RTEXT", "parent", &parent, NULL)
        && !memcmp (&parent, &rtext->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("RTEXT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD pt;
    if (dwg_dynapi_entity_value (rtext, "RTEXT", "pt", &pt, NULL)
        && !memcmp (&pt, &rtext->pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("RTEXT.pt [3BD]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (rtext, "RTEXT", "rotation", &rotation, NULL)
        && rotation == rtext->rotation)
      pass ();
    else
      fail ("RTEXT.rotation [BD] %g != %g", rtext->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (rtext, "RTEXT", "rotation", &rotation, 0)
        && rotation == rtext->rotation)
      pass ();
    else
      fail ("RTEXT.rotation [BD] set+1 %g != %g", rtext->rotation, rotation);
    rtext->rotation--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (rtext, "RTEXT", "style", &style, NULL)
        && !memcmp (&style, &rtext->style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("RTEXT.style [H]");
  }
  {
    BITCODE_T text_value;
    if (dwg_dynapi_entity_value (rtext, "RTEXT", "text_value", &text_value, NULL)
        && text_value
           ? strEQ ((char *)text_value, (char *)rtext->text_value)
           : !rtext->text_value)
      pass ();
    else
      fail ("RTEXT.text_value [T] '%s' <> '%s'", text_value, rtext->text_value);
  }
  if (failed && (is_class_unstable ("RTEXT") || is_class_debugging ("RTEXT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RTEXT", failed);
      failed = 0;
    }
  return failed;
}
static int test_SECTIONOBJECT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SECTIONOBJECT *restrict sectionobject = obj->tio.entity->tio.SECTIONOBJECT;
  failed = 0;
  if (!obj_obj || !sectionobject)
    {
      fail ("NULL SECTIONOBJECT");
      return 1;
    }
  {
    BITCODE_3BD* blverts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "num_blverts", &count, NULL)
        && dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "blverts", &blverts, NULL)
        && blverts == sectionobject->blverts)
      pass ();
    else
      fail ("SECTIONOBJECT.blverts [3BD*] * %u num_blverts", count);
  }
  {
    BITCODE_BD bottom_height;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "bottom_height", &bottom_height, NULL)
        && bottom_height == sectionobject->bottom_height)
      pass ();
    else
      fail ("SECTIONOBJECT.bottom_height [BD] %g != %g", sectionobject->bottom_height, bottom_height);
    bottom_height++;
    if (dwg_dynapi_entity_set_value (sectionobject, "SECTIONOBJECT", "bottom_height", &bottom_height, 0)
        && bottom_height == sectionobject->bottom_height)
      pass ();
    else
      fail ("SECTIONOBJECT.bottom_height [BD] set+1 %g != %g", sectionobject->bottom_height, bottom_height);
    sectionobject->bottom_height--;
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "flags", &flags, NULL)
        && flags == sectionobject->flags)
      pass ();
    else
      fail ("SECTIONOBJECT.flags [BL] %u != %u", sectionobject->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (sectionobject, "SECTIONOBJECT", "flags", &flags, 0)
        && flags == sectionobject->flags)
      pass ();
    else
      fail ("SECTIONOBJECT.flags [BL] set+1 %u != %u", sectionobject->flags, flags);
    sectionobject->flags--;
  }
  {
    BITCODE_BS indicator_alpha;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "indicator_alpha", &indicator_alpha, NULL)
        && indicator_alpha == sectionobject->indicator_alpha)
      pass ();
    else
      fail ("SECTIONOBJECT.indicator_alpha [BS] %hu != %hu", sectionobject->indicator_alpha, indicator_alpha);
    indicator_alpha++;
    if (dwg_dynapi_entity_set_value (sectionobject, "SECTIONOBJECT", "indicator_alpha", &indicator_alpha, 0)
        && indicator_alpha == sectionobject->indicator_alpha)
      pass ();
    else
      fail ("SECTIONOBJECT.indicator_alpha [BS] set+1 %hu != %hu", sectionobject->indicator_alpha, indicator_alpha);
    sectionobject->indicator_alpha--;
  }
  {
    BITCODE_CMC indicator_color;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "indicator_color", &indicator_color, NULL)
        && !memcmp (&indicator_color, &sectionobject->indicator_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SECTIONOBJECT.indicator_color [CMC]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)sectionobject->name)
           : !sectionobject->name)
      pass ();
    else
      fail ("SECTIONOBJECT.name [T] '%s' <> '%s'", name, sectionobject->name);
  }
  {
    BITCODE_BL num_blverts;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "num_blverts", &num_blverts, NULL)
        && num_blverts == sectionobject->num_blverts)
      pass ();
    else
      fail ("SECTIONOBJECT.num_blverts [BL] %u != %u", sectionobject->num_blverts, num_blverts);
    num_blverts++;
    if (dwg_dynapi_entity_set_value (sectionobject, "SECTIONOBJECT", "num_blverts", &num_blverts, 0)
        && num_blverts == sectionobject->num_blverts)
      pass ();
    else
      fail ("SECTIONOBJECT.num_blverts [BL] set+1 %u != %u", sectionobject->num_blverts, num_blverts);
    sectionobject->num_blverts--;
  }
  {
    BITCODE_BL num_verts;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "num_verts", &num_verts, NULL)
        && num_verts == sectionobject->num_verts)
      pass ();
    else
      fail ("SECTIONOBJECT.num_verts [BL] %u != %u", sectionobject->num_verts, num_verts);
    num_verts++;
    if (dwg_dynapi_entity_set_value (sectionobject, "SECTIONOBJECT", "num_verts", &num_verts, 0)
        && num_verts == sectionobject->num_verts)
      pass ();
    else
      fail ("SECTIONOBJECT.num_verts [BL] set+1 %u != %u", sectionobject->num_verts, num_verts);
    sectionobject->num_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "parent", &parent, NULL)
        && !memcmp (&parent, &sectionobject->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("SECTIONOBJECT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H section_settings;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "section_settings", &section_settings, NULL)
        && !memcmp (&section_settings, &sectionobject->section_settings, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SECTIONOBJECT.section_settings [H]");
  }
  {
    BITCODE_BL state;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "state", &state, NULL)
        && state == sectionobject->state)
      pass ();
    else
      fail ("SECTIONOBJECT.state [BL] %u != %u", sectionobject->state, state);
    state++;
    if (dwg_dynapi_entity_set_value (sectionobject, "SECTIONOBJECT", "state", &state, 0)
        && state == sectionobject->state)
      pass ();
    else
      fail ("SECTIONOBJECT.state [BL] set+1 %u != %u", sectionobject->state, state);
    sectionobject->state--;
  }
  {
    BITCODE_BD top_height;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "top_height", &top_height, NULL)
        && top_height == sectionobject->top_height)
      pass ();
    else
      fail ("SECTIONOBJECT.top_height [BD] %g != %g", sectionobject->top_height, top_height);
    top_height++;
    if (dwg_dynapi_entity_set_value (sectionobject, "SECTIONOBJECT", "top_height", &top_height, 0)
        && top_height == sectionobject->top_height)
      pass ();
    else
      fail ("SECTIONOBJECT.top_height [BD] set+1 %g != %g", sectionobject->top_height, top_height);
    sectionobject->top_height--;
  }
  {
    BITCODE_3BD vert_dir;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "vert_dir", &vert_dir, NULL)
        && !memcmp (&vert_dir, &sectionobject->vert_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("SECTIONOBJECT.vert_dir [3BD]");
  }
  {
    BITCODE_3BD* verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "num_verts", &count, NULL)
        && dwg_dynapi_entity_value (sectionobject, "SECTIONOBJECT", "verts", &verts, NULL)
        && verts == sectionobject->verts)
      pass ();
    else
      fail ("SECTIONOBJECT.verts [3BD*] * %u num_verts", count);
  }
  if (failed && (is_class_unstable ("SECTIONOBJECT") || is_class_debugging ("SECTIONOBJECT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SECTIONOBJECT", failed);
      failed = 0;
    }
  return failed;
}
static int test_SEQEND (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SEQEND *restrict seqend = obj->tio.entity->tio.SEQEND;
  failed = 0;
  if (!obj_obj || !seqend)
    {
      fail ("NULL SEQEND");
      return 1;
    }
  {
    BITCODE_RL begin_addr_r11;
    if (dwg_dynapi_entity_value (seqend, "SEQEND", "begin_addr_r11", &begin_addr_r11, NULL)
        && begin_addr_r11 == seqend->begin_addr_r11)
      pass ();
    else
      fail ("SEQEND.begin_addr_r11 [RL] %u != %u", seqend->begin_addr_r11, begin_addr_r11);
    begin_addr_r11++;
    if (dwg_dynapi_entity_set_value (seqend, "SEQEND", "begin_addr_r11", &begin_addr_r11, 0)
        && begin_addr_r11 == seqend->begin_addr_r11)
      pass ();
    else
      fail ("SEQEND.begin_addr_r11 [RL] set+1 %u != %u", seqend->begin_addr_r11, begin_addr_r11);
    seqend->begin_addr_r11--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (seqend, "SEQEND", "parent", &parent, NULL)
        && !memcmp (&parent, &seqend->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("SEQEND.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("SEQEND") || is_class_debugging ("SEQEND")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SEQEND", failed);
      failed = 0;
    }
  return failed;
}
static int test_SHAPE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SHAPE *restrict shape = obj->tio.entity->tio.SHAPE;
  failed = 0;
  if (!obj_obj || !shape)
    {
      fail ("NULL SHAPE");
      return 1;
    }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &shape->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("SHAPE.extrusion [BE]");
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &shape->ins_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("SHAPE.ins_pt [3BD]");
  }
  {
    BITCODE_BD oblique_angle;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "oblique_angle", &oblique_angle, NULL)
        && oblique_angle == shape->oblique_angle)
      pass ();
    else
      fail ("SHAPE.oblique_angle [BD] %g != %g", shape->oblique_angle, oblique_angle);
    oblique_angle++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "oblique_angle", &oblique_angle, 0)
        && oblique_angle == shape->oblique_angle)
      pass ();
    else
      fail ("SHAPE.oblique_angle [BD] set+1 %g != %g", shape->oblique_angle, oblique_angle);
    shape->oblique_angle--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "parent", &parent, NULL)
        && !memcmp (&parent, &shape->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("SHAPE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "rotation", &rotation, NULL)
        && rotation == shape->rotation)
      pass ();
    else
      fail ("SHAPE.rotation [BD] %g != %g", shape->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "rotation", &rotation, 0)
        && rotation == shape->rotation)
      pass ();
    else
      fail ("SHAPE.rotation [BD] set+1 %g != %g", shape->rotation, rotation);
    shape->rotation--;
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "scale", &scale, NULL)
        && scale == shape->scale)
      pass ();
    else
      fail ("SHAPE.scale [BD] %g != %g", shape->scale, scale);
    scale++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "scale", &scale, 0)
        && scale == shape->scale)
      pass ();
    else
      fail ("SHAPE.scale [BD] set+1 %g != %g", shape->scale, scale);
    shape->scale--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "style", &style, NULL)
        && !memcmp (&style, &shape->style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SHAPE.style [H]");
  }
  {
    BITCODE_BS style_id;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "style_id", &style_id, NULL)
        && style_id == shape->style_id)
      pass ();
    else
      fail ("SHAPE.style_id [BS] %hu != %hu", shape->style_id, style_id);
    style_id++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "style_id", &style_id, 0)
        && style_id == shape->style_id)
      pass ();
    else
      fail ("SHAPE.style_id [BS] set+1 %hu != %hu", shape->style_id, style_id);
    shape->style_id--;
  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "thickness", &thickness, NULL)
        && thickness == shape->thickness)
      pass ();
    else
      fail ("SHAPE.thickness [BD] %g != %g", shape->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "thickness", &thickness, 0)
        && thickness == shape->thickness)
      pass ();
    else
      fail ("SHAPE.thickness [BD] set+1 %g != %g", shape->thickness, thickness);
    shape->thickness--;
  }
  {
    BITCODE_BD width_factor;
    if (dwg_dynapi_entity_value (shape, "SHAPE", "width_factor", &width_factor, NULL)
        && width_factor == shape->width_factor)
      pass ();
    else
      fail ("SHAPE.width_factor [BD] %g != %g", shape->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (shape, "SHAPE", "width_factor", &width_factor, 0)
        && width_factor == shape->width_factor)
      pass ();
    else
      fail ("SHAPE.width_factor [BD] set+1 %g != %g", shape->width_factor, width_factor);
    shape->width_factor--;
  }
  if (failed && (is_class_unstable ("SHAPE") || is_class_debugging ("SHAPE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SHAPE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SOLID (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SOLID *restrict solid = obj->tio.entity->tio.SOLID;
  failed = 0;
  if (!obj_obj || !solid)
    {
      fail ("NULL SOLID");
      return 1;
    }
  {
    BITCODE_2RD corner1;
    if (dwg_dynapi_entity_value (solid, "SOLID", "corner1", &corner1, NULL)
        && !memcmp (&corner1, &solid->corner1, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("SOLID.corner1 [2RD]");
  }
  {
    BITCODE_2RD corner2;
    if (dwg_dynapi_entity_value (solid, "SOLID", "corner2", &corner2, NULL)
        && !memcmp (&corner2, &solid->corner2, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("SOLID.corner2 [2RD]");
  }
  {
    BITCODE_2RD corner3;
    if (dwg_dynapi_entity_value (solid, "SOLID", "corner3", &corner3, NULL)
        && !memcmp (&corner3, &solid->corner3, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("SOLID.corner3 [2RD]");
  }
  {
    BITCODE_2RD corner4;
    if (dwg_dynapi_entity_value (solid, "SOLID", "corner4", &corner4, NULL)
        && !memcmp (&corner4, &solid->corner4, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("SOLID.corner4 [2RD]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (solid, "SOLID", "elevation", &elevation, NULL)
        && elevation == solid->elevation)
      pass ();
    else
      fail ("SOLID.elevation [BD] %g != %g", solid->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (solid, "SOLID", "elevation", &elevation, 0)
        && elevation == solid->elevation)
      pass ();
    else
      fail ("SOLID.elevation [BD] set+1 %g != %g", solid->elevation, elevation);
    solid->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (solid, "SOLID", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &solid->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("SOLID.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (solid, "SOLID", "parent", &parent, NULL)
        && !memcmp (&parent, &solid->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("SOLID.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (solid, "SOLID", "thickness", &thickness, NULL)
        && thickness == solid->thickness)
      pass ();
    else
      fail ("SOLID.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", solid->thickness, thickness);
    if (dwg_dynapi_entity_set_value (solid, "SOLID", "thickness", &thickness, 0)
        && thickness == solid->thickness)
      pass ();
    else
      fail ("SOLID.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", solid->thickness, thickness);
    solid->thickness--;
  }
  if (failed && (is_class_unstable ("SOLID") || is_class_debugging ("SOLID")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SOLID", failed);
      failed = 0;
    }
  return failed;
}
static int test_SPLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SPLINE *restrict spline = obj->tio.entity->tio.SPLINE;
  failed = 0;
  if (!obj_obj || !spline)
    {
      fail ("NULL SPLINE");
      return 1;
    }
  {
    BITCODE_3BD beg_tan_vec;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "beg_tan_vec", &beg_tan_vec, NULL)
        && !memcmp (&beg_tan_vec, &spline->beg_tan_vec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("SPLINE.beg_tan_vec [3BD]");
  }
  {
    BITCODE_B closed_b;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "closed_b", &closed_b, NULL)
        && closed_b == spline->closed_b)
      pass ();
    else
      fail ("SPLINE.closed_b [B] " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b);
    closed_b++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "closed_b", &closed_b, 0)
        && closed_b == spline->closed_b)
      pass ();
    else
      fail ("SPLINE.closed_b [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b);
    spline->closed_b--;
  }
  {
    Dwg_SPLINE_control_point* ctrl_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_ctrl_pts", &count, NULL)
        && dwg_dynapi_entity_value (spline, "SPLINE", "ctrl_pts", &ctrl_pts, NULL)
        && ctrl_pts == spline->ctrl_pts)
      pass ();
    else
      fail ("SPLINE.ctrl_pts [Dwg_SPLINE_control_point*] * %u num_ctrl_pts", count);
  }
  {
    BITCODE_BD ctrl_tol;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "ctrl_tol", &ctrl_tol, NULL)
        && ctrl_tol == spline->ctrl_tol)
      pass ();
    else
      fail ("SPLINE.ctrl_tol [BD] %g != %g", spline->ctrl_tol, ctrl_tol);
    ctrl_tol++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "ctrl_tol", &ctrl_tol, 0)
        && ctrl_tol == spline->ctrl_tol)
      pass ();
    else
      fail ("SPLINE.ctrl_tol [BD] set+1 %g != %g", spline->ctrl_tol, ctrl_tol);
    spline->ctrl_tol--;
  }
  {
    BITCODE_BS degree;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "degree", &degree, NULL)
        && degree == spline->degree)
      pass ();
    else
      fail ("SPLINE.degree [BS] %hu != %hu", spline->degree, degree);
    degree++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "degree", &degree, 0)
        && degree == spline->degree)
      pass ();
    else
      fail ("SPLINE.degree [BS] set+1 %hu != %hu", spline->degree, degree);
    spline->degree--;
  }
  {
    BITCODE_3BD end_tan_vec;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "end_tan_vec", &end_tan_vec, NULL)
        && !memcmp (&end_tan_vec, &spline->end_tan_vec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("SPLINE.end_tan_vec [3BD]");
  }
  {
    BITCODE_3DPOINT* fit_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_fit_pts", &count, NULL)
        && dwg_dynapi_entity_value (spline, "SPLINE", "fit_pts", &fit_pts, NULL)
        && fit_pts == spline->fit_pts)
      pass ();
    else
      fail ("SPLINE.fit_pts [3DPOINT*] * %u num_fit_pts", count);
  }
  {
    BITCODE_BD fit_tol;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "fit_tol", &fit_tol, NULL)
        && fit_tol == spline->fit_tol)
      pass ();
    else
      fail ("SPLINE.fit_tol [BD] %g != %g", spline->fit_tol, fit_tol);
    fit_tol++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "fit_tol", &fit_tol, 0)
        && fit_tol == spline->fit_tol)
      pass ();
    else
      fail ("SPLINE.fit_tol [BD] set+1 %g != %g", spline->fit_tol, fit_tol);
    spline->fit_tol--;
  }
  {
    BITCODE_RS flag;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "flag", &flag, NULL)
        && flag == spline->flag)
      pass ();
    else
      fail ("SPLINE.flag [RS] %hu != %hu", spline->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "flag", &flag, 0)
        && flag == spline->flag)
      pass ();
    else
      fail ("SPLINE.flag [RS] set+1 %hu != %hu", spline->flag, flag);
    spline->flag--;
  }
  {
    BITCODE_BD knot_tol;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "knot_tol", &knot_tol, NULL)
        && knot_tol == spline->knot_tol)
      pass ();
    else
      fail ("SPLINE.knot_tol [BD] %g != %g", spline->knot_tol, knot_tol);
    knot_tol++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "knot_tol", &knot_tol, 0)
        && knot_tol == spline->knot_tol)
      pass ();
    else
      fail ("SPLINE.knot_tol [BD] set+1 %g != %g", spline->knot_tol, knot_tol);
    spline->knot_tol--;
  }
  {
    BITCODE_BL knotparam;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "knotparam", &knotparam, NULL)
        && knotparam == spline->knotparam)
      pass ();
    else
      fail ("SPLINE.knotparam [BL] %u != %u", spline->knotparam, knotparam);
    knotparam++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "knotparam", &knotparam, 0)
        && knotparam == spline->knotparam)
      pass ();
    else
      fail ("SPLINE.knotparam [BL] set+1 %u != %u", spline->knotparam, knotparam);
    spline->knotparam--;
  }
  {
    BITCODE_BD* knots;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_knots", &count, NULL)
        && dwg_dynapi_entity_value (spline, "SPLINE", "knots", &knots, NULL)
        && knots == spline->knots)
      pass ();
    else
      fail ("SPLINE.knots [BD*] * %u num_knots", count);
  }
  {
    BITCODE_BL num_ctrl_pts;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts, NULL)
        && num_ctrl_pts == spline->num_ctrl_pts)
      pass ();
    else
      fail ("SPLINE.num_ctrl_pts [BL] %u != %u", spline->num_ctrl_pts, num_ctrl_pts);
    num_ctrl_pts++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts, 0)
        && num_ctrl_pts == spline->num_ctrl_pts)
      pass ();
    else
      fail ("SPLINE.num_ctrl_pts [BL] set+1 %u != %u", spline->num_ctrl_pts, num_ctrl_pts);
    spline->num_ctrl_pts--;
  }
  {
    BITCODE_BS num_fit_pts;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_fit_pts", &num_fit_pts, NULL)
        && num_fit_pts == spline->num_fit_pts)
      pass ();
    else
      fail ("SPLINE.num_fit_pts [BS] %hu != %hu", spline->num_fit_pts, num_fit_pts);
    num_fit_pts++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_fit_pts", &num_fit_pts, 0)
        && num_fit_pts == spline->num_fit_pts)
      pass ();
    else
      fail ("SPLINE.num_fit_pts [BS] set+1 %hu != %hu", spline->num_fit_pts, num_fit_pts);
    spline->num_fit_pts--;
  }
  {
    BITCODE_BL num_knots;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "num_knots", &num_knots, NULL)
        && num_knots == spline->num_knots)
      pass ();
    else
      fail ("SPLINE.num_knots [BL] %u != %u", spline->num_knots, num_knots);
    num_knots++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_knots", &num_knots, 0)
        && num_knots == spline->num_knots)
      pass ();
    else
      fail ("SPLINE.num_knots [BL] set+1 %u != %u", spline->num_knots, num_knots);
    spline->num_knots--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "parent", &parent, NULL)
        && !memcmp (&parent, &spline->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("SPLINE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_B periodic;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "periodic", &periodic, NULL)
        && periodic == spline->periodic)
      pass ();
    else
      fail ("SPLINE.periodic [B] " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic);
    periodic++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "periodic", &periodic, 0)
        && periodic == spline->periodic)
      pass ();
    else
      fail ("SPLINE.periodic [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic);
    spline->periodic--;
  }
  {
    BITCODE_B rational;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "rational", &rational, NULL)
        && rational == spline->rational)
      pass ();
    else
      fail ("SPLINE.rational [B] " FORMAT_B " != " FORMAT_B "", spline->rational, rational);
    rational++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "rational", &rational, 0)
        && rational == spline->rational)
      pass ();
    else
      fail ("SPLINE.rational [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->rational, rational);
    spline->rational--;
  }
  {
    BITCODE_BS scenario;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "scenario", &scenario, NULL)
        && scenario == spline->scenario)
      pass ();
    else
      fail ("SPLINE.scenario [BS] %hu != %hu", spline->scenario, scenario);
    scenario++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "scenario", &scenario, 0)
        && scenario == spline->scenario)
      pass ();
    else
      fail ("SPLINE.scenario [BS] set+1 %hu != %hu", spline->scenario, scenario);
    spline->scenario--;
  }
  {
    BITCODE_BL splineflags;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "splineflags", &splineflags, NULL)
        && splineflags == spline->splineflags)
      pass ();
    else
      fail ("SPLINE.splineflags [BL] %u != %u", spline->splineflags, splineflags);
    splineflags++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "splineflags", &splineflags, 0)
        && splineflags == spline->splineflags)
      pass ();
    else
      fail ("SPLINE.splineflags [BL] set+1 %u != %u", spline->splineflags, splineflags);
    spline->splineflags--;
  }
  {
    BITCODE_B weighted;
    if (dwg_dynapi_entity_value (spline, "SPLINE", "weighted", &weighted, NULL)
        && weighted == spline->weighted)
      pass ();
    else
      fail ("SPLINE.weighted [B] " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted);
    weighted++;
    if (dwg_dynapi_entity_set_value (spline, "SPLINE", "weighted", &weighted, 0)
        && weighted == spline->weighted)
      pass ();
    else
      fail ("SPLINE.weighted [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted);
    spline->weighted--;
  }
  if (failed && (is_class_unstable ("SPLINE") || is_class_debugging ("SPLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SPLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SWEPTSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_SWEPTSURFACE *restrict sweptsurface = obj->tio.entity->tio.SWEPTSURFACE;
  failed = 0;
  if (!obj_obj || !sweptsurface)
    {
      fail ("NULL SWEPTSURFACE");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == sweptsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("SWEPTSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == sweptsurface->_dxf_sab_converted)
      pass ();
    else
      fail ("SWEPTSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->_dxf_sab_converted, _dxf_sab_converted);
    sweptsurface->_dxf_sab_converted--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)sweptsurface->acis_data)
           : !sweptsurface->acis_data)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, sweptsurface->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty, NULL)
        && acis_empty == sweptsurface->acis_empty)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty, 0)
        && acis_empty == sweptsurface->acis_empty)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty, acis_empty);
    sweptsurface->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == sweptsurface->acis_empty2)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == sweptsurface->acis_empty2)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty2, acis_empty2);
    sweptsurface->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == sweptsurface->acis_empty_bit)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == sweptsurface->acis_empty_bit)
      pass ();
    else
      fail ("SWEPTSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty_bit, acis_empty_bit);
    sweptsurface->acis_empty_bit--;
  }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle, NULL)
        && align_angle == sweptsurface->align_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.align_angle [BD] %g != %g", sweptsurface->align_angle, align_angle);
    align_angle++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle, 0)
        && align_angle == sweptsurface->align_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.align_angle [BD] set+1 %g != %g", sweptsurface->align_angle, align_angle);
    sweptsurface->align_angle--;
  }
  {
    BITCODE_B align_start;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "align_start", &align_start, NULL)
        && align_start == sweptsurface->align_start)
      pass ();
    else
      fail ("SWEPTSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start);
    align_start++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "align_start", &align_start, 0)
        && align_start == sweptsurface->align_start)
      pass ();
    else
      fail ("SWEPTSURFACE.align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start);
    sweptsurface->align_start--;
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "bank", &bank, NULL)
        && bank == sweptsurface->bank)
      pass ();
    else
      fail ("SWEPTSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank);
    bank++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "bank", &bank, 0)
        && bank == sweptsurface->bank)
      pass ();
    else
      fail ("SWEPTSURFACE.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank);
    sweptsurface->bank--;
  }
  {
    BITCODE_B base_point_set;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set, NULL)
        && base_point_set == sweptsurface->base_point_set)
      pass ();
    else
      fail ("SWEPTSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set);
    base_point_set++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set, 0)
        && base_point_set == sweptsurface->base_point_set)
      pass ();
    else
      fail ("SWEPTSURFACE.base_point_set [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set);
    sweptsurface->base_point_set--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &sweptsurface->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("SWEPTSURFACE.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "class_version", &class_version, NULL)
        && class_version == sweptsurface->class_version)
      pass ();
    else
      fail ("SWEPTSURFACE.class_version [BL] %u != %u", sweptsurface->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "class_version", &class_version, 0)
        && class_version == sweptsurface->class_version)
      pass ();
    else
      fail ("SWEPTSURFACE.class_version [BL] set+1 %u != %u", sweptsurface->class_version, class_version);
    sweptsurface->class_version--;
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle, NULL)
        && draft_angle == sweptsurface->draft_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_angle [BD] %g != %g", sweptsurface->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle, 0)
        && draft_angle == sweptsurface->draft_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_angle [BD] set+1 %g != %g", sweptsurface->draft_angle, draft_angle);
    sweptsurface->draft_angle--;
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance, NULL)
        && draft_end_distance == sweptsurface->draft_end_distance)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_end_distance [BD] %g != %g", sweptsurface->draft_end_distance, draft_end_distance);
    draft_end_distance++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance, 0)
        && draft_end_distance == sweptsurface->draft_end_distance)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_end_distance [BD] set+1 %g != %g", sweptsurface->draft_end_distance, draft_end_distance);
    sweptsurface->draft_end_distance--;
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance, NULL)
        && draft_start_distance == sweptsurface->draft_start_distance)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_start_distance [BD] %g != %g", sweptsurface->draft_start_distance, draft_start_distance);
    draft_start_distance++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance, 0)
        && draft_start_distance == sweptsurface->draft_start_distance)
      pass ();
    else
      fail ("SWEPTSURFACE.draft_start_distance [BD] set+1 %g != %g", sweptsurface->draft_start_distance, draft_start_distance);
    sweptsurface->draft_start_distance--;
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &sweptsurface->encr_sat_data, sizeof (sweptsurface->encr_sat_data)))
      pass ();
    else
      fail ("SWEPTSURFACE.encr_sat_data [char **]");
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "end_marker", &end_marker, NULL)
        && end_marker == sweptsurface->end_marker)
      pass ();
    else
      fail ("SWEPTSURFACE.end_marker [BL] %u != %u", sweptsurface->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "end_marker", &end_marker, 0)
        && end_marker == sweptsurface->end_marker)
      pass ();
    else
      fail ("SWEPTSURFACE.end_marker [BL] set+1 %u != %u", sweptsurface->end_marker, end_marker);
    sweptsurface->end_marker--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &sweptsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("SWEPTSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == sweptsurface->has_revision_guid)
      pass ();
    else
      fail ("SWEPTSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == sweptsurface->has_revision_guid)
      pass ();
    else
      fail ("SWEPTSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->has_revision_guid, has_revision_guid);
    sweptsurface->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &sweptsurface->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SWEPTSURFACE.history_id [H]");
  }
  {
    BITCODE_B is_solid;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "is_solid", &is_solid, NULL)
        && is_solid == sweptsurface->is_solid)
      pass ();
    else
      fail ("SWEPTSURFACE.is_solid [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->is_solid, is_solid);
    is_solid++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "is_solid", &is_solid, 0)
        && is_solid == sweptsurface->is_solid)
      pass ();
    else
      fail ("SWEPTSURFACE.is_solid [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->is_solid, is_solid);
    sweptsurface->is_solid--;
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present, NULL)
        && isoline_present == sweptsurface->isoline_present)
      pass ();
    else
      fail ("SWEPTSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present, 0)
        && isoline_present == sweptsurface->isoline_present)
      pass ();
    else
      fail ("SWEPTSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->isoline_present, isoline_present);
    sweptsurface->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "isolines", &isolines, NULL)
        && isolines == sweptsurface->isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.isolines [BL] %u != %u", sweptsurface->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "isolines", &isolines, 0)
        && isolines == sweptsurface->isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.isolines [BL] set+1 %u != %u", sweptsurface->isolines, isolines);
    sweptsurface->isolines--;
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "materials", &materials, NULL)
        && materials == sweptsurface->materials)
      pass ();
    else
      fail ("SWEPTSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version, NULL)
        && modeler_format_version == sweptsurface->modeler_format_version)
      pass ();
    else
      fail ("SWEPTSURFACE.modeler_format_version [BS] %hu != %hu", sweptsurface->modeler_format_version, modeler_format_version);
    modeler_format_version++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version, 0)
        && modeler_format_version == sweptsurface->modeler_format_version)
      pass ();
    else
      fail ("SWEPTSURFACE.modeler_format_version [BS] set+1 %hu != %hu", sweptsurface->modeler_format_version, modeler_format_version);
    sweptsurface->modeler_format_version--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks, NULL)
        && num_blocks == sweptsurface->num_blocks)
      pass ();
    else
      fail ("SWEPTSURFACE.num_blocks [BL] %u != %u", sweptsurface->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks, 0)
        && num_blocks == sweptsurface->num_blocks)
      pass ();
    else
      fail ("SWEPTSURFACE.num_blocks [BL] set+1 %u != %u", sweptsurface->num_blocks, num_blocks);
    sweptsurface->num_blocks--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_materials", &num_materials, NULL)
        && num_materials == sweptsurface->num_materials)
      pass ();
    else
      fail ("SWEPTSURFACE.num_materials [BL] %u != %u", sweptsurface->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_materials", &num_materials, 0)
        && num_materials == sweptsurface->num_materials)
      pass ();
    else
      fail ("SWEPTSURFACE.num_materials [BL] set+1 %u != %u", sweptsurface->num_materials, num_materials);
    sweptsurface->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == sweptsurface->num_silhouettes)
      pass ();
    else
      fail ("SWEPTSURFACE.num_silhouettes [BL] %u != %u", sweptsurface->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == sweptsurface->num_silhouettes)
      pass ();
    else
      fail ("SWEPTSURFACE.num_silhouettes [BL] set+1 %u != %u", sweptsurface->num_silhouettes, num_silhouettes);
    sweptsurface->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires, NULL)
        && num_wires == sweptsurface->num_wires)
      pass ();
    else
      fail ("SWEPTSURFACE.num_wires [BL] %u != %u", sweptsurface->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires, 0)
        && num_wires == sweptsurface->num_wires)
      pass ();
    else
      fail ("SWEPTSURFACE.num_wires [BL] set+1 %u != %u", sweptsurface->num_wires, num_wires);
    sweptsurface->num_wires--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "parent", &parent, NULL)
        && !memcmp (&parent, &sweptsurface->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("SWEPTSURFACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_H path_entity;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity", &path_entity, NULL)
        && !memcmp (&path_entity, &sweptsurface->path_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SWEPTSURFACE.path_entity [H]");
  }
  {
    BITCODE_BL path_entity_id;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id, NULL)
        && path_entity_id == sweptsurface->path_entity_id)
      pass ();
    else
      fail ("SWEPTSURFACE.path_entity_id [BL] %u != %u", sweptsurface->path_entity_id, path_entity_id);
    path_entity_id++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id, 0)
        && path_entity_id == sweptsurface->path_entity_id)
      pass ();
    else
      fail ("SWEPTSURFACE.path_entity_id [BL] set+1 %u != %u", sweptsurface->path_entity_id, path_entity_id);
    sweptsurface->path_entity_id--;
  }
  {
    BITCODE_B path_entity_transform_computed;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL)
        && path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
      pass ();
    else
      fail ("SWEPTSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed);
    path_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, 0)
        && path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
      pass ();
    else
      fail ("SWEPTSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed);
    sweptsurface->path_entity_transform_computed--;
  }
  {
    BITCODE_BD* path_entity_transmatrix;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
        && !memcmp (&path_entity_transmatrix, &sweptsurface->path_entity_transmatrix, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("SWEPTSURFACE.path_entity_transmatrix [BD*]");
  }
  {
    BITCODE_BS path_flags;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_flags", &path_flags, NULL)
        && path_flags == sweptsurface->path_flags)
      pass ();
    else
      fail ("SWEPTSURFACE.path_flags [BS] %hu != %hu", sweptsurface->path_flags, path_flags);
    path_flags++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "path_flags", &path_flags, 0)
        && path_flags == sweptsurface->path_flags)
      pass ();
    else
      fail ("SWEPTSURFACE.path_flags [BS] set+1 %hu != %hu", sweptsurface->path_flags, path_flags);
    sweptsurface->path_flags--;
  }
  {
    BITCODE_TF pathdata;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "pathdata", &pathdata, NULL)
        && !memcmp (&pathdata, &sweptsurface->pathdata, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("SWEPTSURFACE.pathdata [TF]");
  }
  {
    BITCODE_BL pathdata_size;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "pathdata_size", &pathdata_size, NULL)
        && pathdata_size == sweptsurface->pathdata_size)
      pass ();
    else
      fail ("SWEPTSURFACE.pathdata_size [BL] %u != %u", sweptsurface->pathdata_size, pathdata_size);
    pathdata_size++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "pathdata_size", &pathdata_size, 0)
        && pathdata_size == sweptsurface->pathdata_size)
      pass ();
    else
      fail ("SWEPTSURFACE.pathdata_size [BL] set+1 %u != %u", sweptsurface->pathdata_size, pathdata_size);
    sweptsurface->pathdata_size--;
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "point", &point, NULL)
        && !memcmp (&point, &sweptsurface->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("SWEPTSURFACE.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "point_present", &point_present, NULL)
        && point_present == sweptsurface->point_present)
      pass ();
    else
      fail ("SWEPTSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "point_present", &point_present, 0)
        && point_present == sweptsurface->point_present)
      pass ();
    else
      fail ("SWEPTSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->point_present, point_present);
    sweptsurface->point_present--;
  }
  {
    BITCODE_3BD reference_vector_for_controlling_twist;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
        && !memcmp (&reference_vector_for_controlling_twist, &sweptsurface->reference_vector_for_controlling_twist, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("SWEPTSURFACE.reference_vector_for_controlling_twist [3BD]");
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &sweptsurface->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("SWEPTSURFACE.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &sweptsurface->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("SWEPTSURFACE.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_major", &revision_major, NULL)
        && revision_major == sweptsurface->revision_major)
      pass ();
    else
      fail ("SWEPTSURFACE.revision_major [BL] %u != %u", sweptsurface->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "revision_major", &revision_major, 0)
        && revision_major == sweptsurface->revision_major)
      pass ();
    else
      fail ("SWEPTSURFACE.revision_major [BL] set+1 %u != %u", sweptsurface->revision_major, revision_major);
    sweptsurface->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == sweptsurface->revision_minor1)
      pass ();
    else
      fail ("SWEPTSURFACE.revision_minor1 [BS] %hu != %hu", sweptsurface->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == sweptsurface->revision_minor1)
      pass ();
    else
      fail ("SWEPTSURFACE.revision_minor1 [BS] set+1 %hu != %hu", sweptsurface->revision_minor1, revision_minor1);
    sweptsurface->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == sweptsurface->revision_minor2)
      pass ();
    else
      fail ("SWEPTSURFACE.revision_minor2 [BS] %hu != %hu", sweptsurface->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == sweptsurface->revision_minor2)
      pass ();
    else
      fail ("SWEPTSURFACE.revision_minor2 [BS] set+1 %hu != %hu", sweptsurface->revision_minor2, revision_minor2);
    sweptsurface->revision_minor2--;
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sab_size", &sab_size, NULL)
        && sab_size == sweptsurface->sab_size)
      pass ();
    else
      fail ("SWEPTSURFACE.sab_size [BL] %u != %u", sweptsurface->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sab_size", &sab_size, 0)
        && sab_size == sweptsurface->sab_size)
      pass ();
    else
      fail ("SWEPTSURFACE.sab_size [BL] set+1 %u != %u", sweptsurface->sab_size, sab_size);
    sweptsurface->sab_size--;
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor, NULL)
        && scale_factor == sweptsurface->scale_factor)
      pass ();
    else
      fail ("SWEPTSURFACE.scale_factor [BD] %g != %g", sweptsurface->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor, 0)
        && scale_factor == sweptsurface->scale_factor)
      pass ();
    else
      fail ("SWEPTSURFACE.scale_factor [BD] set+1 %g != %g", sweptsurface->scale_factor, scale_factor);
    sweptsurface->scale_factor--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "silhouettes", &silhouettes, NULL)
        && silhouettes == sweptsurface->silhouettes)
      pass ();
    else
      fail ("SWEPTSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_BS sweep_alignment_flags;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, NULL)
        && sweep_alignment_flags == sweptsurface->sweep_alignment_flags)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_alignment_flags [BS] %hu != %hu", sweptsurface->sweep_alignment_flags, sweep_alignment_flags);
    sweep_alignment_flags++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, 0)
        && sweep_alignment_flags == sweptsurface->sweep_alignment_flags)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_alignment_flags [BS] set+1 %hu != %hu", sweptsurface->sweep_alignment_flags, sweep_alignment_flags);
    sweptsurface->sweep_alignment_flags--;
  }
  {
    BITCODE_H sweep_entity;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity", &sweep_entity, NULL)
        && !memcmp (&sweep_entity, &sweptsurface->sweep_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SWEPTSURFACE.sweep_entity [H]");
  }
  {
    BITCODE_BL sweep_entity_id;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id, NULL)
        && sweep_entity_id == sweptsurface->sweep_entity_id)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_entity_id [BL] %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id);
    sweep_entity_id++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id, 0)
        && sweep_entity_id == sweptsurface->sweep_entity_id)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_entity_id [BL] set+1 %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id);
    sweptsurface->sweep_entity_id--;
  }
  {
    BITCODE_B sweep_entity_transform_computed;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL)
        && sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
    sweep_entity_transform_computed++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, 0)
        && sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
      pass ();
    else
      fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
    sweptsurface->sweep_entity_transform_computed--;
  }
  {
    BITCODE_BD* sweep_entity_transmatrix;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
        && !memcmp (&sweep_entity_transmatrix, &sweptsurface->sweep_entity_transmatrix, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("SWEPTSURFACE.sweep_entity_transmatrix [BD*]");
  }
  {
    BITCODE_TF sweepdata;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweepdata", &sweepdata, NULL)
        && !memcmp (&sweepdata, &sweptsurface->sweepdata, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("SWEPTSURFACE.sweepdata [TF]");
  }
  {
    BITCODE_BL sweepdata_size;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweepdata_size", &sweepdata_size, NULL)
        && sweepdata_size == sweptsurface->sweepdata_size)
      pass ();
    else
      fail ("SWEPTSURFACE.sweepdata_size [BL] %u != %u", sweptsurface->sweepdata_size, sweepdata_size);
    sweepdata_size++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweepdata_size", &sweepdata_size, 0)
        && sweepdata_size == sweptsurface->sweepdata_size)
      pass ();
    else
      fail ("SWEPTSURFACE.sweepdata_size [BL] set+1 %u != %u", sweptsurface->sweepdata_size, sweepdata_size);
    sweptsurface->sweepdata_size--;
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle, NULL)
        && twist_angle == sweptsurface->twist_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.twist_angle [BD] %g != %g", sweptsurface->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle, 0)
        && twist_angle == sweptsurface->twist_angle)
      pass ();
    else
      fail ("SWEPTSURFACE.twist_angle [BD] set+1 %g != %g", sweptsurface->twist_angle, twist_angle);
    sweptsurface->twist_angle--;
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines, NULL)
        && u_isolines == sweptsurface->u_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.u_isolines [BS] %hu != %hu", sweptsurface->u_isolines, u_isolines);
    u_isolines++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines, 0)
        && u_isolines == sweptsurface->u_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.u_isolines [BS] set+1 %hu != %hu", sweptsurface->u_isolines, u_isolines);
    sweptsurface->u_isolines--;
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "unknown", &unknown, NULL)
        && unknown == sweptsurface->unknown)
      pass ();
    else
      fail ("SWEPTSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "unknown", &unknown, 0)
        && unknown == sweptsurface->unknown)
      pass ();
    else
      fail ("SWEPTSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->unknown, unknown);
    sweptsurface->unknown--;
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines, NULL)
        && v_isolines == sweptsurface->v_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.v_isolines [BS] %hu != %hu", sweptsurface->v_isolines, v_isolines);
    v_isolines++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines, 0)
        && v_isolines == sweptsurface->v_isolines)
      pass ();
    else
      fail ("SWEPTSURFACE.v_isolines [BS] set+1 %hu != %hu", sweptsurface->v_isolines, v_isolines);
    sweptsurface->v_isolines--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "version", &version, NULL)
        && version == sweptsurface->version)
      pass ();
    else
      fail ("SWEPTSURFACE.version [BS] %hu != %hu", sweptsurface->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "version", &version, 0)
        && version == sweptsurface->version)
      pass ();
    else
      fail ("SWEPTSURFACE.version [BS] set+1 %hu != %hu", sweptsurface->version, version);
    sweptsurface->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == sweptsurface->wireframe_data_present)
      pass ();
    else
      fail ("SWEPTSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == sweptsurface->wireframe_data_present)
      pass ();
    else
      fail ("SWEPTSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->wireframe_data_present, wireframe_data_present);
    sweptsurface->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "wires", &wires, NULL)
        && wires == sweptsurface->wires)
      pass ();
    else
      fail ("SWEPTSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("SWEPTSURFACE") || is_class_debugging ("SWEPTSURFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SWEPTSURFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_TABLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_TABLE *restrict table = obj->tio.entity->tio.TABLE;
  failed = 0;
  if (!obj_obj || !table)
    {
      fail ("NULL TABLE");
      return 1;
    }
  {
    BITCODE_H* attribs;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "attribs", &attribs, NULL)
        && attribs == table->attribs)
      pass ();
    else
      fail ("TABLE.attribs [H*] * %u num_owned", count);
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value (table, "TABLE", "block_header", &block_header, NULL)
        && !memcmp (&block_header, &table->block_header, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.block_header [H]");
  }
  {
    BITCODE_BL border_color_overrides_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "border_color_overrides_flag", &border_color_overrides_flag, NULL)
        && border_color_overrides_flag == table->border_color_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_color_overrides_flag [BL] %u != %u", table->border_color_overrides_flag, border_color_overrides_flag);
    border_color_overrides_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "border_color_overrides_flag", &border_color_overrides_flag, 0)
        && border_color_overrides_flag == table->border_color_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_color_overrides_flag [BL] set+1 %u != %u", table->border_color_overrides_flag, border_color_overrides_flag);
    table->border_color_overrides_flag--;
  }
  {
    BITCODE_BL border_lineweight_overrides_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "border_lineweight_overrides_flag", &border_lineweight_overrides_flag, NULL)
        && border_lineweight_overrides_flag == table->border_lineweight_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_lineweight_overrides_flag [BL] %u != %u", table->border_lineweight_overrides_flag, border_lineweight_overrides_flag);
    border_lineweight_overrides_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "border_lineweight_overrides_flag", &border_lineweight_overrides_flag, 0)
        && border_lineweight_overrides_flag == table->border_lineweight_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_lineweight_overrides_flag [BL] set+1 %u != %u", table->border_lineweight_overrides_flag, border_lineweight_overrides_flag);
    table->border_lineweight_overrides_flag--;
  }
  {
    BITCODE_BL border_visibility_overrides_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "border_visibility_overrides_flag", &border_visibility_overrides_flag, NULL)
        && border_visibility_overrides_flag == table->border_visibility_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_visibility_overrides_flag [BL] %u != %u", table->border_visibility_overrides_flag, border_visibility_overrides_flag);
    border_visibility_overrides_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "border_visibility_overrides_flag", &border_visibility_overrides_flag, 0)
        && border_visibility_overrides_flag == table->border_visibility_overrides_flag)
      pass ();
    else
      fail ("TABLE.border_visibility_overrides_flag [BL] set+1 %u != %u", table->border_visibility_overrides_flag, border_visibility_overrides_flag);
    table->border_visibility_overrides_flag--;
  }
  {
    BITCODE_BL break_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_flag", &break_flag, NULL)
        && break_flag == table->break_flag)
      pass ();
    else
      fail ("TABLE.break_flag [BL] %u != %u", table->break_flag, break_flag);
    break_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_flag", &break_flag, 0)
        && break_flag == table->break_flag)
      pass ();
    else
      fail ("TABLE.break_flag [BL] set+1 %u != %u", table->break_flag, break_flag);
    table->break_flag--;
  }
  {
    BITCODE_BL break_flow_direction;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_flow_direction", &break_flow_direction, NULL)
        && break_flow_direction == table->break_flow_direction)
      pass ();
    else
      fail ("TABLE.break_flow_direction [BL] %u != %u", table->break_flow_direction, break_flow_direction);
    break_flow_direction++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_flow_direction", &break_flow_direction, 0)
        && break_flow_direction == table->break_flow_direction)
      pass ();
    else
      fail ("TABLE.break_flow_direction [BL] set+1 %u != %u", table->break_flow_direction, break_flow_direction);
    table->break_flow_direction--;
  }
  {
    Dwg_TABLE_BreakHeight* break_heights;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_break_heights", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "break_heights", &break_heights, NULL)
        && break_heights == table->break_heights)
      pass ();
    else
      fail ("TABLE.break_heights [Dwg_TABLE_BreakHeight*] * %u num_break_heights", count);
  }
  {
    Dwg_TABLE_BreakRow* break_rows;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_break_rows", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "break_rows", &break_rows, NULL)
        && break_rows == table->break_rows)
      pass ();
    else
      fail ("TABLE.break_rows [Dwg_TABLE_BreakRow*] * %u num_break_rows", count);
  }
  {
    BITCODE_BD break_spacing;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_spacing", &break_spacing, NULL)
        && break_spacing == table->break_spacing)
      pass ();
    else
      fail ("TABLE.break_spacing [BD] %g != %g", table->break_spacing, break_spacing);
    break_spacing++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_spacing", &break_spacing, 0)
        && break_spacing == table->break_spacing)
      pass ();
    else
      fail ("TABLE.break_spacing [BD] set+1 %g != %g", table->break_spacing, break_spacing);
    table->break_spacing--;
  }
  {
    BITCODE_BL break_unknown1;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_unknown1", &break_unknown1, NULL)
        && break_unknown1 == table->break_unknown1)
      pass ();
    else
      fail ("TABLE.break_unknown1 [BL] %u != %u", table->break_unknown1, break_unknown1);
    break_unknown1++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_unknown1", &break_unknown1, 0)
        && break_unknown1 == table->break_unknown1)
      pass ();
    else
      fail ("TABLE.break_unknown1 [BL] set+1 %u != %u", table->break_unknown1, break_unknown1);
    table->break_unknown1--;
  }
  {
    BITCODE_BL break_unknown2;
    if (dwg_dynapi_entity_value (table, "TABLE", "break_unknown2", &break_unknown2, NULL)
        && break_unknown2 == table->break_unknown2)
      pass ();
    else
      fail ("TABLE.break_unknown2 [BL] %u != %u", table->break_unknown2, break_unknown2);
    break_unknown2++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "break_unknown2", &break_unknown2, 0)
        && break_unknown2 == table->break_unknown2)
      pass ();
    else
      fail ("TABLE.break_unknown2 [BL] set+1 %u != %u", table->break_unknown2, break_unknown2);
    table->break_unknown2--;
  }
  {
    Dwg_TABLE_Cell* cells;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_cells", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "cells", &cells, NULL)
        && cells == table->cells)
      pass ();
    else
      fail ("TABLE.cells [Dwg_TABLE_Cell*] * %u num_cells", count);
  }
  {
    BITCODE_BD* col_widths;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_col_widths", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "col_widths", &col_widths, NULL)
        && col_widths == table->col_widths)
      pass ();
    else
      fail ("TABLE.col_widths [BD*] * %u num_col_widths", count);
  }
  {
    BITCODE_CMC data_horiz_bottom_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_bottom_color", &data_horiz_bottom_color, NULL)
        && !memcmp (&data_horiz_bottom_color, &table->data_horiz_bottom_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.data_horiz_bottom_color [CMC]");
  }
  {
    BITCODE_BS data_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_bottom_linewt", &data_horiz_bottom_linewt, NULL)
        && data_horiz_bottom_linewt == table->data_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_bottom_linewt [BS] %hu != %hu", table->data_horiz_bottom_linewt, data_horiz_bottom_linewt);
    data_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_bottom_linewt", &data_horiz_bottom_linewt, 0)
        && data_horiz_bottom_linewt == table->data_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->data_horiz_bottom_linewt, data_horiz_bottom_linewt);
    table->data_horiz_bottom_linewt--;
  }
  {
    BITCODE_BS data_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_bottom_visibility", &data_horiz_bottom_visibility, NULL)
        && data_horiz_bottom_visibility == table->data_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_bottom_visibility [BS] %hu != %hu", table->data_horiz_bottom_visibility, data_horiz_bottom_visibility);
    data_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_bottom_visibility", &data_horiz_bottom_visibility, 0)
        && data_horiz_bottom_visibility == table->data_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->data_horiz_bottom_visibility, data_horiz_bottom_visibility);
    table->data_horiz_bottom_visibility--;
  }
  {
    BITCODE_CMC data_horiz_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_ins_color", &data_horiz_ins_color, NULL)
        && !memcmp (&data_horiz_ins_color, &table->data_horiz_ins_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.data_horiz_ins_color [CMC]");
  }
  {
    BITCODE_BS data_horiz_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_ins_linewt", &data_horiz_ins_linewt, NULL)
        && data_horiz_ins_linewt == table->data_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_ins_linewt [BS] %hu != %hu", table->data_horiz_ins_linewt, data_horiz_ins_linewt);
    data_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_ins_linewt", &data_horiz_ins_linewt, 0)
        && data_horiz_ins_linewt == table->data_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_ins_linewt [BS] set+1 %hu != %hu", table->data_horiz_ins_linewt, data_horiz_ins_linewt);
    table->data_horiz_ins_linewt--;
  }
  {
    BITCODE_BS data_horiz_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_ins_visibility", &data_horiz_ins_visibility, NULL)
        && data_horiz_ins_visibility == table->data_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_ins_visibility [BS] %hu != %hu", table->data_horiz_ins_visibility, data_horiz_ins_visibility);
    data_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_ins_visibility", &data_horiz_ins_visibility, 0)
        && data_horiz_ins_visibility == table->data_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_ins_visibility [BS] set+1 %hu != %hu", table->data_horiz_ins_visibility, data_horiz_ins_visibility);
    table->data_horiz_ins_visibility--;
  }
  {
    BITCODE_CMC data_horiz_top_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_top_color", &data_horiz_top_color, NULL)
        && !memcmp (&data_horiz_top_color, &table->data_horiz_top_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.data_horiz_top_color [CMC]");
  }
  {
    BITCODE_BS data_horiz_top_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_top_linewt", &data_horiz_top_linewt, NULL)
        && data_horiz_top_linewt == table->data_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_top_linewt [BS] %hu != %hu", table->data_horiz_top_linewt, data_horiz_top_linewt);
    data_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_top_linewt", &data_horiz_top_linewt, 0)
        && data_horiz_top_linewt == table->data_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.data_horiz_top_linewt [BS] set+1 %hu != %hu", table->data_horiz_top_linewt, data_horiz_top_linewt);
    table->data_horiz_top_linewt--;
  }
  {
    BITCODE_BS data_horiz_top_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_horiz_top_visibility", &data_horiz_top_visibility, NULL)
        && data_horiz_top_visibility == table->data_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_top_visibility [BS] %hu != %hu", table->data_horiz_top_visibility, data_horiz_top_visibility);
    data_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_horiz_top_visibility", &data_horiz_top_visibility, 0)
        && data_horiz_top_visibility == table->data_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.data_horiz_top_visibility [BS] set+1 %hu != %hu", table->data_horiz_top_visibility, data_horiz_top_visibility);
    table->data_horiz_top_visibility--;
  }
  {
    BITCODE_BS data_row_alignment;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_alignment", &data_row_alignment, NULL)
        && data_row_alignment == table->data_row_alignment)
      pass ();
    else
      fail ("TABLE.data_row_alignment [BS] %hu != %hu", table->data_row_alignment, data_row_alignment);
    data_row_alignment++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_row_alignment", &data_row_alignment, 0)
        && data_row_alignment == table->data_row_alignment)
      pass ();
    else
      fail ("TABLE.data_row_alignment [BS] set+1 %hu != %hu", table->data_row_alignment, data_row_alignment);
    table->data_row_alignment--;
  }
  {
    BITCODE_CMC data_row_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_color", &data_row_color, NULL)
        && !memcmp (&data_row_color, &table->data_row_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.data_row_color [CMC]");
  }
  {
    BITCODE_CMC data_row_fill_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_fill_color", &data_row_fill_color, NULL)
        && !memcmp (&data_row_fill_color, &table->data_row_fill_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.data_row_fill_color [CMC]");
  }
  {
    BITCODE_B data_row_fill_none;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_fill_none", &data_row_fill_none, NULL)
        && data_row_fill_none == table->data_row_fill_none)
      pass ();
    else
      fail ("TABLE.data_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->data_row_fill_none, data_row_fill_none);
    data_row_fill_none++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_row_fill_none", &data_row_fill_none, 0)
        && data_row_fill_none == table->data_row_fill_none)
      pass ();
    else
      fail ("TABLE.data_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->data_row_fill_none, data_row_fill_none);
    table->data_row_fill_none--;
  }
  {
    BITCODE_BD data_row_height;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_height", &data_row_height, NULL)
        && data_row_height == table->data_row_height)
      pass ();
    else
      fail ("TABLE.data_row_height [BD] %g != %g", table->data_row_height, data_row_height);
    data_row_height++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_row_height", &data_row_height, 0)
        && data_row_height == table->data_row_height)
      pass ();
    else
      fail ("TABLE.data_row_height [BD] set+1 %g != %g", table->data_row_height, data_row_height);
    table->data_row_height--;
  }
  {
    BITCODE_H data_row_style_override;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_row_style_override", &data_row_style_override, NULL)
        && !memcmp (&data_row_style_override, &table->data_row_style_override, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.data_row_style_override [H]");
  }
  {
    BITCODE_H data_text_style;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_text_style", &data_text_style, NULL)
        && !memcmp (&data_text_style, &table->data_text_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.data_text_style [H]");
  }
  {
    BITCODE_CMC data_vert_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_ins_color", &data_vert_ins_color, NULL)
        && !memcmp (&data_vert_ins_color, &table->data_vert_ins_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.data_vert_ins_color [CMC]");
  }
  {
    BITCODE_BS data_vert_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_ins_linewt", &data_vert_ins_linewt, NULL)
        && data_vert_ins_linewt == table->data_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_ins_linewt [BS] %hu != %hu", table->data_vert_ins_linewt, data_vert_ins_linewt);
    data_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_ins_linewt", &data_vert_ins_linewt, 0)
        && data_vert_ins_linewt == table->data_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_ins_linewt [BS] set+1 %hu != %hu", table->data_vert_ins_linewt, data_vert_ins_linewt);
    table->data_vert_ins_linewt--;
  }
  {
    BITCODE_BS data_vert_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_ins_visibility", &data_vert_ins_visibility, NULL)
        && data_vert_ins_visibility == table->data_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_ins_visibility [BS] %hu != %hu", table->data_vert_ins_visibility, data_vert_ins_visibility);
    data_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_ins_visibility", &data_vert_ins_visibility, 0)
        && data_vert_ins_visibility == table->data_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_ins_visibility [BS] set+1 %hu != %hu", table->data_vert_ins_visibility, data_vert_ins_visibility);
    table->data_vert_ins_visibility--;
  }
  {
    BITCODE_CMC data_vert_left_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_left_color", &data_vert_left_color, NULL)
        && !memcmp (&data_vert_left_color, &table->data_vert_left_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.data_vert_left_color [CMC]");
  }
  {
    BITCODE_BS data_vert_left_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_left_linewt", &data_vert_left_linewt, NULL)
        && data_vert_left_linewt == table->data_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_left_linewt [BS] %hu != %hu", table->data_vert_left_linewt, data_vert_left_linewt);
    data_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_left_linewt", &data_vert_left_linewt, 0)
        && data_vert_left_linewt == table->data_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_left_linewt [BS] set+1 %hu != %hu", table->data_vert_left_linewt, data_vert_left_linewt);
    table->data_vert_left_linewt--;
  }
  {
    BITCODE_BS data_vert_left_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_left_visibility", &data_vert_left_visibility, NULL)
        && data_vert_left_visibility == table->data_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_left_visibility [BS] %hu != %hu", table->data_vert_left_visibility, data_vert_left_visibility);
    data_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_left_visibility", &data_vert_left_visibility, 0)
        && data_vert_left_visibility == table->data_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_left_visibility [BS] set+1 %hu != %hu", table->data_vert_left_visibility, data_vert_left_visibility);
    table->data_vert_left_visibility--;
  }
  {
    BITCODE_CMC data_vert_right_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_right_color", &data_vert_right_color, NULL)
        && !memcmp (&data_vert_right_color, &table->data_vert_right_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.data_vert_right_color [CMC]");
  }
  {
    BITCODE_BS data_vert_right_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_right_linewt", &data_vert_right_linewt, NULL)
        && data_vert_right_linewt == table->data_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_right_linewt [BS] %hu != %hu", table->data_vert_right_linewt, data_vert_right_linewt);
    data_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_right_linewt", &data_vert_right_linewt, 0)
        && data_vert_right_linewt == table->data_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.data_vert_right_linewt [BS] set+1 %hu != %hu", table->data_vert_right_linewt, data_vert_right_linewt);
    table->data_vert_right_linewt--;
  }
  {
    BITCODE_BS data_vert_right_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "data_vert_right_visibility", &data_vert_right_visibility, NULL)
        && data_vert_right_visibility == table->data_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_right_visibility [BS] %hu != %hu", table->data_vert_right_visibility, data_vert_right_visibility);
    data_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "data_vert_right_visibility", &data_vert_right_visibility, 0)
        && data_vert_right_visibility == table->data_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.data_vert_right_visibility [BS] set+1 %hu != %hu", table->data_vert_right_visibility, data_vert_right_visibility);
    table->data_vert_right_visibility--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (table, "TABLE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &table->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("TABLE.extrusion [BE]");
  }
  {
    Dwg_FormattedTableData fdata;
    if (dwg_dynapi_entity_value (table, "TABLE", "fdata", &fdata, NULL)
        && !memcmp (&fdata, &table->fdata, sizeof (Dwg_FormattedTableData)))
        pass ();
    else
        fail ("TABLE.fdata [Dwg_FormattedTableData]");
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value (table, "TABLE", "first_attrib", &first_attrib, NULL)
        && !memcmp (&first_attrib, &table->first_attrib, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.first_attrib [H]");
  }
  {
    BITCODE_BS flag_for_table_value;
    if (dwg_dynapi_entity_value (table, "TABLE", "flag_for_table_value", &flag_for_table_value, NULL)
        && flag_for_table_value == table->flag_for_table_value)
      pass ();
    else
      fail ("TABLE.flag_for_table_value [BS] %hu != %hu", table->flag_for_table_value, flag_for_table_value);
    flag_for_table_value++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "flag_for_table_value", &flag_for_table_value, 0)
        && flag_for_table_value == table->flag_for_table_value)
      pass ();
    else
      fail ("TABLE.flag_for_table_value [BS] set+1 %hu != %hu", table->flag_for_table_value, flag_for_table_value);
    table->flag_for_table_value--;
  }
  {
    BITCODE_BS flow_direction;
    if (dwg_dynapi_entity_value (table, "TABLE", "flow_direction", &flow_direction, NULL)
        && flow_direction == table->flow_direction)
      pass ();
    else
      fail ("TABLE.flow_direction [BS] %hu != %hu", table->flow_direction, flow_direction);
    flow_direction++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "flow_direction", &flow_direction, 0)
        && flow_direction == table->flow_direction)
      pass ();
    else
      fail ("TABLE.flow_direction [BS] set+1 %hu != %hu", table->flow_direction, flow_direction);
    table->flow_direction--;
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_attribs", &has_attribs, NULL)
        && has_attribs == table->has_attribs)
      pass ();
    else
      fail ("TABLE.has_attribs [B] " FORMAT_B " != " FORMAT_B "", table->has_attribs, has_attribs);
    has_attribs++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_attribs", &has_attribs, 0)
        && has_attribs == table->has_attribs)
      pass ();
    else
      fail ("TABLE.has_attribs [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_attribs, has_attribs);
    table->has_attribs--;
  }
  {
    BITCODE_B has_border_color_overrides;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_border_color_overrides", &has_border_color_overrides, NULL)
        && has_border_color_overrides == table->has_border_color_overrides)
      pass ();
    else
      fail ("TABLE.has_border_color_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_color_overrides, has_border_color_overrides);
    has_border_color_overrides++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_border_color_overrides", &has_border_color_overrides, 0)
        && has_border_color_overrides == table->has_border_color_overrides)
      pass ();
    else
      fail ("TABLE.has_border_color_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_color_overrides, has_border_color_overrides);
    table->has_border_color_overrides--;
  }
  {
    BITCODE_B has_border_lineweight_overrides;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_border_lineweight_overrides", &has_border_lineweight_overrides, NULL)
        && has_border_lineweight_overrides == table->has_border_lineweight_overrides)
      pass ();
    else
      fail ("TABLE.has_border_lineweight_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_lineweight_overrides, has_border_lineweight_overrides);
    has_border_lineweight_overrides++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_border_lineweight_overrides", &has_border_lineweight_overrides, 0)
        && has_border_lineweight_overrides == table->has_border_lineweight_overrides)
      pass ();
    else
      fail ("TABLE.has_border_lineweight_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_lineweight_overrides, has_border_lineweight_overrides);
    table->has_border_lineweight_overrides--;
  }
  {
    BITCODE_B has_border_visibility_overrides;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_border_visibility_overrides", &has_border_visibility_overrides, NULL)
        && has_border_visibility_overrides == table->has_border_visibility_overrides)
      pass ();
    else
      fail ("TABLE.has_border_visibility_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_visibility_overrides, has_border_visibility_overrides);
    has_border_visibility_overrides++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_border_visibility_overrides", &has_border_visibility_overrides, 0)
        && has_border_visibility_overrides == table->has_border_visibility_overrides)
      pass ();
    else
      fail ("TABLE.has_border_visibility_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_border_visibility_overrides, has_border_visibility_overrides);
    table->has_border_visibility_overrides--;
  }
  {
    BITCODE_BL has_break_data;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_break_data", &has_break_data, NULL)
        && has_break_data == table->has_break_data)
      pass ();
    else
      fail ("TABLE.has_break_data [BL] %u != %u", table->has_break_data, has_break_data);
    has_break_data++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_break_data", &has_break_data, 0)
        && has_break_data == table->has_break_data)
      pass ();
    else
      fail ("TABLE.has_break_data [BL] set+1 %u != %u", table->has_break_data, has_break_data);
    table->has_break_data--;
  }
  {
    BITCODE_B has_table_overrides;
    if (dwg_dynapi_entity_value (table, "TABLE", "has_table_overrides", &has_table_overrides, NULL)
        && has_table_overrides == table->has_table_overrides)
      pass ();
    else
      fail ("TABLE.has_table_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_table_overrides, has_table_overrides);
    has_table_overrides++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "has_table_overrides", &has_table_overrides, 0)
        && has_table_overrides == table->has_table_overrides)
      pass ();
    else
      fail ("TABLE.has_table_overrides [B] set+1 " FORMAT_B " != " FORMAT_B "", table->has_table_overrides, has_table_overrides);
    table->has_table_overrides--;
  }
  {
    BITCODE_CMC header_horiz_bottom_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_bottom_color", &header_horiz_bottom_color, NULL)
        && !memcmp (&header_horiz_bottom_color, &table->header_horiz_bottom_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.header_horiz_bottom_color [CMC]");
  }
  {
    BITCODE_BS header_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_bottom_linewt", &header_horiz_bottom_linewt, NULL)
        && header_horiz_bottom_linewt == table->header_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_bottom_linewt [BS] %hu != %hu", table->header_horiz_bottom_linewt, header_horiz_bottom_linewt);
    header_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_bottom_linewt", &header_horiz_bottom_linewt, 0)
        && header_horiz_bottom_linewt == table->header_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->header_horiz_bottom_linewt, header_horiz_bottom_linewt);
    table->header_horiz_bottom_linewt--;
  }
  {
    BITCODE_BS header_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_bottom_visibility", &header_horiz_bottom_visibility, NULL)
        && header_horiz_bottom_visibility == table->header_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_bottom_visibility [BS] %hu != %hu", table->header_horiz_bottom_visibility, header_horiz_bottom_visibility);
    header_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_bottom_visibility", &header_horiz_bottom_visibility, 0)
        && header_horiz_bottom_visibility == table->header_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->header_horiz_bottom_visibility, header_horiz_bottom_visibility);
    table->header_horiz_bottom_visibility--;
  }
  {
    BITCODE_CMC header_horiz_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_ins_color", &header_horiz_ins_color, NULL)
        && !memcmp (&header_horiz_ins_color, &table->header_horiz_ins_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.header_horiz_ins_color [CMC]");
  }
  {
    BITCODE_BS header_horiz_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_ins_linewt", &header_horiz_ins_linewt, NULL)
        && header_horiz_ins_linewt == table->header_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_ins_linewt [BS] %hu != %hu", table->header_horiz_ins_linewt, header_horiz_ins_linewt);
    header_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_ins_linewt", &header_horiz_ins_linewt, 0)
        && header_horiz_ins_linewt == table->header_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_ins_linewt [BS] set+1 %hu != %hu", table->header_horiz_ins_linewt, header_horiz_ins_linewt);
    table->header_horiz_ins_linewt--;
  }
  {
    BITCODE_BS header_horiz_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_ins_visibility", &header_horiz_ins_visibility, NULL)
        && header_horiz_ins_visibility == table->header_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_ins_visibility [BS] %hu != %hu", table->header_horiz_ins_visibility, header_horiz_ins_visibility);
    header_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_ins_visibility", &header_horiz_ins_visibility, 0)
        && header_horiz_ins_visibility == table->header_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_ins_visibility [BS] set+1 %hu != %hu", table->header_horiz_ins_visibility, header_horiz_ins_visibility);
    table->header_horiz_ins_visibility--;
  }
  {
    BITCODE_CMC header_horiz_top_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_top_color", &header_horiz_top_color, NULL)
        && !memcmp (&header_horiz_top_color, &table->header_horiz_top_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.header_horiz_top_color [CMC]");
  }
  {
    BITCODE_BS header_horiz_top_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_top_linewt", &header_horiz_top_linewt, NULL)
        && header_horiz_top_linewt == table->header_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_top_linewt [BS] %hu != %hu", table->header_horiz_top_linewt, header_horiz_top_linewt);
    header_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_top_linewt", &header_horiz_top_linewt, 0)
        && header_horiz_top_linewt == table->header_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.header_horiz_top_linewt [BS] set+1 %hu != %hu", table->header_horiz_top_linewt, header_horiz_top_linewt);
    table->header_horiz_top_linewt--;
  }
  {
    BITCODE_BS header_horiz_top_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_horiz_top_visibility", &header_horiz_top_visibility, NULL)
        && header_horiz_top_visibility == table->header_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_top_visibility [BS] %hu != %hu", table->header_horiz_top_visibility, header_horiz_top_visibility);
    header_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_horiz_top_visibility", &header_horiz_top_visibility, 0)
        && header_horiz_top_visibility == table->header_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.header_horiz_top_visibility [BS] set+1 %hu != %hu", table->header_horiz_top_visibility, header_horiz_top_visibility);
    table->header_horiz_top_visibility--;
  }
  {
    BITCODE_BS header_row_alignment;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_alignment", &header_row_alignment, NULL)
        && header_row_alignment == table->header_row_alignment)
      pass ();
    else
      fail ("TABLE.header_row_alignment [BS] %hu != %hu", table->header_row_alignment, header_row_alignment);
    header_row_alignment++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_row_alignment", &header_row_alignment, 0)
        && header_row_alignment == table->header_row_alignment)
      pass ();
    else
      fail ("TABLE.header_row_alignment [BS] set+1 %hu != %hu", table->header_row_alignment, header_row_alignment);
    table->header_row_alignment--;
  }
  {
    BITCODE_CMC header_row_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_color", &header_row_color, NULL)
        && !memcmp (&header_row_color, &table->header_row_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.header_row_color [CMC]");
  }
  {
    BITCODE_CMC header_row_fill_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_fill_color", &header_row_fill_color, NULL)
        && !memcmp (&header_row_fill_color, &table->header_row_fill_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.header_row_fill_color [CMC]");
  }
  {
    BITCODE_B header_row_fill_none;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_fill_none", &header_row_fill_none, NULL)
        && header_row_fill_none == table->header_row_fill_none)
      pass ();
    else
      fail ("TABLE.header_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->header_row_fill_none, header_row_fill_none);
    header_row_fill_none++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_row_fill_none", &header_row_fill_none, 0)
        && header_row_fill_none == table->header_row_fill_none)
      pass ();
    else
      fail ("TABLE.header_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->header_row_fill_none, header_row_fill_none);
    table->header_row_fill_none--;
  }
  {
    BITCODE_BD header_row_height;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_height", &header_row_height, NULL)
        && header_row_height == table->header_row_height)
      pass ();
    else
      fail ("TABLE.header_row_height [BD] %g != %g", table->header_row_height, header_row_height);
    header_row_height++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_row_height", &header_row_height, 0)
        && header_row_height == table->header_row_height)
      pass ();
    else
      fail ("TABLE.header_row_height [BD] set+1 %g != %g", table->header_row_height, header_row_height);
    table->header_row_height--;
  }
  {
    BITCODE_H header_row_style_override;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_row_style_override", &header_row_style_override, NULL)
        && !memcmp (&header_row_style_override, &table->header_row_style_override, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.header_row_style_override [H]");
  }
  {
    BITCODE_B header_suppressed;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_suppressed", &header_suppressed, NULL)
        && header_suppressed == table->header_suppressed)
      pass ();
    else
      fail ("TABLE.header_suppressed [B] " FORMAT_B " != " FORMAT_B "", table->header_suppressed, header_suppressed);
    header_suppressed++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_suppressed", &header_suppressed, 0)
        && header_suppressed == table->header_suppressed)
      pass ();
    else
      fail ("TABLE.header_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", table->header_suppressed, header_suppressed);
    table->header_suppressed--;
  }
  {
    BITCODE_H header_text_style;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_text_style", &header_text_style, NULL)
        && !memcmp (&header_text_style, &table->header_text_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.header_text_style [H]");
  }
  {
    BITCODE_CMC header_vert_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_ins_color", &header_vert_ins_color, NULL)
        && !memcmp (&header_vert_ins_color, &table->header_vert_ins_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.header_vert_ins_color [CMC]");
  }
  {
    BITCODE_BS header_vert_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_ins_linewt", &header_vert_ins_linewt, NULL)
        && header_vert_ins_linewt == table->header_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_ins_linewt [BS] %hu != %hu", table->header_vert_ins_linewt, header_vert_ins_linewt);
    header_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_ins_linewt", &header_vert_ins_linewt, 0)
        && header_vert_ins_linewt == table->header_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_ins_linewt [BS] set+1 %hu != %hu", table->header_vert_ins_linewt, header_vert_ins_linewt);
    table->header_vert_ins_linewt--;
  }
  {
    BITCODE_BS header_vert_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_ins_visibility", &header_vert_ins_visibility, NULL)
        && header_vert_ins_visibility == table->header_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_ins_visibility [BS] %hu != %hu", table->header_vert_ins_visibility, header_vert_ins_visibility);
    header_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_ins_visibility", &header_vert_ins_visibility, 0)
        && header_vert_ins_visibility == table->header_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_ins_visibility [BS] set+1 %hu != %hu", table->header_vert_ins_visibility, header_vert_ins_visibility);
    table->header_vert_ins_visibility--;
  }
  {
    BITCODE_CMC header_vert_left_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_left_color", &header_vert_left_color, NULL)
        && !memcmp (&header_vert_left_color, &table->header_vert_left_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.header_vert_left_color [CMC]");
  }
  {
    BITCODE_BS header_vert_left_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_left_linewt", &header_vert_left_linewt, NULL)
        && header_vert_left_linewt == table->header_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_left_linewt [BS] %hu != %hu", table->header_vert_left_linewt, header_vert_left_linewt);
    header_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_left_linewt", &header_vert_left_linewt, 0)
        && header_vert_left_linewt == table->header_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_left_linewt [BS] set+1 %hu != %hu", table->header_vert_left_linewt, header_vert_left_linewt);
    table->header_vert_left_linewt--;
  }
  {
    BITCODE_BS header_vert_left_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_left_visibility", &header_vert_left_visibility, NULL)
        && header_vert_left_visibility == table->header_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_left_visibility [BS] %hu != %hu", table->header_vert_left_visibility, header_vert_left_visibility);
    header_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_left_visibility", &header_vert_left_visibility, 0)
        && header_vert_left_visibility == table->header_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_left_visibility [BS] set+1 %hu != %hu", table->header_vert_left_visibility, header_vert_left_visibility);
    table->header_vert_left_visibility--;
  }
  {
    BITCODE_CMC header_vert_right_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_right_color", &header_vert_right_color, NULL)
        && !memcmp (&header_vert_right_color, &table->header_vert_right_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.header_vert_right_color [CMC]");
  }
  {
    BITCODE_BS header_vert_right_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_right_linewt", &header_vert_right_linewt, NULL)
        && header_vert_right_linewt == table->header_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_right_linewt [BS] %hu != %hu", table->header_vert_right_linewt, header_vert_right_linewt);
    header_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_right_linewt", &header_vert_right_linewt, 0)
        && header_vert_right_linewt == table->header_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.header_vert_right_linewt [BS] set+1 %hu != %hu", table->header_vert_right_linewt, header_vert_right_linewt);
    table->header_vert_right_linewt--;
  }
  {
    BITCODE_BS header_vert_right_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "header_vert_right_visibility", &header_vert_right_visibility, NULL)
        && header_vert_right_visibility == table->header_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_right_visibility [BS] %hu != %hu", table->header_vert_right_visibility, header_vert_right_visibility);
    header_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "header_vert_right_visibility", &header_vert_right_visibility, 0)
        && header_vert_right_visibility == table->header_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.header_vert_right_visibility [BS] set+1 %hu != %hu", table->header_vert_right_visibility, header_vert_right_visibility);
    table->header_vert_right_visibility--;
  }
  {
    BITCODE_3BD hor_dir;
    if (dwg_dynapi_entity_value (table, "TABLE", "hor_dir", &hor_dir, NULL)
        && !memcmp (&hor_dir, &table->hor_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("TABLE.hor_dir [3BD]");
  }
  {
    BITCODE_BD horiz_cell_margin;
    if (dwg_dynapi_entity_value (table, "TABLE", "horiz_cell_margin", &horiz_cell_margin, NULL)
        && horiz_cell_margin == table->horiz_cell_margin)
      pass ();
    else
      fail ("TABLE.horiz_cell_margin [BD] %g != %g", table->horiz_cell_margin, horiz_cell_margin);
    horiz_cell_margin++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "horiz_cell_margin", &horiz_cell_margin, 0)
        && horiz_cell_margin == table->horiz_cell_margin)
      pass ();
    else
      fail ("TABLE.horiz_cell_margin [BD] set+1 %g != %g", table->horiz_cell_margin, horiz_cell_margin);
    table->horiz_cell_margin--;
  }
  {
    BITCODE_3BD horiz_direction;
    if (dwg_dynapi_entity_value (table, "TABLE", "horiz_direction", &horiz_direction, NULL)
        && !memcmp (&horiz_direction, &table->horiz_direction, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("TABLE.horiz_direction [3BD]");
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value (table, "TABLE", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &table->ins_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("TABLE.ins_pt [3BD]");
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value (table, "TABLE", "last_attrib", &last_attrib, NULL)
        && !memcmp (&last_attrib, &table->last_attrib, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.last_attrib [H]");
  }
  {
    Dwg_LinkedData ldata;
    if (dwg_dynapi_entity_value (table, "TABLE", "ldata", &ldata, NULL)
        && !memcmp (&ldata, &table->ldata, sizeof (Dwg_LinkedData)))
        pass ();
    else
        fail ("TABLE.ldata [Dwg_LinkedData]");
  }
  {
    BITCODE_BL num_break_heights;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_break_heights", &num_break_heights, NULL)
        && num_break_heights == table->num_break_heights)
      pass ();
    else
      fail ("TABLE.num_break_heights [BL] %u != %u", table->num_break_heights, num_break_heights);
    num_break_heights++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_break_heights", &num_break_heights, 0)
        && num_break_heights == table->num_break_heights)
      pass ();
    else
      fail ("TABLE.num_break_heights [BL] set+1 %u != %u", table->num_break_heights, num_break_heights);
    table->num_break_heights--;
  }
  {
    BITCODE_BL num_break_rows;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_break_rows", &num_break_rows, NULL)
        && num_break_rows == table->num_break_rows)
      pass ();
    else
      fail ("TABLE.num_break_rows [BL] %u != %u", table->num_break_rows, num_break_rows);
    num_break_rows++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_break_rows", &num_break_rows, 0)
        && num_break_rows == table->num_break_rows)
      pass ();
    else
      fail ("TABLE.num_break_rows [BL] set+1 %u != %u", table->num_break_rows, num_break_rows);
    table->num_break_rows--;
  }
  {
    unsigned long num_cells;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_cells", &num_cells, NULL)
        && num_cells == table->num_cells)
      pass ();
    else
      fail ("TABLE.num_cells [unsigned long] %lu != %lu", table->num_cells, num_cells);
    num_cells++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_cells", &num_cells, 0)
        && num_cells == table->num_cells)
      pass ();
    else
      fail ("TABLE.num_cells [unsigned long] set+1 %lu != %lu", table->num_cells, num_cells);
    table->num_cells--;
  }
  {
    BITCODE_BL num_cols;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_cols", &num_cols, NULL)
        && num_cols == table->num_cols)
      pass ();
    else
      fail ("TABLE.num_cols [BL] %u != %u", table->num_cols, num_cols);
    num_cols++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_cols", &num_cols, 0)
        && num_cols == table->num_cols)
      pass ();
    else
      fail ("TABLE.num_cols [BL] set+1 %u != %u", table->num_cols, num_cols);
    table->num_cols--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_owned", &num_owned, NULL)
        && num_owned == table->num_owned)
      pass ();
    else
      fail ("TABLE.num_owned [BL] %u != %u", table->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_owned", &num_owned, 0)
        && num_owned == table->num_owned)
      pass ();
    else
      fail ("TABLE.num_owned [BL] set+1 %u != %u", table->num_owned, num_owned);
    table->num_owned--;
  }
  {
    BITCODE_BL num_rows;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_rows", &num_rows, NULL)
        && num_rows == table->num_rows)
      pass ();
    else
      fail ("TABLE.num_rows [BL] %u != %u", table->num_rows, num_rows);
    num_rows++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "num_rows", &num_rows, 0)
        && num_rows == table->num_rows)
      pass ();
    else
      fail ("TABLE.num_rows [BL] set+1 %u != %u", table->num_rows, num_rows);
    table->num_rows--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (table, "TABLE", "parent", &parent, NULL)
        && !memcmp (&parent, &table->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("TABLE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (table, "TABLE", "rotation", &rotation, NULL)
        && rotation == table->rotation)
      pass ();
    else
      fail ("TABLE.rotation [BD] %g != %g", table->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "rotation", &rotation, 0)
        && rotation == table->rotation)
      pass ();
    else
      fail ("TABLE.rotation [BD] set+1 %g != %g", table->rotation, rotation);
    table->rotation--;
  }
  {
    BITCODE_BD* row_heights;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (table, "TABLE", "num_row_heights", &count, NULL)
        && dwg_dynapi_entity_value (table, "TABLE", "row_heights", &row_heights, NULL)
        && row_heights == table->row_heights)
      pass ();
    else
      fail ("TABLE.row_heights [BD*] * %u num_row_heights", count);
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value (table, "TABLE", "scale", &scale, NULL)
        && !memcmp (&scale, &table->scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("TABLE.scale [3BD_1]");
  }
  {
    BITCODE_BB scale_flag;
    if (dwg_dynapi_entity_value (table, "TABLE", "scale_flag", &scale_flag, NULL)
        && scale_flag == table->scale_flag)
      pass ();
    else
      fail ("TABLE.scale_flag [BB] " FORMAT_BB " != " FORMAT_BB "", table->scale_flag, scale_flag);
    scale_flag++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "scale_flag", &scale_flag, 0)
        && scale_flag == table->scale_flag)
      pass ();
    else
      fail ("TABLE.scale_flag [BB] set+1 " FORMAT_BB " != " FORMAT_BB "", table->scale_flag, scale_flag);
    table->scale_flag--;
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value (table, "TABLE", "seqend", &seqend, NULL)
        && !memcmp (&seqend, &table->seqend, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.seqend [H]");
  }
  {
    BITCODE_BL table_flag_override;
    if (dwg_dynapi_entity_value (table, "TABLE", "table_flag_override", &table_flag_override, NULL)
        && table_flag_override == table->table_flag_override)
      pass ();
    else
      fail ("TABLE.table_flag_override [BL] %u != %u", table->table_flag_override, table_flag_override);
    table_flag_override++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "table_flag_override", &table_flag_override, 0)
        && table_flag_override == table->table_flag_override)
      pass ();
    else
      fail ("TABLE.table_flag_override [BL] set+1 %u != %u", table->table_flag_override, table_flag_override);
    table->table_flag_override--;
  }
  {
    BITCODE_H tablestyle;
    if (dwg_dynapi_entity_value (table, "TABLE", "tablestyle", &tablestyle, NULL)
        && !memcmp (&tablestyle, &table->tablestyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.tablestyle [H]");
  }
  {
    Dwg_LinkedTableData tdata;
    if (dwg_dynapi_entity_value (table, "TABLE", "tdata", &tdata, NULL)
        && !memcmp (&tdata, &table->tdata, sizeof (Dwg_LinkedTableData)))
        pass ();
    else
        fail ("TABLE.tdata [Dwg_LinkedTableData]");
  }
  {
    BITCODE_CMC title_horiz_bottom_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_bottom_color", &title_horiz_bottom_color, NULL)
        && !memcmp (&title_horiz_bottom_color, &table->title_horiz_bottom_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.title_horiz_bottom_color [CMC]");
  }
  {
    BITCODE_BS title_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_bottom_linewt", &title_horiz_bottom_linewt, NULL)
        && title_horiz_bottom_linewt == table->title_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_bottom_linewt [BS] %hu != %hu", table->title_horiz_bottom_linewt, title_horiz_bottom_linewt);
    title_horiz_bottom_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_bottom_linewt", &title_horiz_bottom_linewt, 0)
        && title_horiz_bottom_linewt == table->title_horiz_bottom_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_bottom_linewt [BS] set+1 %hu != %hu", table->title_horiz_bottom_linewt, title_horiz_bottom_linewt);
    table->title_horiz_bottom_linewt--;
  }
  {
    BITCODE_BS title_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_bottom_visibility", &title_horiz_bottom_visibility, NULL)
        && title_horiz_bottom_visibility == table->title_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_bottom_visibility [BS] %hu != %hu", table->title_horiz_bottom_visibility, title_horiz_bottom_visibility);
    title_horiz_bottom_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_bottom_visibility", &title_horiz_bottom_visibility, 0)
        && title_horiz_bottom_visibility == table->title_horiz_bottom_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_bottom_visibility [BS] set+1 %hu != %hu", table->title_horiz_bottom_visibility, title_horiz_bottom_visibility);
    table->title_horiz_bottom_visibility--;
  }
  {
    BITCODE_CMC title_horiz_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_ins_color", &title_horiz_ins_color, NULL)
        && !memcmp (&title_horiz_ins_color, &table->title_horiz_ins_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.title_horiz_ins_color [CMC]");
  }
  {
    BITCODE_BS title_horiz_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_ins_linewt", &title_horiz_ins_linewt, NULL)
        && title_horiz_ins_linewt == table->title_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_ins_linewt [BS] %hu != %hu", table->title_horiz_ins_linewt, title_horiz_ins_linewt);
    title_horiz_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_ins_linewt", &title_horiz_ins_linewt, 0)
        && title_horiz_ins_linewt == table->title_horiz_ins_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_ins_linewt [BS] set+1 %hu != %hu", table->title_horiz_ins_linewt, title_horiz_ins_linewt);
    table->title_horiz_ins_linewt--;
  }
  {
    BITCODE_BS title_horiz_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_ins_visibility", &title_horiz_ins_visibility, NULL)
        && title_horiz_ins_visibility == table->title_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_ins_visibility [BS] %hu != %hu", table->title_horiz_ins_visibility, title_horiz_ins_visibility);
    title_horiz_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_ins_visibility", &title_horiz_ins_visibility, 0)
        && title_horiz_ins_visibility == table->title_horiz_ins_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_ins_visibility [BS] set+1 %hu != %hu", table->title_horiz_ins_visibility, title_horiz_ins_visibility);
    table->title_horiz_ins_visibility--;
  }
  {
    BITCODE_CMC title_horiz_top_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_top_color", &title_horiz_top_color, NULL)
        && !memcmp (&title_horiz_top_color, &table->title_horiz_top_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.title_horiz_top_color [CMC]");
  }
  {
    BITCODE_BS title_horiz_top_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_top_linewt", &title_horiz_top_linewt, NULL)
        && title_horiz_top_linewt == table->title_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_top_linewt [BS] %hu != %hu", table->title_horiz_top_linewt, title_horiz_top_linewt);
    title_horiz_top_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_top_linewt", &title_horiz_top_linewt, 0)
        && title_horiz_top_linewt == table->title_horiz_top_linewt)
      pass ();
    else
      fail ("TABLE.title_horiz_top_linewt [BS] set+1 %hu != %hu", table->title_horiz_top_linewt, title_horiz_top_linewt);
    table->title_horiz_top_linewt--;
  }
  {
    BITCODE_BS title_horiz_top_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_horiz_top_visibility", &title_horiz_top_visibility, NULL)
        && title_horiz_top_visibility == table->title_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_top_visibility [BS] %hu != %hu", table->title_horiz_top_visibility, title_horiz_top_visibility);
    title_horiz_top_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_horiz_top_visibility", &title_horiz_top_visibility, 0)
        && title_horiz_top_visibility == table->title_horiz_top_visibility)
      pass ();
    else
      fail ("TABLE.title_horiz_top_visibility [BS] set+1 %hu != %hu", table->title_horiz_top_visibility, title_horiz_top_visibility);
    table->title_horiz_top_visibility--;
  }
  {
    BITCODE_BS title_row_alignment;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_alignment", &title_row_alignment, NULL)
        && title_row_alignment == table->title_row_alignment)
      pass ();
    else
      fail ("TABLE.title_row_alignment [BS] %hu != %hu", table->title_row_alignment, title_row_alignment);
    title_row_alignment++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_row_alignment", &title_row_alignment, 0)
        && title_row_alignment == table->title_row_alignment)
      pass ();
    else
      fail ("TABLE.title_row_alignment [BS] set+1 %hu != %hu", table->title_row_alignment, title_row_alignment);
    table->title_row_alignment--;
  }
  {
    BITCODE_CMC title_row_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_color", &title_row_color, NULL)
        && !memcmp (&title_row_color, &table->title_row_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.title_row_color [CMC]");
  }
  {
    BITCODE_CMC title_row_fill_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_fill_color", &title_row_fill_color, NULL)
        && !memcmp (&title_row_fill_color, &table->title_row_fill_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.title_row_fill_color [CMC]");
  }
  {
    BITCODE_B title_row_fill_none;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_fill_none", &title_row_fill_none, NULL)
        && title_row_fill_none == table->title_row_fill_none)
      pass ();
    else
      fail ("TABLE.title_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->title_row_fill_none, title_row_fill_none);
    title_row_fill_none++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_row_fill_none", &title_row_fill_none, 0)
        && title_row_fill_none == table->title_row_fill_none)
      pass ();
    else
      fail ("TABLE.title_row_fill_none [B] set+1 " FORMAT_B " != " FORMAT_B "", table->title_row_fill_none, title_row_fill_none);
    table->title_row_fill_none--;
  }
  {
    BITCODE_BD title_row_height;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_height", &title_row_height, NULL)
        && title_row_height == table->title_row_height)
      pass ();
    else
      fail ("TABLE.title_row_height [BD] %g != %g", table->title_row_height, title_row_height);
    title_row_height++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_row_height", &title_row_height, 0)
        && title_row_height == table->title_row_height)
      pass ();
    else
      fail ("TABLE.title_row_height [BD] set+1 %g != %g", table->title_row_height, title_row_height);
    table->title_row_height--;
  }
  {
    BITCODE_H title_row_style_override;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_row_style_override", &title_row_style_override, NULL)
        && !memcmp (&title_row_style_override, &table->title_row_style_override, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.title_row_style_override [H]");
  }
  {
    BITCODE_B title_suppressed;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_suppressed", &title_suppressed, NULL)
        && title_suppressed == table->title_suppressed)
      pass ();
    else
      fail ("TABLE.title_suppressed [B] " FORMAT_B " != " FORMAT_B "", table->title_suppressed, title_suppressed);
    title_suppressed++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_suppressed", &title_suppressed, 0)
        && title_suppressed == table->title_suppressed)
      pass ();
    else
      fail ("TABLE.title_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", table->title_suppressed, title_suppressed);
    table->title_suppressed--;
  }
  {
    BITCODE_H title_text_style;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_text_style", &title_text_style, NULL)
        && !memcmp (&title_text_style, &table->title_text_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.title_text_style [H]");
  }
  {
    BITCODE_CMC title_vert_ins_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_ins_color", &title_vert_ins_color, NULL)
        && !memcmp (&title_vert_ins_color, &table->title_vert_ins_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.title_vert_ins_color [CMC]");
  }
  {
    BITCODE_BS title_vert_ins_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_ins_linewt", &title_vert_ins_linewt, NULL)
        && title_vert_ins_linewt == table->title_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_ins_linewt [BS] %hu != %hu", table->title_vert_ins_linewt, title_vert_ins_linewt);
    title_vert_ins_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_ins_linewt", &title_vert_ins_linewt, 0)
        && title_vert_ins_linewt == table->title_vert_ins_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_ins_linewt [BS] set+1 %hu != %hu", table->title_vert_ins_linewt, title_vert_ins_linewt);
    table->title_vert_ins_linewt--;
  }
  {
    BITCODE_BS title_vert_ins_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_ins_visibility", &title_vert_ins_visibility, NULL)
        && title_vert_ins_visibility == table->title_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_ins_visibility [BS] %hu != %hu", table->title_vert_ins_visibility, title_vert_ins_visibility);
    title_vert_ins_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_ins_visibility", &title_vert_ins_visibility, 0)
        && title_vert_ins_visibility == table->title_vert_ins_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_ins_visibility [BS] set+1 %hu != %hu", table->title_vert_ins_visibility, title_vert_ins_visibility);
    table->title_vert_ins_visibility--;
  }
  {
    BITCODE_CMC title_vert_left_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_left_color", &title_vert_left_color, NULL)
        && !memcmp (&title_vert_left_color, &table->title_vert_left_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.title_vert_left_color [CMC]");
  }
  {
    BITCODE_BS title_vert_left_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_left_linewt", &title_vert_left_linewt, NULL)
        && title_vert_left_linewt == table->title_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_left_linewt [BS] %hu != %hu", table->title_vert_left_linewt, title_vert_left_linewt);
    title_vert_left_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_left_linewt", &title_vert_left_linewt, 0)
        && title_vert_left_linewt == table->title_vert_left_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_left_linewt [BS] set+1 %hu != %hu", table->title_vert_left_linewt, title_vert_left_linewt);
    table->title_vert_left_linewt--;
  }
  {
    BITCODE_BS title_vert_left_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_left_visibility", &title_vert_left_visibility, NULL)
        && title_vert_left_visibility == table->title_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_left_visibility [BS] %hu != %hu", table->title_vert_left_visibility, title_vert_left_visibility);
    title_vert_left_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_left_visibility", &title_vert_left_visibility, 0)
        && title_vert_left_visibility == table->title_vert_left_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_left_visibility [BS] set+1 %hu != %hu", table->title_vert_left_visibility, title_vert_left_visibility);
    table->title_vert_left_visibility--;
  }
  {
    BITCODE_CMC title_vert_right_color;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_right_color", &title_vert_right_color, NULL)
        && !memcmp (&title_vert_right_color, &table->title_vert_right_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("TABLE.title_vert_right_color [CMC]");
  }
  {
    BITCODE_BS title_vert_right_linewt;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_right_linewt", &title_vert_right_linewt, NULL)
        && title_vert_right_linewt == table->title_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_right_linewt [BS] %hu != %hu", table->title_vert_right_linewt, title_vert_right_linewt);
    title_vert_right_linewt++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_right_linewt", &title_vert_right_linewt, 0)
        && title_vert_right_linewt == table->title_vert_right_linewt)
      pass ();
    else
      fail ("TABLE.title_vert_right_linewt [BS] set+1 %hu != %hu", table->title_vert_right_linewt, title_vert_right_linewt);
    table->title_vert_right_linewt--;
  }
  {
    BITCODE_BS title_vert_right_visibility;
    if (dwg_dynapi_entity_value (table, "TABLE", "title_vert_right_visibility", &title_vert_right_visibility, NULL)
        && title_vert_right_visibility == table->title_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_right_visibility [BS] %hu != %hu", table->title_vert_right_visibility, title_vert_right_visibility);
    title_vert_right_visibility++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "title_vert_right_visibility", &title_vert_right_visibility, 0)
        && title_vert_right_visibility == table->title_vert_right_visibility)
      pass ();
    else
      fail ("TABLE.title_vert_right_visibility [BS] set+1 %hu != %hu", table->title_vert_right_visibility, title_vert_right_visibility);
    table->title_vert_right_visibility--;
  }
  {
    BITCODE_B unknown_b;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_b", &unknown_b, NULL)
        && unknown_b == table->unknown_b)
      pass ();
    else
      fail ("TABLE.unknown_b [B] " FORMAT_B " != " FORMAT_B "", table->unknown_b, unknown_b);
    unknown_b++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_b", &unknown_b, 0)
        && unknown_b == table->unknown_b)
      pass ();
    else
      fail ("TABLE.unknown_b [B] set+1 " FORMAT_B " != " FORMAT_B "", table->unknown_b, unknown_b);
    table->unknown_b--;
  }
  {
    BITCODE_BL unknown_bl;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_bl", &unknown_bl, NULL)
        && unknown_bl == table->unknown_bl)
      pass ();
    else
      fail ("TABLE.unknown_bl [BL] %u != %u", table->unknown_bl, unknown_bl);
    unknown_bl++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_bl", &unknown_bl, 0)
        && unknown_bl == table->unknown_bl)
      pass ();
    else
      fail ("TABLE.unknown_bl [BL] set+1 %u != %u", table->unknown_bl, unknown_bl);
    table->unknown_bl--;
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_bl1", &unknown_bl1, NULL)
        && unknown_bl1 == table->unknown_bl1)
      pass ();
    else
      fail ("TABLE.unknown_bl1 [BL] %u != %u", table->unknown_bl1, unknown_bl1);
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_bl1", &unknown_bl1, 0)
        && unknown_bl1 == table->unknown_bl1)
      pass ();
    else
      fail ("TABLE.unknown_bl1 [BL] set+1 %u != %u", table->unknown_bl1, unknown_bl1);
    table->unknown_bl1--;
  }
  {
    BITCODE_BS unknown_bs;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_bs", &unknown_bs, NULL)
        && unknown_bs == table->unknown_bs)
      pass ();
    else
      fail ("TABLE.unknown_bs [BS] %hu != %hu", table->unknown_bs, unknown_bs);
    unknown_bs++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_bs", &unknown_bs, 0)
        && unknown_bs == table->unknown_bs)
      pass ();
    else
      fail ("TABLE.unknown_bs [BS] set+1 %hu != %hu", table->unknown_bs, unknown_bs);
    table->unknown_bs--;
  }
  {
    BITCODE_H unknown_h;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_h", &unknown_h, NULL)
        && !memcmp (&unknown_h, &table->unknown_h, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLE.unknown_h [H]");
  }
  {
    BITCODE_RC unknown_rc;
    if (dwg_dynapi_entity_value (table, "TABLE", "unknown_rc", &unknown_rc, NULL)
        && unknown_rc == table->unknown_rc)
      pass ();
    else
      fail ("TABLE.unknown_rc [RC] %u != %u", table->unknown_rc, unknown_rc);
    unknown_rc++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "unknown_rc", &unknown_rc, 0)
        && unknown_rc == table->unknown_rc)
      pass ();
    else
      fail ("TABLE.unknown_rc [RC] set+1 %u != %u", table->unknown_rc, unknown_rc);
    table->unknown_rc--;
  }
  {
    BITCODE_BD vert_cell_margin;
    if (dwg_dynapi_entity_value (table, "TABLE", "vert_cell_margin", &vert_cell_margin, NULL)
        && vert_cell_margin == table->vert_cell_margin)
      pass ();
    else
      fail ("TABLE.vert_cell_margin [BD] %g != %g", table->vert_cell_margin, vert_cell_margin);
    vert_cell_margin++;
    if (dwg_dynapi_entity_set_value (table, "TABLE", "vert_cell_margin", &vert_cell_margin, 0)
        && vert_cell_margin == table->vert_cell_margin)
      pass ();
    else
      fail ("TABLE.vert_cell_margin [BD] set+1 %g != %g", table->vert_cell_margin, vert_cell_margin);
    table->vert_cell_margin--;
  }
  if (failed && (is_class_unstable ("TABLE") || is_class_debugging ("TABLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TABLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_TEXT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_TEXT *restrict text = obj->tio.entity->tio.TEXT;
  failed = 0;
  if (!obj_obj || !text)
    {
      fail ("NULL TEXT");
      return 1;
    }
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value (text, "TEXT", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &text->alignment_pt, sizeof (BITCODE_2DPOINT)))
        pass ();
    else
        fail ("TEXT.alignment_pt [2DPOINT]");
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value (text, "TEXT", "dataflags", &dataflags, NULL)
        && dataflags == text->dataflags)
      pass ();
    else
      fail ("TEXT.dataflags [RC] %u != %u", text->dataflags, dataflags);
    dataflags++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "dataflags", &dataflags, 0)
        && dataflags == text->dataflags)
      pass ();
    else
      fail ("TEXT.dataflags [RC] set+1 %u != %u", text->dataflags, dataflags);
    text->dataflags--;
  }
  {
    BITCODE_RD elevation;
    if (dwg_dynapi_entity_value (text, "TEXT", "elevation", &elevation, NULL)
        && elevation == text->elevation)
      pass ();
    else
      fail ("TEXT.elevation [RD] %g != %g", text->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "elevation", &elevation, 0)
        && elevation == text->elevation)
      pass ();
    else
      fail ("TEXT.elevation [RD] set+1 %g != %g", text->elevation, elevation);
    text->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (text, "TEXT", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &text->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("TEXT.extrusion [BE]");
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value (text, "TEXT", "generation", &generation, NULL)
        && generation == text->generation)
      pass ();
    else
      fail ("TEXT.generation [BS] %hu != %hu", text->generation, generation);
    generation++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "generation", &generation, 0)
        && generation == text->generation)
      pass ();
    else
      fail ("TEXT.generation [BS] set+1 %hu != %hu", text->generation, generation);
    text->generation--;
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value (text, "TEXT", "height", &height, NULL)
        && height == text->height)
      pass ();
    else
      fail ("TEXT.height [RD] %g != %g", text->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "height", &height, 0)
        && height == text->height)
      pass ();
    else
      fail ("TEXT.height [RD] set+1 %g != %g", text->height, height);
    text->height--;
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value (text, "TEXT", "horiz_alignment", &horiz_alignment, NULL)
        && horiz_alignment == text->horiz_alignment)
      pass ();
    else
      fail ("TEXT.horiz_alignment [BS] %hu != %hu", text->horiz_alignment, horiz_alignment);
    horiz_alignment++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "horiz_alignment", &horiz_alignment, 0)
        && horiz_alignment == text->horiz_alignment)
      pass ();
    else
      fail ("TEXT.horiz_alignment [BS] set+1 %hu != %hu", text->horiz_alignment, horiz_alignment);
    text->horiz_alignment--;
  }
  {
    BITCODE_2DPOINT ins_pt;
    if (dwg_dynapi_entity_value (text, "TEXT", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &text->ins_pt, sizeof (BITCODE_2DPOINT)))
        pass ();
    else
        fail ("TEXT.ins_pt [2DPOINT]");
  }
  {
    BITCODE_RD oblique_angle;
    if (dwg_dynapi_entity_value (text, "TEXT", "oblique_angle", &oblique_angle, NULL)
        && oblique_angle == text->oblique_angle)
      pass ();
    else
      fail ("TEXT.oblique_angle [RD] %g != %g", text->oblique_angle, oblique_angle);
    oblique_angle++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "oblique_angle", &oblique_angle, 0)
        && oblique_angle == text->oblique_angle)
      pass ();
    else
      fail ("TEXT.oblique_angle [RD] set+1 %g != %g", text->oblique_angle, oblique_angle);
    text->oblique_angle--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (text, "TEXT", "parent", &parent, NULL)
        && !memcmp (&parent, &text->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("TEXT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value (text, "TEXT", "rotation", &rotation, NULL)
        && rotation == text->rotation)
      pass ();
    else
      fail ("TEXT.rotation [RD] %g != %g", text->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "rotation", &rotation, 0)
        && rotation == text->rotation)
      pass ();
    else
      fail ("TEXT.rotation [RD] set+1 %g != %g", text->rotation, rotation);
    text->rotation--;
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value (text, "TEXT", "style", &style, NULL)
        && !memcmp (&style, &text->style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TEXT.style [H]");
  }
  {
    BITCODE_T text_value;
    if (dwg_dynapi_entity_value (text, "TEXT", "text_value", &text_value, NULL)
        && text_value
           ? strEQ ((char *)text_value, (char *)text->text_value)
           : !text->text_value)
      pass ();
    else
      fail ("TEXT.text_value [T] '%s' <> '%s'", text_value, text->text_value);
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value (text, "TEXT", "thickness", &thickness, NULL)
        && thickness == text->thickness)
      pass ();
    else
      fail ("TEXT.thickness [RD] %g != %g", text->thickness, thickness);
    thickness++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "thickness", &thickness, 0)
        && thickness == text->thickness)
      pass ();
    else
      fail ("TEXT.thickness [RD] set+1 %g != %g", text->thickness, thickness);
    text->thickness--;
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value (text, "TEXT", "vert_alignment", &vert_alignment, NULL)
        && vert_alignment == text->vert_alignment)
      pass ();
    else
      fail ("TEXT.vert_alignment [BS] %hu != %hu", text->vert_alignment, vert_alignment);
    vert_alignment++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "vert_alignment", &vert_alignment, 0)
        && vert_alignment == text->vert_alignment)
      pass ();
    else
      fail ("TEXT.vert_alignment [BS] set+1 %hu != %hu", text->vert_alignment, vert_alignment);
    text->vert_alignment--;
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value (text, "TEXT", "width_factor", &width_factor, NULL)
        && width_factor == text->width_factor)
      pass ();
    else
      fail ("TEXT.width_factor [RD] %g != %g", text->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (text, "TEXT", "width_factor", &width_factor, 0)
        && width_factor == text->width_factor)
      pass ();
    else
      fail ("TEXT.width_factor [RD] set+1 %g != %g", text->width_factor, width_factor);
    text->width_factor--;
  }
  if (failed && (is_class_unstable ("TEXT") || is_class_debugging ("TEXT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TEXT", failed);
      failed = 0;
    }
  return failed;
}
static int test_TOLERANCE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_TOLERANCE *restrict tolerance = obj->tio.entity->tio.TOLERANCE;
  failed = 0;
  if (!obj_obj || !tolerance)
    {
      fail ("NULL TOLERANCE");
      return 1;
    }
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "dimgap", &dimgap, NULL)
        && dimgap == tolerance->dimgap)
      pass ();
    else
      fail ("TOLERANCE.dimgap [BD] %g != %g", tolerance->dimgap, dimgap);
    dimgap++;
    if (dwg_dynapi_entity_set_value (tolerance, "TOLERANCE", "dimgap", &dimgap, 0)
        && dimgap == tolerance->dimgap)
      pass ();
    else
      fail ("TOLERANCE.dimgap [BD] set+1 %g != %g", tolerance->dimgap, dimgap);
    tolerance->dimgap--;
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "dimstyle", &dimstyle, NULL)
        && !memcmp (&dimstyle, &tolerance->dimstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TOLERANCE.dimstyle [H]");
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &tolerance->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("TOLERANCE.extrusion [BE]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "height", &height, NULL)
        && height == tolerance->height)
      pass ();
    else
      fail ("TOLERANCE.height [BD] %g != %g", tolerance->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (tolerance, "TOLERANCE", "height", &height, 0)
        && height == tolerance->height)
      pass ();
    else
      fail ("TOLERANCE.height [BD] set+1 %g != %g", tolerance->height, height);
    tolerance->height--;
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &tolerance->ins_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("TOLERANCE.ins_pt [3BD]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "parent", &parent, NULL)
        && !memcmp (&parent, &tolerance->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("TOLERANCE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_T text_value;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "text_value", &text_value, NULL)
        && text_value
           ? strEQ ((char *)text_value, (char *)tolerance->text_value)
           : !tolerance->text_value)
      pass ();
    else
      fail ("TOLERANCE.text_value [T] '%s' <> '%s'", text_value, tolerance->text_value);
  }
  {
    BITCODE_BS unknown_short;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "unknown_short", &unknown_short, NULL)
        && unknown_short == tolerance->unknown_short)
      pass ();
    else
      fail ("TOLERANCE.unknown_short [BS] %hu != %hu", tolerance->unknown_short, unknown_short);
    unknown_short++;
    if (dwg_dynapi_entity_set_value (tolerance, "TOLERANCE", "unknown_short", &unknown_short, 0)
        && unknown_short == tolerance->unknown_short)
      pass ();
    else
      fail ("TOLERANCE.unknown_short [BS] set+1 %hu != %hu", tolerance->unknown_short, unknown_short);
    tolerance->unknown_short--;
  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value (tolerance, "TOLERANCE", "x_direction", &x_direction, NULL)
        && !memcmp (&x_direction, &tolerance->x_direction, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("TOLERANCE.x_direction [3BD]");
  }
  if (failed && (is_class_unstable ("TOLERANCE") || is_class_debugging ("TOLERANCE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TOLERANCE", failed);
      failed = 0;
    }
  return failed;
}
static int test_TRACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_TRACE *restrict trace = obj->tio.entity->tio.TRACE;
  failed = 0;
  if (!obj_obj || !trace)
    {
      fail ("NULL TRACE");
      return 1;
    }
  {
    BITCODE_2RD corner1;
    if (dwg_dynapi_entity_value (trace, "TRACE", "corner1", &corner1, NULL)
        && !memcmp (&corner1, &trace->corner1, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("TRACE.corner1 [2RD]");
  }
  {
    BITCODE_2RD corner2;
    if (dwg_dynapi_entity_value (trace, "TRACE", "corner2", &corner2, NULL)
        && !memcmp (&corner2, &trace->corner2, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("TRACE.corner2 [2RD]");
  }
  {
    BITCODE_2RD corner3;
    if (dwg_dynapi_entity_value (trace, "TRACE", "corner3", &corner3, NULL)
        && !memcmp (&corner3, &trace->corner3, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("TRACE.corner3 [2RD]");
  }
  {
    BITCODE_2RD corner4;
    if (dwg_dynapi_entity_value (trace, "TRACE", "corner4", &corner4, NULL)
        && !memcmp (&corner4, &trace->corner4, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("TRACE.corner4 [2RD]");
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value (trace, "TRACE", "elevation", &elevation, NULL)
        && elevation == trace->elevation)
      pass ();
    else
      fail ("TRACE.elevation [BD] %g != %g", trace->elevation, elevation);
    elevation++;
    if (dwg_dynapi_entity_set_value (trace, "TRACE", "elevation", &elevation, 0)
        && elevation == trace->elevation)
      pass ();
    else
      fail ("TRACE.elevation [BD] set+1 %g != %g", trace->elevation, elevation);
    trace->elevation--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (trace, "TRACE", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &trace->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("TRACE.extrusion [BE]");
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (trace, "TRACE", "parent", &parent, NULL)
        && !memcmp (&parent, &trace->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("TRACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value (trace, "TRACE", "thickness", &thickness, NULL)
        && thickness == trace->thickness)
      pass ();
    else
      fail ("TRACE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", trace->thickness, thickness);
    if (dwg_dynapi_entity_set_value (trace, "TRACE", "thickness", &thickness, 0)
        && thickness == trace->thickness)
      pass ();
    else
      fail ("TRACE.thickness [BT] set+1 " FORMAT_BT " != " FORMAT_BT "", trace->thickness, thickness);
    trace->thickness--;
  }
  if (failed && (is_class_unstable ("TRACE") || is_class_debugging ("TRACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TRACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_2D (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_2D *restrict vertex_2d = obj->tio.entity->tio.VERTEX_2D;
  failed = 0;
  if (!obj_obj || !vertex_2d)
    {
      fail ("NULL VERTEX_2D");
      return 1;
    }
  {
    BITCODE_BD bulge;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "bulge", &bulge, NULL)
        && bulge == vertex_2d->bulge)
      pass ();
    else
      fail ("VERTEX_2D.bulge [BD] %g != %g", vertex_2d->bulge, bulge);
    bulge++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "bulge", &bulge, 0)
        && bulge == vertex_2d->bulge)
      pass ();
    else
      fail ("VERTEX_2D.bulge [BD] set+1 %g != %g", vertex_2d->bulge, bulge);
    vertex_2d->bulge--;
  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "end_width", &end_width, NULL)
        && end_width == vertex_2d->end_width)
      pass ();
    else
      fail ("VERTEX_2D.end_width [BD] %g != %g", vertex_2d->end_width, end_width);
    end_width++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "end_width", &end_width, 0)
        && end_width == vertex_2d->end_width)
      pass ();
    else
      fail ("VERTEX_2D.end_width [BD] set+1 %g != %g", vertex_2d->end_width, end_width);
    vertex_2d->end_width--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "flag", &flag, NULL)
        && flag == vertex_2d->flag)
      pass ();
    else
      fail ("VERTEX_2D.flag [RC] %u != %u", vertex_2d->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "flag", &flag, 0)
        && flag == vertex_2d->flag)
      pass ();
    else
      fail ("VERTEX_2D.flag [RC] set+1 %u != %u", vertex_2d->flag, flag);
    vertex_2d->flag--;
  }
  {
    BITCODE_BL id;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "id", &id, NULL)
        && id == vertex_2d->id)
      pass ();
    else
      fail ("VERTEX_2D.id [BL] %u != %u", vertex_2d->id, id);
    id++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "id", &id, 0)
        && id == vertex_2d->id)
      pass ();
    else
      fail ("VERTEX_2D.id [BL] set+1 %u != %u", vertex_2d->id, id);
    vertex_2d->id--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "parent", &parent, NULL)
        && !memcmp (&parent, &vertex_2d->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("VERTEX_2D.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "point", &point, NULL)
        && !memcmp (&point, &vertex_2d->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VERTEX_2D.point [3BD]");
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "start_width", &start_width, NULL)
        && start_width == vertex_2d->start_width)
      pass ();
    else
      fail ("VERTEX_2D.start_width [BD] %g != %g", vertex_2d->start_width, start_width);
    start_width++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "start_width", &start_width, 0)
        && start_width == vertex_2d->start_width)
      pass ();
    else
      fail ("VERTEX_2D.start_width [BD] set+1 %g != %g", vertex_2d->start_width, start_width);
    vertex_2d->start_width--;
  }
  {
    BITCODE_BD tangent_dir;
    if (dwg_dynapi_entity_value (vertex_2d, "VERTEX_2D", "tangent_dir", &tangent_dir, NULL)
        && tangent_dir == vertex_2d->tangent_dir)
      pass ();
    else
      fail ("VERTEX_2D.tangent_dir [BD] %g != %g", vertex_2d->tangent_dir, tangent_dir);
    tangent_dir++;
    if (dwg_dynapi_entity_set_value (vertex_2d, "VERTEX_2D", "tangent_dir", &tangent_dir, 0)
        && tangent_dir == vertex_2d->tangent_dir)
      pass ();
    else
      fail ("VERTEX_2D.tangent_dir [BD] set+1 %g != %g", vertex_2d->tangent_dir, tangent_dir);
    vertex_2d->tangent_dir--;
  }
  if (failed && (is_class_unstable ("VERTEX_2D") || is_class_debugging ("VERTEX_2D")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_2D", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_3D (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_3D *restrict vertex_3d = obj->tio.entity->tio.VERTEX_3D;
  failed = 0;
  if (!obj_obj || !vertex_3d)
    {
      fail ("NULL VERTEX_3D");
      return 1;
    }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vertex_3d, "VERTEX_3D", "flag", &flag, NULL)
        && flag == vertex_3d->flag)
      pass ();
    else
      fail ("VERTEX_3D.flag [RC] %u != %u", vertex_3d->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vertex_3d, "VERTEX_3D", "flag", &flag, 0)
        && flag == vertex_3d->flag)
      pass ();
    else
      fail ("VERTEX_3D.flag [RC] set+1 %u != %u", vertex_3d->flag, flag);
    vertex_3d->flag--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (vertex_3d, "VERTEX_3D", "parent", &parent, NULL)
        && !memcmp (&parent, &vertex_3d->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("VERTEX_3D.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (vertex_3d, "VERTEX_3D", "point", &point, NULL)
        && !memcmp (&point, &vertex_3d->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VERTEX_3D.point [3BD]");
  }
  if (failed && (is_class_unstable ("VERTEX_3D") || is_class_debugging ("VERTEX_3D")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_3D", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_MESH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_MESH *restrict vertex_mesh = obj->tio.entity->tio.VERTEX_MESH;
  failed = 0;
  if (!obj_obj || !vertex_mesh)
    {
      fail ("NULL VERTEX_MESH");
      return 1;
    }
  if (failed && (is_class_unstable ("VERTEX_MESH") || is_class_debugging ("VERTEX_MESH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_MESH", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_PFACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_PFACE *restrict vertex_pface = obj->tio.entity->tio.VERTEX_PFACE;
  failed = 0;
  if (!obj_obj || !vertex_pface)
    {
      fail ("NULL VERTEX_PFACE");
      return 1;
    }
  if (failed && (is_class_unstable ("VERTEX_PFACE") || is_class_debugging ("VERTEX_PFACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_PFACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_PFACE_FACE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_PFACE_FACE *restrict vertex_pface_face = obj->tio.entity->tio.VERTEX_PFACE_FACE;
  failed = 0;
  if (!obj_obj || !vertex_pface_face)
    {
      fail ("NULL VERTEX_PFACE_FACE");
      return 1;
    }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "flag", &flag, NULL)
        && flag == vertex_pface_face->flag)
      pass ();
    else
      fail ("VERTEX_PFACE_FACE.flag [RC] %u != %u", vertex_pface_face->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vertex_pface_face, "VERTEX_PFACE_FACE", "flag", &flag, 0)
        && flag == vertex_pface_face->flag)
      pass ();
    else
      fail ("VERTEX_PFACE_FACE.flag [RC] set+1 %u != %u", vertex_pface_face->flag, flag);
    vertex_pface_face->flag--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "parent", &parent, NULL)
        && !memcmp (&parent, &vertex_pface_face->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("VERTEX_PFACE_FACE.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_BS vertind[4];
    if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "vertind[4]", &vertind, NULL)
        && !memcmp (&vertind, &vertex_pface_face->vertind, sizeof (BITCODE_BS)))
        pass ();
    else
        fail ("VERTEX_PFACE_FACE.vertind[4] [BS]");
  }
  if (failed && (is_class_unstable ("VERTEX_PFACE_FACE") || is_class_debugging ("VERTEX_PFACE_FACE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_PFACE_FACE", failed);
      failed = 0;
    }
  return failed;
}
static int test_VERTEX_R11 (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VERTEX_R11 *restrict vertex_r11 = obj->tio.entity->tio.VERTEX_R11;
  failed = 0;
  if (!obj_obj || !vertex_r11)
    {
      fail ("NULL VERTEX_R11");
      return 1;
    }
  {
    BITCODE_RD bulge;
    if (dwg_dynapi_entity_value (vertex_r11, "VERTEX_R11", "bulge", &bulge, NULL)
        && bulge == vertex_r11->bulge)
      pass ();
    else
      fail ("VERTEX_R11.bulge [RD] %g != %g", vertex_r11->bulge, bulge);
    bulge++;
    if (dwg_dynapi_entity_set_value (vertex_r11, "VERTEX_R11", "bulge", &bulge, 0)
        && bulge == vertex_r11->bulge)
      pass ();
    else
      fail ("VERTEX_R11.bulge [RD] set+1 %g != %g", vertex_r11->bulge, bulge);
    vertex_r11->bulge--;
  }
  {
    BITCODE_RD end_width;
    if (dwg_dynapi_entity_value (vertex_r11, "VERTEX_R11", "end_width", &end_width, NULL)
        && end_width == vertex_r11->end_width)
      pass ();
    else
      fail ("VERTEX_R11.end_width [RD] %g != %g", vertex_r11->end_width, end_width);
    end_width++;
    if (dwg_dynapi_entity_set_value (vertex_r11, "VERTEX_R11", "end_width", &end_width, 0)
        && end_width == vertex_r11->end_width)
      pass ();
    else
      fail ("VERTEX_R11.end_width [RD] set+1 %g != %g", vertex_r11->end_width, end_width);
    vertex_r11->end_width--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vertex_r11, "VERTEX_R11", "flag", &flag, NULL)
        && flag == vertex_r11->flag)
      pass ();
    else
      fail ("VERTEX_R11.flag [RC] %u != %u", vertex_r11->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vertex_r11, "VERTEX_R11", "flag", &flag, 0)
        && flag == vertex_r11->flag)
      pass ();
    else
      fail ("VERTEX_R11.flag [RC] set+1 %u != %u", vertex_r11->flag, flag);
    vertex_r11->flag--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (vertex_r11, "VERTEX_R11", "parent", &parent, NULL)
        && !memcmp (&parent, &vertex_r11->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("VERTEX_R11.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_2RD point;
    if (dwg_dynapi_entity_value (vertex_r11, "VERTEX_R11", "point", &point, NULL)
        && !memcmp (&point, &vertex_r11->point, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VERTEX_R11.point [2RD]");
  }
  {
    BITCODE_RD start_width;
    if (dwg_dynapi_entity_value (vertex_r11, "VERTEX_R11", "start_width", &start_width, NULL)
        && start_width == vertex_r11->start_width)
      pass ();
    else
      fail ("VERTEX_R11.start_width [RD] %g != %g", vertex_r11->start_width, start_width);
    start_width++;
    if (dwg_dynapi_entity_set_value (vertex_r11, "VERTEX_R11", "start_width", &start_width, 0)
        && start_width == vertex_r11->start_width)
      pass ();
    else
      fail ("VERTEX_R11.start_width [RD] set+1 %g != %g", vertex_r11->start_width, start_width);
    vertex_r11->start_width--;
  }
  {
    BITCODE_RD tangent_dir;
    if (dwg_dynapi_entity_value (vertex_r11, "VERTEX_R11", "tangent_dir", &tangent_dir, NULL)
        && tangent_dir == vertex_r11->tangent_dir)
      pass ();
    else
      fail ("VERTEX_R11.tangent_dir [RD] %g != %g", vertex_r11->tangent_dir, tangent_dir);
    tangent_dir++;
    if (dwg_dynapi_entity_set_value (vertex_r11, "VERTEX_R11", "tangent_dir", &tangent_dir, 0)
        && tangent_dir == vertex_r11->tangent_dir)
      pass ();
    else
      fail ("VERTEX_R11.tangent_dir [RD] set+1 %g != %g", vertex_r11->tangent_dir, tangent_dir);
    vertex_r11->tangent_dir--;
  }
  {
    BITCODE_BS vertind[4];
    if (dwg_dynapi_entity_value (vertex_r11, "VERTEX_R11", "vertind[4]", &vertind, NULL)
        && !memcmp (&vertind, &vertex_r11->vertind, sizeof (BITCODE_BS)))
        pass ();
    else
        fail ("VERTEX_R11.vertind[4] [BS]");
  }
  if (failed && (is_class_unstable ("VERTEX_R11") || is_class_debugging ("VERTEX_R11")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VERTEX_R11", failed);
      failed = 0;
    }
  return failed;
}
static int test_VIEWPORT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VIEWPORT *restrict viewport = obj->tio.entity->tio.VIEWPORT;
  failed = 0;
  if (!obj_obj || !viewport)
    {
      fail ("NULL VIEWPORT");
      return 1;
    }
  {
    BITCODE_2RD GRIDUNIT;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "GRIDUNIT", &GRIDUNIT, NULL)
        && !memcmp (&GRIDUNIT, &viewport->GRIDUNIT, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VIEWPORT.GRIDUNIT [2RD]");
  }
  {
    BITCODE_BD SNAPANG;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "SNAPANG", &SNAPANG, NULL)
        && SNAPANG == viewport->SNAPANG)
      pass ();
    else
      fail ("VIEWPORT.SNAPANG [BD] %g != %g", viewport->SNAPANG, SNAPANG);
    SNAPANG++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "SNAPANG", &SNAPANG, 0)
        && SNAPANG == viewport->SNAPANG)
      pass ();
    else
      fail ("VIEWPORT.SNAPANG [BD] set+1 %g != %g", viewport->SNAPANG, SNAPANG);
    viewport->SNAPANG--;
  }
  {
    BITCODE_2RD SNAPBASE;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "SNAPBASE", &SNAPBASE, NULL)
        && !memcmp (&SNAPBASE, &viewport->SNAPBASE, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VIEWPORT.SNAPBASE [2RD]");
  }
  {
    BITCODE_2RD SNAPUNIT;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "SNAPUNIT", &SNAPUNIT, NULL)
        && !memcmp (&SNAPUNIT, &viewport->SNAPUNIT, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VIEWPORT.SNAPUNIT [2RD]");
  }
  {
    BITCODE_BS UCSORTHOVIEW;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "UCSORTHOVIEW", &UCSORTHOVIEW, NULL)
        && UCSORTHOVIEW == viewport->UCSORTHOVIEW)
      pass ();
    else
      fail ("VIEWPORT.UCSORTHOVIEW [BS] %hu != %hu", viewport->UCSORTHOVIEW, UCSORTHOVIEW);
    UCSORTHOVIEW++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "UCSORTHOVIEW", &UCSORTHOVIEW, 0)
        && UCSORTHOVIEW == viewport->UCSORTHOVIEW)
      pass ();
    else
      fail ("VIEWPORT.UCSORTHOVIEW [BS] set+1 %hu != %hu", viewport->UCSORTHOVIEW, UCSORTHOVIEW);
    viewport->UCSORTHOVIEW--;
  }
  {
    BITCODE_B UCSVP;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "UCSVP", &UCSVP, NULL)
        && UCSVP == viewport->UCSVP)
      pass ();
    else
      fail ("VIEWPORT.UCSVP [B] " FORMAT_B " != " FORMAT_B "", viewport->UCSVP, UCSVP);
    UCSVP++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "UCSVP", &UCSVP, 0)
        && UCSVP == viewport->UCSVP)
      pass ();
    else
      fail ("VIEWPORT.UCSVP [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->UCSVP, UCSVP);
    viewport->UCSVP--;
  }
  {
    BITCODE_2RD VIEWCTR;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "VIEWCTR", &VIEWCTR, NULL)
        && !memcmp (&VIEWCTR, &viewport->VIEWCTR, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VIEWPORT.VIEWCTR [2RD]");
  }
  {
    BITCODE_3BD VIEWDIR;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "VIEWDIR", &VIEWDIR, NULL)
        && !memcmp (&VIEWDIR, &viewport->VIEWDIR, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEWPORT.VIEWDIR [3BD]");
  }
  {
    BITCODE_BD VIEWSIZE;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "VIEWSIZE", &VIEWSIZE, NULL)
        && VIEWSIZE == viewport->VIEWSIZE)
      pass ();
    else
      fail ("VIEWPORT.VIEWSIZE [BD] %g != %g", viewport->VIEWSIZE, VIEWSIZE);
    VIEWSIZE++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "VIEWSIZE", &VIEWSIZE, 0)
        && VIEWSIZE == viewport->VIEWSIZE)
      pass ();
    else
      fail ("VIEWPORT.VIEWSIZE [BD] set+1 %g != %g", viewport->VIEWSIZE, VIEWSIZE);
    viewport->VIEWSIZE--;
  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ambient_color", &ambient_color, NULL)
        && !memcmp (&ambient_color, &viewport->ambient_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VIEWPORT.ambient_color [CMC]");
  }
  {
    BITCODE_BD back_clip_z;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "back_clip_z", &back_clip_z, NULL)
        && back_clip_z == viewport->back_clip_z)
      pass ();
    else
      fail ("VIEWPORT.back_clip_z [BD] %g != %g", viewport->back_clip_z, back_clip_z);
    back_clip_z++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "back_clip_z", &back_clip_z, 0)
        && back_clip_z == viewport->back_clip_z)
      pass ();
    else
      fail ("VIEWPORT.back_clip_z [BD] set+1 %g != %g", viewport->back_clip_z, back_clip_z);
    viewport->back_clip_z--;
  }
  {
    BITCODE_H background;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "background", &background, NULL)
        && !memcmp (&background, &viewport->background, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEWPORT.background [H]");
  }
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &viewport->base_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEWPORT.base_ucs [H]");
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "brightness", &brightness, NULL)
        && brightness == viewport->brightness)
      pass ();
    else
      fail ("VIEWPORT.brightness [BD] %g != %g", viewport->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "brightness", &brightness, 0)
        && brightness == viewport->brightness)
      pass ();
    else
      fail ("VIEWPORT.brightness [BD] set+1 %g != %g", viewport->brightness, brightness);
    viewport->brightness--;
  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "center", &center, NULL)
        && !memcmp (&center, &viewport->center, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEWPORT.center [3BD]");
  }
  {
    BITCODE_BS circle_zoom;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "circle_zoom", &circle_zoom, NULL)
        && circle_zoom == viewport->circle_zoom)
      pass ();
    else
      fail ("VIEWPORT.circle_zoom [BS] %hu != %hu", viewport->circle_zoom, circle_zoom);
    circle_zoom++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "circle_zoom", &circle_zoom, 0)
        && circle_zoom == viewport->circle_zoom)
      pass ();
    else
      fail ("VIEWPORT.circle_zoom [BS] set+1 %hu != %hu", viewport->circle_zoom, circle_zoom);
    viewport->circle_zoom--;
  }
  {
    BITCODE_H clip_boundary;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "clip_boundary", &clip_boundary, NULL)
        && !memcmp (&clip_boundary, &viewport->clip_boundary, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEWPORT.clip_boundary [H]");
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "contrast", &contrast, NULL)
        && contrast == viewport->contrast)
      pass ();
    else
      fail ("VIEWPORT.contrast [BD] %g != %g", viewport->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "contrast", &contrast, 0)
        && contrast == viewport->contrast)
      pass ();
    else
      fail ("VIEWPORT.contrast [BD] set+1 %g != %g", viewport->contrast, contrast);
    viewport->contrast--;
  }
  {
    BITCODE_RC default_lighting_type;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "default_lighting_type", &default_lighting_type, NULL)
        && default_lighting_type == viewport->default_lighting_type)
      pass ();
    else
      fail ("VIEWPORT.default_lighting_type [RC] %u != %u", viewport->default_lighting_type, default_lighting_type);
    default_lighting_type++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "default_lighting_type", &default_lighting_type, 0)
        && default_lighting_type == viewport->default_lighting_type)
      pass ();
    else
      fail ("VIEWPORT.default_lighting_type [RC] set+1 %u != %u", viewport->default_lighting_type, default_lighting_type);
    viewport->default_lighting_type--;
  }
  {
    BITCODE_BD front_clip_z;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "front_clip_z", &front_clip_z, NULL)
        && front_clip_z == viewport->front_clip_z)
      pass ();
    else
      fail ("VIEWPORT.front_clip_z [BD] %g != %g", viewport->front_clip_z, front_clip_z);
    front_clip_z++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "front_clip_z", &front_clip_z, 0)
        && front_clip_z == viewport->front_clip_z)
      pass ();
    else
      fail ("VIEWPORT.front_clip_z [BD] set+1 %g != %g", viewport->front_clip_z, front_clip_z);
    viewport->front_clip_z--;
  }
  {
    BITCODE_H* frozen_layers;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "num_frozen_layers", &count, NULL)
        && dwg_dynapi_entity_value (viewport, "VIEWPORT", "frozen_layers", &frozen_layers, NULL)
        && frozen_layers == viewport->frozen_layers)
      pass ();
    else
      fail ("VIEWPORT.frozen_layers [H*] * %u num_frozen_layers", count);
  }
  {
    BITCODE_BS grid_major;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "grid_major", &grid_major, NULL)
        && grid_major == viewport->grid_major)
      pass ();
    else
      fail ("VIEWPORT.grid_major [BS] %hu != %hu", viewport->grid_major, grid_major);
    grid_major++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "grid_major", &grid_major, 0)
        && grid_major == viewport->grid_major)
      pass ();
    else
      fail ("VIEWPORT.grid_major [BS] set+1 %hu != %hu", viewport->grid_major, grid_major);
    viewport->grid_major--;
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "height", &height, NULL)
        && height == viewport->height)
      pass ();
    else
      fail ("VIEWPORT.height [BD] %g != %g", viewport->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "height", &height, 0)
        && height == viewport->height)
      pass ();
    else
      fail ("VIEWPORT.height [BD] set+1 %g != %g", viewport->height, height);
    viewport->height--;
  }
  {
    BITCODE_RS id;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "id", &id, NULL)
        && id == viewport->id)
      pass ();
    else
      fail ("VIEWPORT.id [RS] %hu != %hu", viewport->id, id);
    id++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "id", &id, 0)
        && id == viewport->id)
      pass ();
    else
      fail ("VIEWPORT.id [RS] set+1 %hu != %hu", viewport->id, id);
    viewport->id--;
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "lens_length", &lens_length, NULL)
        && lens_length == viewport->lens_length)
      pass ();
    else
      fail ("VIEWPORT.lens_length [BD] %g != %g", viewport->lens_length, lens_length);
    lens_length++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "lens_length", &lens_length, 0)
        && lens_length == viewport->lens_length)
      pass ();
    else
      fail ("VIEWPORT.lens_length [BD] set+1 %g != %g", viewport->lens_length, lens_length);
    viewport->lens_length--;
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &viewport->named_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEWPORT.named_ucs [H]");
  }
  {
    BITCODE_BL num_frozen_layers;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "num_frozen_layers", &num_frozen_layers, NULL)
        && num_frozen_layers == viewport->num_frozen_layers)
      pass ();
    else
      fail ("VIEWPORT.num_frozen_layers [BL] %u != %u", viewport->num_frozen_layers, num_frozen_layers);
    num_frozen_layers++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "num_frozen_layers", &num_frozen_layers, 0)
        && num_frozen_layers == viewport->num_frozen_layers)
      pass ();
    else
      fail ("VIEWPORT.num_frozen_layers [BL] set+1 %u != %u", viewport->num_frozen_layers, num_frozen_layers);
    viewport->num_frozen_layers--;
  }
  {
    BITCODE_RS on_off;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "on_off", &on_off, NULL)
        && on_off == viewport->on_off)
      pass ();
    else
      fail ("VIEWPORT.on_off [RS] %hu != %hu", viewport->on_off, on_off);
    on_off++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "on_off", &on_off, 0)
        && on_off == viewport->on_off)
      pass ();
    else
      fail ("VIEWPORT.on_off [RS] set+1 %hu != %hu", viewport->on_off, on_off);
    viewport->on_off--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "parent", &parent, NULL)
        && !memcmp (&parent, &viewport->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("VIEWPORT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "render_mode", &render_mode, NULL)
        && render_mode == viewport->render_mode)
      pass ();
    else
      fail ("VIEWPORT.render_mode [RC] %u != %u", viewport->render_mode, render_mode);
    render_mode++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "render_mode", &render_mode, 0)
        && render_mode == viewport->render_mode)
      pass ();
    else
      fail ("VIEWPORT.render_mode [RC] set+1 %u != %u", viewport->render_mode, render_mode);
    viewport->render_mode--;
  }
  {
    BITCODE_H shadeplot;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "shadeplot", &shadeplot, NULL)
        && !memcmp (&shadeplot, &viewport->shadeplot, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEWPORT.shadeplot [H]");
  }
  {
    BITCODE_BS shadeplot_mode;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "shadeplot_mode", &shadeplot_mode, NULL)
        && shadeplot_mode == viewport->shadeplot_mode)
      pass ();
    else
      fail ("VIEWPORT.shadeplot_mode [BS] %hu != %hu", viewport->shadeplot_mode, shadeplot_mode);
    shadeplot_mode++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "shadeplot_mode", &shadeplot_mode, 0)
        && shadeplot_mode == viewport->shadeplot_mode)
      pass ();
    else
      fail ("VIEWPORT.shadeplot_mode [BS] set+1 %hu != %hu", viewport->shadeplot_mode, shadeplot_mode);
    viewport->shadeplot_mode--;
  }
  {
    BITCODE_BL status_flag;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "status_flag", &status_flag, NULL)
        && status_flag == viewport->status_flag)
      pass ();
    else
      fail ("VIEWPORT.status_flag [BL] %u != %u", viewport->status_flag, status_flag);
    status_flag++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "status_flag", &status_flag, 0)
        && status_flag == viewport->status_flag)
      pass ();
    else
      fail ("VIEWPORT.status_flag [BL] set+1 %u != %u", viewport->status_flag, status_flag);
    viewport->status_flag--;
  }
  {
    BITCODE_T style_sheet;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "style_sheet", &style_sheet, NULL)
        && style_sheet
           ? strEQ ((char *)style_sheet, (char *)viewport->style_sheet)
           : !viewport->style_sheet)
      pass ();
    else
      fail ("VIEWPORT.style_sheet [T] '%s' <> '%s'", style_sheet, viewport->style_sheet);
  }
  {
    BITCODE_H sun;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "sun", &sun, NULL)
        && !memcmp (&sun, &viewport->sun, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEWPORT.sun [H]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "twist_angle", &twist_angle, NULL)
        && twist_angle == viewport->twist_angle)
      pass ();
    else
      fail ("VIEWPORT.twist_angle [BD] %g != %g", viewport->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "twist_angle", &twist_angle, 0)
        && twist_angle == viewport->twist_angle)
      pass ();
    else
      fail ("VIEWPORT.twist_angle [BD] set+1 %g != %g", viewport->twist_angle, twist_angle);
    viewport->twist_angle--;
  }
  {
    BITCODE_B ucs_at_origin;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_at_origin", &ucs_at_origin, NULL)
        && ucs_at_origin == viewport->ucs_at_origin)
      pass ();
    else
      fail ("VIEWPORT.ucs_at_origin [B] " FORMAT_B " != " FORMAT_B "", viewport->ucs_at_origin, ucs_at_origin);
    ucs_at_origin++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "ucs_at_origin", &ucs_at_origin, 0)
        && ucs_at_origin == viewport->ucs_at_origin)
      pass ();
    else
      fail ("VIEWPORT.ucs_at_origin [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->ucs_at_origin, ucs_at_origin);
    viewport->ucs_at_origin--;
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucs_elevation", &ucs_elevation, NULL)
        && ucs_elevation == viewport->ucs_elevation)
      pass ();
    else
      fail ("VIEWPORT.ucs_elevation [BD] %g != %g", viewport->ucs_elevation, ucs_elevation);
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "ucs_elevation", &ucs_elevation, 0)
        && ucs_elevation == viewport->ucs_elevation)
      pass ();
    else
      fail ("VIEWPORT.ucs_elevation [BD] set+1 %g != %g", viewport->ucs_elevation, ucs_elevation);
    viewport->ucs_elevation--;
  }
  {
    BITCODE_3BD ucsorg;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucsorg", &ucsorg, NULL)
        && !memcmp (&ucsorg, &viewport->ucsorg, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEWPORT.ucsorg [3BD]");
  }
  {
    BITCODE_3BD ucsxdir;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucsxdir", &ucsxdir, NULL)
        && !memcmp (&ucsxdir, &viewport->ucsxdir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEWPORT.ucsxdir [3BD]");
  }
  {
    BITCODE_3BD ucsydir;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "ucsydir", &ucsydir, NULL)
        && !memcmp (&ucsydir, &viewport->ucsydir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEWPORT.ucsydir [3BD]");
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "use_default_lights", &use_default_lights, NULL)
        && use_default_lights == viewport->use_default_lights)
      pass ();
    else
      fail ("VIEWPORT.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", viewport->use_default_lights, use_default_lights);
    use_default_lights++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "use_default_lights", &use_default_lights, 0)
        && use_default_lights == viewport->use_default_lights)
      pass ();
    else
      fail ("VIEWPORT.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", viewport->use_default_lights, use_default_lights);
    viewport->use_default_lights--;
  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "view_target", &view_target, NULL)
        && !memcmp (&view_target, &viewport->view_target, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEWPORT.view_target [3BD]");
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &viewport->visualstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEWPORT.visualstyle [H]");
  }
  {
    BITCODE_H vport_entity_header;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "vport_entity_header", &vport_entity_header, NULL)
        && !memcmp (&vport_entity_header, &viewport->vport_entity_header, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEWPORT.vport_entity_header [H]");
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value (viewport, "VIEWPORT", "width", &width, NULL)
        && width == viewport->width)
      pass ();
    else
      fail ("VIEWPORT.width [BD] %g != %g", viewport->width, width);
    width++;
    if (dwg_dynapi_entity_set_value (viewport, "VIEWPORT", "width", &width, 0)
        && width == viewport->width)
      pass ();
    else
      fail ("VIEWPORT.width [BD] set+1 %g != %g", viewport->width, width);
    viewport->width--;
  }
  if (failed && (is_class_unstable ("VIEWPORT") || is_class_debugging ("VIEWPORT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VIEWPORT", failed);
      failed = 0;
    }
  return failed;
}
static int test_VISIBILITYGRIPENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VISIBILITYGRIPENTITY *restrict visibilitygripentity = obj->tio.entity->tio.VISIBILITYGRIPENTITY;
  failed = 0;
  if (!obj_obj || !visibilitygripentity)
    {
      fail ("NULL VISIBILITYGRIPENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (visibilitygripentity, "VISIBILITYGRIPENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &visibilitygripentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("VISIBILITYGRIPENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("VISIBILITYGRIPENTITY") || is_class_debugging ("VISIBILITYGRIPENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VISIBILITYGRIPENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_VISIBILITYPARAMETERENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_VISIBILITYPARAMETERENTITY *restrict visibilityparameterentity = obj->tio.entity->tio.VISIBILITYPARAMETERENTITY;
  failed = 0;
  if (!obj_obj || !visibilityparameterentity)
    {
      fail ("NULL VISIBILITYPARAMETERENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (visibilityparameterentity, "VISIBILITYPARAMETERENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &visibilityparameterentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("VISIBILITYPARAMETERENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("VISIBILITYPARAMETERENTITY") || is_class_debugging ("VISIBILITYPARAMETERENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VISIBILITYPARAMETERENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_WIPEOUT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_WIPEOUT *restrict wipeout = obj->tio.entity->tio.WIPEOUT;
  failed = 0;
  if (!obj_obj || !wipeout)
    {
      fail ("NULL WIPEOUT");
      return 1;
    }
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "brightness", &brightness, NULL)
        && brightness == wipeout->brightness)
      pass ();
    else
      fail ("WIPEOUT.brightness [RC] %u != %u", wipeout->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "brightness", &brightness, 0)
        && brightness == wipeout->brightness)
      pass ();
    else
      fail ("WIPEOUT.brightness [RC] set+1 %u != %u", wipeout->brightness, brightness);
    wipeout->brightness--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "class_version", &class_version, NULL)
        && class_version == wipeout->class_version)
      pass ();
    else
      fail ("WIPEOUT.class_version [BL] %u != %u", wipeout->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "class_version", &class_version, 0)
        && class_version == wipeout->class_version)
      pass ();
    else
      fail ("WIPEOUT.class_version [BL] set+1 %u != %u", wipeout->class_version, class_version);
    wipeout->class_version--;
  }
  {
    BITCODE_BS clip_boundary_type;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "clip_boundary_type", &clip_boundary_type, NULL)
        && clip_boundary_type == wipeout->clip_boundary_type)
      pass ();
    else
      fail ("WIPEOUT.clip_boundary_type [BS] %hu != %hu", wipeout->clip_boundary_type, clip_boundary_type);
    clip_boundary_type++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "clip_boundary_type", &clip_boundary_type, 0)
        && clip_boundary_type == wipeout->clip_boundary_type)
      pass ();
    else
      fail ("WIPEOUT.clip_boundary_type [BS] set+1 %hu != %hu", wipeout->clip_boundary_type, clip_boundary_type);
    wipeout->clip_boundary_type--;
  }
  {
    BITCODE_B clip_mode;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "clip_mode", &clip_mode, NULL)
        && clip_mode == wipeout->clip_mode)
      pass ();
    else
      fail ("WIPEOUT.clip_mode [B] " FORMAT_B " != " FORMAT_B "", wipeout->clip_mode, clip_mode);
    clip_mode++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "clip_mode", &clip_mode, 0)
        && clip_mode == wipeout->clip_mode)
      pass ();
    else
      fail ("WIPEOUT.clip_mode [B] set+1 " FORMAT_B " != " FORMAT_B "", wipeout->clip_mode, clip_mode);
    wipeout->clip_mode--;
  }
  {
    BITCODE_2RD* clip_verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "num_clip_verts", &count, NULL)
        && dwg_dynapi_entity_value (wipeout, "WIPEOUT", "clip_verts", &clip_verts, NULL)
        && clip_verts == wipeout->clip_verts)
      pass ();
    else
      fail ("WIPEOUT.clip_verts [2RD*] * %u num_clip_verts", count);
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "clipping", &clipping, NULL)
        && clipping == wipeout->clipping)
      pass ();
    else
      fail ("WIPEOUT.clipping [B] " FORMAT_B " != " FORMAT_B "", wipeout->clipping, clipping);
    clipping++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "clipping", &clipping, 0)
        && clipping == wipeout->clipping)
      pass ();
    else
      fail ("WIPEOUT.clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", wipeout->clipping, clipping);
    wipeout->clipping--;
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "contrast", &contrast, NULL)
        && contrast == wipeout->contrast)
      pass ();
    else
      fail ("WIPEOUT.contrast [RC] %u != %u", wipeout->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "contrast", &contrast, 0)
        && contrast == wipeout->contrast)
      pass ();
    else
      fail ("WIPEOUT.contrast [RC] set+1 %u != %u", wipeout->contrast, contrast);
    wipeout->contrast--;
  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "display_props", &display_props, NULL)
        && display_props == wipeout->display_props)
      pass ();
    else
      fail ("WIPEOUT.display_props [BS] %hu != %hu", wipeout->display_props, display_props);
    display_props++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "display_props", &display_props, 0)
        && display_props == wipeout->display_props)
      pass ();
    else
      fail ("WIPEOUT.display_props [BS] set+1 %hu != %hu", wipeout->display_props, display_props);
    wipeout->display_props--;
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "fade", &fade, NULL)
        && fade == wipeout->fade)
      pass ();
    else
      fail ("WIPEOUT.fade [RC] %u != %u", wipeout->fade, fade);
    fade++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "fade", &fade, 0)
        && fade == wipeout->fade)
      pass ();
    else
      fail ("WIPEOUT.fade [RC] set+1 %u != %u", wipeout->fade, fade);
    wipeout->fade--;
  }
  {
    BITCODE_H imagedef;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "imagedef", &imagedef, NULL)
        && !memcmp (&imagedef, &wipeout->imagedef, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("WIPEOUT.imagedef [H]");
  }
  {
    BITCODE_H imagedefreactor;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "imagedefreactor", &imagedefreactor, NULL)
        && !memcmp (&imagedefreactor, &wipeout->imagedefreactor, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("WIPEOUT.imagedefreactor [H]");
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "num_clip_verts", &num_clip_verts, NULL)
        && num_clip_verts == wipeout->num_clip_verts)
      pass ();
    else
      fail ("WIPEOUT.num_clip_verts [BL] %u != %u", wipeout->num_clip_verts, num_clip_verts);
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value (wipeout, "WIPEOUT", "num_clip_verts", &num_clip_verts, 0)
        && num_clip_verts == wipeout->num_clip_verts)
      pass ();
    else
      fail ("WIPEOUT.num_clip_verts [BL] set+1 %u != %u", wipeout->num_clip_verts, num_clip_verts);
    wipeout->num_clip_verts--;
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "parent", &parent, NULL)
        && !memcmp (&parent, &wipeout->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("WIPEOUT.parent [struct _dwg_object_entity*]");
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "pt0", &pt0, NULL)
        && !memcmp (&pt0, &wipeout->pt0, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("WIPEOUT.pt0 [3BD]");
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "size", &size, NULL)
        && !memcmp (&size, &wipeout->size, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("WIPEOUT.size [2RD]");
  }
  {
    BITCODE_3BD uvec;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "uvec", &uvec, NULL)
        && !memcmp (&uvec, &wipeout->uvec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("WIPEOUT.uvec [3BD]");
  }
  {
    BITCODE_3BD vvec;
    if (dwg_dynapi_entity_value (wipeout, "WIPEOUT", "vvec", &vvec, NULL)
        && !memcmp (&vvec, &wipeout->vvec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("WIPEOUT.vvec [3BD]");
  }
  if (failed && (is_class_unstable ("WIPEOUT") || is_class_debugging ("WIPEOUT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "WIPEOUT", failed);
      failed = 0;
    }
  return failed;
}
static int test_XLINE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_XLINE *restrict xline = obj->tio.entity->tio.XLINE;
  failed = 0;
  if (!obj_obj || !xline)
    {
      fail ("NULL XLINE");
      return 1;
    }
  if (failed && (is_class_unstable ("XLINE") || is_class_debugging ("XLINE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "XLINE", failed);
      failed = 0;
    }
  return failed;
}
static int test_XYGRIPENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_XYGRIPENTITY *restrict xygripentity = obj->tio.entity->tio.XYGRIPENTITY;
  failed = 0;
  if (!obj_obj || !xygripentity)
    {
      fail ("NULL XYGRIPENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (xygripentity, "XYGRIPENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &xygripentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("XYGRIPENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("XYGRIPENTITY") || is_class_debugging ("XYGRIPENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "XYGRIPENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_XYPARAMETERENTITY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
  Dwg_Entity_XYPARAMETERENTITY *restrict xyparameterentity = obj->tio.entity->tio.XYPARAMETERENTITY;
  failed = 0;
  if (!obj_obj || !xyparameterentity)
    {
      fail ("NULL XYPARAMETERENTITY");
      return 1;
    }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value (xyparameterentity, "XYPARAMETERENTITY", "parent", &parent, NULL)
        && !memcmp (&parent, &xyparameterentity->parent, sizeof (struct _dwg_object_entity*)))
        pass ();
    else
        fail ("XYPARAMETERENTITY.parent [struct _dwg_object_entity*]");
  }
  if (failed && (is_class_unstable ("XYPARAMETERENTITY") || is_class_debugging ("XYPARAMETERENTITY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "XYPARAMETERENTITY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACMECOMMANDHISTORY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACMECOMMANDHISTORY *restrict acmecommandhistory = obj->tio.object->tio.ACMECOMMANDHISTORY;
  failed = 0;
  if (!obj_obj || !acmecommandhistory)
    {
      fail ("NULL ACMECOMMANDHISTORY");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (acmecommandhistory, "ACMECOMMANDHISTORY", "class_version", &class_version, NULL)
        && class_version == acmecommandhistory->class_version)
      pass ();
    else
      fail ("ACMECOMMANDHISTORY.class_version [BS] %hu != %hu", acmecommandhistory->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (acmecommandhistory, "ACMECOMMANDHISTORY", "class_version", &class_version, 0)
        && class_version == acmecommandhistory->class_version)
      pass ();
    else
      fail ("ACMECOMMANDHISTORY.class_version [BS] set+1 %hu != %hu", acmecommandhistory->class_version, class_version);
    acmecommandhistory->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acmecommandhistory, "ACMECOMMANDHISTORY", "parent", &parent, NULL)
        && !memcmp (&parent, &acmecommandhistory->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACMECOMMANDHISTORY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ACMECOMMANDHISTORY") || is_class_debugging ("ACMECOMMANDHISTORY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACMECOMMANDHISTORY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACMESCOPE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACMESCOPE *restrict acmescope = obj->tio.object->tio.ACMESCOPE;
  failed = 0;
  if (!obj_obj || !acmescope)
    {
      fail ("NULL ACMESCOPE");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (acmescope, "ACMESCOPE", "class_version", &class_version, NULL)
        && class_version == acmescope->class_version)
      pass ();
    else
      fail ("ACMESCOPE.class_version [BS] %hu != %hu", acmescope->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (acmescope, "ACMESCOPE", "class_version", &class_version, 0)
        && class_version == acmescope->class_version)
      pass ();
    else
      fail ("ACMESCOPE.class_version [BS] set+1 %hu != %hu", acmescope->class_version, class_version);
    acmescope->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acmescope, "ACMESCOPE", "parent", &parent, NULL)
        && !memcmp (&parent, &acmescope->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACMESCOPE.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ACMESCOPE") || is_class_debugging ("ACMESCOPE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACMESCOPE", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACMESTATEMGR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACMESTATEMGR *restrict acmestatemgr = obj->tio.object->tio.ACMESTATEMGR;
  failed = 0;
  if (!obj_obj || !acmestatemgr)
    {
      fail ("NULL ACMESTATEMGR");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (acmestatemgr, "ACMESTATEMGR", "class_version", &class_version, NULL)
        && class_version == acmestatemgr->class_version)
      pass ();
    else
      fail ("ACMESTATEMGR.class_version [BS] %hu != %hu", acmestatemgr->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (acmestatemgr, "ACMESTATEMGR", "class_version", &class_version, 0)
        && class_version == acmestatemgr->class_version)
      pass ();
    else
      fail ("ACMESTATEMGR.class_version [BS] set+1 %hu != %hu", acmestatemgr->class_version, class_version);
    acmestatemgr->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acmestatemgr, "ACMESTATEMGR", "parent", &parent, NULL)
        && !memcmp (&parent, &acmestatemgr->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACMESTATEMGR.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ACMESTATEMGR") || is_class_debugging ("ACMESTATEMGR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACMESTATEMGR", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_BOOLEAN_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_BOOLEAN_CLASS *restrict acsh_boolean_class = obj->tio.object->tio.ACSH_BOOLEAN_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_boolean_class)
    {
      fail ("NULL ACSH_BOOLEAN_CLASS");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_boolean_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_BOOLEAN_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_boolean_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_BOOLEAN_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "major", &major, NULL)
        && major == acsh_boolean_class->major)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.major [BL] %u != %u", acsh_boolean_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "major", &major, 0)
        && major == acsh_boolean_class->major)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.major [BL] set+1 %u != %u", acsh_boolean_class->major, major);
    acsh_boolean_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "minor", &minor, NULL)
        && minor == acsh_boolean_class->minor)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.minor [BL] %u != %u", acsh_boolean_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "minor", &minor, 0)
        && minor == acsh_boolean_class->minor)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.minor [BL] set+1 %u != %u", acsh_boolean_class->minor, minor);
    acsh_boolean_class->minor--;
  }
  {
    BITCODE_BL operand1;
    if (dwg_dynapi_entity_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "operand1", &operand1, NULL)
        && operand1 == acsh_boolean_class->operand1)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.operand1 [BL] %u != %u", acsh_boolean_class->operand1, operand1);
    operand1++;
    if (dwg_dynapi_entity_set_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "operand1", &operand1, 0)
        && operand1 == acsh_boolean_class->operand1)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.operand1 [BL] set+1 %u != %u", acsh_boolean_class->operand1, operand1);
    acsh_boolean_class->operand1--;
  }
  {
    BITCODE_BL operand2;
    if (dwg_dynapi_entity_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "operand2", &operand2, NULL)
        && operand2 == acsh_boolean_class->operand2)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.operand2 [BL] %u != %u", acsh_boolean_class->operand2, operand2);
    operand2++;
    if (dwg_dynapi_entity_set_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "operand2", &operand2, 0)
        && operand2 == acsh_boolean_class->operand2)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.operand2 [BL] set+1 %u != %u", acsh_boolean_class->operand2, operand2);
    acsh_boolean_class->operand2--;
  }
  {
    BITCODE_RCd operation;
    if (dwg_dynapi_entity_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "operation", &operation, NULL)
        && operation == acsh_boolean_class->operation)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.operation [RCd] " FORMAT_RCd " != " FORMAT_RCd "", acsh_boolean_class->operation, operation);
    operation++;
    if (dwg_dynapi_entity_set_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "operation", &operation, 0)
        && operation == acsh_boolean_class->operation)
      pass ();
    else
      fail ("ACSH_BOOLEAN_CLASS.operation [RCd] set+1 " FORMAT_RCd " != " FORMAT_RCd "", acsh_boolean_class->operation, operation);
    acsh_boolean_class->operation--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_boolean_class, "ACSH_BOOLEAN_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_boolean_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_BOOLEAN_CLASS.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ACSH_BOOLEAN_CLASS") || is_class_debugging ("ACSH_BOOLEAN_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_BOOLEAN_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_BOX_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_BOX_CLASS *restrict acsh_box_class = obj->tio.object->tio.ACSH_BOX_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_box_class)
    {
      fail ("NULL ACSH_BOX_CLASS");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_box_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_BOX_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "height", &height, NULL)
        && height == acsh_box_class->height)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.height [BD] %g != %g", acsh_box_class->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "height", &height, 0)
        && height == acsh_box_class->height)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.height [BD] set+1 %g != %g", acsh_box_class->height, height);
    acsh_box_class->height--;
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_box_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_BOX_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BD length;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "length", &length, NULL)
        && length == acsh_box_class->length)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.length [BD] %g != %g", acsh_box_class->length, length);
    length++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "length", &length, 0)
        && length == acsh_box_class->length)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.length [BD] set+1 %g != %g", acsh_box_class->length, length);
    acsh_box_class->length--;
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "major", &major, NULL)
        && major == acsh_box_class->major)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.major [BL] %u != %u", acsh_box_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "major", &major, 0)
        && major == acsh_box_class->major)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.major [BL] set+1 %u != %u", acsh_box_class->major, major);
    acsh_box_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "minor", &minor, NULL)
        && minor == acsh_box_class->minor)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.minor [BL] %u != %u", acsh_box_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "minor", &minor, 0)
        && minor == acsh_box_class->minor)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.minor [BL] set+1 %u != %u", acsh_box_class->minor, minor);
    acsh_box_class->minor--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_box_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_BOX_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "width", &width, NULL)
        && width == acsh_box_class->width)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.width [BD] %g != %g", acsh_box_class->width, width);
    width++;
    if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "width", &width, 0)
        && width == acsh_box_class->width)
      pass ();
    else
      fail ("ACSH_BOX_CLASS.width [BD] set+1 %g != %g", acsh_box_class->width, width);
    acsh_box_class->width--;
  }
  if (failed && (is_class_unstable ("ACSH_BOX_CLASS") || is_class_debugging ("ACSH_BOX_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_BOX_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_BREP_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_BREP_CLASS *restrict acsh_brep_class = obj->tio.object->tio.ACSH_BREP_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_brep_class)
    {
      fail ("NULL ACSH_BREP_CLASS");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == acsh_brep_class->_dxf_sab_converted)
      pass ();
    else
      fail ("ACSH_BREP_CLASS._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == acsh_brep_class->_dxf_sab_converted)
      pass ();
    else
      fail ("ACSH_BREP_CLASS._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->_dxf_sab_converted, _dxf_sab_converted);
    acsh_brep_class->_dxf_sab_converted--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)acsh_brep_class->acis_data)
           : !acsh_brep_class->acis_data)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.acis_data [RC*] '%s' <> '%s'", acis_data, acsh_brep_class->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty", &acis_empty, NULL)
        && acis_empty == acsh_brep_class->acis_empty)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.acis_empty [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty", &acis_empty, 0)
        && acis_empty == acsh_brep_class->acis_empty)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty, acis_empty);
    acsh_brep_class->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == acsh_brep_class->acis_empty2)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == acsh_brep_class->acis_empty2)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty2, acis_empty2);
    acsh_brep_class->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == acsh_brep_class->acis_empty_bit)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == acsh_brep_class->acis_empty_bit)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty_bit, acis_empty_bit);
    acsh_brep_class->acis_empty_bit--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &acsh_brep_class->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.block_size [BL*]");
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &acsh_brep_class->encr_sat_data, sizeof (acsh_brep_class->encr_sat_data)))
      pass ();
    else
      fail ("ACSH_BREP_CLASS.encr_sat_data [char **]");
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "end_marker", &end_marker, NULL)
        && end_marker == acsh_brep_class->end_marker)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.end_marker [BL] %u != %u", acsh_brep_class->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "end_marker", &end_marker, 0)
        && end_marker == acsh_brep_class->end_marker)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.end_marker [BL] set+1 %u != %u", acsh_brep_class->end_marker, end_marker);
    acsh_brep_class->end_marker--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_brep_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &acsh_brep_class->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == acsh_brep_class->has_revision_guid)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == acsh_brep_class->has_revision_guid)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->has_revision_guid, has_revision_guid);
    acsh_brep_class->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &acsh_brep_class->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.history_id [H]");
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_brep_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "isoline_present", &isoline_present, NULL)
        && isoline_present == acsh_brep_class->isoline_present)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.isoline_present [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "isoline_present", &isoline_present, 0)
        && isoline_present == acsh_brep_class->isoline_present)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->isoline_present, isoline_present);
    acsh_brep_class->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "isolines", &isolines, NULL)
        && isolines == acsh_brep_class->isolines)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.isolines [BL] %u != %u", acsh_brep_class->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "isolines", &isolines, 0)
        && isolines == acsh_brep_class->isolines)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.isolines [BL] set+1 %u != %u", acsh_brep_class->isolines, isolines);
    acsh_brep_class->isolines--;
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "major", &major, NULL)
        && major == acsh_brep_class->major)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.major [BL] %u != %u", acsh_brep_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "major", &major, 0)
        && major == acsh_brep_class->major)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.major [BL] set+1 %u != %u", acsh_brep_class->major, major);
    acsh_brep_class->major--;
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "materials", &materials, NULL)
        && materials == acsh_brep_class->materials)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "minor", &minor, NULL)
        && minor == acsh_brep_class->minor)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.minor [BL] %u != %u", acsh_brep_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "minor", &minor, 0)
        && minor == acsh_brep_class->minor)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.minor [BL] set+1 %u != %u", acsh_brep_class->minor, minor);
    acsh_brep_class->minor--;
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_blocks", &num_blocks, NULL)
        && num_blocks == acsh_brep_class->num_blocks)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.num_blocks [BL] %u != %u", acsh_brep_class->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_blocks", &num_blocks, 0)
        && num_blocks == acsh_brep_class->num_blocks)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.num_blocks [BL] set+1 %u != %u", acsh_brep_class->num_blocks, num_blocks);
    acsh_brep_class->num_blocks--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_materials", &num_materials, NULL)
        && num_materials == acsh_brep_class->num_materials)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.num_materials [BL] %u != %u", acsh_brep_class->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_materials", &num_materials, 0)
        && num_materials == acsh_brep_class->num_materials)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.num_materials [BL] set+1 %u != %u", acsh_brep_class->num_materials, num_materials);
    acsh_brep_class->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == acsh_brep_class->num_silhouettes)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.num_silhouettes [BL] %u != %u", acsh_brep_class->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == acsh_brep_class->num_silhouettes)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.num_silhouettes [BL] set+1 %u != %u", acsh_brep_class->num_silhouettes, num_silhouettes);
    acsh_brep_class->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_wires", &num_wires, NULL)
        && num_wires == acsh_brep_class->num_wires)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.num_wires [BL] %u != %u", acsh_brep_class->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_wires", &num_wires, 0)
        && num_wires == acsh_brep_class->num_wires)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.num_wires [BL] set+1 %u != %u", acsh_brep_class->num_wires, num_wires);
    acsh_brep_class->num_wires--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_brep_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "point", &point, NULL)
        && !memcmp (&point, &acsh_brep_class->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "point_present", &point_present, NULL)
        && point_present == acsh_brep_class->point_present)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.point_present [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "point_present", &point_present, 0)
        && point_present == acsh_brep_class->point_present)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->point_present, point_present);
    acsh_brep_class->point_present--;
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &acsh_brep_class->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &acsh_brep_class->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("ACSH_BREP_CLASS.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_major", &revision_major, NULL)
        && revision_major == acsh_brep_class->revision_major)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.revision_major [BL] %u != %u", acsh_brep_class->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_major", &revision_major, 0)
        && revision_major == acsh_brep_class->revision_major)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.revision_major [BL] set+1 %u != %u", acsh_brep_class->revision_major, revision_major);
    acsh_brep_class->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == acsh_brep_class->revision_minor1)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.revision_minor1 [BS] %hu != %hu", acsh_brep_class->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == acsh_brep_class->revision_minor1)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.revision_minor1 [BS] set+1 %hu != %hu", acsh_brep_class->revision_minor1, revision_minor1);
    acsh_brep_class->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == acsh_brep_class->revision_minor2)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.revision_minor2 [BS] %hu != %hu", acsh_brep_class->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == acsh_brep_class->revision_minor2)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.revision_minor2 [BS] set+1 %hu != %hu", acsh_brep_class->revision_minor2, revision_minor2);
    acsh_brep_class->revision_minor2--;
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "sab_size", &sab_size, NULL)
        && sab_size == acsh_brep_class->sab_size)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.sab_size [BL] %u != %u", acsh_brep_class->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "sab_size", &sab_size, 0)
        && sab_size == acsh_brep_class->sab_size)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.sab_size [BL] set+1 %u != %u", acsh_brep_class->sab_size, sab_size);
    acsh_brep_class->sab_size--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "silhouettes", &silhouettes, NULL)
        && silhouettes == acsh_brep_class->silhouettes)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "unknown", &unknown, NULL)
        && unknown == acsh_brep_class->unknown)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.unknown [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "unknown", &unknown, 0)
        && unknown == acsh_brep_class->unknown)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->unknown, unknown);
    acsh_brep_class->unknown--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "version", &version, NULL)
        && version == acsh_brep_class->version)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.version [BS] %hu != %hu", acsh_brep_class->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "version", &version, 0)
        && version == acsh_brep_class->version)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.version [BS] set+1 %hu != %hu", acsh_brep_class->version, version);
    acsh_brep_class->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == acsh_brep_class->wireframe_data_present)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == acsh_brep_class->wireframe_data_present)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->wireframe_data_present, wireframe_data_present);
    acsh_brep_class->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "wires", &wires, NULL)
        && wires == acsh_brep_class->wires)
      pass ();
    else
      fail ("ACSH_BREP_CLASS.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("ACSH_BREP_CLASS") || is_class_debugging ("ACSH_BREP_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_BREP_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_CHAMFER_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_CHAMFER_CLASS *restrict acsh_chamfer_class = obj->tio.object->tio.ACSH_CHAMFER_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_chamfer_class)
    {
      fail ("NULL ACSH_CHAMFER_CLASS");
      return 1;
    }
  {
    BITCODE_BD base_dist;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "base_dist", &base_dist, NULL)
        && base_dist == acsh_chamfer_class->base_dist)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.base_dist [BD] %g != %g", acsh_chamfer_class->base_dist, base_dist);
    base_dist++;
    if (dwg_dynapi_entity_set_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "base_dist", &base_dist, 0)
        && base_dist == acsh_chamfer_class->base_dist)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.base_dist [BD] set+1 %g != %g", acsh_chamfer_class->base_dist, base_dist);
    acsh_chamfer_class->base_dist--;
  }
  {
    BITCODE_BL bl92;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "bl92", &bl92, NULL)
        && bl92 == acsh_chamfer_class->bl92)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.bl92 [BL] %u != %u", acsh_chamfer_class->bl92, bl92);
    bl92++;
    if (dwg_dynapi_entity_set_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "bl92", &bl92, 0)
        && bl92 == acsh_chamfer_class->bl92)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.bl92 [BL] set+1 %u != %u", acsh_chamfer_class->bl92, bl92);
    acsh_chamfer_class->bl92--;
  }
  {
    BITCODE_BL bl95;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "bl95", &bl95, NULL)
        && bl95 == acsh_chamfer_class->bl95)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.bl95 [BL] %u != %u", acsh_chamfer_class->bl95, bl95);
    bl95++;
    if (dwg_dynapi_entity_set_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "bl95", &bl95, 0)
        && bl95 == acsh_chamfer_class->bl95)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.bl95 [BL] set+1 %u != %u", acsh_chamfer_class->bl95, bl95);
    acsh_chamfer_class->bl95--;
  }
  {
    BITCODE_BL* edges;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "num_edges", &count, NULL)
        && dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "edges", &edges, NULL)
        && edges == acsh_chamfer_class->edges)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.edges [BL*] * %u num_edges", count);
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_chamfer_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_CHAMFER_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_chamfer_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_CHAMFER_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "major", &major, NULL)
        && major == acsh_chamfer_class->major)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.major [BL] %u != %u", acsh_chamfer_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "major", &major, 0)
        && major == acsh_chamfer_class->major)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.major [BL] set+1 %u != %u", acsh_chamfer_class->major, major);
    acsh_chamfer_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "minor", &minor, NULL)
        && minor == acsh_chamfer_class->minor)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.minor [BL] %u != %u", acsh_chamfer_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "minor", &minor, 0)
        && minor == acsh_chamfer_class->minor)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.minor [BL] set+1 %u != %u", acsh_chamfer_class->minor, minor);
    acsh_chamfer_class->minor--;
  }
  {
    BITCODE_BL num_edges;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "num_edges", &num_edges, NULL)
        && num_edges == acsh_chamfer_class->num_edges)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.num_edges [BL] %u != %u", acsh_chamfer_class->num_edges, num_edges);
    num_edges++;
    if (dwg_dynapi_entity_set_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "num_edges", &num_edges, 0)
        && num_edges == acsh_chamfer_class->num_edges)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.num_edges [BL] set+1 %u != %u", acsh_chamfer_class->num_edges, num_edges);
    acsh_chamfer_class->num_edges--;
  }
  {
    BITCODE_BD other_dist;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "other_dist", &other_dist, NULL)
        && other_dist == acsh_chamfer_class->other_dist)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.other_dist [BD] %g != %g", acsh_chamfer_class->other_dist, other_dist);
    other_dist++;
    if (dwg_dynapi_entity_set_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "other_dist", &other_dist, 0)
        && other_dist == acsh_chamfer_class->other_dist)
      pass ();
    else
      fail ("ACSH_CHAMFER_CLASS.other_dist [BD] set+1 %g != %g", acsh_chamfer_class->other_dist, other_dist);
    acsh_chamfer_class->other_dist--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_chamfer_class, "ACSH_CHAMFER_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_chamfer_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_CHAMFER_CLASS.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ACSH_CHAMFER_CLASS") || is_class_debugging ("ACSH_CHAMFER_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_CHAMFER_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_CONE_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_CONE_CLASS *restrict acsh_cone_class = obj->tio.object->tio.ACSH_CONE_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_cone_class)
    {
      fail ("NULL ACSH_CONE_CLASS");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_cone_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_CONE_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "height", &height, NULL)
        && height == acsh_cone_class->height)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.height [BD] %g != %g", acsh_cone_class->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (acsh_cone_class, "ACSH_CONE_CLASS", "height", &height, 0)
        && height == acsh_cone_class->height)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.height [BD] set+1 %g != %g", acsh_cone_class->height, height);
    acsh_cone_class->height--;
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_cone_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_CONE_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "major", &major, NULL)
        && major == acsh_cone_class->major)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.major [BL] %u != %u", acsh_cone_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_cone_class, "ACSH_CONE_CLASS", "major", &major, 0)
        && major == acsh_cone_class->major)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.major [BL] set+1 %u != %u", acsh_cone_class->major, major);
    acsh_cone_class->major--;
  }
  {
    BITCODE_BD major_radius;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "major_radius", &major_radius, NULL)
        && major_radius == acsh_cone_class->major_radius)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.major_radius [BD] %g != %g", acsh_cone_class->major_radius, major_radius);
    major_radius++;
    if (dwg_dynapi_entity_set_value (acsh_cone_class, "ACSH_CONE_CLASS", "major_radius", &major_radius, 0)
        && major_radius == acsh_cone_class->major_radius)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.major_radius [BD] set+1 %g != %g", acsh_cone_class->major_radius, major_radius);
    acsh_cone_class->major_radius--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "minor", &minor, NULL)
        && minor == acsh_cone_class->minor)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.minor [BL] %u != %u", acsh_cone_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_cone_class, "ACSH_CONE_CLASS", "minor", &minor, 0)
        && minor == acsh_cone_class->minor)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.minor [BL] set+1 %u != %u", acsh_cone_class->minor, minor);
    acsh_cone_class->minor--;
  }
  {
    BITCODE_BD minor_radius;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "minor_radius", &minor_radius, NULL)
        && minor_radius == acsh_cone_class->minor_radius)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.minor_radius [BD] %g != %g", acsh_cone_class->minor_radius, minor_radius);
    minor_radius++;
    if (dwg_dynapi_entity_set_value (acsh_cone_class, "ACSH_CONE_CLASS", "minor_radius", &minor_radius, 0)
        && minor_radius == acsh_cone_class->minor_radius)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.minor_radius [BD] set+1 %g != %g", acsh_cone_class->minor_radius, minor_radius);
    acsh_cone_class->minor_radius--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_cone_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_CONE_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD x_radius;
    if (dwg_dynapi_entity_value (acsh_cone_class, "ACSH_CONE_CLASS", "x_radius", &x_radius, NULL)
        && x_radius == acsh_cone_class->x_radius)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.x_radius [BD] %g != %g", acsh_cone_class->x_radius, x_radius);
    x_radius++;
    if (dwg_dynapi_entity_set_value (acsh_cone_class, "ACSH_CONE_CLASS", "x_radius", &x_radius, 0)
        && x_radius == acsh_cone_class->x_radius)
      pass ();
    else
      fail ("ACSH_CONE_CLASS.x_radius [BD] set+1 %g != %g", acsh_cone_class->x_radius, x_radius);
    acsh_cone_class->x_radius--;
  }
  if (failed && (is_class_unstable ("ACSH_CONE_CLASS") || is_class_debugging ("ACSH_CONE_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_CONE_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_CYLINDER_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_CYLINDER_CLASS *restrict acsh_cylinder_class = obj->tio.object->tio.ACSH_CYLINDER_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_cylinder_class)
    {
      fail ("NULL ACSH_CYLINDER_CLASS");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_cylinder_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_CYLINDER_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "height", &height, NULL)
        && height == acsh_cylinder_class->height)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.height [BD] %g != %g", acsh_cylinder_class->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "height", &height, 0)
        && height == acsh_cylinder_class->height)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.height [BD] set+1 %g != %g", acsh_cylinder_class->height, height);
    acsh_cylinder_class->height--;
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_cylinder_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_CYLINDER_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "major", &major, NULL)
        && major == acsh_cylinder_class->major)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.major [BL] %u != %u", acsh_cylinder_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "major", &major, 0)
        && major == acsh_cylinder_class->major)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.major [BL] set+1 %u != %u", acsh_cylinder_class->major, major);
    acsh_cylinder_class->major--;
  }
  {
    BITCODE_BD major_radius;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "major_radius", &major_radius, NULL)
        && major_radius == acsh_cylinder_class->major_radius)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.major_radius [BD] %g != %g", acsh_cylinder_class->major_radius, major_radius);
    major_radius++;
    if (dwg_dynapi_entity_set_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "major_radius", &major_radius, 0)
        && major_radius == acsh_cylinder_class->major_radius)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.major_radius [BD] set+1 %g != %g", acsh_cylinder_class->major_radius, major_radius);
    acsh_cylinder_class->major_radius--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "minor", &minor, NULL)
        && minor == acsh_cylinder_class->minor)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.minor [BL] %u != %u", acsh_cylinder_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "minor", &minor, 0)
        && minor == acsh_cylinder_class->minor)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.minor [BL] set+1 %u != %u", acsh_cylinder_class->minor, minor);
    acsh_cylinder_class->minor--;
  }
  {
    BITCODE_BD minor_radius;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "minor_radius", &minor_radius, NULL)
        && minor_radius == acsh_cylinder_class->minor_radius)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.minor_radius [BD] %g != %g", acsh_cylinder_class->minor_radius, minor_radius);
    minor_radius++;
    if (dwg_dynapi_entity_set_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "minor_radius", &minor_radius, 0)
        && minor_radius == acsh_cylinder_class->minor_radius)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.minor_radius [BD] set+1 %g != %g", acsh_cylinder_class->minor_radius, minor_radius);
    acsh_cylinder_class->minor_radius--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_cylinder_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_CYLINDER_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD x_radius;
    if (dwg_dynapi_entity_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "x_radius", &x_radius, NULL)
        && x_radius == acsh_cylinder_class->x_radius)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.x_radius [BD] %g != %g", acsh_cylinder_class->x_radius, x_radius);
    x_radius++;
    if (dwg_dynapi_entity_set_value (acsh_cylinder_class, "ACSH_CYLINDER_CLASS", "x_radius", &x_radius, 0)
        && x_radius == acsh_cylinder_class->x_radius)
      pass ();
    else
      fail ("ACSH_CYLINDER_CLASS.x_radius [BD] set+1 %g != %g", acsh_cylinder_class->x_radius, x_radius);
    acsh_cylinder_class->x_radius--;
  }
  if (failed && (is_class_unstable ("ACSH_CYLINDER_CLASS") || is_class_debugging ("ACSH_CYLINDER_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_CYLINDER_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_EXTRUSION_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_EXTRUSION_CLASS *restrict acsh_extrusion_class = obj->tio.object->tio.ACSH_EXTRUSION_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_extrusion_class)
    {
      fail ("NULL ACSH_EXTRUSION_CLASS");
      return 1;
    }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "align_angle", &align_angle, NULL)
        && align_angle == acsh_extrusion_class->align_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.align_angle [BD] %g != %g", acsh_extrusion_class->align_angle, align_angle);
    align_angle++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "align_angle", &align_angle, 0)
        && align_angle == acsh_extrusion_class->align_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.align_angle [BD] set+1 %g != %g", acsh_extrusion_class->align_angle, align_angle);
    acsh_extrusion_class->align_angle--;
  }
  {
    BITCODE_RC align_option;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "align_option", &align_option, NULL)
        && align_option == acsh_extrusion_class->align_option)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.align_option [RC] %u != %u", acsh_extrusion_class->align_option, align_option);
    align_option++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "align_option", &align_option, 0)
        && align_option == acsh_extrusion_class->align_option)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.align_option [RC] set+1 %u != %u", acsh_extrusion_class->align_option, align_option);
    acsh_extrusion_class->align_option--;
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "bank", &bank, NULL)
        && bank == acsh_extrusion_class->bank)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.bank [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->bank, bank);
    bank++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "bank", &bank, 0)
        && bank == acsh_extrusion_class->bank)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->bank, bank);
    acsh_extrusion_class->bank--;
  }
  {
    BITCODE_BL bl92;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "bl92", &bl92, NULL)
        && bl92 == acsh_extrusion_class->bl92)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.bl92 [BL] %u != %u", acsh_extrusion_class->bl92, bl92);
    bl92++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "bl92", &bl92, 0)
        && bl92 == acsh_extrusion_class->bl92)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.bl92 [BL] set+1 %u != %u", acsh_extrusion_class->bl92, bl92);
    acsh_extrusion_class->bl92--;
  }
  {
    BITCODE_B check_intersections;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "check_intersections", &check_intersections, NULL)
        && check_intersections == acsh_extrusion_class->check_intersections)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.check_intersections [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->check_intersections, check_intersections);
    check_intersections++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "check_intersections", &check_intersections, 0)
        && check_intersections == acsh_extrusion_class->check_intersections)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.check_intersections [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->check_intersections, check_intersections);
    acsh_extrusion_class->check_intersections--;
  }
  {
    BITCODE_3BD direction;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "direction", &direction, NULL)
        && !memcmp (&direction, &acsh_extrusion_class->direction, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.direction [3BD]");
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "draft_angle", &draft_angle, NULL)
        && draft_angle == acsh_extrusion_class->draft_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.draft_angle [BD] %g != %g", acsh_extrusion_class->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "draft_angle", &draft_angle, 0)
        && draft_angle == acsh_extrusion_class->draft_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.draft_angle [BD] set+1 %g != %g", acsh_extrusion_class->draft_angle, draft_angle);
    acsh_extrusion_class->draft_angle--;
  }
  {
    BITCODE_BD end_draft_dist;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "end_draft_dist", &end_draft_dist, NULL)
        && end_draft_dist == acsh_extrusion_class->end_draft_dist)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.end_draft_dist [BD] %g != %g", acsh_extrusion_class->end_draft_dist, end_draft_dist);
    end_draft_dist++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "end_draft_dist", &end_draft_dist, 0)
        && end_draft_dist == acsh_extrusion_class->end_draft_dist)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.end_draft_dist [BD] set+1 %g != %g", acsh_extrusion_class->end_draft_dist, end_draft_dist);
    acsh_extrusion_class->end_draft_dist--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_extrusion_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_B has_align_start;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "has_align_start", &has_align_start, NULL)
        && has_align_start == acsh_extrusion_class->has_align_start)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.has_align_start [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->has_align_start, has_align_start);
    has_align_start++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "has_align_start", &has_align_start, 0)
        && has_align_start == acsh_extrusion_class->has_align_start)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.has_align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->has_align_start, has_align_start);
    acsh_extrusion_class->has_align_start--;
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_extrusion_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "major", &major, NULL)
        && major == acsh_extrusion_class->major)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.major [BL] %u != %u", acsh_extrusion_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "major", &major, 0)
        && major == acsh_extrusion_class->major)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.major [BL] set+1 %u != %u", acsh_extrusion_class->major, major);
    acsh_extrusion_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "minor", &minor, NULL)
        && minor == acsh_extrusion_class->minor)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.minor [BL] %u != %u", acsh_extrusion_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "minor", &minor, 0)
        && minor == acsh_extrusion_class->minor)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.minor [BL] set+1 %u != %u", acsh_extrusion_class->minor, minor);
    acsh_extrusion_class->minor--;
  }
  {
    BITCODE_RC miter_option;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "miter_option", &miter_option, NULL)
        && miter_option == acsh_extrusion_class->miter_option)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.miter_option [RC] %u != %u", acsh_extrusion_class->miter_option, miter_option);
    miter_option++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "miter_option", &miter_option, 0)
        && miter_option == acsh_extrusion_class->miter_option)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.miter_option [RC] set+1 %u != %u", acsh_extrusion_class->miter_option, miter_option);
    acsh_extrusion_class->miter_option--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_extrusion_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD* pathentity_transform;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "pathentity_transform", &pathentity_transform, NULL)
        && !memcmp (&pathentity_transform, &acsh_extrusion_class->pathentity_transform, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.pathentity_transform [BD*]");
  }
  {
    BITCODE_3BD pt2;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "pt2", &pt2, NULL)
        && !memcmp (&pt2, &acsh_extrusion_class->pt2, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.pt2 [3BD]");
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "scale_factor", &scale_factor, NULL)
        && scale_factor == acsh_extrusion_class->scale_factor)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.scale_factor [BD] %g != %g", acsh_extrusion_class->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "scale_factor", &scale_factor, 0)
        && scale_factor == acsh_extrusion_class->scale_factor)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.scale_factor [BD] set+1 %g != %g", acsh_extrusion_class->scale_factor, scale_factor);
    acsh_extrusion_class->scale_factor--;
  }
  {
    BITCODE_B shsw_b294;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b294", &shsw_b294, NULL)
        && shsw_b294 == acsh_extrusion_class->shsw_b294)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b294 [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b294, shsw_b294);
    shsw_b294++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b294", &shsw_b294, 0)
        && shsw_b294 == acsh_extrusion_class->shsw_b294)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b294 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b294, shsw_b294);
    acsh_extrusion_class->shsw_b294--;
  }
  {
    BITCODE_B shsw_b295;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b295", &shsw_b295, NULL)
        && shsw_b295 == acsh_extrusion_class->shsw_b295)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b295 [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b295, shsw_b295);
    shsw_b295++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b295", &shsw_b295, 0)
        && shsw_b295 == acsh_extrusion_class->shsw_b295)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b295 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b295, shsw_b295);
    acsh_extrusion_class->shsw_b295--;
  }
  {
    BITCODE_B shsw_b296;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b296", &shsw_b296, NULL)
        && shsw_b296 == acsh_extrusion_class->shsw_b296)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b296 [B] " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b296, shsw_b296);
    shsw_b296++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_b296", &shsw_b296, 0)
        && shsw_b296 == acsh_extrusion_class->shsw_b296)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_b296 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_extrusion_class->shsw_b296, shsw_b296);
    acsh_extrusion_class->shsw_b296--;
  }
  {
    BITCODE_BL shsw_bl93;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl93", &shsw_bl93, NULL)
        && shsw_bl93 == acsh_extrusion_class->shsw_bl93)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl93 [BL] %u != %u", acsh_extrusion_class->shsw_bl93, shsw_bl93);
    shsw_bl93++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_bl93", &shsw_bl93, 0)
        && shsw_bl93 == acsh_extrusion_class->shsw_bl93)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_bl93 [BL] set+1 %u != %u", acsh_extrusion_class->shsw_bl93, shsw_bl93);
    acsh_extrusion_class->shsw_bl93--;
  }
  {
    BITCODE_TF shsw_text;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text", &shsw_text, NULL)
        && !memcmp (&shsw_text, &acsh_extrusion_class->shsw_text, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.shsw_text [TF]");
  }
  {
    BITCODE_TF shsw_text2;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text2", &shsw_text2, NULL)
        && !memcmp (&shsw_text2, &acsh_extrusion_class->shsw_text2, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.shsw_text2 [TF]");
  }
  {
    BITCODE_BL shsw_text2_size;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text2_size", &shsw_text2_size, NULL)
        && shsw_text2_size == acsh_extrusion_class->shsw_text2_size)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_text2_size [BL] %u != %u", acsh_extrusion_class->shsw_text2_size, shsw_text2_size);
    shsw_text2_size++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text2_size", &shsw_text2_size, 0)
        && shsw_text2_size == acsh_extrusion_class->shsw_text2_size)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_text2_size [BL] set+1 %u != %u", acsh_extrusion_class->shsw_text2_size, shsw_text2_size);
    acsh_extrusion_class->shsw_text2_size--;
  }
  {
    BITCODE_BL shsw_text_size;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text_size", &shsw_text_size, NULL)
        && shsw_text_size == acsh_extrusion_class->shsw_text_size)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_text_size [BL] %u != %u", acsh_extrusion_class->shsw_text_size, shsw_text_size);
    shsw_text_size++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "shsw_text_size", &shsw_text_size, 0)
        && shsw_text_size == acsh_extrusion_class->shsw_text_size)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.shsw_text_size [BL] set+1 %u != %u", acsh_extrusion_class->shsw_text_size, shsw_text_size);
    acsh_extrusion_class->shsw_text_size--;
  }
  {
    BITCODE_BD start_draft_dist;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "start_draft_dist", &start_draft_dist, NULL)
        && start_draft_dist == acsh_extrusion_class->start_draft_dist)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.start_draft_dist [BD] %g != %g", acsh_extrusion_class->start_draft_dist, start_draft_dist);
    start_draft_dist++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "start_draft_dist", &start_draft_dist, 0)
        && start_draft_dist == acsh_extrusion_class->start_draft_dist)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.start_draft_dist [BD] set+1 %g != %g", acsh_extrusion_class->start_draft_dist, start_draft_dist);
    acsh_extrusion_class->start_draft_dist--;
  }
  {
    BITCODE_BD* sweepentity_transform;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "sweepentity_transform", &sweepentity_transform, NULL)
        && !memcmp (&sweepentity_transform, &acsh_extrusion_class->sweepentity_transform, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("ACSH_EXTRUSION_CLASS.sweepentity_transform [BD*]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "twist_angle", &twist_angle, NULL)
        && twist_angle == acsh_extrusion_class->twist_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.twist_angle [BD] %g != %g", acsh_extrusion_class->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (acsh_extrusion_class, "ACSH_EXTRUSION_CLASS", "twist_angle", &twist_angle, 0)
        && twist_angle == acsh_extrusion_class->twist_angle)
      pass ();
    else
      fail ("ACSH_EXTRUSION_CLASS.twist_angle [BD] set+1 %g != %g", acsh_extrusion_class->twist_angle, twist_angle);
    acsh_extrusion_class->twist_angle--;
  }
  if (failed && (is_class_unstable ("ACSH_EXTRUSION_CLASS") || is_class_debugging ("ACSH_EXTRUSION_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_EXTRUSION_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_FILLET_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_FILLET_CLASS *restrict acsh_fillet_class = obj->tio.object->tio.ACSH_FILLET_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_fillet_class)
    {
      fail ("NULL ACSH_FILLET_CLASS");
      return 1;
    }
  {
    BITCODE_BL bl92;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "bl92", &bl92, NULL)
        && bl92 == acsh_fillet_class->bl92)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.bl92 [BL] %u != %u", acsh_fillet_class->bl92, bl92);
    bl92++;
    if (dwg_dynapi_entity_set_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "bl92", &bl92, 0)
        && bl92 == acsh_fillet_class->bl92)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.bl92 [BL] set+1 %u != %u", acsh_fillet_class->bl92, bl92);
    acsh_fillet_class->bl92--;
  }
  {
    BITCODE_BL* edges;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_edges", &count, NULL)
        && dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "edges", &edges, NULL)
        && edges == acsh_fillet_class->edges)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.edges [BL*] * %u num_edges", count);
  }
  {
    BITCODE_BD* endsetbacks;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_endsetbacks", &count, NULL)
        && dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "endsetbacks", &endsetbacks, NULL)
        && endsetbacks == acsh_fillet_class->endsetbacks)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.endsetbacks [BD*] * %u num_endsetbacks", count);
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_fillet_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_FILLET_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_fillet_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_FILLET_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "major", &major, NULL)
        && major == acsh_fillet_class->major)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.major [BL] %u != %u", acsh_fillet_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "major", &major, 0)
        && major == acsh_fillet_class->major)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.major [BL] set+1 %u != %u", acsh_fillet_class->major, major);
    acsh_fillet_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "minor", &minor, NULL)
        && minor == acsh_fillet_class->minor)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.minor [BL] %u != %u", acsh_fillet_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "minor", &minor, 0)
        && minor == acsh_fillet_class->minor)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.minor [BL] set+1 %u != %u", acsh_fillet_class->minor, minor);
    acsh_fillet_class->minor--;
  }
  {
    BITCODE_BL num_edges;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_edges", &num_edges, NULL)
        && num_edges == acsh_fillet_class->num_edges)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.num_edges [BL] %u != %u", acsh_fillet_class->num_edges, num_edges);
    num_edges++;
    if (dwg_dynapi_entity_set_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_edges", &num_edges, 0)
        && num_edges == acsh_fillet_class->num_edges)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.num_edges [BL] set+1 %u != %u", acsh_fillet_class->num_edges, num_edges);
    acsh_fillet_class->num_edges--;
  }
  {
    BITCODE_BL num_endsetbacks;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_endsetbacks", &num_endsetbacks, NULL)
        && num_endsetbacks == acsh_fillet_class->num_endsetbacks)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.num_endsetbacks [BL] %u != %u", acsh_fillet_class->num_endsetbacks, num_endsetbacks);
    num_endsetbacks++;
    if (dwg_dynapi_entity_set_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_endsetbacks", &num_endsetbacks, 0)
        && num_endsetbacks == acsh_fillet_class->num_endsetbacks)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.num_endsetbacks [BL] set+1 %u != %u", acsh_fillet_class->num_endsetbacks, num_endsetbacks);
    acsh_fillet_class->num_endsetbacks--;
  }
  {
    BITCODE_BL num_radiuses;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_radiuses", &num_radiuses, NULL)
        && num_radiuses == acsh_fillet_class->num_radiuses)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.num_radiuses [BL] %u != %u", acsh_fillet_class->num_radiuses, num_radiuses);
    num_radiuses++;
    if (dwg_dynapi_entity_set_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_radiuses", &num_radiuses, 0)
        && num_radiuses == acsh_fillet_class->num_radiuses)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.num_radiuses [BL] set+1 %u != %u", acsh_fillet_class->num_radiuses, num_radiuses);
    acsh_fillet_class->num_radiuses--;
  }
  {
    BITCODE_BL num_startsetbacks;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_startsetbacks", &num_startsetbacks, NULL)
        && num_startsetbacks == acsh_fillet_class->num_startsetbacks)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.num_startsetbacks [BL] %u != %u", acsh_fillet_class->num_startsetbacks, num_startsetbacks);
    num_startsetbacks++;
    if (dwg_dynapi_entity_set_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_startsetbacks", &num_startsetbacks, 0)
        && num_startsetbacks == acsh_fillet_class->num_startsetbacks)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.num_startsetbacks [BL] set+1 %u != %u", acsh_fillet_class->num_startsetbacks, num_startsetbacks);
    acsh_fillet_class->num_startsetbacks--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_fillet_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_FILLET_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD* radiuses;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_radiuses", &count, NULL)
        && dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "radiuses", &radiuses, NULL)
        && radiuses == acsh_fillet_class->radiuses)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.radiuses [BD*] * %u num_radiuses", count);
  }
  {
    BITCODE_BD* startsetbacks;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "num_startsetbacks", &count, NULL)
        && dwg_dynapi_entity_value (acsh_fillet_class, "ACSH_FILLET_CLASS", "startsetbacks", &startsetbacks, NULL)
        && startsetbacks == acsh_fillet_class->startsetbacks)
      pass ();
    else
      fail ("ACSH_FILLET_CLASS.startsetbacks [BD*] * %u num_startsetbacks", count);
  }
  if (failed && (is_class_unstable ("ACSH_FILLET_CLASS") || is_class_debugging ("ACSH_FILLET_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_FILLET_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_HISTORY_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_HISTORY_CLASS *restrict acsh_history_class = obj->tio.object->tio.ACSH_HISTORY_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_history_class)
    {
      fail ("NULL ACSH_HISTORY_CLASS");
      return 1;
    }
  {
    BITCODE_BL h_nodeid;
    if (dwg_dynapi_entity_value (acsh_history_class, "ACSH_HISTORY_CLASS", "h_nodeid", &h_nodeid, NULL)
        && h_nodeid == acsh_history_class->h_nodeid)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.h_nodeid [BL] %u != %u", acsh_history_class->h_nodeid, h_nodeid);
    h_nodeid++;
    if (dwg_dynapi_entity_set_value (acsh_history_class, "ACSH_HISTORY_CLASS", "h_nodeid", &h_nodeid, 0)
        && h_nodeid == acsh_history_class->h_nodeid)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.h_nodeid [BL] set+1 %u != %u", acsh_history_class->h_nodeid, h_nodeid);
    acsh_history_class->h_nodeid--;
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_history_class, "ACSH_HISTORY_CLASS", "major", &major, NULL)
        && major == acsh_history_class->major)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.major [BL] %u != %u", acsh_history_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_history_class, "ACSH_HISTORY_CLASS", "major", &major, 0)
        && major == acsh_history_class->major)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.major [BL] set+1 %u != %u", acsh_history_class->major, major);
    acsh_history_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_history_class, "ACSH_HISTORY_CLASS", "minor", &minor, NULL)
        && minor == acsh_history_class->minor)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.minor [BL] %u != %u", acsh_history_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_history_class, "ACSH_HISTORY_CLASS", "minor", &minor, 0)
        && minor == acsh_history_class->minor)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.minor [BL] set+1 %u != %u", acsh_history_class->minor, minor);
    acsh_history_class->minor--;
  }
  {
    BITCODE_H owner;
    if (dwg_dynapi_entity_value (acsh_history_class, "ACSH_HISTORY_CLASS", "owner", &owner, NULL)
        && !memcmp (&owner, &acsh_history_class->owner, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ACSH_HISTORY_CLASS.owner [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_history_class, "ACSH_HISTORY_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_history_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_HISTORY_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B record_history;
    if (dwg_dynapi_entity_value (acsh_history_class, "ACSH_HISTORY_CLASS", "record_history", &record_history, NULL)
        && record_history == acsh_history_class->record_history)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.record_history [B] " FORMAT_B " != " FORMAT_B "", acsh_history_class->record_history, record_history);
    record_history++;
    if (dwg_dynapi_entity_set_value (acsh_history_class, "ACSH_HISTORY_CLASS", "record_history", &record_history, 0)
        && record_history == acsh_history_class->record_history)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.record_history [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_history_class->record_history, record_history);
    acsh_history_class->record_history--;
  }
  {
    BITCODE_B show_history;
    if (dwg_dynapi_entity_value (acsh_history_class, "ACSH_HISTORY_CLASS", "show_history", &show_history, NULL)
        && show_history == acsh_history_class->show_history)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.show_history [B] " FORMAT_B " != " FORMAT_B "", acsh_history_class->show_history, show_history);
    show_history++;
    if (dwg_dynapi_entity_set_value (acsh_history_class, "ACSH_HISTORY_CLASS", "show_history", &show_history, 0)
        && show_history == acsh_history_class->show_history)
      pass ();
    else
      fail ("ACSH_HISTORY_CLASS.show_history [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_history_class->show_history, show_history);
    acsh_history_class->show_history--;
  }
  if (failed && (is_class_unstable ("ACSH_HISTORY_CLASS") || is_class_debugging ("ACSH_HISTORY_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_HISTORY_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_LOFT_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_LOFT_CLASS *restrict acsh_loft_class = obj->tio.object->tio.ACSH_LOFT_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_loft_class)
    {
      fail ("NULL ACSH_LOFT_CLASS");
      return 1;
    }
  {
    BITCODE_H* crosssects;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "num_crosssects", &count, NULL)
        && dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "crosssects", &crosssects, NULL)
        && crosssects == acsh_loft_class->crosssects)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.crosssects [H*] * %u num_crosssects", count);
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_loft_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_LOFT_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_H* guides;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "num_guides", &count, NULL)
        && dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "guides", &guides, NULL)
        && guides == acsh_loft_class->guides)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.guides [H*] * %u num_guides", count);
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_loft_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_LOFT_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "major", &major, NULL)
        && major == acsh_loft_class->major)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.major [BL] %u != %u", acsh_loft_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_loft_class, "ACSH_LOFT_CLASS", "major", &major, 0)
        && major == acsh_loft_class->major)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.major [BL] set+1 %u != %u", acsh_loft_class->major, major);
    acsh_loft_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "minor", &minor, NULL)
        && minor == acsh_loft_class->minor)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.minor [BL] %u != %u", acsh_loft_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_loft_class, "ACSH_LOFT_CLASS", "minor", &minor, 0)
        && minor == acsh_loft_class->minor)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.minor [BL] set+1 %u != %u", acsh_loft_class->minor, minor);
    acsh_loft_class->minor--;
  }
  {
    BITCODE_BL num_crosssects;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "num_crosssects", &num_crosssects, NULL)
        && num_crosssects == acsh_loft_class->num_crosssects)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.num_crosssects [BL] %u != %u", acsh_loft_class->num_crosssects, num_crosssects);
    num_crosssects++;
    if (dwg_dynapi_entity_set_value (acsh_loft_class, "ACSH_LOFT_CLASS", "num_crosssects", &num_crosssects, 0)
        && num_crosssects == acsh_loft_class->num_crosssects)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.num_crosssects [BL] set+1 %u != %u", acsh_loft_class->num_crosssects, num_crosssects);
    acsh_loft_class->num_crosssects--;
  }
  {
    BITCODE_BL num_guides;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "num_guides", &num_guides, NULL)
        && num_guides == acsh_loft_class->num_guides)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.num_guides [BL] %u != %u", acsh_loft_class->num_guides, num_guides);
    num_guides++;
    if (dwg_dynapi_entity_set_value (acsh_loft_class, "ACSH_LOFT_CLASS", "num_guides", &num_guides, 0)
        && num_guides == acsh_loft_class->num_guides)
      pass ();
    else
      fail ("ACSH_LOFT_CLASS.num_guides [BL] set+1 %u != %u", acsh_loft_class->num_guides, num_guides);
    acsh_loft_class->num_guides--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_loft_class, "ACSH_LOFT_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_loft_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_LOFT_CLASS.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ACSH_LOFT_CLASS") || is_class_debugging ("ACSH_LOFT_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_LOFT_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_PYRAMID_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_PYRAMID_CLASS *restrict acsh_pyramid_class = obj->tio.object->tio.ACSH_PYRAMID_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_pyramid_class)
    {
      fail ("NULL ACSH_PYRAMID_CLASS");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_pyramid_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_PYRAMID_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "height", &height, NULL)
        && height == acsh_pyramid_class->height)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.height [BD] %g != %g", acsh_pyramid_class->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "height", &height, 0)
        && height == acsh_pyramid_class->height)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.height [BD] set+1 %g != %g", acsh_pyramid_class->height, height);
    acsh_pyramid_class->height--;
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_pyramid_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_PYRAMID_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "major", &major, NULL)
        && major == acsh_pyramid_class->major)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.major [BL] %u != %u", acsh_pyramid_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "major", &major, 0)
        && major == acsh_pyramid_class->major)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.major [BL] set+1 %u != %u", acsh_pyramid_class->major, major);
    acsh_pyramid_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "minor", &minor, NULL)
        && minor == acsh_pyramid_class->minor)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.minor [BL] %u != %u", acsh_pyramid_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "minor", &minor, 0)
        && minor == acsh_pyramid_class->minor)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.minor [BL] set+1 %u != %u", acsh_pyramid_class->minor, minor);
    acsh_pyramid_class->minor--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_pyramid_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_PYRAMID_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "radius", &radius, NULL)
        && radius == acsh_pyramid_class->radius)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.radius [BD] %g != %g", acsh_pyramid_class->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "radius", &radius, 0)
        && radius == acsh_pyramid_class->radius)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.radius [BD] set+1 %g != %g", acsh_pyramid_class->radius, radius);
    acsh_pyramid_class->radius--;
  }
  {
    BITCODE_BL sides;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "sides", &sides, NULL)
        && sides == acsh_pyramid_class->sides)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.sides [BL] %u != %u", acsh_pyramid_class->sides, sides);
    sides++;
    if (dwg_dynapi_entity_set_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "sides", &sides, 0)
        && sides == acsh_pyramid_class->sides)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.sides [BL] set+1 %u != %u", acsh_pyramid_class->sides, sides);
    acsh_pyramid_class->sides--;
  }
  {
    BITCODE_BD topradius;
    if (dwg_dynapi_entity_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "topradius", &topradius, NULL)
        && topradius == acsh_pyramid_class->topradius)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.topradius [BD] %g != %g", acsh_pyramid_class->topradius, topradius);
    topradius++;
    if (dwg_dynapi_entity_set_value (acsh_pyramid_class, "ACSH_PYRAMID_CLASS", "topradius", &topradius, 0)
        && topradius == acsh_pyramid_class->topradius)
      pass ();
    else
      fail ("ACSH_PYRAMID_CLASS.topradius [BD] set+1 %g != %g", acsh_pyramid_class->topradius, topradius);
    acsh_pyramid_class->topradius--;
  }
  if (failed && (is_class_unstable ("ACSH_PYRAMID_CLASS") || is_class_debugging ("ACSH_PYRAMID_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_PYRAMID_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_REVOLVE_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_REVOLVE_CLASS *restrict acsh_revolve_class = obj->tio.object->tio.ACSH_REVOLVE_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_revolve_class)
    {
      fail ("NULL ACSH_REVOLVE_CLASS");
      return 1;
    }
  {
    BITCODE_3BD axis_pt;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "axis_pt", &axis_pt, NULL)
        && !memcmp (&axis_pt, &acsh_revolve_class->axis_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ACSH_REVOLVE_CLASS.axis_pt [3BD]");
  }
  {
    BITCODE_B b290;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "b290", &b290, NULL)
        && b290 == acsh_revolve_class->b290)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.b290 [B] " FORMAT_B " != " FORMAT_B "", acsh_revolve_class->b290, b290);
    b290++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "b290", &b290, 0)
        && b290 == acsh_revolve_class->b290)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.b290 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_revolve_class->b290, b290);
    acsh_revolve_class->b290--;
  }
  {
    BITCODE_BD bd44;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "bd44", &bd44, NULL)
        && bd44 == acsh_revolve_class->bd44)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.bd44 [BD] %g != %g", acsh_revolve_class->bd44, bd44);
    bd44++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "bd44", &bd44, 0)
        && bd44 == acsh_revolve_class->bd44)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.bd44 [BD] set+1 %g != %g", acsh_revolve_class->bd44, bd44);
    acsh_revolve_class->bd44--;
  }
  {
    BITCODE_BD bd45;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "bd45", &bd45, NULL)
        && bd45 == acsh_revolve_class->bd45)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.bd45 [BD] %g != %g", acsh_revolve_class->bd45, bd45);
    bd45++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "bd45", &bd45, 0)
        && bd45 == acsh_revolve_class->bd45)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.bd45 [BD] set+1 %g != %g", acsh_revolve_class->bd45, bd45);
    acsh_revolve_class->bd45--;
  }
  {
    BITCODE_2RD direction;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "direction", &direction, NULL)
        && !memcmp (&direction, &acsh_revolve_class->direction, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("ACSH_REVOLVE_CLASS.direction [2RD]");
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "draft_angle", &draft_angle, NULL)
        && draft_angle == acsh_revolve_class->draft_angle)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.draft_angle [BD] %g != %g", acsh_revolve_class->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "draft_angle", &draft_angle, 0)
        && draft_angle == acsh_revolve_class->draft_angle)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.draft_angle [BD] set+1 %g != %g", acsh_revolve_class->draft_angle, draft_angle);
    acsh_revolve_class->draft_angle--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_revolve_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_REVOLVE_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_revolve_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_REVOLVE_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_B is_close_to_axis;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "is_close_to_axis", &is_close_to_axis, NULL)
        && is_close_to_axis == acsh_revolve_class->is_close_to_axis)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.is_close_to_axis [B] " FORMAT_B " != " FORMAT_B "", acsh_revolve_class->is_close_to_axis, is_close_to_axis);
    is_close_to_axis++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "is_close_to_axis", &is_close_to_axis, 0)
        && is_close_to_axis == acsh_revolve_class->is_close_to_axis)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.is_close_to_axis [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_revolve_class->is_close_to_axis, is_close_to_axis);
    acsh_revolve_class->is_close_to_axis--;
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "major", &major, NULL)
        && major == acsh_revolve_class->major)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.major [BL] %u != %u", acsh_revolve_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "major", &major, 0)
        && major == acsh_revolve_class->major)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.major [BL] set+1 %u != %u", acsh_revolve_class->major, major);
    acsh_revolve_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "minor", &minor, NULL)
        && minor == acsh_revolve_class->minor)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.minor [BL] %u != %u", acsh_revolve_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "minor", &minor, 0)
        && minor == acsh_revolve_class->minor)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.minor [BL] set+1 %u != %u", acsh_revolve_class->minor, minor);
    acsh_revolve_class->minor--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_revolve_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_REVOLVE_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD revolve_angle;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "revolve_angle", &revolve_angle, NULL)
        && revolve_angle == acsh_revolve_class->revolve_angle)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.revolve_angle [BD] %g != %g", acsh_revolve_class->revolve_angle, revolve_angle);
    revolve_angle++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "revolve_angle", &revolve_angle, 0)
        && revolve_angle == acsh_revolve_class->revolve_angle)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.revolve_angle [BD] set+1 %g != %g", acsh_revolve_class->revolve_angle, revolve_angle);
    acsh_revolve_class->revolve_angle--;
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "start_angle", &start_angle, NULL)
        && start_angle == acsh_revolve_class->start_angle)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.start_angle [BD] %g != %g", acsh_revolve_class->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "start_angle", &start_angle, 0)
        && start_angle == acsh_revolve_class->start_angle)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.start_angle [BD] set+1 %g != %g", acsh_revolve_class->start_angle, start_angle);
    acsh_revolve_class->start_angle--;
  }
  {
    BITCODE_H sweep_entity;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "sweep_entity", &sweep_entity, NULL)
        && !memcmp (&sweep_entity, &acsh_revolve_class->sweep_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ACSH_REVOLVE_CLASS.sweep_entity [H]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "twist_angle", &twist_angle, NULL)
        && twist_angle == acsh_revolve_class->twist_angle)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.twist_angle [BD] %g != %g", acsh_revolve_class->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (acsh_revolve_class, "ACSH_REVOLVE_CLASS", "twist_angle", &twist_angle, 0)
        && twist_angle == acsh_revolve_class->twist_angle)
      pass ();
    else
      fail ("ACSH_REVOLVE_CLASS.twist_angle [BD] set+1 %g != %g", acsh_revolve_class->twist_angle, twist_angle);
    acsh_revolve_class->twist_angle--;
  }
  if (failed && (is_class_unstable ("ACSH_REVOLVE_CLASS") || is_class_debugging ("ACSH_REVOLVE_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_REVOLVE_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_SPHERE_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_SPHERE_CLASS *restrict acsh_sphere_class = obj->tio.object->tio.ACSH_SPHERE_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_sphere_class)
    {
      fail ("NULL ACSH_SPHERE_CLASS");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_sphere_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_SPHERE_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_sphere_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_SPHERE_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "major", &major, NULL)
        && major == acsh_sphere_class->major)
      pass ();
    else
      fail ("ACSH_SPHERE_CLASS.major [BL] %u != %u", acsh_sphere_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "major", &major, 0)
        && major == acsh_sphere_class->major)
      pass ();
    else
      fail ("ACSH_SPHERE_CLASS.major [BL] set+1 %u != %u", acsh_sphere_class->major, major);
    acsh_sphere_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "minor", &minor, NULL)
        && minor == acsh_sphere_class->minor)
      pass ();
    else
      fail ("ACSH_SPHERE_CLASS.minor [BL] %u != %u", acsh_sphere_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "minor", &minor, 0)
        && minor == acsh_sphere_class->minor)
      pass ();
    else
      fail ("ACSH_SPHERE_CLASS.minor [BL] set+1 %u != %u", acsh_sphere_class->minor, minor);
    acsh_sphere_class->minor--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_sphere_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_SPHERE_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "radius", &radius, NULL)
        && radius == acsh_sphere_class->radius)
      pass ();
    else
      fail ("ACSH_SPHERE_CLASS.radius [BD] %g != %g", acsh_sphere_class->radius, radius);
    radius++;
    if (dwg_dynapi_entity_set_value (acsh_sphere_class, "ACSH_SPHERE_CLASS", "radius", &radius, 0)
        && radius == acsh_sphere_class->radius)
      pass ();
    else
      fail ("ACSH_SPHERE_CLASS.radius [BD] set+1 %g != %g", acsh_sphere_class->radius, radius);
    acsh_sphere_class->radius--;
  }
  if (failed && (is_class_unstable ("ACSH_SPHERE_CLASS") || is_class_debugging ("ACSH_SPHERE_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_SPHERE_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_SWEEP_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_SWEEP_CLASS *restrict acsh_sweep_class = obj->tio.object->tio.ACSH_SWEEP_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_sweep_class)
    {
      fail ("NULL ACSH_SWEEP_CLASS");
      return 1;
    }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_angle", &align_angle, NULL)
        && align_angle == acsh_sweep_class->align_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.align_angle [BD] %g != %g", acsh_sweep_class->align_angle, align_angle);
    align_angle++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_angle", &align_angle, 0)
        && align_angle == acsh_sweep_class->align_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.align_angle [BD] set+1 %g != %g", acsh_sweep_class->align_angle, align_angle);
    acsh_sweep_class->align_angle--;
  }
  {
    BITCODE_RC align_option;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_option", &align_option, NULL)
        && align_option == acsh_sweep_class->align_option)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.align_option [RC] %u != %u", acsh_sweep_class->align_option, align_option);
    align_option++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_option", &align_option, 0)
        && align_option == acsh_sweep_class->align_option)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.align_option [RC] set+1 %u != %u", acsh_sweep_class->align_option, align_option);
    acsh_sweep_class->align_option--;
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "bank", &bank, NULL)
        && bank == acsh_sweep_class->bank)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.bank [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->bank, bank);
    bank++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "bank", &bank, 0)
        && bank == acsh_sweep_class->bank)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->bank, bank);
    acsh_sweep_class->bank--;
  }
  {
    BITCODE_BL bl92;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "bl92", &bl92, NULL)
        && bl92 == acsh_sweep_class->bl92)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.bl92 [BL] %u != %u", acsh_sweep_class->bl92, bl92);
    bl92++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "bl92", &bl92, 0)
        && bl92 == acsh_sweep_class->bl92)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.bl92 [BL] set+1 %u != %u", acsh_sweep_class->bl92, bl92);
    acsh_sweep_class->bl92--;
  }
  {
    BITCODE_B check_intersections;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "check_intersections", &check_intersections, NULL)
        && check_intersections == acsh_sweep_class->check_intersections)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.check_intersections [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->check_intersections, check_intersections);
    check_intersections++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "check_intersections", &check_intersections, 0)
        && check_intersections == acsh_sweep_class->check_intersections)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.check_intersections [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->check_intersections, check_intersections);
    acsh_sweep_class->check_intersections--;
  }
  {
    BITCODE_3BD direction;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "direction", &direction, NULL)
        && !memcmp (&direction, &acsh_sweep_class->direction, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.direction [3BD]");
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "draft_angle", &draft_angle, NULL)
        && draft_angle == acsh_sweep_class->draft_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.draft_angle [BD] %g != %g", acsh_sweep_class->draft_angle, draft_angle);
    draft_angle++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "draft_angle", &draft_angle, 0)
        && draft_angle == acsh_sweep_class->draft_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.draft_angle [BD] set+1 %g != %g", acsh_sweep_class->draft_angle, draft_angle);
    acsh_sweep_class->draft_angle--;
  }
  {
    BITCODE_BD end_draft_dist;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "end_draft_dist", &end_draft_dist, NULL)
        && end_draft_dist == acsh_sweep_class->end_draft_dist)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.end_draft_dist [BD] %g != %g", acsh_sweep_class->end_draft_dist, end_draft_dist);
    end_draft_dist++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "end_draft_dist", &end_draft_dist, 0)
        && end_draft_dist == acsh_sweep_class->end_draft_dist)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.end_draft_dist [BD] set+1 %g != %g", acsh_sweep_class->end_draft_dist, end_draft_dist);
    acsh_sweep_class->end_draft_dist--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_sweep_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_B has_align_start;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "has_align_start", &has_align_start, NULL)
        && has_align_start == acsh_sweep_class->has_align_start)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.has_align_start [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->has_align_start, has_align_start);
    has_align_start++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "has_align_start", &has_align_start, 0)
        && has_align_start == acsh_sweep_class->has_align_start)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.has_align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->has_align_start, has_align_start);
    acsh_sweep_class->has_align_start--;
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_sweep_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "major", &major, NULL)
        && major == acsh_sweep_class->major)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.major [BL] %u != %u", acsh_sweep_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "major", &major, 0)
        && major == acsh_sweep_class->major)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.major [BL] set+1 %u != %u", acsh_sweep_class->major, major);
    acsh_sweep_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "minor", &minor, NULL)
        && minor == acsh_sweep_class->minor)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.minor [BL] %u != %u", acsh_sweep_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "minor", &minor, 0)
        && minor == acsh_sweep_class->minor)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.minor [BL] set+1 %u != %u", acsh_sweep_class->minor, minor);
    acsh_sweep_class->minor--;
  }
  {
    BITCODE_RC miter_option;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "miter_option", &miter_option, NULL)
        && miter_option == acsh_sweep_class->miter_option)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.miter_option [RC] %u != %u", acsh_sweep_class->miter_option, miter_option);
    miter_option++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "miter_option", &miter_option, 0)
        && miter_option == acsh_sweep_class->miter_option)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.miter_option [RC] set+1 %u != %u", acsh_sweep_class->miter_option, miter_option);
    acsh_sweep_class->miter_option--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_sweep_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD* pathentity_transform;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "pathentity_transform", &pathentity_transform, NULL)
        && !memcmp (&pathentity_transform, &acsh_sweep_class->pathentity_transform, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.pathentity_transform [BD*]");
  }
  {
    BITCODE_3BD pt2;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "pt2", &pt2, NULL)
        && !memcmp (&pt2, &acsh_sweep_class->pt2, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.pt2 [3BD]");
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "scale_factor", &scale_factor, NULL)
        && scale_factor == acsh_sweep_class->scale_factor)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.scale_factor [BD] %g != %g", acsh_sweep_class->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "scale_factor", &scale_factor, 0)
        && scale_factor == acsh_sweep_class->scale_factor)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.scale_factor [BD] set+1 %g != %g", acsh_sweep_class->scale_factor, scale_factor);
    acsh_sweep_class->scale_factor--;
  }
  {
    BITCODE_B shsw_b294;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b294", &shsw_b294, NULL)
        && shsw_b294 == acsh_sweep_class->shsw_b294)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b294 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b294, shsw_b294);
    shsw_b294++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b294", &shsw_b294, 0)
        && shsw_b294 == acsh_sweep_class->shsw_b294)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b294 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b294, shsw_b294);
    acsh_sweep_class->shsw_b294--;
  }
  {
    BITCODE_B shsw_b295;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b295", &shsw_b295, NULL)
        && shsw_b295 == acsh_sweep_class->shsw_b295)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b295 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b295, shsw_b295);
    shsw_b295++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b295", &shsw_b295, 0)
        && shsw_b295 == acsh_sweep_class->shsw_b295)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b295 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b295, shsw_b295);
    acsh_sweep_class->shsw_b295--;
  }
  {
    BITCODE_B shsw_b296;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b296", &shsw_b296, NULL)
        && shsw_b296 == acsh_sweep_class->shsw_b296)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b296 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b296, shsw_b296);
    shsw_b296++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b296", &shsw_b296, 0)
        && shsw_b296 == acsh_sweep_class->shsw_b296)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_b296 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b296, shsw_b296);
    acsh_sweep_class->shsw_b296--;
  }
  {
    BITCODE_BL shsw_bl93;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl93", &shsw_bl93, NULL)
        && shsw_bl93 == acsh_sweep_class->shsw_bl93)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] %u != %u", acsh_sweep_class->shsw_bl93, shsw_bl93);
    shsw_bl93++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl93", &shsw_bl93, 0)
        && shsw_bl93 == acsh_sweep_class->shsw_bl93)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] set+1 %u != %u", acsh_sweep_class->shsw_bl93, shsw_bl93);
    acsh_sweep_class->shsw_bl93--;
  }
  {
    BITCODE_TF shsw_text;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text", &shsw_text, NULL)
        && !memcmp (&shsw_text, &acsh_sweep_class->shsw_text, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.shsw_text [TF]");
  }
  {
    BITCODE_TF shsw_text2;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text2", &shsw_text2, NULL)
        && !memcmp (&shsw_text2, &acsh_sweep_class->shsw_text2, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.shsw_text2 [TF]");
  }
  {
    BITCODE_BL shsw_text2_size;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text2_size", &shsw_text2_size, NULL)
        && shsw_text2_size == acsh_sweep_class->shsw_text2_size)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_text2_size [BL] %u != %u", acsh_sweep_class->shsw_text2_size, shsw_text2_size);
    shsw_text2_size++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text2_size", &shsw_text2_size, 0)
        && shsw_text2_size == acsh_sweep_class->shsw_text2_size)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_text2_size [BL] set+1 %u != %u", acsh_sweep_class->shsw_text2_size, shsw_text2_size);
    acsh_sweep_class->shsw_text2_size--;
  }
  {
    BITCODE_BL shsw_text_size;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text_size", &shsw_text_size, NULL)
        && shsw_text_size == acsh_sweep_class->shsw_text_size)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_text_size [BL] %u != %u", acsh_sweep_class->shsw_text_size, shsw_text_size);
    shsw_text_size++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text_size", &shsw_text_size, 0)
        && shsw_text_size == acsh_sweep_class->shsw_text_size)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.shsw_text_size [BL] set+1 %u != %u", acsh_sweep_class->shsw_text_size, shsw_text_size);
    acsh_sweep_class->shsw_text_size--;
  }
  {
    BITCODE_BD start_draft_dist;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "start_draft_dist", &start_draft_dist, NULL)
        && start_draft_dist == acsh_sweep_class->start_draft_dist)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.start_draft_dist [BD] %g != %g", acsh_sweep_class->start_draft_dist, start_draft_dist);
    start_draft_dist++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "start_draft_dist", &start_draft_dist, 0)
        && start_draft_dist == acsh_sweep_class->start_draft_dist)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.start_draft_dist [BD] set+1 %g != %g", acsh_sweep_class->start_draft_dist, start_draft_dist);
    acsh_sweep_class->start_draft_dist--;
  }
  {
    BITCODE_BD* sweepentity_transform;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "sweepentity_transform", &sweepentity_transform, NULL)
        && !memcmp (&sweepentity_transform, &acsh_sweep_class->sweepentity_transform, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("ACSH_SWEEP_CLASS.sweepentity_transform [BD*]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "twist_angle", &twist_angle, NULL)
        && twist_angle == acsh_sweep_class->twist_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.twist_angle [BD] %g != %g", acsh_sweep_class->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (acsh_sweep_class, "ACSH_SWEEP_CLASS", "twist_angle", &twist_angle, 0)
        && twist_angle == acsh_sweep_class->twist_angle)
      pass ();
    else
      fail ("ACSH_SWEEP_CLASS.twist_angle [BD] set+1 %g != %g", acsh_sweep_class->twist_angle, twist_angle);
    acsh_sweep_class->twist_angle--;
  }
  if (failed && (is_class_unstable ("ACSH_SWEEP_CLASS") || is_class_debugging ("ACSH_SWEEP_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_SWEEP_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_TORUS_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_TORUS_CLASS *restrict acsh_torus_class = obj->tio.object->tio.ACSH_TORUS_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_torus_class)
    {
      fail ("NULL ACSH_TORUS_CLASS");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_torus_class, "ACSH_TORUS_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_torus_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_TORUS_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_torus_class, "ACSH_TORUS_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_torus_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_TORUS_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_torus_class, "ACSH_TORUS_CLASS", "major", &major, NULL)
        && major == acsh_torus_class->major)
      pass ();
    else
      fail ("ACSH_TORUS_CLASS.major [BL] %u != %u", acsh_torus_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_torus_class, "ACSH_TORUS_CLASS", "major", &major, 0)
        && major == acsh_torus_class->major)
      pass ();
    else
      fail ("ACSH_TORUS_CLASS.major [BL] set+1 %u != %u", acsh_torus_class->major, major);
    acsh_torus_class->major--;
  }
  {
    BITCODE_BD major_radius;
    if (dwg_dynapi_entity_value (acsh_torus_class, "ACSH_TORUS_CLASS", "major_radius", &major_radius, NULL)
        && major_radius == acsh_torus_class->major_radius)
      pass ();
    else
      fail ("ACSH_TORUS_CLASS.major_radius [BD] %g != %g", acsh_torus_class->major_radius, major_radius);
    major_radius++;
    if (dwg_dynapi_entity_set_value (acsh_torus_class, "ACSH_TORUS_CLASS", "major_radius", &major_radius, 0)
        && major_radius == acsh_torus_class->major_radius)
      pass ();
    else
      fail ("ACSH_TORUS_CLASS.major_radius [BD] set+1 %g != %g", acsh_torus_class->major_radius, major_radius);
    acsh_torus_class->major_radius--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_torus_class, "ACSH_TORUS_CLASS", "minor", &minor, NULL)
        && minor == acsh_torus_class->minor)
      pass ();
    else
      fail ("ACSH_TORUS_CLASS.minor [BL] %u != %u", acsh_torus_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_torus_class, "ACSH_TORUS_CLASS", "minor", &minor, 0)
        && minor == acsh_torus_class->minor)
      pass ();
    else
      fail ("ACSH_TORUS_CLASS.minor [BL] set+1 %u != %u", acsh_torus_class->minor, minor);
    acsh_torus_class->minor--;
  }
  {
    BITCODE_BD minor_radius;
    if (dwg_dynapi_entity_value (acsh_torus_class, "ACSH_TORUS_CLASS", "minor_radius", &minor_radius, NULL)
        && minor_radius == acsh_torus_class->minor_radius)
      pass ();
    else
      fail ("ACSH_TORUS_CLASS.minor_radius [BD] %g != %g", acsh_torus_class->minor_radius, minor_radius);
    minor_radius++;
    if (dwg_dynapi_entity_set_value (acsh_torus_class, "ACSH_TORUS_CLASS", "minor_radius", &minor_radius, 0)
        && minor_radius == acsh_torus_class->minor_radius)
      pass ();
    else
      fail ("ACSH_TORUS_CLASS.minor_radius [BD] set+1 %g != %g", acsh_torus_class->minor_radius, minor_radius);
    acsh_torus_class->minor_radius--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_torus_class, "ACSH_TORUS_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_torus_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_TORUS_CLASS.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ACSH_TORUS_CLASS") || is_class_debugging ("ACSH_TORUS_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_TORUS_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ACSH_WEDGE_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ACSH_WEDGE_CLASS *restrict acsh_wedge_class = obj->tio.object->tio.ACSH_WEDGE_CLASS;
  failed = 0;
  if (!obj_obj || !acsh_wedge_class)
    {
      fail ("NULL ACSH_WEDGE_CLASS");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &acsh_wedge_class->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("ACSH_WEDGE_CLASS.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "height", &height, NULL)
        && height == acsh_wedge_class->height)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.height [BD] %g != %g", acsh_wedge_class->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "height", &height, 0)
        && height == acsh_wedge_class->height)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.height [BD] set+1 %g != %g", acsh_wedge_class->height, height);
    acsh_wedge_class->height--;
  }
  {
    Dwg_ACSH_HistoryNode history_node;
    if (dwg_dynapi_entity_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "history_node", &history_node, NULL)
        && !memcmp (&history_node, &acsh_wedge_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
        pass ();
    else
        fail ("ACSH_WEDGE_CLASS.history_node [Dwg_ACSH_HistoryNode]");
  }
  {
    BITCODE_BD length;
    if (dwg_dynapi_entity_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "length", &length, NULL)
        && length == acsh_wedge_class->length)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.length [BD] %g != %g", acsh_wedge_class->length, length);
    length++;
    if (dwg_dynapi_entity_set_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "length", &length, 0)
        && length == acsh_wedge_class->length)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.length [BD] set+1 %g != %g", acsh_wedge_class->length, length);
    acsh_wedge_class->length--;
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "major", &major, NULL)
        && major == acsh_wedge_class->major)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.major [BL] %u != %u", acsh_wedge_class->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "major", &major, 0)
        && major == acsh_wedge_class->major)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.major [BL] set+1 %u != %u", acsh_wedge_class->major, major);
    acsh_wedge_class->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "minor", &minor, NULL)
        && minor == acsh_wedge_class->minor)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.minor [BL] %u != %u", acsh_wedge_class->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "minor", &minor, 0)
        && minor == acsh_wedge_class->minor)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.minor [BL] set+1 %u != %u", acsh_wedge_class->minor, minor);
    acsh_wedge_class->minor--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "parent", &parent, NULL)
        && !memcmp (&parent, &acsh_wedge_class->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ACSH_WEDGE_CLASS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "width", &width, NULL)
        && width == acsh_wedge_class->width)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.width [BD] %g != %g", acsh_wedge_class->width, width);
    width++;
    if (dwg_dynapi_entity_set_value (acsh_wedge_class, "ACSH_WEDGE_CLASS", "width", &width, 0)
        && width == acsh_wedge_class->width)
      pass ();
    else
      fail ("ACSH_WEDGE_CLASS.width [BD] set+1 %g != %g", acsh_wedge_class->width, width);
    acsh_wedge_class->width--;
  }
  if (failed && (is_class_unstable ("ACSH_WEDGE_CLASS") || is_class_debugging ("ACSH_WEDGE_CLASS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ACSH_WEDGE_CLASS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ALDIMOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ALDIMOBJECTCONTEXTDATA *restrict aldimobjectcontextdata = obj->tio.object->tio.ALDIMOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !aldimobjectcontextdata)
    {
      fail ("NULL ALDIMOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == aldimobjectcontextdata->class_version)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", aldimobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == aldimobjectcontextdata->class_version)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", aldimobjectcontextdata->class_version, class_version);
    aldimobjectcontextdata->class_version--;
  }
  {
    Dwg_OCD_Dimension dimension;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "dimension", &dimension, NULL)
        && !memcmp (&dimension, &aldimobjectcontextdata->dimension, sizeof (Dwg_OCD_Dimension)))
        pass ();
    else
        fail ("ALDIMOBJECTCONTEXTDATA.dimension [Dwg_OCD_Dimension]");
  }
  {
    BITCODE_3BD dimline_pt;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "dimline_pt", &dimline_pt, NULL)
        && !memcmp (&dimline_pt, &aldimobjectcontextdata->dimline_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ALDIMOBJECTCONTEXTDATA.dimline_pt [3BD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == aldimobjectcontextdata->is_default)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == aldimobjectcontextdata->is_default)
      pass ();
    else
      fail ("ALDIMOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", aldimobjectcontextdata->is_default, is_default);
    aldimobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &aldimobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ALDIMOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (aldimobjectcontextdata, "ALDIMOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &aldimobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ALDIMOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("ALDIMOBJECTCONTEXTDATA") || is_class_debugging ("ALDIMOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ALDIMOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_ANGDIMOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ANGDIMOBJECTCONTEXTDATA *restrict angdimobjectcontextdata = obj->tio.object->tio.ANGDIMOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !angdimobjectcontextdata)
    {
      fail ("NULL ANGDIMOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_3BD arc_pt;
    if (dwg_dynapi_entity_value (angdimobjectcontextdata, "ANGDIMOBJECTCONTEXTDATA", "arc_pt", &arc_pt, NULL)
        && !memcmp (&arc_pt, &angdimobjectcontextdata->arc_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ANGDIMOBJECTCONTEXTDATA.arc_pt [3BD]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (angdimobjectcontextdata, "ANGDIMOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == angdimobjectcontextdata->class_version)
      pass ();
    else
      fail ("ANGDIMOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", angdimobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (angdimobjectcontextdata, "ANGDIMOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == angdimobjectcontextdata->class_version)
      pass ();
    else
      fail ("ANGDIMOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", angdimobjectcontextdata->class_version, class_version);
    angdimobjectcontextdata->class_version--;
  }
  {
    Dwg_OCD_Dimension dimension;
    if (dwg_dynapi_entity_value (angdimobjectcontextdata, "ANGDIMOBJECTCONTEXTDATA", "dimension", &dimension, NULL)
        && !memcmp (&dimension, &angdimobjectcontextdata->dimension, sizeof (Dwg_OCD_Dimension)))
        pass ();
    else
        fail ("ANGDIMOBJECTCONTEXTDATA.dimension [Dwg_OCD_Dimension]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (angdimobjectcontextdata, "ANGDIMOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == angdimobjectcontextdata->is_default)
      pass ();
    else
      fail ("ANGDIMOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", angdimobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (angdimobjectcontextdata, "ANGDIMOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == angdimobjectcontextdata->is_default)
      pass ();
    else
      fail ("ANGDIMOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", angdimobjectcontextdata->is_default, is_default);
    angdimobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (angdimobjectcontextdata, "ANGDIMOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &angdimobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ANGDIMOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (angdimobjectcontextdata, "ANGDIMOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &angdimobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ANGDIMOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("ANGDIMOBJECTCONTEXTDATA") || is_class_debugging ("ANGDIMOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ANGDIMOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_ANNOTSCALEOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ANNOTSCALEOBJECTCONTEXTDATA *restrict annotscaleobjectcontextdata = obj->tio.object->tio.ANNOTSCALEOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !annotscaleobjectcontextdata)
    {
      fail ("NULL ANNOTSCALEOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (annotscaleobjectcontextdata, "ANNOTSCALEOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == annotscaleobjectcontextdata->class_version)
      pass ();
    else
      fail ("ANNOTSCALEOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", annotscaleobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (annotscaleobjectcontextdata, "ANNOTSCALEOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == annotscaleobjectcontextdata->class_version)
      pass ();
    else
      fail ("ANNOTSCALEOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", annotscaleobjectcontextdata->class_version, class_version);
    annotscaleobjectcontextdata->class_version--;
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (annotscaleobjectcontextdata, "ANNOTSCALEOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == annotscaleobjectcontextdata->is_default)
      pass ();
    else
      fail ("ANNOTSCALEOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", annotscaleobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (annotscaleobjectcontextdata, "ANNOTSCALEOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == annotscaleobjectcontextdata->is_default)
      pass ();
    else
      fail ("ANNOTSCALEOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", annotscaleobjectcontextdata->is_default, is_default);
    annotscaleobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (annotscaleobjectcontextdata, "ANNOTSCALEOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &annotscaleobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ANNOTSCALEOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (annotscaleobjectcontextdata, "ANNOTSCALEOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &annotscaleobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ANNOTSCALEOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("ANNOTSCALEOBJECTCONTEXTDATA") || is_class_debugging ("ANNOTSCALEOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ANNOTSCALEOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_APPID (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_APPID *restrict appid = obj->tio.object->tio.APPID;
  failed = 0;
  if (!obj_obj || !appid)
    {
      fail ("NULL APPID");
      return 1;
    }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (appid, "APPID", "flag", &flag, NULL)
        && flag == appid->flag)
      pass ();
    else
      fail ("APPID.flag [RC] %u != %u", appid->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "flag", &flag, 0)
        && flag == appid->flag)
      pass ();
    else
      fail ("APPID.flag [RC] set+1 %u != %u", appid->flag, flag);
    appid->flag--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (appid, "APPID", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == appid->is_xref_dep)
      pass ();
    else
      fail ("APPID.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", appid->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == appid->is_xref_dep)
      pass ();
    else
      fail ("APPID.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", appid->is_xref_dep, is_xref_dep);
    appid->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (appid, "APPID", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == appid->is_xref_ref)
      pass ();
    else
      fail ("APPID.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", appid->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == appid->is_xref_ref)
      pass ();
    else
      fail ("APPID.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", appid->is_xref_ref, is_xref_ref);
    appid->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (appid, "APPID", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == appid->is_xref_resolved)
      pass ();
    else
      fail ("APPID.is_xref_resolved [BS] %hu != %hu", appid->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == appid->is_xref_resolved)
      pass ();
    else
      fail ("APPID.is_xref_resolved [BS] set+1 %hu != %hu", appid->is_xref_resolved, is_xref_resolved);
    appid->is_xref_resolved--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (appid, "APPID", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)appid->name)
           : !appid->name)
      pass ();
    else
      fail ("APPID.name [TV] '%s' <> '%s'", name, appid->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (appid, "APPID", "parent", &parent, NULL)
        && !memcmp (&parent, &appid->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("APPID.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value (appid, "APPID", "unknown", &unknown, NULL)
        && unknown == appid->unknown)
      pass ();
    else
      fail ("APPID.unknown [RC] %u != %u", appid->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "unknown", &unknown, 0)
        && unknown == appid->unknown)
      pass ();
    else
      fail ("APPID.unknown [RC] set+1 %u != %u", appid->unknown, unknown);
    appid->unknown--;
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (appid, "APPID", "used", &used, NULL)
        && used == appid->used)
      pass ();
    else
      fail ("APPID.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", appid->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (appid, "APPID", "used", &used, 0)
        && used == appid->used)
      pass ();
    else
      fail ("APPID.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", appid->used, used);
    appid->used--;
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (appid, "APPID", "xref", &xref, NULL)
        && !memcmp (&xref, &appid->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("APPID.xref [H]");
  }
  if (failed && (is_class_unstable ("APPID") || is_class_debugging ("APPID")))
    {
      ok ("%s failed %d tests (TODO unstable)", "APPID", failed);
      failed = 0;
    }
  return failed;
}
static int test_APPID_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_APPID_CONTROL *restrict appid_control = obj->tio.object->tio.APPID_CONTROL;
  failed = 0;
  if (!obj_obj || !appid_control)
    {
      fail ("NULL APPID_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "entries", &entries, NULL)
        && entries == appid_control->entries)
      pass ();
    else
      fail ("APPID_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == appid_control->flags_r11)
      pass ();
    else
      fail ("APPID_CONTROL.flags_r11 [RS] %hu != %hu", appid_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (appid_control, "APPID_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == appid_control->flags_r11)
      pass ();
    else
      fail ("APPID_CONTROL.flags_r11 [RS] set+1 %hu != %hu", appid_control->flags_r11, flags_r11);
    appid_control->flags_r11--;
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == appid_control->num_entries)
      pass ();
    else
      fail ("APPID_CONTROL.num_entries [BS] %hu != %hu", appid_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (appid_control, "APPID_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == appid_control->num_entries)
      pass ();
    else
      fail ("APPID_CONTROL.num_entries [BS] set+1 %hu != %hu", appid_control->num_entries, num_entries);
    appid_control->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &appid_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("APPID_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("APPID_CONTROL") || is_class_debugging ("APPID_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "APPID_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOC2DCONSTRAINTGROUP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOC2DCONSTRAINTGROUP *restrict assoc2dconstraintgroup = obj->tio.object->tio.ASSOC2DCONSTRAINTGROUP;
  failed = 0;
  if (!obj_obj || !assoc2dconstraintgroup)
    {
      fail ("NULL ASSOC2DCONSTRAINTGROUP");
      return 1;
    }
  {
    BITCODE_BL action_index;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "action_index", &action_index, NULL)
        && action_index == assoc2dconstraintgroup->action_index)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.action_index [BL] %u != %u", assoc2dconstraintgroup->action_index, action_index);
    action_index++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "action_index", &action_index, 0)
        && action_index == assoc2dconstraintgroup->action_index)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.action_index [BL] set+1 %u != %u", assoc2dconstraintgroup->action_index, action_index);
    assoc2dconstraintgroup->action_index--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assoc2dconstraintgroup->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.actionbody [H]");
  }
  {
    BITCODE_H* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "actions", &actions, NULL)
        && actions == assoc2dconstraintgroup->actions)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.actions [H*] * %u num_actions", count);
  }
  {
    BITCODE_B b1;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1, NULL)
        && b1 == assoc2dconstraintgroup->b1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1);
    b1++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1, 0)
        && b1 == assoc2dconstraintgroup->b1)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1);
    assoc2dconstraintgroup->b1--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "class_version", &class_version, NULL)
        && class_version == assoc2dconstraintgroup->class_version)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.class_version [BS] %hu != %hu", assoc2dconstraintgroup->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "class_version", &class_version, 0)
        && class_version == assoc2dconstraintgroup->class_version)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.class_version [BS] set+1 %hu != %hu", assoc2dconstraintgroup->class_version, class_version);
    assoc2dconstraintgroup->class_version--;
  }
  {
    Dwg_ASSOCACTION_Deps* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "deps", &deps, NULL)
        && deps == assoc2dconstraintgroup->deps)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.deps [Dwg_ASSOCACTION_Deps*] * %u num_deps", count);
  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status, NULL)
        && geometry_status == assoc2dconstraintgroup->geometry_status)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status);
    geometry_status++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status, 0)
        && geometry_status == assoc2dconstraintgroup->geometry_status)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] set+1 %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status);
    assoc2dconstraintgroup->geometry_status--;
  }
  {
    BITCODE_H h1;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "h1", &h1, NULL)
        && !memcmp (&h1, &assoc2dconstraintgroup->h1, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.h1 [H]");
  }
  {
    BITCODE_BL max_assoc_dep_index;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "max_assoc_dep_index", &max_assoc_dep_index, NULL)
        && max_assoc_dep_index == assoc2dconstraintgroup->max_assoc_dep_index)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.max_assoc_dep_index [BL] %u != %u", assoc2dconstraintgroup->max_assoc_dep_index, max_assoc_dep_index);
    max_assoc_dep_index++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "max_assoc_dep_index", &max_assoc_dep_index, 0)
        && max_assoc_dep_index == assoc2dconstraintgroup->max_assoc_dep_index)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.max_assoc_dep_index [BL] set+1 %u != %u", assoc2dconstraintgroup->max_assoc_dep_index, max_assoc_dep_index);
    assoc2dconstraintgroup->max_assoc_dep_index--;
  }
  {
    Dwg_CONSTRAINTGROUPNODE* nodes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_nodes", &count, NULL)
        && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "nodes", &nodes, NULL)
        && nodes == assoc2dconstraintgroup->nodes)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.nodes [Dwg_CONSTRAINTGROUPNODE*] * %u num_nodes", count);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_actions", &num_actions, NULL)
        && num_actions == assoc2dconstraintgroup->num_actions)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_actions [BL] %u != %u", assoc2dconstraintgroup->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_actions", &num_actions, 0)
        && num_actions == assoc2dconstraintgroup->num_actions)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_actions [BL] set+1 %u != %u", assoc2dconstraintgroup->num_actions, num_actions);
    assoc2dconstraintgroup->num_actions--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_deps", &num_deps, NULL)
        && num_deps == assoc2dconstraintgroup->num_deps)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_deps [BL] %u != %u", assoc2dconstraintgroup->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_deps", &num_deps, 0)
        && num_deps == assoc2dconstraintgroup->num_deps)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_deps [BL] set+1 %u != %u", assoc2dconstraintgroup->num_deps, num_deps);
    assoc2dconstraintgroup->num_deps--;
  }
  {
    BITCODE_BL num_nodes;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_nodes", &num_nodes, NULL)
        && num_nodes == assoc2dconstraintgroup->num_nodes)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_nodes [BL] %u != %u", assoc2dconstraintgroup->num_nodes, num_nodes);
    num_nodes++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_nodes", &num_nodes, 0)
        && num_nodes == assoc2dconstraintgroup->num_nodes)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_nodes [BL] set+1 %u != %u", assoc2dconstraintgroup->num_nodes, num_nodes);
    assoc2dconstraintgroup->num_nodes--;
  }
  {
    BITCODE_BL num_owned_params;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_owned_params", &num_owned_params, NULL)
        && num_owned_params == assoc2dconstraintgroup->num_owned_params)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_owned_params [BL] %u != %u", assoc2dconstraintgroup->num_owned_params, num_owned_params);
    num_owned_params++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_owned_params", &num_owned_params, 0)
        && num_owned_params == assoc2dconstraintgroup->num_owned_params)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_owned_params [BL] set+1 %u != %u", assoc2dconstraintgroup->num_owned_params, num_owned_params);
    assoc2dconstraintgroup->num_owned_params--;
  }
  {
    BITCODE_BL num_values;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_values", &num_values, NULL)
        && num_values == assoc2dconstraintgroup->num_values)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_values [BL] %u != %u", assoc2dconstraintgroup->num_values, num_values);
    num_values++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_values", &num_values, 0)
        && num_values == assoc2dconstraintgroup->num_values)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.num_values [BL] set+1 %u != %u", assoc2dconstraintgroup->num_values, num_values);
    assoc2dconstraintgroup->num_values--;
  }
  {
    BITCODE_H* owned_params;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_owned_params", &count, NULL)
        && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "owned_params", &owned_params, NULL)
        && owned_params == assoc2dconstraintgroup->owned_params)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.owned_params [H*] * %u num_owned_params", count);
  }
  {
    BITCODE_H owningnetwork;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "owningnetwork", &owningnetwork, NULL)
        && !memcmp (&owningnetwork, &assoc2dconstraintgroup->owningnetwork, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.owningnetwork [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "parent", &parent, NULL)
        && !memcmp (&parent, &assoc2dconstraintgroup->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.parent [struct _dwg_object_object*]");
  }
  {
    struct _dwg_VALUEPARAM* values;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_values", &count, NULL)
        && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "values", &values, NULL)
        && values == assoc2dconstraintgroup->values)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.values [struct _dwg_VALUEPARAM*] * %u num_values", count);
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "version", &version, NULL)
        && version == assoc2dconstraintgroup->version)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.version [BL] %u != %u", assoc2dconstraintgroup->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "version", &version, 0)
        && version == assoc2dconstraintgroup->version)
      pass ();
    else
      fail ("ASSOC2DCONSTRAINTGROUP.version [BL] set+1 %u != %u", assoc2dconstraintgroup->version, version);
    assoc2dconstraintgroup->version--;
  }
  {
    BITCODE_3BD workplane[3];
    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "workplane[3]", &workplane, NULL)
        && !memcmp (&workplane, &assoc2dconstraintgroup->workplane, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ASSOC2DCONSTRAINTGROUP.workplane[3] [3BD]");
  }
  if (failed && (is_class_unstable ("ASSOC2DCONSTRAINTGROUP") || is_class_debugging ("ASSOC2DCONSTRAINTGROUP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOC2DCONSTRAINTGROUP", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOC3POINTANGULARDIMACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOC3POINTANGULARDIMACTIONBODY *restrict assoc3pointangulardimactionbody = obj->tio.object->tio.ASSOC3POINTANGULARDIMACTIONBODY;
  failed = 0;
  if (!obj_obj || !assoc3pointangulardimactionbody)
    {
      fail ("NULL ASSOC3POINTANGULARDIMACTIONBODY");
      return 1;
    }
  {
    BITCODE_BS aaab_version;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "aaab_version", &aaab_version, NULL)
        && aaab_version == assoc3pointangulardimactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOC3POINTANGULARDIMACTIONBODY.aaab_version [BS] %hu != %hu", assoc3pointangulardimactionbody->aaab_version, aaab_version);
    aaab_version++;
    if (dwg_dynapi_entity_set_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "aaab_version", &aaab_version, 0)
        && aaab_version == assoc3pointangulardimactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOC3POINTANGULARDIMACTIONBODY.aaab_version [BS] set+1 %hu != %hu", assoc3pointangulardimactionbody->aaab_version, aaab_version);
    assoc3pointangulardimactionbody->aaab_version--;
  }
  {
    BITCODE_BS aab_version;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assoc3pointangulardimactionbody->aab_version)
      pass ();
    else
      fail ("ASSOC3POINTANGULARDIMACTIONBODY.aab_version [BS] %hu != %hu", assoc3pointangulardimactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assoc3pointangulardimactionbody->aab_version)
      pass ();
    else
      fail ("ASSOC3POINTANGULARDIMACTIONBODY.aab_version [BS] set+1 %hu != %hu", assoc3pointangulardimactionbody->aab_version, aab_version);
    assoc3pointangulardimactionbody->aab_version--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assoc3pointangulardimactionbody->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOC3POINTANGULARDIMACTIONBODY.actionbody [H]");
  }
  {
    BITCODE_H assoc_dep;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "assoc_dep", &assoc_dep, NULL)
        && !memcmp (&assoc_dep, &assoc3pointangulardimactionbody->assoc_dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOC3POINTANGULARDIMACTIONBODY.assoc_dep [H]");
  }
  {
    BITCODE_H assocdep;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "assocdep", &assocdep, NULL)
        && !memcmp (&assocdep, &assoc3pointangulardimactionbody->assocdep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOC3POINTANGULARDIMACTIONBODY.assocdep [H]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assoc3pointangulardimactionbody->class_version)
      pass ();
    else
      fail ("ASSOC3POINTANGULARDIMACTIONBODY.class_version [BS] %hu != %hu", assoc3pointangulardimactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "class_version", &class_version, 0)
        && class_version == assoc3pointangulardimactionbody->class_version)
      pass ();
    else
      fail ("ASSOC3POINTANGULARDIMACTIONBODY.class_version [BS] set+1 %hu != %hu", assoc3pointangulardimactionbody->class_version, class_version);
    assoc3pointangulardimactionbody->class_version--;
  }
  {
    BITCODE_H d_node;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "d_node", &d_node, NULL)
        && !memcmp (&d_node, &assoc3pointangulardimactionbody->d_node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOC3POINTANGULARDIMACTIONBODY.d_node [H]");
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assoc3pointangulardimactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOC3POINTANGULARDIMACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assoc3pointangulardimactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOC3POINTANGULARDIMACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H r_node;
    if (dwg_dynapi_entity_value (assoc3pointangulardimactionbody, "ASSOC3POINTANGULARDIMACTIONBODY", "r_node", &r_node, NULL)
        && !memcmp (&r_node, &assoc3pointangulardimactionbody->r_node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOC3POINTANGULARDIMACTIONBODY.r_node [H]");
  }
  if (failed && (is_class_unstable ("ASSOC3POINTANGULARDIMACTIONBODY") || is_class_debugging ("ASSOC3POINTANGULARDIMACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOC3POINTANGULARDIMACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCACTION *restrict assocaction = obj->tio.object->tio.ASSOCACTION;
  failed = 0;
  if (!obj_obj || !assocaction)
    {
      fail ("NULL ASSOCACTION");
      return 1;
    }
  {
    BITCODE_BL action_index;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "action_index", &action_index, NULL)
        && action_index == assocaction->action_index)
      pass ();
    else
      fail ("ASSOCACTION.action_index [BL] %u != %u", assocaction->action_index, action_index);
    action_index++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "action_index", &action_index, 0)
        && action_index == assocaction->action_index)
      pass ();
    else
      fail ("ASSOCACTION.action_index [BL] set+1 %u != %u", assocaction->action_index, action_index);
    assocaction->action_index--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assocaction->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCACTION.actionbody [H]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "class_version", &class_version, NULL)
        && class_version == assocaction->class_version)
      pass ();
    else
      fail ("ASSOCACTION.class_version [BS] %hu != %hu", assocaction->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "class_version", &class_version, 0)
        && class_version == assocaction->class_version)
      pass ();
    else
      fail ("ASSOCACTION.class_version [BS] set+1 %hu != %hu", assocaction->class_version, class_version);
    assocaction->class_version--;
  }
  {
    Dwg_ASSOCACTION_Deps* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "deps", &deps, NULL)
        && deps == assocaction->deps)
      pass ();
    else
      fail ("ASSOCACTION.deps [Dwg_ASSOCACTION_Deps*] * %u num_deps", count);
  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "geometry_status", &geometry_status, NULL)
        && geometry_status == assocaction->geometry_status)
      pass ();
    else
      fail ("ASSOCACTION.geometry_status [BL] %u != %u", assocaction->geometry_status, geometry_status);
    geometry_status++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "geometry_status", &geometry_status, 0)
        && geometry_status == assocaction->geometry_status)
      pass ();
    else
      fail ("ASSOCACTION.geometry_status [BL] set+1 %u != %u", assocaction->geometry_status, geometry_status);
    assocaction->geometry_status--;
  }
  {
    BITCODE_BL max_assoc_dep_index;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "max_assoc_dep_index", &max_assoc_dep_index, NULL)
        && max_assoc_dep_index == assocaction->max_assoc_dep_index)
      pass ();
    else
      fail ("ASSOCACTION.max_assoc_dep_index [BL] %u != %u", assocaction->max_assoc_dep_index, max_assoc_dep_index);
    max_assoc_dep_index++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "max_assoc_dep_index", &max_assoc_dep_index, 0)
        && max_assoc_dep_index == assocaction->max_assoc_dep_index)
      pass ();
    else
      fail ("ASSOCACTION.max_assoc_dep_index [BL] set+1 %u != %u", assocaction->max_assoc_dep_index, max_assoc_dep_index);
    assocaction->max_assoc_dep_index--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "num_deps", &num_deps, NULL)
        && num_deps == assocaction->num_deps)
      pass ();
    else
      fail ("ASSOCACTION.num_deps [BL] %u != %u", assocaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "num_deps", &num_deps, 0)
        && num_deps == assocaction->num_deps)
      pass ();
    else
      fail ("ASSOCACTION.num_deps [BL] set+1 %u != %u", assocaction->num_deps, num_deps);
    assocaction->num_deps--;
  }
  {
    BITCODE_BL num_owned_params;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "num_owned_params", &num_owned_params, NULL)
        && num_owned_params == assocaction->num_owned_params)
      pass ();
    else
      fail ("ASSOCACTION.num_owned_params [BL] %u != %u", assocaction->num_owned_params, num_owned_params);
    num_owned_params++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "num_owned_params", &num_owned_params, 0)
        && num_owned_params == assocaction->num_owned_params)
      pass ();
    else
      fail ("ASSOCACTION.num_owned_params [BL] set+1 %u != %u", assocaction->num_owned_params, num_owned_params);
    assocaction->num_owned_params--;
  }
  {
    BITCODE_BL num_values;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "num_values", &num_values, NULL)
        && num_values == assocaction->num_values)
      pass ();
    else
      fail ("ASSOCACTION.num_values [BL] %u != %u", assocaction->num_values, num_values);
    num_values++;
    if (dwg_dynapi_entity_set_value (assocaction, "ASSOCACTION", "num_values", &num_values, 0)
        && num_values == assocaction->num_values)
      pass ();
    else
      fail ("ASSOCACTION.num_values [BL] set+1 %u != %u", assocaction->num_values, num_values);
    assocaction->num_values--;
  }
  {
    BITCODE_H* owned_params;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "num_owned_params", &count, NULL)
        && dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "owned_params", &owned_params, NULL)
        && owned_params == assocaction->owned_params)
      pass ();
    else
      fail ("ASSOCACTION.owned_params [H*] * %u num_owned_params", count);
  }
  {
    BITCODE_H owningnetwork;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "owningnetwork", &owningnetwork, NULL)
        && !memcmp (&owningnetwork, &assocaction->owningnetwork, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCACTION.owningnetwork [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &assocaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCACTION.parent [struct _dwg_object_object*]");
  }
  {
    struct _dwg_VALUEPARAM* values;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "num_values", &count, NULL)
        && dwg_dynapi_entity_value (assocaction, "ASSOCACTION", "values", &values, NULL)
        && values == assocaction->values)
      pass ();
    else
      fail ("ASSOCACTION.values [struct _dwg_VALUEPARAM*] * %u num_values", count);
  }
  if (failed && (is_class_unstable ("ASSOCACTION") || is_class_debugging ("ASSOCACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCACTIONPARAM *restrict assocactionparam = obj->tio.object->tio.ASSOCACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocactionparam)
    {
      fail ("NULL ASSOCACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocactionparam, "ASSOCACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCACTIONPARAM.aap_version [BL] %u != %u", assocactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocactionparam, "ASSOCACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCACTIONPARAM.aap_version [BL] set+1 %u != %u", assocactionparam->aap_version, aap_version);
    assocactionparam->aap_version--;
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocactionparam, "ASSOCACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCACTIONPARAM.is_r2013 [BS] %hu != %hu", assocactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocactionparam, "ASSOCACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocactionparam->is_r2013, is_r2013);
    assocactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocactionparam, "ASSOCACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocactionparam->name)
           : !assocactionparam->name)
      pass ();
    else
      fail ("ASSOCACTIONPARAM.name [T] '%s' <> '%s'", name, assocactionparam->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocactionparam, "ASSOCACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCACTIONPARAM") || is_class_debugging ("ASSOCACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCALIGNEDDIMACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCALIGNEDDIMACTIONBODY *restrict assocaligneddimactionbody = obj->tio.object->tio.ASSOCALIGNEDDIMACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocaligneddimactionbody)
    {
      fail ("NULL ASSOCALIGNEDDIMACTIONBODY");
      return 1;
    }
  {
    BITCODE_BS aaab_version;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aaab_version", &aaab_version, NULL)
        && aaab_version == assocaligneddimactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.aaab_version [BS] %hu != %hu", assocaligneddimactionbody->aaab_version, aaab_version);
    aaab_version++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aaab_version", &aaab_version, 0)
        && aaab_version == assocaligneddimactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.aaab_version [BS] set+1 %hu != %hu", assocaligneddimactionbody->aaab_version, aaab_version);
    assocaligneddimactionbody->aaab_version--;
  }
  {
    BITCODE_BS aab_version;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocaligneddimactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.aab_version [BS] %hu != %hu", assocaligneddimactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocaligneddimactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.aab_version [BS] set+1 %hu != %hu", assocaligneddimactionbody->aab_version, aab_version);
    assocaligneddimactionbody->aab_version--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assocaligneddimactionbody->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.actionbody [H]");
  }
  {
    BITCODE_H assoc_dep;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "assoc_dep", &assoc_dep, NULL)
        && !memcmp (&assoc_dep, &assocaligneddimactionbody->assoc_dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.assoc_dep [H]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocaligneddimactionbody->class_version)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.class_version [BL] %u != %u", assocaligneddimactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocaligneddimactionbody->class_version)
      pass ();
    else
      fail ("ASSOCALIGNEDDIMACTIONBODY.class_version [BL] set+1 %u != %u", assocaligneddimactionbody->class_version, class_version);
    assocaligneddimactionbody->class_version--;
  }
  {
    BITCODE_H d_node;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "d_node", &d_node, NULL)
        && !memcmp (&d_node, &assocaligneddimactionbody->d_node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.d_node [H]");
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocaligneddimactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocaligneddimactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H r_node;
    if (dwg_dynapi_entity_value (assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "r_node", &r_node, NULL)
        && !memcmp (&r_node, &assocaligneddimactionbody->r_node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCALIGNEDDIMACTIONBODY.r_node [H]");
  }
  if (failed && (is_class_unstable ("ASSOCALIGNEDDIMACTIONBODY") || is_class_debugging ("ASSOCALIGNEDDIMACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCALIGNEDDIMACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCARRAYACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCARRAYACTIONBODY *restrict assocarrayactionbody = obj->tio.object->tio.ASSOCARRAYACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocarrayactionbody)
    {
      fail ("NULL ASSOCARRAYACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aaab_version;
    if (dwg_dynapi_entity_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "aaab_version", &aaab_version, NULL)
        && aaab_version == assocarrayactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCARRAYACTIONBODY.aaab_version [BL] %u != %u", assocarrayactionbody->aaab_version, aaab_version);
    aaab_version++;
    if (dwg_dynapi_entity_set_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "aaab_version", &aaab_version, 0)
        && aaab_version == assocarrayactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCARRAYACTIONBODY.aaab_version [BL] set+1 %u != %u", assocarrayactionbody->aaab_version, aaab_version);
    assocarrayactionbody->aaab_version--;
  }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocarrayactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCARRAYACTIONBODY.aab_version [BL] %u != %u", assocarrayactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocarrayactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCARRAYACTIONBODY.aab_version [BL] set+1 %u != %u", assocarrayactionbody->aab_version, aab_version);
    assocarrayactionbody->aab_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocarrayactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCARRAYACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    BITCODE_T paramblock;
    if (dwg_dynapi_entity_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "paramblock", &paramblock, NULL)
        && paramblock
           ? strEQ ((char *)paramblock, (char *)assocarrayactionbody->paramblock)
           : !assocarrayactionbody->paramblock)
      pass ();
    else
      fail ("ASSOCARRAYACTIONBODY.paramblock [T] '%s' <> '%s'", paramblock, assocarrayactionbody->paramblock);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocarrayactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCARRAYACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD* transmatrix;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "num_transmatrix", &count, NULL)
        && dwg_dynapi_entity_value (assocarrayactionbody, "ASSOCARRAYACTIONBODY", "transmatrix", &transmatrix, NULL)
        && transmatrix == assocarrayactionbody->transmatrix)
      pass ();
    else
      fail ("ASSOCARRAYACTIONBODY.transmatrix [BD*] * %u num_transmatrix", count);
  }
  if (failed && (is_class_unstable ("ASSOCARRAYACTIONBODY") || is_class_debugging ("ASSOCARRAYACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCARRAYACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCARRAYMODIFYACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCARRAYMODIFYACTIONBODY *restrict assocarraymodifyactionbody = obj->tio.object->tio.ASSOCARRAYMODIFYACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocarraymodifyactionbody)
    {
      fail ("NULL ASSOCARRAYMODIFYACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aaab_version;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "aaab_version", &aaab_version, NULL)
        && aaab_version == assocarraymodifyactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.aaab_version [BL] %u != %u", assocarraymodifyactionbody->aaab_version, aaab_version);
    aaab_version++;
    if (dwg_dynapi_entity_set_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "aaab_version", &aaab_version, 0)
        && aaab_version == assocarraymodifyactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.aaab_version [BL] set+1 %u != %u", assocarraymodifyactionbody->aaab_version, aaab_version);
    assocarraymodifyactionbody->aaab_version--;
  }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocarraymodifyactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.aab_version [BL] %u != %u", assocarraymodifyactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocarraymodifyactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.aab_version [BL] set+1 %u != %u", assocarraymodifyactionbody->aab_version, aab_version);
    assocarraymodifyactionbody->aab_version--;
  }
  {
    Dwg_ARRAYITEMLOCATOR* items;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "num_items", &count, NULL)
        && dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "items", &items, NULL)
        && items == assocarraymodifyactionbody->items)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.items [Dwg_ARRAYITEMLOCATOR*] * %u num_items", count);
  }
  {
    BITCODE_BL num_items;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "num_items", &num_items, NULL)
        && num_items == assocarraymodifyactionbody->num_items)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.num_items [BL] %u != %u", assocarraymodifyactionbody->num_items, num_items);
    num_items++;
    if (dwg_dynapi_entity_set_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "num_items", &num_items, 0)
        && num_items == assocarraymodifyactionbody->num_items)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.num_items [BL] set+1 %u != %u", assocarraymodifyactionbody->num_items, num_items);
    assocarraymodifyactionbody->num_items--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocarraymodifyactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCARRAYMODIFYACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    BITCODE_T paramblock;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "paramblock", &paramblock, NULL)
        && paramblock
           ? strEQ ((char *)paramblock, (char *)assocarraymodifyactionbody->paramblock)
           : !assocarraymodifyactionbody->paramblock)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.paramblock [T] '%s' <> '%s'", paramblock, assocarraymodifyactionbody->paramblock);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocarraymodifyactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCARRAYMODIFYACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS status;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "status", &status, NULL)
        && status == assocarraymodifyactionbody->status)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.status [BS] %hu != %hu", assocarraymodifyactionbody->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "status", &status, 0)
        && status == assocarraymodifyactionbody->status)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.status [BS] set+1 %hu != %hu", assocarraymodifyactionbody->status, status);
    assocarraymodifyactionbody->status--;
  }
  {
    BITCODE_BD* transmatrix;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "num_transmatrix", &count, NULL)
        && dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "transmatrix", &transmatrix, NULL)
        && transmatrix == assocarraymodifyactionbody->transmatrix)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYACTIONBODY.transmatrix [BD*] * %u num_transmatrix", count);
  }
  if (failed && (is_class_unstable ("ASSOCARRAYMODIFYACTIONBODY") || is_class_debugging ("ASSOCARRAYMODIFYACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCARRAYMODIFYACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCASMBODYACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCASMBODYACTIONPARAM *restrict assocasmbodyactionparam = obj->tio.object->tio.ASSOCASMBODYACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocasmbodyactionparam)
    {
      fail ("NULL ASSOCASMBODYACTIONPARAM");
      return 1;
    }
  {
    BITCODE_B _dxf_sab_converted;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
        && _dxf_sab_converted == assocasmbodyactionparam->_dxf_sab_converted)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->_dxf_sab_converted, _dxf_sab_converted);
    _dxf_sab_converted++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "_dxf_sab_converted", &_dxf_sab_converted, 0)
        && _dxf_sab_converted == assocasmbodyactionparam->_dxf_sab_converted)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->_dxf_sab_converted, _dxf_sab_converted);
    assocasmbodyactionparam->_dxf_sab_converted--;
  }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocasmbodyactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.aap_version [BL] %u != %u", assocasmbodyactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocasmbodyactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.aap_version [BL] set+1 %u != %u", assocasmbodyactionparam->aap_version, aap_version);
    assocasmbodyactionparam->aap_version--;
  }
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_data", &acis_data, NULL)
        && acis_data
           ? strEQ ((char *)acis_data, (char *)assocasmbodyactionparam->acis_data)
           : !assocasmbodyactionparam->acis_data)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.acis_data [RC*] '%s' <> '%s'", acis_data, assocasmbodyactionparam->acis_data);
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty", &acis_empty, NULL)
        && acis_empty == assocasmbodyactionparam->acis_empty)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.acis_empty [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty, acis_empty);
    acis_empty++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty", &acis_empty, 0)
        && acis_empty == assocasmbodyactionparam->acis_empty)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty, acis_empty);
    assocasmbodyactionparam->acis_empty--;
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty2", &acis_empty2, NULL)
        && acis_empty2 == assocasmbodyactionparam->acis_empty2)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty2, acis_empty2);
    acis_empty2++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty2", &acis_empty2, 0)
        && acis_empty2 == assocasmbodyactionparam->acis_empty2)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty2, acis_empty2);
    assocasmbodyactionparam->acis_empty2--;
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty_bit", &acis_empty_bit, NULL)
        && acis_empty_bit == assocasmbodyactionparam->acis_empty_bit)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty_bit, acis_empty_bit);
    acis_empty_bit++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty_bit", &acis_empty_bit, 0)
        && acis_empty_bit == assocasmbodyactionparam->acis_empty_bit)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty_bit, acis_empty_bit);
    assocasmbodyactionparam->acis_empty_bit--;
  }
  {
    BITCODE_BL asdap_class_version;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "asdap_class_version", &asdap_class_version, NULL)
        && asdap_class_version == assocasmbodyactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.asdap_class_version [BL] %u != %u", assocasmbodyactionparam->asdap_class_version, asdap_class_version);
    asdap_class_version++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "asdap_class_version", &asdap_class_version, 0)
        && asdap_class_version == assocasmbodyactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.asdap_class_version [BL] set+1 %u != %u", assocasmbodyactionparam->asdap_class_version, asdap_class_version);
    assocasmbodyactionparam->asdap_class_version--;
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "block_size", &block_size, NULL)
        && !memcmp (&block_size, &assocasmbodyactionparam->block_size, sizeof (BITCODE_BL*)))
        pass ();
    else
        fail ("ASSOCASMBODYACTIONPARAM.block_size [BL*]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assocasmbodyactionparam->class_version)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.class_version [BL] %u != %u", assocasmbodyactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assocasmbodyactionparam->class_version)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.class_version [BL] set+1 %u != %u", assocasmbodyactionparam->class_version, class_version);
    assocasmbodyactionparam->class_version--;
  }
  {
    BITCODE_H dep;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "dep", &dep, NULL)
        && !memcmp (&dep, &assocasmbodyactionparam->dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCASMBODYACTIONPARAM.dep [H]");
  }
  {
    char ** encr_sat_data;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "encr_sat_data", &encr_sat_data, NULL)
        && !memcmp (&encr_sat_data, &assocasmbodyactionparam->encr_sat_data, sizeof (assocasmbodyactionparam->encr_sat_data)))
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.encr_sat_data [char **]");
  }
  {
    BITCODE_BL end_marker;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "end_marker", &end_marker, NULL)
        && end_marker == assocasmbodyactionparam->end_marker)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.end_marker [BL] %u != %u", assocasmbodyactionparam->end_marker, end_marker);
    end_marker++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "end_marker", &end_marker, 0)
        && end_marker == assocasmbodyactionparam->end_marker)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.end_marker [BL] set+1 %u != %u", assocasmbodyactionparam->end_marker, end_marker);
    assocasmbodyactionparam->end_marker--;
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp (&extra_acis_data, &assocasmbodyactionparam->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
        pass ();
    else
        fail ("ASSOCASMBODYACTIONPARAM.extra_acis_data [struct _dwg_entity_3DSOLID*]");
  }
  {
    BITCODE_B has_revision_guid;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "has_revision_guid", &has_revision_guid, NULL)
        && has_revision_guid == assocasmbodyactionparam->has_revision_guid)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->has_revision_guid, has_revision_guid);
    has_revision_guid++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "has_revision_guid", &has_revision_guid, 0)
        && has_revision_guid == assocasmbodyactionparam->has_revision_guid)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->has_revision_guid, has_revision_guid);
    assocasmbodyactionparam->has_revision_guid--;
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "history_id", &history_id, NULL)
        && !memcmp (&history_id, &assocasmbodyactionparam->history_id, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCASMBODYACTIONPARAM.history_id [H]");
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocasmbodyactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.is_r2013 [BS] %hu != %hu", assocasmbodyactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocasmbodyactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocasmbodyactionparam->is_r2013, is_r2013);
    assocasmbodyactionparam->is_r2013--;
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "isoline_present", &isoline_present, NULL)
        && isoline_present == assocasmbodyactionparam->isoline_present)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.isoline_present [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->isoline_present, isoline_present);
    isoline_present++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "isoline_present", &isoline_present, 0)
        && isoline_present == assocasmbodyactionparam->isoline_present)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->isoline_present, isoline_present);
    assocasmbodyactionparam->isoline_present--;
  }
  {
    BITCODE_BL isolines;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "isolines", &isolines, NULL)
        && isolines == assocasmbodyactionparam->isolines)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.isolines [BL] %u != %u", assocasmbodyactionparam->isolines, isolines);
    isolines++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "isolines", &isolines, 0)
        && isolines == assocasmbodyactionparam->isolines)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.isolines [BL] set+1 %u != %u", assocasmbodyactionparam->isolines, isolines);
    assocasmbodyactionparam->isolines--;
  }
  {
    Dwg_3DSOLID_material* materials;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_materials", &count, NULL)
        && dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "materials", &materials, NULL)
        && materials == assocasmbodyactionparam->materials)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocasmbodyactionparam->name)
           : !assocasmbodyactionparam->name)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.name [T] '%s' <> '%s'", name, assocasmbodyactionparam->name);
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_blocks", &num_blocks, NULL)
        && num_blocks == assocasmbodyactionparam->num_blocks)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.num_blocks [BL] %u != %u", assocasmbodyactionparam->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_blocks", &num_blocks, 0)
        && num_blocks == assocasmbodyactionparam->num_blocks)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.num_blocks [BL] set+1 %u != %u", assocasmbodyactionparam->num_blocks, num_blocks);
    assocasmbodyactionparam->num_blocks--;
  }
  {
    BITCODE_BL num_materials;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_materials", &num_materials, NULL)
        && num_materials == assocasmbodyactionparam->num_materials)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.num_materials [BL] %u != %u", assocasmbodyactionparam->num_materials, num_materials);
    num_materials++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_materials", &num_materials, 0)
        && num_materials == assocasmbodyactionparam->num_materials)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.num_materials [BL] set+1 %u != %u", assocasmbodyactionparam->num_materials, num_materials);
    assocasmbodyactionparam->num_materials--;
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_silhouettes", &num_silhouettes, NULL)
        && num_silhouettes == assocasmbodyactionparam->num_silhouettes)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.num_silhouettes [BL] %u != %u", assocasmbodyactionparam->num_silhouettes, num_silhouettes);
    num_silhouettes++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_silhouettes", &num_silhouettes, 0)
        && num_silhouettes == assocasmbodyactionparam->num_silhouettes)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.num_silhouettes [BL] set+1 %u != %u", assocasmbodyactionparam->num_silhouettes, num_silhouettes);
    assocasmbodyactionparam->num_silhouettes--;
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_wires", &num_wires, NULL)
        && num_wires == assocasmbodyactionparam->num_wires)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.num_wires [BL] %u != %u", assocasmbodyactionparam->num_wires, num_wires);
    num_wires++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_wires", &num_wires, 0)
        && num_wires == assocasmbodyactionparam->num_wires)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.num_wires [BL] set+1 %u != %u", assocasmbodyactionparam->num_wires, num_wires);
    assocasmbodyactionparam->num_wires--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocasmbodyactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCASMBODYACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "point", &point, NULL)
        && !memcmp (&point, &assocasmbodyactionparam->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ASSOCASMBODYACTIONPARAM.point [3BD]");
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "point_present", &point_present, NULL)
        && point_present == assocasmbodyactionparam->point_present)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.point_present [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->point_present, point_present);
    point_present++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "point_present", &point_present, 0)
        && point_present == assocasmbodyactionparam->point_present)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->point_present, point_present);
    assocasmbodyactionparam->point_present--;
  }
  {
    BITCODE_RC revision_bytes[9];
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_bytes[9]", &revision_bytes, NULL)
        && !memcmp (&revision_bytes, &assocasmbodyactionparam->revision_bytes, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("ASSOCASMBODYACTIONPARAM.revision_bytes[9] [RC]");
  }
  {
    BITCODE_RC revision_guid[39];
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_guid[39]", &revision_guid, NULL)
        && !memcmp (&revision_guid, &assocasmbodyactionparam->revision_guid, sizeof (BITCODE_RC)))
        pass ();
    else
        fail ("ASSOCASMBODYACTIONPARAM.revision_guid[39] [RC]");
  }
  {
    BITCODE_BL revision_major;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_major", &revision_major, NULL)
        && revision_major == assocasmbodyactionparam->revision_major)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.revision_major [BL] %u != %u", assocasmbodyactionparam->revision_major, revision_major);
    revision_major++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_major", &revision_major, 0)
        && revision_major == assocasmbodyactionparam->revision_major)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.revision_major [BL] set+1 %u != %u", assocasmbodyactionparam->revision_major, revision_major);
    assocasmbodyactionparam->revision_major--;
  }
  {
    BITCODE_BS revision_minor1;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_minor1", &revision_minor1, NULL)
        && revision_minor1 == assocasmbodyactionparam->revision_minor1)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.revision_minor1 [BS] %hu != %hu", assocasmbodyactionparam->revision_minor1, revision_minor1);
    revision_minor1++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_minor1", &revision_minor1, 0)
        && revision_minor1 == assocasmbodyactionparam->revision_minor1)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.revision_minor1 [BS] set+1 %hu != %hu", assocasmbodyactionparam->revision_minor1, revision_minor1);
    assocasmbodyactionparam->revision_minor1--;
  }
  {
    BITCODE_BS revision_minor2;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_minor2", &revision_minor2, NULL)
        && revision_minor2 == assocasmbodyactionparam->revision_minor2)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.revision_minor2 [BS] %hu != %hu", assocasmbodyactionparam->revision_minor2, revision_minor2);
    revision_minor2++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_minor2", &revision_minor2, 0)
        && revision_minor2 == assocasmbodyactionparam->revision_minor2)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.revision_minor2 [BS] set+1 %hu != %hu", assocasmbodyactionparam->revision_minor2, revision_minor2);
    assocasmbodyactionparam->revision_minor2--;
  }
  {
    BITCODE_BL sab_size;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "sab_size", &sab_size, NULL)
        && sab_size == assocasmbodyactionparam->sab_size)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.sab_size [BL] %u != %u", assocasmbodyactionparam->sab_size, sab_size);
    sab_size++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "sab_size", &sab_size, 0)
        && sab_size == assocasmbodyactionparam->sab_size)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.sab_size [BL] set+1 %u != %u", assocasmbodyactionparam->sab_size, sab_size);
    assocasmbodyactionparam->sab_size--;
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_silhouettes", &count, NULL)
        && dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "silhouettes", &silhouettes, NULL)
        && silhouettes == assocasmbodyactionparam->silhouettes)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "unknown", &unknown, NULL)
        && unknown == assocasmbodyactionparam->unknown)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.unknown [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "unknown", &unknown, 0)
        && unknown == assocasmbodyactionparam->unknown)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->unknown, unknown);
    assocasmbodyactionparam->unknown--;
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "version", &version, NULL)
        && version == assocasmbodyactionparam->version)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.version [BS] %hu != %hu", assocasmbodyactionparam->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "version", &version, 0)
        && version == assocasmbodyactionparam->version)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.version [BS] set+1 %hu != %hu", assocasmbodyactionparam->version, version);
    assocasmbodyactionparam->version--;
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "wireframe_data_present", &wireframe_data_present, NULL)
        && wireframe_data_present == assocasmbodyactionparam->wireframe_data_present)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->wireframe_data_present, wireframe_data_present);
    wireframe_data_present++;
    if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "wireframe_data_present", &wireframe_data_present, 0)
        && wireframe_data_present == assocasmbodyactionparam->wireframe_data_present)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->wireframe_data_present, wireframe_data_present);
    assocasmbodyactionparam->wireframe_data_present--;
  }
  {
    Dwg_3DSOLID_wire* wires;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_wires", &count, NULL)
        && dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "wires", &wires, NULL)
        && wires == assocasmbodyactionparam->wires)
      pass ();
    else
      fail ("ASSOCASMBODYACTIONPARAM.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
  }
  if (failed && (is_class_unstable ("ASSOCASMBODYACTIONPARAM") || is_class_debugging ("ASSOCASMBODYACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCASMBODYACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCBLENDSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCBLENDSURFACEACTIONBODY *restrict assocblendsurfaceactionbody = obj->tio.object->tio.ASSOCBLENDSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocblendsurfaceactionbody)
    {
      fail ("NULL ASSOCBLENDSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocblendsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.aab_version [BL] %u != %u", assocblendsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocblendsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocblendsurfaceactionbody->aab_version, aab_version);
    assocblendsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_B b1;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b1", &b1, NULL)
        && b1 == assocblendsurfaceactionbody->b1)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b1 [B] " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b1, b1);
    b1++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b1", &b1, 0)
        && b1 == assocblendsurfaceactionbody->b1)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b1, b1);
    assocblendsurfaceactionbody->b1--;
  }
  {
    BITCODE_B b2;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b2", &b2, NULL)
        && b2 == assocblendsurfaceactionbody->b2)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b2 [B] " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b2, b2);
    b2++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b2", &b2, 0)
        && b2 == assocblendsurfaceactionbody->b2)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b2, b2);
    assocblendsurfaceactionbody->b2--;
  }
  {
    BITCODE_B b3;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b3", &b3, NULL)
        && b3 == assocblendsurfaceactionbody->b3)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b3 [B] " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b3, b3);
    b3++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b3", &b3, 0)
        && b3 == assocblendsurfaceactionbody->b3)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b3 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b3, b3);
    assocblendsurfaceactionbody->b3--;
  }
  {
    BITCODE_B b4;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b4", &b4, NULL)
        && b4 == assocblendsurfaceactionbody->b4)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b4 [B] " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b4, b4);
    b4++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b4", &b4, 0)
        && b4 == assocblendsurfaceactionbody->b4)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b4 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b4, b4);
    assocblendsurfaceactionbody->b4--;
  }
  {
    BITCODE_B b5;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b5", &b5, NULL)
        && b5 == assocblendsurfaceactionbody->b5)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b5 [B] " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b5, b5);
    b5++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "b5", &b5, 0)
        && b5 == assocblendsurfaceactionbody->b5)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.b5 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocblendsurfaceactionbody->b5, b5);
    assocblendsurfaceactionbody->b5--;
  }
  {
    BITCODE_BS blend_options;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "blend_options", &blend_options, NULL)
        && blend_options == assocblendsurfaceactionbody->blend_options)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.blend_options [BS] %hu != %hu", assocblendsurfaceactionbody->blend_options, blend_options);
    blend_options++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "blend_options", &blend_options, 0)
        && blend_options == assocblendsurfaceactionbody->blend_options)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.blend_options [BS] set+1 %hu != %hu", assocblendsurfaceactionbody->blend_options, blend_options);
    assocblendsurfaceactionbody->blend_options--;
  }
  {
    BITCODE_BS bs2;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "bs2", &bs2, NULL)
        && bs2 == assocblendsurfaceactionbody->bs2)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.bs2 [BS] %hu != %hu", assocblendsurfaceactionbody->bs2, bs2);
    bs2++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "bs2", &bs2, 0)
        && bs2 == assocblendsurfaceactionbody->bs2)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.bs2 [BS] set+1 %hu != %hu", assocblendsurfaceactionbody->bs2, bs2);
    assocblendsurfaceactionbody->bs2--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocblendsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.class_version [BL] %u != %u", assocblendsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocblendsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocblendsurfaceactionbody->class_version, class_version);
    assocblendsurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocblendsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCBLENDSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocblendsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCBLENDSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocblendsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocblendsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocblendsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCBLENDSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocblendsurfaceactionbody->pbsab_status, pbsab_status);
    assocblendsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocblendsurfaceactionbody, "ASSOCBLENDSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocblendsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCBLENDSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCBLENDSURFACEACTIONBODY") || is_class_debugging ("ASSOCBLENDSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCBLENDSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCCOMPOUNDACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCCOMPOUNDACTIONPARAM *restrict assoccompoundactionparam = obj->tio.object->tio.ASSOCCOMPOUNDACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assoccompoundactionparam)
    {
      fail ("NULL ASSOCCOMPOUNDACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assoccompoundactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.aap_version [BL] %u != %u", assoccompoundactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assoccompoundactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.aap_version [BL] set+1 %u != %u", assoccompoundactionparam->aap_version, aap_version);
    assoccompoundactionparam->aap_version--;
  }
  {
    BITCODE_BL bl2;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "bl2", &bl2, NULL)
        && bl2 == assoccompoundactionparam->bl2)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.bl2 [BL] %u != %u", assoccompoundactionparam->bl2, bl2);
    bl2++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "bl2", &bl2, 0)
        && bl2 == assoccompoundactionparam->bl2)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.bl2 [BL] set+1 %u != %u", assoccompoundactionparam->bl2, bl2);
    assoccompoundactionparam->bl2--;
  }
  {
    BITCODE_BS bs1;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "bs1", &bs1, NULL)
        && bs1 == assoccompoundactionparam->bs1)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.bs1 [BS] %hu != %hu", assoccompoundactionparam->bs1, bs1);
    bs1++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "bs1", &bs1, 0)
        && bs1 == assoccompoundactionparam->bs1)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.bs1 [BS] set+1 %hu != %hu", assoccompoundactionparam->bs1, bs1);
    assoccompoundactionparam->bs1--;
  }
  {
    BITCODE_BL child_id;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "child_id", &child_id, NULL)
        && child_id == assoccompoundactionparam->child_id)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.child_id [BL] %u != %u", assoccompoundactionparam->child_id, child_id);
    child_id++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "child_id", &child_id, 0)
        && child_id == assoccompoundactionparam->child_id)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.child_id [BL] set+1 %u != %u", assoccompoundactionparam->child_id, child_id);
    assoccompoundactionparam->child_id--;
  }
  {
    BITCODE_H child_param;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "child_param", &child_param, NULL)
        && !memcmp (&child_param, &assoccompoundactionparam->child_param, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCCOMPOUNDACTIONPARAM.child_param [H]");
  }
  {
    BITCODE_BS child_status;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "child_status", &child_status, NULL)
        && child_status == assoccompoundactionparam->child_status)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.child_status [BS] %hu != %hu", assoccompoundactionparam->child_status, child_status);
    child_status++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "child_status", &child_status, 0)
        && child_status == assoccompoundactionparam->child_status)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.child_status [BS] set+1 %hu != %hu", assoccompoundactionparam->child_status, child_status);
    assoccompoundactionparam->child_status--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assoccompoundactionparam->class_version)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.class_version [BS] %hu != %hu", assoccompoundactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assoccompoundactionparam->class_version)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.class_version [BS] set+1 %hu != %hu", assoccompoundactionparam->class_version, class_version);
    assoccompoundactionparam->class_version--;
  }
  {
    BITCODE_H h330_2;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "h330_2", &h330_2, NULL)
        && !memcmp (&h330_2, &assoccompoundactionparam->h330_2, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCCOMPOUNDACTIONPARAM.h330_2 [H]");
  }
  {
    BITCODE_H h330_3;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "h330_3", &h330_3, NULL)
        && !memcmp (&h330_3, &assoccompoundactionparam->h330_3, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCCOMPOUNDACTIONPARAM.h330_3 [H]");
  }
  {
    BITCODE_B has_child_param;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "has_child_param", &has_child_param, NULL)
        && has_child_param == assoccompoundactionparam->has_child_param)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.has_child_param [B] " FORMAT_B " != " FORMAT_B "", assoccompoundactionparam->has_child_param, has_child_param);
    has_child_param++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "has_child_param", &has_child_param, 0)
        && has_child_param == assoccompoundactionparam->has_child_param)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.has_child_param [B] set+1 " FORMAT_B " != " FORMAT_B "", assoccompoundactionparam->has_child_param, has_child_param);
    assoccompoundactionparam->has_child_param--;
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assoccompoundactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.is_r2013 [BS] %hu != %hu", assoccompoundactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assoccompoundactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assoccompoundactionparam->is_r2013, is_r2013);
    assoccompoundactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assoccompoundactionparam->name)
           : !assoccompoundactionparam->name)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.name [T] '%s' <> '%s'", name, assoccompoundactionparam->name);
  }
  {
    BITCODE_BL num_params;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "num_params", &num_params, NULL)
        && num_params == assoccompoundactionparam->num_params)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.num_params [BL] %u != %u", assoccompoundactionparam->num_params, num_params);
    num_params++;
    if (dwg_dynapi_entity_set_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "num_params", &num_params, 0)
        && num_params == assoccompoundactionparam->num_params)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.num_params [BL] set+1 %u != %u", assoccompoundactionparam->num_params, num_params);
    assoccompoundactionparam->num_params--;
  }
  {
    BITCODE_H* params;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "num_params", &count, NULL)
        && dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "params", &params, NULL)
        && params == assoccompoundactionparam->params)
      pass ();
    else
      fail ("ASSOCCOMPOUNDACTIONPARAM.params [H*] * %u num_params", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assoccompoundactionparam, "ASSOCCOMPOUNDACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assoccompoundactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCCOMPOUNDACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCCOMPOUNDACTIONPARAM") || is_class_debugging ("ASSOCCOMPOUNDACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCCOMPOUNDACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCDEPENDENCY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCDEPENDENCY *restrict assocdependency = obj->tio.object->tio.ASSOCDEPENDENCY;
  failed = 0;
  if (!obj_obj || !assocdependency)
    {
      fail ("NULL ASSOCDEPENDENCY");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "class_version", &class_version, NULL)
        && class_version == assocdependency->class_version)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.class_version [BS] %hu != %hu", assocdependency->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "class_version", &class_version, 0)
        && class_version == assocdependency->class_version)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.class_version [BS] set+1 %hu != %hu", assocdependency->class_version, class_version);
    assocdependency->class_version--;
  }
  {
    BITCODE_H dep_body;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "dep_body", &dep_body, NULL)
        && !memcmp (&dep_body, &assocdependency->dep_body, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.dep_body [H]");
  }
  {
    BITCODE_H dep_on;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "dep_on", &dep_on, NULL)
        && !memcmp (&dep_on, &assocdependency->dep_on, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.dep_on [H]");
  }
  {
    BITCODE_BLd depbodyid;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "depbodyid", &depbodyid, NULL)
        && depbodyid == assocdependency->depbodyid)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.depbodyid [BLd] " FORMAT_BLd " != " FORMAT_BLd "", assocdependency->depbodyid, depbodyid);
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "depbodyid", &depbodyid, 0)
        && depbodyid == assocdependency->depbodyid)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.depbodyid [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", assocdependency->depbodyid, depbodyid);
    assocdependency->depbodyid--;
  }
  {
    BITCODE_B has_name;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "has_name", &has_name, NULL)
        && has_name == assocdependency->has_name)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.has_name [B] " FORMAT_B " != " FORMAT_B "", assocdependency->has_name, has_name);
    has_name++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "has_name", &has_name, 0)
        && has_name == assocdependency->has_name)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.has_name [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->has_name, has_name);
    assocdependency->has_name--;
  }
  {
    BITCODE_B is_attached_to_object;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "is_attached_to_object", &is_attached_to_object, NULL)
        && is_attached_to_object == assocdependency->is_attached_to_object)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.is_attached_to_object [B] " FORMAT_B " != " FORMAT_B "", assocdependency->is_attached_to_object, is_attached_to_object);
    is_attached_to_object++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "is_attached_to_object", &is_attached_to_object, 0)
        && is_attached_to_object == assocdependency->is_attached_to_object)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.is_attached_to_object [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->is_attached_to_object, is_attached_to_object);
    assocdependency->is_attached_to_object--;
  }
  {
    BITCODE_B is_delegating_to_owning_action;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "is_delegating_to_owning_action", &is_delegating_to_owning_action, NULL)
        && is_delegating_to_owning_action == assocdependency->is_delegating_to_owning_action)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.is_delegating_to_owning_action [B] " FORMAT_B " != " FORMAT_B "", assocdependency->is_delegating_to_owning_action, is_delegating_to_owning_action);
    is_delegating_to_owning_action++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "is_delegating_to_owning_action", &is_delegating_to_owning_action, 0)
        && is_delegating_to_owning_action == assocdependency->is_delegating_to_owning_action)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.is_delegating_to_owning_action [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->is_delegating_to_owning_action, is_delegating_to_owning_action);
    assocdependency->is_delegating_to_owning_action--;
  }
  {
    BITCODE_B is_read_dep;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "is_read_dep", &is_read_dep, NULL)
        && is_read_dep == assocdependency->is_read_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.is_read_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->is_read_dep, is_read_dep);
    is_read_dep++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "is_read_dep", &is_read_dep, 0)
        && is_read_dep == assocdependency->is_read_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.is_read_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->is_read_dep, is_read_dep);
    assocdependency->is_read_dep--;
  }
  {
    BITCODE_B is_write_dep;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "is_write_dep", &is_write_dep, NULL)
        && is_write_dep == assocdependency->is_write_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.is_write_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->is_write_dep, is_write_dep);
    is_write_dep++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "is_write_dep", &is_write_dep, 0)
        && is_write_dep == assocdependency->is_write_dep)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.is_write_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", assocdependency->is_write_dep, is_write_dep);
    assocdependency->is_write_dep--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocdependency->name)
           : !assocdependency->name)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.name [T] '%s' <> '%s'", name, assocdependency->name);
  }
  {
    BITCODE_H node;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "node", &node, NULL)
        && !memcmp (&node, &assocdependency->node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.node [H]");
  }
  {
    BITCODE_BLd order;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "order", &order, NULL)
        && order == assocdependency->order)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.order [BLd] " FORMAT_BLd " != " FORMAT_BLd "", assocdependency->order, order);
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "order", &order, 0)
        && order == assocdependency->order)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.order [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", assocdependency->order, order);
    assocdependency->order--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocdependency->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "readdep", &readdep, NULL)
        && !memcmp (&readdep, &assocdependency->readdep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCDEPENDENCY.readdep [H]");
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value (assocdependency, "ASSOCDEPENDENCY", "status", &status, NULL)
        && status == assocdependency->status)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.status [BL] %u != %u", assocdependency->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (assocdependency, "ASSOCDEPENDENCY", "status", &status, 0)
        && status == assocdependency->status)
      pass ();
    else
      fail ("ASSOCDEPENDENCY.status [BL] set+1 %u != %u", assocdependency->status, status);
    assocdependency->status--;
  }
  if (failed && (is_class_unstable ("ASSOCDEPENDENCY") || is_class_debugging ("ASSOCDEPENDENCY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCDEPENDENCY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCDIMDEPENDENCYBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCDIMDEPENDENCYBODY *restrict assocdimdependencybody = obj->tio.object->tio.ASSOCDIMDEPENDENCYBODY;
  failed = 0;
  if (!obj_obj || !assocdimdependencybody)
    {
      fail ("NULL ASSOCDIMDEPENDENCYBODY");
      return 1;
    }
  {
    BITCODE_BS adb_version;
    if (dwg_dynapi_entity_value (assocdimdependencybody, "ASSOCDIMDEPENDENCYBODY", "adb_version", &adb_version, NULL)
        && adb_version == assocdimdependencybody->adb_version)
      pass ();
    else
      fail ("ASSOCDIMDEPENDENCYBODY.adb_version [BS] %hu != %hu", assocdimdependencybody->adb_version, adb_version);
    adb_version++;
    if (dwg_dynapi_entity_set_value (assocdimdependencybody, "ASSOCDIMDEPENDENCYBODY", "adb_version", &adb_version, 0)
        && adb_version == assocdimdependencybody->adb_version)
      pass ();
    else
      fail ("ASSOCDIMDEPENDENCYBODY.adb_version [BS] set+1 %hu != %hu", assocdimdependencybody->adb_version, adb_version);
    assocdimdependencybody->adb_version--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocdimdependencybody, "ASSOCDIMDEPENDENCYBODY", "class_version", &class_version, NULL)
        && class_version == assocdimdependencybody->class_version)
      pass ();
    else
      fail ("ASSOCDIMDEPENDENCYBODY.class_version [BS] %hu != %hu", assocdimdependencybody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocdimdependencybody, "ASSOCDIMDEPENDENCYBODY", "class_version", &class_version, 0)
        && class_version == assocdimdependencybody->class_version)
      pass ();
    else
      fail ("ASSOCDIMDEPENDENCYBODY.class_version [BS] set+1 %hu != %hu", assocdimdependencybody->class_version, class_version);
    assocdimdependencybody->class_version--;
  }
  {
    BITCODE_BS dimbase_version;
    if (dwg_dynapi_entity_value (assocdimdependencybody, "ASSOCDIMDEPENDENCYBODY", "dimbase_version", &dimbase_version, NULL)
        && dimbase_version == assocdimdependencybody->dimbase_version)
      pass ();
    else
      fail ("ASSOCDIMDEPENDENCYBODY.dimbase_version [BS] %hu != %hu", assocdimdependencybody->dimbase_version, dimbase_version);
    dimbase_version++;
    if (dwg_dynapi_entity_set_value (assocdimdependencybody, "ASSOCDIMDEPENDENCYBODY", "dimbase_version", &dimbase_version, 0)
        && dimbase_version == assocdimdependencybody->dimbase_version)
      pass ();
    else
      fail ("ASSOCDIMDEPENDENCYBODY.dimbase_version [BS] set+1 %hu != %hu", assocdimdependencybody->dimbase_version, dimbase_version);
    assocdimdependencybody->dimbase_version--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocdimdependencybody, "ASSOCDIMDEPENDENCYBODY", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocdimdependencybody->name)
           : !assocdimdependencybody->name)
      pass ();
    else
      fail ("ASSOCDIMDEPENDENCYBODY.name [T] '%s' <> '%s'", name, assocdimdependencybody->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocdimdependencybody, "ASSOCDIMDEPENDENCYBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocdimdependencybody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCDIMDEPENDENCYBODY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCDIMDEPENDENCYBODY") || is_class_debugging ("ASSOCDIMDEPENDENCYBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCDIMDEPENDENCYBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCEDGEACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCEDGEACTIONPARAM *restrict assocedgeactionparam = obj->tio.object->tio.ASSOCEDGEACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocedgeactionparam)
    {
      fail ("NULL ASSOCEDGEACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocedgeactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.aap_version [BL] %u != %u", assocedgeactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocedgeactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.aap_version [BL] set+1 %u != %u", assocedgeactionparam->aap_version, aap_version);
    assocedgeactionparam->aap_version--;
  }
  {
    BITCODE_BL action_type;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "action_type", &action_type, NULL)
        && action_type == assocedgeactionparam->action_type)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.action_type [BL] %u != %u", assocedgeactionparam->action_type, action_type);
    action_type++;
    if (dwg_dynapi_entity_set_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "action_type", &action_type, 0)
        && action_type == assocedgeactionparam->action_type)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.action_type [BL] set+1 %u != %u", assocedgeactionparam->action_type, action_type);
    assocedgeactionparam->action_type--;
  }
  {
    BITCODE_BL asdap_class_version;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "asdap_class_version", &asdap_class_version, NULL)
        && asdap_class_version == assocedgeactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.asdap_class_version [BL] %u != %u", assocedgeactionparam->asdap_class_version, asdap_class_version);
    asdap_class_version++;
    if (dwg_dynapi_entity_set_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "asdap_class_version", &asdap_class_version, 0)
        && asdap_class_version == assocedgeactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.asdap_class_version [BL] set+1 %u != %u", assocedgeactionparam->asdap_class_version, asdap_class_version);
    assocedgeactionparam->asdap_class_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assocedgeactionparam->class_version)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.class_version [BL] %u != %u", assocedgeactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assocedgeactionparam->class_version)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.class_version [BL] set+1 %u != %u", assocedgeactionparam->class_version, class_version);
    assocedgeactionparam->class_version--;
  }
  {
    BITCODE_H dep;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "dep", &dep, NULL)
        && !memcmp (&dep, &assocedgeactionparam->dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCEDGEACTIONPARAM.dep [H]");
  }
  {
    BITCODE_B has_action;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "has_action", &has_action, NULL)
        && has_action == assocedgeactionparam->has_action)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.has_action [B] " FORMAT_B " != " FORMAT_B "", assocedgeactionparam->has_action, has_action);
    has_action++;
    if (dwg_dynapi_entity_set_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "has_action", &has_action, 0)
        && has_action == assocedgeactionparam->has_action)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.has_action [B] set+1 " FORMAT_B " != " FORMAT_B "", assocedgeactionparam->has_action, has_action);
    assocedgeactionparam->has_action--;
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocedgeactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.is_r2013 [BS] %hu != %hu", assocedgeactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocedgeactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocedgeactionparam->is_r2013, is_r2013);
    assocedgeactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocedgeactionparam->name)
           : !assocedgeactionparam->name)
      pass ();
    else
      fail ("ASSOCEDGEACTIONPARAM.name [T] '%s' <> '%s'", name, assocedgeactionparam->name);
  }
  {
    BITCODE_H param;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "param", &param, NULL)
        && !memcmp (&param, &assocedgeactionparam->param, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCEDGEACTIONPARAM.param [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocedgeactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCEDGEACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H subent;
    if (dwg_dynapi_entity_value (assocedgeactionparam, "ASSOCEDGEACTIONPARAM", "subent", &subent, NULL)
        && !memcmp (&subent, &assocedgeactionparam->subent, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCEDGEACTIONPARAM.subent [H]");
  }
  if (failed && (is_class_unstable ("ASSOCEDGEACTIONPARAM") || is_class_debugging ("ASSOCEDGEACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCEDGEACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCEDGECHAMFERACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCEDGECHAMFERACTIONBODY *restrict assocedgechamferactionbody = obj->tio.object->tio.ASSOCEDGECHAMFERACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocedgechamferactionbody)
    {
      fail ("NULL ASSOCEDGECHAMFERACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocedgechamferactionbody, "ASSOCEDGECHAMFERACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocedgechamferactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCEDGECHAMFERACTIONBODY.aab_version [BL] %u != %u", assocedgechamferactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocedgechamferactionbody, "ASSOCEDGECHAMFERACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocedgechamferactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCEDGECHAMFERACTIONBODY.aab_version [BL] set+1 %u != %u", assocedgechamferactionbody->aab_version, aab_version);
    assocedgechamferactionbody->aab_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocedgechamferactionbody, "ASSOCEDGECHAMFERACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocedgechamferactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCEDGECHAMFERACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocedgechamferactionbody, "ASSOCEDGECHAMFERACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocedgechamferactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCEDGECHAMFERACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocedgechamferactionbody, "ASSOCEDGECHAMFERACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocedgechamferactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEDGECHAMFERACTIONBODY.pbsab_status [BL] %u != %u", assocedgechamferactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocedgechamferactionbody, "ASSOCEDGECHAMFERACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocedgechamferactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEDGECHAMFERACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocedgechamferactionbody->pbsab_status, pbsab_status);
    assocedgechamferactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocedgechamferactionbody, "ASSOCEDGECHAMFERACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocedgechamferactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCEDGECHAMFERACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCEDGECHAMFERACTIONBODY") || is_class_debugging ("ASSOCEDGECHAMFERACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCEDGECHAMFERACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCEDGEFILLETACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCEDGEFILLETACTIONBODY *restrict assocedgefilletactionbody = obj->tio.object->tio.ASSOCEDGEFILLETACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocedgefilletactionbody)
    {
      fail ("NULL ASSOCEDGEFILLETACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocedgefilletactionbody, "ASSOCEDGEFILLETACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocedgefilletactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCEDGEFILLETACTIONBODY.aab_version [BL] %u != %u", assocedgefilletactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocedgefilletactionbody, "ASSOCEDGEFILLETACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocedgefilletactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCEDGEFILLETACTIONBODY.aab_version [BL] set+1 %u != %u", assocedgefilletactionbody->aab_version, aab_version);
    assocedgefilletactionbody->aab_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocedgefilletactionbody, "ASSOCEDGEFILLETACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocedgefilletactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCEDGEFILLETACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocedgefilletactionbody, "ASSOCEDGEFILLETACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocedgefilletactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCEDGEFILLETACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocedgefilletactionbody, "ASSOCEDGEFILLETACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocedgefilletactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEDGEFILLETACTIONBODY.pbsab_status [BL] %u != %u", assocedgefilletactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocedgefilletactionbody, "ASSOCEDGEFILLETACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocedgefilletactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEDGEFILLETACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocedgefilletactionbody->pbsab_status, pbsab_status);
    assocedgefilletactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocedgefilletactionbody, "ASSOCEDGEFILLETACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocedgefilletactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCEDGEFILLETACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCEDGEFILLETACTIONBODY") || is_class_debugging ("ASSOCEDGEFILLETACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCEDGEFILLETACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCEXTENDSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCEXTENDSURFACEACTIONBODY *restrict assocextendsurfaceactionbody = obj->tio.object->tio.ASSOCEXTENDSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocextendsurfaceactionbody)
    {
      fail ("NULL ASSOCEXTENDSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocextendsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCEXTENDSURFACEACTIONBODY.aab_version [BL] %u != %u", assocextendsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocextendsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCEXTENDSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocextendsurfaceactionbody->aab_version, aab_version);
    assocextendsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocextendsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCEXTENDSURFACEACTIONBODY.class_version [BL] %u != %u", assocextendsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocextendsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCEXTENDSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocextendsurfaceactionbody->class_version, class_version);
    assocextendsurfaceactionbody->class_version--;
  }
  {
    BITCODE_RC option;
    if (dwg_dynapi_entity_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "option", &option, NULL)
        && option == assocextendsurfaceactionbody->option)
      pass ();
    else
      fail ("ASSOCEXTENDSURFACEACTIONBODY.option [RC] %u != %u", assocextendsurfaceactionbody->option, option);
    option++;
    if (dwg_dynapi_entity_set_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "option", &option, 0)
        && option == assocextendsurfaceactionbody->option)
      pass ();
    else
      fail ("ASSOCEXTENDSURFACEACTIONBODY.option [RC] set+1 %u != %u", assocextendsurfaceactionbody->option, option);
    assocextendsurfaceactionbody->option--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocextendsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCEXTENDSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocextendsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCEXTENDSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocextendsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEXTENDSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocextendsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocextendsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEXTENDSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocextendsurfaceactionbody->pbsab_status, pbsab_status);
    assocextendsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocextendsurfaceactionbody, "ASSOCEXTENDSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocextendsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCEXTENDSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCEXTENDSURFACEACTIONBODY") || is_class_debugging ("ASSOCEXTENDSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCEXTENDSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCEXTRUDEDSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCEXTRUDEDSURFACEACTIONBODY *restrict assocextrudedsurfaceactionbody = obj->tio.object->tio.ASSOCEXTRUDEDSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocextrudedsurfaceactionbody)
    {
      fail ("NULL ASSOCEXTRUDEDSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocextrudedsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.aab_version [BL] %u != %u", assocextrudedsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocextrudedsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->aab_version, aab_version);
    assocextrudedsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocextrudedsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.class_version [BL] %u != %u", assocextrudedsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocextrudedsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->class_version, class_version);
    assocextrudedsurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocextrudedsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocextrudedsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocextrudedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocextrudedsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocextrudedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocextrudedsurfaceactionbody->pbsab_status, pbsab_status);
    assocextrudedsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocextrudedsurfaceactionbody, "ASSOCEXTRUDEDSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocextrudedsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCEXTRUDEDSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCEXTRUDEDSURFACEACTIONBODY") || is_class_debugging ("ASSOCEXTRUDEDSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCEXTRUDEDSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCFACEACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCFACEACTIONPARAM *restrict assocfaceactionparam = obj->tio.object->tio.ASSOCFACEACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocfaceactionparam)
    {
      fail ("NULL ASSOCFACEACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocfaceactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.aap_version [BL] %u != %u", assocfaceactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocfaceactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.aap_version [BL] set+1 %u != %u", assocfaceactionparam->aap_version, aap_version);
    assocfaceactionparam->aap_version--;
  }
  {
    BITCODE_BL asdap_class_version;
    if (dwg_dynapi_entity_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "asdap_class_version", &asdap_class_version, NULL)
        && asdap_class_version == assocfaceactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.asdap_class_version [BL] %u != %u", assocfaceactionparam->asdap_class_version, asdap_class_version);
    asdap_class_version++;
    if (dwg_dynapi_entity_set_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "asdap_class_version", &asdap_class_version, 0)
        && asdap_class_version == assocfaceactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.asdap_class_version [BL] set+1 %u != %u", assocfaceactionparam->asdap_class_version, asdap_class_version);
    assocfaceactionparam->asdap_class_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assocfaceactionparam->class_version)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.class_version [BL] %u != %u", assocfaceactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assocfaceactionparam->class_version)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.class_version [BL] set+1 %u != %u", assocfaceactionparam->class_version, class_version);
    assocfaceactionparam->class_version--;
  }
  {
    BITCODE_H dep;
    if (dwg_dynapi_entity_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "dep", &dep, NULL)
        && !memcmp (&dep, &assocfaceactionparam->dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCFACEACTIONPARAM.dep [H]");
  }
  {
    BITCODE_BL index;
    if (dwg_dynapi_entity_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "index", &index, NULL)
        && index == assocfaceactionparam->index)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.index [BL] %u != %u", assocfaceactionparam->index, index);
    index++;
    if (dwg_dynapi_entity_set_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "index", &index, 0)
        && index == assocfaceactionparam->index)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.index [BL] set+1 %u != %u", assocfaceactionparam->index, index);
    assocfaceactionparam->index--;
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocfaceactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.is_r2013 [BS] %hu != %hu", assocfaceactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocfaceactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocfaceactionparam->is_r2013, is_r2013);
    assocfaceactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocfaceactionparam->name)
           : !assocfaceactionparam->name)
      pass ();
    else
      fail ("ASSOCFACEACTIONPARAM.name [T] '%s' <> '%s'", name, assocfaceactionparam->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocfaceactionparam, "ASSOCFACEACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocfaceactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCFACEACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCFACEACTIONPARAM") || is_class_debugging ("ASSOCFACEACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCFACEACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCFILLETSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCFILLETSURFACEACTIONBODY *restrict assocfilletsurfaceactionbody = obj->tio.object->tio.ASSOCFILLETSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocfilletsurfaceactionbody)
    {
      fail ("NULL ASSOCFILLETSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocfilletsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCFILLETSURFACEACTIONBODY.aab_version [BL] %u != %u", assocfilletsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocfilletsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCFILLETSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocfilletsurfaceactionbody->aab_version, aab_version);
    assocfilletsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocfilletsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCFILLETSURFACEACTIONBODY.class_version [BL] %u != %u", assocfilletsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocfilletsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCFILLETSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocfilletsurfaceactionbody->class_version, class_version);
    assocfilletsurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocfilletsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCFILLETSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocfilletsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCFILLETSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocfilletsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCFILLETSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocfilletsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocfilletsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCFILLETSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocfilletsurfaceactionbody->pbsab_status, pbsab_status);
    assocfilletsurfaceactionbody->pbsab_status--;
  }
  {
    BITCODE_2RD pt1;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "pt1", &pt1, NULL)
        && !memcmp (&pt1, &assocfilletsurfaceactionbody->pt1, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("ASSOCFILLETSURFACEACTIONBODY.pt1 [2RD]");
  }
  {
    BITCODE_2RD pt2;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "pt2", &pt2, NULL)
        && !memcmp (&pt2, &assocfilletsurfaceactionbody->pt2, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("ASSOCFILLETSURFACEACTIONBODY.pt2 [2RD]");
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocfilletsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCFILLETSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  {
    BITCODE_BS status;
    if (dwg_dynapi_entity_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "status", &status, NULL)
        && status == assocfilletsurfaceactionbody->status)
      pass ();
    else
      fail ("ASSOCFILLETSURFACEACTIONBODY.status [BS] %hu != %hu", assocfilletsurfaceactionbody->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (assocfilletsurfaceactionbody, "ASSOCFILLETSURFACEACTIONBODY", "status", &status, 0)
        && status == assocfilletsurfaceactionbody->status)
      pass ();
    else
      fail ("ASSOCFILLETSURFACEACTIONBODY.status [BS] set+1 %hu != %hu", assocfilletsurfaceactionbody->status, status);
    assocfilletsurfaceactionbody->status--;
  }
  if (failed && (is_class_unstable ("ASSOCFILLETSURFACEACTIONBODY") || is_class_debugging ("ASSOCFILLETSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCFILLETSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCGEOMDEPENDENCY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCGEOMDEPENDENCY *restrict assocgeomdependency = obj->tio.object->tio.ASSOCGEOMDEPENDENCY;
  failed = 0;
  if (!obj_obj || !assocgeomdependency)
    {
      fail ("NULL ASSOCGEOMDEPENDENCY");
      return 1;
    }
  {
    Dwg_Object_ASSOCDEPENDENCY assocdep;
    if (dwg_dynapi_entity_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "assocdep", &assocdep, NULL)
        && !memcmp (&assocdep, &assocgeomdependency->assocdep, sizeof (Dwg_Object_ASSOCDEPENDENCY)))
        pass ();
    else
        fail ("ASSOCGEOMDEPENDENCY.assocdep [Dwg_Object_ASSOCDEPENDENCY]");
  }
  {
    BITCODE_T assocdep_name;
    if (dwg_dynapi_entity_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "assocdep.name", &assocdep_name, NULL)
        && assocdep_name
           ? strEQ ((char *)assocdep_name, (char *)assocgeomdependency->assocdep.name)
           : !assocgeomdependency->assocdep.name)
      pass ();
    else
      fail ("ASSOCGEOMDEPENDENCY.assocdep.name [T] '%s' <> '%s'", assocdep_name, assocgeomdependency->assocdep.name);
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "class_version", &class_version, NULL)
        && class_version == assocgeomdependency->class_version)
      pass ();
    else
      fail ("ASSOCGEOMDEPENDENCY.class_version [BS] %hu != %hu", assocgeomdependency->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "class_version", &class_version, 0)
        && class_version == assocgeomdependency->class_version)
      pass ();
    else
      fail ("ASSOCGEOMDEPENDENCY.class_version [BS] set+1 %hu != %hu", assocgeomdependency->class_version, class_version);
    assocgeomdependency->class_version--;
  }
  {
    BITCODE_T classname;
    if (dwg_dynapi_entity_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "classname", &classname, NULL)
        && classname
           ? strEQ ((char *)classname, (char *)assocgeomdependency->classname)
           : !assocgeomdependency->classname)
      pass ();
    else
      fail ("ASSOCGEOMDEPENDENCY.classname [T] '%s' <> '%s'", classname, assocgeomdependency->classname);
  }
  {
    BITCODE_B dependent_on_compound_object;
    if (dwg_dynapi_entity_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "dependent_on_compound_object", &dependent_on_compound_object, NULL)
        && dependent_on_compound_object == assocgeomdependency->dependent_on_compound_object)
      pass ();
    else
      fail ("ASSOCGEOMDEPENDENCY.dependent_on_compound_object [B] " FORMAT_B " != " FORMAT_B "", assocgeomdependency->dependent_on_compound_object, dependent_on_compound_object);
    dependent_on_compound_object++;
    if (dwg_dynapi_entity_set_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "dependent_on_compound_object", &dependent_on_compound_object, 0)
        && dependent_on_compound_object == assocgeomdependency->dependent_on_compound_object)
      pass ();
    else
      fail ("ASSOCGEOMDEPENDENCY.dependent_on_compound_object [B] set+1 " FORMAT_B " != " FORMAT_B "", assocgeomdependency->dependent_on_compound_object, dependent_on_compound_object);
    assocgeomdependency->dependent_on_compound_object--;
  }
  {
    BITCODE_B enabled;
    if (dwg_dynapi_entity_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "enabled", &enabled, NULL)
        && enabled == assocgeomdependency->enabled)
      pass ();
    else
      fail ("ASSOCGEOMDEPENDENCY.enabled [B] " FORMAT_B " != " FORMAT_B "", assocgeomdependency->enabled, enabled);
    enabled++;
    if (dwg_dynapi_entity_set_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "enabled", &enabled, 0)
        && enabled == assocgeomdependency->enabled)
      pass ();
    else
      fail ("ASSOCGEOMDEPENDENCY.enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", assocgeomdependency->enabled, enabled);
    assocgeomdependency->enabled--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocgeomdependency, "ASSOCGEOMDEPENDENCY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocgeomdependency->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCGEOMDEPENDENCY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCGEOMDEPENDENCY") || is_class_debugging ("ASSOCGEOMDEPENDENCY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCGEOMDEPENDENCY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCLOFTEDSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCLOFTEDSURFACEACTIONBODY *restrict assocloftedsurfaceactionbody = obj->tio.object->tio.ASSOCLOFTEDSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocloftedsurfaceactionbody)
    {
      fail ("NULL ASSOCLOFTEDSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocloftedsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.aab_version [BL] %u != %u", assocloftedsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocloftedsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocloftedsurfaceactionbody->aab_version, aab_version);
    assocloftedsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocloftedsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.class_version [BL] %u != %u", assocloftedsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocloftedsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocloftedsurfaceactionbody->class_version, class_version);
    assocloftedsurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocloftedsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCLOFTEDSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocloftedsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCLOFTEDSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocloftedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocloftedsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocloftedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCLOFTEDSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocloftedsurfaceactionbody->pbsab_status, pbsab_status);
    assocloftedsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocloftedsurfaceactionbody, "ASSOCLOFTEDSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocloftedsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCLOFTEDSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCLOFTEDSURFACEACTIONBODY") || is_class_debugging ("ASSOCLOFTEDSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCLOFTEDSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCMLEADERACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCMLEADERACTIONBODY *restrict assocmleaderactionbody = obj->tio.object->tio.ASSOCMLEADERACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocmleaderactionbody)
    {
      fail ("NULL ASSOCMLEADERACTIONBODY");
      return 1;
    }
  {
    BITCODE_BS aaab_version;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "aaab_version", &aaab_version, NULL)
        && aaab_version == assocmleaderactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.aaab_version [BS] %hu != %hu", assocmleaderactionbody->aaab_version, aaab_version);
    aaab_version++;
    if (dwg_dynapi_entity_set_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "aaab_version", &aaab_version, 0)
        && aaab_version == assocmleaderactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.aaab_version [BS] set+1 %hu != %hu", assocmleaderactionbody->aaab_version, aaab_version);
    assocmleaderactionbody->aaab_version--;
  }
  {
    BITCODE_BS aab_version;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocmleaderactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.aab_version [BS] %hu != %hu", assocmleaderactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocmleaderactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.aab_version [BS] set+1 %hu != %hu", assocmleaderactionbody->aab_version, aab_version);
    assocmleaderactionbody->aab_version--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assocmleaderactionbody->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCMLEADERACTIONBODY.actionbody [H]");
  }
  {
    Dwg_ASSOCACTIONBODY_action* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "actions", &actions, NULL)
        && actions == assocmleaderactionbody->actions)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.actions [Dwg_ASSOCACTIONBODY_action*] * %u num_actions", count);
  }
  {
    BITCODE_H assoc_dep;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "assoc_dep", &assoc_dep, NULL)
        && !memcmp (&assoc_dep, &assocmleaderactionbody->assoc_dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCMLEADERACTIONBODY.assoc_dep [H]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocmleaderactionbody->class_version)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.class_version [BL] %u != %u", assocmleaderactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocmleaderactionbody->class_version)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.class_version [BL] set+1 %u != %u", assocmleaderactionbody->class_version, class_version);
    assocmleaderactionbody->class_version--;
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "num_actions", &num_actions, NULL)
        && num_actions == assocmleaderactionbody->num_actions)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.num_actions [BL] %u != %u", assocmleaderactionbody->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "num_actions", &num_actions, 0)
        && num_actions == assocmleaderactionbody->num_actions)
      pass ();
    else
      fail ("ASSOCMLEADERACTIONBODY.num_actions [BL] set+1 %u != %u", assocmleaderactionbody->num_actions, num_actions);
    assocmleaderactionbody->num_actions--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocmleaderactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCMLEADERACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocmleaderactionbody, "ASSOCMLEADERACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocmleaderactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCMLEADERACTIONBODY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCMLEADERACTIONBODY") || is_class_debugging ("ASSOCMLEADERACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCMLEADERACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCNETWORK (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCNETWORK *restrict assocnetwork = obj->tio.object->tio.ASSOCNETWORK;
  failed = 0;
  if (!obj_obj || !assocnetwork)
    {
      fail ("NULL ASSOCNETWORK");
      return 1;
    }
  {
    BITCODE_BL action_index;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "action_index", &action_index, NULL)
        && action_index == assocnetwork->action_index)
      pass ();
    else
      fail ("ASSOCNETWORK.action_index [BL] %u != %u", assocnetwork->action_index, action_index);
    action_index++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "action_index", &action_index, 0)
        && action_index == assocnetwork->action_index)
      pass ();
    else
      fail ("ASSOCNETWORK.action_index [BL] set+1 %u != %u", assocnetwork->action_index, action_index);
    assocnetwork->action_index--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assocnetwork->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCNETWORK.actionbody [H]");
  }
  {
    Dwg_ASSOCACTION_Deps* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "actions", &actions, NULL)
        && actions == assocnetwork->actions)
      pass ();
    else
      fail ("ASSOCNETWORK.actions [Dwg_ASSOCACTION_Deps*] * %u num_actions", count);
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "class_version", &class_version, NULL)
        && class_version == assocnetwork->class_version)
      pass ();
    else
      fail ("ASSOCNETWORK.class_version [BS] %hu != %hu", assocnetwork->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "class_version", &class_version, 0)
        && class_version == assocnetwork->class_version)
      pass ();
    else
      fail ("ASSOCNETWORK.class_version [BS] set+1 %hu != %hu", assocnetwork->class_version, class_version);
    assocnetwork->class_version--;
  }
  {
    Dwg_ASSOCACTION_Deps* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "deps", &deps, NULL)
        && deps == assocnetwork->deps)
      pass ();
    else
      fail ("ASSOCNETWORK.deps [Dwg_ASSOCACTION_Deps*] * %u num_deps", count);
  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "geometry_status", &geometry_status, NULL)
        && geometry_status == assocnetwork->geometry_status)
      pass ();
    else
      fail ("ASSOCNETWORK.geometry_status [BL] %u != %u", assocnetwork->geometry_status, geometry_status);
    geometry_status++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "geometry_status", &geometry_status, 0)
        && geometry_status == assocnetwork->geometry_status)
      pass ();
    else
      fail ("ASSOCNETWORK.geometry_status [BL] set+1 %u != %u", assocnetwork->geometry_status, geometry_status);
    assocnetwork->geometry_status--;
  }
  {
    BITCODE_BL max_assoc_dep_index;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "max_assoc_dep_index", &max_assoc_dep_index, NULL)
        && max_assoc_dep_index == assocnetwork->max_assoc_dep_index)
      pass ();
    else
      fail ("ASSOCNETWORK.max_assoc_dep_index [BL] %u != %u", assocnetwork->max_assoc_dep_index, max_assoc_dep_index);
    max_assoc_dep_index++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "max_assoc_dep_index", &max_assoc_dep_index, 0)
        && max_assoc_dep_index == assocnetwork->max_assoc_dep_index)
      pass ();
    else
      fail ("ASSOCNETWORK.max_assoc_dep_index [BL] set+1 %u != %u", assocnetwork->max_assoc_dep_index, max_assoc_dep_index);
    assocnetwork->max_assoc_dep_index--;
  }
  {
    BITCODE_BL network_action_index;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "network_action_index", &network_action_index, NULL)
        && network_action_index == assocnetwork->network_action_index)
      pass ();
    else
      fail ("ASSOCNETWORK.network_action_index [BL] %u != %u", assocnetwork->network_action_index, network_action_index);
    network_action_index++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "network_action_index", &network_action_index, 0)
        && network_action_index == assocnetwork->network_action_index)
      pass ();
    else
      fail ("ASSOCNETWORK.network_action_index [BL] set+1 %u != %u", assocnetwork->network_action_index, network_action_index);
    assocnetwork->network_action_index--;
  }
  {
    BITCODE_BS network_version;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "network_version", &network_version, NULL)
        && network_version == assocnetwork->network_version)
      pass ();
    else
      fail ("ASSOCNETWORK.network_version [BS] %hu != %hu", assocnetwork->network_version, network_version);
    network_version++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "network_version", &network_version, 0)
        && network_version == assocnetwork->network_version)
      pass ();
    else
      fail ("ASSOCNETWORK.network_version [BS] set+1 %hu != %hu", assocnetwork->network_version, network_version);
    assocnetwork->network_version--;
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_actions", &num_actions, NULL)
        && num_actions == assocnetwork->num_actions)
      pass ();
    else
      fail ("ASSOCNETWORK.num_actions [BL] %u != %u", assocnetwork->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "num_actions", &num_actions, 0)
        && num_actions == assocnetwork->num_actions)
      pass ();
    else
      fail ("ASSOCNETWORK.num_actions [BL] set+1 %u != %u", assocnetwork->num_actions, num_actions);
    assocnetwork->num_actions--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_deps", &num_deps, NULL)
        && num_deps == assocnetwork->num_deps)
      pass ();
    else
      fail ("ASSOCNETWORK.num_deps [BL] %u != %u", assocnetwork->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "num_deps", &num_deps, 0)
        && num_deps == assocnetwork->num_deps)
      pass ();
    else
      fail ("ASSOCNETWORK.num_deps [BL] set+1 %u != %u", assocnetwork->num_deps, num_deps);
    assocnetwork->num_deps--;
  }
  {
    BITCODE_BL num_owned_actions;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_owned_actions", &num_owned_actions, NULL)
        && num_owned_actions == assocnetwork->num_owned_actions)
      pass ();
    else
      fail ("ASSOCNETWORK.num_owned_actions [BL] %u != %u", assocnetwork->num_owned_actions, num_owned_actions);
    num_owned_actions++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "num_owned_actions", &num_owned_actions, 0)
        && num_owned_actions == assocnetwork->num_owned_actions)
      pass ();
    else
      fail ("ASSOCNETWORK.num_owned_actions [BL] set+1 %u != %u", assocnetwork->num_owned_actions, num_owned_actions);
    assocnetwork->num_owned_actions--;
  }
  {
    BITCODE_BL num_owned_params;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_owned_params", &num_owned_params, NULL)
        && num_owned_params == assocnetwork->num_owned_params)
      pass ();
    else
      fail ("ASSOCNETWORK.num_owned_params [BL] %u != %u", assocnetwork->num_owned_params, num_owned_params);
    num_owned_params++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "num_owned_params", &num_owned_params, 0)
        && num_owned_params == assocnetwork->num_owned_params)
      pass ();
    else
      fail ("ASSOCNETWORK.num_owned_params [BL] set+1 %u != %u", assocnetwork->num_owned_params, num_owned_params);
    assocnetwork->num_owned_params--;
  }
  {
    BITCODE_BL num_values;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_values", &num_values, NULL)
        && num_values == assocnetwork->num_values)
      pass ();
    else
      fail ("ASSOCNETWORK.num_values [BL] %u != %u", assocnetwork->num_values, num_values);
    num_values++;
    if (dwg_dynapi_entity_set_value (assocnetwork, "ASSOCNETWORK", "num_values", &num_values, 0)
        && num_values == assocnetwork->num_values)
      pass ();
    else
      fail ("ASSOCNETWORK.num_values [BL] set+1 %u != %u", assocnetwork->num_values, num_values);
    assocnetwork->num_values--;
  }
  {
    BITCODE_H* owned_actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_owned_actions", &count, NULL)
        && dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "owned_actions", &owned_actions, NULL)
        && owned_actions == assocnetwork->owned_actions)
      pass ();
    else
      fail ("ASSOCNETWORK.owned_actions [H*] * %u num_owned_actions", count);
  }
  {
    BITCODE_H* owned_params;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_owned_params", &count, NULL)
        && dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "owned_params", &owned_params, NULL)
        && owned_params == assocnetwork->owned_params)
      pass ();
    else
      fail ("ASSOCNETWORK.owned_params [H*] * %u num_owned_params", count);
  }
  {
    BITCODE_H owningnetwork;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "owningnetwork", &owningnetwork, NULL)
        && !memcmp (&owningnetwork, &assocnetwork->owningnetwork, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCNETWORK.owningnetwork [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "parent", &parent, NULL)
        && !memcmp (&parent, &assocnetwork->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCNETWORK.parent [struct _dwg_object_object*]");
  }
  {
    struct _dwg_VALUEPARAM* values;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "num_values", &count, NULL)
        && dwg_dynapi_entity_value (assocnetwork, "ASSOCNETWORK", "values", &values, NULL)
        && values == assocnetwork->values)
      pass ();
    else
      fail ("ASSOCNETWORK.values [struct _dwg_VALUEPARAM*] * %u num_values", count);
  }
  if (failed && (is_class_unstable ("ASSOCNETWORK") || is_class_debugging ("ASSOCNETWORK")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCNETWORK", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCNETWORKSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCNETWORKSURFACEACTIONBODY *restrict assocnetworksurfaceactionbody = obj->tio.object->tio.ASSOCNETWORKSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocnetworksurfaceactionbody)
    {
      fail ("NULL ASSOCNETWORKSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocnetworksurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCNETWORKSURFACEACTIONBODY.aab_version [BL] %u != %u", assocnetworksurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocnetworksurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCNETWORKSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocnetworksurfaceactionbody->aab_version, aab_version);
    assocnetworksurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocnetworksurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCNETWORKSURFACEACTIONBODY.class_version [BL] %u != %u", assocnetworksurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocnetworksurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCNETWORKSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocnetworksurfaceactionbody->class_version, class_version);
    assocnetworksurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocnetworksurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCNETWORKSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocnetworksurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCNETWORKSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocnetworksurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCNETWORKSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocnetworksurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocnetworksurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCNETWORKSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocnetworksurfaceactionbody->pbsab_status, pbsab_status);
    assocnetworksurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocnetworksurfaceactionbody, "ASSOCNETWORKSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocnetworksurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCNETWORKSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCNETWORKSURFACEACTIONBODY") || is_class_debugging ("ASSOCNETWORKSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCNETWORKSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCOBJECTACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCOBJECTACTIONPARAM *restrict assocobjectactionparam = obj->tio.object->tio.ASSOCOBJECTACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocobjectactionparam)
    {
      fail ("NULL ASSOCOBJECTACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocobjectactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.aap_version [BL] %u != %u", assocobjectactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocobjectactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.aap_version [BL] set+1 %u != %u", assocobjectactionparam->aap_version, aap_version);
    assocobjectactionparam->aap_version--;
  }
  {
    BITCODE_BL asdap_class_version;
    if (dwg_dynapi_entity_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "asdap_class_version", &asdap_class_version, NULL)
        && asdap_class_version == assocobjectactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.asdap_class_version [BL] %u != %u", assocobjectactionparam->asdap_class_version, asdap_class_version);
    asdap_class_version++;
    if (dwg_dynapi_entity_set_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "asdap_class_version", &asdap_class_version, 0)
        && asdap_class_version == assocobjectactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.asdap_class_version [BL] set+1 %u != %u", assocobjectactionparam->asdap_class_version, asdap_class_version);
    assocobjectactionparam->asdap_class_version--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assocobjectactionparam->class_version)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.class_version [BS] %hu != %hu", assocobjectactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assocobjectactionparam->class_version)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.class_version [BS] set+1 %hu != %hu", assocobjectactionparam->class_version, class_version);
    assocobjectactionparam->class_version--;
  }
  {
    BITCODE_H dep;
    if (dwg_dynapi_entity_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "dep", &dep, NULL)
        && !memcmp (&dep, &assocobjectactionparam->dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCOBJECTACTIONPARAM.dep [H]");
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocobjectactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.is_r2013 [BS] %hu != %hu", assocobjectactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocobjectactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocobjectactionparam->is_r2013, is_r2013);
    assocobjectactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocobjectactionparam->name)
           : !assocobjectactionparam->name)
      pass ();
    else
      fail ("ASSOCOBJECTACTIONPARAM.name [T] '%s' <> '%s'", name, assocobjectactionparam->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocobjectactionparam, "ASSOCOBJECTACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocobjectactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCOBJECTACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCOBJECTACTIONPARAM") || is_class_debugging ("ASSOCOBJECTACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCOBJECTACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCOFFSETSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCOFFSETSURFACEACTIONBODY *restrict assocoffsetsurfaceactionbody = obj->tio.object->tio.ASSOCOFFSETSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocoffsetsurfaceactionbody)
    {
      fail ("NULL ASSOCOFFSETSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocoffsetsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCOFFSETSURFACEACTIONBODY.aab_version [BL] %u != %u", assocoffsetsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocoffsetsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCOFFSETSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocoffsetsurfaceactionbody->aab_version, aab_version);
    assocoffsetsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_B b1;
    if (dwg_dynapi_entity_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "b1", &b1, NULL)
        && b1 == assocoffsetsurfaceactionbody->b1)
      pass ();
    else
      fail ("ASSOCOFFSETSURFACEACTIONBODY.b1 [B] " FORMAT_B " != " FORMAT_B "", assocoffsetsurfaceactionbody->b1, b1);
    b1++;
    if (dwg_dynapi_entity_set_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "b1", &b1, 0)
        && b1 == assocoffsetsurfaceactionbody->b1)
      pass ();
    else
      fail ("ASSOCOFFSETSURFACEACTIONBODY.b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocoffsetsurfaceactionbody->b1, b1);
    assocoffsetsurfaceactionbody->b1--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocoffsetsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCOFFSETSURFACEACTIONBODY.class_version [BL] %u != %u", assocoffsetsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocoffsetsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCOFFSETSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocoffsetsurfaceactionbody->class_version, class_version);
    assocoffsetsurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocoffsetsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCOFFSETSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocoffsetsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCOFFSETSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocoffsetsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCOFFSETSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocoffsetsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocoffsetsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCOFFSETSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocoffsetsurfaceactionbody->pbsab_status, pbsab_status);
    assocoffsetsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocoffsetsurfaceactionbody, "ASSOCOFFSETSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocoffsetsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCOFFSETSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCOFFSETSURFACEACTIONBODY") || is_class_debugging ("ASSOCOFFSETSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCOFFSETSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCORDINATEDIMACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCORDINATEDIMACTIONBODY *restrict assocordinatedimactionbody = obj->tio.object->tio.ASSOCORDINATEDIMACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocordinatedimactionbody)
    {
      fail ("NULL ASSOCORDINATEDIMACTIONBODY");
      return 1;
    }
  {
    BITCODE_BS aaab_version;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "aaab_version", &aaab_version, NULL)
        && aaab_version == assocordinatedimactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCORDINATEDIMACTIONBODY.aaab_version [BS] %hu != %hu", assocordinatedimactionbody->aaab_version, aaab_version);
    aaab_version++;
    if (dwg_dynapi_entity_set_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "aaab_version", &aaab_version, 0)
        && aaab_version == assocordinatedimactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCORDINATEDIMACTIONBODY.aaab_version [BS] set+1 %hu != %hu", assocordinatedimactionbody->aaab_version, aaab_version);
    assocordinatedimactionbody->aaab_version--;
  }
  {
    BITCODE_BS aab_version;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocordinatedimactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCORDINATEDIMACTIONBODY.aab_version [BS] %hu != %hu", assocordinatedimactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocordinatedimactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCORDINATEDIMACTIONBODY.aab_version [BS] set+1 %hu != %hu", assocordinatedimactionbody->aab_version, aab_version);
    assocordinatedimactionbody->aab_version--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assocordinatedimactionbody->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCORDINATEDIMACTIONBODY.actionbody [H]");
  }
  {
    BITCODE_H assoc_dep;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "assoc_dep", &assoc_dep, NULL)
        && !memcmp (&assoc_dep, &assocordinatedimactionbody->assoc_dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCORDINATEDIMACTIONBODY.assoc_dep [H]");
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocordinatedimactionbody->class_version)
      pass ();
    else
      fail ("ASSOCORDINATEDIMACTIONBODY.class_version [BL] %u != %u", assocordinatedimactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocordinatedimactionbody->class_version)
      pass ();
    else
      fail ("ASSOCORDINATEDIMACTIONBODY.class_version [BL] set+1 %u != %u", assocordinatedimactionbody->class_version, class_version);
    assocordinatedimactionbody->class_version--;
  }
  {
    BITCODE_H d_node;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "d_node", &d_node, NULL)
        && !memcmp (&d_node, &assocordinatedimactionbody->d_node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCORDINATEDIMACTIONBODY.d_node [H]");
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocordinatedimactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCORDINATEDIMACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocordinatedimactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCORDINATEDIMACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H r_node;
    if (dwg_dynapi_entity_value (assocordinatedimactionbody, "ASSOCORDINATEDIMACTIONBODY", "r_node", &r_node, NULL)
        && !memcmp (&r_node, &assocordinatedimactionbody->r_node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCORDINATEDIMACTIONBODY.r_node [H]");
  }
  if (failed && (is_class_unstable ("ASSOCORDINATEDIMACTIONBODY") || is_class_debugging ("ASSOCORDINATEDIMACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCORDINATEDIMACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCOSNAPPOINTREFACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM *restrict assocosnappointrefactionparam = obj->tio.object->tio.ASSOCOSNAPPOINTREFACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocosnappointrefactionparam)
    {
      fail ("NULL ASSOCOSNAPPOINTREFACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocosnappointrefactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.aap_version [BL] %u != %u", assocosnappointrefactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocosnappointrefactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.aap_version [BL] set+1 %u != %u", assocosnappointrefactionparam->aap_version, aap_version);
    assocosnappointrefactionparam->aap_version--;
  }
  {
    BITCODE_BL bl2;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "bl2", &bl2, NULL)
        && bl2 == assocosnappointrefactionparam->bl2)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.bl2 [BL] %u != %u", assocosnappointrefactionparam->bl2, bl2);
    bl2++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "bl2", &bl2, 0)
        && bl2 == assocosnappointrefactionparam->bl2)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.bl2 [BL] set+1 %u != %u", assocosnappointrefactionparam->bl2, bl2);
    assocosnappointrefactionparam->bl2--;
  }
  {
    BITCODE_BS bs1;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "bs1", &bs1, NULL)
        && bs1 == assocosnappointrefactionparam->bs1)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.bs1 [BS] %hu != %hu", assocosnappointrefactionparam->bs1, bs1);
    bs1++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "bs1", &bs1, 0)
        && bs1 == assocosnappointrefactionparam->bs1)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.bs1 [BS] set+1 %hu != %hu", assocosnappointrefactionparam->bs1, bs1);
    assocosnappointrefactionparam->bs1--;
  }
  {
    BITCODE_BL child_id;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "child_id", &child_id, NULL)
        && child_id == assocosnappointrefactionparam->child_id)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.child_id [BL] %u != %u", assocosnappointrefactionparam->child_id, child_id);
    child_id++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "child_id", &child_id, 0)
        && child_id == assocosnappointrefactionparam->child_id)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.child_id [BL] set+1 %u != %u", assocosnappointrefactionparam->child_id, child_id);
    assocosnappointrefactionparam->child_id--;
  }
  {
    BITCODE_H child_param;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "child_param", &child_param, NULL)
        && !memcmp (&child_param, &assocosnappointrefactionparam->child_param, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.child_param [H]");
  }
  {
    BITCODE_BS child_status;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "child_status", &child_status, NULL)
        && child_status == assocosnappointrefactionparam->child_status)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.child_status [BS] %hu != %hu", assocosnappointrefactionparam->child_status, child_status);
    child_status++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "child_status", &child_status, 0)
        && child_status == assocosnappointrefactionparam->child_status)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.child_status [BS] set+1 %hu != %hu", assocosnappointrefactionparam->child_status, child_status);
    assocosnappointrefactionparam->child_status--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assocosnappointrefactionparam->class_version)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.class_version [BS] %hu != %hu", assocosnappointrefactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assocosnappointrefactionparam->class_version)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.class_version [BS] set+1 %hu != %hu", assocosnappointrefactionparam->class_version, class_version);
    assocosnappointrefactionparam->class_version--;
  }
  {
    BITCODE_H h330_2;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "h330_2", &h330_2, NULL)
        && !memcmp (&h330_2, &assocosnappointrefactionparam->h330_2, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.h330_2 [H]");
  }
  {
    BITCODE_H h330_3;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "h330_3", &h330_3, NULL)
        && !memcmp (&h330_3, &assocosnappointrefactionparam->h330_3, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.h330_3 [H]");
  }
  {
    BITCODE_B has_child_param;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "has_child_param", &has_child_param, NULL)
        && has_child_param == assocosnappointrefactionparam->has_child_param)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.has_child_param [B] " FORMAT_B " != " FORMAT_B "", assocosnappointrefactionparam->has_child_param, has_child_param);
    has_child_param++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "has_child_param", &has_child_param, 0)
        && has_child_param == assocosnappointrefactionparam->has_child_param)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.has_child_param [B] set+1 " FORMAT_B " != " FORMAT_B "", assocosnappointrefactionparam->has_child_param, has_child_param);
    assocosnappointrefactionparam->has_child_param--;
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocosnappointrefactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.is_r2013 [BS] %hu != %hu", assocosnappointrefactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocosnappointrefactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocosnappointrefactionparam->is_r2013, is_r2013);
    assocosnappointrefactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocosnappointrefactionparam->name)
           : !assocosnappointrefactionparam->name)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.name [T] '%s' <> '%s'", name, assocosnappointrefactionparam->name);
  }
  {
    BITCODE_BL num_params;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "num_params", &num_params, NULL)
        && num_params == assocosnappointrefactionparam->num_params)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BL] %u != %u", assocosnappointrefactionparam->num_params, num_params);
    num_params++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "num_params", &num_params, 0)
        && num_params == assocosnappointrefactionparam->num_params)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BL] set+1 %u != %u", assocosnappointrefactionparam->num_params, num_params);
    assocosnappointrefactionparam->num_params--;
  }
  {
    BITCODE_RC osnap_mode;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "osnap_mode", &osnap_mode, NULL)
        && osnap_mode == assocosnappointrefactionparam->osnap_mode)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.osnap_mode [RC] %u != %u", assocosnappointrefactionparam->osnap_mode, osnap_mode);
    osnap_mode++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "osnap_mode", &osnap_mode, 0)
        && osnap_mode == assocosnappointrefactionparam->osnap_mode)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.osnap_mode [RC] set+1 %u != %u", assocosnappointrefactionparam->osnap_mode, osnap_mode);
    assocosnappointrefactionparam->osnap_mode--;
  }
  {
    BITCODE_BD param;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "param", &param, NULL)
        && param == assocosnappointrefactionparam->param)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.param [BD] %g != %g", assocosnappointrefactionparam->param, param);
    param++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "param", &param, 0)
        && param == assocosnappointrefactionparam->param)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.param [BD] set+1 %g != %g", assocosnappointrefactionparam->param, param);
    assocosnappointrefactionparam->param--;
  }
  {
    BITCODE_H* params;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "num_params", &count, NULL)
        && dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "params", &params, NULL)
        && params == assocosnappointrefactionparam->params)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.params [H*] * %u num_params", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocosnappointrefactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS status;
    if (dwg_dynapi_entity_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "status", &status, NULL)
        && status == assocosnappointrefactionparam->status)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] %hu != %hu", assocosnappointrefactionparam->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "status", &status, 0)
        && status == assocosnappointrefactionparam->status)
      pass ();
    else
      fail ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] set+1 %hu != %hu", assocosnappointrefactionparam->status, status);
    assocosnappointrefactionparam->status--;
  }
  if (failed && (is_class_unstable ("ASSOCOSNAPPOINTREFACTIONPARAM") || is_class_debugging ("ASSOCOSNAPPOINTREFACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCOSNAPPOINTREFACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCPATCHSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCPATCHSURFACEACTIONBODY *restrict assocpatchsurfaceactionbody = obj->tio.object->tio.ASSOCPATCHSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocpatchsurfaceactionbody)
    {
      fail ("NULL ASSOCPATCHSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocpatchsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCPATCHSURFACEACTIONBODY.aab_version [BL] %u != %u", assocpatchsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocpatchsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCPATCHSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocpatchsurfaceactionbody->aab_version, aab_version);
    assocpatchsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocpatchsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCPATCHSURFACEACTIONBODY.class_version [BL] %u != %u", assocpatchsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocpatchsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCPATCHSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocpatchsurfaceactionbody->class_version, class_version);
    assocpatchsurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocpatchsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCPATCHSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocpatchsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCPATCHSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocpatchsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCPATCHSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocpatchsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocpatchsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCPATCHSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocpatchsurfaceactionbody->pbsab_status, pbsab_status);
    assocpatchsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocpatchsurfaceactionbody, "ASSOCPATCHSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocpatchsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCPATCHSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCPATCHSURFACEACTIONBODY") || is_class_debugging ("ASSOCPATCHSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCPATCHSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCPATHACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCPATHACTIONPARAM *restrict assocpathactionparam = obj->tio.object->tio.ASSOCPATHACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocpathactionparam)
    {
      fail ("NULL ASSOCPATHACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocpathactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.aap_version [BL] %u != %u", assocpathactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocpathactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.aap_version [BL] set+1 %u != %u", assocpathactionparam->aap_version, aap_version);
    assocpathactionparam->aap_version--;
  }
  {
    BITCODE_BL bl2;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "bl2", &bl2, NULL)
        && bl2 == assocpathactionparam->bl2)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.bl2 [BL] %u != %u", assocpathactionparam->bl2, bl2);
    bl2++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "bl2", &bl2, 0)
        && bl2 == assocpathactionparam->bl2)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.bl2 [BL] set+1 %u != %u", assocpathactionparam->bl2, bl2);
    assocpathactionparam->bl2--;
  }
  {
    BITCODE_BS bs1;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "bs1", &bs1, NULL)
        && bs1 == assocpathactionparam->bs1)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.bs1 [BS] %hu != %hu", assocpathactionparam->bs1, bs1);
    bs1++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "bs1", &bs1, 0)
        && bs1 == assocpathactionparam->bs1)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.bs1 [BS] set+1 %hu != %hu", assocpathactionparam->bs1, bs1);
    assocpathactionparam->bs1--;
  }
  {
    BITCODE_BL child_id;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "child_id", &child_id, NULL)
        && child_id == assocpathactionparam->child_id)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.child_id [BL] %u != %u", assocpathactionparam->child_id, child_id);
    child_id++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "child_id", &child_id, 0)
        && child_id == assocpathactionparam->child_id)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.child_id [BL] set+1 %u != %u", assocpathactionparam->child_id, child_id);
    assocpathactionparam->child_id--;
  }
  {
    BITCODE_H child_param;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "child_param", &child_param, NULL)
        && !memcmp (&child_param, &assocpathactionparam->child_param, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCPATHACTIONPARAM.child_param [H]");
  }
  {
    BITCODE_BS child_status;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "child_status", &child_status, NULL)
        && child_status == assocpathactionparam->child_status)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.child_status [BS] %hu != %hu", assocpathactionparam->child_status, child_status);
    child_status++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "child_status", &child_status, 0)
        && child_status == assocpathactionparam->child_status)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.child_status [BS] set+1 %hu != %hu", assocpathactionparam->child_status, child_status);
    assocpathactionparam->child_status--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assocpathactionparam->class_version)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.class_version [BS] %hu != %hu", assocpathactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assocpathactionparam->class_version)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.class_version [BS] set+1 %hu != %hu", assocpathactionparam->class_version, class_version);
    assocpathactionparam->class_version--;
  }
  {
    BITCODE_H h330_2;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "h330_2", &h330_2, NULL)
        && !memcmp (&h330_2, &assocpathactionparam->h330_2, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCPATHACTIONPARAM.h330_2 [H]");
  }
  {
    BITCODE_H h330_3;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "h330_3", &h330_3, NULL)
        && !memcmp (&h330_3, &assocpathactionparam->h330_3, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCPATHACTIONPARAM.h330_3 [H]");
  }
  {
    BITCODE_B has_child_param;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "has_child_param", &has_child_param, NULL)
        && has_child_param == assocpathactionparam->has_child_param)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.has_child_param [B] " FORMAT_B " != " FORMAT_B "", assocpathactionparam->has_child_param, has_child_param);
    has_child_param++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "has_child_param", &has_child_param, 0)
        && has_child_param == assocpathactionparam->has_child_param)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.has_child_param [B] set+1 " FORMAT_B " != " FORMAT_B "", assocpathactionparam->has_child_param, has_child_param);
    assocpathactionparam->has_child_param--;
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocpathactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.is_r2013 [BS] %hu != %hu", assocpathactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocpathactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocpathactionparam->is_r2013, is_r2013);
    assocpathactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocpathactionparam->name)
           : !assocpathactionparam->name)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.name [T] '%s' <> '%s'", name, assocpathactionparam->name);
  }
  {
    BITCODE_BL num_params;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "num_params", &num_params, NULL)
        && num_params == assocpathactionparam->num_params)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.num_params [BL] %u != %u", assocpathactionparam->num_params, num_params);
    num_params++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "num_params", &num_params, 0)
        && num_params == assocpathactionparam->num_params)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.num_params [BL] set+1 %u != %u", assocpathactionparam->num_params, num_params);
    assocpathactionparam->num_params--;
  }
  {
    BITCODE_H* params;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "num_params", &count, NULL)
        && dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "params", &params, NULL)
        && params == assocpathactionparam->params)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.params [H*] * %u num_params", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocpathactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCPATHACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "version", &version, NULL)
        && version == assocpathactionparam->version)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.version [BL] %u != %u", assocpathactionparam->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (assocpathactionparam, "ASSOCPATHACTIONPARAM", "version", &version, 0)
        && version == assocpathactionparam->version)
      pass ();
    else
      fail ("ASSOCPATHACTIONPARAM.version [BL] set+1 %u != %u", assocpathactionparam->version, version);
    assocpathactionparam->version--;
  }
  if (failed && (is_class_unstable ("ASSOCPATHACTIONPARAM") || is_class_debugging ("ASSOCPATHACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCPATHACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCPERSSUBENTMANAGER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCPERSSUBENTMANAGER *restrict assocperssubentmanager = obj->tio.object->tio.ASSOCPERSSUBENTMANAGER;
  failed = 0;
  if (!obj_obj || !assocperssubentmanager)
    {
      fail ("NULL ASSOCPERSSUBENTMANAGER");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "class_version", &class_version, NULL)
        && class_version == assocperssubentmanager->class_version)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.class_version [BL] %u != %u", assocperssubentmanager->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "class_version", &class_version, 0)
        && class_version == assocperssubentmanager->class_version)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.class_version [BL] set+1 %u != %u", assocperssubentmanager->class_version, class_version);
    assocperssubentmanager->class_version--;
  }
  {
    BITCODE_BL num_steps;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "num_steps", &num_steps, NULL)
        && num_steps == assocperssubentmanager->num_steps)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.num_steps [BL] %u != %u", assocperssubentmanager->num_steps, num_steps);
    num_steps++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "num_steps", &num_steps, 0)
        && num_steps == assocperssubentmanager->num_steps)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.num_steps [BL] set+1 %u != %u", assocperssubentmanager->num_steps, num_steps);
    assocperssubentmanager->num_steps--;
  }
  {
    BITCODE_BL num_subents;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "num_subents", &num_subents, NULL)
        && num_subents == assocperssubentmanager->num_subents)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.num_subents [BL] %u != %u", assocperssubentmanager->num_subents, num_subents);
    num_subents++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "num_subents", &num_subents, 0)
        && num_subents == assocperssubentmanager->num_subents)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.num_subents [BL] set+1 %u != %u", assocperssubentmanager->num_subents, num_subents);
    assocperssubentmanager->num_subents--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "parent", &parent, NULL)
        && !memcmp (&parent, &assocperssubentmanager->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCPERSSUBENTMANAGER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL* steps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "num_steps", &count, NULL)
        && dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "steps", &steps, NULL)
        && steps == assocperssubentmanager->steps)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.steps [BL*] * %u num_steps", count);
  }
  {
    BITCODE_BL* subents;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "num_subents", &count, NULL)
        && dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "subents", &subents, NULL)
        && subents == assocperssubentmanager->subents)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.subents [BL*] * %u num_subents", count);
  }
  {
    BITCODE_BL unknown_0;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_0", &unknown_0, NULL)
        && unknown_0 == assocperssubentmanager->unknown_0)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_0 [BL] %u != %u", assocperssubentmanager->unknown_0, unknown_0);
    unknown_0++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_0", &unknown_0, 0)
        && unknown_0 == assocperssubentmanager->unknown_0)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_0 [BL] set+1 %u != %u", assocperssubentmanager->unknown_0, unknown_0);
    assocperssubentmanager->unknown_0--;
  }
  {
    BITCODE_BL unknown_2;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_2", &unknown_2, NULL)
        && unknown_2 == assocperssubentmanager->unknown_2)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_2 [BL] %u != %u", assocperssubentmanager->unknown_2, unknown_2);
    unknown_2++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_2", &unknown_2, 0)
        && unknown_2 == assocperssubentmanager->unknown_2)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_2 [BL] set+1 %u != %u", assocperssubentmanager->unknown_2, unknown_2);
    assocperssubentmanager->unknown_2--;
  }
  {
    BITCODE_BL unknown_3;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_3", &unknown_3, NULL)
        && unknown_3 == assocperssubentmanager->unknown_3)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_3 [BL] %u != %u", assocperssubentmanager->unknown_3, unknown_3);
    unknown_3++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_3", &unknown_3, 0)
        && unknown_3 == assocperssubentmanager->unknown_3)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_3 [BL] set+1 %u != %u", assocperssubentmanager->unknown_3, unknown_3);
    assocperssubentmanager->unknown_3--;
  }
  {
    BITCODE_B unknown_b37;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_b37", &unknown_b37, NULL)
        && unknown_b37 == assocperssubentmanager->unknown_b37)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] " FORMAT_B " != " FORMAT_B "", assocperssubentmanager->unknown_b37, unknown_b37);
    unknown_b37++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_b37", &unknown_b37, 0)
        && unknown_b37 == assocperssubentmanager->unknown_b37)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocperssubentmanager->unknown_b37, unknown_b37);
    assocperssubentmanager->unknown_b37--;
  }
  {
    BITCODE_BL unknown_bl10;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl10", &unknown_bl10, NULL)
        && unknown_bl10 == assocperssubentmanager->unknown_bl10)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] %u != %u", assocperssubentmanager->unknown_bl10, unknown_bl10);
    unknown_bl10++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl10", &unknown_bl10, 0)
        && unknown_bl10 == assocperssubentmanager->unknown_bl10)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl10, unknown_bl10);
    assocperssubentmanager->unknown_bl10--;
  }
  {
    BITCODE_BL unknown_bl11;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl11", &unknown_bl11, NULL)
        && unknown_bl11 == assocperssubentmanager->unknown_bl11)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] %u != %u", assocperssubentmanager->unknown_bl11, unknown_bl11);
    unknown_bl11++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl11", &unknown_bl11, 0)
        && unknown_bl11 == assocperssubentmanager->unknown_bl11)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl11, unknown_bl11);
    assocperssubentmanager->unknown_bl11--;
  }
  {
    BITCODE_BL unknown_bl12;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl12", &unknown_bl12, NULL)
        && unknown_bl12 == assocperssubentmanager->unknown_bl12)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] %u != %u", assocperssubentmanager->unknown_bl12, unknown_bl12);
    unknown_bl12++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl12", &unknown_bl12, 0)
        && unknown_bl12 == assocperssubentmanager->unknown_bl12)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl12, unknown_bl12);
    assocperssubentmanager->unknown_bl12--;
  }
  {
    BITCODE_BL unknown_bl13;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl13", &unknown_bl13, NULL)
        && unknown_bl13 == assocperssubentmanager->unknown_bl13)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] %u != %u", assocperssubentmanager->unknown_bl13, unknown_bl13);
    unknown_bl13++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl13", &unknown_bl13, 0)
        && unknown_bl13 == assocperssubentmanager->unknown_bl13)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl13, unknown_bl13);
    assocperssubentmanager->unknown_bl13--;
  }
  {
    BITCODE_BL unknown_bl14;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl14", &unknown_bl14, NULL)
        && unknown_bl14 == assocperssubentmanager->unknown_bl14)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] %u != %u", assocperssubentmanager->unknown_bl14, unknown_bl14);
    unknown_bl14++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl14", &unknown_bl14, 0)
        && unknown_bl14 == assocperssubentmanager->unknown_bl14)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl14, unknown_bl14);
    assocperssubentmanager->unknown_bl14--;
  }
  {
    BITCODE_BL unknown_bl15;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl15", &unknown_bl15, NULL)
        && unknown_bl15 == assocperssubentmanager->unknown_bl15)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] %u != %u", assocperssubentmanager->unknown_bl15, unknown_bl15);
    unknown_bl15++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl15", &unknown_bl15, 0)
        && unknown_bl15 == assocperssubentmanager->unknown_bl15)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl15, unknown_bl15);
    assocperssubentmanager->unknown_bl15--;
  }
  {
    BITCODE_BL unknown_bl16;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl16", &unknown_bl16, NULL)
        && unknown_bl16 == assocperssubentmanager->unknown_bl16)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] %u != %u", assocperssubentmanager->unknown_bl16, unknown_bl16);
    unknown_bl16++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl16", &unknown_bl16, 0)
        && unknown_bl16 == assocperssubentmanager->unknown_bl16)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl16, unknown_bl16);
    assocperssubentmanager->unknown_bl16--;
  }
  {
    BITCODE_BL unknown_bl17;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl17", &unknown_bl17, NULL)
        && unknown_bl17 == assocperssubentmanager->unknown_bl17)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] %u != %u", assocperssubentmanager->unknown_bl17, unknown_bl17);
    unknown_bl17++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl17", &unknown_bl17, 0)
        && unknown_bl17 == assocperssubentmanager->unknown_bl17)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl17, unknown_bl17);
    assocperssubentmanager->unknown_bl17--;
  }
  {
    BITCODE_BL unknown_bl18;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl18", &unknown_bl18, NULL)
        && unknown_bl18 == assocperssubentmanager->unknown_bl18)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] %u != %u", assocperssubentmanager->unknown_bl18, unknown_bl18);
    unknown_bl18++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl18", &unknown_bl18, 0)
        && unknown_bl18 == assocperssubentmanager->unknown_bl18)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl18, unknown_bl18);
    assocperssubentmanager->unknown_bl18--;
  }
  {
    BITCODE_BL unknown_bl19;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl19", &unknown_bl19, NULL)
        && unknown_bl19 == assocperssubentmanager->unknown_bl19)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] %u != %u", assocperssubentmanager->unknown_bl19, unknown_bl19);
    unknown_bl19++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl19", &unknown_bl19, 0)
        && unknown_bl19 == assocperssubentmanager->unknown_bl19)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl19, unknown_bl19);
    assocperssubentmanager->unknown_bl19--;
  }
  {
    BITCODE_BL unknown_bl20;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl20", &unknown_bl20, NULL)
        && unknown_bl20 == assocperssubentmanager->unknown_bl20)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] %u != %u", assocperssubentmanager->unknown_bl20, unknown_bl20);
    unknown_bl20++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl20", &unknown_bl20, 0)
        && unknown_bl20 == assocperssubentmanager->unknown_bl20)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl20, unknown_bl20);
    assocperssubentmanager->unknown_bl20--;
  }
  {
    BITCODE_BL unknown_bl21;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl21", &unknown_bl21, NULL)
        && unknown_bl21 == assocperssubentmanager->unknown_bl21)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] %u != %u", assocperssubentmanager->unknown_bl21, unknown_bl21);
    unknown_bl21++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl21", &unknown_bl21, 0)
        && unknown_bl21 == assocperssubentmanager->unknown_bl21)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl21, unknown_bl21);
    assocperssubentmanager->unknown_bl21--;
  }
  {
    BITCODE_BL unknown_bl22;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl22", &unknown_bl22, NULL)
        && unknown_bl22 == assocperssubentmanager->unknown_bl22)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] %u != %u", assocperssubentmanager->unknown_bl22, unknown_bl22);
    unknown_bl22++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl22", &unknown_bl22, 0)
        && unknown_bl22 == assocperssubentmanager->unknown_bl22)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl22, unknown_bl22);
    assocperssubentmanager->unknown_bl22--;
  }
  {
    BITCODE_BL unknown_bl23;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl23", &unknown_bl23, NULL)
        && unknown_bl23 == assocperssubentmanager->unknown_bl23)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] %u != %u", assocperssubentmanager->unknown_bl23, unknown_bl23);
    unknown_bl23++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl23", &unknown_bl23, 0)
        && unknown_bl23 == assocperssubentmanager->unknown_bl23)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl23, unknown_bl23);
    assocperssubentmanager->unknown_bl23--;
  }
  {
    BITCODE_BL unknown_bl24;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl24", &unknown_bl24, NULL)
        && unknown_bl24 == assocperssubentmanager->unknown_bl24)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] %u != %u", assocperssubentmanager->unknown_bl24, unknown_bl24);
    unknown_bl24++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl24", &unknown_bl24, 0)
        && unknown_bl24 == assocperssubentmanager->unknown_bl24)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl24, unknown_bl24);
    assocperssubentmanager->unknown_bl24--;
  }
  {
    BITCODE_BL unknown_bl25;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl25", &unknown_bl25, NULL)
        && unknown_bl25 == assocperssubentmanager->unknown_bl25)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] %u != %u", assocperssubentmanager->unknown_bl25, unknown_bl25);
    unknown_bl25++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl25", &unknown_bl25, 0)
        && unknown_bl25 == assocperssubentmanager->unknown_bl25)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl25, unknown_bl25);
    assocperssubentmanager->unknown_bl25--;
  }
  {
    BITCODE_BL unknown_bl26;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl26", &unknown_bl26, NULL)
        && unknown_bl26 == assocperssubentmanager->unknown_bl26)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] %u != %u", assocperssubentmanager->unknown_bl26, unknown_bl26);
    unknown_bl26++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl26", &unknown_bl26, 0)
        && unknown_bl26 == assocperssubentmanager->unknown_bl26)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl26, unknown_bl26);
    assocperssubentmanager->unknown_bl26--;
  }
  {
    BITCODE_BL unknown_bl27;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl27", &unknown_bl27, NULL)
        && unknown_bl27 == assocperssubentmanager->unknown_bl27)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] %u != %u", assocperssubentmanager->unknown_bl27, unknown_bl27);
    unknown_bl27++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl27", &unknown_bl27, 0)
        && unknown_bl27 == assocperssubentmanager->unknown_bl27)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl27, unknown_bl27);
    assocperssubentmanager->unknown_bl27--;
  }
  {
    BITCODE_BL unknown_bl28;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl28", &unknown_bl28, NULL)
        && unknown_bl28 == assocperssubentmanager->unknown_bl28)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] %u != %u", assocperssubentmanager->unknown_bl28, unknown_bl28);
    unknown_bl28++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl28", &unknown_bl28, 0)
        && unknown_bl28 == assocperssubentmanager->unknown_bl28)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl28, unknown_bl28);
    assocperssubentmanager->unknown_bl28--;
  }
  {
    BITCODE_BL unknown_bl29;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl29", &unknown_bl29, NULL)
        && unknown_bl29 == assocperssubentmanager->unknown_bl29)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] %u != %u", assocperssubentmanager->unknown_bl29, unknown_bl29);
    unknown_bl29++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl29", &unknown_bl29, 0)
        && unknown_bl29 == assocperssubentmanager->unknown_bl29)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl29, unknown_bl29);
    assocperssubentmanager->unknown_bl29--;
  }
  {
    BITCODE_BL unknown_bl30;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl30", &unknown_bl30, NULL)
        && unknown_bl30 == assocperssubentmanager->unknown_bl30)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] %u != %u", assocperssubentmanager->unknown_bl30, unknown_bl30);
    unknown_bl30++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl30", &unknown_bl30, 0)
        && unknown_bl30 == assocperssubentmanager->unknown_bl30)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl30, unknown_bl30);
    assocperssubentmanager->unknown_bl30--;
  }
  {
    BITCODE_BL unknown_bl31;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl31", &unknown_bl31, NULL)
        && unknown_bl31 == assocperssubentmanager->unknown_bl31)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] %u != %u", assocperssubentmanager->unknown_bl31, unknown_bl31);
    unknown_bl31++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl31", &unknown_bl31, 0)
        && unknown_bl31 == assocperssubentmanager->unknown_bl31)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl31, unknown_bl31);
    assocperssubentmanager->unknown_bl31--;
  }
  {
    BITCODE_BL unknown_bl32;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl32", &unknown_bl32, NULL)
        && unknown_bl32 == assocperssubentmanager->unknown_bl32)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] %u != %u", assocperssubentmanager->unknown_bl32, unknown_bl32);
    unknown_bl32++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl32", &unknown_bl32, 0)
        && unknown_bl32 == assocperssubentmanager->unknown_bl32)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl32, unknown_bl32);
    assocperssubentmanager->unknown_bl32--;
  }
  {
    BITCODE_BL unknown_bl33;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl33", &unknown_bl33, NULL)
        && unknown_bl33 == assocperssubentmanager->unknown_bl33)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] %u != %u", assocperssubentmanager->unknown_bl33, unknown_bl33);
    unknown_bl33++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl33", &unknown_bl33, 0)
        && unknown_bl33 == assocperssubentmanager->unknown_bl33)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl33, unknown_bl33);
    assocperssubentmanager->unknown_bl33--;
  }
  {
    BITCODE_BL unknown_bl34;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl34", &unknown_bl34, NULL)
        && unknown_bl34 == assocperssubentmanager->unknown_bl34)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] %u != %u", assocperssubentmanager->unknown_bl34, unknown_bl34);
    unknown_bl34++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl34", &unknown_bl34, 0)
        && unknown_bl34 == assocperssubentmanager->unknown_bl34)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl34, unknown_bl34);
    assocperssubentmanager->unknown_bl34--;
  }
  {
    BITCODE_BL unknown_bl35;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl35", &unknown_bl35, NULL)
        && unknown_bl35 == assocperssubentmanager->unknown_bl35)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] %u != %u", assocperssubentmanager->unknown_bl35, unknown_bl35);
    unknown_bl35++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl35", &unknown_bl35, 0)
        && unknown_bl35 == assocperssubentmanager->unknown_bl35)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl35, unknown_bl35);
    assocperssubentmanager->unknown_bl35--;
  }
  {
    BITCODE_BL unknown_bl36;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl36", &unknown_bl36, NULL)
        && unknown_bl36 == assocperssubentmanager->unknown_bl36)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] %u != %u", assocperssubentmanager->unknown_bl36, unknown_bl36);
    unknown_bl36++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl36", &unknown_bl36, 0)
        && unknown_bl36 == assocperssubentmanager->unknown_bl36)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl36, unknown_bl36);
    assocperssubentmanager->unknown_bl36--;
  }
  {
    BITCODE_BL unknown_bl6;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, NULL)
        && unknown_bl6 == assocperssubentmanager->unknown_bl6)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] %u != %u", assocperssubentmanager->unknown_bl6, unknown_bl6);
    unknown_bl6++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, 0)
        && unknown_bl6 == assocperssubentmanager->unknown_bl6)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl6, unknown_bl6);
    assocperssubentmanager->unknown_bl6--;
  }
  {
    BITCODE_BL unknown_bl6a;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6a", &unknown_bl6a, NULL)
        && unknown_bl6a == assocperssubentmanager->unknown_bl6a)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] %u != %u", assocperssubentmanager->unknown_bl6a, unknown_bl6a);
    unknown_bl6a++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6a", &unknown_bl6a, 0)
        && unknown_bl6a == assocperssubentmanager->unknown_bl6a)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl6a, unknown_bl6a);
    assocperssubentmanager->unknown_bl6a--;
  }
  {
    BITCODE_BL unknown_bl7;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7", &unknown_bl7, NULL)
        && unknown_bl7 == assocperssubentmanager->unknown_bl7)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] %u != %u", assocperssubentmanager->unknown_bl7, unknown_bl7);
    unknown_bl7++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7", &unknown_bl7, 0)
        && unknown_bl7 == assocperssubentmanager->unknown_bl7)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl7, unknown_bl7);
    assocperssubentmanager->unknown_bl7--;
  }
  {
    BITCODE_BL unknown_bl7a;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7a", &unknown_bl7a, NULL)
        && unknown_bl7a == assocperssubentmanager->unknown_bl7a)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] %u != %u", assocperssubentmanager->unknown_bl7a, unknown_bl7a);
    unknown_bl7a++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7a", &unknown_bl7a, 0)
        && unknown_bl7a == assocperssubentmanager->unknown_bl7a)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl7a, unknown_bl7a);
    assocperssubentmanager->unknown_bl7a--;
  }
  {
    BITCODE_BL unknown_bl8;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl8", &unknown_bl8, NULL)
        && unknown_bl8 == assocperssubentmanager->unknown_bl8)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] %u != %u", assocperssubentmanager->unknown_bl8, unknown_bl8);
    unknown_bl8++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl8", &unknown_bl8, 0)
        && unknown_bl8 == assocperssubentmanager->unknown_bl8)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl8, unknown_bl8);
    assocperssubentmanager->unknown_bl8--;
  }
  {
    BITCODE_BL unknown_bl9;
    if (dwg_dynapi_entity_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl9", &unknown_bl9, NULL)
        && unknown_bl9 == assocperssubentmanager->unknown_bl9)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] %u != %u", assocperssubentmanager->unknown_bl9, unknown_bl9);
    unknown_bl9++;
    if (dwg_dynapi_entity_set_value (assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl9", &unknown_bl9, 0)
        && unknown_bl9 == assocperssubentmanager->unknown_bl9)
      pass ();
    else
      fail ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] set+1 %u != %u", assocperssubentmanager->unknown_bl9, unknown_bl9);
    assocperssubentmanager->unknown_bl9--;
  }
  if (failed && (is_class_unstable ("ASSOCPERSSUBENTMANAGER") || is_class_debugging ("ASSOCPERSSUBENTMANAGER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCPERSSUBENTMANAGER", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCPLANESURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCPLANESURFACEACTIONBODY *restrict assocplanesurfaceactionbody = obj->tio.object->tio.ASSOCPLANESURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocplanesurfaceactionbody)
    {
      fail ("NULL ASSOCPLANESURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocplanesurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.aab_version [BL] %u != %u", assocplanesurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocplanesurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocplanesurfaceactionbody->aab_version, aab_version);
    assocplanesurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocplanesurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.class_version [BL] %u != %u", assocplanesurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocplanesurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocplanesurfaceactionbody->class_version, class_version);
    assocplanesurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocplanesurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCPLANESURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocplanesurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCPLANESURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocplanesurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocplanesurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocplanesurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocplanesurfaceactionbody->pbsab_status, pbsab_status);
    assocplanesurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocplanesurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCPLANESURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCPLANESURFACEACTIONBODY") || is_class_debugging ("ASSOCPLANESURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCPLANESURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCPOINTREFACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCPOINTREFACTIONPARAM *restrict assocpointrefactionparam = obj->tio.object->tio.ASSOCPOINTREFACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocpointrefactionparam)
    {
      fail ("NULL ASSOCPOINTREFACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocpointrefactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.aap_version [BL] %u != %u", assocpointrefactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocpointrefactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.aap_version [BL] set+1 %u != %u", assocpointrefactionparam->aap_version, aap_version);
    assocpointrefactionparam->aap_version--;
  }
  {
    BITCODE_BL bl2;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "bl2", &bl2, NULL)
        && bl2 == assocpointrefactionparam->bl2)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.bl2 [BL] %u != %u", assocpointrefactionparam->bl2, bl2);
    bl2++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "bl2", &bl2, 0)
        && bl2 == assocpointrefactionparam->bl2)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.bl2 [BL] set+1 %u != %u", assocpointrefactionparam->bl2, bl2);
    assocpointrefactionparam->bl2--;
  }
  {
    BITCODE_BS bs1;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "bs1", &bs1, NULL)
        && bs1 == assocpointrefactionparam->bs1)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.bs1 [BS] %hu != %hu", assocpointrefactionparam->bs1, bs1);
    bs1++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "bs1", &bs1, 0)
        && bs1 == assocpointrefactionparam->bs1)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.bs1 [BS] set+1 %hu != %hu", assocpointrefactionparam->bs1, bs1);
    assocpointrefactionparam->bs1--;
  }
  {
    BITCODE_BL child_id;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "child_id", &child_id, NULL)
        && child_id == assocpointrefactionparam->child_id)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.child_id [BL] %u != %u", assocpointrefactionparam->child_id, child_id);
    child_id++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "child_id", &child_id, 0)
        && child_id == assocpointrefactionparam->child_id)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.child_id [BL] set+1 %u != %u", assocpointrefactionparam->child_id, child_id);
    assocpointrefactionparam->child_id--;
  }
  {
    BITCODE_H child_param;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "child_param", &child_param, NULL)
        && !memcmp (&child_param, &assocpointrefactionparam->child_param, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCPOINTREFACTIONPARAM.child_param [H]");
  }
  {
    BITCODE_BS child_status;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "child_status", &child_status, NULL)
        && child_status == assocpointrefactionparam->child_status)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.child_status [BS] %hu != %hu", assocpointrefactionparam->child_status, child_status);
    child_status++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "child_status", &child_status, 0)
        && child_status == assocpointrefactionparam->child_status)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.child_status [BS] set+1 %hu != %hu", assocpointrefactionparam->child_status, child_status);
    assocpointrefactionparam->child_status--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assocpointrefactionparam->class_version)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.class_version [BS] %hu != %hu", assocpointrefactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assocpointrefactionparam->class_version)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.class_version [BS] set+1 %hu != %hu", assocpointrefactionparam->class_version, class_version);
    assocpointrefactionparam->class_version--;
  }
  {
    BITCODE_H h330_2;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "h330_2", &h330_2, NULL)
        && !memcmp (&h330_2, &assocpointrefactionparam->h330_2, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCPOINTREFACTIONPARAM.h330_2 [H]");
  }
  {
    BITCODE_H h330_3;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "h330_3", &h330_3, NULL)
        && !memcmp (&h330_3, &assocpointrefactionparam->h330_3, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCPOINTREFACTIONPARAM.h330_3 [H]");
  }
  {
    BITCODE_B has_child_param;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "has_child_param", &has_child_param, NULL)
        && has_child_param == assocpointrefactionparam->has_child_param)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.has_child_param [B] " FORMAT_B " != " FORMAT_B "", assocpointrefactionparam->has_child_param, has_child_param);
    has_child_param++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "has_child_param", &has_child_param, 0)
        && has_child_param == assocpointrefactionparam->has_child_param)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.has_child_param [B] set+1 " FORMAT_B " != " FORMAT_B "", assocpointrefactionparam->has_child_param, has_child_param);
    assocpointrefactionparam->has_child_param--;
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocpointrefactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.is_r2013 [BS] %hu != %hu", assocpointrefactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocpointrefactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocpointrefactionparam->is_r2013, is_r2013);
    assocpointrefactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocpointrefactionparam->name)
           : !assocpointrefactionparam->name)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.name [T] '%s' <> '%s'", name, assocpointrefactionparam->name);
  }
  {
    BITCODE_BL num_params;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "num_params", &num_params, NULL)
        && num_params == assocpointrefactionparam->num_params)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.num_params [BL] %u != %u", assocpointrefactionparam->num_params, num_params);
    num_params++;
    if (dwg_dynapi_entity_set_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "num_params", &num_params, 0)
        && num_params == assocpointrefactionparam->num_params)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.num_params [BL] set+1 %u != %u", assocpointrefactionparam->num_params, num_params);
    assocpointrefactionparam->num_params--;
  }
  {
    BITCODE_H* params;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "num_params", &count, NULL)
        && dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "params", &params, NULL)
        && params == assocpointrefactionparam->params)
      pass ();
    else
      fail ("ASSOCPOINTREFACTIONPARAM.params [H*] * %u num_params", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocpointrefactionparam, "ASSOCPOINTREFACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocpointrefactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCPOINTREFACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCPOINTREFACTIONPARAM") || is_class_debugging ("ASSOCPOINTREFACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCPOINTREFACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCRESTOREENTITYSTATEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCRESTOREENTITYSTATEACTIONBODY *restrict assocrestoreentitystateactionbody = obj->tio.object->tio.ASSOCRESTOREENTITYSTATEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocrestoreentitystateactionbody)
    {
      fail ("NULL ASSOCRESTOREENTITYSTATEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocrestoreentitystateactionbody, "ASSOCRESTOREENTITYSTATEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocrestoreentitystateactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCRESTOREENTITYSTATEACTIONBODY.aab_version [BL] %u != %u", assocrestoreentitystateactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocrestoreentitystateactionbody, "ASSOCRESTOREENTITYSTATEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocrestoreentitystateactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCRESTOREENTITYSTATEACTIONBODY.aab_version [BL] set+1 %u != %u", assocrestoreentitystateactionbody->aab_version, aab_version);
    assocrestoreentitystateactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocrestoreentitystateactionbody, "ASSOCRESTOREENTITYSTATEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocrestoreentitystateactionbody->class_version)
      pass ();
    else
      fail ("ASSOCRESTOREENTITYSTATEACTIONBODY.class_version [BL] %u != %u", assocrestoreentitystateactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocrestoreentitystateactionbody, "ASSOCRESTOREENTITYSTATEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocrestoreentitystateactionbody->class_version)
      pass ();
    else
      fail ("ASSOCRESTOREENTITYSTATEACTIONBODY.class_version [BL] set+1 %u != %u", assocrestoreentitystateactionbody->class_version, class_version);
    assocrestoreentitystateactionbody->class_version--;
  }
  {
    BITCODE_H entity;
    if (dwg_dynapi_entity_value (assocrestoreentitystateactionbody, "ASSOCRESTOREENTITYSTATEACTIONBODY", "entity", &entity, NULL)
        && !memcmp (&entity, &assocrestoreentitystateactionbody->entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCRESTOREENTITYSTATEACTIONBODY.entity [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocrestoreentitystateactionbody, "ASSOCRESTOREENTITYSTATEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocrestoreentitystateactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCRESTOREENTITYSTATEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCRESTOREENTITYSTATEACTIONBODY") || is_class_debugging ("ASSOCRESTOREENTITYSTATEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCRESTOREENTITYSTATEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCREVOLVEDSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCREVOLVEDSURFACEACTIONBODY *restrict assocrevolvedsurfaceactionbody = obj->tio.object->tio.ASSOCREVOLVEDSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocrevolvedsurfaceactionbody)
    {
      fail ("NULL ASSOCREVOLVEDSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocrevolvedsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.aab_version [BL] %u != %u", assocrevolvedsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocrevolvedsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->aab_version, aab_version);
    assocrevolvedsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocrevolvedsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.class_version [BL] %u != %u", assocrevolvedsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocrevolvedsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->class_version, class_version);
    assocrevolvedsurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocrevolvedsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocrevolvedsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCREVOLVEDSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocrevolvedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocrevolvedsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocrevolvedsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCREVOLVEDSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocrevolvedsurfaceactionbody->pbsab_status, pbsab_status);
    assocrevolvedsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocrevolvedsurfaceactionbody, "ASSOCREVOLVEDSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocrevolvedsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCREVOLVEDSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCREVOLVEDSURFACEACTIONBODY") || is_class_debugging ("ASSOCREVOLVEDSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCREVOLVEDSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCROTATEDDIMACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCROTATEDDIMACTIONBODY *restrict assocrotateddimactionbody = obj->tio.object->tio.ASSOCROTATEDDIMACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocrotateddimactionbody)
    {
      fail ("NULL ASSOCROTATEDDIMACTIONBODY");
      return 1;
    }
  {
    BITCODE_BS aaab_version;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "aaab_version", &aaab_version, NULL)
        && aaab_version == assocrotateddimactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCROTATEDDIMACTIONBODY.aaab_version [BS] %hu != %hu", assocrotateddimactionbody->aaab_version, aaab_version);
    aaab_version++;
    if (dwg_dynapi_entity_set_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "aaab_version", &aaab_version, 0)
        && aaab_version == assocrotateddimactionbody->aaab_version)
      pass ();
    else
      fail ("ASSOCROTATEDDIMACTIONBODY.aaab_version [BS] set+1 %hu != %hu", assocrotateddimactionbody->aaab_version, aaab_version);
    assocrotateddimactionbody->aaab_version--;
  }
  {
    BITCODE_BS aab_version;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocrotateddimactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCROTATEDDIMACTIONBODY.aab_version [BS] %hu != %hu", assocrotateddimactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocrotateddimactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCROTATEDDIMACTIONBODY.aab_version [BS] set+1 %hu != %hu", assocrotateddimactionbody->aab_version, aab_version);
    assocrotateddimactionbody->aab_version--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assocrotateddimactionbody->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCROTATEDDIMACTIONBODY.actionbody [H]");
  }
  {
    BITCODE_H assoc_dep;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "assoc_dep", &assoc_dep, NULL)
        && !memcmp (&assoc_dep, &assocrotateddimactionbody->assoc_dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCROTATEDDIMACTIONBODY.assoc_dep [H]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocrotateddimactionbody->class_version)
      pass ();
    else
      fail ("ASSOCROTATEDDIMACTIONBODY.class_version [BS] %hu != %hu", assocrotateddimactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocrotateddimactionbody->class_version)
      pass ();
    else
      fail ("ASSOCROTATEDDIMACTIONBODY.class_version [BS] set+1 %hu != %hu", assocrotateddimactionbody->class_version, class_version);
    assocrotateddimactionbody->class_version--;
  }
  {
    BITCODE_H d_node;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "d_node", &d_node, NULL)
        && !memcmp (&d_node, &assocrotateddimactionbody->d_node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCROTATEDDIMACTIONBODY.d_node [H]");
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocrotateddimactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCROTATEDDIMACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocrotateddimactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCROTATEDDIMACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H r_node;
    if (dwg_dynapi_entity_value (assocrotateddimactionbody, "ASSOCROTATEDDIMACTIONBODY", "r_node", &r_node, NULL)
        && !memcmp (&r_node, &assocrotateddimactionbody->r_node, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCROTATEDDIMACTIONBODY.r_node [H]");
  }
  if (failed && (is_class_unstable ("ASSOCROTATEDDIMACTIONBODY") || is_class_debugging ("ASSOCROTATEDDIMACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCROTATEDDIMACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCSWEPTSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCSWEPTSURFACEACTIONBODY *restrict assocsweptsurfaceactionbody = obj->tio.object->tio.ASSOCSWEPTSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assocsweptsurfaceactionbody)
    {
      fail ("NULL ASSOCSWEPTSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assocsweptsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.aab_version [BL] %u != %u", assocsweptsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assocsweptsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assocsweptsurfaceactionbody->aab_version, aab_version);
    assocsweptsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assocsweptsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.class_version [BL] %u != %u", assocsweptsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assocsweptsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assocsweptsurfaceactionbody->class_version, class_version);
    assocsweptsurfaceactionbody->class_version--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assocsweptsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCSWEPTSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocsweptsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCSWEPTSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assocsweptsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocsweptsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assocsweptsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCSWEPTSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assocsweptsurfaceactionbody->pbsab_status, pbsab_status);
    assocsweptsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assocsweptsurfaceactionbody, "ASSOCSWEPTSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assocsweptsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCSWEPTSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCSWEPTSURFACEACTIONBODY") || is_class_debugging ("ASSOCSWEPTSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCSWEPTSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCTRIMSURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCTRIMSURFACEACTIONBODY *restrict assoctrimsurfaceactionbody = obj->tio.object->tio.ASSOCTRIMSURFACEACTIONBODY;
  failed = 0;
  if (!obj_obj || !assoctrimsurfaceactionbody)
    {
      fail ("NULL ASSOCTRIMSURFACEACTIONBODY");
      return 1;
    }
  {
    BITCODE_BL aab_version;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "aab_version", &aab_version, NULL)
        && aab_version == assoctrimsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.aab_version [BL] %u != %u", assoctrimsurfaceactionbody->aab_version, aab_version);
    aab_version++;
    if (dwg_dynapi_entity_set_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "aab_version", &aab_version, 0)
        && aab_version == assoctrimsurfaceactionbody->aab_version)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.aab_version [BL] set+1 %u != %u", assoctrimsurfaceactionbody->aab_version, aab_version);
    assoctrimsurfaceactionbody->aab_version--;
  }
  {
    BITCODE_B b1;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "b1", &b1, NULL)
        && b1 == assoctrimsurfaceactionbody->b1)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.b1 [B] " FORMAT_B " != " FORMAT_B "", assoctrimsurfaceactionbody->b1, b1);
    b1++;
    if (dwg_dynapi_entity_set_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "b1", &b1, 0)
        && b1 == assoctrimsurfaceactionbody->b1)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assoctrimsurfaceactionbody->b1, b1);
    assoctrimsurfaceactionbody->b1--;
  }
  {
    BITCODE_B b2;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "b2", &b2, NULL)
        && b2 == assoctrimsurfaceactionbody->b2)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.b2 [B] " FORMAT_B " != " FORMAT_B "", assoctrimsurfaceactionbody->b2, b2);
    b2++;
    if (dwg_dynapi_entity_set_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "b2", &b2, 0)
        && b2 == assoctrimsurfaceactionbody->b2)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assoctrimsurfaceactionbody->b2, b2);
    assoctrimsurfaceactionbody->b2--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "class_version", &class_version, NULL)
        && class_version == assoctrimsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.class_version [BL] %u != %u", assoctrimsurfaceactionbody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "class_version", &class_version, 0)
        && class_version == assoctrimsurfaceactionbody->class_version)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.class_version [BL] set+1 %u != %u", assoctrimsurfaceactionbody->class_version, class_version);
    assoctrimsurfaceactionbody->class_version--;
  }
  {
    BITCODE_BD distance;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "distance", &distance, NULL)
        && distance == assoctrimsurfaceactionbody->distance)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.distance [BD] %g != %g", assoctrimsurfaceactionbody->distance, distance);
    distance++;
    if (dwg_dynapi_entity_set_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "distance", &distance, 0)
        && distance == assoctrimsurfaceactionbody->distance)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.distance [BD] set+1 %g != %g", assoctrimsurfaceactionbody->distance, distance);
    assoctrimsurfaceactionbody->distance--;
  }
  {
    Dwg_ASSOCPARAMBASEDACTIONBODY pab;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "pab", &pab, NULL)
        && !memcmp (&pab, &assoctrimsurfaceactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
        pass ();
    else
        fail ("ASSOCTRIMSURFACEACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &assoctrimsurfaceactionbody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCTRIMSURFACEACTIONBODY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL)
        && pbsab_status == assoctrimsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.pbsab_status [BL] %u != %u", assoctrimsurfaceactionbody->pbsab_status, pbsab_status);
    pbsab_status++;
    if (dwg_dynapi_entity_set_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "pbsab_status", &pbsab_status, 0)
        && pbsab_status == assoctrimsurfaceactionbody->pbsab_status)
      pass ();
    else
      fail ("ASSOCTRIMSURFACEACTIONBODY.pbsab_status [BL] set+1 %u != %u", assoctrimsurfaceactionbody->pbsab_status, pbsab_status);
    assoctrimsurfaceactionbody->pbsab_status--;
  }
  {
    Dwg_ASSOCSURFACEACTIONBODY sab;
    if (dwg_dynapi_entity_value (assoctrimsurfaceactionbody, "ASSOCTRIMSURFACEACTIONBODY", "sab", &sab, NULL)
        && !memcmp (&sab, &assoctrimsurfaceactionbody->sab, sizeof (Dwg_ASSOCSURFACEACTIONBODY)))
        pass ();
    else
        fail ("ASSOCTRIMSURFACEACTIONBODY.sab [Dwg_ASSOCSURFACEACTIONBODY]");
  }
  if (failed && (is_class_unstable ("ASSOCTRIMSURFACEACTIONBODY") || is_class_debugging ("ASSOCTRIMSURFACEACTIONBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCTRIMSURFACEACTIONBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCVALUEDEPENDENCY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCVALUEDEPENDENCY *restrict assocvaluedependency = obj->tio.object->tio.ASSOCVALUEDEPENDENCY;
  failed = 0;
  if (!obj_obj || !assocvaluedependency)
    {
      fail ("NULL ASSOCVALUEDEPENDENCY");
      return 1;
    }
  {
    Dwg_Object_ASSOCDEPENDENCY assocdep;
    if (dwg_dynapi_entity_value (assocvaluedependency, "ASSOCVALUEDEPENDENCY", "assocdep", &assocdep, NULL)
        && !memcmp (&assocdep, &assocvaluedependency->assocdep, sizeof (Dwg_Object_ASSOCDEPENDENCY)))
        pass ();
    else
        fail ("ASSOCVALUEDEPENDENCY.assocdep [Dwg_Object_ASSOCDEPENDENCY]");
  }
  {
    BITCODE_T assocdep_name;
    if (dwg_dynapi_entity_value (assocvaluedependency, "ASSOCVALUEDEPENDENCY", "assocdep.name", &assocdep_name, NULL)
        && assocdep_name
           ? strEQ ((char *)assocdep_name, (char *)assocvaluedependency->assocdep.name)
           : !assocvaluedependency->assocdep.name)
      pass ();
    else
      fail ("ASSOCVALUEDEPENDENCY.assocdep.name [T] '%s' <> '%s'", assocdep_name, assocvaluedependency->assocdep.name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocvaluedependency, "ASSOCVALUEDEPENDENCY", "parent", &parent, NULL)
        && !memcmp (&parent, &assocvaluedependency->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCVALUEDEPENDENCY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("ASSOCVALUEDEPENDENCY") || is_class_debugging ("ASSOCVALUEDEPENDENCY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCVALUEDEPENDENCY", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCVARIABLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCVARIABLE *restrict assocvariable = obj->tio.object->tio.ASSOCVARIABLE;
  failed = 0;
  if (!obj_obj || !assocvariable)
    {
      fail ("NULL ASSOCVARIABLE");
      return 1;
    }
  {
    BITCODE_BL action_index;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "action_index", &action_index, NULL)
        && action_index == assocvariable->action_index)
      pass ();
    else
      fail ("ASSOCVARIABLE.action_index [BL] %u != %u", assocvariable->action_index, action_index);
    action_index++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "action_index", &action_index, 0)
        && action_index == assocvariable->action_index)
      pass ();
    else
      fail ("ASSOCVARIABLE.action_index [BL] set+1 %u != %u", assocvariable->action_index, action_index);
    assocvariable->action_index--;
  }
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "actionbody", &actionbody, NULL)
        && !memcmp (&actionbody, &assocvariable->actionbody, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCVARIABLE.actionbody [H]");
  }
  {
    BITCODE_BS av_class_version;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "av_class_version", &av_class_version, NULL)
        && av_class_version == assocvariable->av_class_version)
      pass ();
    else
      fail ("ASSOCVARIABLE.av_class_version [BS] %hu != %hu", assocvariable->av_class_version, av_class_version);
    av_class_version++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "av_class_version", &av_class_version, 0)
        && av_class_version == assocvariable->av_class_version)
      pass ();
    else
      fail ("ASSOCVARIABLE.av_class_version [BS] set+1 %hu != %hu", assocvariable->av_class_version, av_class_version);
    assocvariable->av_class_version--;
  }
  {
    BITCODE_B b290;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "b290", &b290, NULL)
        && b290 == assocvariable->b290)
      pass ();
    else
      fail ("ASSOCVARIABLE.b290 [B] " FORMAT_B " != " FORMAT_B "", assocvariable->b290, b290);
    b290++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "b290", &b290, 0)
        && b290 == assocvariable->b290)
      pass ();
    else
      fail ("ASSOCVARIABLE.b290 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocvariable->b290, b290);
    assocvariable->b290--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "class_version", &class_version, NULL)
        && class_version == assocvariable->class_version)
      pass ();
    else
      fail ("ASSOCVARIABLE.class_version [BS] %hu != %hu", assocvariable->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "class_version", &class_version, 0)
        && class_version == assocvariable->class_version)
      pass ();
    else
      fail ("ASSOCVARIABLE.class_version [BS] set+1 %hu != %hu", assocvariable->class_version, class_version);
    assocvariable->class_version--;
  }
  {
    Dwg_ASSOCACTION_Deps* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "deps", &deps, NULL)
        && deps == assocvariable->deps)
      pass ();
    else
      fail ("ASSOCVARIABLE.deps [Dwg_ASSOCACTION_Deps*] * %u num_deps", count);
  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "desc", &desc, NULL)
        && desc
           ? strEQ ((char *)desc, (char *)assocvariable->desc)
           : !assocvariable->desc)
      pass ();
    else
      fail ("ASSOCVARIABLE.desc [T] '%s' <> '%s'", desc, assocvariable->desc);
  }
  {
    BITCODE_T evaluator;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "evaluator", &evaluator, NULL)
        && evaluator
           ? strEQ ((char *)evaluator, (char *)assocvariable->evaluator)
           : !assocvariable->evaluator)
      pass ();
    else
      fail ("ASSOCVARIABLE.evaluator [T] '%s' <> '%s'", evaluator, assocvariable->evaluator);
  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "geometry_status", &geometry_status, NULL)
        && geometry_status == assocvariable->geometry_status)
      pass ();
    else
      fail ("ASSOCVARIABLE.geometry_status [BL] %u != %u", assocvariable->geometry_status, geometry_status);
    geometry_status++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "geometry_status", &geometry_status, 0)
        && geometry_status == assocvariable->geometry_status)
      pass ();
    else
      fail ("ASSOCVARIABLE.geometry_status [BL] set+1 %u != %u", assocvariable->geometry_status, geometry_status);
    assocvariable->geometry_status--;
  }
  {
    BITCODE_B has_t78;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "has_t78", &has_t78, NULL)
        && has_t78 == assocvariable->has_t78)
      pass ();
    else
      fail ("ASSOCVARIABLE.has_t78 [B] " FORMAT_B " != " FORMAT_B "", assocvariable->has_t78, has_t78);
    has_t78++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "has_t78", &has_t78, 0)
        && has_t78 == assocvariable->has_t78)
      pass ();
    else
      fail ("ASSOCVARIABLE.has_t78 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocvariable->has_t78, has_t78);
    assocvariable->has_t78--;
  }
  {
    BITCODE_BL max_assoc_dep_index;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "max_assoc_dep_index", &max_assoc_dep_index, NULL)
        && max_assoc_dep_index == assocvariable->max_assoc_dep_index)
      pass ();
    else
      fail ("ASSOCVARIABLE.max_assoc_dep_index [BL] %u != %u", assocvariable->max_assoc_dep_index, max_assoc_dep_index);
    max_assoc_dep_index++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "max_assoc_dep_index", &max_assoc_dep_index, 0)
        && max_assoc_dep_index == assocvariable->max_assoc_dep_index)
      pass ();
    else
      fail ("ASSOCVARIABLE.max_assoc_dep_index [BL] set+1 %u != %u", assocvariable->max_assoc_dep_index, max_assoc_dep_index);
    assocvariable->max_assoc_dep_index--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocvariable->name)
           : !assocvariable->name)
      pass ();
    else
      fail ("ASSOCVARIABLE.name [T] '%s' <> '%s'", name, assocvariable->name);
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "num_deps", &num_deps, NULL)
        && num_deps == assocvariable->num_deps)
      pass ();
    else
      fail ("ASSOCVARIABLE.num_deps [BL] %u != %u", assocvariable->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "num_deps", &num_deps, 0)
        && num_deps == assocvariable->num_deps)
      pass ();
    else
      fail ("ASSOCVARIABLE.num_deps [BL] set+1 %u != %u", assocvariable->num_deps, num_deps);
    assocvariable->num_deps--;
  }
  {
    BITCODE_BL num_owned_params;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "num_owned_params", &num_owned_params, NULL)
        && num_owned_params == assocvariable->num_owned_params)
      pass ();
    else
      fail ("ASSOCVARIABLE.num_owned_params [BL] %u != %u", assocvariable->num_owned_params, num_owned_params);
    num_owned_params++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "num_owned_params", &num_owned_params, 0)
        && num_owned_params == assocvariable->num_owned_params)
      pass ();
    else
      fail ("ASSOCVARIABLE.num_owned_params [BL] set+1 %u != %u", assocvariable->num_owned_params, num_owned_params);
    assocvariable->num_owned_params--;
  }
  {
    BITCODE_BL num_values;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "num_values", &num_values, NULL)
        && num_values == assocvariable->num_values)
      pass ();
    else
      fail ("ASSOCVARIABLE.num_values [BL] %u != %u", assocvariable->num_values, num_values);
    num_values++;
    if (dwg_dynapi_entity_set_value (assocvariable, "ASSOCVARIABLE", "num_values", &num_values, 0)
        && num_values == assocvariable->num_values)
      pass ();
    else
      fail ("ASSOCVARIABLE.num_values [BL] set+1 %u != %u", assocvariable->num_values, num_values);
    assocvariable->num_values--;
  }
  {
    BITCODE_H* owned_params;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "num_owned_params", &count, NULL)
        && dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "owned_params", &owned_params, NULL)
        && owned_params == assocvariable->owned_params)
      pass ();
    else
      fail ("ASSOCVARIABLE.owned_params [H*] * %u num_owned_params", count);
  }
  {
    BITCODE_H owningnetwork;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "owningnetwork", &owningnetwork, NULL)
        && !memcmp (&owningnetwork, &assocvariable->owningnetwork, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCVARIABLE.owningnetwork [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "parent", &parent, NULL)
        && !memcmp (&parent, &assocvariable->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCVARIABLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T t58;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "t58", &t58, NULL)
        && t58
           ? strEQ ((char *)t58, (char *)assocvariable->t58)
           : !assocvariable->t58)
      pass ();
    else
      fail ("ASSOCVARIABLE.t58 [T] '%s' <> '%s'", t58, assocvariable->t58);
  }
  {
    BITCODE_T t78;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "t78", &t78, NULL)
        && t78
           ? strEQ ((char *)t78, (char *)assocvariable->t78)
           : !assocvariable->t78)
      pass ();
    else
      fail ("ASSOCVARIABLE.t78 [T] '%s' <> '%s'", t78, assocvariable->t78);
  }
  {
    Dwg_EvalVariant value;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "value", &value, NULL)
        && !memcmp (&value, &assocvariable->value, sizeof (Dwg_EvalVariant)))
        pass ();
    else
        fail ("ASSOCVARIABLE.value [Dwg_EvalVariant]");
  }
  {
    struct _dwg_VALUEPARAM* values;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "num_values", &count, NULL)
        && dwg_dynapi_entity_value (assocvariable, "ASSOCVARIABLE", "values", &values, NULL)
        && values == assocvariable->values)
      pass ();
    else
      fail ("ASSOCVARIABLE.values [struct _dwg_VALUEPARAM*] * %u num_values", count);
  }
  if (failed && (is_class_unstable ("ASSOCVARIABLE") || is_class_debugging ("ASSOCVARIABLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCVARIABLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCVERTEXACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCVERTEXACTIONPARAM *restrict assocvertexactionparam = obj->tio.object->tio.ASSOCVERTEXACTIONPARAM;
  failed = 0;
  if (!obj_obj || !assocvertexactionparam)
    {
      fail ("NULL ASSOCVERTEXACTIONPARAM");
      return 1;
    }
  {
    BITCODE_BL aap_version;
    if (dwg_dynapi_entity_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "aap_version", &aap_version, NULL)
        && aap_version == assocvertexactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.aap_version [BL] %u != %u", assocvertexactionparam->aap_version, aap_version);
    aap_version++;
    if (dwg_dynapi_entity_set_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "aap_version", &aap_version, 0)
        && aap_version == assocvertexactionparam->aap_version)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.aap_version [BL] set+1 %u != %u", assocvertexactionparam->aap_version, aap_version);
    assocvertexactionparam->aap_version--;
  }
  {
    BITCODE_BL asdap_class_version;
    if (dwg_dynapi_entity_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "asdap_class_version", &asdap_class_version, NULL)
        && asdap_class_version == assocvertexactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.asdap_class_version [BL] %u != %u", assocvertexactionparam->asdap_class_version, asdap_class_version);
    asdap_class_version++;
    if (dwg_dynapi_entity_set_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "asdap_class_version", &asdap_class_version, 0)
        && asdap_class_version == assocvertexactionparam->asdap_class_version)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.asdap_class_version [BL] set+1 %u != %u", assocvertexactionparam->asdap_class_version, asdap_class_version);
    assocvertexactionparam->asdap_class_version--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "class_version", &class_version, NULL)
        && class_version == assocvertexactionparam->class_version)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.class_version [BL] %u != %u", assocvertexactionparam->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "class_version", &class_version, 0)
        && class_version == assocvertexactionparam->class_version)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.class_version [BL] set+1 %u != %u", assocvertexactionparam->class_version, class_version);
    assocvertexactionparam->class_version--;
  }
  {
    BITCODE_H dep;
    if (dwg_dynapi_entity_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "dep", &dep, NULL)
        && !memcmp (&dep, &assocvertexactionparam->dep, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ASSOCVERTEXACTIONPARAM.dep [H]");
  }
  {
    BITCODE_BS is_r2013;
    if (dwg_dynapi_entity_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "is_r2013", &is_r2013, NULL)
        && is_r2013 == assocvertexactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.is_r2013 [BS] %hu != %hu", assocvertexactionparam->is_r2013, is_r2013);
    is_r2013++;
    if (dwg_dynapi_entity_set_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "is_r2013", &is_r2013, 0)
        && is_r2013 == assocvertexactionparam->is_r2013)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocvertexactionparam->is_r2013, is_r2013);
    assocvertexactionparam->is_r2013--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)assocvertexactionparam->name)
           : !assocvertexactionparam->name)
      pass ();
    else
      fail ("ASSOCVERTEXACTIONPARAM.name [T] '%s' <> '%s'", name, assocvertexactionparam->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "parent", &parent, NULL)
        && !memcmp (&parent, &assocvertexactionparam->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ASSOCVERTEXACTIONPARAM.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3BD pt;
    if (dwg_dynapi_entity_value (assocvertexactionparam, "ASSOCVERTEXACTIONPARAM", "pt", &pt, NULL)
        && !memcmp (&pt, &assocvertexactionparam->pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ASSOCVERTEXACTIONPARAM.pt [3BD]");
  }
  if (failed && (is_class_unstable ("ASSOCVERTEXACTIONPARAM") || is_class_debugging ("ASSOCVERTEXACTIONPARAM")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCVERTEXACTIONPARAM", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLKREFOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLKREFOBJECTCONTEXTDATA *restrict blkrefobjectcontextdata = obj->tio.object->tio.BLKREFOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !blkrefobjectcontextdata)
    {
      fail ("NULL BLKREFOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == blkrefobjectcontextdata->class_version)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", blkrefobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == blkrefobjectcontextdata->class_version)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", blkrefobjectcontextdata->class_version, class_version);
    blkrefobjectcontextdata->class_version--;
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &blkrefobjectcontextdata->ins_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLKREFOBJECTCONTEXTDATA.ins_pt [3BD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == blkrefobjectcontextdata->is_default)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", blkrefobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == blkrefobjectcontextdata->is_default)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", blkrefobjectcontextdata->is_default, is_default);
    blkrefobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &blkrefobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLKREFOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "rotation", &rotation, NULL)
        && rotation == blkrefobjectcontextdata->rotation)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.rotation [BD] %g != %g", blkrefobjectcontextdata->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "rotation", &rotation, 0)
        && rotation == blkrefobjectcontextdata->rotation)
      pass ();
    else
      fail ("BLKREFOBJECTCONTEXTDATA.rotation [BD] set+1 %g != %g", blkrefobjectcontextdata->rotation, rotation);
    blkrefobjectcontextdata->rotation--;
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &blkrefobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLKREFOBJECTCONTEXTDATA.scale [H]");
  }
  {
    BITCODE_3BD scale_factor;
    if (dwg_dynapi_entity_value (blkrefobjectcontextdata, "BLKREFOBJECTCONTEXTDATA", "scale_factor", &scale_factor, NULL)
        && !memcmp (&scale_factor, &blkrefobjectcontextdata->scale_factor, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLKREFOBJECTCONTEXTDATA.scale_factor [3BD_1]");
  }
  if (failed && (is_class_unstable ("BLKREFOBJECTCONTEXTDATA") || is_class_debugging ("BLKREFOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLKREFOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKALIGNEDCONSTRAINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKALIGNEDCONSTRAINTPARAMETER *restrict blockalignedconstraintparameter = obj->tio.object->tio.BLOCKALIGNEDCONSTRAINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockalignedconstraintparameter)
    {
      fail ("NULL BLOCKALIGNEDCONSTRAINTPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockalignedconstraintparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockalignedconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.be_major [BL] %u != %u", blockalignedconstraintparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockalignedconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blockalignedconstraintparameter->be_major, be_major);
    blockalignedconstraintparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockalignedconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blockalignedconstraintparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockalignedconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blockalignedconstraintparameter->be_minor, be_minor);
    blockalignedconstraintparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockalignedconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockalignedconstraintparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockalignedconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockalignedconstraintparameter->chain_actions, chain_actions);
    blockalignedconstraintparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockalignedconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockalignedconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_H dependency;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
        && !memcmp (&dependency, &blockalignedconstraintparameter->dependency, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.dependency [H]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockalignedconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blockalignedconstraintparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockalignedconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockalignedconstraintparameter->eed1071, eed1071);
    blockalignedconstraintparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockalignedconstraintparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockalignedconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T expr_description;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
        && expr_description
           ? strEQ ((char *)expr_description, (char *)blockalignedconstraintparameter->expr_description)
           : !blockalignedconstraintparameter->expr_description)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blockalignedconstraintparameter->expr_description);
  }
  {
    BITCODE_T expr_name;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
        && expr_name
           ? strEQ ((char *)expr_name, (char *)blockalignedconstraintparameter->expr_name)
           : !blockalignedconstraintparameter->expr_name)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blockalignedconstraintparameter->expr_name);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockalignedconstraintparameter->name)
           : !blockalignedconstraintparameter->name)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blockalignedconstraintparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockalignedconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blockalignedconstraintparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockalignedconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockalignedconstraintparameter->parameter_base_location, parameter_base_location);
    blockalignedconstraintparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockalignedconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockalignedconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockalignedconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockalignedconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockalignedconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockalignedconstraintparameter->prop_states)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockalignedconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockalignedconstraintparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockalignedconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockalignedconstraintparameter->show_properties, show_properties);
    blockalignedconstraintparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockalignedconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockalignedconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.upd_endpt [3BD]");
  }
  {
    BITCODE_BD value;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "value", &value, NULL)
        && value == blockalignedconstraintparameter->value)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.value [BD] %g != %g", blockalignedconstraintparameter->value, value);
    value++;
    if (dwg_dynapi_entity_set_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "value", &value, 0)
        && value == blockalignedconstraintparameter->value)
      pass ();
    else
      fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.value [BD] set+1 %g != %g", blockalignedconstraintparameter->value, value);
    blockalignedconstraintparameter->value--;
  }
  {
    Dwg_BLOCKPARAMVALUESET value_set;
    if (dwg_dynapi_entity_value (blockalignedconstraintparameter, "BLOCKALIGNEDCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
        && !memcmp (&value_set, &blockalignedconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKALIGNEDCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKALIGNEDCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKALIGNEDCONSTRAINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKALIGNEDCONSTRAINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKALIGNMENTGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKALIGNMENTGRIP *restrict blockalignmentgrip = obj->tio.object->tio.BLOCKALIGNMENTGRIP;
  failed = 0;
  if (!obj_obj || !blockalignmentgrip)
    {
      fail ("NULL BLOCKALIGNMENTGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "be_major", &be_major, NULL)
        && be_major == blockalignmentgrip->be_major)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.be_major [BL] %u != %u", blockalignmentgrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "be_major", &be_major, 0)
        && be_major == blockalignmentgrip->be_major)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.be_major [BL] set+1 %u != %u", blockalignmentgrip->be_major, be_major);
    blockalignmentgrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blockalignmentgrip->be_minor)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.be_minor [BL] %u != %u", blockalignmentgrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "be_minor", &be_minor, 0)
        && be_minor == blockalignmentgrip->be_minor)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.be_minor [BL] set+1 %u != %u", blockalignmentgrip->be_minor, be_minor);
    blockalignmentgrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blockalignmentgrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.bg_bl91 [BL] %u != %u", blockalignmentgrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blockalignmentgrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.bg_bl91 [BL] set+1 %u != %u", blockalignmentgrip->bg_bl91, bg_bl91);
    blockalignmentgrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blockalignmentgrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.bg_bl92 [BL] %u != %u", blockalignmentgrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blockalignmentgrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.bg_bl92 [BL] set+1 %u != %u", blockalignmentgrip->bg_bl92, bg_bl92);
    blockalignmentgrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blockalignmentgrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blockalignmentgrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blockalignmentgrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blockalignmentgrip->bg_insert_cycling, bg_insert_cycling);
    blockalignmentgrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blockalignmentgrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blockalignmentgrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blockalignmentgrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blockalignmentgrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blockalignmentgrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blockalignmentgrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNMENTGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blockalignmentgrip->eed1071)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.eed1071 [BL] %u != %u", blockalignmentgrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blockalignmentgrip->eed1071)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.eed1071 [BL] set+1 %u != %u", blockalignmentgrip->eed1071, eed1071);
    blockalignmentgrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockalignmentgrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKALIGNMENTGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockalignmentgrip->name)
           : !blockalignmentgrip->name)
      pass ();
    else
      fail ("BLOCKALIGNMENTGRIP.name [T] '%s' <> '%s'", name, blockalignmentgrip->name);
  }
  {
    BITCODE_3BD orientation;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "orientation", &orientation, NULL)
        && !memcmp (&orientation, &blockalignmentgrip->orientation, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNMENTGRIP.orientation [3BD_1]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockalignmentgrip, "BLOCKALIGNMENTGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blockalignmentgrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKALIGNMENTGRIP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKALIGNMENTGRIP") || is_class_debugging ("BLOCKALIGNMENTGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKALIGNMENTGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKALIGNMENTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKALIGNMENTPARAMETER *restrict blockalignmentparameter = obj->tio.object->tio.BLOCKALIGNMENTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockalignmentparameter)
    {
      fail ("NULL BLOCKALIGNMENTPARAMETER");
      return 1;
    }
  {
    BITCODE_B align_perpendicular;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "align_perpendicular", &align_perpendicular, NULL)
        && align_perpendicular == blockalignmentparameter->align_perpendicular)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.align_perpendicular [B] " FORMAT_B " != " FORMAT_B "", blockalignmentparameter->align_perpendicular, align_perpendicular);
    align_perpendicular++;
    if (dwg_dynapi_entity_set_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "align_perpendicular", &align_perpendicular, 0)
        && align_perpendicular == blockalignmentparameter->align_perpendicular)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.align_perpendicular [B] set+1 " FORMAT_B " != " FORMAT_B "", blockalignmentparameter->align_perpendicular, align_perpendicular);
    blockalignmentparameter->align_perpendicular--;
  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockalignmentparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockalignmentparameter->be_major)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.be_major [BL] %u != %u", blockalignmentparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockalignmentparameter->be_major)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.be_major [BL] set+1 %u != %u", blockalignmentparameter->be_major, be_major);
    blockalignmentparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockalignmentparameter->be_minor)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.be_minor [BL] %u != %u", blockalignmentparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockalignmentparameter->be_minor)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.be_minor [BL] set+1 %u != %u", blockalignmentparameter->be_minor, be_minor);
    blockalignmentparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockalignmentparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockalignmentparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockalignmentparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockalignmentparameter->chain_actions, chain_actions);
    blockalignmentparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockalignmentparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockalignmentparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockalignmentparameter->eed1071)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.eed1071 [BL] %u != %u", blockalignmentparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockalignmentparameter->eed1071)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.eed1071 [BL] set+1 %u != %u", blockalignmentparameter->eed1071, eed1071);
    blockalignmentparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockalignmentparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockalignmentparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockalignmentparameter->name)
           : !blockalignmentparameter->name)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.name [T] '%s' <> '%s'", name, blockalignmentparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockalignmentparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.parameter_base_location [BS] %hu != %hu", blockalignmentparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockalignmentparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockalignmentparameter->parameter_base_location, parameter_base_location);
    blockalignmentparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockalignmentparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockalignmentparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockalignmentparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockalignmentparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockalignmentparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockalignmentparameter->prop_states)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockalignmentparameter->show_properties)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockalignmentparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockalignmentparameter->show_properties)
      pass ();
    else
      fail ("BLOCKALIGNMENTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockalignmentparameter->show_properties, show_properties);
    blockalignmentparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockalignmentparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockalignmentparameter, "BLOCKALIGNMENTPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockalignmentparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKALIGNMENTPARAMETER.upd_endpt [3BD]");
  }
  if (failed && (is_class_unstable ("BLOCKALIGNMENTPARAMETER") || is_class_debugging ("BLOCKALIGNMENTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKALIGNMENTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKANGULARCONSTRAINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKANGULARCONSTRAINTPARAMETER *restrict blockangularconstraintparameter = obj->tio.object->tio.BLOCKANGULARCONSTRAINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockangularconstraintparameter)
    {
      fail ("NULL BLOCKANGULARCONSTRAINTPARAMETER");
      return 1;
    }
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "angle", &angle, NULL)
        && angle == blockangularconstraintparameter->angle)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.angle [BD] %g != %g", blockangularconstraintparameter->angle, angle);
    angle++;
    if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "angle", &angle, 0)
        && angle == blockangularconstraintparameter->angle)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.angle [BD] set+1 %g != %g", blockangularconstraintparameter->angle, angle);
    blockangularconstraintparameter->angle--;
  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockangularconstraintparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockangularconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.be_major [BL] %u != %u", blockangularconstraintparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockangularconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blockangularconstraintparameter->be_major, be_major);
    blockangularconstraintparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockangularconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blockangularconstraintparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockangularconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blockangularconstraintparameter->be_minor, be_minor);
    blockangularconstraintparameter->be_minor--;
  }
  {
    BITCODE_3BD center_pt;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "center_pt", &center_pt, NULL)
        && !memcmp (&center_pt, &blockangularconstraintparameter->center_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.center_pt [3BD]");
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockangularconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockangularconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->chain_actions, chain_actions);
    blockangularconstraintparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockangularconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockangularconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_H dependency;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
        && !memcmp (&dependency, &blockangularconstraintparameter->dependency, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.dependency [H]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockangularconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blockangularconstraintparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockangularconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockangularconstraintparameter->eed1071, eed1071);
    blockangularconstraintparameter->eed1071--;
  }
  {
    BITCODE_3BD end_pt;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "end_pt", &end_pt, NULL)
        && !memcmp (&end_pt, &blockangularconstraintparameter->end_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.end_pt [3BD]");
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockangularconstraintparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockangularconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T expr_description;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
        && expr_description
           ? strEQ ((char *)expr_description, (char *)blockangularconstraintparameter->expr_description)
           : !blockangularconstraintparameter->expr_description)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blockangularconstraintparameter->expr_description);
  }
  {
    BITCODE_T expr_name;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
        && expr_name
           ? strEQ ((char *)expr_name, (char *)blockangularconstraintparameter->expr_name)
           : !blockangularconstraintparameter->expr_name)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blockangularconstraintparameter->expr_name);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockangularconstraintparameter->name)
           : !blockangularconstraintparameter->name)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blockangularconstraintparameter->name);
  }
  {
    BITCODE_B orientation_on_both_grips;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "orientation_on_both_grips", &orientation_on_both_grips, NULL)
        && orientation_on_both_grips == blockangularconstraintparameter->orientation_on_both_grips)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.orientation_on_both_grips [B] " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->orientation_on_both_grips, orientation_on_both_grips);
    orientation_on_both_grips++;
    if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "orientation_on_both_grips", &orientation_on_both_grips, 0)
        && orientation_on_both_grips == blockangularconstraintparameter->orientation_on_both_grips)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.orientation_on_both_grips [B] set+1 " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->orientation_on_both_grips, orientation_on_both_grips);
    blockangularconstraintparameter->orientation_on_both_grips--;
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockangularconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blockangularconstraintparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockangularconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockangularconstraintparameter->parameter_base_location, parameter_base_location);
    blockangularconstraintparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockangularconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockangularconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockangularconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockangularconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockangularconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockangularconstraintparameter->prop_states)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockangularconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockangularconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKANGULARCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->show_properties, show_properties);
    blockangularconstraintparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockangularconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockangularconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.upd_endpt [3BD]");
  }
  {
    Dwg_BLOCKPARAMVALUESET value_set;
    if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
        && !memcmp (&value_set, &blockangularconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKANGULARCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKANGULARCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKANGULARCONSTRAINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKANGULARCONSTRAINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKARRAYACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKARRAYACTION *restrict blockarrayaction = obj->tio.object->tio.BLOCKARRAYACTION;
  failed = 0;
  if (!obj_obj || !blockarrayaction)
    {
      fail ("NULL BLOCKARRAYACTION");
      return 1;
    }
  {
    BITCODE_BL* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "actions", &actions, NULL)
        && actions == blockarrayaction->actions)
      pass ();
    else
      fail ("BLOCKARRAYACTION.actions [BL*] * %u num_actions", count);
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "be_major", &be_major, NULL)
        && be_major == blockarrayaction->be_major)
      pass ();
    else
      fail ("BLOCKARRAYACTION.be_major [BL] %u != %u", blockarrayaction->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "be_major", &be_major, 0)
        && be_major == blockarrayaction->be_major)
      pass ();
    else
      fail ("BLOCKARRAYACTION.be_major [BL] set+1 %u != %u", blockarrayaction->be_major, be_major);
    blockarrayaction->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "be_minor", &be_minor, NULL)
        && be_minor == blockarrayaction->be_minor)
      pass ();
    else
      fail ("BLOCKARRAYACTION.be_minor [BL] %u != %u", blockarrayaction->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "be_minor", &be_minor, 0)
        && be_minor == blockarrayaction->be_minor)
      pass ();
    else
      fail ("BLOCKARRAYACTION.be_minor [BL] set+1 %u != %u", blockarrayaction->be_minor, be_minor);
    blockarrayaction->be_minor--;
  }
  {
    BITCODE_BD column_offset;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "column_offset", &column_offset, NULL)
        && column_offset == blockarrayaction->column_offset)
      pass ();
    else
      fail ("BLOCKARRAYACTION.column_offset [BD] %g != %g", blockarrayaction->column_offset, column_offset);
    column_offset++;
    if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "column_offset", &column_offset, 0)
        && column_offset == blockarrayaction->column_offset)
      pass ();
    else
      fail ("BLOCKARRAYACTION.column_offset [BD] set+1 %g != %g", blockarrayaction->column_offset, column_offset);
    blockarrayaction->column_offset--;
  }
  {
    Dwg_BLOCKACTION_connectionpts conn_pts;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "conn_pts[4]", &conn_pts, NULL)
        && !memcmp (&conn_pts, &blockarrayaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
        pass ();
    else
        fail ("BLOCKARRAYACTION.conn_pts[4] [Dwg_BLOCKACTION_connectionpts]");
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "deps", &deps, NULL)
        && deps == blockarrayaction->deps)
      pass ();
    else
      fail ("BLOCKARRAYACTION.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_3BD display_location;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "display_location", &display_location, NULL)
        && !memcmp (&display_location, &blockarrayaction->display_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKARRAYACTION.display_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "eed1071", &eed1071, NULL)
        && eed1071 == blockarrayaction->eed1071)
      pass ();
    else
      fail ("BLOCKARRAYACTION.eed1071 [BL] %u != %u", blockarrayaction->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "eed1071", &eed1071, 0)
        && eed1071 == blockarrayaction->eed1071)
      pass ();
    else
      fail ("BLOCKARRAYACTION.eed1071 [BL] set+1 %u != %u", blockarrayaction->eed1071, eed1071);
    blockarrayaction->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockarrayaction->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKARRAYACTION.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockarrayaction->name)
           : !blockarrayaction->name)
      pass ();
    else
      fail ("BLOCKARRAYACTION.name [T] '%s' <> '%s'", name, blockarrayaction->name);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "num_actions", &num_actions, NULL)
        && num_actions == blockarrayaction->num_actions)
      pass ();
    else
      fail ("BLOCKARRAYACTION.num_actions [BL] %u != %u", blockarrayaction->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "num_actions", &num_actions, 0)
        && num_actions == blockarrayaction->num_actions)
      pass ();
    else
      fail ("BLOCKARRAYACTION.num_actions [BL] set+1 %u != %u", blockarrayaction->num_actions, num_actions);
    blockarrayaction->num_actions--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "num_deps", &num_deps, NULL)
        && num_deps == blockarrayaction->num_deps)
      pass ();
    else
      fail ("BLOCKARRAYACTION.num_deps [BL] %u != %u", blockarrayaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "num_deps", &num_deps, 0)
        && num_deps == blockarrayaction->num_deps)
      pass ();
    else
      fail ("BLOCKARRAYACTION.num_deps [BL] set+1 %u != %u", blockarrayaction->num_deps, num_deps);
    blockarrayaction->num_deps--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &blockarrayaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKARRAYACTION.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD row_offset;
    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "row_offset", &row_offset, NULL)
        && row_offset == blockarrayaction->row_offset)
      pass ();
    else
      fail ("BLOCKARRAYACTION.row_offset [BD] %g != %g", blockarrayaction->row_offset, row_offset);
    row_offset++;
    if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "row_offset", &row_offset, 0)
        && row_offset == blockarrayaction->row_offset)
      pass ();
    else
      fail ("BLOCKARRAYACTION.row_offset [BD] set+1 %g != %g", blockarrayaction->row_offset, row_offset);
    blockarrayaction->row_offset--;
  }
  if (failed && (is_class_unstable ("BLOCKARRAYACTION") || is_class_debugging ("BLOCKARRAYACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKARRAYACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKBASEPOINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKBASEPOINTPARAMETER *restrict blockbasepointparameter = obj->tio.object->tio.BLOCKBASEPOINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockbasepointparameter)
    {
      fail ("NULL BLOCKBASEPOINTPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD base_pt;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "base_pt", &base_pt, NULL)
        && !memcmp (&base_pt, &blockbasepointparameter->base_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKBASEPOINTPARAMETER.base_pt [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockbasepointparameter->be_major)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.be_major [BL] %u != %u", blockbasepointparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockbasepointparameter->be_major)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.be_major [BL] set+1 %u != %u", blockbasepointparameter->be_major, be_major);
    blockbasepointparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockbasepointparameter->be_minor)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.be_minor [BL] %u != %u", blockbasepointparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockbasepointparameter->be_minor)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.be_minor [BL] set+1 %u != %u", blockbasepointparameter->be_minor, be_minor);
    blockbasepointparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockbasepointparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockbasepointparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockbasepointparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockbasepointparameter->chain_actions, chain_actions);
    blockbasepointparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &blockbasepointparameter->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKBASEPOINTPARAMETER.def_pt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockbasepointparameter->eed1071)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.eed1071 [BL] %u != %u", blockbasepointparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockbasepointparameter->eed1071)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockbasepointparameter->eed1071, eed1071);
    blockbasepointparameter->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockbasepointparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKBASEPOINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockbasepointparameter->name)
           : !blockbasepointparameter->name)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.name [T] '%s' <> '%s'", name, blockbasepointparameter->name);
  }
  {
    BITCODE_BL num_propinfos;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "num_propinfos", &num_propinfos, NULL)
        && num_propinfos == blockbasepointparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.num_propinfos [BL] %u != %u", blockbasepointparameter->num_propinfos, num_propinfos);
    num_propinfos++;
    if (dwg_dynapi_entity_set_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "num_propinfos", &num_propinfos, 0)
        && num_propinfos == blockbasepointparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.num_propinfos [BL] set+1 %u != %u", blockbasepointparameter->num_propinfos, num_propinfos);
    blockbasepointparameter->num_propinfos--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockbasepointparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKBASEPOINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockbasepointparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKBASEPOINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockbasepointparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKBASEPOINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_3BD pt;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "pt", &pt, NULL)
        && !memcmp (&pt, &blockbasepointparameter->pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKBASEPOINTPARAMETER.pt [3BD]");
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockbasepointparameter->show_properties)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockbasepointparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockbasepointparameter, "BLOCKBASEPOINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockbasepointparameter->show_properties)
      pass ();
    else
      fail ("BLOCKBASEPOINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockbasepointparameter->show_properties, show_properties);
    blockbasepointparameter->show_properties--;
  }
  if (failed && (is_class_unstable ("BLOCKBASEPOINTPARAMETER") || is_class_debugging ("BLOCKBASEPOINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKBASEPOINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKDIAMETRICCONSTRAINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKDIAMETRICCONSTRAINTPARAMETER *restrict blockdiametricconstraintparameter = obj->tio.object->tio.BLOCKDIAMETRICCONSTRAINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockdiametricconstraintparameter)
    {
      fail ("NULL BLOCKDIAMETRICCONSTRAINTPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockdiametricconstraintparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockdiametricconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.be_major [BL] %u != %u", blockdiametricconstraintparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockdiametricconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blockdiametricconstraintparameter->be_major, be_major);
    blockdiametricconstraintparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockdiametricconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blockdiametricconstraintparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockdiametricconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blockdiametricconstraintparameter->be_minor, be_minor);
    blockdiametricconstraintparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockdiametricconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockdiametricconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->chain_actions, chain_actions);
    blockdiametricconstraintparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockdiametricconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockdiametricconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_H dependency;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
        && !memcmp (&dependency, &blockdiametricconstraintparameter->dependency, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.dependency [H]");
  }
  {
    BITCODE_BD distance;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "distance", &distance, NULL)
        && distance == blockdiametricconstraintparameter->distance)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.distance [BD] %g != %g", blockdiametricconstraintparameter->distance, distance);
    distance++;
    if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "distance", &distance, 0)
        && distance == blockdiametricconstraintparameter->distance)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.distance [BD] set+1 %g != %g", blockdiametricconstraintparameter->distance, distance);
    blockdiametricconstraintparameter->distance--;
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockdiametricconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blockdiametricconstraintparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockdiametricconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockdiametricconstraintparameter->eed1071, eed1071);
    blockdiametricconstraintparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockdiametricconstraintparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockdiametricconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T expr_description;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
        && expr_description
           ? strEQ ((char *)expr_description, (char *)blockdiametricconstraintparameter->expr_description)
           : !blockdiametricconstraintparameter->expr_description)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blockdiametricconstraintparameter->expr_description);
  }
  {
    BITCODE_T expr_name;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
        && expr_name
           ? strEQ ((char *)expr_name, (char *)blockdiametricconstraintparameter->expr_name)
           : !blockdiametricconstraintparameter->expr_name)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blockdiametricconstraintparameter->expr_name);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockdiametricconstraintparameter->name)
           : !blockdiametricconstraintparameter->name)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blockdiametricconstraintparameter->name);
  }
  {
    BITCODE_B orientation_on_both_grips;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "orientation_on_both_grips", &orientation_on_both_grips, NULL)
        && orientation_on_both_grips == blockdiametricconstraintparameter->orientation_on_both_grips)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.orientation_on_both_grips [B] " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->orientation_on_both_grips, orientation_on_both_grips);
    orientation_on_both_grips++;
    if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "orientation_on_both_grips", &orientation_on_both_grips, 0)
        && orientation_on_both_grips == blockdiametricconstraintparameter->orientation_on_both_grips)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.orientation_on_both_grips [B] set+1 " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->orientation_on_both_grips, orientation_on_both_grips);
    blockdiametricconstraintparameter->orientation_on_both_grips--;
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockdiametricconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blockdiametricconstraintparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockdiametricconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockdiametricconstraintparameter->parameter_base_location, parameter_base_location);
    blockdiametricconstraintparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockdiametricconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockdiametricconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockdiametricconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockdiametricconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockdiametricconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockdiametricconstraintparameter->prop_states)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockdiametricconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockdiametricconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->show_properties, show_properties);
    blockdiametricconstraintparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockdiametricconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockdiametricconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.upd_endpt [3BD]");
  }
  {
    Dwg_BLOCKPARAMVALUESET value_set;
    if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
        && !memcmp (&value_set, &blockdiametricconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKDIAMETRICCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKDIAMETRICCONSTRAINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKDIAMETRICCONSTRAINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKFLIPACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKFLIPACTION *restrict blockflipaction = obj->tio.object->tio.BLOCKFLIPACTION;
  failed = 0;
  if (!obj_obj || !blockflipaction)
    {
      fail ("NULL BLOCKFLIPACTION");
      return 1;
    }
  {
    BITCODE_BD action_offset_x;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "action_offset_x", &action_offset_x, NULL)
        && action_offset_x == blockflipaction->action_offset_x)
      pass ();
    else
      fail ("BLOCKFLIPACTION.action_offset_x [BD] %g != %g", blockflipaction->action_offset_x, action_offset_x);
    action_offset_x++;
    if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "action_offset_x", &action_offset_x, 0)
        && action_offset_x == blockflipaction->action_offset_x)
      pass ();
    else
      fail ("BLOCKFLIPACTION.action_offset_x [BD] set+1 %g != %g", blockflipaction->action_offset_x, action_offset_x);
    blockflipaction->action_offset_x--;
  }
  {
    BITCODE_BD action_offset_y;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "action_offset_y", &action_offset_y, NULL)
        && action_offset_y == blockflipaction->action_offset_y)
      pass ();
    else
      fail ("BLOCKFLIPACTION.action_offset_y [BD] %g != %g", blockflipaction->action_offset_y, action_offset_y);
    action_offset_y++;
    if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "action_offset_y", &action_offset_y, 0)
        && action_offset_y == blockflipaction->action_offset_y)
      pass ();
    else
      fail ("BLOCKFLIPACTION.action_offset_y [BD] set+1 %g != %g", blockflipaction->action_offset_y, action_offset_y);
    blockflipaction->action_offset_y--;
  }
  {
    BITCODE_BL* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "actions", &actions, NULL)
        && actions == blockflipaction->actions)
      pass ();
    else
      fail ("BLOCKFLIPACTION.actions [BL*] * %u num_actions", count);
  }
  {
    BITCODE_BD angle_offset;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "angle_offset", &angle_offset, NULL)
        && angle_offset == blockflipaction->angle_offset)
      pass ();
    else
      fail ("BLOCKFLIPACTION.angle_offset [BD] %g != %g", blockflipaction->angle_offset, angle_offset);
    angle_offset++;
    if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "angle_offset", &angle_offset, 0)
        && angle_offset == blockflipaction->angle_offset)
      pass ();
    else
      fail ("BLOCKFLIPACTION.angle_offset [BD] set+1 %g != %g", blockflipaction->angle_offset, angle_offset);
    blockflipaction->angle_offset--;
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "be_major", &be_major, NULL)
        && be_major == blockflipaction->be_major)
      pass ();
    else
      fail ("BLOCKFLIPACTION.be_major [BL] %u != %u", blockflipaction->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "be_major", &be_major, 0)
        && be_major == blockflipaction->be_major)
      pass ();
    else
      fail ("BLOCKFLIPACTION.be_major [BL] set+1 %u != %u", blockflipaction->be_major, be_major);
    blockflipaction->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "be_minor", &be_minor, NULL)
        && be_minor == blockflipaction->be_minor)
      pass ();
    else
      fail ("BLOCKFLIPACTION.be_minor [BL] %u != %u", blockflipaction->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "be_minor", &be_minor, 0)
        && be_minor == blockflipaction->be_minor)
      pass ();
    else
      fail ("BLOCKFLIPACTION.be_minor [BL] set+1 %u != %u", blockflipaction->be_minor, be_minor);
    blockflipaction->be_minor--;
  }
  {
    Dwg_BLOCKACTION_connectionpts conn_pts;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "conn_pts[4]", &conn_pts, NULL)
        && !memcmp (&conn_pts, &blockflipaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
        pass ();
    else
        fail ("BLOCKFLIPACTION.conn_pts[4] [Dwg_BLOCKACTION_connectionpts]");
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "deps", &deps, NULL)
        && deps == blockflipaction->deps)
      pass ();
    else
      fail ("BLOCKFLIPACTION.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_3BD display_location;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "display_location", &display_location, NULL)
        && !memcmp (&display_location, &blockflipaction->display_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPACTION.display_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "eed1071", &eed1071, NULL)
        && eed1071 == blockflipaction->eed1071)
      pass ();
    else
      fail ("BLOCKFLIPACTION.eed1071 [BL] %u != %u", blockflipaction->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "eed1071", &eed1071, 0)
        && eed1071 == blockflipaction->eed1071)
      pass ();
    else
      fail ("BLOCKFLIPACTION.eed1071 [BL] set+1 %u != %u", blockflipaction->eed1071, eed1071);
    blockflipaction->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockflipaction->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKFLIPACTION.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockflipaction->name)
           : !blockflipaction->name)
      pass ();
    else
      fail ("BLOCKFLIPACTION.name [T] '%s' <> '%s'", name, blockflipaction->name);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "num_actions", &num_actions, NULL)
        && num_actions == blockflipaction->num_actions)
      pass ();
    else
      fail ("BLOCKFLIPACTION.num_actions [BL] %u != %u", blockflipaction->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "num_actions", &num_actions, 0)
        && num_actions == blockflipaction->num_actions)
      pass ();
    else
      fail ("BLOCKFLIPACTION.num_actions [BL] set+1 %u != %u", blockflipaction->num_actions, num_actions);
    blockflipaction->num_actions--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "num_deps", &num_deps, NULL)
        && num_deps == blockflipaction->num_deps)
      pass ();
    else
      fail ("BLOCKFLIPACTION.num_deps [BL] %u != %u", blockflipaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "num_deps", &num_deps, 0)
        && num_deps == blockflipaction->num_deps)
      pass ();
    else
      fail ("BLOCKFLIPACTION.num_deps [BL] set+1 %u != %u", blockflipaction->num_deps, num_deps);
    blockflipaction->num_deps--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &blockflipaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKFLIPACTION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKFLIPACTION") || is_class_debugging ("BLOCKFLIPACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKFLIPACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKFLIPGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKFLIPGRIP *restrict blockflipgrip = obj->tio.object->tio.BLOCKFLIPGRIP;
  failed = 0;
  if (!obj_obj || !blockflipgrip)
    {
      fail ("NULL BLOCKFLIPGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "be_major", &be_major, NULL)
        && be_major == blockflipgrip->be_major)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.be_major [BL] %u != %u", blockflipgrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "be_major", &be_major, 0)
        && be_major == blockflipgrip->be_major)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.be_major [BL] set+1 %u != %u", blockflipgrip->be_major, be_major);
    blockflipgrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blockflipgrip->be_minor)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.be_minor [BL] %u != %u", blockflipgrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "be_minor", &be_minor, 0)
        && be_minor == blockflipgrip->be_minor)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.be_minor [BL] set+1 %u != %u", blockflipgrip->be_minor, be_minor);
    blockflipgrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blockflipgrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.bg_bl91 [BL] %u != %u", blockflipgrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blockflipgrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.bg_bl91 [BL] set+1 %u != %u", blockflipgrip->bg_bl91, bg_bl91);
    blockflipgrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blockflipgrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.bg_bl92 [BL] %u != %u", blockflipgrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blockflipgrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.bg_bl92 [BL] set+1 %u != %u", blockflipgrip->bg_bl92, bg_bl92);
    blockflipgrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blockflipgrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blockflipgrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blockflipgrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blockflipgrip->bg_insert_cycling, bg_insert_cycling);
    blockflipgrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blockflipgrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blockflipgrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blockflipgrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blockflipgrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blockflipgrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blockflipgrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL combined_state;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "combined_state", &combined_state, NULL)
        && combined_state == blockflipgrip->combined_state)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.combined_state [BL] %u != %u", blockflipgrip->combined_state, combined_state);
    combined_state++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "combined_state", &combined_state, 0)
        && combined_state == blockflipgrip->combined_state)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.combined_state [BL] set+1 %u != %u", blockflipgrip->combined_state, combined_state);
    blockflipgrip->combined_state--;
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blockflipgrip->eed1071)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.eed1071 [BL] %u != %u", blockflipgrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blockflipgrip->eed1071)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.eed1071 [BL] set+1 %u != %u", blockflipgrip->eed1071, eed1071);
    blockflipgrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockflipgrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKFLIPGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockflipgrip->name)
           : !blockflipgrip->name)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.name [T] '%s' <> '%s'", name, blockflipgrip->name);
  }
  {
    BITCODE_3BD orientation;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "orientation", &orientation, NULL)
        && !memcmp (&orientation, &blockflipgrip->orientation, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPGRIP.orientation [3BD_1]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blockflipgrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKFLIPGRIP.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS state;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "state", &state, NULL)
        && state == blockflipgrip->state)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.state [BS] %hu != %hu", blockflipgrip->state, state);
    state++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "state", &state, 0)
        && state == blockflipgrip->state)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.state [BS] set+1 %hu != %hu", blockflipgrip->state, state);
    blockflipgrip->state--;
  }
  {
    BITCODE_BS upd_state;
    if (dwg_dynapi_entity_value (blockflipgrip, "BLOCKFLIPGRIP", "upd_state", &upd_state, NULL)
        && upd_state == blockflipgrip->upd_state)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.upd_state [BS] %hu != %hu", blockflipgrip->upd_state, upd_state);
    upd_state++;
    if (dwg_dynapi_entity_set_value (blockflipgrip, "BLOCKFLIPGRIP", "upd_state", &upd_state, 0)
        && upd_state == blockflipgrip->upd_state)
      pass ();
    else
      fail ("BLOCKFLIPGRIP.upd_state [BS] set+1 %hu != %hu", blockflipgrip->upd_state, upd_state);
    blockflipgrip->upd_state--;
  }
  if (failed && (is_class_unstable ("BLOCKFLIPGRIP") || is_class_debugging ("BLOCKFLIPGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKFLIPGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKFLIPPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKFLIPPARAMETER *restrict blockflipparameter = obj->tio.object->tio.BLOCKFLIPPARAMETER;
  failed = 0;
  if (!obj_obj || !blockflipparameter)
    {
      fail ("NULL BLOCKFLIPPARAMETER");
      return 1;
    }
  {
    BITCODE_T base_state_label;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "base_state_label", &base_state_label, NULL)
        && base_state_label
           ? strEQ ((char *)base_state_label, (char *)blockflipparameter->base_state_label)
           : !blockflipparameter->base_state_label)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.base_state_label [T] '%s' <> '%s'", base_state_label, blockflipparameter->base_state_label);
  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockflipparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockflipparameter->be_major)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.be_major [BL] %u != %u", blockflipparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockflipparameter, "BLOCKFLIPPARAMETER", "be_major", &be_major, 0)
        && be_major == blockflipparameter->be_major)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.be_major [BL] set+1 %u != %u", blockflipparameter->be_major, be_major);
    blockflipparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockflipparameter->be_minor)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.be_minor [BL] %u != %u", blockflipparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockflipparameter, "BLOCKFLIPPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockflipparameter->be_minor)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.be_minor [BL] set+1 %u != %u", blockflipparameter->be_minor, be_minor);
    blockflipparameter->be_minor--;
  }
  {
    BITCODE_BL bl96;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "bl96", &bl96, NULL)
        && bl96 == blockflipparameter->bl96)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.bl96 [BL] %u != %u", blockflipparameter->bl96, bl96);
    bl96++;
    if (dwg_dynapi_entity_set_value (blockflipparameter, "BLOCKFLIPPARAMETER", "bl96", &bl96, 0)
        && bl96 == blockflipparameter->bl96)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.bl96 [BL] set+1 %u != %u", blockflipparameter->bl96, bl96);
    blockflipparameter->bl96--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockflipparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockflipparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockflipparameter, "BLOCKFLIPPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockflipparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockflipparameter->chain_actions, chain_actions);
    blockflipparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockflipparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockflipparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_3BD def_label_pt;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "def_label_pt", &def_label_pt, NULL)
        && !memcmp (&def_label_pt, &blockflipparameter->def_label_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.def_label_pt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockflipparameter->eed1071)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.eed1071 [BL] %u != %u", blockflipparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockflipparameter, "BLOCKFLIPPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockflipparameter->eed1071)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.eed1071 [BL] set+1 %u != %u", blockflipparameter->eed1071, eed1071);
    blockflipparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockflipparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockflipparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T flip_label;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "flip_label", &flip_label, NULL)
        && flip_label
           ? strEQ ((char *)flip_label, (char *)blockflipparameter->flip_label)
           : !blockflipparameter->flip_label)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.flip_label [T] '%s' <> '%s'", flip_label, blockflipparameter->flip_label);
  }
  {
    BITCODE_T flip_label_desc;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "flip_label_desc", &flip_label_desc, NULL)
        && flip_label_desc
           ? strEQ ((char *)flip_label_desc, (char *)blockflipparameter->flip_label_desc)
           : !blockflipparameter->flip_label_desc)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.flip_label_desc [T] '%s' <> '%s'", flip_label_desc, blockflipparameter->flip_label_desc);
  }
  {
    BITCODE_T flipped_state_label;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "flipped_state_label", &flipped_state_label, NULL)
        && flipped_state_label
           ? strEQ ((char *)flipped_state_label, (char *)blockflipparameter->flipped_state_label)
           : !blockflipparameter->flipped_state_label)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.flipped_state_label [T] '%s' <> '%s'", flipped_state_label, blockflipparameter->flipped_state_label);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockflipparameter->name)
           : !blockflipparameter->name)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.name [T] '%s' <> '%s'", name, blockflipparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockflipparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.parameter_base_location [BS] %hu != %hu", blockflipparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockflipparameter, "BLOCKFLIPPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockflipparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockflipparameter->parameter_base_location, parameter_base_location);
    blockflipparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockflipparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockflipparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockflipparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockflipparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockflipparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockflipparameter->prop_states)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockflipparameter->show_properties)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockflipparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockflipparameter, "BLOCKFLIPPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockflipparameter->show_properties)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockflipparameter->show_properties, show_properties);
    blockflipparameter->show_properties--;
  }
  {
    BITCODE_T tooltip;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "tooltip", &tooltip, NULL)
        && tooltip
           ? strEQ ((char *)tooltip, (char *)blockflipparameter->tooltip)
           : !blockflipparameter->tooltip)
      pass ();
    else
      fail ("BLOCKFLIPPARAMETER.tooltip [T] '%s' <> '%s'", tooltip, blockflipparameter->tooltip);
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockflipparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockflipparameter, "BLOCKFLIPPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockflipparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKFLIPPARAMETER.upd_endpt [3BD]");
  }
  if (failed && (is_class_unstable ("BLOCKFLIPPARAMETER") || is_class_debugging ("BLOCKFLIPPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKFLIPPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKGRIPLOCATIONCOMPONENT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKGRIPLOCATIONCOMPONENT *restrict blockgriplocationcomponent = obj->tio.object->tio.BLOCKGRIPLOCATIONCOMPONENT;
  failed = 0;
  if (!obj_obj || !blockgriplocationcomponent)
    {
      fail ("NULL BLOCKGRIPLOCATIONCOMPONENT");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockgriplocationcomponent, "BLOCKGRIPLOCATIONCOMPONENT", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockgriplocationcomponent->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKGRIPLOCATIONCOMPONENT.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T grip_expr;
    if (dwg_dynapi_entity_value (blockgriplocationcomponent, "BLOCKGRIPLOCATIONCOMPONENT", "grip_expr", &grip_expr, NULL)
        && grip_expr
           ? strEQ ((char *)grip_expr, (char *)blockgriplocationcomponent->grip_expr)
           : !blockgriplocationcomponent->grip_expr)
      pass ();
    else
      fail ("BLOCKGRIPLOCATIONCOMPONENT.grip_expr [T] '%s' <> '%s'", grip_expr, blockgriplocationcomponent->grip_expr);
  }
  {
    BITCODE_BL grip_type;
    if (dwg_dynapi_entity_value (blockgriplocationcomponent, "BLOCKGRIPLOCATIONCOMPONENT", "grip_type", &grip_type, NULL)
        && grip_type == blockgriplocationcomponent->grip_type)
      pass ();
    else
      fail ("BLOCKGRIPLOCATIONCOMPONENT.grip_type [BL] %u != %u", blockgriplocationcomponent->grip_type, grip_type);
    grip_type++;
    if (dwg_dynapi_entity_set_value (blockgriplocationcomponent, "BLOCKGRIPLOCATIONCOMPONENT", "grip_type", &grip_type, 0)
        && grip_type == blockgriplocationcomponent->grip_type)
      pass ();
    else
      fail ("BLOCKGRIPLOCATIONCOMPONENT.grip_type [BL] set+1 %u != %u", blockgriplocationcomponent->grip_type, grip_type);
    blockgriplocationcomponent->grip_type--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockgriplocationcomponent, "BLOCKGRIPLOCATIONCOMPONENT", "parent", &parent, NULL)
        && !memcmp (&parent, &blockgriplocationcomponent->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKGRIPLOCATIONCOMPONENT.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKGRIPLOCATIONCOMPONENT") || is_class_debugging ("BLOCKGRIPLOCATIONCOMPONENT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKGRIPLOCATIONCOMPONENT", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKHORIZONTALCONSTRAINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKHORIZONTALCONSTRAINTPARAMETER *restrict blockhorizontalconstraintparameter = obj->tio.object->tio.BLOCKHORIZONTALCONSTRAINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockhorizontalconstraintparameter)
    {
      fail ("NULL BLOCKHORIZONTALCONSTRAINTPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockhorizontalconstraintparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockhorizontalconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.be_major [BL] %u != %u", blockhorizontalconstraintparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockhorizontalconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blockhorizontalconstraintparameter->be_major, be_major);
    blockhorizontalconstraintparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockhorizontalconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blockhorizontalconstraintparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockhorizontalconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blockhorizontalconstraintparameter->be_minor, be_minor);
    blockhorizontalconstraintparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockhorizontalconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockhorizontalconstraintparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockhorizontalconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockhorizontalconstraintparameter->chain_actions, chain_actions);
    blockhorizontalconstraintparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockhorizontalconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockhorizontalconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_H dependency;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
        && !memcmp (&dependency, &blockhorizontalconstraintparameter->dependency, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.dependency [H]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockhorizontalconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blockhorizontalconstraintparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockhorizontalconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockhorizontalconstraintparameter->eed1071, eed1071);
    blockhorizontalconstraintparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockhorizontalconstraintparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockhorizontalconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T expr_description;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
        && expr_description
           ? strEQ ((char *)expr_description, (char *)blockhorizontalconstraintparameter->expr_description)
           : !blockhorizontalconstraintparameter->expr_description)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blockhorizontalconstraintparameter->expr_description);
  }
  {
    BITCODE_T expr_name;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
        && expr_name
           ? strEQ ((char *)expr_name, (char *)blockhorizontalconstraintparameter->expr_name)
           : !blockhorizontalconstraintparameter->expr_name)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blockhorizontalconstraintparameter->expr_name);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockhorizontalconstraintparameter->name)
           : !blockhorizontalconstraintparameter->name)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blockhorizontalconstraintparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockhorizontalconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blockhorizontalconstraintparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockhorizontalconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockhorizontalconstraintparameter->parameter_base_location, parameter_base_location);
    blockhorizontalconstraintparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockhorizontalconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockhorizontalconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockhorizontalconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockhorizontalconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockhorizontalconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockhorizontalconstraintparameter->prop_states)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockhorizontalconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockhorizontalconstraintparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockhorizontalconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockhorizontalconstraintparameter->show_properties, show_properties);
    blockhorizontalconstraintparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockhorizontalconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockhorizontalconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.upd_endpt [3BD]");
  }
  {
    BITCODE_BD value;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "value", &value, NULL)
        && value == blockhorizontalconstraintparameter->value)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.value [BD] %g != %g", blockhorizontalconstraintparameter->value, value);
    value++;
    if (dwg_dynapi_entity_set_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "value", &value, 0)
        && value == blockhorizontalconstraintparameter->value)
      pass ();
    else
      fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.value [BD] set+1 %g != %g", blockhorizontalconstraintparameter->value, value);
    blockhorizontalconstraintparameter->value--;
  }
  {
    Dwg_BLOCKPARAMVALUESET value_set;
    if (dwg_dynapi_entity_value (blockhorizontalconstraintparameter, "BLOCKHORIZONTALCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
        && !memcmp (&value_set, &blockhorizontalconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKHORIZONTALCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKHORIZONTALCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKHORIZONTALCONSTRAINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKHORIZONTALCONSTRAINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKLINEARCONSTRAINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKLINEARCONSTRAINTPARAMETER *restrict blocklinearconstraintparameter = obj->tio.object->tio.BLOCKLINEARCONSTRAINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blocklinearconstraintparameter)
    {
      fail ("NULL BLOCKLINEARCONSTRAINTPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blocklinearconstraintparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blocklinearconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.be_major [BL] %u != %u", blocklinearconstraintparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blocklinearconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blocklinearconstraintparameter->be_major, be_major);
    blocklinearconstraintparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blocklinearconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blocklinearconstraintparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blocklinearconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blocklinearconstraintparameter->be_minor, be_minor);
    blocklinearconstraintparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blocklinearconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blocklinearconstraintparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blocklinearconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklinearconstraintparameter->chain_actions, chain_actions);
    blocklinearconstraintparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blocklinearconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blocklinearconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_H dependency;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
        && !memcmp (&dependency, &blocklinearconstraintparameter->dependency, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.dependency [H]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blocklinearconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blocklinearconstraintparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blocklinearconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blocklinearconstraintparameter->eed1071, eed1071);
    blocklinearconstraintparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blocklinearconstraintparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blocklinearconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T expr_description;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
        && expr_description
           ? strEQ ((char *)expr_description, (char *)blocklinearconstraintparameter->expr_description)
           : !blocklinearconstraintparameter->expr_description)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blocklinearconstraintparameter->expr_description);
  }
  {
    BITCODE_T expr_name;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
        && expr_name
           ? strEQ ((char *)expr_name, (char *)blocklinearconstraintparameter->expr_name)
           : !blocklinearconstraintparameter->expr_name)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blocklinearconstraintparameter->expr_name);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blocklinearconstraintparameter->name)
           : !blocklinearconstraintparameter->name)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blocklinearconstraintparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blocklinearconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blocklinearconstraintparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blocklinearconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blocklinearconstraintparameter->parameter_base_location, parameter_base_location);
    blocklinearconstraintparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blocklinearconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blocklinearconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blocklinearconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blocklinearconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blocklinearconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blocklinearconstraintparameter->prop_states)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blocklinearconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blocklinearconstraintparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blocklinearconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklinearconstraintparameter->show_properties, show_properties);
    blocklinearconstraintparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blocklinearconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blocklinearconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.upd_endpt [3BD]");
  }
  {
    BITCODE_BD value;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "value", &value, NULL)
        && value == blocklinearconstraintparameter->value)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.value [BD] %g != %g", blocklinearconstraintparameter->value, value);
    value++;
    if (dwg_dynapi_entity_set_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "value", &value, 0)
        && value == blocklinearconstraintparameter->value)
      pass ();
    else
      fail ("BLOCKLINEARCONSTRAINTPARAMETER.value [BD] set+1 %g != %g", blocklinearconstraintparameter->value, value);
    blocklinearconstraintparameter->value--;
  }
  {
    Dwg_BLOCKPARAMVALUESET value_set;
    if (dwg_dynapi_entity_value (blocklinearconstraintparameter, "BLOCKLINEARCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
        && !memcmp (&value_set, &blocklinearconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKLINEARCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKLINEARCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKLINEARCONSTRAINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKLINEARCONSTRAINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKLINEARGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKLINEARGRIP *restrict blocklineargrip = obj->tio.object->tio.BLOCKLINEARGRIP;
  failed = 0;
  if (!obj_obj || !blocklineargrip)
    {
      fail ("NULL BLOCKLINEARGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "be_major", &be_major, NULL)
        && be_major == blocklineargrip->be_major)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.be_major [BL] %u != %u", blocklineargrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blocklineargrip, "BLOCKLINEARGRIP", "be_major", &be_major, 0)
        && be_major == blocklineargrip->be_major)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.be_major [BL] set+1 %u != %u", blocklineargrip->be_major, be_major);
    blocklineargrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blocklineargrip->be_minor)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.be_minor [BL] %u != %u", blocklineargrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blocklineargrip, "BLOCKLINEARGRIP", "be_minor", &be_minor, 0)
        && be_minor == blocklineargrip->be_minor)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.be_minor [BL] set+1 %u != %u", blocklineargrip->be_minor, be_minor);
    blocklineargrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blocklineargrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.bg_bl91 [BL] %u != %u", blocklineargrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blocklineargrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.bg_bl91 [BL] set+1 %u != %u", blocklineargrip->bg_bl91, bg_bl91);
    blocklineargrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blocklineargrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.bg_bl92 [BL] %u != %u", blocklineargrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blocklineargrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.bg_bl92 [BL] set+1 %u != %u", blocklineargrip->bg_bl92, bg_bl92);
    blocklineargrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blocklineargrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blocklineargrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blocklineargrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklineargrip->bg_insert_cycling, bg_insert_cycling);
    blocklineargrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blocklineargrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blocklineargrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blocklineargrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blocklineargrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blocklineargrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blocklineargrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blocklineargrip->eed1071)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.eed1071 [BL] %u != %u", blocklineargrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blocklineargrip, "BLOCKLINEARGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blocklineargrip->eed1071)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.eed1071 [BL] set+1 %u != %u", blocklineargrip->eed1071, eed1071);
    blocklineargrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blocklineargrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKLINEARGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blocklineargrip->name)
           : !blocklineargrip->name)
      pass ();
    else
      fail ("BLOCKLINEARGRIP.name [T] '%s' <> '%s'", name, blocklineargrip->name);
  }
  {
    BITCODE_3BD orientation;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "orientation", &orientation, NULL)
        && !memcmp (&orientation, &blocklineargrip->orientation, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARGRIP.orientation [3BD_1]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blocklineargrip, "BLOCKLINEARGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blocklineargrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKLINEARGRIP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKLINEARGRIP") || is_class_debugging ("BLOCKLINEARGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKLINEARGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKLINEARPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKLINEARPARAMETER *restrict blocklinearparameter = obj->tio.object->tio.BLOCKLINEARPARAMETER;
  failed = 0;
  if (!obj_obj || !blocklinearparameter)
    {
      fail ("NULL BLOCKLINEARPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blocklinearparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "be_major", &be_major, NULL)
        && be_major == blocklinearparameter->be_major)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.be_major [BL] %u != %u", blocklinearparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "be_major", &be_major, 0)
        && be_major == blocklinearparameter->be_major)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.be_major [BL] set+1 %u != %u", blocklinearparameter->be_major, be_major);
    blocklinearparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blocklinearparameter->be_minor)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.be_minor [BL] %u != %u", blocklinearparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blocklinearparameter->be_minor)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.be_minor [BL] set+1 %u != %u", blocklinearparameter->be_minor, be_minor);
    blocklinearparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blocklinearparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blocklinearparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blocklinearparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklinearparameter->chain_actions, chain_actions);
    blocklinearparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blocklinearparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blocklinearparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_BD distance;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "distance", &distance, NULL)
        && distance == blocklinearparameter->distance)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.distance [BD] %g != %g", blocklinearparameter->distance, distance);
    distance++;
    if (dwg_dynapi_entity_set_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "distance", &distance, 0)
        && distance == blocklinearparameter->distance)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.distance [BD] set+1 %g != %g", blocklinearparameter->distance, distance);
    blocklinearparameter->distance--;
  }
  {
    BITCODE_T distance_desc;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "distance_desc", &distance_desc, NULL)
        && distance_desc
           ? strEQ ((char *)distance_desc, (char *)blocklinearparameter->distance_desc)
           : !blocklinearparameter->distance_desc)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.distance_desc [T] '%s' <> '%s'", distance_desc, blocklinearparameter->distance_desc);
  }
  {
    BITCODE_T distance_name;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "distance_name", &distance_name, NULL)
        && distance_name
           ? strEQ ((char *)distance_name, (char *)blocklinearparameter->distance_name)
           : !blocklinearparameter->distance_name)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.distance_name [T] '%s' <> '%s'", distance_name, blocklinearparameter->distance_name);
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blocklinearparameter->eed1071)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.eed1071 [BL] %u != %u", blocklinearparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blocklinearparameter->eed1071)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.eed1071 [BL] set+1 %u != %u", blocklinearparameter->eed1071, eed1071);
    blocklinearparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blocklinearparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blocklinearparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blocklinearparameter->name)
           : !blocklinearparameter->name)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.name [T] '%s' <> '%s'", name, blocklinearparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blocklinearparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.parameter_base_location [BS] %hu != %hu", blocklinearparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blocklinearparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blocklinearparameter->parameter_base_location, parameter_base_location);
    blocklinearparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blocklinearparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blocklinearparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blocklinearparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blocklinearparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blocklinearparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blocklinearparameter->prop_states)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blocklinearparameter->show_properties)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blocklinearparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blocklinearparameter->show_properties)
      pass ();
    else
      fail ("BLOCKLINEARPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklinearparameter->show_properties, show_properties);
    blocklinearparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blocklinearparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blocklinearparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.upd_endpt [3BD]");
  }
  {
    Dwg_BLOCKPARAMVALUESET value_set;
    if (dwg_dynapi_entity_value (blocklinearparameter, "BLOCKLINEARPARAMETER", "value_set", &value_set, NULL)
        && !memcmp (&value_set, &blocklinearparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKLINEARPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKLINEARPARAMETER") || is_class_debugging ("BLOCKLINEARPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKLINEARPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKLOOKUPACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKLOOKUPACTION *restrict blocklookupaction = obj->tio.object->tio.BLOCKLOOKUPACTION;
  failed = 0;
  if (!obj_obj || !blocklookupaction)
    {
      fail ("NULL BLOCKLOOKUPACTION");
      return 1;
    }
  {
    BITCODE_BL* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "actions", &actions, NULL)
        && actions == blocklookupaction->actions)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.actions [BL*] * %u num_actions", count);
  }
  {
    BITCODE_B b280;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "b280", &b280, NULL)
        && b280 == blocklookupaction->b280)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.b280 [B] " FORMAT_B " != " FORMAT_B "", blocklookupaction->b280, b280);
    b280++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "b280", &b280, 0)
        && b280 == blocklookupaction->b280)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.b280 [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklookupaction->b280, b280);
    blocklookupaction->b280--;
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "be_major", &be_major, NULL)
        && be_major == blocklookupaction->be_major)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.be_major [BL] %u != %u", blocklookupaction->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "be_major", &be_major, 0)
        && be_major == blocklookupaction->be_major)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.be_major [BL] set+1 %u != %u", blocklookupaction->be_major, be_major);
    blocklookupaction->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "be_minor", &be_minor, NULL)
        && be_minor == blocklookupaction->be_minor)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.be_minor [BL] %u != %u", blocklookupaction->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "be_minor", &be_minor, 0)
        && be_minor == blocklookupaction->be_minor)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.be_minor [BL] set+1 %u != %u", blocklookupaction->be_minor, be_minor);
    blocklookupaction->be_minor--;
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "deps", &deps, NULL)
        && deps == blocklookupaction->deps)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_3BD display_location;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "display_location", &display_location, NULL)
        && !memcmp (&display_location, &blocklookupaction->display_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLOOKUPACTION.display_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "eed1071", &eed1071, NULL)
        && eed1071 == blocklookupaction->eed1071)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.eed1071 [BL] %u != %u", blocklookupaction->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "eed1071", &eed1071, 0)
        && eed1071 == blocklookupaction->eed1071)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.eed1071 [BL] set+1 %u != %u", blocklookupaction->eed1071, eed1071);
    blocklookupaction->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blocklookupaction->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKLOOKUPACTION.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_TV* exprs;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "num_exprs", &count, NULL)
        && dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "exprs", &exprs, NULL)
        && exprs == blocklookupaction->exprs)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.exprs [TV*] * %u num_exprs", count);
  }
  {
    Dwg_BLOCKLOOKUPACTION_lut* lut;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "num_lut", &count, NULL)
        && dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "lut", &lut, NULL)
        && lut == blocklookupaction->lut)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.lut [Dwg_BLOCKLOOKUPACTION_lut*] * %u num_lut", count);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blocklookupaction->name)
           : !blocklookupaction->name)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.name [T] '%s' <> '%s'", name, blocklookupaction->name);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "num_actions", &num_actions, NULL)
        && num_actions == blocklookupaction->num_actions)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.num_actions [BL] %u != %u", blocklookupaction->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "num_actions", &num_actions, 0)
        && num_actions == blocklookupaction->num_actions)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.num_actions [BL] set+1 %u != %u", blocklookupaction->num_actions, num_actions);
    blocklookupaction->num_actions--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "num_deps", &num_deps, NULL)
        && num_deps == blocklookupaction->num_deps)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.num_deps [BL] %u != %u", blocklookupaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "num_deps", &num_deps, 0)
        && num_deps == blocklookupaction->num_deps)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.num_deps [BL] set+1 %u != %u", blocklookupaction->num_deps, num_deps);
    blocklookupaction->num_deps--;
  }
  {
    BITCODE_BL numcols;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "numcols", &numcols, NULL)
        && numcols == blocklookupaction->numcols)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.numcols [BL] %u != %u", blocklookupaction->numcols, numcols);
    numcols++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "numcols", &numcols, 0)
        && numcols == blocklookupaction->numcols)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.numcols [BL] set+1 %u != %u", blocklookupaction->numcols, numcols);
    blocklookupaction->numcols--;
  }
  {
    BITCODE_BL numelems;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "numelems", &numelems, NULL)
        && numelems == blocklookupaction->numelems)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.numelems [BL] %u != %u", blocklookupaction->numelems, numelems);
    numelems++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "numelems", &numelems, 0)
        && numelems == blocklookupaction->numelems)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.numelems [BL] set+1 %u != %u", blocklookupaction->numelems, numelems);
    blocklookupaction->numelems--;
  }
  {
    BITCODE_BL numrows;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "numrows", &numrows, NULL)
        && numrows == blocklookupaction->numrows)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.numrows [BL] %u != %u", blocklookupaction->numrows, numrows);
    numrows++;
    if (dwg_dynapi_entity_set_value (blocklookupaction, "BLOCKLOOKUPACTION", "numrows", &numrows, 0)
        && numrows == blocklookupaction->numrows)
      pass ();
    else
      fail ("BLOCKLOOKUPACTION.numrows [BL] set+1 %u != %u", blocklookupaction->numrows, numrows);
    blocklookupaction->numrows--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blocklookupaction, "BLOCKLOOKUPACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &blocklookupaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKLOOKUPACTION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKLOOKUPACTION") || is_class_debugging ("BLOCKLOOKUPACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKLOOKUPACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKLOOKUPGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKLOOKUPGRIP *restrict blocklookupgrip = obj->tio.object->tio.BLOCKLOOKUPGRIP;
  failed = 0;
  if (!obj_obj || !blocklookupgrip)
    {
      fail ("NULL BLOCKLOOKUPGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "be_major", &be_major, NULL)
        && be_major == blocklookupgrip->be_major)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.be_major [BL] %u != %u", blocklookupgrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "be_major", &be_major, 0)
        && be_major == blocklookupgrip->be_major)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.be_major [BL] set+1 %u != %u", blocklookupgrip->be_major, be_major);
    blocklookupgrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blocklookupgrip->be_minor)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.be_minor [BL] %u != %u", blocklookupgrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "be_minor", &be_minor, 0)
        && be_minor == blocklookupgrip->be_minor)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.be_minor [BL] set+1 %u != %u", blocklookupgrip->be_minor, be_minor);
    blocklookupgrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blocklookupgrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.bg_bl91 [BL] %u != %u", blocklookupgrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blocklookupgrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.bg_bl91 [BL] set+1 %u != %u", blocklookupgrip->bg_bl91, bg_bl91);
    blocklookupgrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blocklookupgrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.bg_bl92 [BL] %u != %u", blocklookupgrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blocklookupgrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.bg_bl92 [BL] set+1 %u != %u", blocklookupgrip->bg_bl92, bg_bl92);
    blocklookupgrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blocklookupgrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blocklookupgrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blocklookupgrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklookupgrip->bg_insert_cycling, bg_insert_cycling);
    blocklookupgrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blocklookupgrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blocklookupgrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blocklookupgrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blocklookupgrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blocklookupgrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blocklookupgrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLOOKUPGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blocklookupgrip->eed1071)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.eed1071 [BL] %u != %u", blocklookupgrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blocklookupgrip->eed1071)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.eed1071 [BL] set+1 %u != %u", blocklookupgrip->eed1071, eed1071);
    blocklookupgrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blocklookupgrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKLOOKUPGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blocklookupgrip->name)
           : !blocklookupgrip->name)
      pass ();
    else
      fail ("BLOCKLOOKUPGRIP.name [T] '%s' <> '%s'", name, blocklookupgrip->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blocklookupgrip, "BLOCKLOOKUPGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blocklookupgrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKLOOKUPGRIP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKLOOKUPGRIP") || is_class_debugging ("BLOCKLOOKUPGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKLOOKUPGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKLOOKUPPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKLOOKUPPARAMETER *restrict blocklookupparameter = obj->tio.object->tio.BLOCKLOOKUPPARAMETER;
  failed = 0;
  if (!obj_obj || !blocklookupparameter)
    {
      fail ("NULL BLOCKLOOKUPPARAMETER");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "be_major", &be_major, NULL)
        && be_major == blocklookupparameter->be_major)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.be_major [BL] %u != %u", blocklookupparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "be_major", &be_major, 0)
        && be_major == blocklookupparameter->be_major)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.be_major [BL] set+1 %u != %u", blocklookupparameter->be_major, be_major);
    blocklookupparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blocklookupparameter->be_minor)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.be_minor [BL] %u != %u", blocklookupparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blocklookupparameter->be_minor)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.be_minor [BL] set+1 %u != %u", blocklookupparameter->be_minor, be_minor);
    blocklookupparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blocklookupparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blocklookupparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blocklookupparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklookupparameter->chain_actions, chain_actions);
    blocklookupparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &blocklookupparameter->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKLOOKUPPARAMETER.def_pt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blocklookupparameter->eed1071)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.eed1071 [BL] %u != %u", blocklookupparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blocklookupparameter->eed1071)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.eed1071 [BL] set+1 %u != %u", blocklookupparameter->eed1071, eed1071);
    blocklookupparameter->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blocklookupparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKLOOKUPPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_BL index;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "index", &index, NULL)
        && index == blocklookupparameter->index)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.index [BL] %u != %u", blocklookupparameter->index, index);
    index++;
    if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "index", &index, 0)
        && index == blocklookupparameter->index)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.index [BL] set+1 %u != %u", blocklookupparameter->index, index);
    blocklookupparameter->index--;
  }
  {
    BITCODE_T lookup_desc;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "lookup_desc", &lookup_desc, NULL)
        && lookup_desc
           ? strEQ ((char *)lookup_desc, (char *)blocklookupparameter->lookup_desc)
           : !blocklookupparameter->lookup_desc)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.lookup_desc [T] '%s' <> '%s'", lookup_desc, blocklookupparameter->lookup_desc);
  }
  {
    BITCODE_T lookup_name;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "lookup_name", &lookup_name, NULL)
        && lookup_name
           ? strEQ ((char *)lookup_name, (char *)blocklookupparameter->lookup_name)
           : !blocklookupparameter->lookup_name)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.lookup_name [T] '%s' <> '%s'", lookup_name, blocklookupparameter->lookup_name);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blocklookupparameter->name)
           : !blocklookupparameter->name)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.name [T] '%s' <> '%s'", name, blocklookupparameter->name);
  }
  {
    BITCODE_BL num_propinfos;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "num_propinfos", &num_propinfos, NULL)
        && num_propinfos == blocklookupparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.num_propinfos [BL] %u != %u", blocklookupparameter->num_propinfos, num_propinfos);
    num_propinfos++;
    if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "num_propinfos", &num_propinfos, 0)
        && num_propinfos == blocklookupparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.num_propinfos [BL] set+1 %u != %u", blocklookupparameter->num_propinfos, num_propinfos);
    blocklookupparameter->num_propinfos--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blocklookupparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKLOOKUPPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blocklookupparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLOOKUPPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blocklookupparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKLOOKUPPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blocklookupparameter->show_properties)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blocklookupparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blocklookupparameter->show_properties)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklookupparameter->show_properties, show_properties);
    blocklookupparameter->show_properties--;
  }
  {
    BITCODE_T unknown_t;
    if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "unknown_t", &unknown_t, NULL)
        && unknown_t
           ? strEQ ((char *)unknown_t, (char *)blocklookupparameter->unknown_t)
           : !blocklookupparameter->unknown_t)
      pass ();
    else
      fail ("BLOCKLOOKUPPARAMETER.unknown_t [T] '%s' <> '%s'", unknown_t, blocklookupparameter->unknown_t);
  }
  if (failed && (is_class_unstable ("BLOCKLOOKUPPARAMETER") || is_class_debugging ("BLOCKLOOKUPPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKLOOKUPPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKMOVEACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKMOVEACTION *restrict blockmoveaction = obj->tio.object->tio.BLOCKMOVEACTION;
  failed = 0;
  if (!obj_obj || !blockmoveaction)
    {
      fail ("NULL BLOCKMOVEACTION");
      return 1;
    }
  {
    BITCODE_BD action_offset_x;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "action_offset_x", &action_offset_x, NULL)
        && action_offset_x == blockmoveaction->action_offset_x)
      pass ();
    else
      fail ("BLOCKMOVEACTION.action_offset_x [BD] %g != %g", blockmoveaction->action_offset_x, action_offset_x);
    action_offset_x++;
    if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "action_offset_x", &action_offset_x, 0)
        && action_offset_x == blockmoveaction->action_offset_x)
      pass ();
    else
      fail ("BLOCKMOVEACTION.action_offset_x [BD] set+1 %g != %g", blockmoveaction->action_offset_x, action_offset_x);
    blockmoveaction->action_offset_x--;
  }
  {
    BITCODE_BD action_offset_y;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "action_offset_y", &action_offset_y, NULL)
        && action_offset_y == blockmoveaction->action_offset_y)
      pass ();
    else
      fail ("BLOCKMOVEACTION.action_offset_y [BD] %g != %g", blockmoveaction->action_offset_y, action_offset_y);
    action_offset_y++;
    if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "action_offset_y", &action_offset_y, 0)
        && action_offset_y == blockmoveaction->action_offset_y)
      pass ();
    else
      fail ("BLOCKMOVEACTION.action_offset_y [BD] set+1 %g != %g", blockmoveaction->action_offset_y, action_offset_y);
    blockmoveaction->action_offset_y--;
  }
  {
    BITCODE_BL* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "actions", &actions, NULL)
        && actions == blockmoveaction->actions)
      pass ();
    else
      fail ("BLOCKMOVEACTION.actions [BL*] * %u num_actions", count);
  }
  {
    BITCODE_BD angle_offset;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "angle_offset", &angle_offset, NULL)
        && angle_offset == blockmoveaction->angle_offset)
      pass ();
    else
      fail ("BLOCKMOVEACTION.angle_offset [BD] %g != %g", blockmoveaction->angle_offset, angle_offset);
    angle_offset++;
    if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "angle_offset", &angle_offset, 0)
        && angle_offset == blockmoveaction->angle_offset)
      pass ();
    else
      fail ("BLOCKMOVEACTION.angle_offset [BD] set+1 %g != %g", blockmoveaction->angle_offset, angle_offset);
    blockmoveaction->angle_offset--;
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "be_major", &be_major, NULL)
        && be_major == blockmoveaction->be_major)
      pass ();
    else
      fail ("BLOCKMOVEACTION.be_major [BL] %u != %u", blockmoveaction->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "be_major", &be_major, 0)
        && be_major == blockmoveaction->be_major)
      pass ();
    else
      fail ("BLOCKMOVEACTION.be_major [BL] set+1 %u != %u", blockmoveaction->be_major, be_major);
    blockmoveaction->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "be_minor", &be_minor, NULL)
        && be_minor == blockmoveaction->be_minor)
      pass ();
    else
      fail ("BLOCKMOVEACTION.be_minor [BL] %u != %u", blockmoveaction->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "be_minor", &be_minor, 0)
        && be_minor == blockmoveaction->be_minor)
      pass ();
    else
      fail ("BLOCKMOVEACTION.be_minor [BL] set+1 %u != %u", blockmoveaction->be_minor, be_minor);
    blockmoveaction->be_minor--;
  }
  {
    Dwg_BLOCKACTION_connectionpts conn_pts;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "conn_pts[2]", &conn_pts, NULL)
        && !memcmp (&conn_pts, &blockmoveaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
        pass ();
    else
        fail ("BLOCKMOVEACTION.conn_pts[2] [Dwg_BLOCKACTION_connectionpts]");
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "deps", &deps, NULL)
        && deps == blockmoveaction->deps)
      pass ();
    else
      fail ("BLOCKMOVEACTION.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_3BD display_location;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "display_location", &display_location, NULL)
        && !memcmp (&display_location, &blockmoveaction->display_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKMOVEACTION.display_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "eed1071", &eed1071, NULL)
        && eed1071 == blockmoveaction->eed1071)
      pass ();
    else
      fail ("BLOCKMOVEACTION.eed1071 [BL] %u != %u", blockmoveaction->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "eed1071", &eed1071, 0)
        && eed1071 == blockmoveaction->eed1071)
      pass ();
    else
      fail ("BLOCKMOVEACTION.eed1071 [BL] set+1 %u != %u", blockmoveaction->eed1071, eed1071);
    blockmoveaction->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockmoveaction->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKMOVEACTION.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockmoveaction->name)
           : !blockmoveaction->name)
      pass ();
    else
      fail ("BLOCKMOVEACTION.name [T] '%s' <> '%s'", name, blockmoveaction->name);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "num_actions", &num_actions, NULL)
        && num_actions == blockmoveaction->num_actions)
      pass ();
    else
      fail ("BLOCKMOVEACTION.num_actions [BL] %u != %u", blockmoveaction->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "num_actions", &num_actions, 0)
        && num_actions == blockmoveaction->num_actions)
      pass ();
    else
      fail ("BLOCKMOVEACTION.num_actions [BL] set+1 %u != %u", blockmoveaction->num_actions, num_actions);
    blockmoveaction->num_actions--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "num_deps", &num_deps, NULL)
        && num_deps == blockmoveaction->num_deps)
      pass ();
    else
      fail ("BLOCKMOVEACTION.num_deps [BL] %u != %u", blockmoveaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "num_deps", &num_deps, 0)
        && num_deps == blockmoveaction->num_deps)
      pass ();
    else
      fail ("BLOCKMOVEACTION.num_deps [BL] set+1 %u != %u", blockmoveaction->num_deps, num_deps);
    blockmoveaction->num_deps--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &blockmoveaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKMOVEACTION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKMOVEACTION") || is_class_debugging ("BLOCKMOVEACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKMOVEACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKPARAMDEPENDENCYBODY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKPARAMDEPENDENCYBODY *restrict blockparamdependencybody = obj->tio.object->tio.BLOCKPARAMDEPENDENCYBODY;
  failed = 0;
  if (!obj_obj || !blockparamdependencybody)
    {
      fail ("NULL BLOCKPARAMDEPENDENCYBODY");
      return 1;
    }
  {
    BITCODE_BS adb_version;
    if (dwg_dynapi_entity_value (blockparamdependencybody, "BLOCKPARAMDEPENDENCYBODY", "adb_version", &adb_version, NULL)
        && adb_version == blockparamdependencybody->adb_version)
      pass ();
    else
      fail ("BLOCKPARAMDEPENDENCYBODY.adb_version [BS] %hu != %hu", blockparamdependencybody->adb_version, adb_version);
    adb_version++;
    if (dwg_dynapi_entity_set_value (blockparamdependencybody, "BLOCKPARAMDEPENDENCYBODY", "adb_version", &adb_version, 0)
        && adb_version == blockparamdependencybody->adb_version)
      pass ();
    else
      fail ("BLOCKPARAMDEPENDENCYBODY.adb_version [BS] set+1 %hu != %hu", blockparamdependencybody->adb_version, adb_version);
    blockparamdependencybody->adb_version--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (blockparamdependencybody, "BLOCKPARAMDEPENDENCYBODY", "class_version", &class_version, NULL)
        && class_version == blockparamdependencybody->class_version)
      pass ();
    else
      fail ("BLOCKPARAMDEPENDENCYBODY.class_version [BS] %hu != %hu", blockparamdependencybody->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (blockparamdependencybody, "BLOCKPARAMDEPENDENCYBODY", "class_version", &class_version, 0)
        && class_version == blockparamdependencybody->class_version)
      pass ();
    else
      fail ("BLOCKPARAMDEPENDENCYBODY.class_version [BS] set+1 %hu != %hu", blockparamdependencybody->class_version, class_version);
    blockparamdependencybody->class_version--;
  }
  {
    BITCODE_BS dimbase_version;
    if (dwg_dynapi_entity_value (blockparamdependencybody, "BLOCKPARAMDEPENDENCYBODY", "dimbase_version", &dimbase_version, NULL)
        && dimbase_version == blockparamdependencybody->dimbase_version)
      pass ();
    else
      fail ("BLOCKPARAMDEPENDENCYBODY.dimbase_version [BS] %hu != %hu", blockparamdependencybody->dimbase_version, dimbase_version);
    dimbase_version++;
    if (dwg_dynapi_entity_set_value (blockparamdependencybody, "BLOCKPARAMDEPENDENCYBODY", "dimbase_version", &dimbase_version, 0)
        && dimbase_version == blockparamdependencybody->dimbase_version)
      pass ();
    else
      fail ("BLOCKPARAMDEPENDENCYBODY.dimbase_version [BS] set+1 %hu != %hu", blockparamdependencybody->dimbase_version, dimbase_version);
    blockparamdependencybody->dimbase_version--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockparamdependencybody, "BLOCKPARAMDEPENDENCYBODY", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockparamdependencybody->name)
           : !blockparamdependencybody->name)
      pass ();
    else
      fail ("BLOCKPARAMDEPENDENCYBODY.name [T] '%s' <> '%s'", name, blockparamdependencybody->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockparamdependencybody, "BLOCKPARAMDEPENDENCYBODY", "parent", &parent, NULL)
        && !memcmp (&parent, &blockparamdependencybody->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKPARAMDEPENDENCYBODY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKPARAMDEPENDENCYBODY") || is_class_debugging ("BLOCKPARAMDEPENDENCYBODY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKPARAMDEPENDENCYBODY", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKPOINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKPOINTPARAMETER *restrict blockpointparameter = obj->tio.object->tio.BLOCKPOINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockpointparameter)
    {
      fail ("NULL BLOCKPOINTPARAMETER");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockpointparameter->be_major)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.be_major [BL] %u != %u", blockpointparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockpointparameter, "BLOCKPOINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockpointparameter->be_major)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.be_major [BL] set+1 %u != %u", blockpointparameter->be_major, be_major);
    blockpointparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockpointparameter->be_minor)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.be_minor [BL] %u != %u", blockpointparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockpointparameter, "BLOCKPOINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockpointparameter->be_minor)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.be_minor [BL] set+1 %u != %u", blockpointparameter->be_minor, be_minor);
    blockpointparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockpointparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockpointparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockpointparameter, "BLOCKPOINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockpointparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockpointparameter->chain_actions, chain_actions);
    blockpointparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_label_pt;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "def_label_pt", &def_label_pt, NULL)
        && !memcmp (&def_label_pt, &blockpointparameter->def_label_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOINTPARAMETER.def_label_pt [3BD]");
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &blockpointparameter->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOINTPARAMETER.def_pt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockpointparameter->eed1071)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.eed1071 [BL] %u != %u", blockpointparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockpointparameter, "BLOCKPOINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockpointparameter->eed1071)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockpointparameter->eed1071, eed1071);
    blockpointparameter->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockpointparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKPOINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockpointparameter->name)
           : !blockpointparameter->name)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.name [T] '%s' <> '%s'", name, blockpointparameter->name);
  }
  {
    BITCODE_BL num_propinfos;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "num_propinfos", &num_propinfos, NULL)
        && num_propinfos == blockpointparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.num_propinfos [BL] %u != %u", blockpointparameter->num_propinfos, num_propinfos);
    num_propinfos++;
    if (dwg_dynapi_entity_set_value (blockpointparameter, "BLOCKPOINTPARAMETER", "num_propinfos", &num_propinfos, 0)
        && num_propinfos == blockpointparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.num_propinfos [BL] set+1 %u != %u", blockpointparameter->num_propinfos, num_propinfos);
    blockpointparameter->num_propinfos--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockpointparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKPOINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T position_desc;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "position_desc", &position_desc, NULL)
        && position_desc
           ? strEQ ((char *)position_desc, (char *)blockpointparameter->position_desc)
           : !blockpointparameter->position_desc)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.position_desc [T] '%s' <> '%s'", position_desc, blockpointparameter->position_desc);
  }
  {
    BITCODE_T position_name;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "position_name", &position_name, NULL)
        && position_name
           ? strEQ ((char *)position_name, (char *)blockpointparameter->position_name)
           : !blockpointparameter->position_name)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.position_name [T] '%s' <> '%s'", position_name, blockpointparameter->position_name);
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockpointparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKPOINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockpointparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKPOINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockpointparameter, "BLOCKPOINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockpointparameter->show_properties)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockpointparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockpointparameter, "BLOCKPOINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockpointparameter->show_properties)
      pass ();
    else
      fail ("BLOCKPOINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockpointparameter->show_properties, show_properties);
    blockpointparameter->show_properties--;
  }
  if (failed && (is_class_unstable ("BLOCKPOINTPARAMETER") || is_class_debugging ("BLOCKPOINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKPOINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKPOLARGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKPOLARGRIP *restrict blockpolargrip = obj->tio.object->tio.BLOCKPOLARGRIP;
  failed = 0;
  if (!obj_obj || !blockpolargrip)
    {
      fail ("NULL BLOCKPOLARGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "be_major", &be_major, NULL)
        && be_major == blockpolargrip->be_major)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.be_major [BL] %u != %u", blockpolargrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockpolargrip, "BLOCKPOLARGRIP", "be_major", &be_major, 0)
        && be_major == blockpolargrip->be_major)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.be_major [BL] set+1 %u != %u", blockpolargrip->be_major, be_major);
    blockpolargrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blockpolargrip->be_minor)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.be_minor [BL] %u != %u", blockpolargrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockpolargrip, "BLOCKPOLARGRIP", "be_minor", &be_minor, 0)
        && be_minor == blockpolargrip->be_minor)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.be_minor [BL] set+1 %u != %u", blockpolargrip->be_minor, be_minor);
    blockpolargrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blockpolargrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.bg_bl91 [BL] %u != %u", blockpolargrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blockpolargrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.bg_bl91 [BL] set+1 %u != %u", blockpolargrip->bg_bl91, bg_bl91);
    blockpolargrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blockpolargrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.bg_bl92 [BL] %u != %u", blockpolargrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blockpolargrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.bg_bl92 [BL] set+1 %u != %u", blockpolargrip->bg_bl92, bg_bl92);
    blockpolargrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blockpolargrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blockpolargrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blockpolargrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blockpolargrip->bg_insert_cycling, bg_insert_cycling);
    blockpolargrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blockpolargrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blockpolargrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blockpolargrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blockpolargrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blockpolargrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blockpolargrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOLARGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blockpolargrip->eed1071)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.eed1071 [BL] %u != %u", blockpolargrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockpolargrip, "BLOCKPOLARGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blockpolargrip->eed1071)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.eed1071 [BL] set+1 %u != %u", blockpolargrip->eed1071, eed1071);
    blockpolargrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockpolargrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKPOLARGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockpolargrip->name)
           : !blockpolargrip->name)
      pass ();
    else
      fail ("BLOCKPOLARGRIP.name [T] '%s' <> '%s'", name, blockpolargrip->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockpolargrip, "BLOCKPOLARGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blockpolargrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKPOLARGRIP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKPOLARGRIP") || is_class_debugging ("BLOCKPOLARGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKPOLARGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKPOLARPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKPOLARPARAMETER *restrict blockpolarparameter = obj->tio.object->tio.BLOCKPOLARPARAMETER;
  failed = 0;
  if (!obj_obj || !blockpolarparameter)
    {
      fail ("NULL BLOCKPOLARPARAMETER");
      return 1;
    }
  {
    BITCODE_T angle_desc;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "angle_desc", &angle_desc, NULL)
        && angle_desc
           ? strEQ ((char *)angle_desc, (char *)blockpolarparameter->angle_desc)
           : !blockpolarparameter->angle_desc)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.angle_desc [T] '%s' <> '%s'", angle_desc, blockpolarparameter->angle_desc);
  }
  {
    BITCODE_T angle_name;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "angle_name", &angle_name, NULL)
        && angle_name
           ? strEQ ((char *)angle_name, (char *)blockpolarparameter->angle_name)
           : !blockpolarparameter->angle_name)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.angle_name [T] '%s' <> '%s'", angle_name, blockpolarparameter->angle_name);
  }
  {
    Dwg_BLOCKPARAMVALUESET angle_value_set;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "angle_value_set", &angle_value_set, NULL)
        && !memcmp (&angle_value_set, &blockpolarparameter->angle_value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.angle_value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockpolarparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockpolarparameter->be_major)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.be_major [BL] %u != %u", blockpolarparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "be_major", &be_major, 0)
        && be_major == blockpolarparameter->be_major)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.be_major [BL] set+1 %u != %u", blockpolarparameter->be_major, be_major);
    blockpolarparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockpolarparameter->be_minor)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.be_minor [BL] %u != %u", blockpolarparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockpolarparameter->be_minor)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.be_minor [BL] set+1 %u != %u", blockpolarparameter->be_minor, be_minor);
    blockpolarparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockpolarparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockpolarparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockpolarparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockpolarparameter->chain_actions, chain_actions);
    blockpolarparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockpolarparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockpolarparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_T distance_desc;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "distance_desc", &distance_desc, NULL)
        && distance_desc
           ? strEQ ((char *)distance_desc, (char *)blockpolarparameter->distance_desc)
           : !blockpolarparameter->distance_desc)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.distance_desc [T] '%s' <> '%s'", distance_desc, blockpolarparameter->distance_desc);
  }
  {
    BITCODE_T distance_name;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "distance_name", &distance_name, NULL)
        && distance_name
           ? strEQ ((char *)distance_name, (char *)blockpolarparameter->distance_name)
           : !blockpolarparameter->distance_name)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.distance_name [T] '%s' <> '%s'", distance_name, blockpolarparameter->distance_name);
  }
  {
    Dwg_BLOCKPARAMVALUESET distance_value_set;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "distance_value_set", &distance_value_set, NULL)
        && !memcmp (&distance_value_set, &blockpolarparameter->distance_value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.distance_value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockpolarparameter->eed1071)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.eed1071 [BL] %u != %u", blockpolarparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockpolarparameter->eed1071)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.eed1071 [BL] set+1 %u != %u", blockpolarparameter->eed1071, eed1071);
    blockpolarparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockpolarparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockpolarparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockpolarparameter->name)
           : !blockpolarparameter->name)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.name [T] '%s' <> '%s'", name, blockpolarparameter->name);
  }
  {
    BITCODE_BD offset;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "offset", &offset, NULL)
        && offset == blockpolarparameter->offset)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.offset [BD] %g != %g", blockpolarparameter->offset, offset);
    offset++;
    if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "offset", &offset, 0)
        && offset == blockpolarparameter->offset)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.offset [BD] set+1 %g != %g", blockpolarparameter->offset, offset);
    blockpolarparameter->offset--;
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockpolarparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.parameter_base_location [BS] %hu != %hu", blockpolarparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockpolarparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockpolarparameter->parameter_base_location, parameter_base_location);
    blockpolarparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockpolarparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockpolarparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockpolarparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockpolarparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockpolarparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockpolarparameter->prop_states)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockpolarparameter->show_properties)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockpolarparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockpolarparameter->show_properties)
      pass ();
    else
      fail ("BLOCKPOLARPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockpolarparameter->show_properties, show_properties);
    blockpolarparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockpolarparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockpolarparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOLARPARAMETER.upd_endpt [3BD]");
  }
  if (failed && (is_class_unstable ("BLOCKPOLARPARAMETER") || is_class_debugging ("BLOCKPOLARPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKPOLARPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKPOLARSTRETCHACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKPOLARSTRETCHACTION *restrict blockpolarstretchaction = obj->tio.object->tio.BLOCKPOLARSTRETCHACTION;
  failed = 0;
  if (!obj_obj || !blockpolarstretchaction)
    {
      fail ("NULL BLOCKPOLARSTRETCHACTION");
      return 1;
    }
  {
    BITCODE_BL* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "actions", &actions, NULL)
        && actions == blockpolarstretchaction->actions)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.actions [BL*] * %u num_actions", count);
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "be_major", &be_major, NULL)
        && be_major == blockpolarstretchaction->be_major)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.be_major [BL] %u != %u", blockpolarstretchaction->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "be_major", &be_major, 0)
        && be_major == blockpolarstretchaction->be_major)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.be_major [BL] set+1 %u != %u", blockpolarstretchaction->be_major, be_major);
    blockpolarstretchaction->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "be_minor", &be_minor, NULL)
        && be_minor == blockpolarstretchaction->be_minor)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.be_minor [BL] %u != %u", blockpolarstretchaction->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "be_minor", &be_minor, 0)
        && be_minor == blockpolarstretchaction->be_minor)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.be_minor [BL] set+1 %u != %u", blockpolarstretchaction->be_minor, be_minor);
    blockpolarstretchaction->be_minor--;
  }
  {
    BITCODE_BL* codes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_codes", &count, NULL)
        && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "codes", &codes, NULL)
        && codes == blockpolarstretchaction->codes)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.codes [BL*] * %u num_codes", count);
  }
  {
    Dwg_BLOCKACTION_connectionpts conn_pts;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "conn_pts[6]", &conn_pts, NULL)
        && !memcmp (&conn_pts, &blockpolarstretchaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
        pass ();
    else
        fail ("BLOCKPOLARSTRETCHACTION.conn_pts[6] [Dwg_BLOCKACTION_connectionpts]");
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "deps", &deps, NULL)
        && deps == blockpolarstretchaction->deps)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_3BD display_location;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "display_location", &display_location, NULL)
        && !memcmp (&display_location, &blockpolarstretchaction->display_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPOLARSTRETCHACTION.display_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "eed1071", &eed1071, NULL)
        && eed1071 == blockpolarstretchaction->eed1071)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.eed1071 [BL] %u != %u", blockpolarstretchaction->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "eed1071", &eed1071, 0)
        && eed1071 == blockpolarstretchaction->eed1071)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.eed1071 [BL] set+1 %u != %u", blockpolarstretchaction->eed1071, eed1071);
    blockpolarstretchaction->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockpolarstretchaction->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKPOLARSTRETCHACTION.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_H* hdls;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_hdls", &count, NULL)
        && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "hdls", &hdls, NULL)
        && hdls == blockpolarstretchaction->hdls)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.hdls [H*] * %u num_hdls", count);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockpolarstretchaction->name)
           : !blockpolarstretchaction->name)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.name [T] '%s' <> '%s'", name, blockpolarstretchaction->name);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_actions", &num_actions, NULL)
        && num_actions == blockpolarstretchaction->num_actions)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_actions [BL] %u != %u", blockpolarstretchaction->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_actions", &num_actions, 0)
        && num_actions == blockpolarstretchaction->num_actions)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_actions [BL] set+1 %u != %u", blockpolarstretchaction->num_actions, num_actions);
    blockpolarstretchaction->num_actions--;
  }
  {
    BITCODE_BL num_codes;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_codes", &num_codes, NULL)
        && num_codes == blockpolarstretchaction->num_codes)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_codes [BL] %u != %u", blockpolarstretchaction->num_codes, num_codes);
    num_codes++;
    if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_codes", &num_codes, 0)
        && num_codes == blockpolarstretchaction->num_codes)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_codes [BL] set+1 %u != %u", blockpolarstretchaction->num_codes, num_codes);
    blockpolarstretchaction->num_codes--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_deps", &num_deps, NULL)
        && num_deps == blockpolarstretchaction->num_deps)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_deps [BL] %u != %u", blockpolarstretchaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_deps", &num_deps, 0)
        && num_deps == blockpolarstretchaction->num_deps)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_deps [BL] set+1 %u != %u", blockpolarstretchaction->num_deps, num_deps);
    blockpolarstretchaction->num_deps--;
  }
  {
    BITCODE_BL num_hdls;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_hdls", &num_hdls, NULL)
        && num_hdls == blockpolarstretchaction->num_hdls)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_hdls [BL] %u != %u", blockpolarstretchaction->num_hdls, num_hdls);
    num_hdls++;
    if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_hdls", &num_hdls, 0)
        && num_hdls == blockpolarstretchaction->num_hdls)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_hdls [BL] set+1 %u != %u", blockpolarstretchaction->num_hdls, num_hdls);
    blockpolarstretchaction->num_hdls--;
  }
  {
    BITCODE_BL num_pts;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_pts", &num_pts, NULL)
        && num_pts == blockpolarstretchaction->num_pts)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_pts [BL] %u != %u", blockpolarstretchaction->num_pts, num_pts);
    num_pts++;
    if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_pts", &num_pts, 0)
        && num_pts == blockpolarstretchaction->num_pts)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.num_pts [BL] set+1 %u != %u", blockpolarstretchaction->num_pts, num_pts);
    blockpolarstretchaction->num_pts--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &blockpolarstretchaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKPOLARSTRETCHACTION.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_2RD* pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_pts", &count, NULL)
        && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "pts", &pts, NULL)
        && pts == blockpolarstretchaction->pts)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.pts [2RD*] * %u num_pts", count);
  }
  {
    BITCODE_BS* shorts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_shorts", &count, NULL)
        && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "shorts", &shorts, NULL)
        && shorts == blockpolarstretchaction->shorts)
      pass ();
    else
      fail ("BLOCKPOLARSTRETCHACTION.shorts [BS*] * %u num_shorts", count);
  }
  if (failed && (is_class_unstable ("BLOCKPOLARSTRETCHACTION") || is_class_debugging ("BLOCKPOLARSTRETCHACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKPOLARSTRETCHACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKPROPERTIESTABLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKPROPERTIESTABLE *restrict blockpropertiestable = obj->tio.object->tio.BLOCKPROPERTIESTABLE;
  failed = 0;
  if (!obj_obj || !blockpropertiestable)
    {
      fail ("NULL BLOCKPROPERTIESTABLE");
      return 1;
    }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockpropertiestable, "BLOCKPROPERTIESTABLE", "parent", &parent, NULL)
        && !memcmp (&parent, &blockpropertiestable->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKPROPERTIESTABLE.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKPROPERTIESTABLE") || is_class_debugging ("BLOCKPROPERTIESTABLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKPROPERTIESTABLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKPROPERTIESTABLEGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKPROPERTIESTABLEGRIP *restrict blockpropertiestablegrip = obj->tio.object->tio.BLOCKPROPERTIESTABLEGRIP;
  failed = 0;
  if (!obj_obj || !blockpropertiestablegrip)
    {
      fail ("NULL BLOCKPROPERTIESTABLEGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "be_major", &be_major, NULL)
        && be_major == blockpropertiestablegrip->be_major)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.be_major [BL] %u != %u", blockpropertiestablegrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "be_major", &be_major, 0)
        && be_major == blockpropertiestablegrip->be_major)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.be_major [BL] set+1 %u != %u", blockpropertiestablegrip->be_major, be_major);
    blockpropertiestablegrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blockpropertiestablegrip->be_minor)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.be_minor [BL] %u != %u", blockpropertiestablegrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "be_minor", &be_minor, 0)
        && be_minor == blockpropertiestablegrip->be_minor)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.be_minor [BL] set+1 %u != %u", blockpropertiestablegrip->be_minor, be_minor);
    blockpropertiestablegrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blockpropertiestablegrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.bg_bl91 [BL] %u != %u", blockpropertiestablegrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blockpropertiestablegrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.bg_bl91 [BL] set+1 %u != %u", blockpropertiestablegrip->bg_bl91, bg_bl91);
    blockpropertiestablegrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blockpropertiestablegrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.bg_bl92 [BL] %u != %u", blockpropertiestablegrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blockpropertiestablegrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.bg_bl92 [BL] set+1 %u != %u", blockpropertiestablegrip->bg_bl92, bg_bl92);
    blockpropertiestablegrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blockpropertiestablegrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blockpropertiestablegrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blockpropertiestablegrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blockpropertiestablegrip->bg_insert_cycling, bg_insert_cycling);
    blockpropertiestablegrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blockpropertiestablegrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blockpropertiestablegrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blockpropertiestablegrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blockpropertiestablegrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blockpropertiestablegrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blockpropertiestablegrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKPROPERTIESTABLEGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blockpropertiestablegrip->eed1071)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.eed1071 [BL] %u != %u", blockpropertiestablegrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blockpropertiestablegrip->eed1071)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.eed1071 [BL] set+1 %u != %u", blockpropertiestablegrip->eed1071, eed1071);
    blockpropertiestablegrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockpropertiestablegrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKPROPERTIESTABLEGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockpropertiestablegrip->name)
           : !blockpropertiestablegrip->name)
      pass ();
    else
      fail ("BLOCKPROPERTIESTABLEGRIP.name [T] '%s' <> '%s'", name, blockpropertiestablegrip->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockpropertiestablegrip, "BLOCKPROPERTIESTABLEGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blockpropertiestablegrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKPROPERTIESTABLEGRIP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKPROPERTIESTABLEGRIP") || is_class_debugging ("BLOCKPROPERTIESTABLEGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKPROPERTIESTABLEGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKRADIALCONSTRAINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKRADIALCONSTRAINTPARAMETER *restrict blockradialconstraintparameter = obj->tio.object->tio.BLOCKRADIALCONSTRAINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockradialconstraintparameter)
    {
      fail ("NULL BLOCKRADIALCONSTRAINTPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockradialconstraintparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockradialconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.be_major [BL] %u != %u", blockradialconstraintparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockradialconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blockradialconstraintparameter->be_major, be_major);
    blockradialconstraintparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockradialconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blockradialconstraintparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockradialconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blockradialconstraintparameter->be_minor, be_minor);
    blockradialconstraintparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockradialconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockradialconstraintparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockradialconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockradialconstraintparameter->chain_actions, chain_actions);
    blockradialconstraintparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockradialconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockradialconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_H dependency;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
        && !memcmp (&dependency, &blockradialconstraintparameter->dependency, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.dependency [H]");
  }
  {
    BITCODE_BD distance;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "distance", &distance, NULL)
        && distance == blockradialconstraintparameter->distance)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.distance [BD] %g != %g", blockradialconstraintparameter->distance, distance);
    distance++;
    if (dwg_dynapi_entity_set_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "distance", &distance, 0)
        && distance == blockradialconstraintparameter->distance)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.distance [BD] set+1 %g != %g", blockradialconstraintparameter->distance, distance);
    blockradialconstraintparameter->distance--;
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockradialconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blockradialconstraintparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockradialconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockradialconstraintparameter->eed1071, eed1071);
    blockradialconstraintparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockradialconstraintparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockradialconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T expr_description;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
        && expr_description
           ? strEQ ((char *)expr_description, (char *)blockradialconstraintparameter->expr_description)
           : !blockradialconstraintparameter->expr_description)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blockradialconstraintparameter->expr_description);
  }
  {
    BITCODE_T expr_name;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
        && expr_name
           ? strEQ ((char *)expr_name, (char *)blockradialconstraintparameter->expr_name)
           : !blockradialconstraintparameter->expr_name)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blockradialconstraintparameter->expr_name);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockradialconstraintparameter->name)
           : !blockradialconstraintparameter->name)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blockradialconstraintparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockradialconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blockradialconstraintparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockradialconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockradialconstraintparameter->parameter_base_location, parameter_base_location);
    blockradialconstraintparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockradialconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockradialconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockradialconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockradialconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockradialconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockradialconstraintparameter->prop_states)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockradialconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockradialconstraintparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockradialconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKRADIALCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockradialconstraintparameter->show_properties, show_properties);
    blockradialconstraintparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockradialconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockradialconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.upd_endpt [3BD]");
  }
  {
    Dwg_BLOCKPARAMVALUESET value_set;
    if (dwg_dynapi_entity_value (blockradialconstraintparameter, "BLOCKRADIALCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
        && !memcmp (&value_set, &blockradialconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKRADIALCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKRADIALCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKRADIALCONSTRAINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKRADIALCONSTRAINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKREPRESENTATION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKREPRESENTATION *restrict blockrepresentation = obj->tio.object->tio.BLOCKREPRESENTATION;
  failed = 0;
  if (!obj_obj || !blockrepresentation)
    {
      fail ("NULL BLOCKREPRESENTATION");
      return 1;
    }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (blockrepresentation, "BLOCKREPRESENTATION", "block", &block, NULL)
        && !memcmp (&block, &blockrepresentation->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKREPRESENTATION.block [H]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (blockrepresentation, "BLOCKREPRESENTATION", "flag", &flag, NULL)
        && flag == blockrepresentation->flag)
      pass ();
    else
      fail ("BLOCKREPRESENTATION.flag [BS] %hu != %hu", blockrepresentation->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (blockrepresentation, "BLOCKREPRESENTATION", "flag", &flag, 0)
        && flag == blockrepresentation->flag)
      pass ();
    else
      fail ("BLOCKREPRESENTATION.flag [BS] set+1 %hu != %hu", blockrepresentation->flag, flag);
    blockrepresentation->flag--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockrepresentation, "BLOCKREPRESENTATION", "parent", &parent, NULL)
        && !memcmp (&parent, &blockrepresentation->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKREPRESENTATION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKREPRESENTATION") || is_class_debugging ("BLOCKREPRESENTATION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKREPRESENTATION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKROTATEACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKROTATEACTION *restrict blockrotateaction = obj->tio.object->tio.BLOCKROTATEACTION;
  failed = 0;
  if (!obj_obj || !blockrotateaction)
    {
      fail ("NULL BLOCKROTATEACTION");
      return 1;
    }
  {
    BITCODE_BL* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "actions", &actions, NULL)
        && actions == blockrotateaction->actions)
      pass ();
    else
      fail ("BLOCKROTATEACTION.actions [BL*] * %u num_actions", count);
  }
  {
    BITCODE_3BD base_pt;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "base_pt", &base_pt, NULL)
        && !memcmp (&base_pt, &blockrotateaction->base_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATEACTION.base_pt [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "be_major", &be_major, NULL)
        && be_major == blockrotateaction->be_major)
      pass ();
    else
      fail ("BLOCKROTATEACTION.be_major [BL] %u != %u", blockrotateaction->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "be_major", &be_major, 0)
        && be_major == blockrotateaction->be_major)
      pass ();
    else
      fail ("BLOCKROTATEACTION.be_major [BL] set+1 %u != %u", blockrotateaction->be_major, be_major);
    blockrotateaction->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "be_minor", &be_minor, NULL)
        && be_minor == blockrotateaction->be_minor)
      pass ();
    else
      fail ("BLOCKROTATEACTION.be_minor [BL] %u != %u", blockrotateaction->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "be_minor", &be_minor, 0)
        && be_minor == blockrotateaction->be_minor)
      pass ();
    else
      fail ("BLOCKROTATEACTION.be_minor [BL] set+1 %u != %u", blockrotateaction->be_minor, be_minor);
    blockrotateaction->be_minor--;
  }
  {
    Dwg_BLOCKACTION_connectionpts conn_pts;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "conn_pts[3]", &conn_pts, NULL)
        && !memcmp (&conn_pts, &blockrotateaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
        pass ();
    else
        fail ("BLOCKROTATEACTION.conn_pts[3] [Dwg_BLOCKACTION_connectionpts]");
  }
  {
    BITCODE_B dependent;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "dependent", &dependent, NULL)
        && dependent == blockrotateaction->dependent)
      pass ();
    else
      fail ("BLOCKROTATEACTION.dependent [B] " FORMAT_B " != " FORMAT_B "", blockrotateaction->dependent, dependent);
    dependent++;
    if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "dependent", &dependent, 0)
        && dependent == blockrotateaction->dependent)
      pass ();
    else
      fail ("BLOCKROTATEACTION.dependent [B] set+1 " FORMAT_B " != " FORMAT_B "", blockrotateaction->dependent, dependent);
    blockrotateaction->dependent--;
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "deps", &deps, NULL)
        && deps == blockrotateaction->deps)
      pass ();
    else
      fail ("BLOCKROTATEACTION.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_3BD display_location;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "display_location", &display_location, NULL)
        && !memcmp (&display_location, &blockrotateaction->display_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATEACTION.display_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "eed1071", &eed1071, NULL)
        && eed1071 == blockrotateaction->eed1071)
      pass ();
    else
      fail ("BLOCKROTATEACTION.eed1071 [BL] %u != %u", blockrotateaction->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "eed1071", &eed1071, 0)
        && eed1071 == blockrotateaction->eed1071)
      pass ();
    else
      fail ("BLOCKROTATEACTION.eed1071 [BL] set+1 %u != %u", blockrotateaction->eed1071, eed1071);
    blockrotateaction->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockrotateaction->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKROTATEACTION.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockrotateaction->name)
           : !blockrotateaction->name)
      pass ();
    else
      fail ("BLOCKROTATEACTION.name [T] '%s' <> '%s'", name, blockrotateaction->name);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "num_actions", &num_actions, NULL)
        && num_actions == blockrotateaction->num_actions)
      pass ();
    else
      fail ("BLOCKROTATEACTION.num_actions [BL] %u != %u", blockrotateaction->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "num_actions", &num_actions, 0)
        && num_actions == blockrotateaction->num_actions)
      pass ();
    else
      fail ("BLOCKROTATEACTION.num_actions [BL] set+1 %u != %u", blockrotateaction->num_actions, num_actions);
    blockrotateaction->num_actions--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "num_deps", &num_deps, NULL)
        && num_deps == blockrotateaction->num_deps)
      pass ();
    else
      fail ("BLOCKROTATEACTION.num_deps [BL] %u != %u", blockrotateaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "num_deps", &num_deps, 0)
        && num_deps == blockrotateaction->num_deps)
      pass ();
    else
      fail ("BLOCKROTATEACTION.num_deps [BL] set+1 %u != %u", blockrotateaction->num_deps, num_deps);
    blockrotateaction->num_deps--;
  }
  {
    BITCODE_3BD offset;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "offset", &offset, NULL)
        && !memcmp (&offset, &blockrotateaction->offset, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATEACTION.offset [3BD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &blockrotateaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKROTATEACTION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKROTATEACTION") || is_class_debugging ("BLOCKROTATEACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKROTATEACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKROTATIONGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKROTATIONGRIP *restrict blockrotationgrip = obj->tio.object->tio.BLOCKROTATIONGRIP;
  failed = 0;
  if (!obj_obj || !blockrotationgrip)
    {
      fail ("NULL BLOCKROTATIONGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "be_major", &be_major, NULL)
        && be_major == blockrotationgrip->be_major)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.be_major [BL] %u != %u", blockrotationgrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockrotationgrip, "BLOCKROTATIONGRIP", "be_major", &be_major, 0)
        && be_major == blockrotationgrip->be_major)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.be_major [BL] set+1 %u != %u", blockrotationgrip->be_major, be_major);
    blockrotationgrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blockrotationgrip->be_minor)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.be_minor [BL] %u != %u", blockrotationgrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockrotationgrip, "BLOCKROTATIONGRIP", "be_minor", &be_minor, 0)
        && be_minor == blockrotationgrip->be_minor)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.be_minor [BL] set+1 %u != %u", blockrotationgrip->be_minor, be_minor);
    blockrotationgrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blockrotationgrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.bg_bl91 [BL] %u != %u", blockrotationgrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blockrotationgrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.bg_bl91 [BL] set+1 %u != %u", blockrotationgrip->bg_bl91, bg_bl91);
    blockrotationgrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blockrotationgrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.bg_bl92 [BL] %u != %u", blockrotationgrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blockrotationgrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.bg_bl92 [BL] set+1 %u != %u", blockrotationgrip->bg_bl92, bg_bl92);
    blockrotationgrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blockrotationgrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blockrotationgrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blockrotationgrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blockrotationgrip->bg_insert_cycling, bg_insert_cycling);
    blockrotationgrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blockrotationgrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blockrotationgrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blockrotationgrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blockrotationgrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blockrotationgrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blockrotationgrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATIONGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blockrotationgrip->eed1071)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.eed1071 [BL] %u != %u", blockrotationgrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockrotationgrip, "BLOCKROTATIONGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blockrotationgrip->eed1071)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.eed1071 [BL] set+1 %u != %u", blockrotationgrip->eed1071, eed1071);
    blockrotationgrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockrotationgrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKROTATIONGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockrotationgrip->name)
           : !blockrotationgrip->name)
      pass ();
    else
      fail ("BLOCKROTATIONGRIP.name [T] '%s' <> '%s'", name, blockrotationgrip->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockrotationgrip, "BLOCKROTATIONGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blockrotationgrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKROTATIONGRIP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKROTATIONGRIP") || is_class_debugging ("BLOCKROTATIONGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKROTATIONGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKROTATIONPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKROTATIONPARAMETER *restrict blockrotationparameter = obj->tio.object->tio.BLOCKROTATIONPARAMETER;
  failed = 0;
  if (!obj_obj || !blockrotationparameter)
    {
      fail ("NULL BLOCKROTATIONPARAMETER");
      return 1;
    }
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle", &angle, NULL)
        && angle == blockrotationparameter->angle)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.angle [BD] %g != %g", blockrotationparameter->angle, angle);
    angle++;
    if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle", &angle, 0)
        && angle == blockrotationparameter->angle)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.angle [BD] set+1 %g != %g", blockrotationparameter->angle, angle);
    blockrotationparameter->angle--;
  }
  {
    BITCODE_T angle_desc;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle_desc", &angle_desc, NULL)
        && angle_desc
           ? strEQ ((char *)angle_desc, (char *)blockrotationparameter->angle_desc)
           : !blockrotationparameter->angle_desc)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.angle_desc [T] '%s' <> '%s'", angle_desc, blockrotationparameter->angle_desc);
  }
  {
    BITCODE_T angle_name;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle_name", &angle_name, NULL)
        && angle_name
           ? strEQ ((char *)angle_name, (char *)blockrotationparameter->angle_name)
           : !blockrotationparameter->angle_name)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.angle_name [T] '%s' <> '%s'", angle_name, blockrotationparameter->angle_name);
  }
  {
    Dwg_BLOCKPARAMVALUESET angle_value_set;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle_value_set", &angle_value_set, NULL)
        && !memcmp (&angle_value_set, &blockrotationparameter->angle_value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.angle_value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockrotationparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockrotationparameter->be_major)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.be_major [BL] %u != %u", blockrotationparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "be_major", &be_major, 0)
        && be_major == blockrotationparameter->be_major)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.be_major [BL] set+1 %u != %u", blockrotationparameter->be_major, be_major);
    blockrotationparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockrotationparameter->be_minor)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.be_minor [BL] %u != %u", blockrotationparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockrotationparameter->be_minor)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.be_minor [BL] set+1 %u != %u", blockrotationparameter->be_minor, be_minor);
    blockrotationparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockrotationparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockrotationparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockrotationparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockrotationparameter->chain_actions, chain_actions);
    blockrotationparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_base_angle_pt;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "def_base_angle_pt", &def_base_angle_pt, NULL)
        && !memcmp (&def_base_angle_pt, &blockrotationparameter->def_base_angle_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.def_base_angle_pt [3BD]");
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockrotationparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockrotationparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockrotationparameter->eed1071)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.eed1071 [BL] %u != %u", blockrotationparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockrotationparameter->eed1071)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.eed1071 [BL] set+1 %u != %u", blockrotationparameter->eed1071, eed1071);
    blockrotationparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockrotationparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockrotationparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockrotationparameter->name)
           : !blockrotationparameter->name)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.name [T] '%s' <> '%s'", name, blockrotationparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockrotationparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.parameter_base_location [BS] %hu != %hu", blockrotationparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockrotationparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockrotationparameter->parameter_base_location, parameter_base_location);
    blockrotationparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockrotationparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockrotationparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockrotationparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockrotationparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockrotationparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockrotationparameter->prop_states)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockrotationparameter->show_properties)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockrotationparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockrotationparameter->show_properties)
      pass ();
    else
      fail ("BLOCKROTATIONPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockrotationparameter->show_properties, show_properties);
    blockrotationparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockrotationparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockrotationparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKROTATIONPARAMETER.upd_endpt [3BD]");
  }
  if (failed && (is_class_unstable ("BLOCKROTATIONPARAMETER") || is_class_debugging ("BLOCKROTATIONPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKROTATIONPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKSCALEACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKSCALEACTION *restrict blockscaleaction = obj->tio.object->tio.BLOCKSCALEACTION;
  failed = 0;
  if (!obj_obj || !blockscaleaction)
    {
      fail ("NULL BLOCKSCALEACTION");
      return 1;
    }
  {
    BITCODE_BL* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "actions", &actions, NULL)
        && actions == blockscaleaction->actions)
      pass ();
    else
      fail ("BLOCKSCALEACTION.actions [BL*] * %u num_actions", count);
  }
  {
    BITCODE_3BD base_pt;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "base_pt", &base_pt, NULL)
        && !memcmp (&base_pt, &blockscaleaction->base_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKSCALEACTION.base_pt [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "be_major", &be_major, NULL)
        && be_major == blockscaleaction->be_major)
      pass ();
    else
      fail ("BLOCKSCALEACTION.be_major [BL] %u != %u", blockscaleaction->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "be_major", &be_major, 0)
        && be_major == blockscaleaction->be_major)
      pass ();
    else
      fail ("BLOCKSCALEACTION.be_major [BL] set+1 %u != %u", blockscaleaction->be_major, be_major);
    blockscaleaction->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "be_minor", &be_minor, NULL)
        && be_minor == blockscaleaction->be_minor)
      pass ();
    else
      fail ("BLOCKSCALEACTION.be_minor [BL] %u != %u", blockscaleaction->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "be_minor", &be_minor, 0)
        && be_minor == blockscaleaction->be_minor)
      pass ();
    else
      fail ("BLOCKSCALEACTION.be_minor [BL] set+1 %u != %u", blockscaleaction->be_minor, be_minor);
    blockscaleaction->be_minor--;
  }
  {
    Dwg_BLOCKACTION_connectionpts conn_pts;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "conn_pts[5]", &conn_pts, NULL)
        && !memcmp (&conn_pts, &blockscaleaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
        pass ();
    else
        fail ("BLOCKSCALEACTION.conn_pts[5] [Dwg_BLOCKACTION_connectionpts]");
  }
  {
    BITCODE_B dependent;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "dependent", &dependent, NULL)
        && dependent == blockscaleaction->dependent)
      pass ();
    else
      fail ("BLOCKSCALEACTION.dependent [B] " FORMAT_B " != " FORMAT_B "", blockscaleaction->dependent, dependent);
    dependent++;
    if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "dependent", &dependent, 0)
        && dependent == blockscaleaction->dependent)
      pass ();
    else
      fail ("BLOCKSCALEACTION.dependent [B] set+1 " FORMAT_B " != " FORMAT_B "", blockscaleaction->dependent, dependent);
    blockscaleaction->dependent--;
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "deps", &deps, NULL)
        && deps == blockscaleaction->deps)
      pass ();
    else
      fail ("BLOCKSCALEACTION.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_3BD display_location;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "display_location", &display_location, NULL)
        && !memcmp (&display_location, &blockscaleaction->display_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKSCALEACTION.display_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "eed1071", &eed1071, NULL)
        && eed1071 == blockscaleaction->eed1071)
      pass ();
    else
      fail ("BLOCKSCALEACTION.eed1071 [BL] %u != %u", blockscaleaction->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "eed1071", &eed1071, 0)
        && eed1071 == blockscaleaction->eed1071)
      pass ();
    else
      fail ("BLOCKSCALEACTION.eed1071 [BL] set+1 %u != %u", blockscaleaction->eed1071, eed1071);
    blockscaleaction->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockscaleaction->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKSCALEACTION.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockscaleaction->name)
           : !blockscaleaction->name)
      pass ();
    else
      fail ("BLOCKSCALEACTION.name [T] '%s' <> '%s'", name, blockscaleaction->name);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "num_actions", &num_actions, NULL)
        && num_actions == blockscaleaction->num_actions)
      pass ();
    else
      fail ("BLOCKSCALEACTION.num_actions [BL] %u != %u", blockscaleaction->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "num_actions", &num_actions, 0)
        && num_actions == blockscaleaction->num_actions)
      pass ();
    else
      fail ("BLOCKSCALEACTION.num_actions [BL] set+1 %u != %u", blockscaleaction->num_actions, num_actions);
    blockscaleaction->num_actions--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "num_deps", &num_deps, NULL)
        && num_deps == blockscaleaction->num_deps)
      pass ();
    else
      fail ("BLOCKSCALEACTION.num_deps [BL] %u != %u", blockscaleaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "num_deps", &num_deps, 0)
        && num_deps == blockscaleaction->num_deps)
      pass ();
    else
      fail ("BLOCKSCALEACTION.num_deps [BL] set+1 %u != %u", blockscaleaction->num_deps, num_deps);
    blockscaleaction->num_deps--;
  }
  {
    BITCODE_3BD offset;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "offset", &offset, NULL)
        && !memcmp (&offset, &blockscaleaction->offset, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKSCALEACTION.offset [3BD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &blockscaleaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKSCALEACTION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKSCALEACTION") || is_class_debugging ("BLOCKSCALEACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKSCALEACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKSTRETCHACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKSTRETCHACTION *restrict blockstretchaction = obj->tio.object->tio.BLOCKSTRETCHACTION;
  failed = 0;
  if (!obj_obj || !blockstretchaction)
    {
      fail ("NULL BLOCKSTRETCHACTION");
      return 1;
    }
  {
    BITCODE_BD action_offset_x;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "action_offset_x", &action_offset_x, NULL)
        && action_offset_x == blockstretchaction->action_offset_x)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.action_offset_x [BD] %g != %g", blockstretchaction->action_offset_x, action_offset_x);
    action_offset_x++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "action_offset_x", &action_offset_x, 0)
        && action_offset_x == blockstretchaction->action_offset_x)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.action_offset_x [BD] set+1 %g != %g", blockstretchaction->action_offset_x, action_offset_x);
    blockstretchaction->action_offset_x--;
  }
  {
    BITCODE_BD action_offset_y;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "action_offset_y", &action_offset_y, NULL)
        && action_offset_y == blockstretchaction->action_offset_y)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.action_offset_y [BD] %g != %g", blockstretchaction->action_offset_y, action_offset_y);
    action_offset_y++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "action_offset_y", &action_offset_y, 0)
        && action_offset_y == blockstretchaction->action_offset_y)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.action_offset_y [BD] set+1 %g != %g", blockstretchaction->action_offset_y, action_offset_y);
    blockstretchaction->action_offset_y--;
  }
  {
    BITCODE_BL* actions;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_actions", &count, NULL)
        && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "actions", &actions, NULL)
        && actions == blockstretchaction->actions)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.actions [BL*] * %u num_actions", count);
  }
  {
    BITCODE_BD angle_offset;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "angle_offset", &angle_offset, NULL)
        && angle_offset == blockstretchaction->angle_offset)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.angle_offset [BD] %g != %g", blockstretchaction->angle_offset, angle_offset);
    angle_offset++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "angle_offset", &angle_offset, 0)
        && angle_offset == blockstretchaction->angle_offset)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.angle_offset [BD] set+1 %g != %g", blockstretchaction->angle_offset, angle_offset);
    blockstretchaction->angle_offset--;
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "be_major", &be_major, NULL)
        && be_major == blockstretchaction->be_major)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.be_major [BL] %u != %u", blockstretchaction->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "be_major", &be_major, 0)
        && be_major == blockstretchaction->be_major)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.be_major [BL] set+1 %u != %u", blockstretchaction->be_major, be_major);
    blockstretchaction->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "be_minor", &be_minor, NULL)
        && be_minor == blockstretchaction->be_minor)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.be_minor [BL] %u != %u", blockstretchaction->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "be_minor", &be_minor, 0)
        && be_minor == blockstretchaction->be_minor)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.be_minor [BL] set+1 %u != %u", blockstretchaction->be_minor, be_minor);
    blockstretchaction->be_minor--;
  }
  {
    BITCODE_BL* codes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_codes", &count, NULL)
        && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "codes", &codes, NULL)
        && codes == blockstretchaction->codes)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.codes [BL*] * %u num_codes", count);
  }
  {
    Dwg_BLOCKACTION_connectionpts conn_pts;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "conn_pts[2]", &conn_pts, NULL)
        && !memcmp (&conn_pts, &blockstretchaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
        pass ();
    else
        fail ("BLOCKSTRETCHACTION.conn_pts[2] [Dwg_BLOCKACTION_connectionpts]");
  }
  {
    BITCODE_H* deps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_deps", &count, NULL)
        && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "deps", &deps, NULL)
        && deps == blockstretchaction->deps)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.deps [H*] * %u num_deps", count);
  }
  {
    BITCODE_3BD display_location;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "display_location", &display_location, NULL)
        && !memcmp (&display_location, &blockstretchaction->display_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKSTRETCHACTION.display_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "eed1071", &eed1071, NULL)
        && eed1071 == blockstretchaction->eed1071)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.eed1071 [BL] %u != %u", blockstretchaction->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "eed1071", &eed1071, 0)
        && eed1071 == blockstretchaction->eed1071)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.eed1071 [BL] set+1 %u != %u", blockstretchaction->eed1071, eed1071);
    blockstretchaction->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockstretchaction->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKSTRETCHACTION.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_H* hdls;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_hdls", &count, NULL)
        && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "hdls", &hdls, NULL)
        && hdls == blockstretchaction->hdls)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.hdls [H*] * %u num_hdls", count);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockstretchaction->name)
           : !blockstretchaction->name)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.name [T] '%s' <> '%s'", name, blockstretchaction->name);
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_actions", &num_actions, NULL)
        && num_actions == blockstretchaction->num_actions)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_actions [BL] %u != %u", blockstretchaction->num_actions, num_actions);
    num_actions++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_actions", &num_actions, 0)
        && num_actions == blockstretchaction->num_actions)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_actions [BL] set+1 %u != %u", blockstretchaction->num_actions, num_actions);
    blockstretchaction->num_actions--;
  }
  {
    BITCODE_BL num_codes;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_codes", &num_codes, NULL)
        && num_codes == blockstretchaction->num_codes)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_codes [BL] %u != %u", blockstretchaction->num_codes, num_codes);
    num_codes++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_codes", &num_codes, 0)
        && num_codes == blockstretchaction->num_codes)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_codes [BL] set+1 %u != %u", blockstretchaction->num_codes, num_codes);
    blockstretchaction->num_codes--;
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_deps", &num_deps, NULL)
        && num_deps == blockstretchaction->num_deps)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_deps [BL] %u != %u", blockstretchaction->num_deps, num_deps);
    num_deps++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_deps", &num_deps, 0)
        && num_deps == blockstretchaction->num_deps)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_deps [BL] set+1 %u != %u", blockstretchaction->num_deps, num_deps);
    blockstretchaction->num_deps--;
  }
  {
    BITCODE_BL num_hdls;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_hdls", &num_hdls, NULL)
        && num_hdls == blockstretchaction->num_hdls)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_hdls [BL] %u != %u", blockstretchaction->num_hdls, num_hdls);
    num_hdls++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_hdls", &num_hdls, 0)
        && num_hdls == blockstretchaction->num_hdls)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_hdls [BL] set+1 %u != %u", blockstretchaction->num_hdls, num_hdls);
    blockstretchaction->num_hdls--;
  }
  {
    BITCODE_BL num_pts;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_pts", &num_pts, NULL)
        && num_pts == blockstretchaction->num_pts)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_pts [BL] %u != %u", blockstretchaction->num_pts, num_pts);
    num_pts++;
    if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_pts", &num_pts, 0)
        && num_pts == blockstretchaction->num_pts)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.num_pts [BL] set+1 %u != %u", blockstretchaction->num_pts, num_pts);
    blockstretchaction->num_pts--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &blockstretchaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKSTRETCHACTION.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_2RD* pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_pts", &count, NULL)
        && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "pts", &pts, NULL)
        && pts == blockstretchaction->pts)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.pts [2RD*] * %u num_pts", count);
  }
  {
    BITCODE_BS* shorts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_shorts", &count, NULL)
        && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "shorts", &shorts, NULL)
        && shorts == blockstretchaction->shorts)
      pass ();
    else
      fail ("BLOCKSTRETCHACTION.shorts [BS*] * %u num_shorts", count);
  }
  if (failed && (is_class_unstable ("BLOCKSTRETCHACTION") || is_class_debugging ("BLOCKSTRETCHACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKSTRETCHACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKUSERPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKUSERPARAMETER *restrict blockuserparameter = obj->tio.object->tio.BLOCKUSERPARAMETER;
  failed = 0;
  if (!obj_obj || !blockuserparameter)
    {
      fail ("NULL BLOCKUSERPARAMETER");
      return 1;
    }
  {
    BITCODE_H assocvariable;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "assocvariable", &assocvariable, NULL)
        && !memcmp (&assocvariable, &blockuserparameter->assocvariable, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKUSERPARAMETER.assocvariable [H]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockuserparameter->be_major)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.be_major [BL] %u != %u", blockuserparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockuserparameter, "BLOCKUSERPARAMETER", "be_major", &be_major, 0)
        && be_major == blockuserparameter->be_major)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.be_major [BL] set+1 %u != %u", blockuserparameter->be_major, be_major);
    blockuserparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockuserparameter->be_minor)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.be_minor [BL] %u != %u", blockuserparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockuserparameter, "BLOCKUSERPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockuserparameter->be_minor)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.be_minor [BL] set+1 %u != %u", blockuserparameter->be_minor, be_minor);
    blockuserparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockuserparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockuserparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockuserparameter, "BLOCKUSERPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockuserparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockuserparameter->chain_actions, chain_actions);
    blockuserparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &blockuserparameter->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKUSERPARAMETER.def_pt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockuserparameter->eed1071)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.eed1071 [BL] %u != %u", blockuserparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockuserparameter, "BLOCKUSERPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockuserparameter->eed1071)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.eed1071 [BL] set+1 %u != %u", blockuserparameter->eed1071, eed1071);
    blockuserparameter->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockuserparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKUSERPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T expr;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "expr", &expr, NULL)
        && expr
           ? strEQ ((char *)expr, (char *)blockuserparameter->expr)
           : !blockuserparameter->expr)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.expr [T] '%s' <> '%s'", expr, blockuserparameter->expr);
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "flag", &flag, NULL)
        && flag == blockuserparameter->flag)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.flag [BS] %hu != %hu", blockuserparameter->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (blockuserparameter, "BLOCKUSERPARAMETER", "flag", &flag, 0)
        && flag == blockuserparameter->flag)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.flag [BS] set+1 %hu != %hu", blockuserparameter->flag, flag);
    blockuserparameter->flag--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockuserparameter->name)
           : !blockuserparameter->name)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.name [T] '%s' <> '%s'", name, blockuserparameter->name);
  }
  {
    BITCODE_BL num_propinfos;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "num_propinfos", &num_propinfos, NULL)
        && num_propinfos == blockuserparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.num_propinfos [BL] %u != %u", blockuserparameter->num_propinfos, num_propinfos);
    num_propinfos++;
    if (dwg_dynapi_entity_set_value (blockuserparameter, "BLOCKUSERPARAMETER", "num_propinfos", &num_propinfos, 0)
        && num_propinfos == blockuserparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.num_propinfos [BL] set+1 %u != %u", blockuserparameter->num_propinfos, num_propinfos);
    blockuserparameter->num_propinfos--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockuserparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKUSERPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockuserparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKUSERPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockuserparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKUSERPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockuserparameter->show_properties)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockuserparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockuserparameter, "BLOCKUSERPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockuserparameter->show_properties)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockuserparameter->show_properties, show_properties);
    blockuserparameter->show_properties--;
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "type", &type, NULL)
        && type == blockuserparameter->type)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.type [BS] %hu != %hu", blockuserparameter->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (blockuserparameter, "BLOCKUSERPARAMETER", "type", &type, 0)
        && type == blockuserparameter->type)
      pass ();
    else
      fail ("BLOCKUSERPARAMETER.type [BS] set+1 %hu != %hu", blockuserparameter->type, type);
    blockuserparameter->type--;
  }
  {
    Dwg_EvalVariant value;
    if (dwg_dynapi_entity_value (blockuserparameter, "BLOCKUSERPARAMETER", "value", &value, NULL)
        && !memcmp (&value, &blockuserparameter->value, sizeof (Dwg_EvalVariant)))
        pass ();
    else
        fail ("BLOCKUSERPARAMETER.value [Dwg_EvalVariant]");
  }
  if (failed && (is_class_unstable ("BLOCKUSERPARAMETER") || is_class_debugging ("BLOCKUSERPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKUSERPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKVERTICALCONSTRAINTPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKVERTICALCONSTRAINTPARAMETER *restrict blockverticalconstraintparameter = obj->tio.object->tio.BLOCKVERTICALCONSTRAINTPARAMETER;
  failed = 0;
  if (!obj_obj || !blockverticalconstraintparameter)
    {
      fail ("NULL BLOCKVERTICALCONSTRAINTPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockverticalconstraintparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockverticalconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.be_major [BL] %u != %u", blockverticalconstraintparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "be_major", &be_major, 0)
        && be_major == blockverticalconstraintparameter->be_major)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blockverticalconstraintparameter->be_major, be_major);
    blockverticalconstraintparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockverticalconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blockverticalconstraintparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockverticalconstraintparameter->be_minor)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blockverticalconstraintparameter->be_minor, be_minor);
    blockverticalconstraintparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockverticalconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockverticalconstraintparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockverticalconstraintparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockverticalconstraintparameter->chain_actions, chain_actions);
    blockverticalconstraintparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockverticalconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockverticalconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_H dependency;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
        && !memcmp (&dependency, &blockverticalconstraintparameter->dependency, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.dependency [H]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockverticalconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blockverticalconstraintparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockverticalconstraintparameter->eed1071)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockverticalconstraintparameter->eed1071, eed1071);
    blockverticalconstraintparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockverticalconstraintparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockverticalconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T expr_description;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
        && expr_description
           ? strEQ ((char *)expr_description, (char *)blockverticalconstraintparameter->expr_description)
           : !blockverticalconstraintparameter->expr_description)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blockverticalconstraintparameter->expr_description);
  }
  {
    BITCODE_T expr_name;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
        && expr_name
           ? strEQ ((char *)expr_name, (char *)blockverticalconstraintparameter->expr_name)
           : !blockverticalconstraintparameter->expr_name)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blockverticalconstraintparameter->expr_name);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockverticalconstraintparameter->name)
           : !blockverticalconstraintparameter->name)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blockverticalconstraintparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockverticalconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blockverticalconstraintparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockverticalconstraintparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockverticalconstraintparameter->parameter_base_location, parameter_base_location);
    blockverticalconstraintparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockverticalconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockverticalconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockverticalconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockverticalconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockverticalconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockverticalconstraintparameter->prop_states)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockverticalconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockverticalconstraintparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockverticalconstraintparameter->show_properties)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockverticalconstraintparameter->show_properties, show_properties);
    blockverticalconstraintparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockverticalconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockverticalconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.upd_endpt [3BD]");
  }
  {
    BITCODE_BD value;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "value", &value, NULL)
        && value == blockverticalconstraintparameter->value)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.value [BD] %g != %g", blockverticalconstraintparameter->value, value);
    value++;
    if (dwg_dynapi_entity_set_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "value", &value, 0)
        && value == blockverticalconstraintparameter->value)
      pass ();
    else
      fail ("BLOCKVERTICALCONSTRAINTPARAMETER.value [BD] set+1 %g != %g", blockverticalconstraintparameter->value, value);
    blockverticalconstraintparameter->value--;
  }
  {
    Dwg_BLOCKPARAMVALUESET value_set;
    if (dwg_dynapi_entity_value (blockverticalconstraintparameter, "BLOCKVERTICALCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
        && !memcmp (&value_set, &blockverticalconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKVERTICALCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKVERTICALCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKVERTICALCONSTRAINTPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKVERTICALCONSTRAINTPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKVISIBILITYGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKVISIBILITYGRIP *restrict blockvisibilitygrip = obj->tio.object->tio.BLOCKVISIBILITYGRIP;
  failed = 0;
  if (!obj_obj || !blockvisibilitygrip)
    {
      fail ("NULL BLOCKVISIBILITYGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "be_major", &be_major, NULL)
        && be_major == blockvisibilitygrip->be_major)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.be_major [BL] %u != %u", blockvisibilitygrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "be_major", &be_major, 0)
        && be_major == blockvisibilitygrip->be_major)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.be_major [BL] set+1 %u != %u", blockvisibilitygrip->be_major, be_major);
    blockvisibilitygrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blockvisibilitygrip->be_minor)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.be_minor [BL] %u != %u", blockvisibilitygrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "be_minor", &be_minor, 0)
        && be_minor == blockvisibilitygrip->be_minor)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.be_minor [BL] set+1 %u != %u", blockvisibilitygrip->be_minor, be_minor);
    blockvisibilitygrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blockvisibilitygrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.bg_bl91 [BL] %u != %u", blockvisibilitygrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blockvisibilitygrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.bg_bl91 [BL] set+1 %u != %u", blockvisibilitygrip->bg_bl91, bg_bl91);
    blockvisibilitygrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blockvisibilitygrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.bg_bl92 [BL] %u != %u", blockvisibilitygrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blockvisibilitygrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.bg_bl92 [BL] set+1 %u != %u", blockvisibilitygrip->bg_bl92, bg_bl92);
    blockvisibilitygrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blockvisibilitygrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blockvisibilitygrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blockvisibilitygrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blockvisibilitygrip->bg_insert_cycling, bg_insert_cycling);
    blockvisibilitygrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blockvisibilitygrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blockvisibilitygrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blockvisibilitygrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blockvisibilitygrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blockvisibilitygrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blockvisibilitygrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKVISIBILITYGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blockvisibilitygrip->eed1071)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.eed1071 [BL] %u != %u", blockvisibilitygrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blockvisibilitygrip->eed1071)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.eed1071 [BL] set+1 %u != %u", blockvisibilitygrip->eed1071, eed1071);
    blockvisibilitygrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockvisibilitygrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKVISIBILITYGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockvisibilitygrip->name)
           : !blockvisibilitygrip->name)
      pass ();
    else
      fail ("BLOCKVISIBILITYGRIP.name [T] '%s' <> '%s'", name, blockvisibilitygrip->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockvisibilitygrip, "BLOCKVISIBILITYGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blockvisibilitygrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKVISIBILITYGRIP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKVISIBILITYGRIP") || is_class_debugging ("BLOCKVISIBILITYGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKVISIBILITYGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKVISIBILITYPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKVISIBILITYPARAMETER *restrict blockvisibilityparameter = obj->tio.object->tio.BLOCKVISIBILITYPARAMETER;
  failed = 0;
  if (!obj_obj || !blockvisibilityparameter)
    {
      fail ("NULL BLOCKVISIBILITYPARAMETER");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockvisibilityparameter->be_major)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.be_major [BL] %u != %u", blockvisibilityparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "be_major", &be_major, 0)
        && be_major == blockvisibilityparameter->be_major)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.be_major [BL] set+1 %u != %u", blockvisibilityparameter->be_major, be_major);
    blockvisibilityparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockvisibilityparameter->be_minor)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.be_minor [BL] %u != %u", blockvisibilityparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockvisibilityparameter->be_minor)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.be_minor [BL] set+1 %u != %u", blockvisibilityparameter->be_minor, be_minor);
    blockvisibilityparameter->be_minor--;
  }
  {
    BITCODE_H* blocks;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "num_blocks", &count, NULL)
        && dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "blocks", &blocks, NULL)
        && blocks == blockvisibilityparameter->blocks)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.blocks [H*] * %u num_blocks", count);
  }
  {
    BITCODE_T blockvisi_desc;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "blockvisi_desc", &blockvisi_desc, NULL)
        && blockvisi_desc
           ? strEQ ((char *)blockvisi_desc, (char *)blockvisibilityparameter->blockvisi_desc)
           : !blockvisibilityparameter->blockvisi_desc)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.blockvisi_desc [T] '%s' <> '%s'", blockvisi_desc, blockvisibilityparameter->blockvisi_desc);
  }
  {
    BITCODE_T blockvisi_name;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "blockvisi_name", &blockvisi_name, NULL)
        && blockvisi_name
           ? strEQ ((char *)blockvisi_name, (char *)blockvisibilityparameter->blockvisi_name)
           : !blockvisibilityparameter->blockvisi_name)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.blockvisi_name [T] '%s' <> '%s'", blockvisi_name, blockvisibilityparameter->blockvisi_name);
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockvisibilityparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockvisibilityparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockvisibilityparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockvisibilityparameter->chain_actions, chain_actions);
    blockvisibilityparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &blockvisibilityparameter->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKVISIBILITYPARAMETER.def_pt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockvisibilityparameter->eed1071)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.eed1071 [BL] %u != %u", blockvisibilityparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockvisibilityparameter->eed1071)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.eed1071 [BL] set+1 %u != %u", blockvisibilityparameter->eed1071, eed1071);
    blockvisibilityparameter->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockvisibilityparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKVISIBILITYPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_B is_initialized;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "is_initialized", &is_initialized, NULL)
        && is_initialized == blockvisibilityparameter->is_initialized)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.is_initialized [B] " FORMAT_B " != " FORMAT_B "", blockvisibilityparameter->is_initialized, is_initialized);
    is_initialized++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "is_initialized", &is_initialized, 0)
        && is_initialized == blockvisibilityparameter->is_initialized)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.is_initialized [B] set+1 " FORMAT_B " != " FORMAT_B "", blockvisibilityparameter->is_initialized, is_initialized);
    blockvisibilityparameter->is_initialized--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockvisibilityparameter->name)
           : !blockvisibilityparameter->name)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.name [T] '%s' <> '%s'", name, blockvisibilityparameter->name);
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "num_blocks", &num_blocks, NULL)
        && num_blocks == blockvisibilityparameter->num_blocks)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.num_blocks [BL] %u != %u", blockvisibilityparameter->num_blocks, num_blocks);
    num_blocks++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "num_blocks", &num_blocks, 0)
        && num_blocks == blockvisibilityparameter->num_blocks)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.num_blocks [BL] set+1 %u != %u", blockvisibilityparameter->num_blocks, num_blocks);
    blockvisibilityparameter->num_blocks--;
  }
  {
    BITCODE_BL num_propinfos;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "num_propinfos", &num_propinfos, NULL)
        && num_propinfos == blockvisibilityparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.num_propinfos [BL] %u != %u", blockvisibilityparameter->num_propinfos, num_propinfos);
    num_propinfos++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "num_propinfos", &num_propinfos, 0)
        && num_propinfos == blockvisibilityparameter->num_propinfos)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.num_propinfos [BL] set+1 %u != %u", blockvisibilityparameter->num_propinfos, num_propinfos);
    blockvisibilityparameter->num_propinfos--;
  }
  {
    BITCODE_BL num_states;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "num_states", &num_states, NULL)
        && num_states == blockvisibilityparameter->num_states)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.num_states [BL] %u != %u", blockvisibilityparameter->num_states, num_states);
    num_states++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "num_states", &num_states, 0)
        && num_states == blockvisibilityparameter->num_states)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.num_states [BL] set+1 %u != %u", blockvisibilityparameter->num_states, num_states);
    blockvisibilityparameter->num_states--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockvisibilityparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKVISIBILITYPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockvisibilityparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKVISIBILITYPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockvisibilityparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKVISIBILITYPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockvisibilityparameter->show_properties)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockvisibilityparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockvisibilityparameter->show_properties)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockvisibilityparameter->show_properties, show_properties);
    blockvisibilityparameter->show_properties--;
  }
  {
    Dwg_BLOCKVISIBILITYPARAMETER_state* states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "num_states", &count, NULL)
        && dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "states", &states, NULL)
        && states == blockvisibilityparameter->states)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.states [Dwg_BLOCKVISIBILITYPARAMETER_state*] * %u num_states", count);
  }
  {
    BITCODE_B unknown_bool;
    if (dwg_dynapi_entity_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "unknown_bool", &unknown_bool, NULL)
        && unknown_bool == blockvisibilityparameter->unknown_bool)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.unknown_bool [B] " FORMAT_B " != " FORMAT_B "", blockvisibilityparameter->unknown_bool, unknown_bool);
    unknown_bool++;
    if (dwg_dynapi_entity_set_value (blockvisibilityparameter, "BLOCKVISIBILITYPARAMETER", "unknown_bool", &unknown_bool, 0)
        && unknown_bool == blockvisibilityparameter->unknown_bool)
      pass ();
    else
      fail ("BLOCKVISIBILITYPARAMETER.unknown_bool [B] set+1 " FORMAT_B " != " FORMAT_B "", blockvisibilityparameter->unknown_bool, unknown_bool);
    blockvisibilityparameter->unknown_bool--;
  }
  if (failed && (is_class_unstable ("BLOCKVISIBILITYPARAMETER") || is_class_debugging ("BLOCKVISIBILITYPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKVISIBILITYPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKXYGRIP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKXYGRIP *restrict blockxygrip = obj->tio.object->tio.BLOCKXYGRIP;
  failed = 0;
  if (!obj_obj || !blockxygrip)
    {
      fail ("NULL BLOCKXYGRIP");
      return 1;
    }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "be_major", &be_major, NULL)
        && be_major == blockxygrip->be_major)
      pass ();
    else
      fail ("BLOCKXYGRIP.be_major [BL] %u != %u", blockxygrip->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockxygrip, "BLOCKXYGRIP", "be_major", &be_major, 0)
        && be_major == blockxygrip->be_major)
      pass ();
    else
      fail ("BLOCKXYGRIP.be_major [BL] set+1 %u != %u", blockxygrip->be_major, be_major);
    blockxygrip->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "be_minor", &be_minor, NULL)
        && be_minor == blockxygrip->be_minor)
      pass ();
    else
      fail ("BLOCKXYGRIP.be_minor [BL] %u != %u", blockxygrip->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockxygrip, "BLOCKXYGRIP", "be_minor", &be_minor, 0)
        && be_minor == blockxygrip->be_minor)
      pass ();
    else
      fail ("BLOCKXYGRIP.be_minor [BL] set+1 %u != %u", blockxygrip->be_minor, be_minor);
    blockxygrip->be_minor--;
  }
  {
    BITCODE_BL bg_bl91;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "bg_bl91", &bg_bl91, NULL)
        && bg_bl91 == blockxygrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKXYGRIP.bg_bl91 [BL] %u != %u", blockxygrip->bg_bl91, bg_bl91);
    bg_bl91++;
    if (dwg_dynapi_entity_set_value (blockxygrip, "BLOCKXYGRIP", "bg_bl91", &bg_bl91, 0)
        && bg_bl91 == blockxygrip->bg_bl91)
      pass ();
    else
      fail ("BLOCKXYGRIP.bg_bl91 [BL] set+1 %u != %u", blockxygrip->bg_bl91, bg_bl91);
    blockxygrip->bg_bl91--;
  }
  {
    BITCODE_BL bg_bl92;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "bg_bl92", &bg_bl92, NULL)
        && bg_bl92 == blockxygrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKXYGRIP.bg_bl92 [BL] %u != %u", blockxygrip->bg_bl92, bg_bl92);
    bg_bl92++;
    if (dwg_dynapi_entity_set_value (blockxygrip, "BLOCKXYGRIP", "bg_bl92", &bg_bl92, 0)
        && bg_bl92 == blockxygrip->bg_bl92)
      pass ();
    else
      fail ("BLOCKXYGRIP.bg_bl92 [BL] set+1 %u != %u", blockxygrip->bg_bl92, bg_bl92);
    blockxygrip->bg_bl92--;
  }
  {
    BITCODE_B bg_insert_cycling;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "bg_insert_cycling", &bg_insert_cycling, NULL)
        && bg_insert_cycling == blockxygrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKXYGRIP.bg_insert_cycling [B] " FORMAT_B " != " FORMAT_B "", blockxygrip->bg_insert_cycling, bg_insert_cycling);
    bg_insert_cycling++;
    if (dwg_dynapi_entity_set_value (blockxygrip, "BLOCKXYGRIP", "bg_insert_cycling", &bg_insert_cycling, 0)
        && bg_insert_cycling == blockxygrip->bg_insert_cycling)
      pass ();
    else
      fail ("BLOCKXYGRIP.bg_insert_cycling [B] set+1 " FORMAT_B " != " FORMAT_B "", blockxygrip->bg_insert_cycling, bg_insert_cycling);
    blockxygrip->bg_insert_cycling--;
  }
  {
    BITCODE_BLd bg_insert_cycling_weight;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, NULL)
        && bg_insert_cycling_weight == blockxygrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKXYGRIP.bg_insert_cycling_weight [BLd] " FORMAT_BLd " != " FORMAT_BLd "", blockxygrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    if (dwg_dynapi_entity_set_value (blockxygrip, "BLOCKXYGRIP", "bg_insert_cycling_weight", &bg_insert_cycling_weight, 0)
        && bg_insert_cycling_weight == blockxygrip->bg_insert_cycling_weight)
      pass ();
    else
      fail ("BLOCKXYGRIP.bg_insert_cycling_weight [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", blockxygrip->bg_insert_cycling_weight, bg_insert_cycling_weight);
    blockxygrip->bg_insert_cycling_weight--;
  }
  {
    BITCODE_3BD bg_location;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "bg_location", &bg_location, NULL)
        && !memcmp (&bg_location, &blockxygrip->bg_location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKXYGRIP.bg_location [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "eed1071", &eed1071, NULL)
        && eed1071 == blockxygrip->eed1071)
      pass ();
    else
      fail ("BLOCKXYGRIP.eed1071 [BL] %u != %u", blockxygrip->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockxygrip, "BLOCKXYGRIP", "eed1071", &eed1071, 0)
        && eed1071 == blockxygrip->eed1071)
      pass ();
    else
      fail ("BLOCKXYGRIP.eed1071 [BL] set+1 %u != %u", blockxygrip->eed1071, eed1071);
    blockxygrip->eed1071--;
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockxygrip->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKXYGRIP.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockxygrip->name)
           : !blockxygrip->name)
      pass ();
    else
      fail ("BLOCKXYGRIP.name [T] '%s' <> '%s'", name, blockxygrip->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockxygrip, "BLOCKXYGRIP", "parent", &parent, NULL)
        && !memcmp (&parent, &blockxygrip->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKXYGRIP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCKXYGRIP") || is_class_debugging ("BLOCKXYGRIP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKXYGRIP", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCKXYPARAMETER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCKXYPARAMETER *restrict blockxyparameter = obj->tio.object->tio.BLOCKXYPARAMETER;
  failed = 0;
  if (!obj_obj || !blockxyparameter)
    {
      fail ("NULL BLOCKXYPARAMETER");
      return 1;
    }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "basept", &basept, NULL)
        && !memcmp (&basept, &blockxyparameter->basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.basept [3BD]");
  }
  {
    BITCODE_BL be_major;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "be_major", &be_major, NULL)
        && be_major == blockxyparameter->be_major)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.be_major [BL] %u != %u", blockxyparameter->be_major, be_major);
    be_major++;
    if (dwg_dynapi_entity_set_value (blockxyparameter, "BLOCKXYPARAMETER", "be_major", &be_major, 0)
        && be_major == blockxyparameter->be_major)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.be_major [BL] set+1 %u != %u", blockxyparameter->be_major, be_major);
    blockxyparameter->be_major--;
  }
  {
    BITCODE_BL be_minor;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "be_minor", &be_minor, NULL)
        && be_minor == blockxyparameter->be_minor)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.be_minor [BL] %u != %u", blockxyparameter->be_minor, be_minor);
    be_minor++;
    if (dwg_dynapi_entity_set_value (blockxyparameter, "BLOCKXYPARAMETER", "be_minor", &be_minor, 0)
        && be_minor == blockxyparameter->be_minor)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.be_minor [BL] set+1 %u != %u", blockxyparameter->be_minor, be_minor);
    blockxyparameter->be_minor--;
  }
  {
    BITCODE_B chain_actions;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "chain_actions", &chain_actions, NULL)
        && chain_actions == blockxyparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockxyparameter->chain_actions, chain_actions);
    chain_actions++;
    if (dwg_dynapi_entity_set_value (blockxyparameter, "BLOCKXYPARAMETER", "chain_actions", &chain_actions, 0)
        && chain_actions == blockxyparameter->chain_actions)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockxyparameter->chain_actions, chain_actions);
    blockxyparameter->chain_actions--;
  }
  {
    BITCODE_3BD def_basept;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "def_basept", &def_basept, NULL)
        && !memcmp (&def_basept, &blockxyparameter->def_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.def_basept [3BD]");
  }
  {
    BITCODE_3BD def_endpt;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "def_endpt", &def_endpt, NULL)
        && !memcmp (&def_endpt, &blockxyparameter->def_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.def_endpt [3BD]");
  }
  {
    BITCODE_BL eed1071;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "eed1071", &eed1071, NULL)
        && eed1071 == blockxyparameter->eed1071)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.eed1071 [BL] %u != %u", blockxyparameter->eed1071, eed1071);
    eed1071++;
    if (dwg_dynapi_entity_set_value (blockxyparameter, "BLOCKXYPARAMETER", "eed1071", &eed1071, 0)
        && eed1071 == blockxyparameter->eed1071)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.eed1071 [BL] set+1 %u != %u", blockxyparameter->eed1071, eed1071);
    blockxyparameter->eed1071--;
  }
  {
    BITCODE_3BD endpt;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "endpt", &endpt, NULL)
        && !memcmp (&endpt, &blockxyparameter->endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.endpt [3BD]");
  }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &blockxyparameter->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.evalexpr [Dwg_EvalExpr]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)blockxyparameter->name)
           : !blockxyparameter->name)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.name [T] '%s' <> '%s'", name, blockxyparameter->name);
  }
  {
    BITCODE_BS parameter_base_location;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
        && parameter_base_location == blockxyparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.parameter_base_location [BS] %hu != %hu", blockxyparameter->parameter_base_location, parameter_base_location);
    parameter_base_location++;
    if (dwg_dynapi_entity_set_value (blockxyparameter, "BLOCKXYPARAMETER", "parameter_base_location", &parameter_base_location, 0)
        && parameter_base_location == blockxyparameter->parameter_base_location)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockxyparameter->parameter_base_location, parameter_base_location);
    blockxyparameter->parameter_base_location--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "parent", &parent, NULL)
        && !memcmp (&parent, &blockxyparameter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop1;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "prop1", &prop1, NULL)
        && !memcmp (&prop1, &blockxyparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop2;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "prop2", &prop2, NULL)
        && !memcmp (&prop2, &blockxyparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop3;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "prop3", &prop3, NULL)
        && !memcmp (&prop3, &blockxyparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    Dwg_BLOCKPARAMETER_PropInfo prop4;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "prop4", &prop4, NULL)
        && !memcmp (&prop4, &blockxyparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
  }
  {
    BITCODE_BL* prop_states;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "num_prop_states", &count, NULL)
        && dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "prop_states", &prop_states, NULL)
        && prop_states == blockxyparameter->prop_states)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.prop_states [BL*] * %u num_prop_states", count);
  }
  {
    BITCODE_B show_properties;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "show_properties", &show_properties, NULL)
        && show_properties == blockxyparameter->show_properties)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockxyparameter->show_properties, show_properties);
    show_properties++;
    if (dwg_dynapi_entity_set_value (blockxyparameter, "BLOCKXYPARAMETER", "show_properties", &show_properties, 0)
        && show_properties == blockxyparameter->show_properties)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockxyparameter->show_properties, show_properties);
    blockxyparameter->show_properties--;
  }
  {
    BITCODE_3BD upd_basept;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "upd_basept", &upd_basept, NULL)
        && !memcmp (&upd_basept, &blockxyparameter->upd_basept, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.upd_basept [3BD]");
  }
  {
    BITCODE_3BD upd_endpt;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "upd_endpt", &upd_endpt, NULL)
        && !memcmp (&upd_endpt, &blockxyparameter->upd_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.upd_endpt [3BD]");
  }
  {
    BITCODE_T x_label;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "x_label", &x_label, NULL)
        && x_label
           ? strEQ ((char *)x_label, (char *)blockxyparameter->x_label)
           : !blockxyparameter->x_label)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.x_label [T] '%s' <> '%s'", x_label, blockxyparameter->x_label);
  }
  {
    BITCODE_T x_label_desc;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "x_label_desc", &x_label_desc, NULL)
        && x_label_desc
           ? strEQ ((char *)x_label_desc, (char *)blockxyparameter->x_label_desc)
           : !blockxyparameter->x_label_desc)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.x_label_desc [T] '%s' <> '%s'", x_label_desc, blockxyparameter->x_label_desc);
  }
  {
    BITCODE_BD x_value;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "x_value", &x_value, NULL)
        && x_value == blockxyparameter->x_value)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.x_value [BD] %g != %g", blockxyparameter->x_value, x_value);
    x_value++;
    if (dwg_dynapi_entity_set_value (blockxyparameter, "BLOCKXYPARAMETER", "x_value", &x_value, 0)
        && x_value == blockxyparameter->x_value)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.x_value [BD] set+1 %g != %g", blockxyparameter->x_value, x_value);
    blockxyparameter->x_value--;
  }
  {
    Dwg_BLOCKPARAMVALUESET x_value_set;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "x_value_set", &x_value_set, NULL)
        && !memcmp (&x_value_set, &blockxyparameter->x_value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.x_value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  {
    BITCODE_T y_label;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "y_label", &y_label, NULL)
        && y_label
           ? strEQ ((char *)y_label, (char *)blockxyparameter->y_label)
           : !blockxyparameter->y_label)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.y_label [T] '%s' <> '%s'", y_label, blockxyparameter->y_label);
  }
  {
    BITCODE_T y_label_desc;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "y_label_desc", &y_label_desc, NULL)
        && y_label_desc
           ? strEQ ((char *)y_label_desc, (char *)blockxyparameter->y_label_desc)
           : !blockxyparameter->y_label_desc)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.y_label_desc [T] '%s' <> '%s'", y_label_desc, blockxyparameter->y_label_desc);
  }
  {
    BITCODE_BD y_value;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "y_value", &y_value, NULL)
        && y_value == blockxyparameter->y_value)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.y_value [BD] %g != %g", blockxyparameter->y_value, y_value);
    y_value++;
    if (dwg_dynapi_entity_set_value (blockxyparameter, "BLOCKXYPARAMETER", "y_value", &y_value, 0)
        && y_value == blockxyparameter->y_value)
      pass ();
    else
      fail ("BLOCKXYPARAMETER.y_value [BD] set+1 %g != %g", blockxyparameter->y_value, y_value);
    blockxyparameter->y_value--;
  }
  {
    Dwg_BLOCKPARAMVALUESET y_value_set;
    if (dwg_dynapi_entity_value (blockxyparameter, "BLOCKXYPARAMETER", "y_value_set", &y_value_set, NULL)
        && !memcmp (&y_value_set, &blockxyparameter->y_value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
        pass ();
    else
        fail ("BLOCKXYPARAMETER.y_value_set [Dwg_BLOCKPARAMVALUESET]");
  }
  if (failed && (is_class_unstable ("BLOCKXYPARAMETER") || is_class_debugging ("BLOCKXYPARAMETER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCKXYPARAMETER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCK_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCK_CONTROL *restrict block_control = obj->tio.object->tio.BLOCK_CONTROL;
  failed = 0;
  if (!obj_obj || !block_control)
    {
      fail ("NULL BLOCK_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "entries", &entries, NULL)
        && entries == block_control->entries)
      pass ();
    else
      fail ("BLOCK_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == block_control->flags_r11)
      pass ();
    else
      fail ("BLOCK_CONTROL.flags_r11 [RS] %hu != %hu", block_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (block_control, "BLOCK_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == block_control->flags_r11)
      pass ();
    else
      fail ("BLOCK_CONTROL.flags_r11 [RS] set+1 %hu != %hu", block_control->flags_r11, flags_r11);
    block_control->flags_r11--;
  }
  {
    BITCODE_H model_space;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "model_space", &model_space, NULL)
        && !memcmp (&model_space, &block_control->model_space, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCK_CONTROL.model_space [H]");
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == block_control->num_entries)
      pass ();
    else
      fail ("BLOCK_CONTROL.num_entries [BS] %hu != %hu", block_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (block_control, "BLOCK_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == block_control->num_entries)
      pass ();
    else
      fail ("BLOCK_CONTROL.num_entries [BS] set+1 %hu != %hu", block_control->num_entries, num_entries);
    block_control->num_entries--;
  }
  {
    BITCODE_H paper_space;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "paper_space", &paper_space, NULL)
        && !memcmp (&paper_space, &block_control->paper_space, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCK_CONTROL.paper_space [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (block_control, "BLOCK_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &block_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCK_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BLOCK_CONTROL") || is_class_debugging ("BLOCK_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCK_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_BLOCK_HEADER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BLOCK_HEADER *restrict block_header = obj->tio.object->tio.BLOCK_HEADER;
  failed = 0;
  if (!obj_obj || !block_header)
    {
      fail ("NULL BLOCK_HEADER");
      return 1;
    }
  {
    BITCODE_BL __iterator;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "__iterator", &__iterator, NULL)
        && __iterator == block_header->__iterator)
      pass ();
    else
      fail ("BLOCK_HEADER.__iterator [BL] %u != %u", block_header->__iterator, __iterator);
    __iterator++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "__iterator", &__iterator, 0)
        && __iterator == block_header->__iterator)
      pass ();
    else
      fail ("BLOCK_HEADER.__iterator [BL] set+1 %u != %u", block_header->__iterator, __iterator);
    block_header->__iterator--;
  }
  {
    BITCODE_B anonymous;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "anonymous", &anonymous, NULL)
        && anonymous == block_header->anonymous)
      pass ();
    else
      fail ("BLOCK_HEADER.anonymous [B] " FORMAT_B " != " FORMAT_B "", block_header->anonymous, anonymous);
    anonymous++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "anonymous", &anonymous, 0)
        && anonymous == block_header->anonymous)
      pass ();
    else
      fail ("BLOCK_HEADER.anonymous [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->anonymous, anonymous);
    block_header->anonymous--;
  }
  {
    BITCODE_3DPOINT base_pt;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "base_pt", &base_pt, NULL)
        && !memcmp (&base_pt, &block_header->base_pt, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("BLOCK_HEADER.base_pt [3DPOINT]");
  }
  {
    BITCODE_B blkisxref;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "blkisxref", &blkisxref, NULL)
        && blkisxref == block_header->blkisxref)
      pass ();
    else
      fail ("BLOCK_HEADER.blkisxref [B] " FORMAT_B " != " FORMAT_B "", block_header->blkisxref, blkisxref);
    blkisxref++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "blkisxref", &blkisxref, 0)
        && blkisxref == block_header->blkisxref)
      pass ();
    else
      fail ("BLOCK_HEADER.blkisxref [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->blkisxref, blkisxref);
    block_header->blkisxref--;
  }
  {
    BITCODE_H block_entity;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "block_entity", &block_entity, NULL)
        && !memcmp (&block_entity, &block_header->block_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCK_HEADER.block_entity [H]");
  }
  {
    BITCODE_RL block_offset_r11;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "block_offset_r11", &block_offset_r11, NULL)
        && block_offset_r11 == block_header->block_offset_r11)
      pass ();
    else
      fail ("BLOCK_HEADER.block_offset_r11 [RL] %u != %u", block_header->block_offset_r11, block_offset_r11);
    block_offset_r11++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "block_offset_r11", &block_offset_r11, 0)
        && block_offset_r11 == block_header->block_offset_r11)
      pass ();
    else
      fail ("BLOCK_HEADER.block_offset_r11 [RL] set+1 %u != %u", block_header->block_offset_r11, block_offset_r11);
    block_header->block_offset_r11--;
  }
  {
    BITCODE_RC block_scaling;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "block_scaling", &block_scaling, NULL)
        && block_scaling == block_header->block_scaling)
      pass ();
    else
      fail ("BLOCK_HEADER.block_scaling [RC] %u != %u", block_header->block_scaling, block_scaling);
    block_scaling++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "block_scaling", &block_scaling, 0)
        && block_scaling == block_header->block_scaling)
      pass ();
    else
      fail ("BLOCK_HEADER.block_scaling [RC] set+1 %u != %u", block_header->block_scaling, block_scaling);
    block_header->block_scaling--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)block_header->description)
           : !block_header->description)
      pass ();
    else
      fail ("BLOCK_HEADER.description [T] '%s' <> '%s'", description, block_header->description);
  }
  {
    BITCODE_H endblk_entity;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "endblk_entity", &endblk_entity, NULL)
        && !memcmp (&endblk_entity, &block_header->endblk_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCK_HEADER.endblk_entity [H]");
  }
  {
    BITCODE_H* entities;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "num_owned", &count, NULL)
        && dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "entities", &entities, NULL)
        && entities == block_header->entities)
      pass ();
    else
      fail ("BLOCK_HEADER.entities [H*] * %u num_owned", count);
  }
  {
    BITCODE_B explodable;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "explodable", &explodable, NULL)
        && explodable == block_header->explodable)
      pass ();
    else
      fail ("BLOCK_HEADER.explodable [B] " FORMAT_B " != " FORMAT_B "", block_header->explodable, explodable);
    explodable++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "explodable", &explodable, 0)
        && explodable == block_header->explodable)
      pass ();
    else
      fail ("BLOCK_HEADER.explodable [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->explodable, explodable);
    block_header->explodable--;
  }
  {
    BITCODE_H first_entity;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "first_entity", &first_entity, NULL)
        && !memcmp (&first_entity, &block_header->first_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCK_HEADER.first_entity [H]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "flag", &flag, NULL)
        && flag == block_header->flag)
      pass ();
    else
      fail ("BLOCK_HEADER.flag [RC] %u != %u", block_header->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "flag", &flag, 0)
        && flag == block_header->flag)
      pass ();
    else
      fail ("BLOCK_HEADER.flag [RC] set+1 %u != %u", block_header->flag, flag);
    block_header->flag--;
  }
  {
    BITCODE_RS flag2;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "flag2", &flag2, NULL)
        && flag2 == block_header->flag2)
      pass ();
    else
      fail ("BLOCK_HEADER.flag2 [RS] %hu != %hu", block_header->flag2, flag2);
    flag2++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "flag2", &flag2, 0)
        && flag2 == block_header->flag2)
      pass ();
    else
      fail ("BLOCK_HEADER.flag2 [RS] set+1 %hu != %hu", block_header->flag2, flag2);
    block_header->flag2--;
  }
  {
    BITCODE_B hasattrs;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "hasattrs", &hasattrs, NULL)
        && hasattrs == block_header->hasattrs)
      pass ();
    else
      fail ("BLOCK_HEADER.hasattrs [B] " FORMAT_B " != " FORMAT_B "", block_header->hasattrs, hasattrs);
    hasattrs++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "hasattrs", &hasattrs, 0)
        && hasattrs == block_header->hasattrs)
      pass ();
    else
      fail ("BLOCK_HEADER.hasattrs [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->hasattrs, hasattrs);
    block_header->hasattrs--;
  }
  {
    BITCODE_BS insert_units;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "insert_units", &insert_units, NULL)
        && insert_units == block_header->insert_units)
      pass ();
    else
      fail ("BLOCK_HEADER.insert_units [BS] %hu != %hu", block_header->insert_units, insert_units);
    insert_units++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "insert_units", &insert_units, 0)
        && insert_units == block_header->insert_units)
      pass ();
    else
      fail ("BLOCK_HEADER.insert_units [BS] set+1 %hu != %hu", block_header->insert_units, insert_units);
    block_header->insert_units--;
  }
  {
    BITCODE_H* inserts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "num_inserts", &count, NULL)
        && dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "inserts", &inserts, NULL)
        && inserts == block_header->inserts)
      pass ();
    else
      fail ("BLOCK_HEADER.inserts [H*] * %u num_inserts", count);
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == block_header->is_xref_dep)
      pass ();
    else
      fail ("BLOCK_HEADER.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", block_header->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == block_header->is_xref_dep)
      pass ();
    else
      fail ("BLOCK_HEADER.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->is_xref_dep, is_xref_dep);
    block_header->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == block_header->is_xref_ref)
      pass ();
    else
      fail ("BLOCK_HEADER.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", block_header->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == block_header->is_xref_ref)
      pass ();
    else
      fail ("BLOCK_HEADER.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->is_xref_ref, is_xref_ref);
    block_header->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == block_header->is_xref_resolved)
      pass ();
    else
      fail ("BLOCK_HEADER.is_xref_resolved [BS] %hu != %hu", block_header->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == block_header->is_xref_resolved)
      pass ();
    else
      fail ("BLOCK_HEADER.is_xref_resolved [BS] set+1 %hu != %hu", block_header->is_xref_resolved, is_xref_resolved);
    block_header->is_xref_resolved--;
  }
  {
    BITCODE_H last_entity;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "last_entity", &last_entity, NULL)
        && !memcmp (&last_entity, &block_header->last_entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCK_HEADER.last_entity [H]");
  }
  {
    BITCODE_H layout;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "layout", &layout, NULL)
        && !memcmp (&layout, &block_header->layout, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCK_HEADER.layout [H]");
  }
  {
    BITCODE_B loaded_bit;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "loaded_bit", &loaded_bit, NULL)
        && loaded_bit == block_header->loaded_bit)
      pass ();
    else
      fail ("BLOCK_HEADER.loaded_bit [B] " FORMAT_B " != " FORMAT_B "", block_header->loaded_bit, loaded_bit);
    loaded_bit++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "loaded_bit", &loaded_bit, 0)
        && loaded_bit == block_header->loaded_bit)
      pass ();
    else
      fail ("BLOCK_HEADER.loaded_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->loaded_bit, loaded_bit);
    block_header->loaded_bit--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)block_header->name)
           : !block_header->name)
      pass ();
    else
      fail ("BLOCK_HEADER.name [TV] '%s' <> '%s'", name, block_header->name);
  }
  {
    BITCODE_RL num_inserts;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "num_inserts", &num_inserts, NULL)
        && num_inserts == block_header->num_inserts)
      pass ();
    else
      fail ("BLOCK_HEADER.num_inserts [RL] %u != %u", block_header->num_inserts, num_inserts);
    num_inserts++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "num_inserts", &num_inserts, 0)
        && num_inserts == block_header->num_inserts)
      pass ();
    else
      fail ("BLOCK_HEADER.num_inserts [RL] set+1 %u != %u", block_header->num_inserts, num_inserts);
    block_header->num_inserts--;
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "num_owned", &num_owned, NULL)
        && num_owned == block_header->num_owned)
      pass ();
    else
      fail ("BLOCK_HEADER.num_owned [BL] %u != %u", block_header->num_owned, num_owned);
    num_owned++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "num_owned", &num_owned, 0)
        && num_owned == block_header->num_owned)
      pass ();
    else
      fail ("BLOCK_HEADER.num_owned [BL] set+1 %u != %u", block_header->num_owned, num_owned);
    block_header->num_owned--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "parent", &parent, NULL)
        && !memcmp (&parent, &block_header->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BLOCK_HEADER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_TF preview;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "preview", &preview, NULL)
        && !memcmp (&preview, &block_header->preview, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("BLOCK_HEADER.preview [TF]");
  }
  {
    BITCODE_BL preview_size;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "preview_size", &preview_size, NULL)
        && preview_size == block_header->preview_size)
      pass ();
    else
      fail ("BLOCK_HEADER.preview_size [BL] %u != %u", block_header->preview_size, preview_size);
    preview_size++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "preview_size", &preview_size, 0)
        && preview_size == block_header->preview_size)
      pass ();
    else
      fail ("BLOCK_HEADER.preview_size [BL] set+1 %u != %u", block_header->preview_size, preview_size);
    block_header->preview_size--;
  }
  {
    BITCODE_RC unknown_r11;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "unknown_r11", &unknown_r11, NULL)
        && unknown_r11 == block_header->unknown_r11)
      pass ();
    else
      fail ("BLOCK_HEADER.unknown_r11 [RC] %u != %u", block_header->unknown_r11, unknown_r11);
    unknown_r11++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "unknown_r11", &unknown_r11, 0)
        && unknown_r11 == block_header->unknown_r11)
      pass ();
    else
      fail ("BLOCK_HEADER.unknown_r11 [RC] set+1 %u != %u", block_header->unknown_r11, unknown_r11);
    block_header->unknown_r11--;
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "used", &used, NULL)
        && used == block_header->used)
      pass ();
    else
      fail ("BLOCK_HEADER.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", block_header->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "used", &used, 0)
        && used == block_header->used)
      pass ();
    else
      fail ("BLOCK_HEADER.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", block_header->used, used);
    block_header->used--;
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "xref", &xref, NULL)
        && !memcmp (&xref, &block_header->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BLOCK_HEADER.xref [H]");
  }
  {
    BITCODE_T xref_pname;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "xref_pname", &xref_pname, NULL)
        && xref_pname
           ? strEQ ((char *)xref_pname, (char *)block_header->xref_pname)
           : !block_header->xref_pname)
      pass ();
    else
      fail ("BLOCK_HEADER.xref_pname [T] '%s' <> '%s'", xref_pname, block_header->xref_pname);
  }
  {
    BITCODE_B xrefoverlaid;
    if (dwg_dynapi_entity_value (block_header, "BLOCK_HEADER", "xrefoverlaid", &xrefoverlaid, NULL)
        && xrefoverlaid == block_header->xrefoverlaid)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefoverlaid [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefoverlaid, xrefoverlaid);
    xrefoverlaid++;
    if (dwg_dynapi_entity_set_value (block_header, "BLOCK_HEADER", "xrefoverlaid", &xrefoverlaid, 0)
        && xrefoverlaid == block_header->xrefoverlaid)
      pass ();
    else
      fail ("BLOCK_HEADER.xrefoverlaid [B] set+1 " FORMAT_B " != " FORMAT_B "", block_header->xrefoverlaid, xrefoverlaid);
    block_header->xrefoverlaid--;
  }
  if (failed && (is_class_unstable ("BLOCK_HEADER") || is_class_debugging ("BLOCK_HEADER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BLOCK_HEADER", failed);
      failed = 0;
    }
  return failed;
}
static int test_BREAKDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BREAKDATA *restrict breakdata = obj->tio.object->tio.BREAKDATA;
  failed = 0;
  if (!obj_obj || !breakdata)
    {
      fail ("NULL BREAKDATA");
      return 1;
    }
  {
    BITCODE_H dimref;
    if (dwg_dynapi_entity_value (breakdata, "BREAKDATA", "dimref", &dimref, NULL)
        && !memcmp (&dimref, &breakdata->dimref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("BREAKDATA.dimref [H]");
  }
  {
    BITCODE_BL num_pointrefs;
    if (dwg_dynapi_entity_value (breakdata, "BREAKDATA", "num_pointrefs", &num_pointrefs, NULL)
        && num_pointrefs == breakdata->num_pointrefs)
      pass ();
    else
      fail ("BREAKDATA.num_pointrefs [BL] %u != %u", breakdata->num_pointrefs, num_pointrefs);
    num_pointrefs++;
    if (dwg_dynapi_entity_set_value (breakdata, "BREAKDATA", "num_pointrefs", &num_pointrefs, 0)
        && num_pointrefs == breakdata->num_pointrefs)
      pass ();
    else
      fail ("BREAKDATA.num_pointrefs [BL] set+1 %u != %u", breakdata->num_pointrefs, num_pointrefs);
    breakdata->num_pointrefs--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (breakdata, "BREAKDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &breakdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BREAKDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H* pointrefs;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (breakdata, "BREAKDATA", "num_pointrefs", &count, NULL)
        && dwg_dynapi_entity_value (breakdata, "BREAKDATA", "pointrefs", &pointrefs, NULL)
        && pointrefs == breakdata->pointrefs)
      pass ();
    else
      fail ("BREAKDATA.pointrefs [H*] * %u num_pointrefs", count);
  }
  if (failed && (is_class_unstable ("BREAKDATA") || is_class_debugging ("BREAKDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BREAKDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_BREAKPOINTREF (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_BREAKPOINTREF *restrict breakpointref = obj->tio.object->tio.BREAKPOINTREF;
  failed = 0;
  if (!obj_obj || !breakpointref)
    {
      fail ("NULL BREAKPOINTREF");
      return 1;
    }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (breakpointref, "BREAKPOINTREF", "parent", &parent, NULL)
        && !memcmp (&parent, &breakpointref->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("BREAKPOINTREF.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("BREAKPOINTREF") || is_class_debugging ("BREAKPOINTREF")))
    {
      ok ("%s failed %d tests (TODO unstable)", "BREAKPOINTREF", failed);
      failed = 0;
    }
  return failed;
}
static int test_CELLSTYLEMAP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_CELLSTYLEMAP *restrict cellstylemap = obj->tio.object->tio.CELLSTYLEMAP;
  failed = 0;
  if (!obj_obj || !cellstylemap)
    {
      fail ("NULL CELLSTYLEMAP");
      return 1;
    }
  {
    Dwg_TABLESTYLE_CellStyle* cells;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (cellstylemap, "CELLSTYLEMAP", "num_cells", &count, NULL)
        && dwg_dynapi_entity_value (cellstylemap, "CELLSTYLEMAP", "cells", &cells, NULL)
        && cells == cellstylemap->cells)
      pass ();
    else
      fail ("CELLSTYLEMAP.cells [Dwg_TABLESTYLE_CellStyle*] * %u num_cells", count);
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value (cellstylemap, "CELLSTYLEMAP", "num_cells", &num_cells, NULL)
        && num_cells == cellstylemap->num_cells)
      pass ();
    else
      fail ("CELLSTYLEMAP.num_cells [BL] %u != %u", cellstylemap->num_cells, num_cells);
    num_cells++;
    if (dwg_dynapi_entity_set_value (cellstylemap, "CELLSTYLEMAP", "num_cells", &num_cells, 0)
        && num_cells == cellstylemap->num_cells)
      pass ();
    else
      fail ("CELLSTYLEMAP.num_cells [BL] set+1 %u != %u", cellstylemap->num_cells, num_cells);
    cellstylemap->num_cells--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (cellstylemap, "CELLSTYLEMAP", "parent", &parent, NULL)
        && !memcmp (&parent, &cellstylemap->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("CELLSTYLEMAP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("CELLSTYLEMAP") || is_class_debugging ("CELLSTYLEMAP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CELLSTYLEMAP", failed);
      failed = 0;
    }
  return failed;
}
static int test_CONTEXTDATAMANAGER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_CONTEXTDATAMANAGER *restrict contextdatamanager = obj->tio.object->tio.CONTEXTDATAMANAGER;
  failed = 0;
  if (!obj_obj || !contextdatamanager)
    {
      fail ("NULL CONTEXTDATAMANAGER");
      return 1;
    }
  {
    BITCODE_BL num_submgrs;
    if (dwg_dynapi_entity_value (contextdatamanager, "CONTEXTDATAMANAGER", "num_submgrs", &num_submgrs, NULL)
        && num_submgrs == contextdatamanager->num_submgrs)
      pass ();
    else
      fail ("CONTEXTDATAMANAGER.num_submgrs [BL] %u != %u", contextdatamanager->num_submgrs, num_submgrs);
    num_submgrs++;
    if (dwg_dynapi_entity_set_value (contextdatamanager, "CONTEXTDATAMANAGER", "num_submgrs", &num_submgrs, 0)
        && num_submgrs == contextdatamanager->num_submgrs)
      pass ();
    else
      fail ("CONTEXTDATAMANAGER.num_submgrs [BL] set+1 %u != %u", contextdatamanager->num_submgrs, num_submgrs);
    contextdatamanager->num_submgrs--;
  }
  {
    BITCODE_H objectcontext;
    if (dwg_dynapi_entity_value (contextdatamanager, "CONTEXTDATAMANAGER", "objectcontext", &objectcontext, NULL)
        && !memcmp (&objectcontext, &contextdatamanager->objectcontext, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("CONTEXTDATAMANAGER.objectcontext [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (contextdatamanager, "CONTEXTDATAMANAGER", "parent", &parent, NULL)
        && !memcmp (&parent, &contextdatamanager->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("CONTEXTDATAMANAGER.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_CONTEXTDATA_submgr* submgrs;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (contextdatamanager, "CONTEXTDATAMANAGER", "num_submgrs", &count, NULL)
        && dwg_dynapi_entity_value (contextdatamanager, "CONTEXTDATAMANAGER", "submgrs", &submgrs, NULL)
        && submgrs == contextdatamanager->submgrs)
      pass ();
    else
      fail ("CONTEXTDATAMANAGER.submgrs [Dwg_CONTEXTDATA_submgr*] * %u num_submgrs", count);
  }
  if (failed && (is_class_unstable ("CONTEXTDATAMANAGER") || is_class_debugging ("CONTEXTDATAMANAGER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CONTEXTDATAMANAGER", failed);
      failed = 0;
    }
  return failed;
}
static int test_CSACDOCUMENTOPTIONS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_CSACDOCUMENTOPTIONS *restrict csacdocumentoptions = obj->tio.object->tio.CSACDOCUMENTOPTIONS;
  failed = 0;
  if (!obj_obj || !csacdocumentoptions)
    {
      fail ("NULL CSACDOCUMENTOPTIONS");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (csacdocumentoptions, "CSACDOCUMENTOPTIONS", "class_version", &class_version, NULL)
        && class_version == csacdocumentoptions->class_version)
      pass ();
    else
      fail ("CSACDOCUMENTOPTIONS.class_version [BS] %hu != %hu", csacdocumentoptions->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (csacdocumentoptions, "CSACDOCUMENTOPTIONS", "class_version", &class_version, 0)
        && class_version == csacdocumentoptions->class_version)
      pass ();
    else
      fail ("CSACDOCUMENTOPTIONS.class_version [BS] set+1 %hu != %hu", csacdocumentoptions->class_version, class_version);
    csacdocumentoptions->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (csacdocumentoptions, "CSACDOCUMENTOPTIONS", "parent", &parent, NULL)
        && !memcmp (&parent, &csacdocumentoptions->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("CSACDOCUMENTOPTIONS.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("CSACDOCUMENTOPTIONS") || is_class_debugging ("CSACDOCUMENTOPTIONS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CSACDOCUMENTOPTIONS", failed);
      failed = 0;
    }
  return failed;
}
static int test_CURVEPATH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_CURVEPATH *restrict curvepath = obj->tio.object->tio.CURVEPATH;
  failed = 0;
  if (!obj_obj || !curvepath)
    {
      fail ("NULL CURVEPATH");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (curvepath, "CURVEPATH", "class_version", &class_version, NULL)
        && class_version == curvepath->class_version)
      pass ();
    else
      fail ("CURVEPATH.class_version [BS] %hu != %hu", curvepath->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (curvepath, "CURVEPATH", "class_version", &class_version, 0)
        && class_version == curvepath->class_version)
      pass ();
    else
      fail ("CURVEPATH.class_version [BS] set+1 %hu != %hu", curvepath->class_version, class_version);
    curvepath->class_version--;
  }
  {
    BITCODE_H entity;
    if (dwg_dynapi_entity_value (curvepath, "CURVEPATH", "entity", &entity, NULL)
        && !memcmp (&entity, &curvepath->entity, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("CURVEPATH.entity [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (curvepath, "CURVEPATH", "parent", &parent, NULL)
        && !memcmp (&parent, &curvepath->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("CURVEPATH.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("CURVEPATH") || is_class_debugging ("CURVEPATH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "CURVEPATH", failed);
      failed = 0;
    }
  return failed;
}
static int test_DATALINK (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DATALINK *restrict datalink = obj->tio.object->tio.DATALINK;
  failed = 0;
  if (!obj_obj || !datalink)
    {
      fail ("NULL DATALINK");
      return 1;
    }
  {
    BITCODE_BL bl92;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "bl92", &bl92, NULL)
        && bl92 == datalink->bl92)
      pass ();
    else
      fail ("DATALINK.bl92 [BL] %u != %u", datalink->bl92, bl92);
    bl92++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "bl92", &bl92, 0)
        && bl92 == datalink->bl92)
      pass ();
    else
      fail ("DATALINK.bl92 [BL] set+1 %u != %u", datalink->bl92, bl92);
    datalink->bl92--;
  }
  {
    BITCODE_BL bl93;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "bl93", &bl93, NULL)
        && bl93 == datalink->bl93)
      pass ();
    else
      fail ("DATALINK.bl93 [BL] %u != %u", datalink->bl93, bl93);
    bl93++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "bl93", &bl93, 0)
        && bl93 == datalink->bl93)
      pass ();
    else
      fail ("DATALINK.bl93 [BL] set+1 %u != %u", datalink->bl93, bl93);
    datalink->bl93--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "class_version", &class_version, NULL)
        && class_version == datalink->class_version)
      pass ();
    else
      fail ("DATALINK.class_version [BS] %hu != %hu", datalink->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "class_version", &class_version, 0)
        && class_version == datalink->class_version)
      pass ();
    else
      fail ("DATALINK.class_version [BS] set+1 %hu != %hu", datalink->class_version, class_version);
    datalink->class_version--;
  }
  {
    BITCODE_T connection_string;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "connection_string", &connection_string, NULL)
        && connection_string
           ? strEQ ((char *)connection_string, (char *)datalink->connection_string)
           : !datalink->connection_string)
      pass ();
    else
      fail ("DATALINK.connection_string [T] '%s' <> '%s'", connection_string, datalink->connection_string);
  }
  {
    Dwg_DATALINK_customdata* customdata;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "num_customdata", &count, NULL)
        && dwg_dynapi_entity_value (datalink, "DATALINK", "customdata", &customdata, NULL)
        && customdata == datalink->customdata)
      pass ();
    else
      fail ("DATALINK.customdata [Dwg_DATALINK_customdata*] * %u num_customdata", count);
  }
  {
    BITCODE_T data_adapter;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "data_adapter", &data_adapter, NULL)
        && data_adapter
           ? strEQ ((char *)data_adapter, (char *)datalink->data_adapter)
           : !datalink->data_adapter)
      pass ();
    else
      fail ("DATALINK.data_adapter [T] '%s' <> '%s'", data_adapter, datalink->data_adapter);
  }
  {
    BITCODE_BS day;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "day", &day, NULL)
        && day == datalink->day)
      pass ();
    else
      fail ("DATALINK.day [BS] %hu != %hu", datalink->day, day);
    day++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "day", &day, 0)
        && day == datalink->day)
      pass ();
    else
      fail ("DATALINK.day [BS] set+1 %hu != %hu", datalink->day, day);
    datalink->day--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)datalink->description)
           : !datalink->description)
      pass ();
    else
      fail ("DATALINK.description [T] '%s' <> '%s'", description, datalink->description);
  }
  {
    BITCODE_H hardowner;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "hardowner", &hardowner, NULL)
        && !memcmp (&hardowner, &datalink->hardowner, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DATALINK.hardowner [H]");
  }
  {
    BITCODE_BS hour;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "hour", &hour, NULL)
        && hour == datalink->hour)
      pass ();
    else
      fail ("DATALINK.hour [BS] %hu != %hu", datalink->hour, hour);
    hour++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "hour", &hour, 0)
        && hour == datalink->hour)
      pass ();
    else
      fail ("DATALINK.hour [BS] set+1 %hu != %hu", datalink->hour, hour);
    datalink->hour--;
  }
  {
    BITCODE_BS minute;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "minute", &minute, NULL)
        && minute == datalink->minute)
      pass ();
    else
      fail ("DATALINK.minute [BS] %hu != %hu", datalink->minute, minute);
    minute++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "minute", &minute, 0)
        && minute == datalink->minute)
      pass ();
    else
      fail ("DATALINK.minute [BS] set+1 %hu != %hu", datalink->minute, minute);
    datalink->minute--;
  }
  {
    BITCODE_BS month;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "month", &month, NULL)
        && month == datalink->month)
      pass ();
    else
      fail ("DATALINK.month [BS] %hu != %hu", datalink->month, month);
    month++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "month", &month, 0)
        && month == datalink->month)
      pass ();
    else
      fail ("DATALINK.month [BS] set+1 %hu != %hu", datalink->month, month);
    datalink->month--;
  }
  {
    BITCODE_BS msec;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "msec", &msec, NULL)
        && msec == datalink->msec)
      pass ();
    else
      fail ("DATALINK.msec [BS] %hu != %hu", datalink->msec, msec);
    msec++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "msec", &msec, 0)
        && msec == datalink->msec)
      pass ();
    else
      fail ("DATALINK.msec [BS] set+1 %hu != %hu", datalink->msec, msec);
    datalink->msec--;
  }
  {
    BITCODE_BL num_customdata;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "num_customdata", &num_customdata, NULL)
        && num_customdata == datalink->num_customdata)
      pass ();
    else
      fail ("DATALINK.num_customdata [BL] %u != %u", datalink->num_customdata, num_customdata);
    num_customdata++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "num_customdata", &num_customdata, 0)
        && num_customdata == datalink->num_customdata)
      pass ();
    else
      fail ("DATALINK.num_customdata [BL] set+1 %u != %u", datalink->num_customdata, num_customdata);
    datalink->num_customdata--;
  }
  {
    BITCODE_BL option;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "option", &option, NULL)
        && option == datalink->option)
      pass ();
    else
      fail ("DATALINK.option [BL] %u != %u", datalink->option, option);
    option++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "option", &option, 0)
        && option == datalink->option)
      pass ();
    else
      fail ("DATALINK.option [BL] set+1 %u != %u", datalink->option, option);
    datalink->option--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "parent", &parent, NULL)
        && !memcmp (&parent, &datalink->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DATALINK.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS path_option;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "path_option", &path_option, NULL)
        && path_option == datalink->path_option)
      pass ();
    else
      fail ("DATALINK.path_option [BS] %hu != %hu", datalink->path_option, path_option);
    path_option++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "path_option", &path_option, 0)
        && path_option == datalink->path_option)
      pass ();
    else
      fail ("DATALINK.path_option [BS] set+1 %hu != %hu", datalink->path_option, path_option);
    datalink->path_option--;
  }
  {
    BITCODE_BS seconds;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "seconds", &seconds, NULL)
        && seconds == datalink->seconds)
      pass ();
    else
      fail ("DATALINK.seconds [BS] %hu != %hu", datalink->seconds, seconds);
    seconds++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "seconds", &seconds, 0)
        && seconds == datalink->seconds)
      pass ();
    else
      fail ("DATALINK.seconds [BS] set+1 %hu != %hu", datalink->seconds, seconds);
    datalink->seconds--;
  }
  {
    BITCODE_T tooltip;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "tooltip", &tooltip, NULL)
        && tooltip
           ? strEQ ((char *)tooltip, (char *)datalink->tooltip)
           : !datalink->tooltip)
      pass ();
    else
      fail ("DATALINK.tooltip [T] '%s' <> '%s'", tooltip, datalink->tooltip);
  }
  {
    BITCODE_BL update_option;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "update_option", &update_option, NULL)
        && update_option == datalink->update_option)
      pass ();
    else
      fail ("DATALINK.update_option [BL] %u != %u", datalink->update_option, update_option);
    update_option++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "update_option", &update_option, 0)
        && update_option == datalink->update_option)
      pass ();
    else
      fail ("DATALINK.update_option [BL] set+1 %u != %u", datalink->update_option, update_option);
    datalink->update_option--;
  }
  {
    BITCODE_T update_status;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "update_status", &update_status, NULL)
        && update_status
           ? strEQ ((char *)update_status, (char *)datalink->update_status)
           : !datalink->update_status)
      pass ();
    else
      fail ("DATALINK.update_status [T] '%s' <> '%s'", update_status, datalink->update_status);
  }
  {
    BITCODE_BS year;
    if (dwg_dynapi_entity_value (datalink, "DATALINK", "year", &year, NULL)
        && year == datalink->year)
      pass ();
    else
      fail ("DATALINK.year [BS] %hu != %hu", datalink->year, year);
    year++;
    if (dwg_dynapi_entity_set_value (datalink, "DATALINK", "year", &year, 0)
        && year == datalink->year)
      pass ();
    else
      fail ("DATALINK.year [BS] set+1 %hu != %hu", datalink->year, year);
    datalink->year--;
  }
  if (failed && (is_class_unstable ("DATALINK") || is_class_debugging ("DATALINK")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DATALINK", failed);
      failed = 0;
    }
  return failed;
}
static int test_DATATABLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DATATABLE *restrict datatable = obj->tio.object->tio.DATATABLE;
  failed = 0;
  if (!obj_obj || !datatable)
    {
      fail ("NULL DATATABLE");
      return 1;
    }
  {
    Dwg_DATATABLE_column* cols;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (datatable, "DATATABLE", "num_cols", &count, NULL)
        && dwg_dynapi_entity_value (datatable, "DATATABLE", "cols", &cols, NULL)
        && cols == datatable->cols)
      pass ();
    else
      fail ("DATATABLE.cols [Dwg_DATATABLE_column*] * %u num_cols", count);
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value (datatable, "DATATABLE", "flags", &flags, NULL)
        && flags == datatable->flags)
      pass ();
    else
      fail ("DATATABLE.flags [BS] %hu != %hu", datatable->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (datatable, "DATATABLE", "flags", &flags, 0)
        && flags == datatable->flags)
      pass ();
    else
      fail ("DATATABLE.flags [BS] set+1 %hu != %hu", datatable->flags, flags);
    datatable->flags--;
  }
  {
    BITCODE_BL num_cols;
    if (dwg_dynapi_entity_value (datatable, "DATATABLE", "num_cols", &num_cols, NULL)
        && num_cols == datatable->num_cols)
      pass ();
    else
      fail ("DATATABLE.num_cols [BL] %u != %u", datatable->num_cols, num_cols);
    num_cols++;
    if (dwg_dynapi_entity_set_value (datatable, "DATATABLE", "num_cols", &num_cols, 0)
        && num_cols == datatable->num_cols)
      pass ();
    else
      fail ("DATATABLE.num_cols [BL] set+1 %u != %u", datatable->num_cols, num_cols);
    datatable->num_cols--;
  }
  {
    BITCODE_BL num_rows;
    if (dwg_dynapi_entity_value (datatable, "DATATABLE", "num_rows", &num_rows, NULL)
        && num_rows == datatable->num_rows)
      pass ();
    else
      fail ("DATATABLE.num_rows [BL] %u != %u", datatable->num_rows, num_rows);
    num_rows++;
    if (dwg_dynapi_entity_set_value (datatable, "DATATABLE", "num_rows", &num_rows, 0)
        && num_rows == datatable->num_rows)
      pass ();
    else
      fail ("DATATABLE.num_rows [BL] set+1 %u != %u", datatable->num_rows, num_rows);
    datatable->num_rows--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (datatable, "DATATABLE", "parent", &parent, NULL)
        && !memcmp (&parent, &datatable->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DATATABLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T table_name;
    if (dwg_dynapi_entity_value (datatable, "DATATABLE", "table_name", &table_name, NULL)
        && table_name
           ? strEQ ((char *)table_name, (char *)datatable->table_name)
           : !datatable->table_name)
      pass ();
    else
      fail ("DATATABLE.table_name [T] '%s' <> '%s'", table_name, datatable->table_name);
  }
  if (failed && (is_class_unstable ("DATATABLE") || is_class_debugging ("DATATABLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DATATABLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DBCOLOR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DBCOLOR *restrict dbcolor = obj->tio.object->tio.DBCOLOR;
  failed = 0;
  if (!obj_obj || !dbcolor)
    {
      fail ("NULL DBCOLOR");
      return 1;
    }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "color", &color, NULL)
        && !memcmp (&color, &dbcolor->color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DBCOLOR.color [CMC]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dbcolor, "DBCOLOR", "parent", &parent, NULL)
        && !memcmp (&parent, &dbcolor->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DBCOLOR.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DBCOLOR") || is_class_debugging ("DBCOLOR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DBCOLOR", failed);
      failed = 0;
    }
  return failed;
}
static int test_DETAILVIEWSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DETAILVIEWSTYLE *restrict detailviewstyle = obj->tio.object->tio.DETAILVIEWSTYLE;
  failed = 0;
  if (!obj_obj || !detailviewstyle)
    {
      fail ("NULL DETAILVIEWSTYLE");
      return 1;
    }
  {
    BITCODE_H arrow_symbol;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "arrow_symbol", &arrow_symbol, NULL)
        && !memcmp (&arrow_symbol, &detailviewstyle->arrow_symbol, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.arrow_symbol [H]");
  }
  {
    BITCODE_CMC arrow_symbol_color;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "arrow_symbol_color", &arrow_symbol_color, NULL)
        && !memcmp (&arrow_symbol_color, &detailviewstyle->arrow_symbol_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.arrow_symbol_color [CMC]");
  }
  {
    BITCODE_BD arrow_symbol_size;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "arrow_symbol_size", &arrow_symbol_size, NULL)
        && arrow_symbol_size == detailviewstyle->arrow_symbol_size)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.arrow_symbol_size [BD] %g != %g", detailviewstyle->arrow_symbol_size, arrow_symbol_size);
    arrow_symbol_size++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "arrow_symbol_size", &arrow_symbol_size, 0)
        && arrow_symbol_size == detailviewstyle->arrow_symbol_size)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.arrow_symbol_size [BD] set+1 %g != %g", detailviewstyle->arrow_symbol_size, arrow_symbol_size);
    detailviewstyle->arrow_symbol_size--;
  }
  {
    BITCODE_CMC borderline_color;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "borderline_color", &borderline_color, NULL)
        && !memcmp (&borderline_color, &detailviewstyle->borderline_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.borderline_color [CMC]");
  }
  {
    BITCODE_BLd borderline_linewt;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "borderline_linewt", &borderline_linewt, NULL)
        && borderline_linewt == detailviewstyle->borderline_linewt)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.borderline_linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", detailviewstyle->borderline_linewt, borderline_linewt);
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "borderline_linewt", &borderline_linewt, 0)
        && borderline_linewt == detailviewstyle->borderline_linewt)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.borderline_linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", detailviewstyle->borderline_linewt, borderline_linewt);
    detailviewstyle->borderline_linewt--;
  }
  {
    BITCODE_H borderline_ltype;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "borderline_ltype", &borderline_ltype, NULL)
        && !memcmp (&borderline_ltype, &detailviewstyle->borderline_ltype, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.borderline_ltype [H]");
  }
  {
    BITCODE_CMC boundary_line_color;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "boundary_line_color", &boundary_line_color, NULL)
        && !memcmp (&boundary_line_color, &detailviewstyle->boundary_line_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.boundary_line_color [CMC]");
  }
  {
    BITCODE_BLd boundary_linewt;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "boundary_linewt", &boundary_linewt, NULL)
        && boundary_linewt == detailviewstyle->boundary_linewt)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.boundary_linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", detailviewstyle->boundary_linewt, boundary_linewt);
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "boundary_linewt", &boundary_linewt, 0)
        && boundary_linewt == detailviewstyle->boundary_linewt)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.boundary_linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", detailviewstyle->boundary_linewt, boundary_linewt);
    detailviewstyle->boundary_linewt--;
  }
  {
    BITCODE_H boundary_ltype;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "boundary_ltype", &boundary_ltype, NULL)
        && !memcmp (&boundary_ltype, &detailviewstyle->boundary_ltype, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.boundary_ltype [H]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "class_version", &class_version, NULL)
        && class_version == detailviewstyle->class_version)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.class_version [BS] %hu != %hu", detailviewstyle->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "class_version", &class_version, 0)
        && class_version == detailviewstyle->class_version)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.class_version [BS] set+1 %hu != %hu", detailviewstyle->class_version, class_version);
    detailviewstyle->class_version--;
  }
  {
    BITCODE_CMC connection_line_color;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "connection_line_color", &connection_line_color, NULL)
        && !memcmp (&connection_line_color, &detailviewstyle->connection_line_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.connection_line_color [CMC]");
  }
  {
    BITCODE_BLd connection_linewt;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "connection_linewt", &connection_linewt, NULL)
        && connection_linewt == detailviewstyle->connection_linewt)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.connection_linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", detailviewstyle->connection_linewt, connection_linewt);
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "connection_linewt", &connection_linewt, 0)
        && connection_linewt == detailviewstyle->connection_linewt)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.connection_linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", detailviewstyle->connection_linewt, connection_linewt);
    detailviewstyle->connection_linewt--;
  }
  {
    BITCODE_H connection_ltype;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "connection_ltype", &connection_ltype, NULL)
        && !memcmp (&connection_ltype, &detailviewstyle->connection_ltype, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.connection_ltype [H]");
  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "desc", &desc, NULL)
        && desc
           ? strEQ ((char *)desc, (char *)detailviewstyle->desc)
           : !detailviewstyle->desc)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.desc [T] '%s' <> '%s'", desc, detailviewstyle->desc);
  }
  {
    BITCODE_T display_name;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "display_name", &display_name, NULL)
        && display_name
           ? strEQ ((char *)display_name, (char *)detailviewstyle->display_name)
           : !detailviewstyle->display_name)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.display_name [T] '%s' <> '%s'", display_name, detailviewstyle->display_name);
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "flags", &flags, NULL)
        && flags == detailviewstyle->flags)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.flags [BL] %u != %u", detailviewstyle->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "flags", &flags, 0)
        && flags == detailviewstyle->flags)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.flags [BL] set+1 %u != %u", detailviewstyle->flags, flags);
    detailviewstyle->flags--;
  }
  {
    BITCODE_CMC identifier_color;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_color", &identifier_color, NULL)
        && !memcmp (&identifier_color, &detailviewstyle->identifier_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.identifier_color [CMC]");
  }
  {
    BITCODE_T identifier_exclude_characters;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_exclude_characters", &identifier_exclude_characters, NULL)
        && identifier_exclude_characters
           ? strEQ ((char *)identifier_exclude_characters, (char *)detailviewstyle->identifier_exclude_characters)
           : !detailviewstyle->identifier_exclude_characters)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.identifier_exclude_characters [T] '%s' <> '%s'", identifier_exclude_characters, detailviewstyle->identifier_exclude_characters);
  }
  {
    BITCODE_BD identifier_height;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_height", &identifier_height, NULL)
        && identifier_height == detailviewstyle->identifier_height)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.identifier_height [BD] %g != %g", detailviewstyle->identifier_height, identifier_height);
    identifier_height++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_height", &identifier_height, 0)
        && identifier_height == detailviewstyle->identifier_height)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.identifier_height [BD] set+1 %g != %g", detailviewstyle->identifier_height, identifier_height);
    detailviewstyle->identifier_height--;
  }
  {
    BITCODE_BD identifier_offset;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_offset", &identifier_offset, NULL)
        && identifier_offset == detailviewstyle->identifier_offset)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.identifier_offset [BD] %g != %g", detailviewstyle->identifier_offset, identifier_offset);
    identifier_offset++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_offset", &identifier_offset, 0)
        && identifier_offset == detailviewstyle->identifier_offset)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.identifier_offset [BD] set+1 %g != %g", detailviewstyle->identifier_offset, identifier_offset);
    detailviewstyle->identifier_offset--;
  }
  {
    BITCODE_RC identifier_placement;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_placement", &identifier_placement, NULL)
        && identifier_placement == detailviewstyle->identifier_placement)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.identifier_placement [RC] %u != %u", detailviewstyle->identifier_placement, identifier_placement);
    identifier_placement++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_placement", &identifier_placement, 0)
        && identifier_placement == detailviewstyle->identifier_placement)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.identifier_placement [RC] set+1 %u != %u", detailviewstyle->identifier_placement, identifier_placement);
    detailviewstyle->identifier_placement--;
  }
  {
    BITCODE_H identifier_style;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "identifier_style", &identifier_style, NULL)
        && !memcmp (&identifier_style, &detailviewstyle->identifier_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.identifier_style [H]");
  }
  {
    BITCODE_B is_modified_for_recompute;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "is_modified_for_recompute", &is_modified_for_recompute, NULL)
        && is_modified_for_recompute == detailviewstyle->is_modified_for_recompute)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.is_modified_for_recompute [B] " FORMAT_B " != " FORMAT_B "", detailviewstyle->is_modified_for_recompute, is_modified_for_recompute);
    is_modified_for_recompute++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "is_modified_for_recompute", &is_modified_for_recompute, 0)
        && is_modified_for_recompute == detailviewstyle->is_modified_for_recompute)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.is_modified_for_recompute [B] set+1 " FORMAT_B " != " FORMAT_B "", detailviewstyle->is_modified_for_recompute, is_modified_for_recompute);
    detailviewstyle->is_modified_for_recompute--;
  }
  {
    BITCODE_BS mdoc_class_version;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "mdoc_class_version", &mdoc_class_version, NULL)
        && mdoc_class_version == detailviewstyle->mdoc_class_version)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.mdoc_class_version [BS] %hu != %hu", detailviewstyle->mdoc_class_version, mdoc_class_version);
    mdoc_class_version++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "mdoc_class_version", &mdoc_class_version, 0)
        && mdoc_class_version == detailviewstyle->mdoc_class_version)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.mdoc_class_version [BS] set+1 %hu != %hu", detailviewstyle->mdoc_class_version, mdoc_class_version);
    detailviewstyle->mdoc_class_version--;
  }
  {
    BITCODE_RC model_edge;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "model_edge", &model_edge, NULL)
        && model_edge == detailviewstyle->model_edge)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.model_edge [RC] %u != %u", detailviewstyle->model_edge, model_edge);
    model_edge++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "model_edge", &model_edge, 0)
        && model_edge == detailviewstyle->model_edge)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.model_edge [RC] set+1 %u != %u", detailviewstyle->model_edge, model_edge);
    detailviewstyle->model_edge--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &detailviewstyle->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL viewlabel_alignment;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_alignment", &viewlabel_alignment, NULL)
        && viewlabel_alignment == detailviewstyle->viewlabel_alignment)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_alignment [BL] %u != %u", detailviewstyle->viewlabel_alignment, viewlabel_alignment);
    viewlabel_alignment++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_alignment", &viewlabel_alignment, 0)
        && viewlabel_alignment == detailviewstyle->viewlabel_alignment)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_alignment [BL] set+1 %u != %u", detailviewstyle->viewlabel_alignment, viewlabel_alignment);
    detailviewstyle->viewlabel_alignment--;
  }
  {
    BITCODE_BL viewlabel_attachment;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_attachment", &viewlabel_attachment, NULL)
        && viewlabel_attachment == detailviewstyle->viewlabel_attachment)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_attachment [BL] %u != %u", detailviewstyle->viewlabel_attachment, viewlabel_attachment);
    viewlabel_attachment++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_attachment", &viewlabel_attachment, 0)
        && viewlabel_attachment == detailviewstyle->viewlabel_attachment)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_attachment [BL] set+1 %u != %u", detailviewstyle->viewlabel_attachment, viewlabel_attachment);
    detailviewstyle->viewlabel_attachment--;
  }
  {
    BITCODE_BD viewlabel_offset;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_offset", &viewlabel_offset, NULL)
        && viewlabel_offset == detailviewstyle->viewlabel_offset)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_offset [BD] %g != %g", detailviewstyle->viewlabel_offset, viewlabel_offset);
    viewlabel_offset++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_offset", &viewlabel_offset, 0)
        && viewlabel_offset == detailviewstyle->viewlabel_offset)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_offset [BD] set+1 %g != %g", detailviewstyle->viewlabel_offset, viewlabel_offset);
    detailviewstyle->viewlabel_offset--;
  }
  {
    BITCODE_T viewlabel_pattern;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_pattern", &viewlabel_pattern, NULL)
        && viewlabel_pattern
           ? strEQ ((char *)viewlabel_pattern, (char *)detailviewstyle->viewlabel_pattern)
           : !detailviewstyle->viewlabel_pattern)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_pattern [T] '%s' <> '%s'", viewlabel_pattern, detailviewstyle->viewlabel_pattern);
  }
  {
    BITCODE_CMC viewlabel_text_color;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_text_color", &viewlabel_text_color, NULL)
        && !memcmp (&viewlabel_text_color, &detailviewstyle->viewlabel_text_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.viewlabel_text_color [CMC]");
  }
  {
    BITCODE_BD viewlabel_text_height;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_text_height", &viewlabel_text_height, NULL)
        && viewlabel_text_height == detailviewstyle->viewlabel_text_height)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_text_height [BD] %g != %g", detailviewstyle->viewlabel_text_height, viewlabel_text_height);
    viewlabel_text_height++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_text_height", &viewlabel_text_height, 0)
        && viewlabel_text_height == detailviewstyle->viewlabel_text_height)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewlabel_text_height [BD] set+1 %g != %g", detailviewstyle->viewlabel_text_height, viewlabel_text_height);
    detailviewstyle->viewlabel_text_height--;
  }
  {
    BITCODE_H viewlabel_text_style;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "viewlabel_text_style", &viewlabel_text_style, NULL)
        && !memcmp (&viewlabel_text_style, &detailviewstyle->viewlabel_text_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DETAILVIEWSTYLE.viewlabel_text_style [H]");
  }
  {
    BITCODE_BL viewstyle_flags;
    if (dwg_dynapi_entity_value (detailviewstyle, "DETAILVIEWSTYLE", "viewstyle_flags", &viewstyle_flags, NULL)
        && viewstyle_flags == detailviewstyle->viewstyle_flags)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewstyle_flags [BL] %u != %u", detailviewstyle->viewstyle_flags, viewstyle_flags);
    viewstyle_flags++;
    if (dwg_dynapi_entity_set_value (detailviewstyle, "DETAILVIEWSTYLE", "viewstyle_flags", &viewstyle_flags, 0)
        && viewstyle_flags == detailviewstyle->viewstyle_flags)
      pass ();
    else
      fail ("DETAILVIEWSTYLE.viewstyle_flags [BL] set+1 %u != %u", detailviewstyle->viewstyle_flags, viewstyle_flags);
    detailviewstyle->viewstyle_flags--;
  }
  if (failed && (is_class_unstable ("DETAILVIEWSTYLE") || is_class_debugging ("DETAILVIEWSTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DETAILVIEWSTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DICTIONARY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DICTIONARY *restrict dictionary = obj->tio.object->tio.DICTIONARY;
  failed = 0;
  if (!obj_obj || !dictionary)
    {
      fail ("NULL DICTIONARY");
      return 1;
    }
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "cloning", &cloning, NULL)
        && cloning == dictionary->cloning)
      pass ();
    else
      fail ("DICTIONARY.cloning [BS] %hu != %hu", dictionary->cloning, cloning);
    cloning++;
    if (dwg_dynapi_entity_set_value (dictionary, "DICTIONARY", "cloning", &cloning, 0)
        && cloning == dictionary->cloning)
      pass ();
    else
      fail ("DICTIONARY.cloning [BS] set+1 %hu != %hu", dictionary->cloning, cloning);
    dictionary->cloning--;
  }
  {
    BITCODE_RC is_hardowner;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "is_hardowner", &is_hardowner, NULL)
        && is_hardowner == dictionary->is_hardowner)
      pass ();
    else
      fail ("DICTIONARY.is_hardowner [RC] %u != %u", dictionary->is_hardowner, is_hardowner);
    is_hardowner++;
    if (dwg_dynapi_entity_set_value (dictionary, "DICTIONARY", "is_hardowner", &is_hardowner, 0)
        && is_hardowner == dictionary->is_hardowner)
      pass ();
    else
      fail ("DICTIONARY.is_hardowner [RC] set+1 %u != %u", dictionary->is_hardowner, is_hardowner);
    dictionary->is_hardowner--;
  }
  {
    BITCODE_H* itemhandles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "numitems", &count, NULL)
        && dwg_dynapi_entity_value (dictionary, "DICTIONARY", "itemhandles", &itemhandles, NULL)
        && itemhandles == dictionary->itemhandles)
      pass ();
    else
      fail ("DICTIONARY.itemhandles [H*] * %u numitems", count);
  }
  {
    BITCODE_BL numitems;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "numitems", &numitems, NULL)
        && numitems == dictionary->numitems)
      pass ();
    else
      fail ("DICTIONARY.numitems [BL] %u != %u", dictionary->numitems, numitems);
    numitems++;
    if (dwg_dynapi_entity_set_value (dictionary, "DICTIONARY", "numitems", &numitems, 0)
        && numitems == dictionary->numitems)
      pass ();
    else
      fail ("DICTIONARY.numitems [BL] set+1 %u != %u", dictionary->numitems, numitems);
    dictionary->numitems--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "parent", &parent, NULL)
        && !memcmp (&parent, &dictionary->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DICTIONARY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T* texts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dictionary, "DICTIONARY", "numitems", &count, NULL)
        && dwg_dynapi_entity_value (dictionary, "DICTIONARY", "texts", &texts, NULL)
        && texts == dictionary->texts)
      pass ();
    else
      fail ("DICTIONARY.texts [T*] * %u numitems", count);
  }
  if (failed && (is_class_unstable ("DICTIONARY") || is_class_debugging ("DICTIONARY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DICTIONARY", failed);
      failed = 0;
    }
  return failed;
}
static int test_DICTIONARYVAR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DICTIONARYVAR *restrict dictionaryvar = obj->tio.object->tio.DICTIONARYVAR;
  failed = 0;
  if (!obj_obj || !dictionaryvar)
    {
      fail ("NULL DICTIONARYVAR");
      return 1;
    }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dictionaryvar, "DICTIONARYVAR", "parent", &parent, NULL)
        && !memcmp (&parent, &dictionaryvar->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DICTIONARYVAR.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RC schema;
    if (dwg_dynapi_entity_value (dictionaryvar, "DICTIONARYVAR", "schema", &schema, NULL)
        && schema == dictionaryvar->schema)
      pass ();
    else
      fail ("DICTIONARYVAR.schema [RC] %u != %u", dictionaryvar->schema, schema);
    schema++;
    if (dwg_dynapi_entity_set_value (dictionaryvar, "DICTIONARYVAR", "schema", &schema, 0)
        && schema == dictionaryvar->schema)
      pass ();
    else
      fail ("DICTIONARYVAR.schema [RC] set+1 %u != %u", dictionaryvar->schema, schema);
    dictionaryvar->schema--;
  }
  {
    BITCODE_T strvalue;
    if (dwg_dynapi_entity_value (dictionaryvar, "DICTIONARYVAR", "strvalue", &strvalue, NULL)
        && strvalue
           ? strEQ ((char *)strvalue, (char *)dictionaryvar->strvalue)
           : !dictionaryvar->strvalue)
      pass ();
    else
      fail ("DICTIONARYVAR.strvalue [T] '%s' <> '%s'", strvalue, dictionaryvar->strvalue);
  }
  if (failed && (is_class_unstable ("DICTIONARYVAR") || is_class_debugging ("DICTIONARYVAR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DICTIONARYVAR", failed);
      failed = 0;
    }
  return failed;
}
static int test_DICTIONARYWDFLT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DICTIONARYWDFLT *restrict dictionarywdflt = obj->tio.object->tio.DICTIONARYWDFLT;
  failed = 0;
  if (!obj_obj || !dictionarywdflt)
    {
      fail ("NULL DICTIONARYWDFLT");
      return 1;
    }
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "cloning", &cloning, NULL)
        && cloning == dictionarywdflt->cloning)
      pass ();
    else
      fail ("DICTIONARYWDFLT.cloning [BS] %hu != %hu", dictionarywdflt->cloning, cloning);
    cloning++;
    if (dwg_dynapi_entity_set_value (dictionarywdflt, "DICTIONARYWDFLT", "cloning", &cloning, 0)
        && cloning == dictionarywdflt->cloning)
      pass ();
    else
      fail ("DICTIONARYWDFLT.cloning [BS] set+1 %hu != %hu", dictionarywdflt->cloning, cloning);
    dictionarywdflt->cloning--;
  }
  {
    BITCODE_H defaultid;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "defaultid", &defaultid, NULL)
        && !memcmp (&defaultid, &dictionarywdflt->defaultid, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DICTIONARYWDFLT.defaultid [H]");
  }
  {
    BITCODE_RC is_hardowner;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "is_hardowner", &is_hardowner, NULL)
        && is_hardowner == dictionarywdflt->is_hardowner)
      pass ();
    else
      fail ("DICTIONARYWDFLT.is_hardowner [RC] %u != %u", dictionarywdflt->is_hardowner, is_hardowner);
    is_hardowner++;
    if (dwg_dynapi_entity_set_value (dictionarywdflt, "DICTIONARYWDFLT", "is_hardowner", &is_hardowner, 0)
        && is_hardowner == dictionarywdflt->is_hardowner)
      pass ();
    else
      fail ("DICTIONARYWDFLT.is_hardowner [RC] set+1 %u != %u", dictionarywdflt->is_hardowner, is_hardowner);
    dictionarywdflt->is_hardowner--;
  }
  {
    BITCODE_H* itemhandles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "numitems", &count, NULL)
        && dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "itemhandles", &itemhandles, NULL)
        && itemhandles == dictionarywdflt->itemhandles)
      pass ();
    else
      fail ("DICTIONARYWDFLT.itemhandles [H*] * %u numitems", count);
  }
  {
    BITCODE_BL numitems;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "numitems", &numitems, NULL)
        && numitems == dictionarywdflt->numitems)
      pass ();
    else
      fail ("DICTIONARYWDFLT.numitems [BL] %u != %u", dictionarywdflt->numitems, numitems);
    numitems++;
    if (dwg_dynapi_entity_set_value (dictionarywdflt, "DICTIONARYWDFLT", "numitems", &numitems, 0)
        && numitems == dictionarywdflt->numitems)
      pass ();
    else
      fail ("DICTIONARYWDFLT.numitems [BL] set+1 %u != %u", dictionarywdflt->numitems, numitems);
    dictionarywdflt->numitems--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "parent", &parent, NULL)
        && !memcmp (&parent, &dictionarywdflt->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DICTIONARYWDFLT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T* texts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "numitems", &count, NULL)
        && dwg_dynapi_entity_value (dictionarywdflt, "DICTIONARYWDFLT", "texts", &texts, NULL)
        && texts == dictionarywdflt->texts)
      pass ();
    else
      fail ("DICTIONARYWDFLT.texts [T*] * %u numitems", count);
  }
  if (failed && (is_class_unstable ("DICTIONARYWDFLT") || is_class_debugging ("DICTIONARYWDFLT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DICTIONARYWDFLT", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMASSOC (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DIMASSOC *restrict dimassoc = obj->tio.object->tio.DIMASSOC;
  failed = 0;
  if (!obj_obj || !dimassoc)
    {
      fail ("NULL DIMASSOC");
      return 1;
    }
  {
    BITCODE_BL associativity;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "associativity", &associativity, NULL)
        && associativity == dimassoc->associativity)
      pass ();
    else
      fail ("DIMASSOC.associativity [BL] %u != %u", dimassoc->associativity, associativity);
    associativity++;
    if (dwg_dynapi_entity_set_value (dimassoc, "DIMASSOC", "associativity", &associativity, 0)
        && associativity == dimassoc->associativity)
      pass ();
    else
      fail ("DIMASSOC.associativity [BL] set+1 %u != %u", dimassoc->associativity, associativity);
    dimassoc->associativity--;
  }
  {
    BITCODE_H dimensionobj;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "dimensionobj", &dimensionobj, NULL)
        && !memcmp (&dimensionobj, &dimassoc->dimensionobj, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMASSOC.dimensionobj [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "parent", &parent, NULL)
        && !memcmp (&parent, &dimassoc->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DIMASSOC.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_DIMASSOC_Ref* ref;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "ref", &ref, NULL)
        && !memcmp (&ref, &dimassoc->ref, sizeof (Dwg_DIMASSOC_Ref*)))
        pass ();
    else
        fail ("DIMASSOC.ref [Dwg_DIMASSOC_Ref*]");
  }
  {
    BITCODE_RC rotated_type;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "rotated_type", &rotated_type, NULL)
        && rotated_type == dimassoc->rotated_type)
      pass ();
    else
      fail ("DIMASSOC.rotated_type [RC] %u != %u", dimassoc->rotated_type, rotated_type);
    rotated_type++;
    if (dwg_dynapi_entity_set_value (dimassoc, "DIMASSOC", "rotated_type", &rotated_type, 0)
        && rotated_type == dimassoc->rotated_type)
      pass ();
    else
      fail ("DIMASSOC.rotated_type [RC] set+1 %u != %u", dimassoc->rotated_type, rotated_type);
    dimassoc->rotated_type--;
  }
  {
    BITCODE_B trans_space_flag;
    if (dwg_dynapi_entity_value (dimassoc, "DIMASSOC", "trans_space_flag", &trans_space_flag, NULL)
        && trans_space_flag == dimassoc->trans_space_flag)
      pass ();
    else
      fail ("DIMASSOC.trans_space_flag [B] " FORMAT_B " != " FORMAT_B "", dimassoc->trans_space_flag, trans_space_flag);
    trans_space_flag++;
    if (dwg_dynapi_entity_set_value (dimassoc, "DIMASSOC", "trans_space_flag", &trans_space_flag, 0)
        && trans_space_flag == dimassoc->trans_space_flag)
      pass ();
    else
      fail ("DIMASSOC.trans_space_flag [B] set+1 " FORMAT_B " != " FORMAT_B "", dimassoc->trans_space_flag, trans_space_flag);
    dimassoc->trans_space_flag--;
  }
  if (failed && (is_class_unstable ("DIMASSOC") || is_class_debugging ("DIMASSOC")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMASSOC", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DIMSTYLE *restrict dimstyle = obj->tio.object->tio.DIMSTYLE;
  failed = 0;
  if (!obj_obj || !dimstyle)
    {
      fail ("NULL DIMSTYLE");
      return 1;
    }
  {
    BITCODE_BS DIMADEC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMADEC", &DIMADEC, NULL)
        && DIMADEC == dimstyle->DIMADEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMADEC [BS] %hu != %hu", dimstyle->DIMADEC, DIMADEC);
    DIMADEC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMADEC", &DIMADEC, 0)
        && DIMADEC == dimstyle->DIMADEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMADEC [BS] set+1 %hu != %hu", dimstyle->DIMADEC, DIMADEC);
    dimstyle->DIMADEC--;
  }
  {
    BITCODE_B DIMALT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALT", &DIMALT, NULL)
        && DIMALT == dimstyle->DIMALT)
      pass ();
    else
      fail ("DIMSTYLE.DIMALT [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMALT, DIMALT);
    DIMALT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALT", &DIMALT, 0)
        && DIMALT == dimstyle->DIMALT)
      pass ();
    else
      fail ("DIMSTYLE.DIMALT [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMALT, DIMALT);
    dimstyle->DIMALT--;
  }
  {
    BITCODE_BS DIMALTD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTD", &DIMALTD, NULL)
        && DIMALTD == dimstyle->DIMALTD)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTD [BS] %hu != %hu", dimstyle->DIMALTD, DIMALTD);
    DIMALTD++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTD", &DIMALTD, 0)
        && DIMALTD == dimstyle->DIMALTD)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTD [BS] set+1 %hu != %hu", dimstyle->DIMALTD, DIMALTD);
    dimstyle->DIMALTD--;
  }
  {
    BITCODE_BD DIMALTF;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTF", &DIMALTF, NULL)
        && DIMALTF == dimstyle->DIMALTF)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTF [BD] %g != %g", dimstyle->DIMALTF, DIMALTF);
    DIMALTF++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTF", &DIMALTF, 0)
        && DIMALTF == dimstyle->DIMALTF)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTF [BD] set+1 %g != %g", dimstyle->DIMALTF, DIMALTF);
    dimstyle->DIMALTF--;
  }
  {
    BITCODE_BD DIMALTMZF;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTMZF", &DIMALTMZF, NULL)
        && DIMALTMZF == dimstyle->DIMALTMZF)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTMZF [BD] %g != %g", dimstyle->DIMALTMZF, DIMALTMZF);
    DIMALTMZF++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTMZF", &DIMALTMZF, 0)
        && DIMALTMZF == dimstyle->DIMALTMZF)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTMZF [BD] set+1 %g != %g", dimstyle->DIMALTMZF, DIMALTMZF);
    dimstyle->DIMALTMZF--;
  }
  {
    BITCODE_T DIMALTMZS;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTMZS", &DIMALTMZS, NULL)
        && DIMALTMZS
           ? strEQ ((char *)DIMALTMZS, (char *)dimstyle->DIMALTMZS)
           : !dimstyle->DIMALTMZS)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTMZS [T] '%s' <> '%s'", DIMALTMZS, dimstyle->DIMALTMZS);
  }
  {
    BITCODE_BD DIMALTRND;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTRND", &DIMALTRND, NULL)
        && DIMALTRND == dimstyle->DIMALTRND)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTRND [BD] %g != %g", dimstyle->DIMALTRND, DIMALTRND);
    DIMALTRND++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTRND", &DIMALTRND, 0)
        && DIMALTRND == dimstyle->DIMALTRND)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTRND [BD] set+1 %g != %g", dimstyle->DIMALTRND, DIMALTRND);
    dimstyle->DIMALTRND--;
  }
  {
    BITCODE_BS DIMALTTD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTTD", &DIMALTTD, NULL)
        && DIMALTTD == dimstyle->DIMALTTD)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTTD [BS] %hu != %hu", dimstyle->DIMALTTD, DIMALTTD);
    DIMALTTD++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTTD", &DIMALTTD, 0)
        && DIMALTTD == dimstyle->DIMALTTD)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTTD [BS] set+1 %hu != %hu", dimstyle->DIMALTTD, DIMALTTD);
    dimstyle->DIMALTTD--;
  }
  {
    BITCODE_BS DIMALTTZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTTZ", &DIMALTTZ, NULL)
        && DIMALTTZ == dimstyle->DIMALTTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTTZ [BS] %hu != %hu", dimstyle->DIMALTTZ, DIMALTTZ);
    DIMALTTZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTTZ", &DIMALTTZ, 0)
        && DIMALTTZ == dimstyle->DIMALTTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTTZ [BS] set+1 %hu != %hu", dimstyle->DIMALTTZ, DIMALTTZ);
    dimstyle->DIMALTTZ--;
  }
  {
    BITCODE_BS DIMALTU;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTU", &DIMALTU, NULL)
        && DIMALTU == dimstyle->DIMALTU)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTU [BS] %hu != %hu", dimstyle->DIMALTU, DIMALTU);
    DIMALTU++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTU", &DIMALTU, 0)
        && DIMALTU == dimstyle->DIMALTU)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTU [BS] set+1 %hu != %hu", dimstyle->DIMALTU, DIMALTU);
    dimstyle->DIMALTU--;
  }
  {
    BITCODE_BS DIMALTZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMALTZ", &DIMALTZ, NULL)
        && DIMALTZ == dimstyle->DIMALTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTZ [BS] %hu != %hu", dimstyle->DIMALTZ, DIMALTZ);
    DIMALTZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMALTZ", &DIMALTZ, 0)
        && DIMALTZ == dimstyle->DIMALTZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMALTZ [BS] set+1 %hu != %hu", dimstyle->DIMALTZ, DIMALTZ);
    dimstyle->DIMALTZ--;
  }
  {
    BITCODE_T DIMAPOST;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMAPOST", &DIMAPOST, NULL)
        && DIMAPOST
           ? strEQ ((char *)DIMAPOST, (char *)dimstyle->DIMAPOST)
           : !dimstyle->DIMAPOST)
      pass ();
    else
      fail ("DIMSTYLE.DIMAPOST [T] '%s' <> '%s'", DIMAPOST, dimstyle->DIMAPOST);
  }
  {
    BITCODE_BS DIMARCSYM;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMARCSYM", &DIMARCSYM, NULL)
        && DIMARCSYM == dimstyle->DIMARCSYM)
      pass ();
    else
      fail ("DIMSTYLE.DIMARCSYM [BS] %hu != %hu", dimstyle->DIMARCSYM, DIMARCSYM);
    DIMARCSYM++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMARCSYM", &DIMARCSYM, 0)
        && DIMARCSYM == dimstyle->DIMARCSYM)
      pass ();
    else
      fail ("DIMSTYLE.DIMARCSYM [BS] set+1 %hu != %hu", dimstyle->DIMARCSYM, DIMARCSYM);
    dimstyle->DIMARCSYM--;
  }
  {
    BITCODE_BD DIMASZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMASZ", &DIMASZ, NULL)
        && DIMASZ == dimstyle->DIMASZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMASZ [BD] %g != %g", dimstyle->DIMASZ, DIMASZ);
    DIMASZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMASZ", &DIMASZ, 0)
        && DIMASZ == dimstyle->DIMASZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMASZ [BD] set+1 %g != %g", dimstyle->DIMASZ, DIMASZ);
    dimstyle->DIMASZ--;
  }
  {
    BITCODE_BS DIMATFIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMATFIT", &DIMATFIT, NULL)
        && DIMATFIT == dimstyle->DIMATFIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMATFIT [BS] %hu != %hu", dimstyle->DIMATFIT, DIMATFIT);
    DIMATFIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMATFIT", &DIMATFIT, 0)
        && DIMATFIT == dimstyle->DIMATFIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMATFIT [BS] set+1 %hu != %hu", dimstyle->DIMATFIT, DIMATFIT);
    dimstyle->DIMATFIT--;
  }
  {
    BITCODE_BS DIMAUNIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMAUNIT", &DIMAUNIT, NULL)
        && DIMAUNIT == dimstyle->DIMAUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMAUNIT [BS] %hu != %hu", dimstyle->DIMAUNIT, DIMAUNIT);
    DIMAUNIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMAUNIT", &DIMAUNIT, 0)
        && DIMAUNIT == dimstyle->DIMAUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMAUNIT [BS] set+1 %hu != %hu", dimstyle->DIMAUNIT, DIMAUNIT);
    dimstyle->DIMAUNIT--;
  }
  {
    BITCODE_BS DIMAZIN;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMAZIN", &DIMAZIN, NULL)
        && DIMAZIN == dimstyle->DIMAZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMAZIN [BS] %hu != %hu", dimstyle->DIMAZIN, DIMAZIN);
    DIMAZIN++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMAZIN", &DIMAZIN, 0)
        && DIMAZIN == dimstyle->DIMAZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMAZIN [BS] set+1 %hu != %hu", dimstyle->DIMAZIN, DIMAZIN);
    dimstyle->DIMAZIN--;
  }
  {
    BITCODE_H DIMBLK;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK", &DIMBLK, NULL)
        && !memcmp (&DIMBLK, &dimstyle->DIMBLK, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.DIMBLK [H]");
  }
  {
    BITCODE_H DIMBLK1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK1", &DIMBLK1, NULL)
        && !memcmp (&DIMBLK1, &dimstyle->DIMBLK1, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.DIMBLK1 [H]");
  }
  {
    BITCODE_TV DIMBLK1_T;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK1_T", &DIMBLK1_T, NULL)
        && DIMBLK1_T
           ? strEQ ((char *)DIMBLK1_T, (char *)dimstyle->DIMBLK1_T)
           : !dimstyle->DIMBLK1_T)
      pass ();
    else
      fail ("DIMSTYLE.DIMBLK1_T [TV] '%s' <> '%s'", DIMBLK1_T, dimstyle->DIMBLK1_T);
  }
  {
    BITCODE_H DIMBLK2;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK2", &DIMBLK2, NULL)
        && !memcmp (&DIMBLK2, &dimstyle->DIMBLK2, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.DIMBLK2 [H]");
  }
  {
    BITCODE_TV DIMBLK2_T;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK2_T", &DIMBLK2_T, NULL)
        && DIMBLK2_T
           ? strEQ ((char *)DIMBLK2_T, (char *)dimstyle->DIMBLK2_T)
           : !dimstyle->DIMBLK2_T)
      pass ();
    else
      fail ("DIMSTYLE.DIMBLK2_T [TV] '%s' <> '%s'", DIMBLK2_T, dimstyle->DIMBLK2_T);
  }
  {
    BITCODE_TV DIMBLK_T;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMBLK_T", &DIMBLK_T, NULL)
        && DIMBLK_T
           ? strEQ ((char *)DIMBLK_T, (char *)dimstyle->DIMBLK_T)
           : !dimstyle->DIMBLK_T)
      pass ();
    else
      fail ("DIMSTYLE.DIMBLK_T [TV] '%s' <> '%s'", DIMBLK_T, dimstyle->DIMBLK_T);
  }
  {
    BITCODE_BD DIMCEN;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCEN", &DIMCEN, NULL)
        && DIMCEN == dimstyle->DIMCEN)
      pass ();
    else
      fail ("DIMSTYLE.DIMCEN [BD] %g != %g", dimstyle->DIMCEN, DIMCEN);
    DIMCEN++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMCEN", &DIMCEN, 0)
        && DIMCEN == dimstyle->DIMCEN)
      pass ();
    else
      fail ("DIMSTYLE.DIMCEN [BD] set+1 %g != %g", dimstyle->DIMCEN, DIMCEN);
    dimstyle->DIMCEN--;
  }
  {
    BITCODE_CMC DIMCLRD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRD", &DIMCLRD, NULL)
        && !memcmp (&DIMCLRD, &dimstyle->DIMCLRD, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DIMSTYLE.DIMCLRD [CMC]");
  }
  {
    BITCODE_RS DIMCLRD_N;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRD_N", &DIMCLRD_N, NULL)
        && DIMCLRD_N == dimstyle->DIMCLRD_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRD_N [RS] %hu != %hu", dimstyle->DIMCLRD_N, DIMCLRD_N);
    DIMCLRD_N++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMCLRD_N", &DIMCLRD_N, 0)
        && DIMCLRD_N == dimstyle->DIMCLRD_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRD_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRD_N, DIMCLRD_N);
    dimstyle->DIMCLRD_N--;
  }
  {
    BITCODE_CMC DIMCLRE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRE", &DIMCLRE, NULL)
        && !memcmp (&DIMCLRE, &dimstyle->DIMCLRE, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DIMSTYLE.DIMCLRE [CMC]");
  }
  {
    BITCODE_RS DIMCLRE_N;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRE_N", &DIMCLRE_N, NULL)
        && DIMCLRE_N == dimstyle->DIMCLRE_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRE_N [RS] %hu != %hu", dimstyle->DIMCLRE_N, DIMCLRE_N);
    DIMCLRE_N++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMCLRE_N", &DIMCLRE_N, 0)
        && DIMCLRE_N == dimstyle->DIMCLRE_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRE_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRE_N, DIMCLRE_N);
    dimstyle->DIMCLRE_N--;
  }
  {
    BITCODE_CMC DIMCLRT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRT", &DIMCLRT, NULL)
        && !memcmp (&DIMCLRT, &dimstyle->DIMCLRT, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DIMSTYLE.DIMCLRT [CMC]");
  }
  {
    BITCODE_RS DIMCLRT_N;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMCLRT_N", &DIMCLRT_N, NULL)
        && DIMCLRT_N == dimstyle->DIMCLRT_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRT_N [RS] %hu != %hu", dimstyle->DIMCLRT_N, DIMCLRT_N);
    DIMCLRT_N++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMCLRT_N", &DIMCLRT_N, 0)
        && DIMCLRT_N == dimstyle->DIMCLRT_N)
      pass ();
    else
      fail ("DIMSTYLE.DIMCLRT_N [RS] set+1 %hu != %hu", dimstyle->DIMCLRT_N, DIMCLRT_N);
    dimstyle->DIMCLRT_N--;
  }
  {
    BITCODE_BS DIMDEC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMDEC", &DIMDEC, NULL)
        && DIMDEC == dimstyle->DIMDEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMDEC [BS] %hu != %hu", dimstyle->DIMDEC, DIMDEC);
    DIMDEC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMDEC", &DIMDEC, 0)
        && DIMDEC == dimstyle->DIMDEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMDEC [BS] set+1 %hu != %hu", dimstyle->DIMDEC, DIMDEC);
    dimstyle->DIMDEC--;
  }
  {
    BITCODE_BD DIMDLE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMDLE", &DIMDLE, NULL)
        && DIMDLE == dimstyle->DIMDLE)
      pass ();
    else
      fail ("DIMSTYLE.DIMDLE [BD] %g != %g", dimstyle->DIMDLE, DIMDLE);
    DIMDLE++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMDLE", &DIMDLE, 0)
        && DIMDLE == dimstyle->DIMDLE)
      pass ();
    else
      fail ("DIMSTYLE.DIMDLE [BD] set+1 %g != %g", dimstyle->DIMDLE, DIMDLE);
    dimstyle->DIMDLE--;
  }
  {
    BITCODE_BD DIMDLI;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMDLI", &DIMDLI, NULL)
        && DIMDLI == dimstyle->DIMDLI)
      pass ();
    else
      fail ("DIMSTYLE.DIMDLI [BD] %g != %g", dimstyle->DIMDLI, DIMDLI);
    DIMDLI++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMDLI", &DIMDLI, 0)
        && DIMDLI == dimstyle->DIMDLI)
      pass ();
    else
      fail ("DIMSTYLE.DIMDLI [BD] set+1 %g != %g", dimstyle->DIMDLI, DIMDLI);
    dimstyle->DIMDLI--;
  }
  {
    BITCODE_BS DIMDSEP;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMDSEP", &DIMDSEP, NULL)
        && DIMDSEP == dimstyle->DIMDSEP)
      pass ();
    else
      fail ("DIMSTYLE.DIMDSEP [BS] %hu != %hu", dimstyle->DIMDSEP, DIMDSEP);
    DIMDSEP++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMDSEP", &DIMDSEP, 0)
        && DIMDSEP == dimstyle->DIMDSEP)
      pass ();
    else
      fail ("DIMSTYLE.DIMDSEP [BS] set+1 %hu != %hu", dimstyle->DIMDSEP, DIMDSEP);
    dimstyle->DIMDSEP--;
  }
  {
    BITCODE_BD DIMEXE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMEXE", &DIMEXE, NULL)
        && DIMEXE == dimstyle->DIMEXE)
      pass ();
    else
      fail ("DIMSTYLE.DIMEXE [BD] %g != %g", dimstyle->DIMEXE, DIMEXE);
    DIMEXE++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMEXE", &DIMEXE, 0)
        && DIMEXE == dimstyle->DIMEXE)
      pass ();
    else
      fail ("DIMSTYLE.DIMEXE [BD] set+1 %g != %g", dimstyle->DIMEXE, DIMEXE);
    dimstyle->DIMEXE--;
  }
  {
    BITCODE_BD DIMEXO;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMEXO", &DIMEXO, NULL)
        && DIMEXO == dimstyle->DIMEXO)
      pass ();
    else
      fail ("DIMSTYLE.DIMEXO [BD] %g != %g", dimstyle->DIMEXO, DIMEXO);
    DIMEXO++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMEXO", &DIMEXO, 0)
        && DIMEXO == dimstyle->DIMEXO)
      pass ();
    else
      fail ("DIMSTYLE.DIMEXO [BD] set+1 %g != %g", dimstyle->DIMEXO, DIMEXO);
    dimstyle->DIMEXO--;
  }
  {
    BITCODE_BS DIMFIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMFIT", &DIMFIT, NULL)
        && DIMFIT == dimstyle->DIMFIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMFIT [BS] %hu != %hu", dimstyle->DIMFIT, DIMFIT);
    DIMFIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMFIT", &DIMFIT, 0)
        && DIMFIT == dimstyle->DIMFIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMFIT [BS] set+1 %hu != %hu", dimstyle->DIMFIT, DIMFIT);
    dimstyle->DIMFIT--;
  }
  {
    BITCODE_BS DIMFRAC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMFRAC", &DIMFRAC, NULL)
        && DIMFRAC == dimstyle->DIMFRAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMFRAC [BS] %hu != %hu", dimstyle->DIMFRAC, DIMFRAC);
    DIMFRAC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMFRAC", &DIMFRAC, 0)
        && DIMFRAC == dimstyle->DIMFRAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMFRAC [BS] set+1 %hu != %hu", dimstyle->DIMFRAC, DIMFRAC);
    dimstyle->DIMFRAC--;
  }
  {
    BITCODE_BD DIMFXL;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMFXL", &DIMFXL, NULL)
        && DIMFXL == dimstyle->DIMFXL)
      pass ();
    else
      fail ("DIMSTYLE.DIMFXL [BD] %g != %g", dimstyle->DIMFXL, DIMFXL);
    DIMFXL++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMFXL", &DIMFXL, 0)
        && DIMFXL == dimstyle->DIMFXL)
      pass ();
    else
      fail ("DIMSTYLE.DIMFXL [BD] set+1 %g != %g", dimstyle->DIMFXL, DIMFXL);
    dimstyle->DIMFXL--;
  }
  {
    BITCODE_B DIMFXLON;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMFXLON", &DIMFXLON, NULL)
        && DIMFXLON == dimstyle->DIMFXLON)
      pass ();
    else
      fail ("DIMSTYLE.DIMFXLON [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMFXLON, DIMFXLON);
    DIMFXLON++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMFXLON", &DIMFXLON, 0)
        && DIMFXLON == dimstyle->DIMFXLON)
      pass ();
    else
      fail ("DIMSTYLE.DIMFXLON [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMFXLON, DIMFXLON);
    dimstyle->DIMFXLON--;
  }
  {
    BITCODE_BD DIMGAP;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMGAP", &DIMGAP, NULL)
        && DIMGAP == dimstyle->DIMGAP)
      pass ();
    else
      fail ("DIMSTYLE.DIMGAP [BD] %g != %g", dimstyle->DIMGAP, DIMGAP);
    DIMGAP++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMGAP", &DIMGAP, 0)
        && DIMGAP == dimstyle->DIMGAP)
      pass ();
    else
      fail ("DIMSTYLE.DIMGAP [BD] set+1 %g != %g", dimstyle->DIMGAP, DIMGAP);
    dimstyle->DIMGAP--;
  }
  {
    BITCODE_BD DIMJOGANG;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMJOGANG", &DIMJOGANG, NULL)
        && DIMJOGANG == dimstyle->DIMJOGANG)
      pass ();
    else
      fail ("DIMSTYLE.DIMJOGANG [BD] %g != %g", dimstyle->DIMJOGANG, DIMJOGANG);
    DIMJOGANG++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMJOGANG", &DIMJOGANG, 0)
        && DIMJOGANG == dimstyle->DIMJOGANG)
      pass ();
    else
      fail ("DIMSTYLE.DIMJOGANG [BD] set+1 %g != %g", dimstyle->DIMJOGANG, DIMJOGANG);
    dimstyle->DIMJOGANG--;
  }
  {
    BITCODE_BS DIMJUST;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMJUST", &DIMJUST, NULL)
        && DIMJUST == dimstyle->DIMJUST)
      pass ();
    else
      fail ("DIMSTYLE.DIMJUST [BS] %hu != %hu", dimstyle->DIMJUST, DIMJUST);
    DIMJUST++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMJUST", &DIMJUST, 0)
        && DIMJUST == dimstyle->DIMJUST)
      pass ();
    else
      fail ("DIMSTYLE.DIMJUST [BS] set+1 %hu != %hu", dimstyle->DIMJUST, DIMJUST);
    dimstyle->DIMJUST--;
  }
  {
    BITCODE_H DIMLDRBLK;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLDRBLK", &DIMLDRBLK, NULL)
        && !memcmp (&DIMLDRBLK, &dimstyle->DIMLDRBLK, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.DIMLDRBLK [H]");
  }
  {
    BITCODE_BD DIMLFAC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLFAC", &DIMLFAC, NULL)
        && DIMLFAC == dimstyle->DIMLFAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMLFAC [BD] %g != %g", dimstyle->DIMLFAC, DIMLFAC);
    DIMLFAC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLFAC", &DIMLFAC, 0)
        && DIMLFAC == dimstyle->DIMLFAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMLFAC [BD] set+1 %g != %g", dimstyle->DIMLFAC, DIMLFAC);
    dimstyle->DIMLFAC--;
  }
  {
    BITCODE_B DIMLIM;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLIM", &DIMLIM, NULL)
        && DIMLIM == dimstyle->DIMLIM)
      pass ();
    else
      fail ("DIMSTYLE.DIMLIM [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMLIM, DIMLIM);
    DIMLIM++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLIM", &DIMLIM, 0)
        && DIMLIM == dimstyle->DIMLIM)
      pass ();
    else
      fail ("DIMSTYLE.DIMLIM [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMLIM, DIMLIM);
    dimstyle->DIMLIM--;
  }
  {
    BITCODE_H DIMLTEX1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLTEX1", &DIMLTEX1, NULL)
        && !memcmp (&DIMLTEX1, &dimstyle->DIMLTEX1, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.DIMLTEX1 [H]");
  }
  {
    BITCODE_H DIMLTEX2;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLTEX2", &DIMLTEX2, NULL)
        && !memcmp (&DIMLTEX2, &dimstyle->DIMLTEX2, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.DIMLTEX2 [H]");
  }
  {
    BITCODE_H DIMLTYPE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLTYPE", &DIMLTYPE, NULL)
        && !memcmp (&DIMLTYPE, &dimstyle->DIMLTYPE, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.DIMLTYPE [H]");
  }
  {
    BITCODE_BS DIMLUNIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLUNIT", &DIMLUNIT, NULL)
        && DIMLUNIT == dimstyle->DIMLUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMLUNIT [BS] %hu != %hu", dimstyle->DIMLUNIT, DIMLUNIT);
    DIMLUNIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLUNIT", &DIMLUNIT, 0)
        && DIMLUNIT == dimstyle->DIMLUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMLUNIT [BS] set+1 %hu != %hu", dimstyle->DIMLUNIT, DIMLUNIT);
    dimstyle->DIMLUNIT--;
  }
  {
    BITCODE_BSd DIMLWD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLWD", &DIMLWD, NULL)
        && DIMLWD == dimstyle->DIMLWD)
      pass ();
    else
      fail ("DIMSTYLE.DIMLWD [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dimstyle->DIMLWD, DIMLWD);
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLWD", &DIMLWD, 0)
        && DIMLWD == dimstyle->DIMLWD)
      pass ();
    else
      fail ("DIMSTYLE.DIMLWD [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "", dimstyle->DIMLWD, DIMLWD);
    dimstyle->DIMLWD--;
  }
  {
    BITCODE_BSd DIMLWE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMLWE", &DIMLWE, NULL)
        && DIMLWE == dimstyle->DIMLWE)
      pass ();
    else
      fail ("DIMSTYLE.DIMLWE [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dimstyle->DIMLWE, DIMLWE);
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMLWE", &DIMLWE, 0)
        && DIMLWE == dimstyle->DIMLWE)
      pass ();
    else
      fail ("DIMSTYLE.DIMLWE [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "", dimstyle->DIMLWE, DIMLWE);
    dimstyle->DIMLWE--;
  }
  {
    BITCODE_BD DIMMZF;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMMZF", &DIMMZF, NULL)
        && DIMMZF == dimstyle->DIMMZF)
      pass ();
    else
      fail ("DIMSTYLE.DIMMZF [BD] %g != %g", dimstyle->DIMMZF, DIMMZF);
    DIMMZF++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMMZF", &DIMMZF, 0)
        && DIMMZF == dimstyle->DIMMZF)
      pass ();
    else
      fail ("DIMSTYLE.DIMMZF [BD] set+1 %g != %g", dimstyle->DIMMZF, DIMMZF);
    dimstyle->DIMMZF--;
  }
  {
    BITCODE_T DIMMZS;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMMZS", &DIMMZS, NULL)
        && DIMMZS
           ? strEQ ((char *)DIMMZS, (char *)dimstyle->DIMMZS)
           : !dimstyle->DIMMZS)
      pass ();
    else
      fail ("DIMSTYLE.DIMMZS [T] '%s' <> '%s'", DIMMZS, dimstyle->DIMMZS);
  }
  {
    BITCODE_T DIMPOST;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMPOST", &DIMPOST, NULL)
        && DIMPOST
           ? strEQ ((char *)DIMPOST, (char *)dimstyle->DIMPOST)
           : !dimstyle->DIMPOST)
      pass ();
    else
      fail ("DIMSTYLE.DIMPOST [T] '%s' <> '%s'", DIMPOST, dimstyle->DIMPOST);
  }
  {
    BITCODE_BD DIMRND;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMRND", &DIMRND, NULL)
        && DIMRND == dimstyle->DIMRND)
      pass ();
    else
      fail ("DIMSTYLE.DIMRND [BD] %g != %g", dimstyle->DIMRND, DIMRND);
    DIMRND++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMRND", &DIMRND, 0)
        && DIMRND == dimstyle->DIMRND)
      pass ();
    else
      fail ("DIMSTYLE.DIMRND [BD] set+1 %g != %g", dimstyle->DIMRND, DIMRND);
    dimstyle->DIMRND--;
  }
  {
    BITCODE_B DIMSAH;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSAH", &DIMSAH, NULL)
        && DIMSAH == dimstyle->DIMSAH)
      pass ();
    else
      fail ("DIMSTYLE.DIMSAH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSAH, DIMSAH);
    DIMSAH++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSAH", &DIMSAH, 0)
        && DIMSAH == dimstyle->DIMSAH)
      pass ();
    else
      fail ("DIMSTYLE.DIMSAH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSAH, DIMSAH);
    dimstyle->DIMSAH--;
  }
  {
    BITCODE_BD DIMSCALE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSCALE", &DIMSCALE, NULL)
        && DIMSCALE == dimstyle->DIMSCALE)
      pass ();
    else
      fail ("DIMSTYLE.DIMSCALE [BD] %g != %g", dimstyle->DIMSCALE, DIMSCALE);
    DIMSCALE++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSCALE", &DIMSCALE, 0)
        && DIMSCALE == dimstyle->DIMSCALE)
      pass ();
    else
      fail ("DIMSTYLE.DIMSCALE [BD] set+1 %g != %g", dimstyle->DIMSCALE, DIMSCALE);
    dimstyle->DIMSCALE--;
  }
  {
    BITCODE_B DIMSD1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSD1", &DIMSD1, NULL)
        && DIMSD1 == dimstyle->DIMSD1)
      pass ();
    else
      fail ("DIMSTYLE.DIMSD1 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD1, DIMSD1);
    DIMSD1++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSD1", &DIMSD1, 0)
        && DIMSD1 == dimstyle->DIMSD1)
      pass ();
    else
      fail ("DIMSTYLE.DIMSD1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD1, DIMSD1);
    dimstyle->DIMSD1--;
  }
  {
    BITCODE_B DIMSD2;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSD2", &DIMSD2, NULL)
        && DIMSD2 == dimstyle->DIMSD2)
      pass ();
    else
      fail ("DIMSTYLE.DIMSD2 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD2, DIMSD2);
    DIMSD2++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSD2", &DIMSD2, 0)
        && DIMSD2 == dimstyle->DIMSD2)
      pass ();
    else
      fail ("DIMSTYLE.DIMSD2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD2, DIMSD2);
    dimstyle->DIMSD2--;
  }
  {
    BITCODE_B DIMSE1;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSE1", &DIMSE1, NULL)
        && DIMSE1 == dimstyle->DIMSE1)
      pass ();
    else
      fail ("DIMSTYLE.DIMSE1 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE1, DIMSE1);
    DIMSE1++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSE1", &DIMSE1, 0)
        && DIMSE1 == dimstyle->DIMSE1)
      pass ();
    else
      fail ("DIMSTYLE.DIMSE1 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE1, DIMSE1);
    dimstyle->DIMSE1--;
  }
  {
    BITCODE_B DIMSE2;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSE2", &DIMSE2, NULL)
        && DIMSE2 == dimstyle->DIMSE2)
      pass ();
    else
      fail ("DIMSTYLE.DIMSE2 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE2, DIMSE2);
    DIMSE2++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSE2", &DIMSE2, 0)
        && DIMSE2 == dimstyle->DIMSE2)
      pass ();
    else
      fail ("DIMSTYLE.DIMSE2 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE2, DIMSE2);
    dimstyle->DIMSE2--;
  }
  {
    BITCODE_B DIMSOXD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMSOXD", &DIMSOXD, NULL)
        && DIMSOXD == dimstyle->DIMSOXD)
      pass ();
    else
      fail ("DIMSTYLE.DIMSOXD [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSOXD, DIMSOXD);
    DIMSOXD++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMSOXD", &DIMSOXD, 0)
        && DIMSOXD == dimstyle->DIMSOXD)
      pass ();
    else
      fail ("DIMSTYLE.DIMSOXD [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSOXD, DIMSOXD);
    dimstyle->DIMSOXD--;
  }
  {
    BITCODE_BS DIMTAD;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTAD", &DIMTAD, NULL)
        && DIMTAD == dimstyle->DIMTAD)
      pass ();
    else
      fail ("DIMSTYLE.DIMTAD [BS] %hu != %hu", dimstyle->DIMTAD, DIMTAD);
    DIMTAD++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTAD", &DIMTAD, 0)
        && DIMTAD == dimstyle->DIMTAD)
      pass ();
    else
      fail ("DIMSTYLE.DIMTAD [BS] set+1 %hu != %hu", dimstyle->DIMTAD, DIMTAD);
    dimstyle->DIMTAD--;
  }
  {
    BITCODE_BS DIMTDEC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTDEC", &DIMTDEC, NULL)
        && DIMTDEC == dimstyle->DIMTDEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMTDEC [BS] %hu != %hu", dimstyle->DIMTDEC, DIMTDEC);
    DIMTDEC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTDEC", &DIMTDEC, 0)
        && DIMTDEC == dimstyle->DIMTDEC)
      pass ();
    else
      fail ("DIMSTYLE.DIMTDEC [BS] set+1 %hu != %hu", dimstyle->DIMTDEC, DIMTDEC);
    dimstyle->DIMTDEC--;
  }
  {
    BITCODE_BD DIMTFAC;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTFAC", &DIMTFAC, NULL)
        && DIMTFAC == dimstyle->DIMTFAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMTFAC [BD] %g != %g", dimstyle->DIMTFAC, DIMTFAC);
    DIMTFAC++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTFAC", &DIMTFAC, 0)
        && DIMTFAC == dimstyle->DIMTFAC)
      pass ();
    else
      fail ("DIMSTYLE.DIMTFAC [BD] set+1 %g != %g", dimstyle->DIMTFAC, DIMTFAC);
    dimstyle->DIMTFAC--;
  }
  {
    BITCODE_BS DIMTFILL;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTFILL", &DIMTFILL, NULL)
        && DIMTFILL == dimstyle->DIMTFILL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTFILL [BS] %hu != %hu", dimstyle->DIMTFILL, DIMTFILL);
    DIMTFILL++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTFILL", &DIMTFILL, 0)
        && DIMTFILL == dimstyle->DIMTFILL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTFILL [BS] set+1 %hu != %hu", dimstyle->DIMTFILL, DIMTFILL);
    dimstyle->DIMTFILL--;
  }
  {
    BITCODE_CMC DIMTFILLCLR;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTFILLCLR", &DIMTFILLCLR, NULL)
        && !memcmp (&DIMTFILLCLR, &dimstyle->DIMTFILLCLR, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("DIMSTYLE.DIMTFILLCLR [CMC]");
  }
  {
    BITCODE_B DIMTIH;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTIH", &DIMTIH, NULL)
        && DIMTIH == dimstyle->DIMTIH)
      pass ();
    else
      fail ("DIMSTYLE.DIMTIH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIH, DIMTIH);
    DIMTIH++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTIH", &DIMTIH, 0)
        && DIMTIH == dimstyle->DIMTIH)
      pass ();
    else
      fail ("DIMSTYLE.DIMTIH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIH, DIMTIH);
    dimstyle->DIMTIH--;
  }
  {
    BITCODE_B DIMTIX;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTIX", &DIMTIX, NULL)
        && DIMTIX == dimstyle->DIMTIX)
      pass ();
    else
      fail ("DIMSTYLE.DIMTIX [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIX, DIMTIX);
    DIMTIX++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTIX", &DIMTIX, 0)
        && DIMTIX == dimstyle->DIMTIX)
      pass ();
    else
      fail ("DIMSTYLE.DIMTIX [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIX, DIMTIX);
    dimstyle->DIMTIX--;
  }
  {
    BITCODE_BD DIMTM;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTM", &DIMTM, NULL)
        && DIMTM == dimstyle->DIMTM)
      pass ();
    else
      fail ("DIMSTYLE.DIMTM [BD] %g != %g", dimstyle->DIMTM, DIMTM);
    DIMTM++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTM", &DIMTM, 0)
        && DIMTM == dimstyle->DIMTM)
      pass ();
    else
      fail ("DIMSTYLE.DIMTM [BD] set+1 %g != %g", dimstyle->DIMTM, DIMTM);
    dimstyle->DIMTM--;
  }
  {
    BITCODE_BS DIMTMOVE;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTMOVE", &DIMTMOVE, NULL)
        && DIMTMOVE == dimstyle->DIMTMOVE)
      pass ();
    else
      fail ("DIMSTYLE.DIMTMOVE [BS] %hu != %hu", dimstyle->DIMTMOVE, DIMTMOVE);
    DIMTMOVE++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTMOVE", &DIMTMOVE, 0)
        && DIMTMOVE == dimstyle->DIMTMOVE)
      pass ();
    else
      fail ("DIMSTYLE.DIMTMOVE [BS] set+1 %hu != %hu", dimstyle->DIMTMOVE, DIMTMOVE);
    dimstyle->DIMTMOVE--;
  }
  {
    BITCODE_B DIMTOFL;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTOFL", &DIMTOFL, NULL)
        && DIMTOFL == dimstyle->DIMTOFL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOFL [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOFL, DIMTOFL);
    DIMTOFL++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTOFL", &DIMTOFL, 0)
        && DIMTOFL == dimstyle->DIMTOFL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOFL [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOFL, DIMTOFL);
    dimstyle->DIMTOFL--;
  }
  {
    BITCODE_B DIMTOH;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTOH", &DIMTOH, NULL)
        && DIMTOH == dimstyle->DIMTOH)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOH, DIMTOH);
    DIMTOH++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTOH", &DIMTOH, 0)
        && DIMTOH == dimstyle->DIMTOH)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOH [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOH, DIMTOH);
    dimstyle->DIMTOH--;
  }
  {
    BITCODE_B DIMTOL;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTOL", &DIMTOL, NULL)
        && DIMTOL == dimstyle->DIMTOL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOL [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOL, DIMTOL);
    DIMTOL++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTOL", &DIMTOL, 0)
        && DIMTOL == dimstyle->DIMTOL)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOL [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOL, DIMTOL);
    dimstyle->DIMTOL--;
  }
  {
    BITCODE_BS DIMTOLJ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTOLJ", &DIMTOLJ, NULL)
        && DIMTOLJ == dimstyle->DIMTOLJ)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOLJ [BS] %hu != %hu", dimstyle->DIMTOLJ, DIMTOLJ);
    DIMTOLJ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTOLJ", &DIMTOLJ, 0)
        && DIMTOLJ == dimstyle->DIMTOLJ)
      pass ();
    else
      fail ("DIMSTYLE.DIMTOLJ [BS] set+1 %hu != %hu", dimstyle->DIMTOLJ, DIMTOLJ);
    dimstyle->DIMTOLJ--;
  }
  {
    BITCODE_BD DIMTP;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTP", &DIMTP, NULL)
        && DIMTP == dimstyle->DIMTP)
      pass ();
    else
      fail ("DIMSTYLE.DIMTP [BD] %g != %g", dimstyle->DIMTP, DIMTP);
    DIMTP++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTP", &DIMTP, 0)
        && DIMTP == dimstyle->DIMTP)
      pass ();
    else
      fail ("DIMSTYLE.DIMTP [BD] set+1 %g != %g", dimstyle->DIMTP, DIMTP);
    dimstyle->DIMTP--;
  }
  {
    BITCODE_BD DIMTSZ;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTSZ", &DIMTSZ, NULL)
        && DIMTSZ == dimstyle->DIMTSZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMTSZ [BD] %g != %g", dimstyle->DIMTSZ, DIMTSZ);
    DIMTSZ++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTSZ", &DIMTSZ, 0)
        && DIMTSZ == dimstyle->DIMTSZ)
      pass ();
    else
      fail ("DIMSTYLE.DIMTSZ [BD] set+1 %g != %g", dimstyle->DIMTSZ, DIMTSZ);
    dimstyle->DIMTSZ--;
  }
  {
    BITCODE_BD DIMTVP;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTVP", &DIMTVP, NULL)
        && DIMTVP == dimstyle->DIMTVP)
      pass ();
    else
      fail ("DIMSTYLE.DIMTVP [BD] %g != %g", dimstyle->DIMTVP, DIMTVP);
    DIMTVP++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTVP", &DIMTVP, 0)
        && DIMTVP == dimstyle->DIMTVP)
      pass ();
    else
      fail ("DIMSTYLE.DIMTVP [BD] set+1 %g != %g", dimstyle->DIMTVP, DIMTVP);
    dimstyle->DIMTVP--;
  }
  {
    BITCODE_H DIMTXSTY;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTXSTY", &DIMTXSTY, NULL)
        && !memcmp (&DIMTXSTY, &dimstyle->DIMTXSTY, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.DIMTXSTY [H]");
  }
  {
    BITCODE_BD DIMTXT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTXT", &DIMTXT, NULL)
        && DIMTXT == dimstyle->DIMTXT)
      pass ();
    else
      fail ("DIMSTYLE.DIMTXT [BD] %g != %g", dimstyle->DIMTXT, DIMTXT);
    DIMTXT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTXT", &DIMTXT, 0)
        && DIMTXT == dimstyle->DIMTXT)
      pass ();
    else
      fail ("DIMSTYLE.DIMTXT [BD] set+1 %g != %g", dimstyle->DIMTXT, DIMTXT);
    dimstyle->DIMTXT--;
  }
  {
    BITCODE_B DIMTXTDIRECTION;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTXTDIRECTION", &DIMTXTDIRECTION, NULL)
        && DIMTXTDIRECTION == dimstyle->DIMTXTDIRECTION)
      pass ();
    else
      fail ("DIMSTYLE.DIMTXTDIRECTION [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTXTDIRECTION, DIMTXTDIRECTION);
    DIMTXTDIRECTION++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTXTDIRECTION", &DIMTXTDIRECTION, 0)
        && DIMTXTDIRECTION == dimstyle->DIMTXTDIRECTION)
      pass ();
    else
      fail ("DIMSTYLE.DIMTXTDIRECTION [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTXTDIRECTION, DIMTXTDIRECTION);
    dimstyle->DIMTXTDIRECTION--;
  }
  {
    BITCODE_BS DIMTZIN;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMTZIN", &DIMTZIN, NULL)
        && DIMTZIN == dimstyle->DIMTZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMTZIN [BS] %hu != %hu", dimstyle->DIMTZIN, DIMTZIN);
    DIMTZIN++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMTZIN", &DIMTZIN, 0)
        && DIMTZIN == dimstyle->DIMTZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMTZIN [BS] set+1 %hu != %hu", dimstyle->DIMTZIN, DIMTZIN);
    dimstyle->DIMTZIN--;
  }
  {
    BITCODE_BS DIMUNIT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMUNIT", &DIMUNIT, NULL)
        && DIMUNIT == dimstyle->DIMUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMUNIT [BS] %hu != %hu", dimstyle->DIMUNIT, DIMUNIT);
    DIMUNIT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMUNIT", &DIMUNIT, 0)
        && DIMUNIT == dimstyle->DIMUNIT)
      pass ();
    else
      fail ("DIMSTYLE.DIMUNIT [BS] set+1 %hu != %hu", dimstyle->DIMUNIT, DIMUNIT);
    dimstyle->DIMUNIT--;
  }
  {
    BITCODE_B DIMUPT;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMUPT", &DIMUPT, NULL)
        && DIMUPT == dimstyle->DIMUPT)
      pass ();
    else
      fail ("DIMSTYLE.DIMUPT [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMUPT, DIMUPT);
    DIMUPT++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMUPT", &DIMUPT, 0)
        && DIMUPT == dimstyle->DIMUPT)
      pass ();
    else
      fail ("DIMSTYLE.DIMUPT [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->DIMUPT, DIMUPT);
    dimstyle->DIMUPT--;
  }
  {
    BITCODE_BS DIMZIN;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "DIMZIN", &DIMZIN, NULL)
        && DIMZIN == dimstyle->DIMZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMZIN [BS] %hu != %hu", dimstyle->DIMZIN, DIMZIN);
    DIMZIN++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "DIMZIN", &DIMZIN, 0)
        && DIMZIN == dimstyle->DIMZIN)
      pass ();
    else
      fail ("DIMSTYLE.DIMZIN [BS] set+1 %hu != %hu", dimstyle->DIMZIN, DIMZIN);
    dimstyle->DIMZIN--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "flag", &flag, NULL)
        && flag == dimstyle->flag)
      pass ();
    else
      fail ("DIMSTYLE.flag [RC] %u != %u", dimstyle->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "flag", &flag, 0)
        && flag == dimstyle->flag)
      pass ();
    else
      fail ("DIMSTYLE.flag [RC] set+1 %u != %u", dimstyle->flag, flag);
    dimstyle->flag--;
  }
  {
    BITCODE_B flag0;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "flag0", &flag0, NULL)
        && flag0 == dimstyle->flag0)
      pass ();
    else
      fail ("DIMSTYLE.flag0 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->flag0, flag0);
    flag0++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "flag0", &flag0, 0)
        && flag0 == dimstyle->flag0)
      pass ();
    else
      fail ("DIMSTYLE.flag0 [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->flag0, flag0);
    dimstyle->flag0--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == dimstyle->is_xref_dep)
      pass ();
    else
      fail ("DIMSTYLE.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", dimstyle->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == dimstyle->is_xref_dep)
      pass ();
    else
      fail ("DIMSTYLE.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->is_xref_dep, is_xref_dep);
    dimstyle->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == dimstyle->is_xref_ref)
      pass ();
    else
      fail ("DIMSTYLE.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", dimstyle->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == dimstyle->is_xref_ref)
      pass ();
    else
      fail ("DIMSTYLE.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", dimstyle->is_xref_ref, is_xref_ref);
    dimstyle->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == dimstyle->is_xref_resolved)
      pass ();
    else
      fail ("DIMSTYLE.is_xref_resolved [BS] %hu != %hu", dimstyle->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == dimstyle->is_xref_resolved)
      pass ();
    else
      fail ("DIMSTYLE.is_xref_resolved [BS] set+1 %hu != %hu", dimstyle->is_xref_resolved, is_xref_resolved);
    dimstyle->is_xref_resolved--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)dimstyle->name)
           : !dimstyle->name)
      pass ();
    else
      fail ("DIMSTYLE.name [T] '%s' <> '%s'", name, dimstyle->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &dimstyle->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DIMSTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "used", &used, NULL)
        && used == dimstyle->used)
      pass ();
    else
      fail ("DIMSTYLE.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", dimstyle->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (dimstyle, "DIMSTYLE", "used", &used, 0)
        && used == dimstyle->used)
      pass ();
    else
      fail ("DIMSTYLE.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", dimstyle->used, used);
    dimstyle->used--;
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (dimstyle, "DIMSTYLE", "xref", &xref, NULL)
        && !memcmp (&xref, &dimstyle->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DIMSTYLE.xref [H]");
  }
  if (failed && (is_class_unstable ("DIMSTYLE") || is_class_debugging ("DIMSTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMSTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DIMSTYLE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DIMSTYLE_CONTROL *restrict dimstyle_control = obj->tio.object->tio.DIMSTYLE_CONTROL;
  failed = 0;
  if (!obj_obj || !dimstyle_control)
    {
      fail ("NULL DIMSTYLE_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "entries", &entries, NULL)
        && entries == dimstyle_control->entries)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == dimstyle_control->flags_r11)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.flags_r11 [RS] %hu != %hu", dimstyle_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (dimstyle_control, "DIMSTYLE_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == dimstyle_control->flags_r11)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.flags_r11 [RS] set+1 %hu != %hu", dimstyle_control->flags_r11, flags_r11);
    dimstyle_control->flags_r11--;
  }
  {
    BITCODE_H* morehandles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &count, NULL)
        && dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "morehandles", &morehandles, NULL)
        && morehandles == dimstyle_control->morehandles)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.morehandles [H*] * %u num_morehandles", count);
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == dimstyle_control->num_entries)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.num_entries [BS] %hu != %hu", dimstyle_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == dimstyle_control->num_entries)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.num_entries [BS] set+1 %hu != %hu", dimstyle_control->num_entries, num_entries);
    dimstyle_control->num_entries--;
  }
  {
    BITCODE_RC num_morehandles;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &num_morehandles, NULL)
        && num_morehandles == dimstyle_control->num_morehandles)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.num_morehandles [RC] %u != %u", dimstyle_control->num_morehandles, num_morehandles);
    num_morehandles++;
    if (dwg_dynapi_entity_set_value (dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &num_morehandles, 0)
        && num_morehandles == dimstyle_control->num_morehandles)
      pass ();
    else
      fail ("DIMSTYLE_CONTROL.num_morehandles [RC] set+1 %u != %u", dimstyle_control->num_morehandles, num_morehandles);
    dimstyle_control->num_morehandles--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dimstyle_control, "DIMSTYLE_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &dimstyle_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DIMSTYLE_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DIMSTYLE_CONTROL") || is_class_debugging ("DIMSTYLE_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DIMSTYLE_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_DMDIMOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DMDIMOBJECTCONTEXTDATA *restrict dmdimobjectcontextdata = obj->tio.object->tio.DMDIMOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !dmdimobjectcontextdata)
    {
      fail ("NULL DMDIMOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == dmdimobjectcontextdata->class_version)
      pass ();
    else
      fail ("DMDIMOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", dmdimobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == dmdimobjectcontextdata->class_version)
      pass ();
    else
      fail ("DMDIMOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", dmdimobjectcontextdata->class_version, class_version);
    dmdimobjectcontextdata->class_version--;
  }
  {
    BITCODE_3BD def_pt;
    if (dwg_dynapi_entity_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "def_pt", &def_pt, NULL)
        && !memcmp (&def_pt, &dmdimobjectcontextdata->def_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DMDIMOBJECTCONTEXTDATA.def_pt [3BD]");
  }
  {
    Dwg_OCD_Dimension dimension;
    if (dwg_dynapi_entity_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "dimension", &dimension, NULL)
        && !memcmp (&dimension, &dmdimobjectcontextdata->dimension, sizeof (Dwg_OCD_Dimension)))
        pass ();
    else
        fail ("DMDIMOBJECTCONTEXTDATA.dimension [Dwg_OCD_Dimension]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &dmdimobjectcontextdata->first_arc_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("DMDIMOBJECTCONTEXTDATA.first_arc_pt [3BD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == dmdimobjectcontextdata->is_default)
      pass ();
    else
      fail ("DMDIMOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", dmdimobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == dmdimobjectcontextdata->is_default)
      pass ();
    else
      fail ("DMDIMOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", dmdimobjectcontextdata->is_default, is_default);
    dmdimobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &dmdimobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DMDIMOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (dmdimobjectcontextdata, "DMDIMOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &dmdimobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DMDIMOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("DMDIMOBJECTCONTEXTDATA") || is_class_debugging ("DMDIMOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DMDIMOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_DUMMY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DUMMY *restrict dummy = obj->tio.object->tio.DUMMY;
  failed = 0;
  if (!obj_obj || !dummy)
    {
      fail ("NULL DUMMY");
      return 1;
    }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dummy, "DUMMY", "parent", &parent, NULL)
        && !memcmp (&parent, &dummy->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DUMMY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DUMMY") || is_class_debugging ("DUMMY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DUMMY", failed);
      failed = 0;
    }
  return failed;
}
static int test_DYNAMICBLOCKPROXYNODE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DYNAMICBLOCKPROXYNODE *restrict dynamicblockproxynode = obj->tio.object->tio.DYNAMICBLOCKPROXYNODE;
  failed = 0;
  if (!obj_obj || !dynamicblockproxynode)
    {
      fail ("NULL DYNAMICBLOCKPROXYNODE");
      return 1;
    }
  {
    Dwg_EvalExpr evalexpr;
    if (dwg_dynapi_entity_value (dynamicblockproxynode, "DYNAMICBLOCKPROXYNODE", "evalexpr", &evalexpr, NULL)
        && !memcmp (&evalexpr, &dynamicblockproxynode->evalexpr, sizeof (Dwg_EvalExpr)))
        pass ();
    else
        fail ("DYNAMICBLOCKPROXYNODE.evalexpr [Dwg_EvalExpr]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dynamicblockproxynode, "DYNAMICBLOCKPROXYNODE", "parent", &parent, NULL)
        && !memcmp (&parent, &dynamicblockproxynode->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DYNAMICBLOCKPROXYNODE.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DYNAMICBLOCKPROXYNODE") || is_class_debugging ("DYNAMICBLOCKPROXYNODE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DYNAMICBLOCKPROXYNODE", failed);
      failed = 0;
    }
  return failed;
}
static int test_DYNAMICBLOCKPURGEPREVENTER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DYNAMICBLOCKPURGEPREVENTER *restrict dynamicblockpurgepreventer = obj->tio.object->tio.DYNAMICBLOCKPURGEPREVENTER;
  failed = 0;
  if (!obj_obj || !dynamicblockpurgepreventer)
    {
      fail ("NULL DYNAMICBLOCKPURGEPREVENTER");
      return 1;
    }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "block", &block, NULL)
        && !memcmp (&block, &dynamicblockpurgepreventer->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("DYNAMICBLOCKPURGEPREVENTER.block [H]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "flag", &flag, NULL)
        && flag == dynamicblockpurgepreventer->flag)
      pass ();
    else
      fail ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] %hu != %hu", dynamicblockpurgepreventer->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "flag", &flag, 0)
        && flag == dynamicblockpurgepreventer->flag)
      pass ();
    else
      fail ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] set+1 %hu != %hu", dynamicblockpurgepreventer->flag, flag);
    dynamicblockpurgepreventer->flag--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "parent", &parent, NULL)
        && !memcmp (&parent, &dynamicblockpurgepreventer->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("DYNAMICBLOCKPURGEPREVENTER.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("DYNAMICBLOCKPURGEPREVENTER") || is_class_debugging ("DYNAMICBLOCKPURGEPREVENTER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DYNAMICBLOCKPURGEPREVENTER", failed);
      failed = 0;
    }
  return failed;
}
static int test_EVALUATION_GRAPH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_EVALUATION_GRAPH *restrict evaluation_graph = obj->tio.object->tio.EVALUATION_GRAPH;
  failed = 0;
  if (!obj_obj || !evaluation_graph)
    {
      fail ("NULL EVALUATION_GRAPH");
      return 1;
    }
  {
    Dwg_EVAL_Edge* edges;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "num_edges", &count, NULL)
        && dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "edges", &edges, NULL)
        && edges == evaluation_graph->edges)
      pass ();
    else
      fail ("EVALUATION_GRAPH.edges [Dwg_EVAL_Edge*] * %u num_edges", count);
  }
  {
    BITCODE_BLd first_nodeid;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "first_nodeid", &first_nodeid, NULL)
        && first_nodeid == evaluation_graph->first_nodeid)
      pass ();
    else
      fail ("EVALUATION_GRAPH.first_nodeid [BLd] " FORMAT_BLd " != " FORMAT_BLd "", evaluation_graph->first_nodeid, first_nodeid);
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "first_nodeid", &first_nodeid, 0)
        && first_nodeid == evaluation_graph->first_nodeid)
      pass ();
    else
      fail ("EVALUATION_GRAPH.first_nodeid [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", evaluation_graph->first_nodeid, first_nodeid);
    evaluation_graph->first_nodeid--;
  }
  {
    BITCODE_BLd first_nodeid_copy;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "first_nodeid_copy", &first_nodeid_copy, NULL)
        && first_nodeid_copy == evaluation_graph->first_nodeid_copy)
      pass ();
    else
      fail ("EVALUATION_GRAPH.first_nodeid_copy [BLd] " FORMAT_BLd " != " FORMAT_BLd "", evaluation_graph->first_nodeid_copy, first_nodeid_copy);
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "first_nodeid_copy", &first_nodeid_copy, 0)
        && first_nodeid_copy == evaluation_graph->first_nodeid_copy)
      pass ();
    else
      fail ("EVALUATION_GRAPH.first_nodeid_copy [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", evaluation_graph->first_nodeid_copy, first_nodeid_copy);
    evaluation_graph->first_nodeid_copy--;
  }
  {
    BITCODE_B has_graph;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "has_graph", &has_graph, NULL)
        && has_graph == evaluation_graph->has_graph)
      pass ();
    else
      fail ("EVALUATION_GRAPH.has_graph [B] " FORMAT_B " != " FORMAT_B "", evaluation_graph->has_graph, has_graph);
    has_graph++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "has_graph", &has_graph, 0)
        && has_graph == evaluation_graph->has_graph)
      pass ();
    else
      fail ("EVALUATION_GRAPH.has_graph [B] set+1 " FORMAT_B " != " FORMAT_B "", evaluation_graph->has_graph, has_graph);
    evaluation_graph->has_graph--;
  }
  {
    BITCODE_BL major;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "major", &major, NULL)
        && major == evaluation_graph->major)
      pass ();
    else
      fail ("EVALUATION_GRAPH.major [BL] %u != %u", evaluation_graph->major, major);
    major++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "major", &major, 0)
        && major == evaluation_graph->major)
      pass ();
    else
      fail ("EVALUATION_GRAPH.major [BL] set+1 %u != %u", evaluation_graph->major, major);
    evaluation_graph->major--;
  }
  {
    BITCODE_BL minor;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "minor", &minor, NULL)
        && minor == evaluation_graph->minor)
      pass ();
    else
      fail ("EVALUATION_GRAPH.minor [BL] %u != %u", evaluation_graph->minor, minor);
    minor++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "minor", &minor, 0)
        && minor == evaluation_graph->minor)
      pass ();
    else
      fail ("EVALUATION_GRAPH.minor [BL] set+1 %u != %u", evaluation_graph->minor, minor);
    evaluation_graph->minor--;
  }
  {
    Dwg_EVAL_Node* nodes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "num_nodes", &count, NULL)
        && dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "nodes", &nodes, NULL)
        && nodes == evaluation_graph->nodes)
      pass ();
    else
      fail ("EVALUATION_GRAPH.nodes [Dwg_EVAL_Node*] * %u num_nodes", count);
  }
  {
    BITCODE_BL num_edges;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "num_edges", &num_edges, NULL)
        && num_edges == evaluation_graph->num_edges)
      pass ();
    else
      fail ("EVALUATION_GRAPH.num_edges [BL] %u != %u", evaluation_graph->num_edges, num_edges);
    num_edges++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "num_edges", &num_edges, 0)
        && num_edges == evaluation_graph->num_edges)
      pass ();
    else
      fail ("EVALUATION_GRAPH.num_edges [BL] set+1 %u != %u", evaluation_graph->num_edges, num_edges);
    evaluation_graph->num_edges--;
  }
  {
    BITCODE_BL num_nodes;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "num_nodes", &num_nodes, NULL)
        && num_nodes == evaluation_graph->num_nodes)
      pass ();
    else
      fail ("EVALUATION_GRAPH.num_nodes [BL] %u != %u", evaluation_graph->num_nodes, num_nodes);
    num_nodes++;
    if (dwg_dynapi_entity_set_value (evaluation_graph, "EVALUATION_GRAPH", "num_nodes", &num_nodes, 0)
        && num_nodes == evaluation_graph->num_nodes)
      pass ();
    else
      fail ("EVALUATION_GRAPH.num_nodes [BL] set+1 %u != %u", evaluation_graph->num_nodes, num_nodes);
    evaluation_graph->num_nodes--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (evaluation_graph, "EVALUATION_GRAPH", "parent", &parent, NULL)
        && !memcmp (&parent, &evaluation_graph->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("EVALUATION_GRAPH.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("EVALUATION_GRAPH") || is_class_debugging ("EVALUATION_GRAPH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "EVALUATION_GRAPH", failed);
      failed = 0;
    }
  return failed;
}
static int test_FCFOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_FCFOBJECTCONTEXTDATA *restrict fcfobjectcontextdata = obj->tio.object->tio.FCFOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !fcfobjectcontextdata)
    {
      fail ("NULL FCFOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (fcfobjectcontextdata, "FCFOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == fcfobjectcontextdata->class_version)
      pass ();
    else
      fail ("FCFOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", fcfobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (fcfobjectcontextdata, "FCFOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == fcfobjectcontextdata->class_version)
      pass ();
    else
      fail ("FCFOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", fcfobjectcontextdata->class_version, class_version);
    fcfobjectcontextdata->class_version--;
  }
  {
    BITCODE_3BD horiz_dir;
    if (dwg_dynapi_entity_value (fcfobjectcontextdata, "FCFOBJECTCONTEXTDATA", "horiz_dir", &horiz_dir, NULL)
        && !memcmp (&horiz_dir, &fcfobjectcontextdata->horiz_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("FCFOBJECTCONTEXTDATA.horiz_dir [3BD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (fcfobjectcontextdata, "FCFOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == fcfobjectcontextdata->is_default)
      pass ();
    else
      fail ("FCFOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", fcfobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (fcfobjectcontextdata, "FCFOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == fcfobjectcontextdata->is_default)
      pass ();
    else
      fail ("FCFOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", fcfobjectcontextdata->is_default, is_default);
    fcfobjectcontextdata->is_default--;
  }
  {
    BITCODE_3BD location;
    if (dwg_dynapi_entity_value (fcfobjectcontextdata, "FCFOBJECTCONTEXTDATA", "location", &location, NULL)
        && !memcmp (&location, &fcfobjectcontextdata->location, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("FCFOBJECTCONTEXTDATA.location [3BD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (fcfobjectcontextdata, "FCFOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &fcfobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("FCFOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (fcfobjectcontextdata, "FCFOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &fcfobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("FCFOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("FCFOBJECTCONTEXTDATA") || is_class_debugging ("FCFOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "FCFOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_FIELD (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_FIELD *restrict field = obj->tio.object->tio.FIELD;
  failed = 0;
  if (!obj_obj || !field)
    {
      fail ("NULL FIELD");
      return 1;
    }
  {
    BITCODE_H* childs;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_childs", &count, NULL)
        && dwg_dynapi_entity_value (field, "FIELD", "childs", &childs, NULL)
        && childs == field->childs)
      pass ();
    else
      fail ("FIELD.childs [H*] * %u num_childs", count);
  }
  {
    Dwg_FIELD_ChildValue* childval;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_childval", &count, NULL)
        && dwg_dynapi_entity_value (field, "FIELD", "childval", &childval, NULL)
        && childval == field->childval)
      pass ();
    else
      fail ("FIELD.childval [Dwg_FIELD_ChildValue*] * %u num_childval", count);
  }
  {
    BITCODE_T code;
    if (dwg_dynapi_entity_value (field, "FIELD", "code", &code, NULL)
        && code
           ? strEQ ((char *)code, (char *)field->code)
           : !field->code)
      pass ();
    else
      fail ("FIELD.code [T] '%s' <> '%s'", code, field->code);
  }
  {
    BITCODE_BL evaluation_error_code;
    if (dwg_dynapi_entity_value (field, "FIELD", "evaluation_error_code", &evaluation_error_code, NULL)
        && evaluation_error_code == field->evaluation_error_code)
      pass ();
    else
      fail ("FIELD.evaluation_error_code [BL] %u != %u", field->evaluation_error_code, evaluation_error_code);
    evaluation_error_code++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "evaluation_error_code", &evaluation_error_code, 0)
        && evaluation_error_code == field->evaluation_error_code)
      pass ();
    else
      fail ("FIELD.evaluation_error_code [BL] set+1 %u != %u", field->evaluation_error_code, evaluation_error_code);
    field->evaluation_error_code--;
  }
  {
    BITCODE_T evaluation_error_msg;
    if (dwg_dynapi_entity_value (field, "FIELD", "evaluation_error_msg", &evaluation_error_msg, NULL)
        && evaluation_error_msg
           ? strEQ ((char *)evaluation_error_msg, (char *)field->evaluation_error_msg)
           : !field->evaluation_error_msg)
      pass ();
    else
      fail ("FIELD.evaluation_error_msg [T] '%s' <> '%s'", evaluation_error_msg, field->evaluation_error_msg);
  }
  {
    BITCODE_BL evaluation_option;
    if (dwg_dynapi_entity_value (field, "FIELD", "evaluation_option", &evaluation_option, NULL)
        && evaluation_option == field->evaluation_option)
      pass ();
    else
      fail ("FIELD.evaluation_option [BL] %u != %u", field->evaluation_option, evaluation_option);
    evaluation_option++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "evaluation_option", &evaluation_option, 0)
        && evaluation_option == field->evaluation_option)
      pass ();
    else
      fail ("FIELD.evaluation_option [BL] set+1 %u != %u", field->evaluation_option, evaluation_option);
    field->evaluation_option--;
  }
  {
    BITCODE_BL evaluation_status;
    if (dwg_dynapi_entity_value (field, "FIELD", "evaluation_status", &evaluation_status, NULL)
        && evaluation_status == field->evaluation_status)
      pass ();
    else
      fail ("FIELD.evaluation_status [BL] %u != %u", field->evaluation_status, evaluation_status);
    evaluation_status++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "evaluation_status", &evaluation_status, 0)
        && evaluation_status == field->evaluation_status)
      pass ();
    else
      fail ("FIELD.evaluation_status [BL] set+1 %u != %u", field->evaluation_status, evaluation_status);
    field->evaluation_status--;
  }
  {
    BITCODE_BL field_state;
    if (dwg_dynapi_entity_value (field, "FIELD", "field_state", &field_state, NULL)
        && field_state == field->field_state)
      pass ();
    else
      fail ("FIELD.field_state [BL] %u != %u", field->field_state, field_state);
    field_state++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "field_state", &field_state, 0)
        && field_state == field->field_state)
      pass ();
    else
      fail ("FIELD.field_state [BL] set+1 %u != %u", field->field_state, field_state);
    field->field_state--;
  }
  {
    BITCODE_BL filing_option;
    if (dwg_dynapi_entity_value (field, "FIELD", "filing_option", &filing_option, NULL)
        && filing_option == field->filing_option)
      pass ();
    else
      fail ("FIELD.filing_option [BL] %u != %u", field->filing_option, filing_option);
    filing_option++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "filing_option", &filing_option, 0)
        && filing_option == field->filing_option)
      pass ();
    else
      fail ("FIELD.filing_option [BL] set+1 %u != %u", field->filing_option, filing_option);
    field->filing_option--;
  }
  {
    BITCODE_TV format;
    if (dwg_dynapi_entity_value (field, "FIELD", "format", &format, NULL)
        && format
           ? strEQ ((char *)format, (char *)field->format)
           : !field->format)
      pass ();
    else
      fail ("FIELD.format [TV] '%s' <> '%s'", format, field->format);
  }
  {
    BITCODE_T id;
    if (dwg_dynapi_entity_value (field, "FIELD", "id", &id, NULL)
        && id
           ? strEQ ((char *)id, (char *)field->id)
           : !field->id)
      pass ();
    else
      fail ("FIELD.id [T] '%s' <> '%s'", id, field->id);
  }
  {
    BITCODE_BL num_childs;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_childs", &num_childs, NULL)
        && num_childs == field->num_childs)
      pass ();
    else
      fail ("FIELD.num_childs [BL] %u != %u", field->num_childs, num_childs);
    num_childs++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "num_childs", &num_childs, 0)
        && num_childs == field->num_childs)
      pass ();
    else
      fail ("FIELD.num_childs [BL] set+1 %u != %u", field->num_childs, num_childs);
    field->num_childs--;
  }
  {
    BITCODE_BL num_childval;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_childval", &num_childval, NULL)
        && num_childval == field->num_childval)
      pass ();
    else
      fail ("FIELD.num_childval [BL] %u != %u", field->num_childval, num_childval);
    num_childval++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "num_childval", &num_childval, 0)
        && num_childval == field->num_childval)
      pass ();
    else
      fail ("FIELD.num_childval [BL] set+1 %u != %u", field->num_childval, num_childval);
    field->num_childval--;
  }
  {
    BITCODE_BL num_objects;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_objects", &num_objects, NULL)
        && num_objects == field->num_objects)
      pass ();
    else
      fail ("FIELD.num_objects [BL] %u != %u", field->num_objects, num_objects);
    num_objects++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "num_objects", &num_objects, 0)
        && num_objects == field->num_objects)
      pass ();
    else
      fail ("FIELD.num_objects [BL] set+1 %u != %u", field->num_objects, num_objects);
    field->num_objects--;
  }
  {
    BITCODE_H* objects;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (field, "FIELD", "num_objects", &count, NULL)
        && dwg_dynapi_entity_value (field, "FIELD", "objects", &objects, NULL)
        && objects == field->objects)
      pass ();
    else
      fail ("FIELD.objects [H*] * %u num_objects", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (field, "FIELD", "parent", &parent, NULL)
        && !memcmp (&parent, &field->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("FIELD.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_TABLE_value value;
    if (dwg_dynapi_entity_value (field, "FIELD", "value", &value, NULL)
        && !memcmp (&value, &field->value, sizeof (Dwg_TABLE_value)))
        pass ();
    else
        fail ("FIELD.value [Dwg_TABLE_value]");
  }
  {
    BITCODE_T value_string;
    if (dwg_dynapi_entity_value (field, "FIELD", "value_string", &value_string, NULL)
        && value_string
           ? strEQ ((char *)value_string, (char *)field->value_string)
           : !field->value_string)
      pass ();
    else
      fail ("FIELD.value_string [T] '%s' <> '%s'", value_string, field->value_string);
  }
  {
    BITCODE_BL value_string_length;
    if (dwg_dynapi_entity_value (field, "FIELD", "value_string_length", &value_string_length, NULL)
        && value_string_length == field->value_string_length)
      pass ();
    else
      fail ("FIELD.value_string_length [BL] %u != %u", field->value_string_length, value_string_length);
    value_string_length++;
    if (dwg_dynapi_entity_set_value (field, "FIELD", "value_string_length", &value_string_length, 0)
        && value_string_length == field->value_string_length)
      pass ();
    else
      fail ("FIELD.value_string_length [BL] set+1 %u != %u", field->value_string_length, value_string_length);
    field->value_string_length--;
  }
  if (failed && (is_class_unstable ("FIELD") || is_class_debugging ("FIELD")))
    {
      ok ("%s failed %d tests (TODO unstable)", "FIELD", failed);
      failed = 0;
    }
  return failed;
}
static int test_FIELDLIST (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_FIELDLIST *restrict fieldlist = obj->tio.object->tio.FIELDLIST;
  failed = 0;
  if (!obj_obj || !fieldlist)
    {
      fail ("NULL FIELDLIST");
      return 1;
    }
  {
    BITCODE_H* fields;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "num_fields", &count, NULL)
        && dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "fields", &fields, NULL)
        && fields == fieldlist->fields)
      pass ();
    else
      fail ("FIELDLIST.fields [H*] * %u num_fields", count);
  }
  {
    BITCODE_BL num_fields;
    if (dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "num_fields", &num_fields, NULL)
        && num_fields == fieldlist->num_fields)
      pass ();
    else
      fail ("FIELDLIST.num_fields [BL] %u != %u", fieldlist->num_fields, num_fields);
    num_fields++;
    if (dwg_dynapi_entity_set_value (fieldlist, "FIELDLIST", "num_fields", &num_fields, 0)
        && num_fields == fieldlist->num_fields)
      pass ();
    else
      fail ("FIELDLIST.num_fields [BL] set+1 %u != %u", fieldlist->num_fields, num_fields);
    fieldlist->num_fields--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "parent", &parent, NULL)
        && !memcmp (&parent, &fieldlist->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("FIELDLIST.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value (fieldlist, "FIELDLIST", "unknown", &unknown, NULL)
        && unknown == fieldlist->unknown)
      pass ();
    else
      fail ("FIELDLIST.unknown [B] " FORMAT_B " != " FORMAT_B "", fieldlist->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (fieldlist, "FIELDLIST", "unknown", &unknown, 0)
        && unknown == fieldlist->unknown)
      pass ();
    else
      fail ("FIELDLIST.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", fieldlist->unknown, unknown);
    fieldlist->unknown--;
  }
  if (failed && (is_class_unstable ("FIELDLIST") || is_class_debugging ("FIELDLIST")))
    {
      ok ("%s failed %d tests (TODO unstable)", "FIELDLIST", failed);
      failed = 0;
    }
  return failed;
}
static int test_GEODATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_GEODATA *restrict geodata = obj->tio.object->tio.GEODATA;
  failed = 0;
  if (!obj_obj || !geodata)
    {
      fail ("NULL GEODATA");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "class_version", &class_version, NULL)
        && class_version == geodata->class_version)
      pass ();
    else
      fail ("GEODATA.class_version [BL] %u != %u", geodata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "class_version", &class_version, 0)
        && class_version == geodata->class_version)
      pass ();
    else
      fail ("GEODATA.class_version [BL] set+1 %u != %u", geodata->class_version, class_version);
    geodata->class_version--;
  }
  {
    BITCODE_BD coord_proj_radius;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_proj_radius", &coord_proj_radius, NULL)
        && coord_proj_radius == geodata->coord_proj_radius)
      pass ();
    else
      fail ("GEODATA.coord_proj_radius [BD] %g != %g", geodata->coord_proj_radius, coord_proj_radius);
    coord_proj_radius++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "coord_proj_radius", &coord_proj_radius, 0)
        && coord_proj_radius == geodata->coord_proj_radius)
      pass ();
    else
      fail ("GEODATA.coord_proj_radius [BD] set+1 %g != %g", geodata->coord_proj_radius, coord_proj_radius);
    geodata->coord_proj_radius--;
  }
  {
    BITCODE_T coord_system_datum;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_system_datum", &coord_system_datum, NULL)
        && coord_system_datum
           ? strEQ ((char *)coord_system_datum, (char *)geodata->coord_system_datum)
           : !geodata->coord_system_datum)
      pass ();
    else
      fail ("GEODATA.coord_system_datum [T] '%s' <> '%s'", coord_system_datum, geodata->coord_system_datum);
  }
  {
    BITCODE_T coord_system_def;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_system_def", &coord_system_def, NULL)
        && coord_system_def
           ? strEQ ((char *)coord_system_def, (char *)geodata->coord_system_def)
           : !geodata->coord_system_def)
      pass ();
    else
      fail ("GEODATA.coord_system_def [T] '%s' <> '%s'", coord_system_def, geodata->coord_system_def);
  }
  {
    BITCODE_T coord_system_wkt;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_system_wkt", &coord_system_wkt, NULL)
        && coord_system_wkt
           ? strEQ ((char *)coord_system_wkt, (char *)geodata->coord_system_wkt)
           : !geodata->coord_system_wkt)
      pass ();
    else
      fail ("GEODATA.coord_system_wkt [T] '%s' <> '%s'", coord_system_wkt, geodata->coord_system_wkt);
  }
  {
    BITCODE_BS coord_type;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "coord_type", &coord_type, NULL)
        && coord_type == geodata->coord_type)
      pass ();
    else
      fail ("GEODATA.coord_type [BS] %hu != %hu", geodata->coord_type, coord_type);
    coord_type++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "coord_type", &coord_type, 0)
        && coord_type == geodata->coord_type)
      pass ();
    else
      fail ("GEODATA.coord_type [BS] set+1 %hu != %hu", geodata->coord_type, coord_type);
    geodata->coord_type--;
  }
  {
    BITCODE_3BD design_pt;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "design_pt", &design_pt, NULL)
        && !memcmp (&design_pt, &geodata->design_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEODATA.design_pt [3BD]");
  }
  {
    BITCODE_B do_sea_level_corr;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "do_sea_level_corr", &do_sea_level_corr, NULL)
        && do_sea_level_corr == geodata->do_sea_level_corr)
      pass ();
    else
      fail ("GEODATA.do_sea_level_corr [B] " FORMAT_B " != " FORMAT_B "", geodata->do_sea_level_corr, do_sea_level_corr);
    do_sea_level_corr++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "do_sea_level_corr", &do_sea_level_corr, 0)
        && do_sea_level_corr == geodata->do_sea_level_corr)
      pass ();
    else
      fail ("GEODATA.do_sea_level_corr [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->do_sea_level_corr, do_sea_level_corr);
    geodata->do_sea_level_corr--;
  }
  {
    BITCODE_T geo_rss_tag;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "geo_rss_tag", &geo_rss_tag, NULL)
        && geo_rss_tag
           ? strEQ ((char *)geo_rss_tag, (char *)geodata->geo_rss_tag)
           : !geodata->geo_rss_tag)
      pass ();
    else
      fail ("GEODATA.geo_rss_tag [T] '%s' <> '%s'", geo_rss_tag, geodata->geo_rss_tag);
  }
  {
    Dwg_GEODATA_meshface* geomesh_faces;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "num_geomesh_faces", &count, NULL)
        && dwg_dynapi_entity_value (geodata, "GEODATA", "geomesh_faces", &geomesh_faces, NULL)
        && geomesh_faces == geodata->geomesh_faces)
      pass ();
    else
      fail ("GEODATA.geomesh_faces [Dwg_GEODATA_meshface*] * %u num_geomesh_faces", count);
  }
  {
    Dwg_GEODATA_meshpt* geomesh_pts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "num_geomesh_pts", &count, NULL)
        && dwg_dynapi_entity_value (geodata, "GEODATA", "geomesh_pts", &geomesh_pts, NULL)
        && geomesh_pts == geodata->geomesh_pts)
      pass ();
    else
      fail ("GEODATA.geomesh_pts [Dwg_GEODATA_meshpt*] * %u num_geomesh_pts", count);
  }
  {
    BITCODE_B has_civil_data;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "has_civil_data", &has_civil_data, NULL)
        && has_civil_data == geodata->has_civil_data)
      pass ();
    else
      fail ("GEODATA.has_civil_data [B] " FORMAT_B " != " FORMAT_B "", geodata->has_civil_data, has_civil_data);
    has_civil_data++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "has_civil_data", &has_civil_data, 0)
        && has_civil_data == geodata->has_civil_data)
      pass ();
    else
      fail ("GEODATA.has_civil_data [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->has_civil_data, has_civil_data);
    geodata->has_civil_data--;
  }
  {
    BITCODE_H host_block;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "host_block", &host_block, NULL)
        && !memcmp (&host_block, &geodata->host_block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("GEODATA.host_block [H]");
  }
  {
    BITCODE_3BD north_dir;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "north_dir", &north_dir, NULL)
        && !memcmp (&north_dir, &geodata->north_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEODATA.north_dir [3BD]");
  }
  {
    BITCODE_BD north_dir_angle_deg;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "north_dir_angle_deg", &north_dir_angle_deg, NULL)
        && north_dir_angle_deg == geodata->north_dir_angle_deg)
      pass ();
    else
      fail ("GEODATA.north_dir_angle_deg [BD] %g != %g", geodata->north_dir_angle_deg, north_dir_angle_deg);
    north_dir_angle_deg++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "north_dir_angle_deg", &north_dir_angle_deg, 0)
        && north_dir_angle_deg == geodata->north_dir_angle_deg)
      pass ();
    else
      fail ("GEODATA.north_dir_angle_deg [BD] set+1 %g != %g", geodata->north_dir_angle_deg, north_dir_angle_deg);
    geodata->north_dir_angle_deg--;
  }
  {
    BITCODE_BD north_dir_angle_rad;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "north_dir_angle_rad", &north_dir_angle_rad, NULL)
        && north_dir_angle_rad == geodata->north_dir_angle_rad)
      pass ();
    else
      fail ("GEODATA.north_dir_angle_rad [BD] %g != %g", geodata->north_dir_angle_rad, north_dir_angle_rad);
    north_dir_angle_rad++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "north_dir_angle_rad", &north_dir_angle_rad, 0)
        && north_dir_angle_rad == geodata->north_dir_angle_rad)
      pass ();
    else
      fail ("GEODATA.north_dir_angle_rad [BD] set+1 %g != %g", geodata->north_dir_angle_rad, north_dir_angle_rad);
    geodata->north_dir_angle_rad--;
  }
  {
    BITCODE_BL num_geomesh_faces;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "num_geomesh_faces", &num_geomesh_faces, NULL)
        && num_geomesh_faces == geodata->num_geomesh_faces)
      pass ();
    else
      fail ("GEODATA.num_geomesh_faces [BL] %u != %u", geodata->num_geomesh_faces, num_geomesh_faces);
    num_geomesh_faces++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "num_geomesh_faces", &num_geomesh_faces, 0)
        && num_geomesh_faces == geodata->num_geomesh_faces)
      pass ();
    else
      fail ("GEODATA.num_geomesh_faces [BL] set+1 %u != %u", geodata->num_geomesh_faces, num_geomesh_faces);
    geodata->num_geomesh_faces--;
  }
  {
    BITCODE_BL num_geomesh_pts;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "num_geomesh_pts", &num_geomesh_pts, NULL)
        && num_geomesh_pts == geodata->num_geomesh_pts)
      pass ();
    else
      fail ("GEODATA.num_geomesh_pts [BL] %u != %u", geodata->num_geomesh_pts, num_geomesh_pts);
    num_geomesh_pts++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "num_geomesh_pts", &num_geomesh_pts, 0)
        && num_geomesh_pts == geodata->num_geomesh_pts)
      pass ();
    else
      fail ("GEODATA.num_geomesh_pts [BL] set+1 %u != %u", geodata->num_geomesh_pts, num_geomesh_pts);
    geodata->num_geomesh_pts--;
  }
  {
    BITCODE_3BD obs_pt;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "obs_pt", &obs_pt, NULL)
        && !memcmp (&obs_pt, &geodata->obs_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEODATA.obs_pt [3BD]");
  }
  {
    BITCODE_T observation_coverage_tag;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "observation_coverage_tag", &observation_coverage_tag, NULL)
        && observation_coverage_tag
           ? strEQ ((char *)observation_coverage_tag, (char *)geodata->observation_coverage_tag)
           : !geodata->observation_coverage_tag)
      pass ();
    else
      fail ("GEODATA.observation_coverage_tag [T] '%s' <> '%s'", observation_coverage_tag, geodata->observation_coverage_tag);
  }
  {
    BITCODE_T observation_from_tag;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "observation_from_tag", &observation_from_tag, NULL)
        && observation_from_tag
           ? strEQ ((char *)observation_from_tag, (char *)geodata->observation_from_tag)
           : !geodata->observation_from_tag)
      pass ();
    else
      fail ("GEODATA.observation_from_tag [T] '%s' <> '%s'", observation_from_tag, geodata->observation_from_tag);
  }
  {
    BITCODE_T observation_to_tag;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "observation_to_tag", &observation_to_tag, NULL)
        && observation_to_tag
           ? strEQ ((char *)observation_to_tag, (char *)geodata->observation_to_tag)
           : !geodata->observation_to_tag)
      pass ();
    else
      fail ("GEODATA.observation_to_tag [T] '%s' <> '%s'", observation_to_tag, geodata->observation_to_tag);
  }
  {
    BITCODE_B obsolete_false;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "obsolete_false", &obsolete_false, NULL)
        && obsolete_false == geodata->obsolete_false)
      pass ();
    else
      fail ("GEODATA.obsolete_false [B] " FORMAT_B " != " FORMAT_B "", geodata->obsolete_false, obsolete_false);
    obsolete_false++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "obsolete_false", &obsolete_false, 0)
        && obsolete_false == geodata->obsolete_false)
      pass ();
    else
      fail ("GEODATA.obsolete_false [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->obsolete_false, obsolete_false);
    geodata->obsolete_false--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "parent", &parent, NULL)
        && !memcmp (&parent, &geodata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("GEODATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3BD ref_pt;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "ref_pt", &ref_pt, NULL)
        && !memcmp (&ref_pt, &geodata->ref_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEODATA.ref_pt [3BD_1]");
  }
  {
    BITCODE_2RD ref_pt2d;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "ref_pt2d", &ref_pt2d, NULL)
        && !memcmp (&ref_pt2d, &geodata->ref_pt2d, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("GEODATA.ref_pt2d [2RD]");
  }
  {
    BITCODE_BL scale_est;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "scale_est", &scale_est, NULL)
        && scale_est == geodata->scale_est)
      pass ();
    else
      fail ("GEODATA.scale_est [BL] %u != %u", geodata->scale_est, scale_est);
    scale_est++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "scale_est", &scale_est, 0)
        && scale_est == geodata->scale_est)
      pass ();
    else
      fail ("GEODATA.scale_est [BL] set+1 %u != %u", geodata->scale_est, scale_est);
    geodata->scale_est--;
  }
  {
    BITCODE_3BD scale_vec;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "scale_vec", &scale_vec, NULL)
        && !memcmp (&scale_vec, &geodata->scale_vec, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEODATA.scale_vec [3BD_1]");
  }
  {
    BITCODE_BD sea_level_elev;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "sea_level_elev", &sea_level_elev, NULL)
        && sea_level_elev == geodata->sea_level_elev)
      pass ();
    else
      fail ("GEODATA.sea_level_elev [BD] %g != %g", geodata->sea_level_elev, sea_level_elev);
    sea_level_elev++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "sea_level_elev", &sea_level_elev, 0)
        && sea_level_elev == geodata->sea_level_elev)
      pass ();
    else
      fail ("GEODATA.sea_level_elev [BD] set+1 %g != %g", geodata->sea_level_elev, sea_level_elev);
    geodata->sea_level_elev--;
  }
  {
    BITCODE_BD unit_scale_horiz;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unit_scale_horiz", &unit_scale_horiz, NULL)
        && unit_scale_horiz == geodata->unit_scale_horiz)
      pass ();
    else
      fail ("GEODATA.unit_scale_horiz [BD] %g != %g", geodata->unit_scale_horiz, unit_scale_horiz);
    unit_scale_horiz++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unit_scale_horiz", &unit_scale_horiz, 0)
        && unit_scale_horiz == geodata->unit_scale_horiz)
      pass ();
    else
      fail ("GEODATA.unit_scale_horiz [BD] set+1 %g != %g", geodata->unit_scale_horiz, unit_scale_horiz);
    geodata->unit_scale_horiz--;
  }
  {
    BITCODE_BD unit_scale_vert;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unit_scale_vert", &unit_scale_vert, NULL)
        && unit_scale_vert == geodata->unit_scale_vert)
      pass ();
    else
      fail ("GEODATA.unit_scale_vert [BD] %g != %g", geodata->unit_scale_vert, unit_scale_vert);
    unit_scale_vert++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unit_scale_vert", &unit_scale_vert, 0)
        && unit_scale_vert == geodata->unit_scale_vert)
      pass ();
    else
      fail ("GEODATA.unit_scale_vert [BD] set+1 %g != %g", geodata->unit_scale_vert, unit_scale_vert);
    geodata->unit_scale_vert--;
  }
  {
    BITCODE_BL units_value_horiz;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "units_value_horiz", &units_value_horiz, NULL)
        && units_value_horiz == geodata->units_value_horiz)
      pass ();
    else
      fail ("GEODATA.units_value_horiz [BL] %u != %u", geodata->units_value_horiz, units_value_horiz);
    units_value_horiz++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "units_value_horiz", &units_value_horiz, 0)
        && units_value_horiz == geodata->units_value_horiz)
      pass ();
    else
      fail ("GEODATA.units_value_horiz [BL] set+1 %u != %u", geodata->units_value_horiz, units_value_horiz);
    geodata->units_value_horiz--;
  }
  {
    BITCODE_BL units_value_vert;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "units_value_vert", &units_value_vert, NULL)
        && units_value_vert == geodata->units_value_vert)
      pass ();
    else
      fail ("GEODATA.units_value_vert [BL] %u != %u", geodata->units_value_vert, units_value_vert);
    units_value_vert++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "units_value_vert", &units_value_vert, 0)
        && units_value_vert == geodata->units_value_vert)
      pass ();
    else
      fail ("GEODATA.units_value_vert [BL] set+1 %u != %u", geodata->units_value_vert, units_value_vert);
    geodata->units_value_vert--;
  }
  {
    BITCODE_BL unknown1;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unknown1", &unknown1, NULL)
        && unknown1 == geodata->unknown1)
      pass ();
    else
      fail ("GEODATA.unknown1 [BL] %u != %u", geodata->unknown1, unknown1);
    unknown1++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unknown1", &unknown1, 0)
        && unknown1 == geodata->unknown1)
      pass ();
    else
      fail ("GEODATA.unknown1 [BL] set+1 %u != %u", geodata->unknown1, unknown1);
    geodata->unknown1--;
  }
  {
    BITCODE_BL unknown2;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unknown2", &unknown2, NULL)
        && unknown2 == geodata->unknown2)
      pass ();
    else
      fail ("GEODATA.unknown2 [BL] %u != %u", geodata->unknown2, unknown2);
    unknown2++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unknown2", &unknown2, 0)
        && unknown2 == geodata->unknown2)
      pass ();
    else
      fail ("GEODATA.unknown2 [BL] set+1 %u != %u", geodata->unknown2, unknown2);
    geodata->unknown2--;
  }
  {
    BITCODE_B unknown_b;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "unknown_b", &unknown_b, NULL)
        && unknown_b == geodata->unknown_b)
      pass ();
    else
      fail ("GEODATA.unknown_b [B] " FORMAT_B " != " FORMAT_B "", geodata->unknown_b, unknown_b);
    unknown_b++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "unknown_b", &unknown_b, 0)
        && unknown_b == geodata->unknown_b)
      pass ();
    else
      fail ("GEODATA.unknown_b [B] set+1 " FORMAT_B " != " FORMAT_B "", geodata->unknown_b, unknown_b);
    geodata->unknown_b--;
  }
  {
    BITCODE_3BD up_dir;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "up_dir", &up_dir, NULL)
        && !memcmp (&up_dir, &geodata->up_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEODATA.up_dir [3BD]");
  }
  {
    BITCODE_BD user_scale_factor;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "user_scale_factor", &user_scale_factor, NULL)
        && user_scale_factor == geodata->user_scale_factor)
      pass ();
    else
      fail ("GEODATA.user_scale_factor [BD] %g != %g", geodata->user_scale_factor, user_scale_factor);
    user_scale_factor++;
    if (dwg_dynapi_entity_set_value (geodata, "GEODATA", "user_scale_factor", &user_scale_factor, 0)
        && user_scale_factor == geodata->user_scale_factor)
      pass ();
    else
      fail ("GEODATA.user_scale_factor [BD] set+1 %g != %g", geodata->user_scale_factor, user_scale_factor);
    geodata->user_scale_factor--;
  }
  {
    BITCODE_3BD zero1;
    if (dwg_dynapi_entity_value (geodata, "GEODATA", "zero1", &zero1, NULL)
        && !memcmp (&zero1, &geodata->zero1, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEODATA.zero1 [3BD]");
  }
  if (failed && (is_class_unstable ("GEODATA") || is_class_debugging ("GEODATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GEODATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_GEOMAPIMAGE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_GEOMAPIMAGE *restrict geomapimage = obj->tio.object->tio.GEOMAPIMAGE;
  failed = 0;
  if (!obj_obj || !geomapimage)
    {
      fail ("NULL GEOMAPIMAGE");
      return 1;
    }
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "brightness", &brightness, NULL)
        && brightness == geomapimage->brightness)
      pass ();
    else
      fail ("GEOMAPIMAGE.brightness [RC] %u != %u", geomapimage->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "brightness", &brightness, 0)
        && brightness == geomapimage->brightness)
      pass ();
    else
      fail ("GEOMAPIMAGE.brightness [RC] set+1 %u != %u", geomapimage->brightness, brightness);
    geomapimage->brightness--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "class_version", &class_version, NULL)
        && class_version == geomapimage->class_version)
      pass ();
    else
      fail ("GEOMAPIMAGE.class_version [BL] %u != %u", geomapimage->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "class_version", &class_version, 0)
        && class_version == geomapimage->class_version)
      pass ();
    else
      fail ("GEOMAPIMAGE.class_version [BL] set+1 %u != %u", geomapimage->class_version, class_version);
    geomapimage->class_version--;
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "clipping", &clipping, NULL)
        && clipping == geomapimage->clipping)
      pass ();
    else
      fail ("GEOMAPIMAGE.clipping [B] " FORMAT_B " != " FORMAT_B "", geomapimage->clipping, clipping);
    clipping++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "clipping", &clipping, 0)
        && clipping == geomapimage->clipping)
      pass ();
    else
      fail ("GEOMAPIMAGE.clipping [B] set+1 " FORMAT_B " != " FORMAT_B "", geomapimage->clipping, clipping);
    geomapimage->clipping--;
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "contrast", &contrast, NULL)
        && contrast == geomapimage->contrast)
      pass ();
    else
      fail ("GEOMAPIMAGE.contrast [RC] %u != %u", geomapimage->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "contrast", &contrast, 0)
        && contrast == geomapimage->contrast)
      pass ();
    else
      fail ("GEOMAPIMAGE.contrast [RC] set+1 %u != %u", geomapimage->contrast, contrast);
    geomapimage->contrast--;
  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "display_props", &display_props, NULL)
        && display_props == geomapimage->display_props)
      pass ();
    else
      fail ("GEOMAPIMAGE.display_props [BS] %hu != %hu", geomapimage->display_props, display_props);
    display_props++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "display_props", &display_props, 0)
        && display_props == geomapimage->display_props)
      pass ();
    else
      fail ("GEOMAPIMAGE.display_props [BS] set+1 %hu != %hu", geomapimage->display_props, display_props);
    geomapimage->display_props--;
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "fade", &fade, NULL)
        && fade == geomapimage->fade)
      pass ();
    else
      fail ("GEOMAPIMAGE.fade [RC] %u != %u", geomapimage->fade, fade);
    fade++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "fade", &fade, 0)
        && fade == geomapimage->fade)
      pass ();
    else
      fail ("GEOMAPIMAGE.fade [RC] set+1 %u != %u", geomapimage->fade, fade);
    geomapimage->fade--;
  }
  {
    BITCODE_BS geoimage_brightness;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_brightness", &geoimage_brightness, NULL)
        && geoimage_brightness == geomapimage->geoimage_brightness)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_brightness [BS] %hu != %hu", geomapimage->geoimage_brightness, geoimage_brightness);
    geoimage_brightness++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_brightness", &geoimage_brightness, 0)
        && geoimage_brightness == geomapimage->geoimage_brightness)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_brightness [BS] set+1 %hu != %hu", geomapimage->geoimage_brightness, geoimage_brightness);
    geomapimage->geoimage_brightness--;
  }
  {
    BITCODE_BS geoimage_contrast;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_contrast", &geoimage_contrast, NULL)
        && geoimage_contrast == geomapimage->geoimage_contrast)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_contrast [BS] %hu != %hu", geomapimage->geoimage_contrast, geoimage_contrast);
    geoimage_contrast++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_contrast", &geoimage_contrast, 0)
        && geoimage_contrast == geomapimage->geoimage_contrast)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_contrast [BS] set+1 %hu != %hu", geomapimage->geoimage_contrast, geoimage_contrast);
    geomapimage->geoimage_contrast--;
  }
  {
    BITCODE_BS geoimage_fade;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_fade", &geoimage_fade, NULL)
        && geoimage_fade == geomapimage->geoimage_fade)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_fade [BS] %hu != %hu", geomapimage->geoimage_fade, geoimage_fade);
    geoimage_fade++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_fade", &geoimage_fade, 0)
        && geoimage_fade == geomapimage->geoimage_fade)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_fade [BS] set+1 %hu != %hu", geomapimage->geoimage_fade, geoimage_fade);
    geomapimage->geoimage_fade--;
  }
  {
    BITCODE_BS geoimage_height;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_height", &geoimage_height, NULL)
        && geoimage_height == geomapimage->geoimage_height)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_height [BS] %hu != %hu", geomapimage->geoimage_height, geoimage_height);
    geoimage_height++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_height", &geoimage_height, 0)
        && geoimage_height == geomapimage->geoimage_height)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_height [BS] set+1 %hu != %hu", geomapimage->geoimage_height, geoimage_height);
    geomapimage->geoimage_height--;
  }
  {
    BITCODE_BS geoimage_position;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_position", &geoimage_position, NULL)
        && geoimage_position == geomapimage->geoimage_position)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_position [BS] %hu != %hu", geomapimage->geoimage_position, geoimage_position);
    geoimage_position++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_position", &geoimage_position, 0)
        && geoimage_position == geomapimage->geoimage_position)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_position [BS] set+1 %hu != %hu", geomapimage->geoimage_position, geoimage_position);
    geomapimage->geoimage_position--;
  }
  {
    BITCODE_BS geoimage_width;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "geoimage_width", &geoimage_width, NULL)
        && geoimage_width == geomapimage->geoimage_width)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_width [BS] %hu != %hu", geomapimage->geoimage_width, geoimage_width);
    geoimage_width++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "geoimage_width", &geoimage_width, 0)
        && geoimage_width == geomapimage->geoimage_width)
      pass ();
    else
      fail ("GEOMAPIMAGE.geoimage_width [BS] set+1 %hu != %hu", geomapimage->geoimage_width, geoimage_width);
    geomapimage->geoimage_width--;
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "height", &height, NULL)
        && height == geomapimage->height)
      pass ();
    else
      fail ("GEOMAPIMAGE.height [BD] %g != %g", geomapimage->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "height", &height, 0)
        && height == geomapimage->height)
      pass ();
    else
      fail ("GEOMAPIMAGE.height [BD] set+1 %g != %g", geomapimage->height, height);
    geomapimage->height--;
  }
  {
    BITCODE_BD image_file;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "image_file", &image_file, NULL)
        && image_file == geomapimage->image_file)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_file [BD] %g != %g", geomapimage->image_file, image_file);
    image_file++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "image_file", &image_file, 0)
        && image_file == geomapimage->image_file)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_file [BD] set+1 %g != %g", geomapimage->image_file, image_file);
    geomapimage->image_file--;
  }
  {
    BITCODE_BD image_height;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "image_height", &image_height, NULL)
        && image_height == geomapimage->image_height)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_height [BD] %g != %g", geomapimage->image_height, image_height);
    image_height++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "image_height", &image_height, 0)
        && image_height == geomapimage->image_height)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_height [BD] set+1 %g != %g", geomapimage->image_height, image_height);
    geomapimage->image_height--;
  }
  {
    BITCODE_BD image_visibility;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "image_visibility", &image_visibility, NULL)
        && image_visibility == geomapimage->image_visibility)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_visibility [BD] %g != %g", geomapimage->image_visibility, image_visibility);
    image_visibility++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "image_visibility", &image_visibility, 0)
        && image_visibility == geomapimage->image_visibility)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_visibility [BD] set+1 %g != %g", geomapimage->image_visibility, image_visibility);
    geomapimage->image_visibility--;
  }
  {
    BITCODE_BD image_width;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "image_width", &image_width, NULL)
        && image_width == geomapimage->image_width)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_width [BD] %g != %g", geomapimage->image_width, image_width);
    image_width++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "image_width", &image_width, 0)
        && image_width == geomapimage->image_width)
      pass ();
    else
      fail ("GEOMAPIMAGE.image_width [BD] set+1 %g != %g", geomapimage->image_width, image_width);
    geomapimage->image_width--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)geomapimage->name)
           : !geomapimage->name)
      pass ();
    else
      fail ("GEOMAPIMAGE.name [T] '%s' <> '%s'", name, geomapimage->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "parent", &parent, NULL)
        && !memcmp (&parent, &geomapimage->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("GEOMAPIMAGE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "pt0", &pt0, NULL)
        && !memcmp (&pt0, &geomapimage->pt0, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("GEOMAPIMAGE.pt0 [3BD]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "rotation", &rotation, NULL)
        && rotation == geomapimage->rotation)
      pass ();
    else
      fail ("GEOMAPIMAGE.rotation [BD] %g != %g", geomapimage->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "rotation", &rotation, 0)
        && rotation == geomapimage->rotation)
      pass ();
    else
      fail ("GEOMAPIMAGE.rotation [BD] set+1 %g != %g", geomapimage->rotation, rotation);
    geomapimage->rotation--;
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "scale_factor", &scale_factor, NULL)
        && scale_factor == geomapimage->scale_factor)
      pass ();
    else
      fail ("GEOMAPIMAGE.scale_factor [BD] %g != %g", geomapimage->scale_factor, scale_factor);
    scale_factor++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "scale_factor", &scale_factor, 0)
        && scale_factor == geomapimage->scale_factor)
      pass ();
    else
      fail ("GEOMAPIMAGE.scale_factor [BD] set+1 %g != %g", geomapimage->scale_factor, scale_factor);
    geomapimage->scale_factor--;
  }
  {
    BITCODE_B show_rotation;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "show_rotation", &show_rotation, NULL)
        && show_rotation == geomapimage->show_rotation)
      pass ();
    else
      fail ("GEOMAPIMAGE.show_rotation [B] " FORMAT_B " != " FORMAT_B "", geomapimage->show_rotation, show_rotation);
    show_rotation++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "show_rotation", &show_rotation, 0)
        && show_rotation == geomapimage->show_rotation)
      pass ();
    else
      fail ("GEOMAPIMAGE.show_rotation [B] set+1 " FORMAT_B " != " FORMAT_B "", geomapimage->show_rotation, show_rotation);
    geomapimage->show_rotation--;
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "size", &size, NULL)
        && !memcmp (&size, &geomapimage->size, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("GEOMAPIMAGE.size [2RD]");
  }
  {
    BITCODE_BS transparency;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "transparency", &transparency, NULL)
        && transparency == geomapimage->transparency)
      pass ();
    else
      fail ("GEOMAPIMAGE.transparency [BS] %hu != %hu", geomapimage->transparency, transparency);
    transparency++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "transparency", &transparency, 0)
        && transparency == geomapimage->transparency)
      pass ();
    else
      fail ("GEOMAPIMAGE.transparency [BS] set+1 %hu != %hu", geomapimage->transparency, transparency);
    geomapimage->transparency--;
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value (geomapimage, "GEOMAPIMAGE", "width", &width, NULL)
        && width == geomapimage->width)
      pass ();
    else
      fail ("GEOMAPIMAGE.width [BD] %g != %g", geomapimage->width, width);
    width++;
    if (dwg_dynapi_entity_set_value (geomapimage, "GEOMAPIMAGE", "width", &width, 0)
        && width == geomapimage->width)
      pass ();
    else
      fail ("GEOMAPIMAGE.width [BD] set+1 %g != %g", geomapimage->width, width);
    geomapimage->width--;
  }
  if (failed && (is_class_unstable ("GEOMAPIMAGE") || is_class_debugging ("GEOMAPIMAGE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GEOMAPIMAGE", failed);
      failed = 0;
    }
  return failed;
}
static int test_GRADIENT_BACKGROUND (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_GRADIENT_BACKGROUND *restrict gradient_background = obj->tio.object->tio.GRADIENT_BACKGROUND;
  failed = 0;
  if (!obj_obj || !gradient_background)
    {
      fail ("NULL GRADIENT_BACKGROUND");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (gradient_background, "GRADIENT_BACKGROUND", "class_version", &class_version, NULL)
        && class_version == gradient_background->class_version)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.class_version [BL] %u != %u", gradient_background->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (gradient_background, "GRADIENT_BACKGROUND", "class_version", &class_version, 0)
        && class_version == gradient_background->class_version)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.class_version [BL] set+1 %u != %u", gradient_background->class_version, class_version);
    gradient_background->class_version--;
  }
  {
    BITCODE_BLx color_bottom;
    if (dwg_dynapi_entity_value (gradient_background, "GRADIENT_BACKGROUND", "color_bottom", &color_bottom, NULL)
        && color_bottom == gradient_background->color_bottom)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.color_bottom [BLx] " FORMAT_BLx " != " FORMAT_BLx "", gradient_background->color_bottom, color_bottom);
    if (dwg_dynapi_entity_set_value (gradient_background, "GRADIENT_BACKGROUND", "color_bottom", &color_bottom, 0)
        && color_bottom == gradient_background->color_bottom)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.color_bottom [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", gradient_background->color_bottom, color_bottom);
    gradient_background->color_bottom--;
  }
  {
    BITCODE_BLx color_middle;
    if (dwg_dynapi_entity_value (gradient_background, "GRADIENT_BACKGROUND", "color_middle", &color_middle, NULL)
        && color_middle == gradient_background->color_middle)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.color_middle [BLx] " FORMAT_BLx " != " FORMAT_BLx "", gradient_background->color_middle, color_middle);
    if (dwg_dynapi_entity_set_value (gradient_background, "GRADIENT_BACKGROUND", "color_middle", &color_middle, 0)
        && color_middle == gradient_background->color_middle)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.color_middle [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", gradient_background->color_middle, color_middle);
    gradient_background->color_middle--;
  }
  {
    BITCODE_BLx color_top;
    if (dwg_dynapi_entity_value (gradient_background, "GRADIENT_BACKGROUND", "color_top", &color_top, NULL)
        && color_top == gradient_background->color_top)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.color_top [BLx] " FORMAT_BLx " != " FORMAT_BLx "", gradient_background->color_top, color_top);
    if (dwg_dynapi_entity_set_value (gradient_background, "GRADIENT_BACKGROUND", "color_top", &color_top, 0)
        && color_top == gradient_background->color_top)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.color_top [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", gradient_background->color_top, color_top);
    gradient_background->color_top--;
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value (gradient_background, "GRADIENT_BACKGROUND", "height", &height, NULL)
        && height == gradient_background->height)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.height [BD] %g != %g", gradient_background->height, height);
    height++;
    if (dwg_dynapi_entity_set_value (gradient_background, "GRADIENT_BACKGROUND", "height", &height, 0)
        && height == gradient_background->height)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.height [BD] set+1 %g != %g", gradient_background->height, height);
    gradient_background->height--;
  }
  {
    BITCODE_BD horizon;
    if (dwg_dynapi_entity_value (gradient_background, "GRADIENT_BACKGROUND", "horizon", &horizon, NULL)
        && horizon == gradient_background->horizon)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.horizon [BD] %g != %g", gradient_background->horizon, horizon);
    horizon++;
    if (dwg_dynapi_entity_set_value (gradient_background, "GRADIENT_BACKGROUND", "horizon", &horizon, 0)
        && horizon == gradient_background->horizon)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.horizon [BD] set+1 %g != %g", gradient_background->horizon, horizon);
    gradient_background->horizon--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (gradient_background, "GRADIENT_BACKGROUND", "parent", &parent, NULL)
        && !memcmp (&parent, &gradient_background->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("GRADIENT_BACKGROUND.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (gradient_background, "GRADIENT_BACKGROUND", "rotation", &rotation, NULL)
        && rotation == gradient_background->rotation)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.rotation [BD] %g != %g", gradient_background->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (gradient_background, "GRADIENT_BACKGROUND", "rotation", &rotation, 0)
        && rotation == gradient_background->rotation)
      pass ();
    else
      fail ("GRADIENT_BACKGROUND.rotation [BD] set+1 %g != %g", gradient_background->rotation, rotation);
    gradient_background->rotation--;
  }
  if (failed && (is_class_unstable ("GRADIENT_BACKGROUND") || is_class_debugging ("GRADIENT_BACKGROUND")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GRADIENT_BACKGROUND", failed);
      failed = 0;
    }
  return failed;
}
static int test_GROUND_PLANE_BACKGROUND (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_GROUND_PLANE_BACKGROUND *restrict ground_plane_background = obj->tio.object->tio.GROUND_PLANE_BACKGROUND;
  failed = 0;
  if (!obj_obj || !ground_plane_background)
    {
      fail ("NULL GROUND_PLANE_BACKGROUND");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "class_version", &class_version, NULL)
        && class_version == ground_plane_background->class_version)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.class_version [BL] %u != %u", ground_plane_background->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "class_version", &class_version, 0)
        && class_version == ground_plane_background->class_version)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.class_version [BL] set+1 %u != %u", ground_plane_background->class_version, class_version);
    ground_plane_background->class_version--;
  }
  {
    BITCODE_BLx color_far;
    if (dwg_dynapi_entity_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_far", &color_far, NULL)
        && color_far == ground_plane_background->color_far)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_far [BLx] " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_far, color_far);
    if (dwg_dynapi_entity_set_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_far", &color_far, 0)
        && color_far == ground_plane_background->color_far)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_far [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_far, color_far);
    ground_plane_background->color_far--;
  }
  {
    BITCODE_BLx color_near;
    if (dwg_dynapi_entity_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_near", &color_near, NULL)
        && color_near == ground_plane_background->color_near)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_near [BLx] " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_near, color_near);
    if (dwg_dynapi_entity_set_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_near", &color_near, 0)
        && color_near == ground_plane_background->color_near)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_near [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_near, color_near);
    ground_plane_background->color_near--;
  }
  {
    BITCODE_BLx color_sky_horizon;
    if (dwg_dynapi_entity_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_sky_horizon", &color_sky_horizon, NULL)
        && color_sky_horizon == ground_plane_background->color_sky_horizon)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_sky_horizon [BLx] " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_sky_horizon, color_sky_horizon);
    if (dwg_dynapi_entity_set_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_sky_horizon", &color_sky_horizon, 0)
        && color_sky_horizon == ground_plane_background->color_sky_horizon)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_sky_horizon [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_sky_horizon, color_sky_horizon);
    ground_plane_background->color_sky_horizon--;
  }
  {
    BITCODE_BLx color_sky_zenith;
    if (dwg_dynapi_entity_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_sky_zenith", &color_sky_zenith, NULL)
        && color_sky_zenith == ground_plane_background->color_sky_zenith)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_sky_zenith [BLx] " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_sky_zenith, color_sky_zenith);
    if (dwg_dynapi_entity_set_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_sky_zenith", &color_sky_zenith, 0)
        && color_sky_zenith == ground_plane_background->color_sky_zenith)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_sky_zenith [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_sky_zenith, color_sky_zenith);
    ground_plane_background->color_sky_zenith--;
  }
  {
    BITCODE_BLx color_underground_azimuth;
    if (dwg_dynapi_entity_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_underground_azimuth", &color_underground_azimuth, NULL)
        && color_underground_azimuth == ground_plane_background->color_underground_azimuth)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_underground_azimuth [BLx] " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_underground_azimuth, color_underground_azimuth);
    if (dwg_dynapi_entity_set_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_underground_azimuth", &color_underground_azimuth, 0)
        && color_underground_azimuth == ground_plane_background->color_underground_azimuth)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_underground_azimuth [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_underground_azimuth, color_underground_azimuth);
    ground_plane_background->color_underground_azimuth--;
  }
  {
    BITCODE_BLx color_underground_horizon;
    if (dwg_dynapi_entity_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_underground_horizon", &color_underground_horizon, NULL)
        && color_underground_horizon == ground_plane_background->color_underground_horizon)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_underground_horizon [BLx] " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_underground_horizon, color_underground_horizon);
    if (dwg_dynapi_entity_set_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "color_underground_horizon", &color_underground_horizon, 0)
        && color_underground_horizon == ground_plane_background->color_underground_horizon)
      pass ();
    else
      fail ("GROUND_PLANE_BACKGROUND.color_underground_horizon [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", ground_plane_background->color_underground_horizon, color_underground_horizon);
    ground_plane_background->color_underground_horizon--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ground_plane_background, "GROUND_PLANE_BACKGROUND", "parent", &parent, NULL)
        && !memcmp (&parent, &ground_plane_background->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("GROUND_PLANE_BACKGROUND.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("GROUND_PLANE_BACKGROUND") || is_class_debugging ("GROUND_PLANE_BACKGROUND")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GROUND_PLANE_BACKGROUND", failed);
      failed = 0;
    }
  return failed;
}
static int test_GROUP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_GROUP *restrict group = obj->tio.object->tio.GROUP;
  failed = 0;
  if (!obj_obj || !group)
    {
      fail ("NULL GROUP");
      return 1;
    }
  {
    BITCODE_H* groups;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (group, "GROUP", "num_groups", &count, NULL)
        && dwg_dynapi_entity_value (group, "GROUP", "groups", &groups, NULL)
        && groups == group->groups)
      pass ();
    else
      fail ("GROUP.groups [H*] * %u num_groups", count);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (group, "GROUP", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)group->name)
           : !group->name)
      pass ();
    else
      fail ("GROUP.name [T] '%s' <> '%s'", name, group->name);
  }
  {
    BITCODE_BL num_groups;
    if (dwg_dynapi_entity_value (group, "GROUP", "num_groups", &num_groups, NULL)
        && num_groups == group->num_groups)
      pass ();
    else
      fail ("GROUP.num_groups [BL] %u != %u", group->num_groups, num_groups);
    num_groups++;
    if (dwg_dynapi_entity_set_value (group, "GROUP", "num_groups", &num_groups, 0)
        && num_groups == group->num_groups)
      pass ();
    else
      fail ("GROUP.num_groups [BL] set+1 %u != %u", group->num_groups, num_groups);
    group->num_groups--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (group, "GROUP", "parent", &parent, NULL)
        && !memcmp (&parent, &group->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("GROUP.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS selectable;
    if (dwg_dynapi_entity_value (group, "GROUP", "selectable", &selectable, NULL)
        && selectable == group->selectable)
      pass ();
    else
      fail ("GROUP.selectable [BS] %hu != %hu", group->selectable, selectable);
    selectable++;
    if (dwg_dynapi_entity_set_value (group, "GROUP", "selectable", &selectable, 0)
        && selectable == group->selectable)
      pass ();
    else
      fail ("GROUP.selectable [BS] set+1 %hu != %hu", group->selectable, selectable);
    group->selectable--;
  }
  {
    BITCODE_BS unnamed;
    if (dwg_dynapi_entity_value (group, "GROUP", "unnamed", &unnamed, NULL)
        && unnamed == group->unnamed)
      pass ();
    else
      fail ("GROUP.unnamed [BS] %hu != %hu", group->unnamed, unnamed);
    unnamed++;
    if (dwg_dynapi_entity_set_value (group, "GROUP", "unnamed", &unnamed, 0)
        && unnamed == group->unnamed)
      pass ();
    else
      fail ("GROUP.unnamed [BS] set+1 %hu != %hu", group->unnamed, unnamed);
    group->unnamed--;
  }
  if (failed && (is_class_unstable ("GROUP") || is_class_debugging ("GROUP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "GROUP", failed);
      failed = 0;
    }
  return failed;
}
static int test_IBL_BACKGROUND (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_IBL_BACKGROUND *restrict ibl_background = obj->tio.object->tio.IBL_BACKGROUND;
  failed = 0;
  if (!obj_obj || !ibl_background)
    {
      fail ("NULL IBL_BACKGROUND");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (ibl_background, "IBL_BACKGROUND", "class_version", &class_version, NULL)
        && class_version == ibl_background->class_version)
      pass ();
    else
      fail ("IBL_BACKGROUND.class_version [BL] %u != %u", ibl_background->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (ibl_background, "IBL_BACKGROUND", "class_version", &class_version, 0)
        && class_version == ibl_background->class_version)
      pass ();
    else
      fail ("IBL_BACKGROUND.class_version [BL] set+1 %u != %u", ibl_background->class_version, class_version);
    ibl_background->class_version--;
  }
  {
    BITCODE_B display_image;
    if (dwg_dynapi_entity_value (ibl_background, "IBL_BACKGROUND", "display_image", &display_image, NULL)
        && display_image == ibl_background->display_image)
      pass ();
    else
      fail ("IBL_BACKGROUND.display_image [B] " FORMAT_B " != " FORMAT_B "", ibl_background->display_image, display_image);
    display_image++;
    if (dwg_dynapi_entity_set_value (ibl_background, "IBL_BACKGROUND", "display_image", &display_image, 0)
        && display_image == ibl_background->display_image)
      pass ();
    else
      fail ("IBL_BACKGROUND.display_image [B] set+1 " FORMAT_B " != " FORMAT_B "", ibl_background->display_image, display_image);
    ibl_background->display_image--;
  }
  {
    BITCODE_B enable;
    if (dwg_dynapi_entity_value (ibl_background, "IBL_BACKGROUND", "enable", &enable, NULL)
        && enable == ibl_background->enable)
      pass ();
    else
      fail ("IBL_BACKGROUND.enable [B] " FORMAT_B " != " FORMAT_B "", ibl_background->enable, enable);
    enable++;
    if (dwg_dynapi_entity_set_value (ibl_background, "IBL_BACKGROUND", "enable", &enable, 0)
        && enable == ibl_background->enable)
      pass ();
    else
      fail ("IBL_BACKGROUND.enable [B] set+1 " FORMAT_B " != " FORMAT_B "", ibl_background->enable, enable);
    ibl_background->enable--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (ibl_background, "IBL_BACKGROUND", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)ibl_background->name)
           : !ibl_background->name)
      pass ();
    else
      fail ("IBL_BACKGROUND.name [T] '%s' <> '%s'", name, ibl_background->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ibl_background, "IBL_BACKGROUND", "parent", &parent, NULL)
        && !memcmp (&parent, &ibl_background->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("IBL_BACKGROUND.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (ibl_background, "IBL_BACKGROUND", "rotation", &rotation, NULL)
        && rotation == ibl_background->rotation)
      pass ();
    else
      fail ("IBL_BACKGROUND.rotation [BD] %g != %g", ibl_background->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (ibl_background, "IBL_BACKGROUND", "rotation", &rotation, 0)
        && rotation == ibl_background->rotation)
      pass ();
    else
      fail ("IBL_BACKGROUND.rotation [BD] set+1 %g != %g", ibl_background->rotation, rotation);
    ibl_background->rotation--;
  }
  {
    BITCODE_H secondary_background;
    if (dwg_dynapi_entity_value (ibl_background, "IBL_BACKGROUND", "secondary_background", &secondary_background, NULL)
        && !memcmp (&secondary_background, &ibl_background->secondary_background, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("IBL_BACKGROUND.secondary_background [H]");
  }
  if (failed && (is_class_unstable ("IBL_BACKGROUND") || is_class_debugging ("IBL_BACKGROUND")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IBL_BACKGROUND", failed);
      failed = 0;
    }
  return failed;
}
static int test_IDBUFFER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_IDBUFFER *restrict idbuffer = obj->tio.object->tio.IDBUFFER;
  failed = 0;
  if (!obj_obj || !idbuffer)
    {
      fail ("NULL IDBUFFER");
      return 1;
    }
  {
    BITCODE_BL num_obj_ids;
    if (dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "num_obj_ids", &num_obj_ids, NULL)
        && num_obj_ids == idbuffer->num_obj_ids)
      pass ();
    else
      fail ("IDBUFFER.num_obj_ids [BL] %u != %u", idbuffer->num_obj_ids, num_obj_ids);
    num_obj_ids++;
    if (dwg_dynapi_entity_set_value (idbuffer, "IDBUFFER", "num_obj_ids", &num_obj_ids, 0)
        && num_obj_ids == idbuffer->num_obj_ids)
      pass ();
    else
      fail ("IDBUFFER.num_obj_ids [BL] set+1 %u != %u", idbuffer->num_obj_ids, num_obj_ids);
    idbuffer->num_obj_ids--;
  }
  {
    BITCODE_H* obj_ids;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "num_obj_ids", &count, NULL)
        && dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "obj_ids", &obj_ids, NULL)
        && obj_ids == idbuffer->obj_ids)
      pass ();
    else
      fail ("IDBUFFER.obj_ids [H*] * %u num_obj_ids", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "parent", &parent, NULL)
        && !memcmp (&parent, &idbuffer->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("IDBUFFER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value (idbuffer, "IDBUFFER", "unknown", &unknown, NULL)
        && unknown == idbuffer->unknown)
      pass ();
    else
      fail ("IDBUFFER.unknown [RC] %u != %u", idbuffer->unknown, unknown);
    unknown++;
    if (dwg_dynapi_entity_set_value (idbuffer, "IDBUFFER", "unknown", &unknown, 0)
        && unknown == idbuffer->unknown)
      pass ();
    else
      fail ("IDBUFFER.unknown [RC] set+1 %u != %u", idbuffer->unknown, unknown);
    idbuffer->unknown--;
  }
  if (failed && (is_class_unstable ("IDBUFFER") || is_class_debugging ("IDBUFFER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IDBUFFER", failed);
      failed = 0;
    }
  return failed;
}
static int test_IMAGEDEF (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_IMAGEDEF *restrict imagedef = obj->tio.object->tio.IMAGEDEF;
  failed = 0;
  if (!obj_obj || !imagedef)
    {
      fail ("NULL IMAGEDEF");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "class_version", &class_version, NULL)
        && class_version == imagedef->class_version)
      pass ();
    else
      fail ("IMAGEDEF.class_version [BL] %u != %u", imagedef->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (imagedef, "IMAGEDEF", "class_version", &class_version, 0)
        && class_version == imagedef->class_version)
      pass ();
    else
      fail ("IMAGEDEF.class_version [BL] set+1 %u != %u", imagedef->class_version, class_version);
    imagedef->class_version--;
  }
  {
    BITCODE_T file_path;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "file_path", &file_path, NULL)
        && file_path
           ? strEQ ((char *)file_path, (char *)imagedef->file_path)
           : !imagedef->file_path)
      pass ();
    else
      fail ("IMAGEDEF.file_path [T] '%s' <> '%s'", file_path, imagedef->file_path);
  }
  {
    BITCODE_2RD image_size;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "image_size", &image_size, NULL)
        && !memcmp (&image_size, &imagedef->image_size, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("IMAGEDEF.image_size [2RD]");
  }
  {
    BITCODE_B is_loaded;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "is_loaded", &is_loaded, NULL)
        && is_loaded == imagedef->is_loaded)
      pass ();
    else
      fail ("IMAGEDEF.is_loaded [B] " FORMAT_B " != " FORMAT_B "", imagedef->is_loaded, is_loaded);
    is_loaded++;
    if (dwg_dynapi_entity_set_value (imagedef, "IMAGEDEF", "is_loaded", &is_loaded, 0)
        && is_loaded == imagedef->is_loaded)
      pass ();
    else
      fail ("IMAGEDEF.is_loaded [B] set+1 " FORMAT_B " != " FORMAT_B "", imagedef->is_loaded, is_loaded);
    imagedef->is_loaded--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "parent", &parent, NULL)
        && !memcmp (&parent, &imagedef->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("IMAGEDEF.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_2RD pixel_size;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "pixel_size", &pixel_size, NULL)
        && !memcmp (&pixel_size, &imagedef->pixel_size, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("IMAGEDEF.pixel_size [2RD]");
  }
  {
    BITCODE_RC resunits;
    if (dwg_dynapi_entity_value (imagedef, "IMAGEDEF", "resunits", &resunits, NULL)
        && resunits == imagedef->resunits)
      pass ();
    else
      fail ("IMAGEDEF.resunits [RC] %u != %u", imagedef->resunits, resunits);
    resunits++;
    if (dwg_dynapi_entity_set_value (imagedef, "IMAGEDEF", "resunits", &resunits, 0)
        && resunits == imagedef->resunits)
      pass ();
    else
      fail ("IMAGEDEF.resunits [RC] set+1 %u != %u", imagedef->resunits, resunits);
    imagedef->resunits--;
  }
  if (failed && (is_class_unstable ("IMAGEDEF") || is_class_debugging ("IMAGEDEF")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IMAGEDEF", failed);
      failed = 0;
    }
  return failed;
}
static int test_IMAGEDEF_REACTOR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_IMAGEDEF_REACTOR *restrict imagedef_reactor = obj->tio.object->tio.IMAGEDEF_REACTOR;
  failed = 0;
  if (!obj_obj || !imagedef_reactor)
    {
      fail ("NULL IMAGEDEF_REACTOR");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (imagedef_reactor, "IMAGEDEF_REACTOR", "class_version", &class_version, NULL)
        && class_version == imagedef_reactor->class_version)
      pass ();
    else
      fail ("IMAGEDEF_REACTOR.class_version [BL] %u != %u", imagedef_reactor->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (imagedef_reactor, "IMAGEDEF_REACTOR", "class_version", &class_version, 0)
        && class_version == imagedef_reactor->class_version)
      pass ();
    else
      fail ("IMAGEDEF_REACTOR.class_version [BL] set+1 %u != %u", imagedef_reactor->class_version, class_version);
    imagedef_reactor->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (imagedef_reactor, "IMAGEDEF_REACTOR", "parent", &parent, NULL)
        && !memcmp (&parent, &imagedef_reactor->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("IMAGEDEF_REACTOR.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("IMAGEDEF_REACTOR") || is_class_debugging ("IMAGEDEF_REACTOR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IMAGEDEF_REACTOR", failed);
      failed = 0;
    }
  return failed;
}
static int test_IMAGE_BACKGROUND (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_IMAGE_BACKGROUND *restrict image_background = obj->tio.object->tio.IMAGE_BACKGROUND;
  failed = 0;
  if (!obj_obj || !image_background)
    {
      fail ("NULL IMAGE_BACKGROUND");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (image_background, "IMAGE_BACKGROUND", "class_version", &class_version, NULL)
        && class_version == image_background->class_version)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.class_version [BL] %u != %u", image_background->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (image_background, "IMAGE_BACKGROUND", "class_version", &class_version, 0)
        && class_version == image_background->class_version)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.class_version [BL] set+1 %u != %u", image_background->class_version, class_version);
    image_background->class_version--;
  }
  {
    BITCODE_T filename;
    if (dwg_dynapi_entity_value (image_background, "IMAGE_BACKGROUND", "filename", &filename, NULL)
        && filename
           ? strEQ ((char *)filename, (char *)image_background->filename)
           : !image_background->filename)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.filename [T] '%s' <> '%s'", filename, image_background->filename);
  }
  {
    BITCODE_B fit_to_screen;
    if (dwg_dynapi_entity_value (image_background, "IMAGE_BACKGROUND", "fit_to_screen", &fit_to_screen, NULL)
        && fit_to_screen == image_background->fit_to_screen)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.fit_to_screen [B] " FORMAT_B " != " FORMAT_B "", image_background->fit_to_screen, fit_to_screen);
    fit_to_screen++;
    if (dwg_dynapi_entity_set_value (image_background, "IMAGE_BACKGROUND", "fit_to_screen", &fit_to_screen, 0)
        && fit_to_screen == image_background->fit_to_screen)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.fit_to_screen [B] set+1 " FORMAT_B " != " FORMAT_B "", image_background->fit_to_screen, fit_to_screen);
    image_background->fit_to_screen--;
  }
  {
    BITCODE_B maintain_aspect_ratio;
    if (dwg_dynapi_entity_value (image_background, "IMAGE_BACKGROUND", "maintain_aspect_ratio", &maintain_aspect_ratio, NULL)
        && maintain_aspect_ratio == image_background->maintain_aspect_ratio)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.maintain_aspect_ratio [B] " FORMAT_B " != " FORMAT_B "", image_background->maintain_aspect_ratio, maintain_aspect_ratio);
    maintain_aspect_ratio++;
    if (dwg_dynapi_entity_set_value (image_background, "IMAGE_BACKGROUND", "maintain_aspect_ratio", &maintain_aspect_ratio, 0)
        && maintain_aspect_ratio == image_background->maintain_aspect_ratio)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.maintain_aspect_ratio [B] set+1 " FORMAT_B " != " FORMAT_B "", image_background->maintain_aspect_ratio, maintain_aspect_ratio);
    image_background->maintain_aspect_ratio--;
  }
  {
    BITCODE_2BD offset;
    if (dwg_dynapi_entity_value (image_background, "IMAGE_BACKGROUND", "offset", &offset, NULL)
        && !memcmp (&offset, &image_background->offset, sizeof (BITCODE_2BD)))
        pass ();
    else
        fail ("IMAGE_BACKGROUND.offset [2BD_1]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (image_background, "IMAGE_BACKGROUND", "parent", &parent, NULL)
        && !memcmp (&parent, &image_background->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("IMAGE_BACKGROUND.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_2BD scale;
    if (dwg_dynapi_entity_value (image_background, "IMAGE_BACKGROUND", "scale", &scale, NULL)
        && !memcmp (&scale, &image_background->scale, sizeof (BITCODE_2BD)))
        pass ();
    else
        fail ("IMAGE_BACKGROUND.scale [2BD_1]");
  }
  {
    BITCODE_B use_tiling;
    if (dwg_dynapi_entity_value (image_background, "IMAGE_BACKGROUND", "use_tiling", &use_tiling, NULL)
        && use_tiling == image_background->use_tiling)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.use_tiling [B] " FORMAT_B " != " FORMAT_B "", image_background->use_tiling, use_tiling);
    use_tiling++;
    if (dwg_dynapi_entity_set_value (image_background, "IMAGE_BACKGROUND", "use_tiling", &use_tiling, 0)
        && use_tiling == image_background->use_tiling)
      pass ();
    else
      fail ("IMAGE_BACKGROUND.use_tiling [B] set+1 " FORMAT_B " != " FORMAT_B "", image_background->use_tiling, use_tiling);
    image_background->use_tiling--;
  }
  if (failed && (is_class_unstable ("IMAGE_BACKGROUND") || is_class_debugging ("IMAGE_BACKGROUND")))
    {
      ok ("%s failed %d tests (TODO unstable)", "IMAGE_BACKGROUND", failed);
      failed = 0;
    }
  return failed;
}
static int test_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_INDEX *restrict index = obj->tio.object->tio.INDEX;
  failed = 0;
  if (!obj_obj || !index)
    {
      fail ("NULL INDEX");
      return 1;
    }
  {
    BITCODE_TIMEBLL last_updated;
    if (dwg_dynapi_entity_value (index, "INDEX", "last_updated", &last_updated, NULL)
        && !memcmp (&last_updated, &index->last_updated, sizeof (BITCODE_TIMEBLL)))
        pass ();
    else
        fail ("INDEX.last_updated [TIMEBLL]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (index, "INDEX", "parent", &parent, NULL)
        && !memcmp (&parent, &index->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("INDEX.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("INDEX") || is_class_debugging ("INDEX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "INDEX", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYER *restrict layer = obj->tio.object->tio.LAYER;
  failed = 0;
  if (!obj_obj || !layer)
    {
      fail ("NULL LAYER");
      return 1;
    }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (layer, "LAYER", "color", &color, NULL)
        && !memcmp (&color, &layer->color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("LAYER.color [CMC]");
  }
  {
    BITCODE_BS flag0;
    if (dwg_dynapi_entity_value (layer, "LAYER", "flag0", &flag0, NULL)
        && flag0 == layer->flag0)
      pass ();
    else
      fail ("LAYER.flag0 [BS] %hu != %hu", layer->flag0, flag0);
    flag0++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "flag0", &flag0, 0)
        && flag0 == layer->flag0)
      pass ();
    else
      fail ("LAYER.flag0 [BS] set+1 %hu != %hu", layer->flag0, flag0);
    layer->flag0--;
  }
  {
    BITCODE_B frozen;
    if (dwg_dynapi_entity_value (layer, "LAYER", "frozen", &frozen, NULL)
        && frozen == layer->frozen)
      pass ();
    else
      fail ("LAYER.frozen [B] " FORMAT_B " != " FORMAT_B "", layer->frozen, frozen);
    frozen++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "frozen", &frozen, 0)
        && frozen == layer->frozen)
      pass ();
    else
      fail ("LAYER.frozen [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->frozen, frozen);
    layer->frozen--;
  }
  {
    BITCODE_B frozen_in_new;
    if (dwg_dynapi_entity_value (layer, "LAYER", "frozen_in_new", &frozen_in_new, NULL)
        && frozen_in_new == layer->frozen_in_new)
      pass ();
    else
      fail ("LAYER.frozen_in_new [B] " FORMAT_B " != " FORMAT_B "", layer->frozen_in_new, frozen_in_new);
    frozen_in_new++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "frozen_in_new", &frozen_in_new, 0)
        && frozen_in_new == layer->frozen_in_new)
      pass ();
    else
      fail ("LAYER.frozen_in_new [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->frozen_in_new, frozen_in_new);
    layer->frozen_in_new--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (layer, "LAYER", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == layer->is_xref_dep)
      pass ();
    else
      fail ("LAYER.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", layer->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == layer->is_xref_dep)
      pass ();
    else
      fail ("LAYER.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->is_xref_dep, is_xref_dep);
    layer->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (layer, "LAYER", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == layer->is_xref_ref)
      pass ();
    else
      fail ("LAYER.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", layer->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == layer->is_xref_ref)
      pass ();
    else
      fail ("LAYER.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->is_xref_ref, is_xref_ref);
    layer->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (layer, "LAYER", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == layer->is_xref_resolved)
      pass ();
    else
      fail ("LAYER.is_xref_resolved [BS] %hu != %hu", layer->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == layer->is_xref_resolved)
      pass ();
    else
      fail ("LAYER.is_xref_resolved [BS] set+1 %hu != %hu", layer->is_xref_resolved, is_xref_resolved);
    layer->is_xref_resolved--;
  }
  {
    BITCODE_RC linewt;
    if (dwg_dynapi_entity_value (layer, "LAYER", "linewt", &linewt, NULL)
        && linewt == layer->linewt)
      pass ();
    else
      fail ("LAYER.linewt [RC] %u != %u", layer->linewt, linewt);
    linewt++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "linewt", &linewt, 0)
        && linewt == layer->linewt)
      pass ();
    else
      fail ("LAYER.linewt [RC] set+1 %u != %u", layer->linewt, linewt);
    layer->linewt--;
  }
  {
    BITCODE_B locked;
    if (dwg_dynapi_entity_value (layer, "LAYER", "locked", &locked, NULL)
        && locked == layer->locked)
      pass ();
    else
      fail ("LAYER.locked [B] " FORMAT_B " != " FORMAT_B "", layer->locked, locked);
    locked++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "locked", &locked, 0)
        && locked == layer->locked)
      pass ();
    else
      fail ("LAYER.locked [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->locked, locked);
    layer->locked--;
  }
  {
    BITCODE_H ltype;
    if (dwg_dynapi_entity_value (layer, "LAYER", "ltype", &ltype, NULL)
        && !memcmp (&ltype, &layer->ltype, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYER.ltype [H]");
  }
  {
    BITCODE_H material;
    if (dwg_dynapi_entity_value (layer, "LAYER", "material", &material, NULL)
        && !memcmp (&material, &layer->material, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYER.material [H]");
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (layer, "LAYER", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)layer->name)
           : !layer->name)
      pass ();
    else
      fail ("LAYER.name [T] '%s' <> '%s'", name, layer->name);
  }
  {
    BITCODE_B on;
    if (dwg_dynapi_entity_value (layer, "LAYER", "on", &on, NULL)
        && on == layer->on)
      pass ();
    else
      fail ("LAYER.on [B] " FORMAT_B " != " FORMAT_B "", layer->on, on);
    on++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "on", &on, 0)
        && on == layer->on)
      pass ();
    else
      fail ("LAYER.on [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->on, on);
    layer->on--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layer, "LAYER", "parent", &parent, NULL)
        && !memcmp (&parent, &layer->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LAYER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B plotflag;
    if (dwg_dynapi_entity_value (layer, "LAYER", "plotflag", &plotflag, NULL)
        && plotflag == layer->plotflag)
      pass ();
    else
      fail ("LAYER.plotflag [B] " FORMAT_B " != " FORMAT_B "", layer->plotflag, plotflag);
    plotflag++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "plotflag", &plotflag, 0)
        && plotflag == layer->plotflag)
      pass ();
    else
      fail ("LAYER.plotflag [B] set+1 " FORMAT_B " != " FORMAT_B "", layer->plotflag, plotflag);
    layer->plotflag--;
  }
  {
    BITCODE_H plotstyle;
    if (dwg_dynapi_entity_value (layer, "LAYER", "plotstyle", &plotstyle, NULL)
        && !memcmp (&plotstyle, &layer->plotstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYER.plotstyle [H]");
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (layer, "LAYER", "used", &used, NULL)
        && used == layer->used)
      pass ();
    else
      fail ("LAYER.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", layer->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (layer, "LAYER", "used", &used, 0)
        && used == layer->used)
      pass ();
    else
      fail ("LAYER.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", layer->used, used);
    layer->used--;
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (layer, "LAYER", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &layer->visualstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYER.visualstyle [H]");
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (layer, "LAYER", "xref", &xref, NULL)
        && !memcmp (&xref, &layer->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYER.xref [H]");
  }
  if (failed && (is_class_unstable ("LAYER") || is_class_debugging ("LAYER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYER", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYERFILTER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYERFILTER *restrict layerfilter = obj->tio.object->tio.LAYERFILTER;
  failed = 0;
  if (!obj_obj || !layerfilter)
    {
      fail ("NULL LAYERFILTER");
      return 1;
    }
  {
    BITCODE_TV* names;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (layerfilter, "LAYERFILTER", "num_names", &count, NULL)
        && dwg_dynapi_entity_value (layerfilter, "LAYERFILTER", "names", &names, NULL)
        && names == layerfilter->names)
      pass ();
    else
      fail ("LAYERFILTER.names [TV*] * %u num_names", count);
  }
  {
    BITCODE_BL num_names;
    if (dwg_dynapi_entity_value (layerfilter, "LAYERFILTER", "num_names", &num_names, NULL)
        && num_names == layerfilter->num_names)
      pass ();
    else
      fail ("LAYERFILTER.num_names [BL] %u != %u", layerfilter->num_names, num_names);
    num_names++;
    if (dwg_dynapi_entity_set_value (layerfilter, "LAYERFILTER", "num_names", &num_names, 0)
        && num_names == layerfilter->num_names)
      pass ();
    else
      fail ("LAYERFILTER.num_names [BL] set+1 %u != %u", layerfilter->num_names, num_names);
    layerfilter->num_names--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layerfilter, "LAYERFILTER", "parent", &parent, NULL)
        && !memcmp (&parent, &layerfilter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LAYERFILTER.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LAYERFILTER") || is_class_debugging ("LAYERFILTER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYERFILTER", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYER_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYER_CONTROL *restrict layer_control = obj->tio.object->tio.LAYER_CONTROL;
  failed = 0;
  if (!obj_obj || !layer_control)
    {
      fail ("NULL LAYER_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "entries", &entries, NULL)
        && entries == layer_control->entries)
      pass ();
    else
      fail ("LAYER_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == layer_control->flags_r11)
      pass ();
    else
      fail ("LAYER_CONTROL.flags_r11 [RS] %hu != %hu", layer_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (layer_control, "LAYER_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == layer_control->flags_r11)
      pass ();
    else
      fail ("LAYER_CONTROL.flags_r11 [RS] set+1 %hu != %hu", layer_control->flags_r11, flags_r11);
    layer_control->flags_r11--;
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == layer_control->num_entries)
      pass ();
    else
      fail ("LAYER_CONTROL.num_entries [BS] %hu != %hu", layer_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (layer_control, "LAYER_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == layer_control->num_entries)
      pass ();
    else
      fail ("LAYER_CONTROL.num_entries [BS] set+1 %hu != %hu", layer_control->num_entries, num_entries);
    layer_control->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layer_control, "LAYER_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &layer_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LAYER_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LAYER_CONTROL") || is_class_debugging ("LAYER_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYER_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYER_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYER_INDEX *restrict layer_index = obj->tio.object->tio.LAYER_INDEX;
  failed = 0;
  if (!obj_obj || !layer_index)
    {
      fail ("NULL LAYER_INDEX");
      return 1;
    }
  {
    Dwg_LAYER_entry* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "entries", &entries, NULL)
        && entries == layer_index->entries)
      pass ();
    else
      fail ("LAYER_INDEX.entries [Dwg_LAYER_entry*] * %u num_entries", count);
  }
  {
    BITCODE_TIMEBLL last_updated;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "last_updated", &last_updated, NULL)
        && !memcmp (&last_updated, &layer_index->last_updated, sizeof (BITCODE_TIMEBLL)))
        pass ();
    else
        fail ("LAYER_INDEX.last_updated [TIMEBLL]");
  }
  {
    BITCODE_BL num_entries;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "num_entries", &num_entries, NULL)
        && num_entries == layer_index->num_entries)
      pass ();
    else
      fail ("LAYER_INDEX.num_entries [BL] %u != %u", layer_index->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (layer_index, "LAYER_INDEX", "num_entries", &num_entries, 0)
        && num_entries == layer_index->num_entries)
      pass ();
    else
      fail ("LAYER_INDEX.num_entries [BL] set+1 %u != %u", layer_index->num_entries, num_entries);
    layer_index->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layer_index, "LAYER_INDEX", "parent", &parent, NULL)
        && !memcmp (&parent, &layer_index->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LAYER_INDEX.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LAYER_INDEX") || is_class_debugging ("LAYER_INDEX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYER_INDEX", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYOUT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYOUT *restrict layout = obj->tio.object->tio.LAYOUT;
  failed = 0;
  if (!obj_obj || !layout)
    {
      fail ("NULL LAYOUT");
      return 1;
    }
  {
    BITCODE_3DPOINT EXTMAX;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "EXTMAX", &EXTMAX, NULL)
        && !memcmp (&EXTMAX, &layout->EXTMAX, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LAYOUT.EXTMAX [3DPOINT]");
  }
  {
    BITCODE_3DPOINT EXTMIN;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "EXTMIN", &EXTMIN, NULL)
        && !memcmp (&EXTMIN, &layout->EXTMIN, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LAYOUT.EXTMIN [3DPOINT]");
  }
  {
    BITCODE_3DPOINT INSBASE;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "INSBASE", &INSBASE, NULL)
        && !memcmp (&INSBASE, &layout->INSBASE, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LAYOUT.INSBASE [3DPOINT]");
  }
  {
    BITCODE_2DPOINT LIMMAX;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "LIMMAX", &LIMMAX, NULL)
        && !memcmp (&LIMMAX, &layout->LIMMAX, sizeof (BITCODE_2DPOINT)))
        pass ();
    else
        fail ("LAYOUT.LIMMAX [2DPOINT]");
  }
  {
    BITCODE_2DPOINT LIMMIN;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "LIMMIN", &LIMMIN, NULL)
        && !memcmp (&LIMMIN, &layout->LIMMIN, sizeof (BITCODE_2DPOINT)))
        pass ();
    else
        fail ("LAYOUT.LIMMIN [2DPOINT]");
  }
  {
    BITCODE_3DPOINT UCSORG;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "UCSORG", &UCSORG, NULL)
        && !memcmp (&UCSORG, &layout->UCSORG, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LAYOUT.UCSORG [3DPOINT]");
  }
  {
    BITCODE_BS UCSORTHOVIEW;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "UCSORTHOVIEW", &UCSORTHOVIEW, NULL)
        && UCSORTHOVIEW == layout->UCSORTHOVIEW)
      pass ();
    else
      fail ("LAYOUT.UCSORTHOVIEW [BS] %hu != %hu", layout->UCSORTHOVIEW, UCSORTHOVIEW);
    UCSORTHOVIEW++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "UCSORTHOVIEW", &UCSORTHOVIEW, 0)
        && UCSORTHOVIEW == layout->UCSORTHOVIEW)
      pass ();
    else
      fail ("LAYOUT.UCSORTHOVIEW [BS] set+1 %hu != %hu", layout->UCSORTHOVIEW, UCSORTHOVIEW);
    layout->UCSORTHOVIEW--;
  }
  {
    BITCODE_3DPOINT UCSXDIR;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "UCSXDIR", &UCSXDIR, NULL)
        && !memcmp (&UCSXDIR, &layout->UCSXDIR, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LAYOUT.UCSXDIR [3DPOINT]");
  }
  {
    BITCODE_3DPOINT UCSYDIR;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "UCSYDIR", &UCSYDIR, NULL)
        && !memcmp (&UCSYDIR, &layout->UCSYDIR, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LAYOUT.UCSYDIR [3DPOINT]");
  }
  {
    BITCODE_H active_viewport;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "active_viewport", &active_viewport, NULL)
        && !memcmp (&active_viewport, &layout->active_viewport, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYOUT.active_viewport [H]");
  }
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &layout->base_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYOUT.base_ucs [H]");
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "block_header", &block_header, NULL)
        && !memcmp (&block_header, &layout->block_header, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYOUT.block_header [H]");
  }
  {
    BITCODE_BS layout_flags;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "layout_flags", &layout_flags, NULL)
        && layout_flags == layout->layout_flags)
      pass ();
    else
      fail ("LAYOUT.layout_flags [BS] %hu != %hu", layout->layout_flags, layout_flags);
    layout_flags++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "layout_flags", &layout_flags, 0)
        && layout_flags == layout->layout_flags)
      pass ();
    else
      fail ("LAYOUT.layout_flags [BS] set+1 %hu != %hu", layout->layout_flags, layout_flags);
    layout->layout_flags--;
  }
  {
    BITCODE_T layout_name;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "layout_name", &layout_name, NULL)
        && layout_name
           ? strEQ ((char *)layout_name, (char *)layout->layout_name)
           : !layout->layout_name)
      pass ();
    else
      fail ("LAYOUT.layout_name [T] '%s' <> '%s'", layout_name, layout->layout_name);
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &layout->named_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LAYOUT.named_ucs [H]");
  }
  {
    BITCODE_BL num_viewports;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "num_viewports", &num_viewports, NULL)
        && num_viewports == layout->num_viewports)
      pass ();
    else
      fail ("LAYOUT.num_viewports [BL] %u != %u", layout->num_viewports, num_viewports);
    num_viewports++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "num_viewports", &num_viewports, 0)
        && num_viewports == layout->num_viewports)
      pass ();
    else
      fail ("LAYOUT.num_viewports [BL] set+1 %u != %u", layout->num_viewports, num_viewports);
    layout->num_viewports--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "parent", &parent, NULL)
        && !memcmp (&parent, &layout->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LAYOUT.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_Object_PLOTSETTINGS plotsettings;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "plotsettings", &plotsettings, NULL)
        && !memcmp (&plotsettings, &layout->plotsettings, sizeof (Dwg_Object_PLOTSETTINGS)))
        pass ();
    else
        fail ("LAYOUT.plotsettings [Dwg_Object_PLOTSETTINGS]");
  }
  {
    BITCODE_BS tab_order;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "tab_order", &tab_order, NULL)
        && tab_order == layout->tab_order)
      pass ();
    else
      fail ("LAYOUT.tab_order [BS] %hu != %hu", layout->tab_order, tab_order);
    tab_order++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "tab_order", &tab_order, 0)
        && tab_order == layout->tab_order)
      pass ();
    else
      fail ("LAYOUT.tab_order [BS] set+1 %hu != %hu", layout->tab_order, tab_order);
    layout->tab_order--;
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "ucs_elevation", &ucs_elevation, NULL)
        && ucs_elevation == layout->ucs_elevation)
      pass ();
    else
      fail ("LAYOUT.ucs_elevation [BD] %g != %g", layout->ucs_elevation, ucs_elevation);
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value (layout, "LAYOUT", "ucs_elevation", &ucs_elevation, 0)
        && ucs_elevation == layout->ucs_elevation)
      pass ();
    else
      fail ("LAYOUT.ucs_elevation [BD] set+1 %g != %g", layout->ucs_elevation, ucs_elevation);
    layout->ucs_elevation--;
  }
  {
    BITCODE_H* viewports;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (layout, "LAYOUT", "num_viewports", &count, NULL)
        && dwg_dynapi_entity_value (layout, "LAYOUT", "viewports", &viewports, NULL)
        && viewports == layout->viewports)
      pass ();
    else
      fail ("LAYOUT.viewports [H*] * %u num_viewports", count);
  }
  if (failed && (is_class_unstable ("LAYOUT") || is_class_debugging ("LAYOUT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYOUT", failed);
      failed = 0;
    }
  return failed;
}
static int test_LAYOUTPRINTCONFIG (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LAYOUTPRINTCONFIG *restrict layoutprintconfig = obj->tio.object->tio.LAYOUTPRINTCONFIG;
  failed = 0;
  if (!obj_obj || !layoutprintconfig)
    {
      fail ("NULL LAYOUTPRINTCONFIG");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (layoutprintconfig, "LAYOUTPRINTCONFIG", "class_version", &class_version, NULL)
        && class_version == layoutprintconfig->class_version)
      pass ();
    else
      fail ("LAYOUTPRINTCONFIG.class_version [BS] %hu != %hu", layoutprintconfig->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (layoutprintconfig, "LAYOUTPRINTCONFIG", "class_version", &class_version, 0)
        && class_version == layoutprintconfig->class_version)
      pass ();
    else
      fail ("LAYOUTPRINTCONFIG.class_version [BS] set+1 %hu != %hu", layoutprintconfig->class_version, class_version);
    layoutprintconfig->class_version--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (layoutprintconfig, "LAYOUTPRINTCONFIG", "flag", &flag, NULL)
        && flag == layoutprintconfig->flag)
      pass ();
    else
      fail ("LAYOUTPRINTCONFIG.flag [BS] %hu != %hu", layoutprintconfig->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (layoutprintconfig, "LAYOUTPRINTCONFIG", "flag", &flag, 0)
        && flag == layoutprintconfig->flag)
      pass ();
    else
      fail ("LAYOUTPRINTCONFIG.flag [BS] set+1 %hu != %hu", layoutprintconfig->flag, flag);
    layoutprintconfig->flag--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (layoutprintconfig, "LAYOUTPRINTCONFIG", "parent", &parent, NULL)
        && !memcmp (&parent, &layoutprintconfig->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LAYOUTPRINTCONFIG.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LAYOUTPRINTCONFIG") || is_class_debugging ("LAYOUTPRINTCONFIG")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LAYOUTPRINTCONFIG", failed);
      failed = 0;
    }
  return failed;
}
static int test_LEADEROBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LEADEROBJECTCONTEXTDATA *restrict leaderobjectcontextdata = obj->tio.object->tio.LEADEROBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !leaderobjectcontextdata)
    {
      fail ("NULL LEADEROBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_B b290;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "b290", &b290, NULL)
        && b290 == leaderobjectcontextdata->b290)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.b290 [B] " FORMAT_B " != " FORMAT_B "", leaderobjectcontextdata->b290, b290);
    b290++;
    if (dwg_dynapi_entity_set_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "b290", &b290, 0)
        && b290 == leaderobjectcontextdata->b290)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.b290 [B] set+1 " FORMAT_B " != " FORMAT_B "", leaderobjectcontextdata->b290, b290);
    leaderobjectcontextdata->b290--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == leaderobjectcontextdata->class_version)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.class_version [BS] %hu != %hu", leaderobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == leaderobjectcontextdata->class_version)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", leaderobjectcontextdata->class_version, class_version);
    leaderobjectcontextdata->class_version--;
  }
  {
    BITCODE_3DPOINT endptproj;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "endptproj", &endptproj, NULL)
        && !memcmp (&endptproj, &leaderobjectcontextdata->endptproj, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LEADEROBJECTCONTEXTDATA.endptproj [3DPOINT]");
  }
  {
    BITCODE_3DPOINT inspt_offset;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "inspt_offset", &inspt_offset, NULL)
        && !memcmp (&inspt_offset, &leaderobjectcontextdata->inspt_offset, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LEADEROBJECTCONTEXTDATA.inspt_offset [3DPOINT]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == leaderobjectcontextdata->is_default)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", leaderobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == leaderobjectcontextdata->is_default)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", leaderobjectcontextdata->is_default, is_default);
    leaderobjectcontextdata->is_default--;
  }
  {
    BITCODE_BL num_points;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "num_points", &num_points, NULL)
        && num_points == leaderobjectcontextdata->num_points)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.num_points [BL] %u != %u", leaderobjectcontextdata->num_points, num_points);
    num_points++;
    if (dwg_dynapi_entity_set_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "num_points", &num_points, 0)
        && num_points == leaderobjectcontextdata->num_points)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.num_points [BL] set+1 %u != %u", leaderobjectcontextdata->num_points, num_points);
    leaderobjectcontextdata->num_points--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &leaderobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LEADEROBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3DPOINT* points;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "num_points", &count, NULL)
        && dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "points", &points, NULL)
        && points == leaderobjectcontextdata->points)
      pass ();
    else
      fail ("LEADEROBJECTCONTEXTDATA.points [3DPOINT*] * %u num_points", count);
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &leaderobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LEADEROBJECTCONTEXTDATA.scale [H]");
  }
  {
    BITCODE_3DPOINT x_direction;
    if (dwg_dynapi_entity_value (leaderobjectcontextdata, "LEADEROBJECTCONTEXTDATA", "x_direction", &x_direction, NULL)
        && !memcmp (&x_direction, &leaderobjectcontextdata->x_direction, sizeof (BITCODE_3DPOINT)))
        pass ();
    else
        fail ("LEADEROBJECTCONTEXTDATA.x_direction [3DPOINT]");
  }
  if (failed && (is_class_unstable ("LEADEROBJECTCONTEXTDATA") || is_class_debugging ("LEADEROBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LEADEROBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_LIGHTLIST (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LIGHTLIST *restrict lightlist = obj->tio.object->tio.LIGHTLIST;
  failed = 0;
  if (!obj_obj || !lightlist)
    {
      fail ("NULL LIGHTLIST");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "class_version", &class_version, NULL)
        && class_version == lightlist->class_version)
      pass ();
    else
      fail ("LIGHTLIST.class_version [BL] %u != %u", lightlist->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (lightlist, "LIGHTLIST", "class_version", &class_version, 0)
        && class_version == lightlist->class_version)
      pass ();
    else
      fail ("LIGHTLIST.class_version [BL] set+1 %u != %u", lightlist->class_version, class_version);
    lightlist->class_version--;
  }
  {
    Dwg_LIGHTLIST_light* lights;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "num_lights", &count, NULL)
        && dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "lights", &lights, NULL)
        && lights == lightlist->lights)
      pass ();
    else
      fail ("LIGHTLIST.lights [Dwg_LIGHTLIST_light*] * %u num_lights", count);
  }
  {
    BITCODE_BL num_lights;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "num_lights", &num_lights, NULL)
        && num_lights == lightlist->num_lights)
      pass ();
    else
      fail ("LIGHTLIST.num_lights [BL] %u != %u", lightlist->num_lights, num_lights);
    num_lights++;
    if (dwg_dynapi_entity_set_value (lightlist, "LIGHTLIST", "num_lights", &num_lights, 0)
        && num_lights == lightlist->num_lights)
      pass ();
    else
      fail ("LIGHTLIST.num_lights [BL] set+1 %u != %u", lightlist->num_lights, num_lights);
    lightlist->num_lights--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (lightlist, "LIGHTLIST", "parent", &parent, NULL)
        && !memcmp (&parent, &lightlist->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LIGHTLIST.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LIGHTLIST") || is_class_debugging ("LIGHTLIST")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LIGHTLIST", failed);
      failed = 0;
    }
  return failed;
}
static int test_LONG_TRANSACTION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LONG_TRANSACTION *restrict long_transaction = obj->tio.object->tio.LONG_TRANSACTION;
  failed = 0;
  if (!obj_obj || !long_transaction)
    {
      fail ("NULL LONG_TRANSACTION");
      return 1;
    }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (long_transaction, "LONG_TRANSACTION", "parent", &parent, NULL)
        && !memcmp (&parent, &long_transaction->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LONG_TRANSACTION.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LONG_TRANSACTION") || is_class_debugging ("LONG_TRANSACTION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LONG_TRANSACTION", failed);
      failed = 0;
    }
  return failed;
}
static int test_LTYPE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LTYPE *restrict ltype = obj->tio.object->tio.LTYPE;
  failed = 0;
  if (!obj_obj || !ltype)
    {
      fail ("NULL LTYPE");
      return 1;
    }
  {
    BITCODE_RC alignment;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "alignment", &alignment, NULL)
        && alignment == ltype->alignment)
      pass ();
    else
      fail ("LTYPE.alignment [RC] %u != %u", ltype->alignment, alignment);
    alignment++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "alignment", &alignment, 0)
        && alignment == ltype->alignment)
      pass ();
    else
      fail ("LTYPE.alignment [RC] set+1 %u != %u", ltype->alignment, alignment);
    ltype->alignment--;
  }
  {
    Dwg_LTYPE_dash* dashes;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "numdashes", &count, NULL)
        && dwg_dynapi_entity_value (ltype, "LTYPE", "dashes", &dashes, NULL)
        && dashes == ltype->dashes)
      pass ();
    else
      fail ("LTYPE.dashes [Dwg_LTYPE_dash*] * %u numdashes", count);
  }
  {
    BITCODE_RD dashes_r11[12];
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "dashes_r11[12]", &dashes_r11, NULL)
        && !memcmp (&dashes_r11, &ltype->dashes_r11, sizeof (BITCODE_RD)))
        pass ();
    else
        fail ("LTYPE.dashes_r11[12] [RD]");
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)ltype->description)
           : !ltype->description)
      pass ();
    else
      fail ("LTYPE.description [T] '%s' <> '%s'", description, ltype->description);
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "flag", &flag, NULL)
        && flag == ltype->flag)
      pass ();
    else
      fail ("LTYPE.flag [RC] %u != %u", ltype->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "flag", &flag, 0)
        && flag == ltype->flag)
      pass ();
    else
      fail ("LTYPE.flag [RC] set+1 %u != %u", ltype->flag, flag);
    ltype->flag--;
  }
  {
    BITCODE_B has_strings_area;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "has_strings_area", &has_strings_area, NULL)
        && has_strings_area == ltype->has_strings_area)
      pass ();
    else
      fail ("LTYPE.has_strings_area [B] " FORMAT_B " != " FORMAT_B "", ltype->has_strings_area, has_strings_area);
    has_strings_area++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "has_strings_area", &has_strings_area, 0)
        && has_strings_area == ltype->has_strings_area)
      pass ();
    else
      fail ("LTYPE.has_strings_area [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->has_strings_area, has_strings_area);
    ltype->has_strings_area--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == ltype->is_xref_dep)
      pass ();
    else
      fail ("LTYPE.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", ltype->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == ltype->is_xref_dep)
      pass ();
    else
      fail ("LTYPE.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->is_xref_dep, is_xref_dep);
    ltype->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == ltype->is_xref_ref)
      pass ();
    else
      fail ("LTYPE.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", ltype->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == ltype->is_xref_ref)
      pass ();
    else
      fail ("LTYPE.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->is_xref_ref, is_xref_ref);
    ltype->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == ltype->is_xref_resolved)
      pass ();
    else
      fail ("LTYPE.is_xref_resolved [BS] %hu != %hu", ltype->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == ltype->is_xref_resolved)
      pass ();
    else
      fail ("LTYPE.is_xref_resolved [BS] set+1 %hu != %hu", ltype->is_xref_resolved, is_xref_resolved);
    ltype->is_xref_resolved--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)ltype->name)
           : !ltype->name)
      pass ();
    else
      fail ("LTYPE.name [TV] '%s' <> '%s'", name, ltype->name);
  }
  {
    BITCODE_RC numdashes;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "numdashes", &numdashes, NULL)
        && numdashes == ltype->numdashes)
      pass ();
    else
      fail ("LTYPE.numdashes [RC] %u != %u", ltype->numdashes, numdashes);
    numdashes++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "numdashes", &numdashes, 0)
        && numdashes == ltype->numdashes)
      pass ();
    else
      fail ("LTYPE.numdashes [RC] set+1 %u != %u", ltype->numdashes, numdashes);
    ltype->numdashes--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "parent", &parent, NULL)
        && !memcmp (&parent, &ltype->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LTYPE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD pattern_len;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "pattern_len", &pattern_len, NULL)
        && pattern_len == ltype->pattern_len)
      pass ();
    else
      fail ("LTYPE.pattern_len [BD] %g != %g", ltype->pattern_len, pattern_len);
    pattern_len++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "pattern_len", &pattern_len, 0)
        && pattern_len == ltype->pattern_len)
      pass ();
    else
      fail ("LTYPE.pattern_len [BD] set+1 %g != %g", ltype->pattern_len, pattern_len);
    ltype->pattern_len--;
  }
  {
    BITCODE_TF strings_area;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "strings_area", &strings_area, NULL)
        && !memcmp (&strings_area, &ltype->strings_area, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("LTYPE.strings_area [TF]");
  }
  {
    BITCODE_RC unknown_r11;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "unknown_r11", &unknown_r11, NULL)
        && unknown_r11 == ltype->unknown_r11)
      pass ();
    else
      fail ("LTYPE.unknown_r11 [RC] %u != %u", ltype->unknown_r11, unknown_r11);
    unknown_r11++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "unknown_r11", &unknown_r11, 0)
        && unknown_r11 == ltype->unknown_r11)
      pass ();
    else
      fail ("LTYPE.unknown_r11 [RC] set+1 %u != %u", ltype->unknown_r11, unknown_r11);
    ltype->unknown_r11--;
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "used", &used, NULL)
        && used == ltype->used)
      pass ();
    else
      fail ("LTYPE.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", ltype->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "used", &used, 0)
        && used == ltype->used)
      pass ();
    else
      fail ("LTYPE.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", ltype->used, used);
    ltype->used--;
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (ltype, "LTYPE", "xref", &xref, NULL)
        && !memcmp (&xref, &ltype->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LTYPE.xref [H]");
  }
  if (failed && (is_class_unstable ("LTYPE") || is_class_debugging ("LTYPE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LTYPE", failed);
      failed = 0;
    }
  return failed;
}
static int test_LTYPE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_LTYPE_CONTROL *restrict ltype_control = obj->tio.object->tio.LTYPE_CONTROL;
  failed = 0;
  if (!obj_obj || !ltype_control)
    {
      fail ("NULL LTYPE_CONTROL");
      return 1;
    }
  {
    BITCODE_H byblock;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "byblock", &byblock, NULL)
        && !memcmp (&byblock, &ltype_control->byblock, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LTYPE_CONTROL.byblock [H]");
  }
  {
    BITCODE_H bylayer;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "bylayer", &bylayer, NULL)
        && !memcmp (&bylayer, &ltype_control->bylayer, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("LTYPE_CONTROL.bylayer [H]");
  }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "entries", &entries, NULL)
        && entries == ltype_control->entries)
      pass ();
    else
      fail ("LTYPE_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == ltype_control->flags_r11)
      pass ();
    else
      fail ("LTYPE_CONTROL.flags_r11 [RS] %hu != %hu", ltype_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (ltype_control, "LTYPE_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == ltype_control->flags_r11)
      pass ();
    else
      fail ("LTYPE_CONTROL.flags_r11 [RS] set+1 %hu != %hu", ltype_control->flags_r11, flags_r11);
    ltype_control->flags_r11--;
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == ltype_control->num_entries)
      pass ();
    else
      fail ("LTYPE_CONTROL.num_entries [BS] %hu != %hu", ltype_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (ltype_control, "LTYPE_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == ltype_control->num_entries)
      pass ();
    else
      fail ("LTYPE_CONTROL.num_entries [BS] set+1 %hu != %hu", ltype_control->num_entries, num_entries);
    ltype_control->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ltype_control, "LTYPE_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &ltype_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("LTYPE_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("LTYPE_CONTROL") || is_class_debugging ("LTYPE_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "LTYPE_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_MATERIAL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MATERIAL *restrict material = obj->tio.object->tio.MATERIAL;
  failed = 0;
  if (!obj_obj || !material)
    {
      fail ("NULL MATERIAL");
      return 1;
    }
  {
    Dwg_MATERIAL_color ambient_color;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "ambient_color", &ambient_color, NULL)
        && !memcmp (&ambient_color, &material->ambient_color, sizeof (Dwg_MATERIAL_color)))
        pass ();
    else
        fail ("MATERIAL.ambient_color [Dwg_MATERIAL_color]");
  }
  {
    Dwg_MATERIAL_mapper bumpmap;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "bumpmap", &bumpmap, NULL)
        && !memcmp (&bumpmap, &material->bumpmap, sizeof (Dwg_MATERIAL_mapper)))
        pass ();
    else
        fail ("MATERIAL.bumpmap [Dwg_MATERIAL_mapper]");
  }
  {
    BITCODE_BL channel_flags;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "channel_flags", &channel_flags, NULL)
        && channel_flags == material->channel_flags)
      pass ();
    else
      fail ("MATERIAL.channel_flags [BL] %u != %u", material->channel_flags, channel_flags);
    channel_flags++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "channel_flags", &channel_flags, 0)
        && channel_flags == material->channel_flags)
      pass ();
    else
      fail ("MATERIAL.channel_flags [BL] set+1 %u != %u", material->channel_flags, channel_flags);
    material->channel_flags--;
  }
  {
    BITCODE_BD color_bleed_scale;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "color_bleed_scale", &color_bleed_scale, NULL)
        && color_bleed_scale == material->color_bleed_scale)
      pass ();
    else
      fail ("MATERIAL.color_bleed_scale [BD] %g != %g", material->color_bleed_scale, color_bleed_scale);
    color_bleed_scale++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "color_bleed_scale", &color_bleed_scale, 0)
        && color_bleed_scale == material->color_bleed_scale)
      pass ();
    else
      fail ("MATERIAL.color_bleed_scale [BD] set+1 %g != %g", material->color_bleed_scale, color_bleed_scale);
    material->color_bleed_scale--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)material->description)
           : !material->description)
      pass ();
    else
      fail ("MATERIAL.description [T] '%s' <> '%s'", description, material->description);
  }
  {
    Dwg_MATERIAL_color diffuse_color;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffuse_color", &diffuse_color, NULL)
        && !memcmp (&diffuse_color, &material->diffuse_color, sizeof (Dwg_MATERIAL_color)))
        pass ();
    else
        fail ("MATERIAL.diffuse_color [Dwg_MATERIAL_color]");
  }
  {
    Dwg_MATERIAL_mapper diffusemap;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "diffusemap", &diffusemap, NULL)
        && !memcmp (&diffusemap, &material->diffusemap, sizeof (Dwg_MATERIAL_mapper)))
        pass ();
    else
        fail ("MATERIAL.diffusemap [Dwg_MATERIAL_mapper]");
  }
  {
    BITCODE_T genprocname;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocname", &genprocname, NULL)
        && genprocname
           ? strEQ ((char *)genprocname, (char *)material->genprocname)
           : !material->genprocname)
      pass ();
    else
      fail ("MATERIAL.genprocname [T] '%s' <> '%s'", genprocname, material->genprocname);
  }
  {
    BITCODE_B genproctableend;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genproctableend", &genproctableend, NULL)
        && genproctableend == material->genproctableend)
      pass ();
    else
      fail ("MATERIAL.genproctableend [B] " FORMAT_B " != " FORMAT_B "", material->genproctableend, genproctableend);
    genproctableend++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genproctableend", &genproctableend, 0)
        && genproctableend == material->genproctableend)
      pass ();
    else
      fail ("MATERIAL.genproctableend [B] set+1 " FORMAT_B " != " FORMAT_B "", material->genproctableend, genproctableend);
    material->genproctableend--;
  }
  {
    BITCODE_BS genproctype;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genproctype", &genproctype, NULL)
        && genproctype == material->genproctype)
      pass ();
    else
      fail ("MATERIAL.genproctype [BS] %hu != %hu", material->genproctype, genproctype);
    genproctype++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genproctype", &genproctype, 0)
        && genproctype == material->genproctype)
      pass ();
    else
      fail ("MATERIAL.genproctype [BS] set+1 %hu != %hu", material->genproctype, genproctype);
    material->genproctype--;
  }
  {
    BITCODE_B genprocvalbool;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalbool", &genprocvalbool, NULL)
        && genprocvalbool == material->genprocvalbool)
      pass ();
    else
      fail ("MATERIAL.genprocvalbool [B] " FORMAT_B " != " FORMAT_B "", material->genprocvalbool, genprocvalbool);
    genprocvalbool++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genprocvalbool", &genprocvalbool, 0)
        && genprocvalbool == material->genprocvalbool)
      pass ();
    else
      fail ("MATERIAL.genprocvalbool [B] set+1 " FORMAT_B " != " FORMAT_B "", material->genprocvalbool, genprocvalbool);
    material->genprocvalbool--;
  }
  {
    BITCODE_CMC genprocvalcolor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalcolor", &genprocvalcolor, NULL)
        && !memcmp (&genprocvalcolor, &material->genprocvalcolor, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MATERIAL.genprocvalcolor [CMC]");
  }
  {
    BITCODE_BS genprocvalint;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalint", &genprocvalint, NULL)
        && genprocvalint == material->genprocvalint)
      pass ();
    else
      fail ("MATERIAL.genprocvalint [BS] %hu != %hu", material->genprocvalint, genprocvalint);
    genprocvalint++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genprocvalint", &genprocvalint, 0)
        && genprocvalint == material->genprocvalint)
      pass ();
    else
      fail ("MATERIAL.genprocvalint [BS] set+1 %hu != %hu", material->genprocvalint, genprocvalint);
    material->genprocvalint--;
  }
  {
    BITCODE_BD genprocvalreal;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvalreal", &genprocvalreal, NULL)
        && genprocvalreal == material->genprocvalreal)
      pass ();
    else
      fail ("MATERIAL.genprocvalreal [BD] %g != %g", material->genprocvalreal, genprocvalreal);
    genprocvalreal++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "genprocvalreal", &genprocvalreal, 0)
        && genprocvalreal == material->genprocvalreal)
      pass ();
    else
      fail ("MATERIAL.genprocvalreal [BD] set+1 %g != %g", material->genprocvalreal, genprocvalreal);
    material->genprocvalreal--;
  }
  {
    BITCODE_T genprocvaltext;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "genprocvaltext", &genprocvaltext, NULL)
        && genprocvaltext
           ? strEQ ((char *)genprocvaltext, (char *)material->genprocvaltext)
           : !material->genprocvaltext)
      pass ();
    else
      fail ("MATERIAL.genprocvaltext [T] '%s' <> '%s'", genprocvaltext, material->genprocvaltext);
  }
  {
    Dwg_MATERIAL_gentexture* gentextures;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "num_gentextures", &count, NULL)
        && dwg_dynapi_entity_value (material, "MATERIAL", "gentextures", &gentextures, NULL)
        && gentextures == material->gentextures)
      pass ();
    else
      fail ("MATERIAL.gentextures [Dwg_MATERIAL_gentexture*] * %u num_gentextures", count);
  }
  {
    BITCODE_BL illumination_model;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "illumination_model", &illumination_model, NULL)
        && illumination_model == material->illumination_model)
      pass ();
    else
      fail ("MATERIAL.illumination_model [BL] %u != %u", material->illumination_model, illumination_model);
    illumination_model++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "illumination_model", &illumination_model, 0)
        && illumination_model == material->illumination_model)
      pass ();
    else
      fail ("MATERIAL.illumination_model [BL] set+1 %u != %u", material->illumination_model, illumination_model);
    material->illumination_model--;
  }
  {
    BITCODE_BD indirect_bump_scale;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "indirect_bump_scale", &indirect_bump_scale, NULL)
        && indirect_bump_scale == material->indirect_bump_scale)
      pass ();
    else
      fail ("MATERIAL.indirect_bump_scale [BD] %g != %g", material->indirect_bump_scale, indirect_bump_scale);
    indirect_bump_scale++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "indirect_bump_scale", &indirect_bump_scale, 0)
        && indirect_bump_scale == material->indirect_bump_scale)
      pass ();
    else
      fail ("MATERIAL.indirect_bump_scale [BD] set+1 %g != %g", material->indirect_bump_scale, indirect_bump_scale);
    material->indirect_bump_scale--;
  }
  {
    BITCODE_BD luminance;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "luminance", &luminance, NULL)
        && luminance == material->luminance)
      pass ();
    else
      fail ("MATERIAL.luminance [BD] %g != %g", material->luminance, luminance);
    luminance++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "luminance", &luminance, 0)
        && luminance == material->luminance)
      pass ();
    else
      fail ("MATERIAL.luminance [BD] set+1 %g != %g", material->luminance, luminance);
    material->luminance--;
  }
  {
    BITCODE_BS luminance_mode;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "luminance_mode", &luminance_mode, NULL)
        && luminance_mode == material->luminance_mode)
      pass ();
    else
      fail ("MATERIAL.luminance_mode [BS] %hu != %hu", material->luminance_mode, luminance_mode);
    luminance_mode++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "luminance_mode", &luminance_mode, 0)
        && luminance_mode == material->luminance_mode)
      pass ();
    else
      fail ("MATERIAL.luminance_mode [BS] set+1 %hu != %hu", material->luminance_mode, luminance_mode);
    material->luminance_mode--;
  }
  {
    BITCODE_BL mode;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "mode", &mode, NULL)
        && mode == material->mode)
      pass ();
    else
      fail ("MATERIAL.mode [BL] %u != %u", material->mode, mode);
    mode++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "mode", &mode, 0)
        && mode == material->mode)
      pass ();
    else
      fail ("MATERIAL.mode [BL] set+1 %u != %u", material->mode, mode);
    material->mode--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)material->name)
           : !material->name)
      pass ();
    else
      fail ("MATERIAL.name [T] '%s' <> '%s'", name, material->name);
  }
  {
    BITCODE_BS num_gentextures;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "num_gentextures", &num_gentextures, NULL)
        && num_gentextures == material->num_gentextures)
      pass ();
    else
      fail ("MATERIAL.num_gentextures [BS] %hu != %hu", material->num_gentextures, num_gentextures);
    num_gentextures++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "num_gentextures", &num_gentextures, 0)
        && num_gentextures == material->num_gentextures)
      pass ();
    else
      fail ("MATERIAL.num_gentextures [BS] set+1 %hu != %hu", material->num_gentextures, num_gentextures);
    material->num_gentextures--;
  }
  {
    BITCODE_BD opacity_percent;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacity_percent", &opacity_percent, NULL)
        && opacity_percent == material->opacity_percent)
      pass ();
    else
      fail ("MATERIAL.opacity_percent [BD] %g != %g", material->opacity_percent, opacity_percent);
    opacity_percent++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "opacity_percent", &opacity_percent, 0)
        && opacity_percent == material->opacity_percent)
      pass ();
    else
      fail ("MATERIAL.opacity_percent [BD] set+1 %g != %g", material->opacity_percent, opacity_percent);
    material->opacity_percent--;
  }
  {
    Dwg_MATERIAL_mapper opacitymap;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "opacitymap", &opacitymap, NULL)
        && !memcmp (&opacitymap, &material->opacitymap, sizeof (Dwg_MATERIAL_mapper)))
        pass ();
    else
        fail ("MATERIAL.opacitymap [Dwg_MATERIAL_mapper]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "parent", &parent, NULL)
        && !memcmp (&parent, &material->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("MATERIAL.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD reflectance_scale;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectance_scale", &reflectance_scale, NULL)
        && reflectance_scale == material->reflectance_scale)
      pass ();
    else
      fail ("MATERIAL.reflectance_scale [BD] %g != %g", material->reflectance_scale, reflectance_scale);
    reflectance_scale++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectance_scale", &reflectance_scale, 0)
        && reflectance_scale == material->reflectance_scale)
      pass ();
    else
      fail ("MATERIAL.reflectance_scale [BD] set+1 %g != %g", material->reflectance_scale, reflectance_scale);
    material->reflectance_scale--;
  }
  {
    Dwg_MATERIAL_mapper reflectionmap;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectionmap", &reflectionmap, NULL)
        && !memcmp (&reflectionmap, &material->reflectionmap, sizeof (Dwg_MATERIAL_mapper)))
        pass ();
    else
        fail ("MATERIAL.reflectionmap [Dwg_MATERIAL_mapper]");
  }
  {
    BITCODE_BD reflectivity;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "reflectivity", &reflectivity, NULL)
        && reflectivity == material->reflectivity)
      pass ();
    else
      fail ("MATERIAL.reflectivity [BD] %g != %g", material->reflectivity, reflectivity);
    reflectivity++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "reflectivity", &reflectivity, 0)
        && reflectivity == material->reflectivity)
      pass ();
    else
      fail ("MATERIAL.reflectivity [BD] set+1 %g != %g", material->reflectivity, reflectivity);
    material->reflectivity--;
  }
  {
    BITCODE_BD refraction_index;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refraction_index", &refraction_index, NULL)
        && refraction_index == material->refraction_index)
      pass ();
    else
      fail ("MATERIAL.refraction_index [BD] %g != %g", material->refraction_index, refraction_index);
    refraction_index++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "refraction_index", &refraction_index, 0)
        && refraction_index == material->refraction_index)
      pass ();
    else
      fail ("MATERIAL.refraction_index [BD] set+1 %g != %g", material->refraction_index, refraction_index);
    material->refraction_index--;
  }
  {
    Dwg_MATERIAL_mapper refractionmap;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "refractionmap", &refractionmap, NULL)
        && !memcmp (&refractionmap, &material->refractionmap, sizeof (Dwg_MATERIAL_mapper)))
        pass ();
    else
        fail ("MATERIAL.refractionmap [Dwg_MATERIAL_mapper]");
  }
  {
    BITCODE_BD self_illumination;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "self_illumination", &self_illumination, NULL)
        && self_illumination == material->self_illumination)
      pass ();
    else
      fail ("MATERIAL.self_illumination [BD] %g != %g", material->self_illumination, self_illumination);
    self_illumination++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "self_illumination", &self_illumination, 0)
        && self_illumination == material->self_illumination)
      pass ();
    else
      fail ("MATERIAL.self_illumination [BD] set+1 %g != %g", material->self_illumination, self_illumination);
    material->self_illumination--;
  }
  {
    Dwg_MATERIAL_color specular_color;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specular_color", &specular_color, NULL)
        && !memcmp (&specular_color, &material->specular_color, sizeof (Dwg_MATERIAL_color)))
        pass ();
    else
        fail ("MATERIAL.specular_color [Dwg_MATERIAL_color]");
  }
  {
    BITCODE_BD specular_gloss_factor;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specular_gloss_factor", &specular_gloss_factor, NULL)
        && specular_gloss_factor == material->specular_gloss_factor)
      pass ();
    else
      fail ("MATERIAL.specular_gloss_factor [BD] %g != %g", material->specular_gloss_factor, specular_gloss_factor);
    specular_gloss_factor++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "specular_gloss_factor", &specular_gloss_factor, 0)
        && specular_gloss_factor == material->specular_gloss_factor)
      pass ();
    else
      fail ("MATERIAL.specular_gloss_factor [BD] set+1 %g != %g", material->specular_gloss_factor, specular_gloss_factor);
    material->specular_gloss_factor--;
  }
  {
    Dwg_MATERIAL_mapper specularmap;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "specularmap", &specularmap, NULL)
        && !memcmp (&specularmap, &material->specularmap, sizeof (Dwg_MATERIAL_mapper)))
        pass ();
    else
        fail ("MATERIAL.specularmap [Dwg_MATERIAL_mapper]");
  }
  {
    BITCODE_BD translucence;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "translucence", &translucence, NULL)
        && translucence == material->translucence)
      pass ();
    else
      fail ("MATERIAL.translucence [BD] %g != %g", material->translucence, translucence);
    translucence++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "translucence", &translucence, 0)
        && translucence == material->translucence)
      pass ();
    else
      fail ("MATERIAL.translucence [BD] set+1 %g != %g", material->translucence, translucence);
    material->translucence--;
  }
  {
    BITCODE_BD transmittance_scale;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "transmittance_scale", &transmittance_scale, NULL)
        && transmittance_scale == material->transmittance_scale)
      pass ();
    else
      fail ("MATERIAL.transmittance_scale [BD] %g != %g", material->transmittance_scale, transmittance_scale);
    transmittance_scale++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "transmittance_scale", &transmittance_scale, 0)
        && transmittance_scale == material->transmittance_scale)
      pass ();
    else
      fail ("MATERIAL.transmittance_scale [BD] set+1 %g != %g", material->transmittance_scale, transmittance_scale);
    material->transmittance_scale--;
  }
  {
    BITCODE_B two_sided_material;
    if (dwg_dynapi_entity_value (material, "MATERIAL", "two_sided_material", &two_sided_material, NULL)
        && two_sided_material == material->two_sided_material)
      pass ();
    else
      fail ("MATERIAL.two_sided_material [B] " FORMAT_B " != " FORMAT_B "", material->two_sided_material, two_sided_material);
    two_sided_material++;
    if (dwg_dynapi_entity_set_value (material, "MATERIAL", "two_sided_material", &two_sided_material, 0)
        && two_sided_material == material->two_sided_material)
      pass ();
    else
      fail ("MATERIAL.two_sided_material [B] set+1 " FORMAT_B " != " FORMAT_B "", material->two_sided_material, two_sided_material);
    material->two_sided_material--;
  }
  if (failed && (is_class_unstable ("MATERIAL") || is_class_debugging ("MATERIAL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MATERIAL", failed);
      failed = 0;
    }
  return failed;
}
static int test_MENTALRAYRENDERSETTINGS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MENTALRAYRENDERSETTINGS *restrict mentalrayrendersettings = obj->tio.object->tio.MENTALRAYRENDERSETTINGS;
  failed = 0;
  if (!obj_obj || !mentalrayrendersettings)
    {
      fail ("NULL MENTALRAYRENDERSETTINGS");
      return 1;
    }
  {
    BITCODE_B backfaces_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "backfaces_enabled", &backfaces_enabled, NULL)
        && backfaces_enabled == mentalrayrendersettings->backfaces_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.backfaces_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->backfaces_enabled, backfaces_enabled);
    backfaces_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "backfaces_enabled", &backfaces_enabled, 0)
        && backfaces_enabled == mentalrayrendersettings->backfaces_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.backfaces_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->backfaces_enabled, backfaces_enabled);
    mentalrayrendersettings->backfaces_enabled--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "class_version", &class_version, NULL)
        && class_version == mentalrayrendersettings->class_version)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.class_version [BL] %u != %u", mentalrayrendersettings->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "class_version", &class_version, 0)
        && class_version == mentalrayrendersettings->class_version)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.class_version [BL] set+1 %u != %u", mentalrayrendersettings->class_version, class_version);
    mentalrayrendersettings->class_version--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)mentalrayrendersettings->description)
           : !mentalrayrendersettings->description)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.description [T] '%s' <> '%s'", description, mentalrayrendersettings->description);
  }
  {
    BITCODE_BS diagnostics_bsp_mode;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_bsp_mode", &diagnostics_bsp_mode, NULL)
        && diagnostics_bsp_mode == mentalrayrendersettings->diagnostics_bsp_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_bsp_mode [BS] %hu != %hu", mentalrayrendersettings->diagnostics_bsp_mode, diagnostics_bsp_mode);
    diagnostics_bsp_mode++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_bsp_mode", &diagnostics_bsp_mode, 0)
        && diagnostics_bsp_mode == mentalrayrendersettings->diagnostics_bsp_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_bsp_mode [BS] set+1 %hu != %hu", mentalrayrendersettings->diagnostics_bsp_mode, diagnostics_bsp_mode);
    mentalrayrendersettings->diagnostics_bsp_mode--;
  }
  {
    BITCODE_BD diagnostics_grid_float;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_grid_float", &diagnostics_grid_float, NULL)
        && diagnostics_grid_float == mentalrayrendersettings->diagnostics_grid_float)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_grid_float [BD] %g != %g", mentalrayrendersettings->diagnostics_grid_float, diagnostics_grid_float);
    diagnostics_grid_float++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_grid_float", &diagnostics_grid_float, 0)
        && diagnostics_grid_float == mentalrayrendersettings->diagnostics_grid_float)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_grid_float [BD] set+1 %g != %g", mentalrayrendersettings->diagnostics_grid_float, diagnostics_grid_float);
    mentalrayrendersettings->diagnostics_grid_float--;
  }
  {
    BITCODE_BS diagnostics_grid_mode;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_grid_mode", &diagnostics_grid_mode, NULL)
        && diagnostics_grid_mode == mentalrayrendersettings->diagnostics_grid_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_grid_mode [BS] %hu != %hu", mentalrayrendersettings->diagnostics_grid_mode, diagnostics_grid_mode);
    diagnostics_grid_mode++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_grid_mode", &diagnostics_grid_mode, 0)
        && diagnostics_grid_mode == mentalrayrendersettings->diagnostics_grid_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_grid_mode [BS] set+1 %hu != %hu", mentalrayrendersettings->diagnostics_grid_mode, diagnostics_grid_mode);
    mentalrayrendersettings->diagnostics_grid_mode--;
  }
  {
    BITCODE_BS diagnostics_mode;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_mode", &diagnostics_mode, NULL)
        && diagnostics_mode == mentalrayrendersettings->diagnostics_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_mode [BS] %hu != %hu", mentalrayrendersettings->diagnostics_mode, diagnostics_mode);
    diagnostics_mode++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_mode", &diagnostics_mode, 0)
        && diagnostics_mode == mentalrayrendersettings->diagnostics_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_mode [BS] set+1 %hu != %hu", mentalrayrendersettings->diagnostics_mode, diagnostics_mode);
    mentalrayrendersettings->diagnostics_mode--;
  }
  {
    BITCODE_BS diagnostics_photon_mode;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_photon_mode", &diagnostics_photon_mode, NULL)
        && diagnostics_photon_mode == mentalrayrendersettings->diagnostics_photon_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_photon_mode [BS] %hu != %hu", mentalrayrendersettings->diagnostics_photon_mode, diagnostics_photon_mode);
    diagnostics_photon_mode++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_photon_mode", &diagnostics_photon_mode, 0)
        && diagnostics_photon_mode == mentalrayrendersettings->diagnostics_photon_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_photon_mode [BS] set+1 %hu != %hu", mentalrayrendersettings->diagnostics_photon_mode, diagnostics_photon_mode);
    mentalrayrendersettings->diagnostics_photon_mode--;
  }
  {
    BITCODE_B diagnostics_samples_mode;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_samples_mode", &diagnostics_samples_mode, NULL)
        && diagnostics_samples_mode == mentalrayrendersettings->diagnostics_samples_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_samples_mode [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->diagnostics_samples_mode, diagnostics_samples_mode);
    diagnostics_samples_mode++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "diagnostics_samples_mode", &diagnostics_samples_mode, 0)
        && diagnostics_samples_mode == mentalrayrendersettings->diagnostics_samples_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.diagnostics_samples_mode [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->diagnostics_samples_mode, diagnostics_samples_mode);
    mentalrayrendersettings->diagnostics_samples_mode--;
  }
  {
    BITCODE_BL display_index;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "display_index", &display_index, NULL)
        && display_index == mentalrayrendersettings->display_index)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.display_index [BL] %u != %u", mentalrayrendersettings->display_index, display_index);
    display_index++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "display_index", &display_index, 0)
        && display_index == mentalrayrendersettings->display_index)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.display_index [BL] set+1 %u != %u", mentalrayrendersettings->display_index, display_index);
    mentalrayrendersettings->display_index--;
  }
  {
    BITCODE_BD energy_multiplier;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "energy_multiplier", &energy_multiplier, NULL)
        && energy_multiplier == mentalrayrendersettings->energy_multiplier)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.energy_multiplier [BD] %g != %g", mentalrayrendersettings->energy_multiplier, energy_multiplier);
    energy_multiplier++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "energy_multiplier", &energy_multiplier, 0)
        && energy_multiplier == mentalrayrendersettings->energy_multiplier)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.energy_multiplier [BD] set+1 %g != %g", mentalrayrendersettings->energy_multiplier, energy_multiplier);
    mentalrayrendersettings->energy_multiplier--;
  }
  {
    BITCODE_B environ_image_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "environ_image_enabled", &environ_image_enabled, NULL)
        && environ_image_enabled == mentalrayrendersettings->environ_image_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.environ_image_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->environ_image_enabled, environ_image_enabled);
    environ_image_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "environ_image_enabled", &environ_image_enabled, 0)
        && environ_image_enabled == mentalrayrendersettings->environ_image_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.environ_image_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->environ_image_enabled, environ_image_enabled);
    mentalrayrendersettings->environ_image_enabled--;
  }
  {
    BITCODE_T environ_image_filename;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "environ_image_filename", &environ_image_filename, NULL)
        && environ_image_filename
           ? strEQ ((char *)environ_image_filename, (char *)mentalrayrendersettings->environ_image_filename)
           : !mentalrayrendersettings->environ_image_filename)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.environ_image_filename [T] '%s' <> '%s'", environ_image_filename, mentalrayrendersettings->environ_image_filename);
  }
  {
    BITCODE_B export_mi_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "export_mi_enabled", &export_mi_enabled, NULL)
        && export_mi_enabled == mentalrayrendersettings->export_mi_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.export_mi_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->export_mi_enabled, export_mi_enabled);
    export_mi_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "export_mi_enabled", &export_mi_enabled, 0)
        && export_mi_enabled == mentalrayrendersettings->export_mi_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.export_mi_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->export_mi_enabled, export_mi_enabled);
    mentalrayrendersettings->export_mi_enabled--;
  }
  {
    BITCODE_BL fg_ray_count;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_ray_count", &fg_ray_count, NULL)
        && fg_ray_count == mentalrayrendersettings->fg_ray_count)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_ray_count [BL] %u != %u", mentalrayrendersettings->fg_ray_count, fg_ray_count);
    fg_ray_count++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_ray_count", &fg_ray_count, 0)
        && fg_ray_count == mentalrayrendersettings->fg_ray_count)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_ray_count [BL] set+1 %u != %u", mentalrayrendersettings->fg_ray_count, fg_ray_count);
    mentalrayrendersettings->fg_ray_count--;
  }
  {
    BITCODE_BD fg_sample_radius1;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius1", &fg_sample_radius1, NULL)
        && fg_sample_radius1 == mentalrayrendersettings->fg_sample_radius1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius1 [BD] %g != %g", mentalrayrendersettings->fg_sample_radius1, fg_sample_radius1);
    fg_sample_radius1++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius1", &fg_sample_radius1, 0)
        && fg_sample_radius1 == mentalrayrendersettings->fg_sample_radius1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius1 [BD] set+1 %g != %g", mentalrayrendersettings->fg_sample_radius1, fg_sample_radius1);
    mentalrayrendersettings->fg_sample_radius1--;
  }
  {
    BITCODE_BD fg_sample_radius2;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius2", &fg_sample_radius2, NULL)
        && fg_sample_radius2 == mentalrayrendersettings->fg_sample_radius2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius2 [BD] %g != %g", mentalrayrendersettings->fg_sample_radius2, fg_sample_radius2);
    fg_sample_radius2++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius2", &fg_sample_radius2, 0)
        && fg_sample_radius2 == mentalrayrendersettings->fg_sample_radius2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius2 [BD] set+1 %g != %g", mentalrayrendersettings->fg_sample_radius2, fg_sample_radius2);
    mentalrayrendersettings->fg_sample_radius2--;
  }
  {
    BITCODE_B fg_sample_radius_state1;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius_state1", &fg_sample_radius_state1, NULL)
        && fg_sample_radius_state1 == mentalrayrendersettings->fg_sample_radius_state1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius_state1 [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fg_sample_radius_state1, fg_sample_radius_state1);
    fg_sample_radius_state1++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius_state1", &fg_sample_radius_state1, 0)
        && fg_sample_radius_state1 == mentalrayrendersettings->fg_sample_radius_state1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius_state1 [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fg_sample_radius_state1, fg_sample_radius_state1);
    mentalrayrendersettings->fg_sample_radius_state1--;
  }
  {
    BITCODE_B fg_sample_radius_state2;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius_state2", &fg_sample_radius_state2, NULL)
        && fg_sample_radius_state2 == mentalrayrendersettings->fg_sample_radius_state2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius_state2 [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fg_sample_radius_state2, fg_sample_radius_state2);
    fg_sample_radius_state2++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius_state2", &fg_sample_radius_state2, 0)
        && fg_sample_radius_state2 == mentalrayrendersettings->fg_sample_radius_state2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius_state2 [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fg_sample_radius_state2, fg_sample_radius_state2);
    mentalrayrendersettings->fg_sample_radius_state2--;
  }
  {
    BITCODE_B fg_sample_radius_state3;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius_state3", &fg_sample_radius_state3, NULL)
        && fg_sample_radius_state3 == mentalrayrendersettings->fg_sample_radius_state3)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius_state3 [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fg_sample_radius_state3, fg_sample_radius_state3);
    fg_sample_radius_state3++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fg_sample_radius_state3", &fg_sample_radius_state3, 0)
        && fg_sample_radius_state3 == mentalrayrendersettings->fg_sample_radius_state3)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fg_sample_radius_state3 [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fg_sample_radius_state3, fg_sample_radius_state3);
    mentalrayrendersettings->fg_sample_radius_state3--;
  }
  {
    BITCODE_B final_gathering_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "final_gathering_enabled", &final_gathering_enabled, NULL)
        && final_gathering_enabled == mentalrayrendersettings->final_gathering_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.final_gathering_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->final_gathering_enabled, final_gathering_enabled);
    final_gathering_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "final_gathering_enabled", &final_gathering_enabled, 0)
        && final_gathering_enabled == mentalrayrendersettings->final_gathering_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.final_gathering_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->final_gathering_enabled, final_gathering_enabled);
    mentalrayrendersettings->final_gathering_enabled--;
  }
  {
    BITCODE_B fog_background_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fog_background_enabled", &fog_background_enabled, NULL)
        && fog_background_enabled == mentalrayrendersettings->fog_background_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fog_background_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fog_background_enabled, fog_background_enabled);
    fog_background_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fog_background_enabled", &fog_background_enabled, 0)
        && fog_background_enabled == mentalrayrendersettings->fog_background_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fog_background_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fog_background_enabled, fog_background_enabled);
    mentalrayrendersettings->fog_background_enabled--;
  }
  {
    BITCODE_B fog_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fog_enabled", &fog_enabled, NULL)
        && fog_enabled == mentalrayrendersettings->fog_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fog_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fog_enabled, fog_enabled);
    fog_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "fog_enabled", &fog_enabled, 0)
        && fog_enabled == mentalrayrendersettings->fog_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.fog_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->fog_enabled, fog_enabled);
    mentalrayrendersettings->fog_enabled--;
  }
  {
    BITCODE_BL gi_photons_per_light;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "gi_photons_per_light", &gi_photons_per_light, NULL)
        && gi_photons_per_light == mentalrayrendersettings->gi_photons_per_light)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.gi_photons_per_light [BL] %u != %u", mentalrayrendersettings->gi_photons_per_light, gi_photons_per_light);
    gi_photons_per_light++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "gi_photons_per_light", &gi_photons_per_light, 0)
        && gi_photons_per_light == mentalrayrendersettings->gi_photons_per_light)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.gi_photons_per_light [BL] set+1 %u != %u", mentalrayrendersettings->gi_photons_per_light, gi_photons_per_light);
    mentalrayrendersettings->gi_photons_per_light--;
  }
  {
    BITCODE_BL gi_sample_count;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "gi_sample_count", &gi_sample_count, NULL)
        && gi_sample_count == mentalrayrendersettings->gi_sample_count)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.gi_sample_count [BL] %u != %u", mentalrayrendersettings->gi_sample_count, gi_sample_count);
    gi_sample_count++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "gi_sample_count", &gi_sample_count, 0)
        && gi_sample_count == mentalrayrendersettings->gi_sample_count)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.gi_sample_count [BL] set+1 %u != %u", mentalrayrendersettings->gi_sample_count, gi_sample_count);
    mentalrayrendersettings->gi_sample_count--;
  }
  {
    BITCODE_BD gi_sample_radius;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "gi_sample_radius", &gi_sample_radius, NULL)
        && gi_sample_radius == mentalrayrendersettings->gi_sample_radius)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.gi_sample_radius [BD] %g != %g", mentalrayrendersettings->gi_sample_radius, gi_sample_radius);
    gi_sample_radius++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "gi_sample_radius", &gi_sample_radius, 0)
        && gi_sample_radius == mentalrayrendersettings->gi_sample_radius)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.gi_sample_radius [BD] set+1 %g != %g", mentalrayrendersettings->gi_sample_radius, gi_sample_radius);
    mentalrayrendersettings->gi_sample_radius--;
  }
  {
    BITCODE_B gi_sample_radius_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "gi_sample_radius_enabled", &gi_sample_radius_enabled, NULL)
        && gi_sample_radius_enabled == mentalrayrendersettings->gi_sample_radius_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.gi_sample_radius_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->gi_sample_radius_enabled, gi_sample_radius_enabled);
    gi_sample_radius_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "gi_sample_radius_enabled", &gi_sample_radius_enabled, 0)
        && gi_sample_radius_enabled == mentalrayrendersettings->gi_sample_radius_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.gi_sample_radius_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->gi_sample_radius_enabled, gi_sample_radius_enabled);
    mentalrayrendersettings->gi_sample_radius_enabled--;
  }
  {
    BITCODE_B global_illumination_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "global_illumination_enabled", &global_illumination_enabled, NULL)
        && global_illumination_enabled == mentalrayrendersettings->global_illumination_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.global_illumination_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->global_illumination_enabled, global_illumination_enabled);
    global_illumination_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "global_illumination_enabled", &global_illumination_enabled, 0)
        && global_illumination_enabled == mentalrayrendersettings->global_illumination_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.global_illumination_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->global_illumination_enabled, global_illumination_enabled);
    mentalrayrendersettings->global_illumination_enabled--;
  }
  {
    BITCODE_B has_predefined;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "has_predefined", &has_predefined, NULL)
        && has_predefined == mentalrayrendersettings->has_predefined)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.has_predefined [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->has_predefined, has_predefined);
    has_predefined++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "has_predefined", &has_predefined, 0)
        && has_predefined == mentalrayrendersettings->has_predefined)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.has_predefined [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->has_predefined, has_predefined);
    mentalrayrendersettings->has_predefined--;
  }
  {
    BITCODE_BD light_luminance_scale;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "light_luminance_scale", &light_luminance_scale, NULL)
        && light_luminance_scale == mentalrayrendersettings->light_luminance_scale)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.light_luminance_scale [BD] %g != %g", mentalrayrendersettings->light_luminance_scale, light_luminance_scale);
    light_luminance_scale++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "light_luminance_scale", &light_luminance_scale, 0)
        && light_luminance_scale == mentalrayrendersettings->light_luminance_scale)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.light_luminance_scale [BD] set+1 %g != %g", mentalrayrendersettings->light_luminance_scale, light_luminance_scale);
    mentalrayrendersettings->light_luminance_scale--;
  }
  {
    BITCODE_BL memory_limit;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "memory_limit", &memory_limit, NULL)
        && memory_limit == mentalrayrendersettings->memory_limit)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.memory_limit [BL] %u != %u", mentalrayrendersettings->memory_limit, memory_limit);
    memory_limit++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "memory_limit", &memory_limit, 0)
        && memory_limit == mentalrayrendersettings->memory_limit)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.memory_limit [BL] set+1 %u != %u", mentalrayrendersettings->memory_limit, memory_limit);
    mentalrayrendersettings->memory_limit--;
  }
  {
    BITCODE_T mr_description;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "mr_description", &mr_description, NULL)
        && mr_description
           ? strEQ ((char *)mr_description, (char *)mentalrayrendersettings->mr_description)
           : !mentalrayrendersettings->mr_description)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.mr_description [T] '%s' <> '%s'", mr_description, mentalrayrendersettings->mr_description);
  }
  {
    BITCODE_BL mr_version;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "mr_version", &mr_version, NULL)
        && mr_version == mentalrayrendersettings->mr_version)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.mr_version [BL] %u != %u", mentalrayrendersettings->mr_version, mr_version);
    mr_version++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "mr_version", &mr_version, 0)
        && mr_version == mentalrayrendersettings->mr_version)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.mr_version [BL] set+1 %u != %u", mentalrayrendersettings->mr_version, mr_version);
    mentalrayrendersettings->mr_version--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)mentalrayrendersettings->name)
           : !mentalrayrendersettings->name)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.name [T] '%s' <> '%s'", name, mentalrayrendersettings->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "parent", &parent, NULL)
        && !memcmp (&parent, &mentalrayrendersettings->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("MENTALRAYRENDERSETTINGS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL photon_trace_depth1;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "photon_trace_depth1", &photon_trace_depth1, NULL)
        && photon_trace_depth1 == mentalrayrendersettings->photon_trace_depth1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.photon_trace_depth1 [BL] %u != %u", mentalrayrendersettings->photon_trace_depth1, photon_trace_depth1);
    photon_trace_depth1++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "photon_trace_depth1", &photon_trace_depth1, 0)
        && photon_trace_depth1 == mentalrayrendersettings->photon_trace_depth1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.photon_trace_depth1 [BL] set+1 %u != %u", mentalrayrendersettings->photon_trace_depth1, photon_trace_depth1);
    mentalrayrendersettings->photon_trace_depth1--;
  }
  {
    BITCODE_BL photon_trace_depth2;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "photon_trace_depth2", &photon_trace_depth2, NULL)
        && photon_trace_depth2 == mentalrayrendersettings->photon_trace_depth2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.photon_trace_depth2 [BL] %u != %u", mentalrayrendersettings->photon_trace_depth2, photon_trace_depth2);
    photon_trace_depth2++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "photon_trace_depth2", &photon_trace_depth2, 0)
        && photon_trace_depth2 == mentalrayrendersettings->photon_trace_depth2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.photon_trace_depth2 [BL] set+1 %u != %u", mentalrayrendersettings->photon_trace_depth2, photon_trace_depth2);
    mentalrayrendersettings->photon_trace_depth2--;
  }
  {
    BITCODE_BL photon_trace_depth3;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "photon_trace_depth3", &photon_trace_depth3, NULL)
        && photon_trace_depth3 == mentalrayrendersettings->photon_trace_depth3)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.photon_trace_depth3 [BL] %u != %u", mentalrayrendersettings->photon_trace_depth3, photon_trace_depth3);
    photon_trace_depth3++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "photon_trace_depth3", &photon_trace_depth3, 0)
        && photon_trace_depth3 == mentalrayrendersettings->photon_trace_depth3)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.photon_trace_depth3 [BL] set+1 %u != %u", mentalrayrendersettings->photon_trace_depth3, photon_trace_depth3);
    mentalrayrendersettings->photon_trace_depth3--;
  }
  {
    BITCODE_BL ray_trace_depth1;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "ray_trace_depth1", &ray_trace_depth1, NULL)
        && ray_trace_depth1 == mentalrayrendersettings->ray_trace_depth1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.ray_trace_depth1 [BL] %u != %u", mentalrayrendersettings->ray_trace_depth1, ray_trace_depth1);
    ray_trace_depth1++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "ray_trace_depth1", &ray_trace_depth1, 0)
        && ray_trace_depth1 == mentalrayrendersettings->ray_trace_depth1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.ray_trace_depth1 [BL] set+1 %u != %u", mentalrayrendersettings->ray_trace_depth1, ray_trace_depth1);
    mentalrayrendersettings->ray_trace_depth1--;
  }
  {
    BITCODE_BL ray_trace_depth2;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "ray_trace_depth2", &ray_trace_depth2, NULL)
        && ray_trace_depth2 == mentalrayrendersettings->ray_trace_depth2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.ray_trace_depth2 [BL] %u != %u", mentalrayrendersettings->ray_trace_depth2, ray_trace_depth2);
    ray_trace_depth2++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "ray_trace_depth2", &ray_trace_depth2, 0)
        && ray_trace_depth2 == mentalrayrendersettings->ray_trace_depth2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.ray_trace_depth2 [BL] set+1 %u != %u", mentalrayrendersettings->ray_trace_depth2, ray_trace_depth2);
    mentalrayrendersettings->ray_trace_depth2--;
  }
  {
    BITCODE_BL ray_trace_depth3;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "ray_trace_depth3", &ray_trace_depth3, NULL)
        && ray_trace_depth3 == mentalrayrendersettings->ray_trace_depth3)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.ray_trace_depth3 [BL] %u != %u", mentalrayrendersettings->ray_trace_depth3, ray_trace_depth3);
    ray_trace_depth3++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "ray_trace_depth3", &ray_trace_depth3, 0)
        && ray_trace_depth3 == mentalrayrendersettings->ray_trace_depth3)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.ray_trace_depth3 [BL] set+1 %u != %u", mentalrayrendersettings->ray_trace_depth3, ray_trace_depth3);
    mentalrayrendersettings->ray_trace_depth3--;
  }
  {
    BITCODE_B ray_tracing_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "ray_tracing_enabled", &ray_tracing_enabled, NULL)
        && ray_tracing_enabled == mentalrayrendersettings->ray_tracing_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.ray_tracing_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->ray_tracing_enabled, ray_tracing_enabled);
    ray_tracing_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "ray_tracing_enabled", &ray_tracing_enabled, 0)
        && ray_tracing_enabled == mentalrayrendersettings->ray_tracing_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.ray_tracing_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->ray_tracing_enabled, ray_tracing_enabled);
    mentalrayrendersettings->ray_tracing_enabled--;
  }
  {
    BITCODE_BL sampling1;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling1", &sampling1, NULL)
        && sampling1 == mentalrayrendersettings->sampling1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling1 [BL] %u != %u", mentalrayrendersettings->sampling1, sampling1);
    sampling1++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling1", &sampling1, 0)
        && sampling1 == mentalrayrendersettings->sampling1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling1 [BL] set+1 %u != %u", mentalrayrendersettings->sampling1, sampling1);
    mentalrayrendersettings->sampling1--;
  }
  {
    BITCODE_BL sampling2;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling2", &sampling2, NULL)
        && sampling2 == mentalrayrendersettings->sampling2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling2 [BL] %u != %u", mentalrayrendersettings->sampling2, sampling2);
    sampling2++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling2", &sampling2, 0)
        && sampling2 == mentalrayrendersettings->sampling2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling2 [BL] set+1 %u != %u", mentalrayrendersettings->sampling2, sampling2);
    mentalrayrendersettings->sampling2--;
  }
  {
    BITCODE_BD sampling_contrast_color1;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_contrast_color1", &sampling_contrast_color1, NULL)
        && sampling_contrast_color1 == mentalrayrendersettings->sampling_contrast_color1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_contrast_color1 [BD] %g != %g", mentalrayrendersettings->sampling_contrast_color1, sampling_contrast_color1);
    sampling_contrast_color1++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_contrast_color1", &sampling_contrast_color1, 0)
        && sampling_contrast_color1 == mentalrayrendersettings->sampling_contrast_color1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_contrast_color1 [BD] set+1 %g != %g", mentalrayrendersettings->sampling_contrast_color1, sampling_contrast_color1);
    mentalrayrendersettings->sampling_contrast_color1--;
  }
  {
    BITCODE_BD sampling_contrast_color2;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_contrast_color2", &sampling_contrast_color2, NULL)
        && sampling_contrast_color2 == mentalrayrendersettings->sampling_contrast_color2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_contrast_color2 [BD] %g != %g", mentalrayrendersettings->sampling_contrast_color2, sampling_contrast_color2);
    sampling_contrast_color2++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_contrast_color2", &sampling_contrast_color2, 0)
        && sampling_contrast_color2 == mentalrayrendersettings->sampling_contrast_color2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_contrast_color2 [BD] set+1 %g != %g", mentalrayrendersettings->sampling_contrast_color2, sampling_contrast_color2);
    mentalrayrendersettings->sampling_contrast_color2--;
  }
  {
    BITCODE_BD sampling_contrast_color3;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_contrast_color3", &sampling_contrast_color3, NULL)
        && sampling_contrast_color3 == mentalrayrendersettings->sampling_contrast_color3)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_contrast_color3 [BD] %g != %g", mentalrayrendersettings->sampling_contrast_color3, sampling_contrast_color3);
    sampling_contrast_color3++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_contrast_color3", &sampling_contrast_color3, 0)
        && sampling_contrast_color3 == mentalrayrendersettings->sampling_contrast_color3)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_contrast_color3 [BD] set+1 %g != %g", mentalrayrendersettings->sampling_contrast_color3, sampling_contrast_color3);
    mentalrayrendersettings->sampling_contrast_color3--;
  }
  {
    BITCODE_BD sampling_contrast_color4;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_contrast_color4", &sampling_contrast_color4, NULL)
        && sampling_contrast_color4 == mentalrayrendersettings->sampling_contrast_color4)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_contrast_color4 [BD] %g != %g", mentalrayrendersettings->sampling_contrast_color4, sampling_contrast_color4);
    sampling_contrast_color4++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_contrast_color4", &sampling_contrast_color4, 0)
        && sampling_contrast_color4 == mentalrayrendersettings->sampling_contrast_color4)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_contrast_color4 [BD] set+1 %g != %g", mentalrayrendersettings->sampling_contrast_color4, sampling_contrast_color4);
    mentalrayrendersettings->sampling_contrast_color4--;
  }
  {
    BITCODE_BD sampling_filter1;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_filter1", &sampling_filter1, NULL)
        && sampling_filter1 == mentalrayrendersettings->sampling_filter1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_filter1 [BD] %g != %g", mentalrayrendersettings->sampling_filter1, sampling_filter1);
    sampling_filter1++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_filter1", &sampling_filter1, 0)
        && sampling_filter1 == mentalrayrendersettings->sampling_filter1)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_filter1 [BD] set+1 %g != %g", mentalrayrendersettings->sampling_filter1, sampling_filter1);
    mentalrayrendersettings->sampling_filter1--;
  }
  {
    BITCODE_BD sampling_filter2;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_filter2", &sampling_filter2, NULL)
        && sampling_filter2 == mentalrayrendersettings->sampling_filter2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_filter2 [BD] %g != %g", mentalrayrendersettings->sampling_filter2, sampling_filter2);
    sampling_filter2++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_filter2", &sampling_filter2, 0)
        && sampling_filter2 == mentalrayrendersettings->sampling_filter2)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_filter2 [BD] set+1 %g != %g", mentalrayrendersettings->sampling_filter2, sampling_filter2);
    mentalrayrendersettings->sampling_filter2--;
  }
  {
    BITCODE_BS sampling_mr_filter;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_mr_filter", &sampling_mr_filter, NULL)
        && sampling_mr_filter == mentalrayrendersettings->sampling_mr_filter)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_mr_filter [BS] %hu != %hu", mentalrayrendersettings->sampling_mr_filter, sampling_mr_filter);
    sampling_mr_filter++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "sampling_mr_filter", &sampling_mr_filter, 0)
        && sampling_mr_filter == mentalrayrendersettings->sampling_mr_filter)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.sampling_mr_filter [BS] set+1 %hu != %hu", mentalrayrendersettings->sampling_mr_filter, sampling_mr_filter);
    mentalrayrendersettings->sampling_mr_filter--;
  }
  {
    BITCODE_B shadow_maps_enabled;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "shadow_maps_enabled", &shadow_maps_enabled, NULL)
        && shadow_maps_enabled == mentalrayrendersettings->shadow_maps_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.shadow_maps_enabled [B] " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->shadow_maps_enabled, shadow_maps_enabled);
    shadow_maps_enabled++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "shadow_maps_enabled", &shadow_maps_enabled, 0)
        && shadow_maps_enabled == mentalrayrendersettings->shadow_maps_enabled)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.shadow_maps_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", mentalrayrendersettings->shadow_maps_enabled, shadow_maps_enabled);
    mentalrayrendersettings->shadow_maps_enabled--;
  }
  {
    BITCODE_BS shadow_mode;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "shadow_mode", &shadow_mode, NULL)
        && shadow_mode == mentalrayrendersettings->shadow_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.shadow_mode [BS] %hu != %hu", mentalrayrendersettings->shadow_mode, shadow_mode);
    shadow_mode++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "shadow_mode", &shadow_mode, 0)
        && shadow_mode == mentalrayrendersettings->shadow_mode)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.shadow_mode [BS] set+1 %hu != %hu", mentalrayrendersettings->shadow_mode, shadow_mode);
    mentalrayrendersettings->shadow_mode--;
  }
  {
    BITCODE_BS tile_order;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "tile_order", &tile_order, NULL)
        && tile_order == mentalrayrendersettings->tile_order)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.tile_order [BS] %hu != %hu", mentalrayrendersettings->tile_order, tile_order);
    tile_order++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "tile_order", &tile_order, 0)
        && tile_order == mentalrayrendersettings->tile_order)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.tile_order [BS] set+1 %hu != %hu", mentalrayrendersettings->tile_order, tile_order);
    mentalrayrendersettings->tile_order--;
  }
  {
    BITCODE_BL tile_size;
    if (dwg_dynapi_entity_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "tile_size", &tile_size, NULL)
        && tile_size == mentalrayrendersettings->tile_size)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.tile_size [BL] %u != %u", mentalrayrendersettings->tile_size, tile_size);
    tile_size++;
    if (dwg_dynapi_entity_set_value (mentalrayrendersettings, "MENTALRAYRENDERSETTINGS", "tile_size", &tile_size, 0)
        && tile_size == mentalrayrendersettings->tile_size)
      pass ();
    else
      fail ("MENTALRAYRENDERSETTINGS.tile_size [BL] set+1 %u != %u", mentalrayrendersettings->tile_size, tile_size);
    mentalrayrendersettings->tile_size--;
  }
  if (failed && (is_class_unstable ("MENTALRAYRENDERSETTINGS") || is_class_debugging ("MENTALRAYRENDERSETTINGS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MENTALRAYRENDERSETTINGS", failed);
      failed = 0;
    }
  return failed;
}
static int test_MLEADEROBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MLEADEROBJECTCONTEXTDATA *restrict mleaderobjectcontextdata = obj->tio.object->tio.MLEADEROBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !mleaderobjectcontextdata)
    {
      fail ("NULL MLEADEROBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == mleaderobjectcontextdata->class_version)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.class_version [BS] %hu != %hu", mleaderobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == mleaderobjectcontextdata->class_version)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", mleaderobjectcontextdata->class_version, class_version);
    mleaderobjectcontextdata->class_version--;
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == mleaderobjectcontextdata->is_default)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", mleaderobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == mleaderobjectcontextdata->is_default)
      pass ();
    else
      fail ("MLEADEROBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderobjectcontextdata->is_default, is_default);
    mleaderobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &mleaderobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("MLEADEROBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (mleaderobjectcontextdata, "MLEADEROBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &mleaderobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MLEADEROBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("MLEADEROBJECTCONTEXTDATA") || is_class_debugging ("MLEADEROBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MLEADEROBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_MLEADERSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MLEADERSTYLE *restrict mleaderstyle = obj->tio.object->tio.MLEADERSTYLE;
  failed = 0;
  if (!obj_obj || !mleaderstyle)
    {
      fail ("NULL MLEADERSTYLE");
      return 1;
    }
  {
    BITCODE_BD align_space;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "align_space", &align_space, NULL)
        && align_space == mleaderstyle->align_space)
      pass ();
    else
      fail ("MLEADERSTYLE.align_space [BD] %g != %g", mleaderstyle->align_space, align_space);
    align_space++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "align_space", &align_space, 0)
        && align_space == mleaderstyle->align_space)
      pass ();
    else
      fail ("MLEADERSTYLE.align_space [BD] set+1 %g != %g", mleaderstyle->align_space, align_space);
    mleaderstyle->align_space--;
  }
  {
    BITCODE_H arrow_head;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "arrow_head", &arrow_head, NULL)
        && !memcmp (&arrow_head, &mleaderstyle->arrow_head, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MLEADERSTYLE.arrow_head [H]");
  }
  {
    BITCODE_BD arrow_head_size;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "arrow_head_size", &arrow_head_size, NULL)
        && arrow_head_size == mleaderstyle->arrow_head_size)
      pass ();
    else
      fail ("MLEADERSTYLE.arrow_head_size [BD] %g != %g", mleaderstyle->arrow_head_size, arrow_head_size);
    arrow_head_size++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "arrow_head_size", &arrow_head_size, 0)
        && arrow_head_size == mleaderstyle->arrow_head_size)
      pass ();
    else
      fail ("MLEADERSTYLE.arrow_head_size [BD] set+1 %g != %g", mleaderstyle->arrow_head_size, arrow_head_size);
    mleaderstyle->arrow_head_size--;
  }
  {
    BITCODE_BS attach_bottom;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_bottom", &attach_bottom, NULL)
        && attach_bottom == mleaderstyle->attach_bottom)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_bottom [BS] %hu != %hu", mleaderstyle->attach_bottom, attach_bottom);
    attach_bottom++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_bottom", &attach_bottom, 0)
        && attach_bottom == mleaderstyle->attach_bottom)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_bottom [BS] set+1 %hu != %hu", mleaderstyle->attach_bottom, attach_bottom);
    mleaderstyle->attach_bottom--;
  }
  {
    BITCODE_BS attach_dir;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_dir", &attach_dir, NULL)
        && attach_dir == mleaderstyle->attach_dir)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_dir [BS] %hu != %hu", mleaderstyle->attach_dir, attach_dir);
    attach_dir++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_dir", &attach_dir, 0)
        && attach_dir == mleaderstyle->attach_dir)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_dir [BS] set+1 %hu != %hu", mleaderstyle->attach_dir, attach_dir);
    mleaderstyle->attach_dir--;
  }
  {
    BITCODE_BS attach_left;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_left", &attach_left, NULL)
        && attach_left == mleaderstyle->attach_left)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_left [BS] %hu != %hu", mleaderstyle->attach_left, attach_left);
    attach_left++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_left", &attach_left, 0)
        && attach_left == mleaderstyle->attach_left)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_left [BS] set+1 %hu != %hu", mleaderstyle->attach_left, attach_left);
    mleaderstyle->attach_left--;
  }
  {
    BITCODE_BS attach_right;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_right", &attach_right, NULL)
        && attach_right == mleaderstyle->attach_right)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_right [BS] %hu != %hu", mleaderstyle->attach_right, attach_right);
    attach_right++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_right", &attach_right, 0)
        && attach_right == mleaderstyle->attach_right)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_right [BS] set+1 %hu != %hu", mleaderstyle->attach_right, attach_right);
    mleaderstyle->attach_right--;
  }
  {
    BITCODE_BS attach_top;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "attach_top", &attach_top, NULL)
        && attach_top == mleaderstyle->attach_top)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_top [BS] %hu != %hu", mleaderstyle->attach_top, attach_top);
    attach_top++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "attach_top", &attach_top, 0)
        && attach_top == mleaderstyle->attach_top)
      pass ();
    else
      fail ("MLEADERSTYLE.attach_top [BS] set+1 %hu != %hu", mleaderstyle->attach_top, attach_top);
    mleaderstyle->attach_top--;
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block", &block, NULL)
        && !memcmp (&block, &mleaderstyle->block, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MLEADERSTYLE.block [H]");
  }
  {
    BITCODE_CMC block_color;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block_color", &block_color, NULL)
        && !memcmp (&block_color, &mleaderstyle->block_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MLEADERSTYLE.block_color [CMC]");
  }
  {
    BITCODE_BS block_connection;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block_connection", &block_connection, NULL)
        && block_connection == mleaderstyle->block_connection)
      pass ();
    else
      fail ("MLEADERSTYLE.block_connection [BS] %hu != %hu", mleaderstyle->block_connection, block_connection);
    block_connection++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "block_connection", &block_connection, 0)
        && block_connection == mleaderstyle->block_connection)
      pass ();
    else
      fail ("MLEADERSTYLE.block_connection [BS] set+1 %hu != %hu", mleaderstyle->block_connection, block_connection);
    mleaderstyle->block_connection--;
  }
  {
    BITCODE_BD block_rotation;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block_rotation", &block_rotation, NULL)
        && block_rotation == mleaderstyle->block_rotation)
      pass ();
    else
      fail ("MLEADERSTYLE.block_rotation [BD] %g != %g", mleaderstyle->block_rotation, block_rotation);
    block_rotation++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "block_rotation", &block_rotation, 0)
        && block_rotation == mleaderstyle->block_rotation)
      pass ();
    else
      fail ("MLEADERSTYLE.block_rotation [BD] set+1 %g != %g", mleaderstyle->block_rotation, block_rotation);
    mleaderstyle->block_rotation--;
  }
  {
    BITCODE_3BD block_scale;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "block_scale", &block_scale, NULL)
        && !memcmp (&block_scale, &mleaderstyle->block_scale, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("MLEADERSTYLE.block_scale [3BD]");
  }
  {
    BITCODE_BD break_size;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "break_size", &break_size, NULL)
        && break_size == mleaderstyle->break_size)
      pass ();
    else
      fail ("MLEADERSTYLE.break_size [BD] %g != %g", mleaderstyle->break_size, break_size);
    break_size++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "break_size", &break_size, 0)
        && break_size == mleaderstyle->break_size)
      pass ();
    else
      fail ("MLEADERSTYLE.break_size [BD] set+1 %g != %g", mleaderstyle->break_size, break_size);
    mleaderstyle->break_size--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "class_version", &class_version, NULL)
        && class_version == mleaderstyle->class_version)
      pass ();
    else
      fail ("MLEADERSTYLE.class_version [BS] %hu != %hu", mleaderstyle->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "class_version", &class_version, 0)
        && class_version == mleaderstyle->class_version)
      pass ();
    else
      fail ("MLEADERSTYLE.class_version [BS] set+1 %hu != %hu", mleaderstyle->class_version, class_version);
    mleaderstyle->class_version--;
  }
  {
    BITCODE_BS content_type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "content_type", &content_type, NULL)
        && content_type == mleaderstyle->content_type)
      pass ();
    else
      fail ("MLEADERSTYLE.content_type [BS] %hu != %hu", mleaderstyle->content_type, content_type);
    content_type++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "content_type", &content_type, 0)
        && content_type == mleaderstyle->content_type)
      pass ();
    else
      fail ("MLEADERSTYLE.content_type [BS] set+1 %hu != %hu", mleaderstyle->content_type, content_type);
    mleaderstyle->content_type--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)mleaderstyle->description)
           : !mleaderstyle->description)
      pass ();
    else
      fail ("MLEADERSTYLE.description [T] '%s' <> '%s'", description, mleaderstyle->description);
  }
  {
    BITCODE_BD first_seg_angle;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "first_seg_angle", &first_seg_angle, NULL)
        && first_seg_angle == mleaderstyle->first_seg_angle)
      pass ();
    else
      fail ("MLEADERSTYLE.first_seg_angle [BD] %g != %g", mleaderstyle->first_seg_angle, first_seg_angle);
    first_seg_angle++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "first_seg_angle", &first_seg_angle, 0)
        && first_seg_angle == mleaderstyle->first_seg_angle)
      pass ();
    else
      fail ("MLEADERSTYLE.first_seg_angle [BD] set+1 %g != %g", mleaderstyle->first_seg_angle, first_seg_angle);
    mleaderstyle->first_seg_angle--;
  }
  {
    BITCODE_B has_dogleg;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "has_dogleg", &has_dogleg, NULL)
        && has_dogleg == mleaderstyle->has_dogleg)
      pass ();
    else
      fail ("MLEADERSTYLE.has_dogleg [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_dogleg, has_dogleg);
    has_dogleg++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "has_dogleg", &has_dogleg, 0)
        && has_dogleg == mleaderstyle->has_dogleg)
      pass ();
    else
      fail ("MLEADERSTYLE.has_dogleg [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_dogleg, has_dogleg);
    mleaderstyle->has_dogleg--;
  }
  {
    BITCODE_B has_landing;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "has_landing", &has_landing, NULL)
        && has_landing == mleaderstyle->has_landing)
      pass ();
    else
      fail ("MLEADERSTYLE.has_landing [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_landing, has_landing);
    has_landing++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "has_landing", &has_landing, 0)
        && has_landing == mleaderstyle->has_landing)
      pass ();
    else
      fail ("MLEADERSTYLE.has_landing [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_landing, has_landing);
    mleaderstyle->has_landing--;
  }
  {
    BITCODE_B has_text_frame;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "has_text_frame", &has_text_frame, NULL)
        && has_text_frame == mleaderstyle->has_text_frame)
      pass ();
    else
      fail ("MLEADERSTYLE.has_text_frame [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_text_frame, has_text_frame);
    has_text_frame++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "has_text_frame", &has_text_frame, 0)
        && has_text_frame == mleaderstyle->has_text_frame)
      pass ();
    else
      fail ("MLEADERSTYLE.has_text_frame [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_text_frame, has_text_frame);
    mleaderstyle->has_text_frame--;
  }
  {
    BITCODE_B is_annotative;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "is_annotative", &is_annotative, NULL)
        && is_annotative == mleaderstyle->is_annotative)
      pass ();
    else
      fail ("MLEADERSTYLE.is_annotative [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_annotative, is_annotative);
    is_annotative++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "is_annotative", &is_annotative, 0)
        && is_annotative == mleaderstyle->is_annotative)
      pass ();
    else
      fail ("MLEADERSTYLE.is_annotative [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_annotative, is_annotative);
    mleaderstyle->is_annotative--;
  }
  {
    BITCODE_B is_changed;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "is_changed", &is_changed, NULL)
        && is_changed == mleaderstyle->is_changed)
      pass ();
    else
      fail ("MLEADERSTYLE.is_changed [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_changed, is_changed);
    is_changed++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "is_changed", &is_changed, 0)
        && is_changed == mleaderstyle->is_changed)
      pass ();
    else
      fail ("MLEADERSTYLE.is_changed [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_changed, is_changed);
    mleaderstyle->is_changed--;
  }
  {
    BITCODE_BD landing_dist;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "landing_dist", &landing_dist, NULL)
        && landing_dist == mleaderstyle->landing_dist)
      pass ();
    else
      fail ("MLEADERSTYLE.landing_dist [BD] %g != %g", mleaderstyle->landing_dist, landing_dist);
    landing_dist++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "landing_dist", &landing_dist, 0)
        && landing_dist == mleaderstyle->landing_dist)
      pass ();
    else
      fail ("MLEADERSTYLE.landing_dist [BD] set+1 %g != %g", mleaderstyle->landing_dist, landing_dist);
    mleaderstyle->landing_dist--;
  }
  {
    BITCODE_BD landing_gap;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "landing_gap", &landing_gap, NULL)
        && landing_gap == mleaderstyle->landing_gap)
      pass ();
    else
      fail ("MLEADERSTYLE.landing_gap [BD] %g != %g", mleaderstyle->landing_gap, landing_gap);
    landing_gap++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "landing_gap", &landing_gap, 0)
        && landing_gap == mleaderstyle->landing_gap)
      pass ();
    else
      fail ("MLEADERSTYLE.landing_gap [BD] set+1 %g != %g", mleaderstyle->landing_gap, landing_gap);
    mleaderstyle->landing_gap--;
  }
  {
    BITCODE_BS leader_order;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "leader_order", &leader_order, NULL)
        && leader_order == mleaderstyle->leader_order)
      pass ();
    else
      fail ("MLEADERSTYLE.leader_order [BS] %hu != %hu", mleaderstyle->leader_order, leader_order);
    leader_order++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "leader_order", &leader_order, 0)
        && leader_order == mleaderstyle->leader_order)
      pass ();
    else
      fail ("MLEADERSTYLE.leader_order [BS] set+1 %hu != %hu", mleaderstyle->leader_order, leader_order);
    mleaderstyle->leader_order--;
  }
  {
    BITCODE_CMC line_color;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "line_color", &line_color, NULL)
        && !memcmp (&line_color, &mleaderstyle->line_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MLEADERSTYLE.line_color [CMC]");
  }
  {
    BITCODE_H line_type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "line_type", &line_type, NULL)
        && !memcmp (&line_type, &mleaderstyle->line_type, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MLEADERSTYLE.line_type [H]");
  }
  {
    BITCODE_BLd linewt;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "linewt", &linewt, NULL)
        && linewt == mleaderstyle->linewt)
      pass ();
    else
      fail ("MLEADERSTYLE.linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", mleaderstyle->linewt, linewt);
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "linewt", &linewt, 0)
        && linewt == mleaderstyle->linewt)
      pass ();
    else
      fail ("MLEADERSTYLE.linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", mleaderstyle->linewt, linewt);
    mleaderstyle->linewt--;
  }
  {
    BITCODE_BL max_points;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "max_points", &max_points, NULL)
        && max_points == mleaderstyle->max_points)
      pass ();
    else
      fail ("MLEADERSTYLE.max_points [BL] %u != %u", mleaderstyle->max_points, max_points);
    max_points++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "max_points", &max_points, 0)
        && max_points == mleaderstyle->max_points)
      pass ();
    else
      fail ("MLEADERSTYLE.max_points [BL] set+1 %u != %u", mleaderstyle->max_points, max_points);
    mleaderstyle->max_points--;
  }
  {
    BITCODE_BS mleader_order;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "mleader_order", &mleader_order, NULL)
        && mleader_order == mleaderstyle->mleader_order)
      pass ();
    else
      fail ("MLEADERSTYLE.mleader_order [BS] %hu != %hu", mleaderstyle->mleader_order, mleader_order);
    mleader_order++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "mleader_order", &mleader_order, 0)
        && mleader_order == mleaderstyle->mleader_order)
      pass ();
    else
      fail ("MLEADERSTYLE.mleader_order [BS] set+1 %hu != %hu", mleaderstyle->mleader_order, mleader_order);
    mleaderstyle->mleader_order--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &mleaderstyle->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("MLEADERSTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "scale", &scale, NULL)
        && scale == mleaderstyle->scale)
      pass ();
    else
      fail ("MLEADERSTYLE.scale [BD] %g != %g", mleaderstyle->scale, scale);
    scale++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "scale", &scale, 0)
        && scale == mleaderstyle->scale)
      pass ();
    else
      fail ("MLEADERSTYLE.scale [BD] set+1 %g != %g", mleaderstyle->scale, scale);
    mleaderstyle->scale--;
  }
  {
    BITCODE_BD second_seg_angle;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "second_seg_angle", &second_seg_angle, NULL)
        && second_seg_angle == mleaderstyle->second_seg_angle)
      pass ();
    else
      fail ("MLEADERSTYLE.second_seg_angle [BD] %g != %g", mleaderstyle->second_seg_angle, second_seg_angle);
    second_seg_angle++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "second_seg_angle", &second_seg_angle, 0)
        && second_seg_angle == mleaderstyle->second_seg_angle)
      pass ();
    else
      fail ("MLEADERSTYLE.second_seg_angle [BD] set+1 %g != %g", mleaderstyle->second_seg_angle, second_seg_angle);
    mleaderstyle->second_seg_angle--;
  }
  {
    BITCODE_BS text_align_type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_align_type", &text_align_type, NULL)
        && text_align_type == mleaderstyle->text_align_type)
      pass ();
    else
      fail ("MLEADERSTYLE.text_align_type [BS] %hu != %hu", mleaderstyle->text_align_type, text_align_type);
    text_align_type++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_align_type", &text_align_type, 0)
        && text_align_type == mleaderstyle->text_align_type)
      pass ();
    else
      fail ("MLEADERSTYLE.text_align_type [BS] set+1 %hu != %hu", mleaderstyle->text_align_type, text_align_type);
    mleaderstyle->text_align_type--;
  }
  {
    BITCODE_B text_always_left;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_always_left", &text_always_left, NULL)
        && text_always_left == mleaderstyle->text_always_left)
      pass ();
    else
      fail ("MLEADERSTYLE.text_always_left [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_always_left, text_always_left);
    text_always_left++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_always_left", &text_always_left, 0)
        && text_always_left == mleaderstyle->text_always_left)
      pass ();
    else
      fail ("MLEADERSTYLE.text_always_left [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_always_left, text_always_left);
    mleaderstyle->text_always_left--;
  }
  {
    BITCODE_BS text_angle_type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_angle_type", &text_angle_type, NULL)
        && text_angle_type == mleaderstyle->text_angle_type)
      pass ();
    else
      fail ("MLEADERSTYLE.text_angle_type [BS] %hu != %hu", mleaderstyle->text_angle_type, text_angle_type);
    text_angle_type++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_angle_type", &text_angle_type, 0)
        && text_angle_type == mleaderstyle->text_angle_type)
      pass ();
    else
      fail ("MLEADERSTYLE.text_angle_type [BS] set+1 %hu != %hu", mleaderstyle->text_angle_type, text_angle_type);
    mleaderstyle->text_angle_type--;
  }
  {
    BITCODE_CMC text_color;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_color", &text_color, NULL)
        && !memcmp (&text_color, &mleaderstyle->text_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MLEADERSTYLE.text_color [CMC]");
  }
  {
    BITCODE_T text_default;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_default", &text_default, NULL)
        && text_default
           ? strEQ ((char *)text_default, (char *)mleaderstyle->text_default)
           : !mleaderstyle->text_default)
      pass ();
    else
      fail ("MLEADERSTYLE.text_default [T] '%s' <> '%s'", text_default, mleaderstyle->text_default);
  }
  {
    BITCODE_B text_extended;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_extended", &text_extended, NULL)
        && text_extended == mleaderstyle->text_extended)
      pass ();
    else
      fail ("MLEADERSTYLE.text_extended [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_extended, text_extended);
    text_extended++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_extended", &text_extended, 0)
        && text_extended == mleaderstyle->text_extended)
      pass ();
    else
      fail ("MLEADERSTYLE.text_extended [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_extended, text_extended);
    mleaderstyle->text_extended--;
  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_height", &text_height, NULL)
        && text_height == mleaderstyle->text_height)
      pass ();
    else
      fail ("MLEADERSTYLE.text_height [BD] %g != %g", mleaderstyle->text_height, text_height);
    text_height++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "text_height", &text_height, 0)
        && text_height == mleaderstyle->text_height)
      pass ();
    else
      fail ("MLEADERSTYLE.text_height [BD] set+1 %g != %g", mleaderstyle->text_height, text_height);
    mleaderstyle->text_height--;
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "text_style", &text_style, NULL)
        && !memcmp (&text_style, &mleaderstyle->text_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MLEADERSTYLE.text_style [H]");
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "type", &type, NULL)
        && type == mleaderstyle->type)
      pass ();
    else
      fail ("MLEADERSTYLE.type [BS] %hu != %hu", mleaderstyle->type, type);
    type++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "type", &type, 0)
        && type == mleaderstyle->type)
      pass ();
    else
      fail ("MLEADERSTYLE.type [BS] set+1 %hu != %hu", mleaderstyle->type, type);
    mleaderstyle->type--;
  }
  {
    BITCODE_B use_block_rotation;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "use_block_rotation", &use_block_rotation, NULL)
        && use_block_rotation == mleaderstyle->use_block_rotation)
      pass ();
    else
      fail ("MLEADERSTYLE.use_block_rotation [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_rotation, use_block_rotation);
    use_block_rotation++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "use_block_rotation", &use_block_rotation, 0)
        && use_block_rotation == mleaderstyle->use_block_rotation)
      pass ();
    else
      fail ("MLEADERSTYLE.use_block_rotation [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_rotation, use_block_rotation);
    mleaderstyle->use_block_rotation--;
  }
  {
    BITCODE_B use_block_scale;
    if (dwg_dynapi_entity_value (mleaderstyle, "MLEADERSTYLE", "use_block_scale", &use_block_scale, NULL)
        && use_block_scale == mleaderstyle->use_block_scale)
      pass ();
    else
      fail ("MLEADERSTYLE.use_block_scale [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_scale, use_block_scale);
    use_block_scale++;
    if (dwg_dynapi_entity_set_value (mleaderstyle, "MLEADERSTYLE", "use_block_scale", &use_block_scale, 0)
        && use_block_scale == mleaderstyle->use_block_scale)
      pass ();
    else
      fail ("MLEADERSTYLE.use_block_scale [B] set+1 " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_scale, use_block_scale);
    mleaderstyle->use_block_scale--;
  }
  if (failed && (is_class_unstable ("MLEADERSTYLE") || is_class_debugging ("MLEADERSTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MLEADERSTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_MLINESTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MLINESTYLE *restrict mlinestyle = obj->tio.object->tio.MLINESTYLE;
  failed = 0;
  if (!obj_obj || !mlinestyle)
    {
      fail ("NULL MLINESTYLE");
      return 1;
    }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)mlinestyle->description)
           : !mlinestyle->description)
      pass ();
    else
      fail ("MLINESTYLE.description [T] '%s' <> '%s'", description, mlinestyle->description);
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "end_angle", &end_angle, NULL)
        && end_angle == mlinestyle->end_angle)
      pass ();
    else
      fail ("MLINESTYLE.end_angle [BD] %g != %g", mlinestyle->end_angle, end_angle);
    end_angle++;
    if (dwg_dynapi_entity_set_value (mlinestyle, "MLINESTYLE", "end_angle", &end_angle, 0)
        && end_angle == mlinestyle->end_angle)
      pass ();
    else
      fail ("MLINESTYLE.end_angle [BD] set+1 %g != %g", mlinestyle->end_angle, end_angle);
    mlinestyle->end_angle--;
  }
  {
    BITCODE_CMC fill_color;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "fill_color", &fill_color, NULL)
        && !memcmp (&fill_color, &mlinestyle->fill_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("MLINESTYLE.fill_color [CMC]");
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "flag", &flag, NULL)
        && flag == mlinestyle->flag)
      pass ();
    else
      fail ("MLINESTYLE.flag [BS] %hu != %hu", mlinestyle->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (mlinestyle, "MLINESTYLE", "flag", &flag, 0)
        && flag == mlinestyle->flag)
      pass ();
    else
      fail ("MLINESTYLE.flag [BS] set+1 %hu != %hu", mlinestyle->flag, flag);
    mlinestyle->flag--;
  }
  {
    Dwg_MLINESTYLE_line* lines;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "num_lines", &count, NULL)
        && dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "lines", &lines, NULL)
        && lines == mlinestyle->lines)
      pass ();
    else
      fail ("MLINESTYLE.lines [Dwg_MLINESTYLE_line*] * %u num_lines", count);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)mlinestyle->name)
           : !mlinestyle->name)
      pass ();
    else
      fail ("MLINESTYLE.name [T] '%s' <> '%s'", name, mlinestyle->name);
  }
  {
    BITCODE_RC num_lines;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "num_lines", &num_lines, NULL)
        && num_lines == mlinestyle->num_lines)
      pass ();
    else
      fail ("MLINESTYLE.num_lines [RC] %u != %u", mlinestyle->num_lines, num_lines);
    num_lines++;
    if (dwg_dynapi_entity_set_value (mlinestyle, "MLINESTYLE", "num_lines", &num_lines, 0)
        && num_lines == mlinestyle->num_lines)
      pass ();
    else
      fail ("MLINESTYLE.num_lines [RC] set+1 %u != %u", mlinestyle->num_lines, num_lines);
    mlinestyle->num_lines--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &mlinestyle->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("MLINESTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value (mlinestyle, "MLINESTYLE", "start_angle", &start_angle, NULL)
        && start_angle == mlinestyle->start_angle)
      pass ();
    else
      fail ("MLINESTYLE.start_angle [BD] %g != %g", mlinestyle->start_angle, start_angle);
    start_angle++;
    if (dwg_dynapi_entity_set_value (mlinestyle, "MLINESTYLE", "start_angle", &start_angle, 0)
        && start_angle == mlinestyle->start_angle)
      pass ();
    else
      fail ("MLINESTYLE.start_angle [BD] set+1 %g != %g", mlinestyle->start_angle, start_angle);
    mlinestyle->start_angle--;
  }
  if (failed && (is_class_unstable ("MLINESTYLE") || is_class_debugging ("MLINESTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MLINESTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_MOTIONPATH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MOTIONPATH *restrict motionpath = obj->tio.object->tio.MOTIONPATH;
  failed = 0;
  if (!obj_obj || !motionpath)
    {
      fail ("NULL MOTIONPATH");
      return 1;
    }
  {
    BITCODE_H camera_path;
    if (dwg_dynapi_entity_value (motionpath, "MOTIONPATH", "camera_path", &camera_path, NULL)
        && !memcmp (&camera_path, &motionpath->camera_path, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MOTIONPATH.camera_path [H]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (motionpath, "MOTIONPATH", "class_version", &class_version, NULL)
        && class_version == motionpath->class_version)
      pass ();
    else
      fail ("MOTIONPATH.class_version [BS] %hu != %hu", motionpath->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (motionpath, "MOTIONPATH", "class_version", &class_version, 0)
        && class_version == motionpath->class_version)
      pass ();
    else
      fail ("MOTIONPATH.class_version [BS] set+1 %hu != %hu", motionpath->class_version, class_version);
    motionpath->class_version--;
  }
  {
    BITCODE_B corner_decel;
    if (dwg_dynapi_entity_value (motionpath, "MOTIONPATH", "corner_decel", &corner_decel, NULL)
        && corner_decel == motionpath->corner_decel)
      pass ();
    else
      fail ("MOTIONPATH.corner_decel [B] " FORMAT_B " != " FORMAT_B "", motionpath->corner_decel, corner_decel);
    corner_decel++;
    if (dwg_dynapi_entity_set_value (motionpath, "MOTIONPATH", "corner_decel", &corner_decel, 0)
        && corner_decel == motionpath->corner_decel)
      pass ();
    else
      fail ("MOTIONPATH.corner_decel [B] set+1 " FORMAT_B " != " FORMAT_B "", motionpath->corner_decel, corner_decel);
    motionpath->corner_decel--;
  }
  {
    BITCODE_BS frame_rate;
    if (dwg_dynapi_entity_value (motionpath, "MOTIONPATH", "frame_rate", &frame_rate, NULL)
        && frame_rate == motionpath->frame_rate)
      pass ();
    else
      fail ("MOTIONPATH.frame_rate [BS] %hu != %hu", motionpath->frame_rate, frame_rate);
    frame_rate++;
    if (dwg_dynapi_entity_set_value (motionpath, "MOTIONPATH", "frame_rate", &frame_rate, 0)
        && frame_rate == motionpath->frame_rate)
      pass ();
    else
      fail ("MOTIONPATH.frame_rate [BS] set+1 %hu != %hu", motionpath->frame_rate, frame_rate);
    motionpath->frame_rate--;
  }
  {
    BITCODE_BS frames;
    if (dwg_dynapi_entity_value (motionpath, "MOTIONPATH", "frames", &frames, NULL)
        && frames == motionpath->frames)
      pass ();
    else
      fail ("MOTIONPATH.frames [BS] %hu != %hu", motionpath->frames, frames);
    frames++;
    if (dwg_dynapi_entity_set_value (motionpath, "MOTIONPATH", "frames", &frames, 0)
        && frames == motionpath->frames)
      pass ();
    else
      fail ("MOTIONPATH.frames [BS] set+1 %hu != %hu", motionpath->frames, frames);
    motionpath->frames--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (motionpath, "MOTIONPATH", "parent", &parent, NULL)
        && !memcmp (&parent, &motionpath->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("MOTIONPATH.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H target_path;
    if (dwg_dynapi_entity_value (motionpath, "MOTIONPATH", "target_path", &target_path, NULL)
        && !memcmp (&target_path, &motionpath->target_path, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MOTIONPATH.target_path [H]");
  }
  {
    BITCODE_H viewtable;
    if (dwg_dynapi_entity_value (motionpath, "MOTIONPATH", "viewtable", &viewtable, NULL)
        && !memcmp (&viewtable, &motionpath->viewtable, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MOTIONPATH.viewtable [H]");
  }
  if (failed && (is_class_unstable ("MOTIONPATH") || is_class_debugging ("MOTIONPATH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MOTIONPATH", failed);
      failed = 0;
    }
  return failed;
}
static int test_MTEXTATTRIBUTEOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MTEXTATTRIBUTEOBJECTCONTEXTDATA *restrict mtextattributeobjectcontextdata = obj->tio.object->tio.MTEXTATTRIBUTEOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !mtextattributeobjectcontextdata)
    {
      fail ("NULL MTEXTATTRIBUTEOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_2RD alignment_pt;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &mtextattributeobjectcontextdata->alignment_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.alignment_pt [2RD]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == mtextattributeobjectcontextdata->class_version)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", mtextattributeobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == mtextattributeobjectcontextdata->class_version)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", mtextattributeobjectcontextdata->class_version, class_version);
    mtextattributeobjectcontextdata->class_version--;
  }
  {
    struct _dwg_object* context;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "num_context", &count, NULL)
        && dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "context", &context, NULL)
        && context == mtextattributeobjectcontextdata->context)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.context [struct _dwg_object*] * %u num_context", count);
  }
  {
    BITCODE_B enable_context;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "enable_context", &enable_context, NULL)
        && enable_context == mtextattributeobjectcontextdata->enable_context)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.enable_context [B] " FORMAT_B " != " FORMAT_B "", mtextattributeobjectcontextdata->enable_context, enable_context);
    enable_context++;
    if (dwg_dynapi_entity_set_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "enable_context", &enable_context, 0)
        && enable_context == mtextattributeobjectcontextdata->enable_context)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.enable_context [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextattributeobjectcontextdata->enable_context, enable_context);
    mtextattributeobjectcontextdata->enable_context--;
  }
  {
    BITCODE_BS horizontal_mode;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "horizontal_mode", &horizontal_mode, NULL)
        && horizontal_mode == mtextattributeobjectcontextdata->horizontal_mode)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.horizontal_mode [BS] %hu != %hu", mtextattributeobjectcontextdata->horizontal_mode, horizontal_mode);
    horizontal_mode++;
    if (dwg_dynapi_entity_set_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "horizontal_mode", &horizontal_mode, 0)
        && horizontal_mode == mtextattributeobjectcontextdata->horizontal_mode)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.horizontal_mode [BS] set+1 %hu != %hu", mtextattributeobjectcontextdata->horizontal_mode, horizontal_mode);
    mtextattributeobjectcontextdata->horizontal_mode--;
  }
  {
    BITCODE_2RD ins_pt;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &mtextattributeobjectcontextdata->ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.ins_pt [2RD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == mtextattributeobjectcontextdata->is_default)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", mtextattributeobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == mtextattributeobjectcontextdata->is_default)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextattributeobjectcontextdata->is_default, is_default);
    mtextattributeobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &mtextattributeobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "rotation", &rotation, NULL)
        && rotation == mtextattributeobjectcontextdata->rotation)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.rotation [BD] %g != %g", mtextattributeobjectcontextdata->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "rotation", &rotation, 0)
        && rotation == mtextattributeobjectcontextdata->rotation)
      pass ();
    else
      fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.rotation [BD] set+1 %g != %g", mtextattributeobjectcontextdata->rotation, rotation);
    mtextattributeobjectcontextdata->rotation--;
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (mtextattributeobjectcontextdata, "MTEXTATTRIBUTEOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &mtextattributeobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MTEXTATTRIBUTEOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("MTEXTATTRIBUTEOBJECTCONTEXTDATA") || is_class_debugging ("MTEXTATTRIBUTEOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MTEXTATTRIBUTEOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_MTEXTOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_MTEXTOBJECTCONTEXTDATA *restrict mtextobjectcontextdata = obj->tio.object->tio.MTEXTOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !mtextobjectcontextdata)
    {
      fail ("NULL MTEXTOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BL attachment;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "attachment", &attachment, NULL)
        && attachment == mtextobjectcontextdata->attachment)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.attachment [BL] %u != %u", mtextobjectcontextdata->attachment, attachment);
    attachment++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "attachment", &attachment, 0)
        && attachment == mtextobjectcontextdata->attachment)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.attachment [BL] set+1 %u != %u", mtextobjectcontextdata->attachment, attachment);
    mtextobjectcontextdata->attachment--;
  }
  {
    BITCODE_B auto_height;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "auto_height", &auto_height, NULL)
        && auto_height == mtextobjectcontextdata->auto_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.auto_height [B] " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->auto_height, auto_height);
    auto_height++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "auto_height", &auto_height, 0)
        && auto_height == mtextobjectcontextdata->auto_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.auto_height [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->auto_height, auto_height);
    mtextobjectcontextdata->auto_height--;
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == mtextobjectcontextdata->class_version)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", mtextobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == mtextobjectcontextdata->class_version)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", mtextobjectcontextdata->class_version, class_version);
    mtextobjectcontextdata->class_version--;
  }
  {
    BITCODE_BD* column_heights;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "num_column_heights", &count, NULL)
        && dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "column_heights", &column_heights, NULL)
        && column_heights == mtextobjectcontextdata->column_heights)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.column_heights [BD*] * %u num_column_heights", count);
  }
  {
    BITCODE_BL column_type;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "column_type", &column_type, NULL)
        && column_type == mtextobjectcontextdata->column_type)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.column_type [BL] %u != %u", mtextobjectcontextdata->column_type, column_type);
    column_type++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "column_type", &column_type, 0)
        && column_type == mtextobjectcontextdata->column_type)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.column_type [BL] set+1 %u != %u", mtextobjectcontextdata->column_type, column_type);
    mtextobjectcontextdata->column_type--;
  }
  {
    BITCODE_BD column_width;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "column_width", &column_width, NULL)
        && column_width == mtextobjectcontextdata->column_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.column_width [BD] %g != %g", mtextobjectcontextdata->column_width, column_width);
    column_width++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "column_width", &column_width, 0)
        && column_width == mtextobjectcontextdata->column_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.column_width [BD] set+1 %g != %g", mtextobjectcontextdata->column_width, column_width);
    mtextobjectcontextdata->column_width--;
  }
  {
    BITCODE_BD extents_height;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "extents_height", &extents_height, NULL)
        && extents_height == mtextobjectcontextdata->extents_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.extents_height [BD] %g != %g", mtextobjectcontextdata->extents_height, extents_height);
    extents_height++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "extents_height", &extents_height, 0)
        && extents_height == mtextobjectcontextdata->extents_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.extents_height [BD] set+1 %g != %g", mtextobjectcontextdata->extents_height, extents_height);
    mtextobjectcontextdata->extents_height--;
  }
  {
    BITCODE_BD extents_width;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "extents_width", &extents_width, NULL)
        && extents_width == mtextobjectcontextdata->extents_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.extents_width [BD] %g != %g", mtextobjectcontextdata->extents_width, extents_width);
    extents_width++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "extents_width", &extents_width, 0)
        && extents_width == mtextobjectcontextdata->extents_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.extents_width [BD] set+1 %g != %g", mtextobjectcontextdata->extents_width, extents_width);
    mtextobjectcontextdata->extents_width--;
  }
  {
    BITCODE_B flow_reversed;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "flow_reversed", &flow_reversed, NULL)
        && flow_reversed == mtextobjectcontextdata->flow_reversed)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.flow_reversed [B] " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->flow_reversed, flow_reversed);
    flow_reversed++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "flow_reversed", &flow_reversed, 0)
        && flow_reversed == mtextobjectcontextdata->flow_reversed)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.flow_reversed [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->flow_reversed, flow_reversed);
    mtextobjectcontextdata->flow_reversed--;
  }
  {
    BITCODE_BD gutter;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "gutter", &gutter, NULL)
        && gutter == mtextobjectcontextdata->gutter)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.gutter [BD] %g != %g", mtextobjectcontextdata->gutter, gutter);
    gutter++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "gutter", &gutter, 0)
        && gutter == mtextobjectcontextdata->gutter)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.gutter [BD] set+1 %g != %g", mtextobjectcontextdata->gutter, gutter);
    mtextobjectcontextdata->gutter--;
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &mtextobjectcontextdata->ins_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("MTEXTOBJECTCONTEXTDATA.ins_pt [3BD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == mtextobjectcontextdata->is_default)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == mtextobjectcontextdata->is_default)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", mtextobjectcontextdata->is_default, is_default);
    mtextobjectcontextdata->is_default--;
  }
  {
    BITCODE_BL num_column_heights;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "num_column_heights", &num_column_heights, NULL)
        && num_column_heights == mtextobjectcontextdata->num_column_heights)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.num_column_heights [BL] %u != %u", mtextobjectcontextdata->num_column_heights, num_column_heights);
    num_column_heights++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "num_column_heights", &num_column_heights, 0)
        && num_column_heights == mtextobjectcontextdata->num_column_heights)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.num_column_heights [BL] set+1 %u != %u", mtextobjectcontextdata->num_column_heights, num_column_heights);
    mtextobjectcontextdata->num_column_heights--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &mtextobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("MTEXTOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD rect_height;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "rect_height", &rect_height, NULL)
        && rect_height == mtextobjectcontextdata->rect_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.rect_height [BD] %g != %g", mtextobjectcontextdata->rect_height, rect_height);
    rect_height++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "rect_height", &rect_height, 0)
        && rect_height == mtextobjectcontextdata->rect_height)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.rect_height [BD] set+1 %g != %g", mtextobjectcontextdata->rect_height, rect_height);
    mtextobjectcontextdata->rect_height--;
  }
  {
    BITCODE_BD rect_width;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "rect_width", &rect_width, NULL)
        && rect_width == mtextobjectcontextdata->rect_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.rect_width [BD] %g != %g", mtextobjectcontextdata->rect_width, rect_width);
    rect_width++;
    if (dwg_dynapi_entity_set_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "rect_width", &rect_width, 0)
        && rect_width == mtextobjectcontextdata->rect_width)
      pass ();
    else
      fail ("MTEXTOBJECTCONTEXTDATA.rect_width [BD] set+1 %g != %g", mtextobjectcontextdata->rect_width, rect_width);
    mtextobjectcontextdata->rect_width--;
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &mtextobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("MTEXTOBJECTCONTEXTDATA.scale [H]");
  }
  {
    BITCODE_3BD x_axis_dir;
    if (dwg_dynapi_entity_value (mtextobjectcontextdata, "MTEXTOBJECTCONTEXTDATA", "x_axis_dir", &x_axis_dir, NULL)
        && !memcmp (&x_axis_dir, &mtextobjectcontextdata->x_axis_dir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("MTEXTOBJECTCONTEXTDATA.x_axis_dir [3BD]");
  }
  if (failed && (is_class_unstable ("MTEXTOBJECTCONTEXTDATA") || is_class_debugging ("MTEXTOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "MTEXTOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_NAVISWORKSMODELDEF (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_NAVISWORKSMODELDEF *restrict navisworksmodeldef = obj->tio.object->tio.NAVISWORKSMODELDEF;
  failed = 0;
  if (!obj_obj || !navisworksmodeldef)
    {
      fail ("NULL NAVISWORKSMODELDEF");
      return 1;
    }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "flags", &flags, NULL)
        && flags == navisworksmodeldef->flags)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.flags [BS] %hu != %hu", navisworksmodeldef->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "flags", &flags, 0)
        && flags == navisworksmodeldef->flags)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.flags [BS] set+1 %hu != %hu", navisworksmodeldef->flags, flags);
    navisworksmodeldef->flags--;
  }
  {
    BITCODE_B host_drawing_visibility;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "host_drawing_visibility", &host_drawing_visibility, NULL)
        && host_drawing_visibility == navisworksmodeldef->host_drawing_visibility)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.host_drawing_visibility [B] " FORMAT_B " != " FORMAT_B "", navisworksmodeldef->host_drawing_visibility, host_drawing_visibility);
    host_drawing_visibility++;
    if (dwg_dynapi_entity_set_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "host_drawing_visibility", &host_drawing_visibility, 0)
        && host_drawing_visibility == navisworksmodeldef->host_drawing_visibility)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.host_drawing_visibility [B] set+1 " FORMAT_B " != " FORMAT_B "", navisworksmodeldef->host_drawing_visibility, host_drawing_visibility);
    navisworksmodeldef->host_drawing_visibility--;
  }
  {
    BITCODE_3BD max_extent;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "max_extent", &max_extent, NULL)
        && !memcmp (&max_extent, &navisworksmodeldef->max_extent, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("NAVISWORKSMODELDEF.max_extent [3BD]");
  }
  {
    BITCODE_3BD min_extent;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "min_extent", &min_extent, NULL)
        && !memcmp (&min_extent, &navisworksmodeldef->min_extent, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("NAVISWORKSMODELDEF.min_extent [3BD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "parent", &parent, NULL)
        && !memcmp (&parent, &navisworksmodeldef->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("NAVISWORKSMODELDEF.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T path;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "path", &path, NULL)
        && path
           ? strEQ ((char *)path, (char *)navisworksmodeldef->path)
           : !navisworksmodeldef->path)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.path [T] '%s' <> '%s'", path, navisworksmodeldef->path);
  }
  {
    BITCODE_B status;
    if (dwg_dynapi_entity_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "status", &status, NULL)
        && status == navisworksmodeldef->status)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.status [B] " FORMAT_B " != " FORMAT_B "", navisworksmodeldef->status, status);
    status++;
    if (dwg_dynapi_entity_set_value (navisworksmodeldef, "NAVISWORKSMODELDEF", "status", &status, 0)
        && status == navisworksmodeldef->status)
      pass ();
    else
      fail ("NAVISWORKSMODELDEF.status [B] set+1 " FORMAT_B " != " FORMAT_B "", navisworksmodeldef->status, status);
    navisworksmodeldef->status--;
  }
  if (failed && (is_class_unstable ("NAVISWORKSMODELDEF") || is_class_debugging ("NAVISWORKSMODELDEF")))
    {
      ok ("%s failed %d tests (TODO unstable)", "NAVISWORKSMODELDEF", failed);
      failed = 0;
    }
  return failed;
}
static int test_OBJECT_PTR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_OBJECT_PTR *restrict object_ptr = obj->tio.object->tio.OBJECT_PTR;
  failed = 0;
  if (!obj_obj || !object_ptr)
    {
      fail ("NULL OBJECT_PTR");
      return 1;
    }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (object_ptr, "OBJECT_PTR", "parent", &parent, NULL)
        && !memcmp (&parent, &object_ptr->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("OBJECT_PTR.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("OBJECT_PTR") || is_class_debugging ("OBJECT_PTR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "OBJECT_PTR", failed);
      failed = 0;
    }
  return failed;
}
static int test_ORDDIMOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ORDDIMOBJECTCONTEXTDATA *restrict orddimobjectcontextdata = obj->tio.object->tio.ORDDIMOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !orddimobjectcontextdata)
    {
      fail ("NULL ORDDIMOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == orddimobjectcontextdata->class_version)
      pass ();
    else
      fail ("ORDDIMOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", orddimobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == orddimobjectcontextdata->class_version)
      pass ();
    else
      fail ("ORDDIMOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", orddimobjectcontextdata->class_version, class_version);
    orddimobjectcontextdata->class_version--;
  }
  {
    Dwg_OCD_Dimension dimension;
    if (dwg_dynapi_entity_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "dimension", &dimension, NULL)
        && !memcmp (&dimension, &orddimobjectcontextdata->dimension, sizeof (Dwg_OCD_Dimension)))
        pass ();
    else
        fail ("ORDDIMOBJECTCONTEXTDATA.dimension [Dwg_OCD_Dimension]");
  }
  {
    BITCODE_3BD feature_location_pt;
    if (dwg_dynapi_entity_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "feature_location_pt", &feature_location_pt, NULL)
        && !memcmp (&feature_location_pt, &orddimobjectcontextdata->feature_location_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ORDDIMOBJECTCONTEXTDATA.feature_location_pt [3BD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == orddimobjectcontextdata->is_default)
      pass ();
    else
      fail ("ORDDIMOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", orddimobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == orddimobjectcontextdata->is_default)
      pass ();
    else
      fail ("ORDDIMOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", orddimobjectcontextdata->is_default, is_default);
    orddimobjectcontextdata->is_default--;
  }
  {
    BITCODE_3BD leader_endpt;
    if (dwg_dynapi_entity_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "leader_endpt", &leader_endpt, NULL)
        && !memcmp (&leader_endpt, &orddimobjectcontextdata->leader_endpt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("ORDDIMOBJECTCONTEXTDATA.leader_endpt [3BD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &orddimobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("ORDDIMOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (orddimobjectcontextdata, "ORDDIMOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &orddimobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("ORDDIMOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("ORDDIMOBJECTCONTEXTDATA") || is_class_debugging ("ORDDIMOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ORDDIMOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_PARTIAL_VIEWING_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PARTIAL_VIEWING_INDEX *restrict partial_viewing_index = obj->tio.object->tio.PARTIAL_VIEWING_INDEX;
  failed = 0;
  if (!obj_obj || !partial_viewing_index)
    {
      fail ("NULL PARTIAL_VIEWING_INDEX");
      return 1;
    }
  {
    Dwg_PARTIAL_VIEWING_INDEX_Entry* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (partial_viewing_index, "PARTIAL_VIEWING_INDEX", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (partial_viewing_index, "PARTIAL_VIEWING_INDEX", "entries", &entries, NULL)
        && entries == partial_viewing_index->entries)
      pass ();
    else
      fail ("PARTIAL_VIEWING_INDEX.entries [Dwg_PARTIAL_VIEWING_INDEX_Entry*] * %u num_entries", count);
  }
  {
    BITCODE_B has_entries;
    if (dwg_dynapi_entity_value (partial_viewing_index, "PARTIAL_VIEWING_INDEX", "has_entries", &has_entries, NULL)
        && has_entries == partial_viewing_index->has_entries)
      pass ();
    else
      fail ("PARTIAL_VIEWING_INDEX.has_entries [B] " FORMAT_B " != " FORMAT_B "", partial_viewing_index->has_entries, has_entries);
    has_entries++;
    if (dwg_dynapi_entity_set_value (partial_viewing_index, "PARTIAL_VIEWING_INDEX", "has_entries", &has_entries, 0)
        && has_entries == partial_viewing_index->has_entries)
      pass ();
    else
      fail ("PARTIAL_VIEWING_INDEX.has_entries [B] set+1 " FORMAT_B " != " FORMAT_B "", partial_viewing_index->has_entries, has_entries);
    partial_viewing_index->has_entries--;
  }
  {
    BITCODE_BL num_entries;
    if (dwg_dynapi_entity_value (partial_viewing_index, "PARTIAL_VIEWING_INDEX", "num_entries", &num_entries, NULL)
        && num_entries == partial_viewing_index->num_entries)
      pass ();
    else
      fail ("PARTIAL_VIEWING_INDEX.num_entries [BL] %u != %u", partial_viewing_index->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (partial_viewing_index, "PARTIAL_VIEWING_INDEX", "num_entries", &num_entries, 0)
        && num_entries == partial_viewing_index->num_entries)
      pass ();
    else
      fail ("PARTIAL_VIEWING_INDEX.num_entries [BL] set+1 %u != %u", partial_viewing_index->num_entries, num_entries);
    partial_viewing_index->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (partial_viewing_index, "PARTIAL_VIEWING_INDEX", "parent", &parent, NULL)
        && !memcmp (&parent, &partial_viewing_index->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("PARTIAL_VIEWING_INDEX.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("PARTIAL_VIEWING_INDEX") || is_class_debugging ("PARTIAL_VIEWING_INDEX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PARTIAL_VIEWING_INDEX", failed);
      failed = 0;
    }
  return failed;
}
static int test_PERSUBENTMGR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PERSUBENTMGR *restrict persubentmgr = obj->tio.object->tio.PERSUBENTMGR;
  failed = 0;
  if (!obj_obj || !persubentmgr)
    {
      fail ("NULL PERSUBENTMGR");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "class_version", &class_version, NULL)
        && class_version == persubentmgr->class_version)
      pass ();
    else
      fail ("PERSUBENTMGR.class_version [BL] %u != %u", persubentmgr->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (persubentmgr, "PERSUBENTMGR", "class_version", &class_version, 0)
        && class_version == persubentmgr->class_version)
      pass ();
    else
      fail ("PERSUBENTMGR.class_version [BL] set+1 %u != %u", persubentmgr->class_version, class_version);
    persubentmgr->class_version--;
  }
  {
    BITCODE_BL num_steps;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "num_steps", &num_steps, NULL)
        && num_steps == persubentmgr->num_steps)
      pass ();
    else
      fail ("PERSUBENTMGR.num_steps [BL] %u != %u", persubentmgr->num_steps, num_steps);
    num_steps++;
    if (dwg_dynapi_entity_set_value (persubentmgr, "PERSUBENTMGR", "num_steps", &num_steps, 0)
        && num_steps == persubentmgr->num_steps)
      pass ();
    else
      fail ("PERSUBENTMGR.num_steps [BL] set+1 %u != %u", persubentmgr->num_steps, num_steps);
    persubentmgr->num_steps--;
  }
  {
    BITCODE_BL num_subents;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "num_subents", &num_subents, NULL)
        && num_subents == persubentmgr->num_subents)
      pass ();
    else
      fail ("PERSUBENTMGR.num_subents [BL] %u != %u", persubentmgr->num_subents, num_subents);
    num_subents++;
    if (dwg_dynapi_entity_set_value (persubentmgr, "PERSUBENTMGR", "num_subents", &num_subents, 0)
        && num_subents == persubentmgr->num_subents)
      pass ();
    else
      fail ("PERSUBENTMGR.num_subents [BL] set+1 %u != %u", persubentmgr->num_subents, num_subents);
    persubentmgr->num_subents--;
  }
  {
    BITCODE_BL numassocsteps;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "numassocsteps", &numassocsteps, NULL)
        && numassocsteps == persubentmgr->numassocsteps)
      pass ();
    else
      fail ("PERSUBENTMGR.numassocsteps [BL] %u != %u", persubentmgr->numassocsteps, numassocsteps);
    numassocsteps++;
    if (dwg_dynapi_entity_set_value (persubentmgr, "PERSUBENTMGR", "numassocsteps", &numassocsteps, 0)
        && numassocsteps == persubentmgr->numassocsteps)
      pass ();
    else
      fail ("PERSUBENTMGR.numassocsteps [BL] set+1 %u != %u", persubentmgr->numassocsteps, numassocsteps);
    persubentmgr->numassocsteps--;
  }
  {
    BITCODE_BL numassocsubents;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "numassocsubents", &numassocsubents, NULL)
        && numassocsubents == persubentmgr->numassocsubents)
      pass ();
    else
      fail ("PERSUBENTMGR.numassocsubents [BL] %u != %u", persubentmgr->numassocsubents, numassocsubents);
    numassocsubents++;
    if (dwg_dynapi_entity_set_value (persubentmgr, "PERSUBENTMGR", "numassocsubents", &numassocsubents, 0)
        && numassocsubents == persubentmgr->numassocsubents)
      pass ();
    else
      fail ("PERSUBENTMGR.numassocsubents [BL] set+1 %u != %u", persubentmgr->numassocsubents, numassocsubents);
    persubentmgr->numassocsubents--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "parent", &parent, NULL)
        && !memcmp (&parent, &persubentmgr->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("PERSUBENTMGR.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL* steps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "num_steps", &count, NULL)
        && dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "steps", &steps, NULL)
        && steps == persubentmgr->steps)
      pass ();
    else
      fail ("PERSUBENTMGR.steps [BL*] * %u num_steps", count);
  }
  {
    BITCODE_BL* subents;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "num_subents", &count, NULL)
        && dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "subents", &subents, NULL)
        && subents == persubentmgr->subents)
      pass ();
    else
      fail ("PERSUBENTMGR.subents [BL*] * %u num_subents", count);
  }
  {
    BITCODE_BL unknown_0;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "unknown_0", &unknown_0, NULL)
        && unknown_0 == persubentmgr->unknown_0)
      pass ();
    else
      fail ("PERSUBENTMGR.unknown_0 [BL] %u != %u", persubentmgr->unknown_0, unknown_0);
    unknown_0++;
    if (dwg_dynapi_entity_set_value (persubentmgr, "PERSUBENTMGR", "unknown_0", &unknown_0, 0)
        && unknown_0 == persubentmgr->unknown_0)
      pass ();
    else
      fail ("PERSUBENTMGR.unknown_0 [BL] set+1 %u != %u", persubentmgr->unknown_0, unknown_0);
    persubentmgr->unknown_0--;
  }
  {
    BITCODE_BL unknown_2;
    if (dwg_dynapi_entity_value (persubentmgr, "PERSUBENTMGR", "unknown_2", &unknown_2, NULL)
        && unknown_2 == persubentmgr->unknown_2)
      pass ();
    else
      fail ("PERSUBENTMGR.unknown_2 [BL] %u != %u", persubentmgr->unknown_2, unknown_2);
    unknown_2++;
    if (dwg_dynapi_entity_set_value (persubentmgr, "PERSUBENTMGR", "unknown_2", &unknown_2, 0)
        && unknown_2 == persubentmgr->unknown_2)
      pass ();
    else
      fail ("PERSUBENTMGR.unknown_2 [BL] set+1 %u != %u", persubentmgr->unknown_2, unknown_2);
    persubentmgr->unknown_2--;
  }
  if (failed && (is_class_unstable ("PERSUBENTMGR") || is_class_debugging ("PERSUBENTMGR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PERSUBENTMGR", failed);
      failed = 0;
    }
  return failed;
}
static int test_PLACEHOLDER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PLACEHOLDER *restrict placeholder = obj->tio.object->tio.PLACEHOLDER;
  failed = 0;
  if (!obj_obj || !placeholder)
    {
      fail ("NULL PLACEHOLDER");
      return 1;
    }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (placeholder, "PLACEHOLDER", "parent", &parent, NULL)
        && !memcmp (&parent, &placeholder->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("PLACEHOLDER.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("PLACEHOLDER") || is_class_debugging ("PLACEHOLDER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PLACEHOLDER", failed);
      failed = 0;
    }
  return failed;
}
static int test_PLOTSETTINGS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PLOTSETTINGS *restrict plotsettings = obj->tio.object->tio.PLOTSETTINGS;
  failed = 0;
  if (!obj_obj || !plotsettings)
    {
      fail ("NULL PLOTSETTINGS");
      return 1;
    }
  {
    BITCODE_BD bottom_margin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "bottom_margin", &bottom_margin, NULL)
        && bottom_margin == plotsettings->bottom_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.bottom_margin [BD] %g != %g", plotsettings->bottom_margin, bottom_margin);
    bottom_margin++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "bottom_margin", &bottom_margin, 0)
        && bottom_margin == plotsettings->bottom_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.bottom_margin [BD] set+1 %g != %g", plotsettings->bottom_margin, bottom_margin);
    plotsettings->bottom_margin--;
  }
  {
    BITCODE_T canonical_media_name;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "canonical_media_name", &canonical_media_name, NULL)
        && canonical_media_name
           ? strEQ ((char *)canonical_media_name, (char *)plotsettings->canonical_media_name)
           : !plotsettings->canonical_media_name)
      pass ();
    else
      fail ("PLOTSETTINGS.canonical_media_name [T] '%s' <> '%s'", canonical_media_name, plotsettings->canonical_media_name);
  }
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "drawing_units", &drawing_units, NULL)
        && drawing_units == plotsettings->drawing_units)
      pass ();
    else
      fail ("PLOTSETTINGS.drawing_units [BD] %g != %g", plotsettings->drawing_units, drawing_units);
    drawing_units++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "drawing_units", &drawing_units, 0)
        && drawing_units == plotsettings->drawing_units)
      pass ();
    else
      fail ("PLOTSETTINGS.drawing_units [BD] set+1 %g != %g", plotsettings->drawing_units, drawing_units);
    plotsettings->drawing_units--;
  }
  {
    BITCODE_BD left_margin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "left_margin", &left_margin, NULL)
        && left_margin == plotsettings->left_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.left_margin [BD] %g != %g", plotsettings->left_margin, left_margin);
    left_margin++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "left_margin", &left_margin, 0)
        && left_margin == plotsettings->left_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.left_margin [BD] set+1 %g != %g", plotsettings->left_margin, left_margin);
    plotsettings->left_margin--;
  }
  {
    BITCODE_BD paper_height;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_height", &paper_height, NULL)
        && paper_height == plotsettings->paper_height)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_height [BD] %g != %g", plotsettings->paper_height, paper_height);
    paper_height++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "paper_height", &paper_height, 0)
        && paper_height == plotsettings->paper_height)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_height [BD] set+1 %g != %g", plotsettings->paper_height, paper_height);
    plotsettings->paper_height--;
  }
  {
    BITCODE_2BD paper_image_origin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_image_origin", &paper_image_origin, NULL)
        && !memcmp (&paper_image_origin, &plotsettings->paper_image_origin, sizeof (BITCODE_2BD)))
        pass ();
    else
        fail ("PLOTSETTINGS.paper_image_origin [2BD_1]");
  }
  {
    BITCODE_T paper_size;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_size", &paper_size, NULL)
        && paper_size
           ? strEQ ((char *)paper_size, (char *)plotsettings->paper_size)
           : !plotsettings->paper_size)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_size [T] '%s' <> '%s'", paper_size, plotsettings->paper_size);
  }
  {
    BITCODE_BD paper_units;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_units", &paper_units, NULL)
        && paper_units == plotsettings->paper_units)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_units [BD] %g != %g", plotsettings->paper_units, paper_units);
    paper_units++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "paper_units", &paper_units, 0)
        && paper_units == plotsettings->paper_units)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_units [BD] set+1 %g != %g", plotsettings->paper_units, paper_units);
    plotsettings->paper_units--;
  }
  {
    BITCODE_BD paper_width;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "paper_width", &paper_width, NULL)
        && paper_width == plotsettings->paper_width)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_width [BD] %g != %g", plotsettings->paper_width, paper_width);
    paper_width++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "paper_width", &paper_width, 0)
        && paper_width == plotsettings->paper_width)
      pass ();
    else
      fail ("PLOTSETTINGS.paper_width [BD] set+1 %g != %g", plotsettings->paper_width, paper_width);
    plotsettings->paper_width--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "parent", &parent, NULL)
        && !memcmp (&parent, &plotsettings->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("PLOTSETTINGS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS plot_flags;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_flags", &plot_flags, NULL)
        && plot_flags == plotsettings->plot_flags)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_flags [BS] %hu != %hu", plotsettings->plot_flags, plot_flags);
    plot_flags++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "plot_flags", &plot_flags, 0)
        && plot_flags == plotsettings->plot_flags)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_flags [BS] set+1 %hu != %hu", plotsettings->plot_flags, plot_flags);
    plotsettings->plot_flags--;
  }
  {
    BITCODE_2BD plot_origin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_origin", &plot_origin, NULL)
        && !memcmp (&plot_origin, &plotsettings->plot_origin, sizeof (BITCODE_2BD)))
        pass ();
    else
        fail ("PLOTSETTINGS.plot_origin [2BD_1]");
  }
  {
    BITCODE_BS plot_paper_unit;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_paper_unit", &plot_paper_unit, NULL)
        && plot_paper_unit == plotsettings->plot_paper_unit)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_paper_unit [BS] %hu != %hu", plotsettings->plot_paper_unit, plot_paper_unit);
    plot_paper_unit++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "plot_paper_unit", &plot_paper_unit, 0)
        && plot_paper_unit == plotsettings->plot_paper_unit)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_paper_unit [BS] set+1 %hu != %hu", plotsettings->plot_paper_unit, plot_paper_unit);
    plotsettings->plot_paper_unit--;
  }
  {
    BITCODE_BS plot_rotation_mode;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_rotation_mode", &plot_rotation_mode, NULL)
        && plot_rotation_mode == plotsettings->plot_rotation_mode)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_rotation_mode [BS] %hu != %hu", plotsettings->plot_rotation_mode, plot_rotation_mode);
    plot_rotation_mode++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "plot_rotation_mode", &plot_rotation_mode, 0)
        && plot_rotation_mode == plotsettings->plot_rotation_mode)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_rotation_mode [BS] set+1 %hu != %hu", plotsettings->plot_rotation_mode, plot_rotation_mode);
    plotsettings->plot_rotation_mode--;
  }
  {
    BITCODE_BS plot_type;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_type", &plot_type, NULL)
        && plot_type == plotsettings->plot_type)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_type [BS] %hu != %hu", plotsettings->plot_type, plot_type);
    plot_type++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "plot_type", &plot_type, 0)
        && plot_type == plotsettings->plot_type)
      pass ();
    else
      fail ("PLOTSETTINGS.plot_type [BS] set+1 %hu != %hu", plotsettings->plot_type, plot_type);
    plotsettings->plot_type--;
  }
  {
    BITCODE_2BD plot_window_ll;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_window_ll", &plot_window_ll, NULL)
        && !memcmp (&plot_window_ll, &plotsettings->plot_window_ll, sizeof (BITCODE_2BD)))
        pass ();
    else
        fail ("PLOTSETTINGS.plot_window_ll [2BD_1]");
  }
  {
    BITCODE_2BD plot_window_ur;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plot_window_ur", &plot_window_ur, NULL)
        && !memcmp (&plot_window_ur, &plotsettings->plot_window_ur, sizeof (BITCODE_2BD)))
        pass ();
    else
        fail ("PLOTSETTINGS.plot_window_ur [2BD_1]");
  }
  {
    BITCODE_H plotview;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plotview", &plotview, NULL)
        && !memcmp (&plotview, &plotsettings->plotview, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("PLOTSETTINGS.plotview [H]");
  }
  {
    BITCODE_T plotview_name;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "plotview_name", &plotview_name, NULL)
        && plotview_name
           ? strEQ ((char *)plotview_name, (char *)plotsettings->plotview_name)
           : !plotsettings->plotview_name)
      pass ();
    else
      fail ("PLOTSETTINGS.plotview_name [T] '%s' <> '%s'", plotview_name, plotsettings->plotview_name);
  }
  {
    BITCODE_T printer_cfg_file;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "printer_cfg_file", &printer_cfg_file, NULL)
        && printer_cfg_file
           ? strEQ ((char *)printer_cfg_file, (char *)plotsettings->printer_cfg_file)
           : !plotsettings->printer_cfg_file)
      pass ();
    else
      fail ("PLOTSETTINGS.printer_cfg_file [T] '%s' <> '%s'", printer_cfg_file, plotsettings->printer_cfg_file);
  }
  {
    BITCODE_BD right_margin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "right_margin", &right_margin, NULL)
        && right_margin == plotsettings->right_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.right_margin [BD] %g != %g", plotsettings->right_margin, right_margin);
    right_margin++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "right_margin", &right_margin, 0)
        && right_margin == plotsettings->right_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.right_margin [BD] set+1 %g != %g", plotsettings->right_margin, right_margin);
    plotsettings->right_margin--;
  }
  {
    BITCODE_H shadeplot;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "shadeplot", &shadeplot, NULL)
        && !memcmp (&shadeplot, &plotsettings->shadeplot, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("PLOTSETTINGS.shadeplot [H]");
  }
  {
    BITCODE_BS shadeplot_customdpi;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "shadeplot_customdpi", &shadeplot_customdpi, NULL)
        && shadeplot_customdpi == plotsettings->shadeplot_customdpi)
      pass ();
    else
      fail ("PLOTSETTINGS.shadeplot_customdpi [BS] %hu != %hu", plotsettings->shadeplot_customdpi, shadeplot_customdpi);
    shadeplot_customdpi++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "shadeplot_customdpi", &shadeplot_customdpi, 0)
        && shadeplot_customdpi == plotsettings->shadeplot_customdpi)
      pass ();
    else
      fail ("PLOTSETTINGS.shadeplot_customdpi [BS] set+1 %hu != %hu", plotsettings->shadeplot_customdpi, shadeplot_customdpi);
    plotsettings->shadeplot_customdpi--;
  }
  {
    BITCODE_BS shadeplot_reslevel;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "shadeplot_reslevel", &shadeplot_reslevel, NULL)
        && shadeplot_reslevel == plotsettings->shadeplot_reslevel)
      pass ();
    else
      fail ("PLOTSETTINGS.shadeplot_reslevel [BS] %hu != %hu", plotsettings->shadeplot_reslevel, shadeplot_reslevel);
    shadeplot_reslevel++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "shadeplot_reslevel", &shadeplot_reslevel, 0)
        && shadeplot_reslevel == plotsettings->shadeplot_reslevel)
      pass ();
    else
      fail ("PLOTSETTINGS.shadeplot_reslevel [BS] set+1 %hu != %hu", plotsettings->shadeplot_reslevel, shadeplot_reslevel);
    plotsettings->shadeplot_reslevel--;
  }
  {
    BITCODE_BS shadeplot_type;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "shadeplot_type", &shadeplot_type, NULL)
        && shadeplot_type == plotsettings->shadeplot_type)
      pass ();
    else
      fail ("PLOTSETTINGS.shadeplot_type [BS] %hu != %hu", plotsettings->shadeplot_type, shadeplot_type);
    shadeplot_type++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "shadeplot_type", &shadeplot_type, 0)
        && shadeplot_type == plotsettings->shadeplot_type)
      pass ();
    else
      fail ("PLOTSETTINGS.shadeplot_type [BS] set+1 %hu != %hu", plotsettings->shadeplot_type, shadeplot_type);
    plotsettings->shadeplot_type--;
  }
  {
    BITCODE_BD std_scale_factor;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "std_scale_factor", &std_scale_factor, NULL)
        && std_scale_factor == plotsettings->std_scale_factor)
      pass ();
    else
      fail ("PLOTSETTINGS.std_scale_factor [BD] %g != %g", plotsettings->std_scale_factor, std_scale_factor);
    std_scale_factor++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "std_scale_factor", &std_scale_factor, 0)
        && std_scale_factor == plotsettings->std_scale_factor)
      pass ();
    else
      fail ("PLOTSETTINGS.std_scale_factor [BD] set+1 %g != %g", plotsettings->std_scale_factor, std_scale_factor);
    plotsettings->std_scale_factor--;
  }
  {
    BITCODE_BS std_scale_type;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "std_scale_type", &std_scale_type, NULL)
        && std_scale_type == plotsettings->std_scale_type)
      pass ();
    else
      fail ("PLOTSETTINGS.std_scale_type [BS] %hu != %hu", plotsettings->std_scale_type, std_scale_type);
    std_scale_type++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "std_scale_type", &std_scale_type, 0)
        && std_scale_type == plotsettings->std_scale_type)
      pass ();
    else
      fail ("PLOTSETTINGS.std_scale_type [BS] set+1 %hu != %hu", plotsettings->std_scale_type, std_scale_type);
    plotsettings->std_scale_type--;
  }
  {
    BITCODE_T stylesheet;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "stylesheet", &stylesheet, NULL)
        && stylesheet
           ? strEQ ((char *)stylesheet, (char *)plotsettings->stylesheet)
           : !plotsettings->stylesheet)
      pass ();
    else
      fail ("PLOTSETTINGS.stylesheet [T] '%s' <> '%s'", stylesheet, plotsettings->stylesheet);
  }
  {
    BITCODE_BD top_margin;
    if (dwg_dynapi_entity_value (plotsettings, "PLOTSETTINGS", "top_margin", &top_margin, NULL)
        && top_margin == plotsettings->top_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.top_margin [BD] %g != %g", plotsettings->top_margin, top_margin);
    top_margin++;
    if (dwg_dynapi_entity_set_value (plotsettings, "PLOTSETTINGS", "top_margin", &top_margin, 0)
        && top_margin == plotsettings->top_margin)
      pass ();
    else
      fail ("PLOTSETTINGS.top_margin [BD] set+1 %g != %g", plotsettings->top_margin, top_margin);
    plotsettings->top_margin--;
  }
  if (failed && (is_class_unstable ("PLOTSETTINGS") || is_class_debugging ("PLOTSETTINGS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PLOTSETTINGS", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTCLOUDCOLORMAP (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_POINTCLOUDCOLORMAP *restrict pointcloudcolormap = obj->tio.object->tio.POINTCLOUDCOLORMAP;
  failed = 0;
  if (!obj_obj || !pointcloudcolormap)
    {
      fail ("NULL POINTCLOUDCOLORMAP");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "class_version", &class_version, NULL)
        && class_version == pointcloudcolormap->class_version)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.class_version [BS] %hu != %hu", pointcloudcolormap->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "class_version", &class_version, 0)
        && class_version == pointcloudcolormap->class_version)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.class_version [BS] set+1 %hu != %hu", pointcloudcolormap->class_version, class_version);
    pointcloudcolormap->class_version--;
  }
  {
    Dwg_POINTCLOUDCOLORMAP_Ramp* classification_colorramps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "num_classification_colorramps", &count, NULL)
        && dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "classification_colorramps", &classification_colorramps, NULL)
        && classification_colorramps == pointcloudcolormap->classification_colorramps)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.classification_colorramps [Dwg_POINTCLOUDCOLORMAP_Ramp*] * %u num_classification_colorramps", count);
  }
  {
    Dwg_POINTCLOUDCOLORMAP_Ramp* colorramps;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "num_colorramps", &count, NULL)
        && dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "colorramps", &colorramps, NULL)
        && colorramps == pointcloudcolormap->colorramps)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.colorramps [Dwg_POINTCLOUDCOLORMAP_Ramp*] * %u num_colorramps", count);
  }
  {
    BITCODE_T def_classification_colorscheme;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "def_classification_colorscheme", &def_classification_colorscheme, NULL)
        && def_classification_colorscheme
           ? strEQ ((char *)def_classification_colorscheme, (char *)pointcloudcolormap->def_classification_colorscheme)
           : !pointcloudcolormap->def_classification_colorscheme)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.def_classification_colorscheme [T] '%s' <> '%s'", def_classification_colorscheme, pointcloudcolormap->def_classification_colorscheme);
  }
  {
    BITCODE_T def_elevation_colorscheme;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "def_elevation_colorscheme", &def_elevation_colorscheme, NULL)
        && def_elevation_colorscheme
           ? strEQ ((char *)def_elevation_colorscheme, (char *)pointcloudcolormap->def_elevation_colorscheme)
           : !pointcloudcolormap->def_elevation_colorscheme)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.def_elevation_colorscheme [T] '%s' <> '%s'", def_elevation_colorscheme, pointcloudcolormap->def_elevation_colorscheme);
  }
  {
    BITCODE_T def_intensity_colorscheme;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "def_intensity_colorscheme", &def_intensity_colorscheme, NULL)
        && def_intensity_colorscheme
           ? strEQ ((char *)def_intensity_colorscheme, (char *)pointcloudcolormap->def_intensity_colorscheme)
           : !pointcloudcolormap->def_intensity_colorscheme)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.def_intensity_colorscheme [T] '%s' <> '%s'", def_intensity_colorscheme, pointcloudcolormap->def_intensity_colorscheme);
  }
  {
    BITCODE_BL num_classification_colorramps;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "num_classification_colorramps", &num_classification_colorramps, NULL)
        && num_classification_colorramps == pointcloudcolormap->num_classification_colorramps)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.num_classification_colorramps [BL] %u != %u", pointcloudcolormap->num_classification_colorramps, num_classification_colorramps);
    num_classification_colorramps++;
    if (dwg_dynapi_entity_set_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "num_classification_colorramps", &num_classification_colorramps, 0)
        && num_classification_colorramps == pointcloudcolormap->num_classification_colorramps)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.num_classification_colorramps [BL] set+1 %u != %u", pointcloudcolormap->num_classification_colorramps, num_classification_colorramps);
    pointcloudcolormap->num_classification_colorramps--;
  }
  {
    BITCODE_BL num_colorramps;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "num_colorramps", &num_colorramps, NULL)
        && num_colorramps == pointcloudcolormap->num_colorramps)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.num_colorramps [BL] %u != %u", pointcloudcolormap->num_colorramps, num_colorramps);
    num_colorramps++;
    if (dwg_dynapi_entity_set_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "num_colorramps", &num_colorramps, 0)
        && num_colorramps == pointcloudcolormap->num_colorramps)
      pass ();
    else
      fail ("POINTCLOUDCOLORMAP.num_colorramps [BL] set+1 %u != %u", pointcloudcolormap->num_colorramps, num_colorramps);
    pointcloudcolormap->num_colorramps--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (pointcloudcolormap, "POINTCLOUDCOLORMAP", "parent", &parent, NULL)
        && !memcmp (&parent, &pointcloudcolormap->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("POINTCLOUDCOLORMAP.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("POINTCLOUDCOLORMAP") || is_class_debugging ("POINTCLOUDCOLORMAP")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTCLOUDCOLORMAP", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTCLOUDDEF (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_POINTCLOUDDEF *restrict pointclouddef = obj->tio.object->tio.POINTCLOUDDEF;
  failed = 0;
  if (!obj_obj || !pointclouddef)
    {
      fail ("NULL POINTCLOUDDEF");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (pointclouddef, "POINTCLOUDDEF", "class_version", &class_version, NULL)
        && class_version == pointclouddef->class_version)
      pass ();
    else
      fail ("POINTCLOUDDEF.class_version [BL] %u != %u", pointclouddef->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (pointclouddef, "POINTCLOUDDEF", "class_version", &class_version, 0)
        && class_version == pointclouddef->class_version)
      pass ();
    else
      fail ("POINTCLOUDDEF.class_version [BL] set+1 %u != %u", pointclouddef->class_version, class_version);
    pointclouddef->class_version--;
  }
  {
    BITCODE_3BD extents_max;
    if (dwg_dynapi_entity_value (pointclouddef, "POINTCLOUDDEF", "extents_max", &extents_max, NULL)
        && !memcmp (&extents_max, &pointclouddef->extents_max, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDDEF.extents_max [3BD]");
  }
  {
    BITCODE_3BD extents_min;
    if (dwg_dynapi_entity_value (pointclouddef, "POINTCLOUDDEF", "extents_min", &extents_min, NULL)
        && !memcmp (&extents_min, &pointclouddef->extents_min, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDDEF.extents_min [3BD]");
  }
  {
    BITCODE_B is_loaded;
    if (dwg_dynapi_entity_value (pointclouddef, "POINTCLOUDDEF", "is_loaded", &is_loaded, NULL)
        && is_loaded == pointclouddef->is_loaded)
      pass ();
    else
      fail ("POINTCLOUDDEF.is_loaded [B] " FORMAT_B " != " FORMAT_B "", pointclouddef->is_loaded, is_loaded);
    is_loaded++;
    if (dwg_dynapi_entity_set_value (pointclouddef, "POINTCLOUDDEF", "is_loaded", &is_loaded, 0)
        && is_loaded == pointclouddef->is_loaded)
      pass ();
    else
      fail ("POINTCLOUDDEF.is_loaded [B] set+1 " FORMAT_B " != " FORMAT_B "", pointclouddef->is_loaded, is_loaded);
    pointclouddef->is_loaded--;
  }
  {
    BITCODE_RLL numpoints;
    if (dwg_dynapi_entity_value (pointclouddef, "POINTCLOUDDEF", "numpoints", &numpoints, NULL)
        && numpoints == pointclouddef->numpoints)
      pass ();
    else
      fail ("POINTCLOUDDEF.numpoints [RLL] " FORMAT_RLL " != " FORMAT_RLL "", pointclouddef->numpoints, numpoints);
    numpoints++;
    if (dwg_dynapi_entity_set_value (pointclouddef, "POINTCLOUDDEF", "numpoints", &numpoints, 0)
        && numpoints == pointclouddef->numpoints)
      pass ();
    else
      fail ("POINTCLOUDDEF.numpoints [RLL] set+1 " FORMAT_RLL " != " FORMAT_RLL "", pointclouddef->numpoints, numpoints);
    pointclouddef->numpoints--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (pointclouddef, "POINTCLOUDDEF", "parent", &parent, NULL)
        && !memcmp (&parent, &pointclouddef->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("POINTCLOUDDEF.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T source_filename;
    if (dwg_dynapi_entity_value (pointclouddef, "POINTCLOUDDEF", "source_filename", &source_filename, NULL)
        && source_filename
           ? strEQ ((char *)source_filename, (char *)pointclouddef->source_filename)
           : !pointclouddef->source_filename)
      pass ();
    else
      fail ("POINTCLOUDDEF.source_filename [T] '%s' <> '%s'", source_filename, pointclouddef->source_filename);
  }
  if (failed && (is_class_unstable ("POINTCLOUDDEF") || is_class_debugging ("POINTCLOUDDEF")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTCLOUDDEF", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTCLOUDDEFEX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_POINTCLOUDDEFEX *restrict pointclouddefex = obj->tio.object->tio.POINTCLOUDDEFEX;
  failed = 0;
  if (!obj_obj || !pointclouddefex)
    {
      fail ("NULL POINTCLOUDDEFEX");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (pointclouddefex, "POINTCLOUDDEFEX", "class_version", &class_version, NULL)
        && class_version == pointclouddefex->class_version)
      pass ();
    else
      fail ("POINTCLOUDDEFEX.class_version [BL] %u != %u", pointclouddefex->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (pointclouddefex, "POINTCLOUDDEFEX", "class_version", &class_version, 0)
        && class_version == pointclouddefex->class_version)
      pass ();
    else
      fail ("POINTCLOUDDEFEX.class_version [BL] set+1 %u != %u", pointclouddefex->class_version, class_version);
    pointclouddefex->class_version--;
  }
  {
    BITCODE_3BD extents_max;
    if (dwg_dynapi_entity_value (pointclouddefex, "POINTCLOUDDEFEX", "extents_max", &extents_max, NULL)
        && !memcmp (&extents_max, &pointclouddefex->extents_max, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDDEFEX.extents_max [3BD]");
  }
  {
    BITCODE_3BD extents_min;
    if (dwg_dynapi_entity_value (pointclouddefex, "POINTCLOUDDEFEX", "extents_min", &extents_min, NULL)
        && !memcmp (&extents_min, &pointclouddefex->extents_min, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTCLOUDDEFEX.extents_min [3BD]");
  }
  {
    BITCODE_B is_loaded;
    if (dwg_dynapi_entity_value (pointclouddefex, "POINTCLOUDDEFEX", "is_loaded", &is_loaded, NULL)
        && is_loaded == pointclouddefex->is_loaded)
      pass ();
    else
      fail ("POINTCLOUDDEFEX.is_loaded [B] " FORMAT_B " != " FORMAT_B "", pointclouddefex->is_loaded, is_loaded);
    is_loaded++;
    if (dwg_dynapi_entity_set_value (pointclouddefex, "POINTCLOUDDEFEX", "is_loaded", &is_loaded, 0)
        && is_loaded == pointclouddefex->is_loaded)
      pass ();
    else
      fail ("POINTCLOUDDEFEX.is_loaded [B] set+1 " FORMAT_B " != " FORMAT_B "", pointclouddefex->is_loaded, is_loaded);
    pointclouddefex->is_loaded--;
  }
  {
    BITCODE_RLL numpoints;
    if (dwg_dynapi_entity_value (pointclouddefex, "POINTCLOUDDEFEX", "numpoints", &numpoints, NULL)
        && numpoints == pointclouddefex->numpoints)
      pass ();
    else
      fail ("POINTCLOUDDEFEX.numpoints [RLL] " FORMAT_RLL " != " FORMAT_RLL "", pointclouddefex->numpoints, numpoints);
    numpoints++;
    if (dwg_dynapi_entity_set_value (pointclouddefex, "POINTCLOUDDEFEX", "numpoints", &numpoints, 0)
        && numpoints == pointclouddefex->numpoints)
      pass ();
    else
      fail ("POINTCLOUDDEFEX.numpoints [RLL] set+1 " FORMAT_RLL " != " FORMAT_RLL "", pointclouddefex->numpoints, numpoints);
    pointclouddefex->numpoints--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (pointclouddefex, "POINTCLOUDDEFEX", "parent", &parent, NULL)
        && !memcmp (&parent, &pointclouddefex->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("POINTCLOUDDEFEX.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T source_filename;
    if (dwg_dynapi_entity_value (pointclouddefex, "POINTCLOUDDEFEX", "source_filename", &source_filename, NULL)
        && source_filename
           ? strEQ ((char *)source_filename, (char *)pointclouddefex->source_filename)
           : !pointclouddefex->source_filename)
      pass ();
    else
      fail ("POINTCLOUDDEFEX.source_filename [T] '%s' <> '%s'", source_filename, pointclouddefex->source_filename);
  }
  if (failed && (is_class_unstable ("POINTCLOUDDEFEX") || is_class_debugging ("POINTCLOUDDEFEX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTCLOUDDEFEX", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTCLOUDDEF_REACTOR (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_POINTCLOUDDEF_REACTOR *restrict pointclouddef_reactor = obj->tio.object->tio.POINTCLOUDDEF_REACTOR;
  failed = 0;
  if (!obj_obj || !pointclouddef_reactor)
    {
      fail ("NULL POINTCLOUDDEF_REACTOR");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (pointclouddef_reactor, "POINTCLOUDDEF_REACTOR", "class_version", &class_version, NULL)
        && class_version == pointclouddef_reactor->class_version)
      pass ();
    else
      fail ("POINTCLOUDDEF_REACTOR.class_version [BL] %u != %u", pointclouddef_reactor->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (pointclouddef_reactor, "POINTCLOUDDEF_REACTOR", "class_version", &class_version, 0)
        && class_version == pointclouddef_reactor->class_version)
      pass ();
    else
      fail ("POINTCLOUDDEF_REACTOR.class_version [BL] set+1 %u != %u", pointclouddef_reactor->class_version, class_version);
    pointclouddef_reactor->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (pointclouddef_reactor, "POINTCLOUDDEF_REACTOR", "parent", &parent, NULL)
        && !memcmp (&parent, &pointclouddef_reactor->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("POINTCLOUDDEF_REACTOR.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("POINTCLOUDDEF_REACTOR") || is_class_debugging ("POINTCLOUDDEF_REACTOR")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTCLOUDDEF_REACTOR", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTCLOUDDEF_REACTOR_EX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_POINTCLOUDDEF_REACTOR_EX *restrict pointclouddef_reactor_ex = obj->tio.object->tio.POINTCLOUDDEF_REACTOR_EX;
  failed = 0;
  if (!obj_obj || !pointclouddef_reactor_ex)
    {
      fail ("NULL POINTCLOUDDEF_REACTOR_EX");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (pointclouddef_reactor_ex, "POINTCLOUDDEF_REACTOR_EX", "class_version", &class_version, NULL)
        && class_version == pointclouddef_reactor_ex->class_version)
      pass ();
    else
      fail ("POINTCLOUDDEF_REACTOR_EX.class_version [BL] %u != %u", pointclouddef_reactor_ex->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (pointclouddef_reactor_ex, "POINTCLOUDDEF_REACTOR_EX", "class_version", &class_version, 0)
        && class_version == pointclouddef_reactor_ex->class_version)
      pass ();
    else
      fail ("POINTCLOUDDEF_REACTOR_EX.class_version [BL] set+1 %u != %u", pointclouddef_reactor_ex->class_version, class_version);
    pointclouddef_reactor_ex->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (pointclouddef_reactor_ex, "POINTCLOUDDEF_REACTOR_EX", "parent", &parent, NULL)
        && !memcmp (&parent, &pointclouddef_reactor_ex->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("POINTCLOUDDEF_REACTOR_EX.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("POINTCLOUDDEF_REACTOR_EX") || is_class_debugging ("POINTCLOUDDEF_REACTOR_EX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTCLOUDDEF_REACTOR_EX", failed);
      failed = 0;
    }
  return failed;
}
static int test_POINTPATH (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_POINTPATH *restrict pointpath = obj->tio.object->tio.POINTPATH;
  failed = 0;
  if (!obj_obj || !pointpath)
    {
      fail ("NULL POINTPATH");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (pointpath, "POINTPATH", "class_version", &class_version, NULL)
        && class_version == pointpath->class_version)
      pass ();
    else
      fail ("POINTPATH.class_version [BS] %hu != %hu", pointpath->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (pointpath, "POINTPATH", "class_version", &class_version, 0)
        && class_version == pointpath->class_version)
      pass ();
    else
      fail ("POINTPATH.class_version [BS] set+1 %hu != %hu", pointpath->class_version, class_version);
    pointpath->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (pointpath, "POINTPATH", "parent", &parent, NULL)
        && !memcmp (&parent, &pointpath->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("POINTPATH.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value (pointpath, "POINTPATH", "point", &point, NULL)
        && !memcmp (&point, &pointpath->point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("POINTPATH.point [3BD]");
  }
  if (failed && (is_class_unstable ("POINTPATH") || is_class_debugging ("POINTPATH")))
    {
      ok ("%s failed %d tests (TODO unstable)", "POINTPATH", failed);
      failed = 0;
    }
  return failed;
}
static int test_PROXY_OBJECT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PROXY_OBJECT *restrict proxy_object = obj->tio.object->tio.PROXY_OBJECT;
  failed = 0;
  if (!obj_obj || !proxy_object)
    {
      fail ("NULL PROXY_OBJECT");
      return 1;
    }
  {
    BITCODE_BL class_id;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "class_id", &class_id, NULL)
        && class_id == proxy_object->class_id)
      pass ();
    else
      fail ("PROXY_OBJECT.class_id [BL] %u != %u", proxy_object->class_id, class_id);
    class_id++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "class_id", &class_id, 0)
        && class_id == proxy_object->class_id)
      pass ();
    else
      fail ("PROXY_OBJECT.class_id [BL] set+1 %u != %u", proxy_object->class_id, class_id);
    proxy_object->class_id--;
  }
  {
    BITCODE_TF data;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "data", &data, NULL)
        && !memcmp (&data, &proxy_object->data, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("PROXY_OBJECT.data [TF]");
  }
  {
    BITCODE_BL data_numbits;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "data_numbits", &data_numbits, NULL)
        && data_numbits == proxy_object->data_numbits)
      pass ();
    else
      fail ("PROXY_OBJECT.data_numbits [BL] %u != %u", proxy_object->data_numbits, data_numbits);
    data_numbits++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "data_numbits", &data_numbits, 0)
        && data_numbits == proxy_object->data_numbits)
      pass ();
    else
      fail ("PROXY_OBJECT.data_numbits [BL] set+1 %u != %u", proxy_object->data_numbits, data_numbits);
    proxy_object->data_numbits--;
  }
  {
    BITCODE_BL data_size;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "data_size", &data_size, NULL)
        && data_size == proxy_object->data_size)
      pass ();
    else
      fail ("PROXY_OBJECT.data_size [BL] %u != %u", proxy_object->data_size, data_size);
    data_size++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "data_size", &data_size, 0)
        && data_size == proxy_object->data_size)
      pass ();
    else
      fail ("PROXY_OBJECT.data_size [BL] set+1 %u != %u", proxy_object->data_size, data_size);
    proxy_object->data_size--;
  }
  {
    BITCODE_B from_dxf;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "from_dxf", &from_dxf, NULL)
        && from_dxf == proxy_object->from_dxf)
      pass ();
    else
      fail ("PROXY_OBJECT.from_dxf [B] " FORMAT_B " != " FORMAT_B "", proxy_object->from_dxf, from_dxf);
    from_dxf++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "from_dxf", &from_dxf, 0)
        && from_dxf == proxy_object->from_dxf)
      pass ();
    else
      fail ("PROXY_OBJECT.from_dxf [B] set+1 " FORMAT_B " != " FORMAT_B "", proxy_object->from_dxf, from_dxf);
    proxy_object->from_dxf--;
  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "maint_version", &maint_version, NULL)
        && maint_version == proxy_object->maint_version)
      pass ();
    else
      fail ("PROXY_OBJECT.maint_version [BL] %u != %u", proxy_object->maint_version, maint_version);
    maint_version++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "maint_version", &maint_version, 0)
        && maint_version == proxy_object->maint_version)
      pass ();
    else
      fail ("PROXY_OBJECT.maint_version [BL] set+1 %u != %u", proxy_object->maint_version, maint_version);
    proxy_object->maint_version--;
  }
  {
    BITCODE_BL num_objids;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "num_objids", &num_objids, NULL)
        && num_objids == proxy_object->num_objids)
      pass ();
    else
      fail ("PROXY_OBJECT.num_objids [BL] %u != %u", proxy_object->num_objids, num_objids);
    num_objids++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "num_objids", &num_objids, 0)
        && num_objids == proxy_object->num_objids)
      pass ();
    else
      fail ("PROXY_OBJECT.num_objids [BL] set+1 %u != %u", proxy_object->num_objids, num_objids);
    proxy_object->num_objids--;
  }
  {
    BITCODE_H* objids;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "num_objids", &count, NULL)
        && dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "objids", &objids, NULL)
        && objids == proxy_object->objids)
      pass ();
    else
      fail ("PROXY_OBJECT.objids [H*] * %u num_objids", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "parent", &parent, NULL)
        && !memcmp (&parent, &proxy_object->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("PROXY_OBJECT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value (proxy_object, "PROXY_OBJECT", "version", &version, NULL)
        && version == proxy_object->version)
      pass ();
    else
      fail ("PROXY_OBJECT.version [BL] %u != %u", proxy_object->version, version);
    version++;
    if (dwg_dynapi_entity_set_value (proxy_object, "PROXY_OBJECT", "version", &version, 0)
        && version == proxy_object->version)
      pass ();
    else
      fail ("PROXY_OBJECT.version [BL] set+1 %u != %u", proxy_object->version, version);
    proxy_object->version--;
  }
  if (failed && (is_class_unstable ("PROXY_OBJECT") || is_class_debugging ("PROXY_OBJECT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PROXY_OBJECT", failed);
      failed = 0;
    }
  return failed;
}
static int test_RADIMLGOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RADIMLGOBJECTCONTEXTDATA *restrict radimlgobjectcontextdata = obj->tio.object->tio.RADIMLGOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !radimlgobjectcontextdata)
    {
      fail ("NULL RADIMLGOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == radimlgobjectcontextdata->class_version)
      pass ();
    else
      fail ("RADIMLGOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", radimlgobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == radimlgobjectcontextdata->class_version)
      pass ();
    else
      fail ("RADIMLGOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", radimlgobjectcontextdata->class_version, class_version);
    radimlgobjectcontextdata->class_version--;
  }
  {
    Dwg_OCD_Dimension dimension;
    if (dwg_dynapi_entity_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "dimension", &dimension, NULL)
        && !memcmp (&dimension, &radimlgobjectcontextdata->dimension, sizeof (Dwg_OCD_Dimension)))
        pass ();
    else
        fail ("RADIMLGOBJECTCONTEXTDATA.dimension [Dwg_OCD_Dimension]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == radimlgobjectcontextdata->is_default)
      pass ();
    else
      fail ("RADIMLGOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", radimlgobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == radimlgobjectcontextdata->is_default)
      pass ();
    else
      fail ("RADIMLGOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", radimlgobjectcontextdata->is_default, is_default);
    radimlgobjectcontextdata->is_default--;
  }
  {
    BITCODE_3BD jog_point;
    if (dwg_dynapi_entity_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "jog_point", &jog_point, NULL)
        && !memcmp (&jog_point, &radimlgobjectcontextdata->jog_point, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("RADIMLGOBJECTCONTEXTDATA.jog_point [3BD]");
  }
  {
    BITCODE_3BD ovr_center;
    if (dwg_dynapi_entity_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "ovr_center", &ovr_center, NULL)
        && !memcmp (&ovr_center, &radimlgobjectcontextdata->ovr_center, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("RADIMLGOBJECTCONTEXTDATA.ovr_center [3BD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &radimlgobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("RADIMLGOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (radimlgobjectcontextdata, "RADIMLGOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &radimlgobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("RADIMLGOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("RADIMLGOBJECTCONTEXTDATA") || is_class_debugging ("RADIMLGOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RADIMLGOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_RADIMOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RADIMOBJECTCONTEXTDATA *restrict radimobjectcontextdata = obj->tio.object->tio.RADIMOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !radimobjectcontextdata)
    {
      fail ("NULL RADIMOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (radimobjectcontextdata, "RADIMOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == radimobjectcontextdata->class_version)
      pass ();
    else
      fail ("RADIMOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", radimobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (radimobjectcontextdata, "RADIMOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == radimobjectcontextdata->class_version)
      pass ();
    else
      fail ("RADIMOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", radimobjectcontextdata->class_version, class_version);
    radimobjectcontextdata->class_version--;
  }
  {
    Dwg_OCD_Dimension dimension;
    if (dwg_dynapi_entity_value (radimobjectcontextdata, "RADIMOBJECTCONTEXTDATA", "dimension", &dimension, NULL)
        && !memcmp (&dimension, &radimobjectcontextdata->dimension, sizeof (Dwg_OCD_Dimension)))
        pass ();
    else
        fail ("RADIMOBJECTCONTEXTDATA.dimension [Dwg_OCD_Dimension]");
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value (radimobjectcontextdata, "RADIMOBJECTCONTEXTDATA", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp (&first_arc_pt, &radimobjectcontextdata->first_arc_pt, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("RADIMOBJECTCONTEXTDATA.first_arc_pt [3BD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (radimobjectcontextdata, "RADIMOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == radimobjectcontextdata->is_default)
      pass ();
    else
      fail ("RADIMOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", radimobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (radimobjectcontextdata, "RADIMOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == radimobjectcontextdata->is_default)
      pass ();
    else
      fail ("RADIMOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", radimobjectcontextdata->is_default, is_default);
    radimobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (radimobjectcontextdata, "RADIMOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &radimobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("RADIMOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (radimobjectcontextdata, "RADIMOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &radimobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("RADIMOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("RADIMOBJECTCONTEXTDATA") || is_class_debugging ("RADIMOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RADIMOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_RAPIDRTRENDERSETTINGS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RAPIDRTRENDERSETTINGS *restrict rapidrtrendersettings = obj->tio.object->tio.RAPIDRTRENDERSETTINGS;
  failed = 0;
  if (!obj_obj || !rapidrtrendersettings)
    {
      fail ("NULL RAPIDRTRENDERSETTINGS");
      return 1;
    }
  {
    BITCODE_B backfaces_enabled;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "backfaces_enabled", &backfaces_enabled, NULL)
        && backfaces_enabled == rapidrtrendersettings->backfaces_enabled)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.backfaces_enabled [B] " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->backfaces_enabled, backfaces_enabled);
    backfaces_enabled++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "backfaces_enabled", &backfaces_enabled, 0)
        && backfaces_enabled == rapidrtrendersettings->backfaces_enabled)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.backfaces_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->backfaces_enabled, backfaces_enabled);
    rapidrtrendersettings->backfaces_enabled--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "class_version", &class_version, NULL)
        && class_version == rapidrtrendersettings->class_version)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.class_version [BL] %u != %u", rapidrtrendersettings->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "class_version", &class_version, 0)
        && class_version == rapidrtrendersettings->class_version)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.class_version [BL] set+1 %u != %u", rapidrtrendersettings->class_version, class_version);
    rapidrtrendersettings->class_version--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)rapidrtrendersettings->description)
           : !rapidrtrendersettings->description)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.description [T] '%s' <> '%s'", description, rapidrtrendersettings->description);
  }
  {
    BITCODE_BL display_index;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "display_index", &display_index, NULL)
        && display_index == rapidrtrendersettings->display_index)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.display_index [BL] %u != %u", rapidrtrendersettings->display_index, display_index);
    display_index++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "display_index", &display_index, 0)
        && display_index == rapidrtrendersettings->display_index)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.display_index [BL] set+1 %u != %u", rapidrtrendersettings->display_index, display_index);
    rapidrtrendersettings->display_index--;
  }
  {
    BITCODE_B environ_image_enabled;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "environ_image_enabled", &environ_image_enabled, NULL)
        && environ_image_enabled == rapidrtrendersettings->environ_image_enabled)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.environ_image_enabled [B] " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->environ_image_enabled, environ_image_enabled);
    environ_image_enabled++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "environ_image_enabled", &environ_image_enabled, 0)
        && environ_image_enabled == rapidrtrendersettings->environ_image_enabled)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.environ_image_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->environ_image_enabled, environ_image_enabled);
    rapidrtrendersettings->environ_image_enabled--;
  }
  {
    BITCODE_T environ_image_filename;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "environ_image_filename", &environ_image_filename, NULL)
        && environ_image_filename
           ? strEQ ((char *)environ_image_filename, (char *)rapidrtrendersettings->environ_image_filename)
           : !rapidrtrendersettings->environ_image_filename)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.environ_image_filename [T] '%s' <> '%s'", environ_image_filename, rapidrtrendersettings->environ_image_filename);
  }
  {
    BITCODE_BD filter_height;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "filter_height", &filter_height, NULL)
        && filter_height == rapidrtrendersettings->filter_height)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.filter_height [BD] %g != %g", rapidrtrendersettings->filter_height, filter_height);
    filter_height++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "filter_height", &filter_height, 0)
        && filter_height == rapidrtrendersettings->filter_height)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.filter_height [BD] set+1 %g != %g", rapidrtrendersettings->filter_height, filter_height);
    rapidrtrendersettings->filter_height--;
  }
  {
    BITCODE_BL filter_type;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "filter_type", &filter_type, NULL)
        && filter_type == rapidrtrendersettings->filter_type)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.filter_type [BL] %u != %u", rapidrtrendersettings->filter_type, filter_type);
    filter_type++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "filter_type", &filter_type, 0)
        && filter_type == rapidrtrendersettings->filter_type)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.filter_type [BL] set+1 %u != %u", rapidrtrendersettings->filter_type, filter_type);
    rapidrtrendersettings->filter_type--;
  }
  {
    BITCODE_BD filter_width;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "filter_width", &filter_width, NULL)
        && filter_width == rapidrtrendersettings->filter_width)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.filter_width [BD] %g != %g", rapidrtrendersettings->filter_width, filter_width);
    filter_width++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "filter_width", &filter_width, 0)
        && filter_width == rapidrtrendersettings->filter_width)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.filter_width [BD] set+1 %g != %g", rapidrtrendersettings->filter_width, filter_width);
    rapidrtrendersettings->filter_width--;
  }
  {
    BITCODE_B fog_background_enabled;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "fog_background_enabled", &fog_background_enabled, NULL)
        && fog_background_enabled == rapidrtrendersettings->fog_background_enabled)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.fog_background_enabled [B] " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->fog_background_enabled, fog_background_enabled);
    fog_background_enabled++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "fog_background_enabled", &fog_background_enabled, 0)
        && fog_background_enabled == rapidrtrendersettings->fog_background_enabled)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.fog_background_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->fog_background_enabled, fog_background_enabled);
    rapidrtrendersettings->fog_background_enabled--;
  }
  {
    BITCODE_B fog_enabled;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "fog_enabled", &fog_enabled, NULL)
        && fog_enabled == rapidrtrendersettings->fog_enabled)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.fog_enabled [B] " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->fog_enabled, fog_enabled);
    fog_enabled++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "fog_enabled", &fog_enabled, 0)
        && fog_enabled == rapidrtrendersettings->fog_enabled)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.fog_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->fog_enabled, fog_enabled);
    rapidrtrendersettings->fog_enabled--;
  }
  {
    BITCODE_B has_predefined;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "has_predefined", &has_predefined, NULL)
        && has_predefined == rapidrtrendersettings->has_predefined)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.has_predefined [B] " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->has_predefined, has_predefined);
    has_predefined++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "has_predefined", &has_predefined, 0)
        && has_predefined == rapidrtrendersettings->has_predefined)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.has_predefined [B] set+1 " FORMAT_B " != " FORMAT_B "", rapidrtrendersettings->has_predefined, has_predefined);
    rapidrtrendersettings->has_predefined--;
  }
  {
    BITCODE_BL lighting_model;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "lighting_model", &lighting_model, NULL)
        && lighting_model == rapidrtrendersettings->lighting_model)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.lighting_model [BL] %u != %u", rapidrtrendersettings->lighting_model, lighting_model);
    lighting_model++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "lighting_model", &lighting_model, 0)
        && lighting_model == rapidrtrendersettings->lighting_model)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.lighting_model [BL] set+1 %u != %u", rapidrtrendersettings->lighting_model, lighting_model);
    rapidrtrendersettings->lighting_model--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)rapidrtrendersettings->name)
           : !rapidrtrendersettings->name)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.name [T] '%s' <> '%s'", name, rapidrtrendersettings->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "parent", &parent, NULL)
        && !memcmp (&parent, &rapidrtrendersettings->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("RAPIDRTRENDERSETTINGS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL rapidrt_version;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "rapidrt_version", &rapidrt_version, NULL)
        && rapidrt_version == rapidrtrendersettings->rapidrt_version)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.rapidrt_version [BL] %u != %u", rapidrtrendersettings->rapidrt_version, rapidrt_version);
    rapidrt_version++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "rapidrt_version", &rapidrt_version, 0)
        && rapidrt_version == rapidrtrendersettings->rapidrt_version)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.rapidrt_version [BL] set+1 %u != %u", rapidrtrendersettings->rapidrt_version, rapidrt_version);
    rapidrtrendersettings->rapidrt_version--;
  }
  {
    BITCODE_BL render_level;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "render_level", &render_level, NULL)
        && render_level == rapidrtrendersettings->render_level)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.render_level [BL] %u != %u", rapidrtrendersettings->render_level, render_level);
    render_level++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "render_level", &render_level, 0)
        && render_level == rapidrtrendersettings->render_level)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.render_level [BL] set+1 %u != %u", rapidrtrendersettings->render_level, render_level);
    rapidrtrendersettings->render_level--;
  }
  {
    BITCODE_BL render_target;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "render_target", &render_target, NULL)
        && render_target == rapidrtrendersettings->render_target)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.render_target [BL] %u != %u", rapidrtrendersettings->render_target, render_target);
    render_target++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "render_target", &render_target, 0)
        && render_target == rapidrtrendersettings->render_target)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.render_target [BL] set+1 %u != %u", rapidrtrendersettings->render_target, render_target);
    rapidrtrendersettings->render_target--;
  }
  {
    BITCODE_BL render_time;
    if (dwg_dynapi_entity_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "render_time", &render_time, NULL)
        && render_time == rapidrtrendersettings->render_time)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.render_time [BL] %u != %u", rapidrtrendersettings->render_time, render_time);
    render_time++;
    if (dwg_dynapi_entity_set_value (rapidrtrendersettings, "RAPIDRTRENDERSETTINGS", "render_time", &render_time, 0)
        && render_time == rapidrtrendersettings->render_time)
      pass ();
    else
      fail ("RAPIDRTRENDERSETTINGS.render_time [BL] set+1 %u != %u", rapidrtrendersettings->render_time, render_time);
    rapidrtrendersettings->render_time--;
  }
  if (failed && (is_class_unstable ("RAPIDRTRENDERSETTINGS") || is_class_debugging ("RAPIDRTRENDERSETTINGS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RAPIDRTRENDERSETTINGS", failed);
      failed = 0;
    }
  return failed;
}
static int test_RASTERVARIABLES (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RASTERVARIABLES *restrict rastervariables = obj->tio.object->tio.RASTERVARIABLES;
  failed = 0;
  if (!obj_obj || !rastervariables)
    {
      fail ("NULL RASTERVARIABLES");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "class_version", &class_version, NULL)
        && class_version == rastervariables->class_version)
      pass ();
    else
      fail ("RASTERVARIABLES.class_version [BL] %u != %u", rastervariables->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (rastervariables, "RASTERVARIABLES", "class_version", &class_version, 0)
        && class_version == rastervariables->class_version)
      pass ();
    else
      fail ("RASTERVARIABLES.class_version [BL] set+1 %u != %u", rastervariables->class_version, class_version);
    rastervariables->class_version--;
  }
  {
    BITCODE_BS image_frame;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "image_frame", &image_frame, NULL)
        && image_frame == rastervariables->image_frame)
      pass ();
    else
      fail ("RASTERVARIABLES.image_frame [BS] %hu != %hu", rastervariables->image_frame, image_frame);
    image_frame++;
    if (dwg_dynapi_entity_set_value (rastervariables, "RASTERVARIABLES", "image_frame", &image_frame, 0)
        && image_frame == rastervariables->image_frame)
      pass ();
    else
      fail ("RASTERVARIABLES.image_frame [BS] set+1 %hu != %hu", rastervariables->image_frame, image_frame);
    rastervariables->image_frame--;
  }
  {
    BITCODE_BS image_quality;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "image_quality", &image_quality, NULL)
        && image_quality == rastervariables->image_quality)
      pass ();
    else
      fail ("RASTERVARIABLES.image_quality [BS] %hu != %hu", rastervariables->image_quality, image_quality);
    image_quality++;
    if (dwg_dynapi_entity_set_value (rastervariables, "RASTERVARIABLES", "image_quality", &image_quality, 0)
        && image_quality == rastervariables->image_quality)
      pass ();
    else
      fail ("RASTERVARIABLES.image_quality [BS] set+1 %hu != %hu", rastervariables->image_quality, image_quality);
    rastervariables->image_quality--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "parent", &parent, NULL)
        && !memcmp (&parent, &rastervariables->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("RASTERVARIABLES.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS units;
    if (dwg_dynapi_entity_value (rastervariables, "RASTERVARIABLES", "units", &units, NULL)
        && units == rastervariables->units)
      pass ();
    else
      fail ("RASTERVARIABLES.units [BS] %hu != %hu", rastervariables->units, units);
    units++;
    if (dwg_dynapi_entity_set_value (rastervariables, "RASTERVARIABLES", "units", &units, 0)
        && units == rastervariables->units)
      pass ();
    else
      fail ("RASTERVARIABLES.units [BS] set+1 %hu != %hu", rastervariables->units, units);
    rastervariables->units--;
  }
  if (failed && (is_class_unstable ("RASTERVARIABLES") || is_class_debugging ("RASTERVARIABLES")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RASTERVARIABLES", failed);
      failed = 0;
    }
  return failed;
}
static int test_RENDERENTRY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RENDERENTRY *restrict renderentry = obj->tio.object->tio.RENDERENTRY;
  failed = 0;
  if (!obj_obj || !renderentry)
    {
      fail ("NULL RENDERENTRY");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "class_version", &class_version, NULL)
        && class_version == renderentry->class_version)
      pass ();
    else
      fail ("RENDERENTRY.class_version [BL] %u != %u", renderentry->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "class_version", &class_version, 0)
        && class_version == renderentry->class_version)
      pass ();
    else
      fail ("RENDERENTRY.class_version [BL] set+1 %u != %u", renderentry->class_version, class_version);
    renderentry->class_version--;
  }
  {
    BITCODE_BL dimension_x;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "dimension_x", &dimension_x, NULL)
        && dimension_x == renderentry->dimension_x)
      pass ();
    else
      fail ("RENDERENTRY.dimension_x [BL] %u != %u", renderentry->dimension_x, dimension_x);
    dimension_x++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "dimension_x", &dimension_x, 0)
        && dimension_x == renderentry->dimension_x)
      pass ();
    else
      fail ("RENDERENTRY.dimension_x [BL] set+1 %u != %u", renderentry->dimension_x, dimension_x);
    renderentry->dimension_x--;
  }
  {
    BITCODE_BL dimension_y;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "dimension_y", &dimension_y, NULL)
        && dimension_y == renderentry->dimension_y)
      pass ();
    else
      fail ("RENDERENTRY.dimension_y [BL] %u != %u", renderentry->dimension_y, dimension_y);
    dimension_y++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "dimension_y", &dimension_y, 0)
        && dimension_y == renderentry->dimension_y)
      pass ();
    else
      fail ("RENDERENTRY.dimension_y [BL] set+1 %u != %u", renderentry->dimension_y, dimension_y);
    renderentry->dimension_y--;
  }
  {
    BITCODE_BL display_index;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "display_index", &display_index, NULL)
        && display_index == renderentry->display_index)
      pass ();
    else
      fail ("RENDERENTRY.display_index [BL] %u != %u", renderentry->display_index, display_index);
    display_index++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "display_index", &display_index, 0)
        && display_index == renderentry->display_index)
      pass ();
    else
      fail ("RENDERENTRY.display_index [BL] set+1 %u != %u", renderentry->display_index, display_index);
    renderentry->display_index--;
  }
  {
    BITCODE_T image_file_name;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "image_file_name", &image_file_name, NULL)
        && image_file_name
           ? strEQ ((char *)image_file_name, (char *)renderentry->image_file_name)
           : !renderentry->image_file_name)
      pass ();
    else
      fail ("RENDERENTRY.image_file_name [T] '%s' <> '%s'", image_file_name, renderentry->image_file_name);
  }
  {
    BITCODE_BL light_count;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "light_count", &light_count, NULL)
        && light_count == renderentry->light_count)
      pass ();
    else
      fail ("RENDERENTRY.light_count [BL] %u != %u", renderentry->light_count, light_count);
    light_count++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "light_count", &light_count, 0)
        && light_count == renderentry->light_count)
      pass ();
    else
      fail ("RENDERENTRY.light_count [BL] set+1 %u != %u", renderentry->light_count, light_count);
    renderentry->light_count--;
  }
  {
    BITCODE_BL material_count;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "material_count", &material_count, NULL)
        && material_count == renderentry->material_count)
      pass ();
    else
      fail ("RENDERENTRY.material_count [BL] %u != %u", renderentry->material_count, material_count);
    material_count++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "material_count", &material_count, 0)
        && material_count == renderentry->material_count)
      pass ();
    else
      fail ("RENDERENTRY.material_count [BL] set+1 %u != %u", renderentry->material_count, material_count);
    renderentry->material_count--;
  }
  {
    BITCODE_BL memory_amount;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "memory_amount", &memory_amount, NULL)
        && memory_amount == renderentry->memory_amount)
      pass ();
    else
      fail ("RENDERENTRY.memory_amount [BL] %u != %u", renderentry->memory_amount, memory_amount);
    memory_amount++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "memory_amount", &memory_amount, 0)
        && memory_amount == renderentry->memory_amount)
      pass ();
    else
      fail ("RENDERENTRY.memory_amount [BL] set+1 %u != %u", renderentry->memory_amount, memory_amount);
    renderentry->memory_amount--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "parent", &parent, NULL)
        && !memcmp (&parent, &renderentry->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("RENDERENTRY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T preset_name;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "preset_name", &preset_name, NULL)
        && preset_name
           ? strEQ ((char *)preset_name, (char *)renderentry->preset_name)
           : !renderentry->preset_name)
      pass ();
    else
      fail ("RENDERENTRY.preset_name [T] '%s' <> '%s'", preset_name, renderentry->preset_name);
  }
  {
    BITCODE_BD render_time;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "render_time", &render_time, NULL)
        && render_time == renderentry->render_time)
      pass ();
    else
      fail ("RENDERENTRY.render_time [BD] %g != %g", renderentry->render_time, render_time);
    render_time++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "render_time", &render_time, 0)
        && render_time == renderentry->render_time)
      pass ();
    else
      fail ("RENDERENTRY.render_time [BD] set+1 %g != %g", renderentry->render_time, render_time);
    renderentry->render_time--;
  }
  {
    BITCODE_BS start_day;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "start_day", &start_day, NULL)
        && start_day == renderentry->start_day)
      pass ();
    else
      fail ("RENDERENTRY.start_day [BS] %hu != %hu", renderentry->start_day, start_day);
    start_day++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "start_day", &start_day, 0)
        && start_day == renderentry->start_day)
      pass ();
    else
      fail ("RENDERENTRY.start_day [BS] set+1 %hu != %hu", renderentry->start_day, start_day);
    renderentry->start_day--;
  }
  {
    BITCODE_BS start_minute;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "start_minute", &start_minute, NULL)
        && start_minute == renderentry->start_minute)
      pass ();
    else
      fail ("RENDERENTRY.start_minute [BS] %hu != %hu", renderentry->start_minute, start_minute);
    start_minute++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "start_minute", &start_minute, 0)
        && start_minute == renderentry->start_minute)
      pass ();
    else
      fail ("RENDERENTRY.start_minute [BS] set+1 %hu != %hu", renderentry->start_minute, start_minute);
    renderentry->start_minute--;
  }
  {
    BITCODE_BS start_month;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "start_month", &start_month, NULL)
        && start_month == renderentry->start_month)
      pass ();
    else
      fail ("RENDERENTRY.start_month [BS] %hu != %hu", renderentry->start_month, start_month);
    start_month++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "start_month", &start_month, 0)
        && start_month == renderentry->start_month)
      pass ();
    else
      fail ("RENDERENTRY.start_month [BS] set+1 %hu != %hu", renderentry->start_month, start_month);
    renderentry->start_month--;
  }
  {
    BITCODE_BS start_msec;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "start_msec", &start_msec, NULL)
        && start_msec == renderentry->start_msec)
      pass ();
    else
      fail ("RENDERENTRY.start_msec [BS] %hu != %hu", renderentry->start_msec, start_msec);
    start_msec++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "start_msec", &start_msec, 0)
        && start_msec == renderentry->start_msec)
      pass ();
    else
      fail ("RENDERENTRY.start_msec [BS] set+1 %hu != %hu", renderentry->start_msec, start_msec);
    renderentry->start_msec--;
  }
  {
    BITCODE_BS start_second;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "start_second", &start_second, NULL)
        && start_second == renderentry->start_second)
      pass ();
    else
      fail ("RENDERENTRY.start_second [BS] %hu != %hu", renderentry->start_second, start_second);
    start_second++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "start_second", &start_second, 0)
        && start_second == renderentry->start_second)
      pass ();
    else
      fail ("RENDERENTRY.start_second [BS] set+1 %hu != %hu", renderentry->start_second, start_second);
    renderentry->start_second--;
  }
  {
    BITCODE_BS start_year;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "start_year", &start_year, NULL)
        && start_year == renderentry->start_year)
      pass ();
    else
      fail ("RENDERENTRY.start_year [BS] %hu != %hu", renderentry->start_year, start_year);
    start_year++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "start_year", &start_year, 0)
        && start_year == renderentry->start_year)
      pass ();
    else
      fail ("RENDERENTRY.start_year [BS] set+1 %hu != %hu", renderentry->start_year, start_year);
    renderentry->start_year--;
  }
  {
    BITCODE_BL triangle_count;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "triangle_count", &triangle_count, NULL)
        && triangle_count == renderentry->triangle_count)
      pass ();
    else
      fail ("RENDERENTRY.triangle_count [BL] %u != %u", renderentry->triangle_count, triangle_count);
    triangle_count++;
    if (dwg_dynapi_entity_set_value (renderentry, "RENDERENTRY", "triangle_count", &triangle_count, 0)
        && triangle_count == renderentry->triangle_count)
      pass ();
    else
      fail ("RENDERENTRY.triangle_count [BL] set+1 %u != %u", renderentry->triangle_count, triangle_count);
    renderentry->triangle_count--;
  }
  {
    BITCODE_T view_name;
    if (dwg_dynapi_entity_value (renderentry, "RENDERENTRY", "view_name", &view_name, NULL)
        && view_name
           ? strEQ ((char *)view_name, (char *)renderentry->view_name)
           : !renderentry->view_name)
      pass ();
    else
      fail ("RENDERENTRY.view_name [T] '%s' <> '%s'", view_name, renderentry->view_name);
  }
  if (failed && (is_class_unstable ("RENDERENTRY") || is_class_debugging ("RENDERENTRY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RENDERENTRY", failed);
      failed = 0;
    }
  return failed;
}
static int test_RENDERENVIRONMENT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RENDERENVIRONMENT *restrict renderenvironment = obj->tio.object->tio.RENDERENVIRONMENT;
  failed = 0;
  if (!obj_obj || !renderenvironment)
    {
      fail ("NULL RENDERENVIRONMENT");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "class_version", &class_version, NULL)
        && class_version == renderenvironment->class_version)
      pass ();
    else
      fail ("RENDERENVIRONMENT.class_version [BL] %u != %u", renderenvironment->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "class_version", &class_version, 0)
        && class_version == renderenvironment->class_version)
      pass ();
    else
      fail ("RENDERENVIRONMENT.class_version [BL] set+1 %u != %u", renderenvironment->class_version, class_version);
    renderenvironment->class_version--;
  }
  {
    BITCODE_B environ_image_enabled;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "environ_image_enabled", &environ_image_enabled, NULL)
        && environ_image_enabled == renderenvironment->environ_image_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.environ_image_enabled [B] " FORMAT_B " != " FORMAT_B "", renderenvironment->environ_image_enabled, environ_image_enabled);
    environ_image_enabled++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "environ_image_enabled", &environ_image_enabled, 0)
        && environ_image_enabled == renderenvironment->environ_image_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.environ_image_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", renderenvironment->environ_image_enabled, environ_image_enabled);
    renderenvironment->environ_image_enabled--;
  }
  {
    BITCODE_T environ_image_filename;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "environ_image_filename", &environ_image_filename, NULL)
        && environ_image_filename
           ? strEQ ((char *)environ_image_filename, (char *)renderenvironment->environ_image_filename)
           : !renderenvironment->environ_image_filename)
      pass ();
    else
      fail ("RENDERENVIRONMENT.environ_image_filename [T] '%s' <> '%s'", environ_image_filename, renderenvironment->environ_image_filename);
  }
  {
    BITCODE_B fog_background_enabled;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_background_enabled", &fog_background_enabled, NULL)
        && fog_background_enabled == renderenvironment->fog_background_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_background_enabled [B] " FORMAT_B " != " FORMAT_B "", renderenvironment->fog_background_enabled, fog_background_enabled);
    fog_background_enabled++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_background_enabled", &fog_background_enabled, 0)
        && fog_background_enabled == renderenvironment->fog_background_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_background_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", renderenvironment->fog_background_enabled, fog_background_enabled);
    renderenvironment->fog_background_enabled--;
  }
  {
    BITCODE_CMC fog_color;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_color", &fog_color, NULL)
        && !memcmp (&fog_color, &renderenvironment->fog_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("RENDERENVIRONMENT.fog_color [CMC]");
  }
  {
    BITCODE_BD fog_density_far;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_density_far", &fog_density_far, NULL)
        && fog_density_far == renderenvironment->fog_density_far)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_density_far [BD] %g != %g", renderenvironment->fog_density_far, fog_density_far);
    fog_density_far++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_density_far", &fog_density_far, 0)
        && fog_density_far == renderenvironment->fog_density_far)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_density_far [BD] set+1 %g != %g", renderenvironment->fog_density_far, fog_density_far);
    renderenvironment->fog_density_far--;
  }
  {
    BITCODE_BD fog_density_near;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_density_near", &fog_density_near, NULL)
        && fog_density_near == renderenvironment->fog_density_near)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_density_near [BD] %g != %g", renderenvironment->fog_density_near, fog_density_near);
    fog_density_near++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_density_near", &fog_density_near, 0)
        && fog_density_near == renderenvironment->fog_density_near)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_density_near [BD] set+1 %g != %g", renderenvironment->fog_density_near, fog_density_near);
    renderenvironment->fog_density_near--;
  }
  {
    BITCODE_BD fog_distance_far;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_distance_far", &fog_distance_far, NULL)
        && fog_distance_far == renderenvironment->fog_distance_far)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_distance_far [BD] %g != %g", renderenvironment->fog_distance_far, fog_distance_far);
    fog_distance_far++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_distance_far", &fog_distance_far, 0)
        && fog_distance_far == renderenvironment->fog_distance_far)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_distance_far [BD] set+1 %g != %g", renderenvironment->fog_distance_far, fog_distance_far);
    renderenvironment->fog_distance_far--;
  }
  {
    BITCODE_BD fog_distance_near;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_distance_near", &fog_distance_near, NULL)
        && fog_distance_near == renderenvironment->fog_distance_near)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_distance_near [BD] %g != %g", renderenvironment->fog_distance_near, fog_distance_near);
    fog_distance_near++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_distance_near", &fog_distance_near, 0)
        && fog_distance_near == renderenvironment->fog_distance_near)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_distance_near [BD] set+1 %g != %g", renderenvironment->fog_distance_near, fog_distance_near);
    renderenvironment->fog_distance_near--;
  }
  {
    BITCODE_B fog_enabled;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "fog_enabled", &fog_enabled, NULL)
        && fog_enabled == renderenvironment->fog_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_enabled [B] " FORMAT_B " != " FORMAT_B "", renderenvironment->fog_enabled, fog_enabled);
    fog_enabled++;
    if (dwg_dynapi_entity_set_value (renderenvironment, "RENDERENVIRONMENT", "fog_enabled", &fog_enabled, 0)
        && fog_enabled == renderenvironment->fog_enabled)
      pass ();
    else
      fail ("RENDERENVIRONMENT.fog_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", renderenvironment->fog_enabled, fog_enabled);
    renderenvironment->fog_enabled--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (renderenvironment, "RENDERENVIRONMENT", "parent", &parent, NULL)
        && !memcmp (&parent, &renderenvironment->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("RENDERENVIRONMENT.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("RENDERENVIRONMENT") || is_class_debugging ("RENDERENVIRONMENT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RENDERENVIRONMENT", failed);
      failed = 0;
    }
  return failed;
}
static int test_RENDERGLOBAL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RENDERGLOBAL *restrict renderglobal = obj->tio.object->tio.RENDERGLOBAL;
  failed = 0;
  if (!obj_obj || !renderglobal)
    {
      fail ("NULL RENDERGLOBAL");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "class_version", &class_version, NULL)
        && class_version == renderglobal->class_version)
      pass ();
    else
      fail ("RENDERGLOBAL.class_version [BL] %u != %u", renderglobal->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "class_version", &class_version, 0)
        && class_version == renderglobal->class_version)
      pass ();
    else
      fail ("RENDERGLOBAL.class_version [BL] set+1 %u != %u", renderglobal->class_version, class_version);
    renderglobal->class_version--;
  }
  {
    BITCODE_BL destination;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "destination", &destination, NULL)
        && destination == renderglobal->destination)
      pass ();
    else
      fail ("RENDERGLOBAL.destination [BL] %u != %u", renderglobal->destination, destination);
    destination++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "destination", &destination, 0)
        && destination == renderglobal->destination)
      pass ();
    else
      fail ("RENDERGLOBAL.destination [BL] set+1 %u != %u", renderglobal->destination, destination);
    renderglobal->destination--;
  }
  {
    BITCODE_B highlevel_info;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "highlevel_info", &highlevel_info, NULL)
        && highlevel_info == renderglobal->highlevel_info)
      pass ();
    else
      fail ("RENDERGLOBAL.highlevel_info [B] " FORMAT_B " != " FORMAT_B "", renderglobal->highlevel_info, highlevel_info);
    highlevel_info++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "highlevel_info", &highlevel_info, 0)
        && highlevel_info == renderglobal->highlevel_info)
      pass ();
    else
      fail ("RENDERGLOBAL.highlevel_info [B] set+1 " FORMAT_B " != " FORMAT_B "", renderglobal->highlevel_info, highlevel_info);
    renderglobal->highlevel_info--;
  }
  {
    BITCODE_BL image_height;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "image_height", &image_height, NULL)
        && image_height == renderglobal->image_height)
      pass ();
    else
      fail ("RENDERGLOBAL.image_height [BL] %u != %u", renderglobal->image_height, image_height);
    image_height++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "image_height", &image_height, 0)
        && image_height == renderglobal->image_height)
      pass ();
    else
      fail ("RENDERGLOBAL.image_height [BL] set+1 %u != %u", renderglobal->image_height, image_height);
    renderglobal->image_height--;
  }
  {
    BITCODE_BL image_width;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "image_width", &image_width, NULL)
        && image_width == renderglobal->image_width)
      pass ();
    else
      fail ("RENDERGLOBAL.image_width [BL] %u != %u", renderglobal->image_width, image_width);
    image_width++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "image_width", &image_width, 0)
        && image_width == renderglobal->image_width)
      pass ();
    else
      fail ("RENDERGLOBAL.image_width [BL] set+1 %u != %u", renderglobal->image_width, image_width);
    renderglobal->image_width--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "parent", &parent, NULL)
        && !memcmp (&parent, &renderglobal->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("RENDERGLOBAL.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B predef_presets_first;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "predef_presets_first", &predef_presets_first, NULL)
        && predef_presets_first == renderglobal->predef_presets_first)
      pass ();
    else
      fail ("RENDERGLOBAL.predef_presets_first [B] " FORMAT_B " != " FORMAT_B "", renderglobal->predef_presets_first, predef_presets_first);
    predef_presets_first++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "predef_presets_first", &predef_presets_first, 0)
        && predef_presets_first == renderglobal->predef_presets_first)
      pass ();
    else
      fail ("RENDERGLOBAL.predef_presets_first [B] set+1 " FORMAT_B " != " FORMAT_B "", renderglobal->predef_presets_first, predef_presets_first);
    renderglobal->predef_presets_first--;
  }
  {
    BITCODE_BL procedure;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "procedure", &procedure, NULL)
        && procedure == renderglobal->procedure)
      pass ();
    else
      fail ("RENDERGLOBAL.procedure [BL] %u != %u", renderglobal->procedure, procedure);
    procedure++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "procedure", &procedure, 0)
        && procedure == renderglobal->procedure)
      pass ();
    else
      fail ("RENDERGLOBAL.procedure [BL] set+1 %u != %u", renderglobal->procedure, procedure);
    renderglobal->procedure--;
  }
  {
    BITCODE_B save_enabled;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "save_enabled", &save_enabled, NULL)
        && save_enabled == renderglobal->save_enabled)
      pass ();
    else
      fail ("RENDERGLOBAL.save_enabled [B] " FORMAT_B " != " FORMAT_B "", renderglobal->save_enabled, save_enabled);
    save_enabled++;
    if (dwg_dynapi_entity_set_value (renderglobal, "RENDERGLOBAL", "save_enabled", &save_enabled, 0)
        && save_enabled == renderglobal->save_enabled)
      pass ();
    else
      fail ("RENDERGLOBAL.save_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", renderglobal->save_enabled, save_enabled);
    renderglobal->save_enabled--;
  }
  {
    BITCODE_T save_filename;
    if (dwg_dynapi_entity_value (renderglobal, "RENDERGLOBAL", "save_filename", &save_filename, NULL)
        && save_filename
           ? strEQ ((char *)save_filename, (char *)renderglobal->save_filename)
           : !renderglobal->save_filename)
      pass ();
    else
      fail ("RENDERGLOBAL.save_filename [T] '%s' <> '%s'", save_filename, renderglobal->save_filename);
  }
  if (failed && (is_class_unstable ("RENDERGLOBAL") || is_class_debugging ("RENDERGLOBAL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RENDERGLOBAL", failed);
      failed = 0;
    }
  return failed;
}
static int test_RENDERSETTINGS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_RENDERSETTINGS *restrict rendersettings = obj->tio.object->tio.RENDERSETTINGS;
  failed = 0;
  if (!obj_obj || !rendersettings)
    {
      fail ("NULL RENDERSETTINGS");
      return 1;
    }
  {
    BITCODE_B backfaces_enabled;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "backfaces_enabled", &backfaces_enabled, NULL)
        && backfaces_enabled == rendersettings->backfaces_enabled)
      pass ();
    else
      fail ("RENDERSETTINGS.backfaces_enabled [B] " FORMAT_B " != " FORMAT_B "", rendersettings->backfaces_enabled, backfaces_enabled);
    backfaces_enabled++;
    if (dwg_dynapi_entity_set_value (rendersettings, "RENDERSETTINGS", "backfaces_enabled", &backfaces_enabled, 0)
        && backfaces_enabled == rendersettings->backfaces_enabled)
      pass ();
    else
      fail ("RENDERSETTINGS.backfaces_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", rendersettings->backfaces_enabled, backfaces_enabled);
    rendersettings->backfaces_enabled--;
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "class_version", &class_version, NULL)
        && class_version == rendersettings->class_version)
      pass ();
    else
      fail ("RENDERSETTINGS.class_version [BL] %u != %u", rendersettings->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (rendersettings, "RENDERSETTINGS", "class_version", &class_version, 0)
        && class_version == rendersettings->class_version)
      pass ();
    else
      fail ("RENDERSETTINGS.class_version [BL] set+1 %u != %u", rendersettings->class_version, class_version);
    rendersettings->class_version--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)rendersettings->description)
           : !rendersettings->description)
      pass ();
    else
      fail ("RENDERSETTINGS.description [T] '%s' <> '%s'", description, rendersettings->description);
  }
  {
    BITCODE_BL display_index;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "display_index", &display_index, NULL)
        && display_index == rendersettings->display_index)
      pass ();
    else
      fail ("RENDERSETTINGS.display_index [BL] %u != %u", rendersettings->display_index, display_index);
    display_index++;
    if (dwg_dynapi_entity_set_value (rendersettings, "RENDERSETTINGS", "display_index", &display_index, 0)
        && display_index == rendersettings->display_index)
      pass ();
    else
      fail ("RENDERSETTINGS.display_index [BL] set+1 %u != %u", rendersettings->display_index, display_index);
    rendersettings->display_index--;
  }
  {
    BITCODE_B environ_image_enabled;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "environ_image_enabled", &environ_image_enabled, NULL)
        && environ_image_enabled == rendersettings->environ_image_enabled)
      pass ();
    else
      fail ("RENDERSETTINGS.environ_image_enabled [B] " FORMAT_B " != " FORMAT_B "", rendersettings->environ_image_enabled, environ_image_enabled);
    environ_image_enabled++;
    if (dwg_dynapi_entity_set_value (rendersettings, "RENDERSETTINGS", "environ_image_enabled", &environ_image_enabled, 0)
        && environ_image_enabled == rendersettings->environ_image_enabled)
      pass ();
    else
      fail ("RENDERSETTINGS.environ_image_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", rendersettings->environ_image_enabled, environ_image_enabled);
    rendersettings->environ_image_enabled--;
  }
  {
    BITCODE_T environ_image_filename;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "environ_image_filename", &environ_image_filename, NULL)
        && environ_image_filename
           ? strEQ ((char *)environ_image_filename, (char *)rendersettings->environ_image_filename)
           : !rendersettings->environ_image_filename)
      pass ();
    else
      fail ("RENDERSETTINGS.environ_image_filename [T] '%s' <> '%s'", environ_image_filename, rendersettings->environ_image_filename);
  }
  {
    BITCODE_B fog_background_enabled;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "fog_background_enabled", &fog_background_enabled, NULL)
        && fog_background_enabled == rendersettings->fog_background_enabled)
      pass ();
    else
      fail ("RENDERSETTINGS.fog_background_enabled [B] " FORMAT_B " != " FORMAT_B "", rendersettings->fog_background_enabled, fog_background_enabled);
    fog_background_enabled++;
    if (dwg_dynapi_entity_set_value (rendersettings, "RENDERSETTINGS", "fog_background_enabled", &fog_background_enabled, 0)
        && fog_background_enabled == rendersettings->fog_background_enabled)
      pass ();
    else
      fail ("RENDERSETTINGS.fog_background_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", rendersettings->fog_background_enabled, fog_background_enabled);
    rendersettings->fog_background_enabled--;
  }
  {
    BITCODE_B fog_enabled;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "fog_enabled", &fog_enabled, NULL)
        && fog_enabled == rendersettings->fog_enabled)
      pass ();
    else
      fail ("RENDERSETTINGS.fog_enabled [B] " FORMAT_B " != " FORMAT_B "", rendersettings->fog_enabled, fog_enabled);
    fog_enabled++;
    if (dwg_dynapi_entity_set_value (rendersettings, "RENDERSETTINGS", "fog_enabled", &fog_enabled, 0)
        && fog_enabled == rendersettings->fog_enabled)
      pass ();
    else
      fail ("RENDERSETTINGS.fog_enabled [B] set+1 " FORMAT_B " != " FORMAT_B "", rendersettings->fog_enabled, fog_enabled);
    rendersettings->fog_enabled--;
  }
  {
    BITCODE_B has_predefined;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "has_predefined", &has_predefined, NULL)
        && has_predefined == rendersettings->has_predefined)
      pass ();
    else
      fail ("RENDERSETTINGS.has_predefined [B] " FORMAT_B " != " FORMAT_B "", rendersettings->has_predefined, has_predefined);
    has_predefined++;
    if (dwg_dynapi_entity_set_value (rendersettings, "RENDERSETTINGS", "has_predefined", &has_predefined, 0)
        && has_predefined == rendersettings->has_predefined)
      pass ();
    else
      fail ("RENDERSETTINGS.has_predefined [B] set+1 " FORMAT_B " != " FORMAT_B "", rendersettings->has_predefined, has_predefined);
    rendersettings->has_predefined--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)rendersettings->name)
           : !rendersettings->name)
      pass ();
    else
      fail ("RENDERSETTINGS.name [T] '%s' <> '%s'", name, rendersettings->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (rendersettings, "RENDERSETTINGS", "parent", &parent, NULL)
        && !memcmp (&parent, &rendersettings->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("RENDERSETTINGS.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("RENDERSETTINGS") || is_class_debugging ("RENDERSETTINGS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "RENDERSETTINGS", failed);
      failed = 0;
    }
  return failed;
}
static int test_SCALE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SCALE *restrict scale = obj->tio.object->tio.SCALE;
  failed = 0;
  if (!obj_obj || !scale)
    {
      fail ("NULL SCALE");
      return 1;
    }
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value (scale, "SCALE", "drawing_units", &drawing_units, NULL)
        && drawing_units == scale->drawing_units)
      pass ();
    else
      fail ("SCALE.drawing_units [BD] %g != %g", scale->drawing_units, drawing_units);
    drawing_units++;
    if (dwg_dynapi_entity_set_value (scale, "SCALE", "drawing_units", &drawing_units, 0)
        && drawing_units == scale->drawing_units)
      pass ();
    else
      fail ("SCALE.drawing_units [BD] set+1 %g != %g", scale->drawing_units, drawing_units);
    scale->drawing_units--;
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value (scale, "SCALE", "flag", &flag, NULL)
        && flag == scale->flag)
      pass ();
    else
      fail ("SCALE.flag [BS] %hu != %hu", scale->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (scale, "SCALE", "flag", &flag, 0)
        && flag == scale->flag)
      pass ();
    else
      fail ("SCALE.flag [BS] set+1 %hu != %hu", scale->flag, flag);
    scale->flag--;
  }
  {
    BITCODE_B is_unit_scale;
    if (dwg_dynapi_entity_value (scale, "SCALE", "is_unit_scale", &is_unit_scale, NULL)
        && is_unit_scale == scale->is_unit_scale)
      pass ();
    else
      fail ("SCALE.is_unit_scale [B] " FORMAT_B " != " FORMAT_B "", scale->is_unit_scale, is_unit_scale);
    is_unit_scale++;
    if (dwg_dynapi_entity_set_value (scale, "SCALE", "is_unit_scale", &is_unit_scale, 0)
        && is_unit_scale == scale->is_unit_scale)
      pass ();
    else
      fail ("SCALE.is_unit_scale [B] set+1 " FORMAT_B " != " FORMAT_B "", scale->is_unit_scale, is_unit_scale);
    scale->is_unit_scale--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (scale, "SCALE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)scale->name)
           : !scale->name)
      pass ();
    else
      fail ("SCALE.name [T] '%s' <> '%s'", name, scale->name);
  }
  {
    BITCODE_BD paper_units;
    if (dwg_dynapi_entity_value (scale, "SCALE", "paper_units", &paper_units, NULL)
        && paper_units == scale->paper_units)
      pass ();
    else
      fail ("SCALE.paper_units [BD] %g != %g", scale->paper_units, paper_units);
    paper_units++;
    if (dwg_dynapi_entity_set_value (scale, "SCALE", "paper_units", &paper_units, 0)
        && paper_units == scale->paper_units)
      pass ();
    else
      fail ("SCALE.paper_units [BD] set+1 %g != %g", scale->paper_units, paper_units);
    scale->paper_units--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (scale, "SCALE", "parent", &parent, NULL)
        && !memcmp (&parent, &scale->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SCALE.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("SCALE") || is_class_debugging ("SCALE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SCALE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SECTIONVIEWSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SECTIONVIEWSTYLE *restrict sectionviewstyle = obj->tio.object->tio.SECTIONVIEWSTYLE;
  failed = 0;
  if (!obj_obj || !sectionviewstyle)
    {
      fail ("NULL SECTIONVIEWSTYLE");
      return 1;
    }
  {
    BITCODE_H arrow_end_symbol;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_end_symbol", &arrow_end_symbol, NULL)
        && !memcmp (&arrow_end_symbol, &sectionviewstyle->arrow_end_symbol, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.arrow_end_symbol [H]");
  }
  {
    BITCODE_BLd arrow_position;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_position", &arrow_position, NULL)
        && arrow_position == sectionviewstyle->arrow_position)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.arrow_position [BLd] " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->arrow_position, arrow_position);
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_position", &arrow_position, 0)
        && arrow_position == sectionviewstyle->arrow_position)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.arrow_position [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->arrow_position, arrow_position);
    sectionviewstyle->arrow_position--;
  }
  {
    BITCODE_H arrow_start_symbol;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_start_symbol", &arrow_start_symbol, NULL)
        && !memcmp (&arrow_start_symbol, &sectionviewstyle->arrow_start_symbol, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.arrow_start_symbol [H]");
  }
  {
    BITCODE_CMC arrow_symbol_color;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_symbol_color", &arrow_symbol_color, NULL)
        && !memcmp (&arrow_symbol_color, &sectionviewstyle->arrow_symbol_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.arrow_symbol_color [CMC]");
  }
  {
    BITCODE_BD arrow_symbol_extension_length;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_symbol_extension_length", &arrow_symbol_extension_length, NULL)
        && arrow_symbol_extension_length == sectionviewstyle->arrow_symbol_extension_length)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.arrow_symbol_extension_length [BD] %g != %g", sectionviewstyle->arrow_symbol_extension_length, arrow_symbol_extension_length);
    arrow_symbol_extension_length++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_symbol_extension_length", &arrow_symbol_extension_length, 0)
        && arrow_symbol_extension_length == sectionviewstyle->arrow_symbol_extension_length)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.arrow_symbol_extension_length [BD] set+1 %g != %g", sectionviewstyle->arrow_symbol_extension_length, arrow_symbol_extension_length);
    sectionviewstyle->arrow_symbol_extension_length--;
  }
  {
    BITCODE_BD arrow_symbol_size;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_symbol_size", &arrow_symbol_size, NULL)
        && arrow_symbol_size == sectionviewstyle->arrow_symbol_size)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.arrow_symbol_size [BD] %g != %g", sectionviewstyle->arrow_symbol_size, arrow_symbol_size);
    arrow_symbol_size++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "arrow_symbol_size", &arrow_symbol_size, 0)
        && arrow_symbol_size == sectionviewstyle->arrow_symbol_size)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.arrow_symbol_size [BD] set+1 %g != %g", sectionviewstyle->arrow_symbol_size, arrow_symbol_size);
    sectionviewstyle->arrow_symbol_size--;
  }
  {
    BITCODE_CMC bend_line_color;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "bend_line_color", &bend_line_color, NULL)
        && !memcmp (&bend_line_color, &sectionviewstyle->bend_line_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.bend_line_color [CMC]");
  }
  {
    BITCODE_BD bend_line_length;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "bend_line_length", &bend_line_length, NULL)
        && bend_line_length == sectionviewstyle->bend_line_length)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.bend_line_length [BD] %g != %g", sectionviewstyle->bend_line_length, bend_line_length);
    bend_line_length++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "bend_line_length", &bend_line_length, 0)
        && bend_line_length == sectionviewstyle->bend_line_length)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.bend_line_length [BD] set+1 %g != %g", sectionviewstyle->bend_line_length, bend_line_length);
    sectionviewstyle->bend_line_length--;
  }
  {
    BITCODE_BLd bend_linewt;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "bend_linewt", &bend_linewt, NULL)
        && bend_linewt == sectionviewstyle->bend_linewt)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.bend_linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->bend_linewt, bend_linewt);
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "bend_linewt", &bend_linewt, 0)
        && bend_linewt == sectionviewstyle->bend_linewt)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.bend_linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->bend_linewt, bend_linewt);
    sectionviewstyle->bend_linewt--;
  }
  {
    BITCODE_H bend_ltype;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "bend_ltype", &bend_ltype, NULL)
        && !memcmp (&bend_ltype, &sectionviewstyle->bend_ltype, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.bend_ltype [H]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "class_version", &class_version, NULL)
        && class_version == sectionviewstyle->class_version)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.class_version [BS] %hu != %hu", sectionviewstyle->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "class_version", &class_version, 0)
        && class_version == sectionviewstyle->class_version)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.class_version [BS] set+1 %hu != %hu", sectionviewstyle->class_version, class_version);
    sectionviewstyle->class_version--;
  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "desc", &desc, NULL)
        && desc
           ? strEQ ((char *)desc, (char *)sectionviewstyle->desc)
           : !sectionviewstyle->desc)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.desc [T] '%s' <> '%s'", desc, sectionviewstyle->desc);
  }
  {
    BITCODE_T display_name;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "display_name", &display_name, NULL)
        && display_name
           ? strEQ ((char *)display_name, (char *)sectionviewstyle->display_name)
           : !sectionviewstyle->display_name)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.display_name [T] '%s' <> '%s'", display_name, sectionviewstyle->display_name);
  }
  {
    BITCODE_BD end_line_length;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "end_line_length", &end_line_length, NULL)
        && end_line_length == sectionviewstyle->end_line_length)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.end_line_length [BD] %g != %g", sectionviewstyle->end_line_length, end_line_length);
    end_line_length++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "end_line_length", &end_line_length, 0)
        && end_line_length == sectionviewstyle->end_line_length)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.end_line_length [BD] set+1 %g != %g", sectionviewstyle->end_line_length, end_line_length);
    sectionviewstyle->end_line_length--;
  }
  {
    BITCODE_BD end_line_overshoot;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "end_line_overshoot", &end_line_overshoot, NULL)
        && end_line_overshoot == sectionviewstyle->end_line_overshoot)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.end_line_overshoot [BD] %g != %g", sectionviewstyle->end_line_overshoot, end_line_overshoot);
    end_line_overshoot++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "end_line_overshoot", &end_line_overshoot, 0)
        && end_line_overshoot == sectionviewstyle->end_line_overshoot)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.end_line_overshoot [BD] set+1 %g != %g", sectionviewstyle->end_line_overshoot, end_line_overshoot);
    sectionviewstyle->end_line_overshoot--;
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "flags", &flags, NULL)
        && flags == sectionviewstyle->flags)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.flags [BL] %u != %u", sectionviewstyle->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "flags", &flags, 0)
        && flags == sectionviewstyle->flags)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.flags [BL] set+1 %u != %u", sectionviewstyle->flags, flags);
    sectionviewstyle->flags--;
  }
  {
    BITCODE_BD* hatch_angles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "num_hatch_angles", &count, NULL)
        && dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "hatch_angles", &hatch_angles, NULL)
        && hatch_angles == sectionviewstyle->hatch_angles)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.hatch_angles [BD*] * %u num_hatch_angles", count);
  }
  {
    BITCODE_CMC hatch_bg_color;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "hatch_bg_color", &hatch_bg_color, NULL)
        && !memcmp (&hatch_bg_color, &sectionviewstyle->hatch_bg_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.hatch_bg_color [CMC]");
  }
  {
    BITCODE_CMC hatch_color;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "hatch_color", &hatch_color, NULL)
        && !memcmp (&hatch_color, &sectionviewstyle->hatch_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.hatch_color [CMC]");
  }
  {
    BITCODE_T hatch_pattern;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "hatch_pattern", &hatch_pattern, NULL)
        && hatch_pattern
           ? strEQ ((char *)hatch_pattern, (char *)sectionviewstyle->hatch_pattern)
           : !sectionviewstyle->hatch_pattern)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.hatch_pattern [T] '%s' <> '%s'", hatch_pattern, sectionviewstyle->hatch_pattern);
  }
  {
    BITCODE_BD hatch_scale;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "hatch_scale", &hatch_scale, NULL)
        && hatch_scale == sectionviewstyle->hatch_scale)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.hatch_scale [BD] %g != %g", sectionviewstyle->hatch_scale, hatch_scale);
    hatch_scale++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "hatch_scale", &hatch_scale, 0)
        && hatch_scale == sectionviewstyle->hatch_scale)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.hatch_scale [BD] set+1 %g != %g", sectionviewstyle->hatch_scale, hatch_scale);
    sectionviewstyle->hatch_scale--;
  }
  {
    BITCODE_BLd hatch_transparency;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "hatch_transparency", &hatch_transparency, NULL)
        && hatch_transparency == sectionviewstyle->hatch_transparency)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.hatch_transparency [BLd] " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->hatch_transparency, hatch_transparency);
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "hatch_transparency", &hatch_transparency, 0)
        && hatch_transparency == sectionviewstyle->hatch_transparency)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.hatch_transparency [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->hatch_transparency, hatch_transparency);
    sectionviewstyle->hatch_transparency--;
  }
  {
    BITCODE_CMC identifier_color;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_color", &identifier_color, NULL)
        && !memcmp (&identifier_color, &sectionviewstyle->identifier_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.identifier_color [CMC]");
  }
  {
    BITCODE_T identifier_exclude_characters;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_exclude_characters", &identifier_exclude_characters, NULL)
        && identifier_exclude_characters
           ? strEQ ((char *)identifier_exclude_characters, (char *)sectionviewstyle->identifier_exclude_characters)
           : !sectionviewstyle->identifier_exclude_characters)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.identifier_exclude_characters [T] '%s' <> '%s'", identifier_exclude_characters, sectionviewstyle->identifier_exclude_characters);
  }
  {
    BITCODE_BD identifier_height;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_height", &identifier_height, NULL)
        && identifier_height == sectionviewstyle->identifier_height)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.identifier_height [BD] %g != %g", sectionviewstyle->identifier_height, identifier_height);
    identifier_height++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_height", &identifier_height, 0)
        && identifier_height == sectionviewstyle->identifier_height)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.identifier_height [BD] set+1 %g != %g", sectionviewstyle->identifier_height, identifier_height);
    sectionviewstyle->identifier_height--;
  }
  {
    BITCODE_BD identifier_offset;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_offset", &identifier_offset, NULL)
        && identifier_offset == sectionviewstyle->identifier_offset)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.identifier_offset [BD] %g != %g", sectionviewstyle->identifier_offset, identifier_offset);
    identifier_offset++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_offset", &identifier_offset, 0)
        && identifier_offset == sectionviewstyle->identifier_offset)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.identifier_offset [BD] set+1 %g != %g", sectionviewstyle->identifier_offset, identifier_offset);
    sectionviewstyle->identifier_offset--;
  }
  {
    BITCODE_BLd identifier_position;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_position", &identifier_position, NULL)
        && identifier_position == sectionviewstyle->identifier_position)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.identifier_position [BLd] " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->identifier_position, identifier_position);
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_position", &identifier_position, 0)
        && identifier_position == sectionviewstyle->identifier_position)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.identifier_position [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->identifier_position, identifier_position);
    sectionviewstyle->identifier_position--;
  }
  {
    BITCODE_H identifier_style;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "identifier_style", &identifier_style, NULL)
        && !memcmp (&identifier_style, &sectionviewstyle->identifier_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.identifier_style [H]");
  }
  {
    BITCODE_B is_modified_for_recompute;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "is_modified_for_recompute", &is_modified_for_recompute, NULL)
        && is_modified_for_recompute == sectionviewstyle->is_modified_for_recompute)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.is_modified_for_recompute [B] " FORMAT_B " != " FORMAT_B "", sectionviewstyle->is_modified_for_recompute, is_modified_for_recompute);
    is_modified_for_recompute++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "is_modified_for_recompute", &is_modified_for_recompute, 0)
        && is_modified_for_recompute == sectionviewstyle->is_modified_for_recompute)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.is_modified_for_recompute [B] set+1 " FORMAT_B " != " FORMAT_B "", sectionviewstyle->is_modified_for_recompute, is_modified_for_recompute);
    sectionviewstyle->is_modified_for_recompute--;
  }
  {
    BITCODE_BS mdoc_class_version;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "mdoc_class_version", &mdoc_class_version, NULL)
        && mdoc_class_version == sectionviewstyle->mdoc_class_version)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.mdoc_class_version [BS] %hu != %hu", sectionviewstyle->mdoc_class_version, mdoc_class_version);
    mdoc_class_version++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "mdoc_class_version", &mdoc_class_version, 0)
        && mdoc_class_version == sectionviewstyle->mdoc_class_version)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.mdoc_class_version [BS] set+1 %hu != %hu", sectionviewstyle->mdoc_class_version, mdoc_class_version);
    sectionviewstyle->mdoc_class_version--;
  }
  {
    BITCODE_BL num_hatch_angles;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "num_hatch_angles", &num_hatch_angles, NULL)
        && num_hatch_angles == sectionviewstyle->num_hatch_angles)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.num_hatch_angles [BL] %u != %u", sectionviewstyle->num_hatch_angles, num_hatch_angles);
    num_hatch_angles++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "num_hatch_angles", &num_hatch_angles, 0)
        && num_hatch_angles == sectionviewstyle->num_hatch_angles)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.num_hatch_angles [BL] set+1 %u != %u", sectionviewstyle->num_hatch_angles, num_hatch_angles);
    sectionviewstyle->num_hatch_angles--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &sectionviewstyle->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_CMC plane_line_color;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "plane_line_color", &plane_line_color, NULL)
        && !memcmp (&plane_line_color, &sectionviewstyle->plane_line_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.plane_line_color [CMC]");
  }
  {
    BITCODE_BLd plane_linewt;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "plane_linewt", &plane_linewt, NULL)
        && plane_linewt == sectionviewstyle->plane_linewt)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.plane_linewt [BLd] " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->plane_linewt, plane_linewt);
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "plane_linewt", &plane_linewt, 0)
        && plane_linewt == sectionviewstyle->plane_linewt)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.plane_linewt [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", sectionviewstyle->plane_linewt, plane_linewt);
    sectionviewstyle->plane_linewt--;
  }
  {
    BITCODE_H plane_ltype;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "plane_ltype", &plane_ltype, NULL)
        && !memcmp (&plane_ltype, &sectionviewstyle->plane_ltype, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.plane_ltype [H]");
  }
  {
    BITCODE_B unknown_b1;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "unknown_b1", &unknown_b1, NULL)
        && unknown_b1 == sectionviewstyle->unknown_b1)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.unknown_b1 [B] " FORMAT_B " != " FORMAT_B "", sectionviewstyle->unknown_b1, unknown_b1);
    unknown_b1++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "unknown_b1", &unknown_b1, 0)
        && unknown_b1 == sectionviewstyle->unknown_b1)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.unknown_b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", sectionviewstyle->unknown_b1, unknown_b1);
    sectionviewstyle->unknown_b1--;
  }
  {
    BITCODE_B unknown_b2;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "unknown_b2", &unknown_b2, NULL)
        && unknown_b2 == sectionviewstyle->unknown_b2)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.unknown_b2 [B] " FORMAT_B " != " FORMAT_B "", sectionviewstyle->unknown_b2, unknown_b2);
    unknown_b2++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "unknown_b2", &unknown_b2, 0)
        && unknown_b2 == sectionviewstyle->unknown_b2)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.unknown_b2 [B] set+1 " FORMAT_B " != " FORMAT_B "", sectionviewstyle->unknown_b2, unknown_b2);
    sectionviewstyle->unknown_b2--;
  }
  {
    BITCODE_BL viewlabel_alignment;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_alignment", &viewlabel_alignment, NULL)
        && viewlabel_alignment == sectionviewstyle->viewlabel_alignment)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_alignment [BL] %u != %u", sectionviewstyle->viewlabel_alignment, viewlabel_alignment);
    viewlabel_alignment++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_alignment", &viewlabel_alignment, 0)
        && viewlabel_alignment == sectionviewstyle->viewlabel_alignment)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_alignment [BL] set+1 %u != %u", sectionviewstyle->viewlabel_alignment, viewlabel_alignment);
    sectionviewstyle->viewlabel_alignment--;
  }
  {
    BITCODE_BL viewlabel_attachment;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_attachment", &viewlabel_attachment, NULL)
        && viewlabel_attachment == sectionviewstyle->viewlabel_attachment)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_attachment [BL] %u != %u", sectionviewstyle->viewlabel_attachment, viewlabel_attachment);
    viewlabel_attachment++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_attachment", &viewlabel_attachment, 0)
        && viewlabel_attachment == sectionviewstyle->viewlabel_attachment)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_attachment [BL] set+1 %u != %u", sectionviewstyle->viewlabel_attachment, viewlabel_attachment);
    sectionviewstyle->viewlabel_attachment--;
  }
  {
    BITCODE_BD viewlabel_offset;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_offset", &viewlabel_offset, NULL)
        && viewlabel_offset == sectionviewstyle->viewlabel_offset)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_offset [BD] %g != %g", sectionviewstyle->viewlabel_offset, viewlabel_offset);
    viewlabel_offset++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_offset", &viewlabel_offset, 0)
        && viewlabel_offset == sectionviewstyle->viewlabel_offset)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_offset [BD] set+1 %g != %g", sectionviewstyle->viewlabel_offset, viewlabel_offset);
    sectionviewstyle->viewlabel_offset--;
  }
  {
    BITCODE_T viewlabel_pattern;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_pattern", &viewlabel_pattern, NULL)
        && viewlabel_pattern
           ? strEQ ((char *)viewlabel_pattern, (char *)sectionviewstyle->viewlabel_pattern)
           : !sectionviewstyle->viewlabel_pattern)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_pattern [T] '%s' <> '%s'", viewlabel_pattern, sectionviewstyle->viewlabel_pattern);
  }
  {
    BITCODE_CMC viewlabel_text_color;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_text_color", &viewlabel_text_color, NULL)
        && !memcmp (&viewlabel_text_color, &sectionviewstyle->viewlabel_text_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.viewlabel_text_color [CMC]");
  }
  {
    BITCODE_BD viewlabel_text_height;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_text_height", &viewlabel_text_height, NULL)
        && viewlabel_text_height == sectionviewstyle->viewlabel_text_height)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_text_height [BD] %g != %g", sectionviewstyle->viewlabel_text_height, viewlabel_text_height);
    viewlabel_text_height++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_text_height", &viewlabel_text_height, 0)
        && viewlabel_text_height == sectionviewstyle->viewlabel_text_height)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewlabel_text_height [BD] set+1 %g != %g", sectionviewstyle->viewlabel_text_height, viewlabel_text_height);
    sectionviewstyle->viewlabel_text_height--;
  }
  {
    BITCODE_H viewlabel_text_style;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewlabel_text_style", &viewlabel_text_style, NULL)
        && !memcmp (&viewlabel_text_style, &sectionviewstyle->viewlabel_text_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SECTIONVIEWSTYLE.viewlabel_text_style [H]");
  }
  {
    BITCODE_BL viewstyle_flags;
    if (dwg_dynapi_entity_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewstyle_flags", &viewstyle_flags, NULL)
        && viewstyle_flags == sectionviewstyle->viewstyle_flags)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewstyle_flags [BL] %u != %u", sectionviewstyle->viewstyle_flags, viewstyle_flags);
    viewstyle_flags++;
    if (dwg_dynapi_entity_set_value (sectionviewstyle, "SECTIONVIEWSTYLE", "viewstyle_flags", &viewstyle_flags, 0)
        && viewstyle_flags == sectionviewstyle->viewstyle_flags)
      pass ();
    else
      fail ("SECTIONVIEWSTYLE.viewstyle_flags [BL] set+1 %u != %u", sectionviewstyle->viewstyle_flags, viewstyle_flags);
    sectionviewstyle->viewstyle_flags--;
  }
  if (failed && (is_class_unstable ("SECTIONVIEWSTYLE") || is_class_debugging ("SECTIONVIEWSTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SECTIONVIEWSTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SECTION_MANAGER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SECTION_MANAGER *restrict section_manager = obj->tio.object->tio.SECTION_MANAGER;
  failed = 0;
  if (!obj_obj || !section_manager)
    {
      fail ("NULL SECTION_MANAGER");
      return 1;
    }
  {
    BITCODE_B is_live;
    if (dwg_dynapi_entity_value (section_manager, "SECTION_MANAGER", "is_live", &is_live, NULL)
        && is_live == section_manager->is_live)
      pass ();
    else
      fail ("SECTION_MANAGER.is_live [B] " FORMAT_B " != " FORMAT_B "", section_manager->is_live, is_live);
    is_live++;
    if (dwg_dynapi_entity_set_value (section_manager, "SECTION_MANAGER", "is_live", &is_live, 0)
        && is_live == section_manager->is_live)
      pass ();
    else
      fail ("SECTION_MANAGER.is_live [B] set+1 " FORMAT_B " != " FORMAT_B "", section_manager->is_live, is_live);
    section_manager->is_live--;
  }
  {
    BITCODE_BS num_sections;
    if (dwg_dynapi_entity_value (section_manager, "SECTION_MANAGER", "num_sections", &num_sections, NULL)
        && num_sections == section_manager->num_sections)
      pass ();
    else
      fail ("SECTION_MANAGER.num_sections [BS] %hu != %hu", section_manager->num_sections, num_sections);
    num_sections++;
    if (dwg_dynapi_entity_set_value (section_manager, "SECTION_MANAGER", "num_sections", &num_sections, 0)
        && num_sections == section_manager->num_sections)
      pass ();
    else
      fail ("SECTION_MANAGER.num_sections [BS] set+1 %hu != %hu", section_manager->num_sections, num_sections);
    section_manager->num_sections--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (section_manager, "SECTION_MANAGER", "parent", &parent, NULL)
        && !memcmp (&parent, &section_manager->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SECTION_MANAGER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H* sections;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (section_manager, "SECTION_MANAGER", "num_sections", &count, NULL)
        && dwg_dynapi_entity_value (section_manager, "SECTION_MANAGER", "sections", &sections, NULL)
        && sections == section_manager->sections)
      pass ();
    else
      fail ("SECTION_MANAGER.sections [H*] * %u num_sections", count);
  }
  if (failed && (is_class_unstable ("SECTION_MANAGER") || is_class_debugging ("SECTION_MANAGER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SECTION_MANAGER", failed);
      failed = 0;
    }
  return failed;
}
static int test_SECTION_SETTINGS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SECTION_SETTINGS *restrict section_settings = obj->tio.object->tio.SECTION_SETTINGS;
  failed = 0;
  if (!obj_obj || !section_settings)
    {
      fail ("NULL SECTION_SETTINGS");
      return 1;
    }
  {
    BITCODE_BS curr_type;
    if (dwg_dynapi_entity_value (section_settings, "SECTION_SETTINGS", "curr_type", &curr_type, NULL)
        && curr_type == section_settings->curr_type)
      pass ();
    else
      fail ("SECTION_SETTINGS.curr_type [BS] %hu != %hu", section_settings->curr_type, curr_type);
    curr_type++;
    if (dwg_dynapi_entity_set_value (section_settings, "SECTION_SETTINGS", "curr_type", &curr_type, 0)
        && curr_type == section_settings->curr_type)
      pass ();
    else
      fail ("SECTION_SETTINGS.curr_type [BS] set+1 %hu != %hu", section_settings->curr_type, curr_type);
    section_settings->curr_type--;
  }
  {
    BITCODE_BL num_types;
    if (dwg_dynapi_entity_value (section_settings, "SECTION_SETTINGS", "num_types", &num_types, NULL)
        && num_types == section_settings->num_types)
      pass ();
    else
      fail ("SECTION_SETTINGS.num_types [BL] %u != %u", section_settings->num_types, num_types);
    num_types++;
    if (dwg_dynapi_entity_set_value (section_settings, "SECTION_SETTINGS", "num_types", &num_types, 0)
        && num_types == section_settings->num_types)
      pass ();
    else
      fail ("SECTION_SETTINGS.num_types [BL] set+1 %u != %u", section_settings->num_types, num_types);
    section_settings->num_types--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (section_settings, "SECTION_SETTINGS", "parent", &parent, NULL)
        && !memcmp (&parent, &section_settings->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SECTION_SETTINGS.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_SECTION_typesettings* types;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (section_settings, "SECTION_SETTINGS", "num_types", &count, NULL)
        && dwg_dynapi_entity_value (section_settings, "SECTION_SETTINGS", "types", &types, NULL)
        && types == section_settings->types)
      pass ();
    else
      fail ("SECTION_SETTINGS.types [Dwg_SECTION_typesettings*] * %u num_types", count);
  }
  if (failed && (is_class_unstable ("SECTION_SETTINGS") || is_class_debugging ("SECTION_SETTINGS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SECTION_SETTINGS", failed);
      failed = 0;
    }
  return failed;
}
static int test_SKYLIGHT_BACKGROUND (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SKYLIGHT_BACKGROUND *restrict skylight_background = obj->tio.object->tio.SKYLIGHT_BACKGROUND;
  failed = 0;
  if (!obj_obj || !skylight_background)
    {
      fail ("NULL SKYLIGHT_BACKGROUND");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (skylight_background, "SKYLIGHT_BACKGROUND", "class_version", &class_version, NULL)
        && class_version == skylight_background->class_version)
      pass ();
    else
      fail ("SKYLIGHT_BACKGROUND.class_version [BL] %u != %u", skylight_background->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (skylight_background, "SKYLIGHT_BACKGROUND", "class_version", &class_version, 0)
        && class_version == skylight_background->class_version)
      pass ();
    else
      fail ("SKYLIGHT_BACKGROUND.class_version [BL] set+1 %u != %u", skylight_background->class_version, class_version);
    skylight_background->class_version--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (skylight_background, "SKYLIGHT_BACKGROUND", "parent", &parent, NULL)
        && !memcmp (&parent, &skylight_background->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SKYLIGHT_BACKGROUND.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H sunid;
    if (dwg_dynapi_entity_value (skylight_background, "SKYLIGHT_BACKGROUND", "sunid", &sunid, NULL)
        && !memcmp (&sunid, &skylight_background->sunid, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SKYLIGHT_BACKGROUND.sunid [H]");
  }
  if (failed && (is_class_unstable ("SKYLIGHT_BACKGROUND") || is_class_debugging ("SKYLIGHT_BACKGROUND")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SKYLIGHT_BACKGROUND", failed);
      failed = 0;
    }
  return failed;
}
static int test_SOLID_BACKGROUND (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SOLID_BACKGROUND *restrict solid_background = obj->tio.object->tio.SOLID_BACKGROUND;
  failed = 0;
  if (!obj_obj || !solid_background)
    {
      fail ("NULL SOLID_BACKGROUND");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (solid_background, "SOLID_BACKGROUND", "class_version", &class_version, NULL)
        && class_version == solid_background->class_version)
      pass ();
    else
      fail ("SOLID_BACKGROUND.class_version [BL] %u != %u", solid_background->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (solid_background, "SOLID_BACKGROUND", "class_version", &class_version, 0)
        && class_version == solid_background->class_version)
      pass ();
    else
      fail ("SOLID_BACKGROUND.class_version [BL] set+1 %u != %u", solid_background->class_version, class_version);
    solid_background->class_version--;
  }
  {
    BITCODE_BLx color;
    if (dwg_dynapi_entity_value (solid_background, "SOLID_BACKGROUND", "color", &color, NULL)
        && color == solid_background->color)
      pass ();
    else
      fail ("SOLID_BACKGROUND.color [BLx] " FORMAT_BLx " != " FORMAT_BLx "", solid_background->color, color);
    if (dwg_dynapi_entity_set_value (solid_background, "SOLID_BACKGROUND", "color", &color, 0)
        && color == solid_background->color)
      pass ();
    else
      fail ("SOLID_BACKGROUND.color [BLx] set+1 " FORMAT_BLx " != " FORMAT_BLx "", solid_background->color, color);
    solid_background->color--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (solid_background, "SOLID_BACKGROUND", "parent", &parent, NULL)
        && !memcmp (&parent, &solid_background->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SOLID_BACKGROUND.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("SOLID_BACKGROUND") || is_class_debugging ("SOLID_BACKGROUND")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SOLID_BACKGROUND", failed);
      failed = 0;
    }
  return failed;
}
static int test_SORTENTSTABLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SORTENTSTABLE *restrict sortentstable = obj->tio.object->tio.SORTENTSTABLE;
  failed = 0;
  if (!obj_obj || !sortentstable)
    {
      fail ("NULL SORTENTSTABLE");
      return 1;
    }
  {
    BITCODE_H block_owner;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "block_owner", &block_owner, NULL)
        && !memcmp (&block_owner, &sortentstable->block_owner, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SORTENTSTABLE.block_owner [H]");
  }
  {
    BITCODE_H* ents;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "num_ents", &count, NULL)
        && dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "ents", &ents, NULL)
        && ents == sortentstable->ents)
      pass ();
    else
      fail ("SORTENTSTABLE.ents [H*] * %u num_ents", count);
  }
  {
    BITCODE_BL num_ents;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "num_ents", &num_ents, NULL)
        && num_ents == sortentstable->num_ents)
      pass ();
    else
      fail ("SORTENTSTABLE.num_ents [BL] %u != %u", sortentstable->num_ents, num_ents);
    num_ents++;
    if (dwg_dynapi_entity_set_value (sortentstable, "SORTENTSTABLE", "num_ents", &num_ents, 0)
        && num_ents == sortentstable->num_ents)
      pass ();
    else
      fail ("SORTENTSTABLE.num_ents [BL] set+1 %u != %u", sortentstable->num_ents, num_ents);
    sortentstable->num_ents--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "parent", &parent, NULL)
        && !memcmp (&parent, &sortentstable->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SORTENTSTABLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H* sort_ents;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "num_ents", &count, NULL)
        && dwg_dynapi_entity_value (sortentstable, "SORTENTSTABLE", "sort_ents", &sort_ents, NULL)
        && sort_ents == sortentstable->sort_ents)
      pass ();
    else
      fail ("SORTENTSTABLE.sort_ents [H*] * %u num_ents", count);
  }
  if (failed && (is_class_unstable ("SORTENTSTABLE") || is_class_debugging ("SORTENTSTABLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SORTENTSTABLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_SPATIAL_FILTER (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SPATIAL_FILTER *restrict spatial_filter = obj->tio.object->tio.SPATIAL_FILTER;
  failed = 0;
  if (!obj_obj || !spatial_filter)
    {
      fail ("NULL SPATIAL_FILTER");
      return 1;
    }
  {
    BITCODE_BS back_clip_on;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "back_clip_on", &back_clip_on, NULL)
        && back_clip_on == spatial_filter->back_clip_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.back_clip_on [BS] %hu != %hu", spatial_filter->back_clip_on, back_clip_on);
    back_clip_on++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "back_clip_on", &back_clip_on, 0)
        && back_clip_on == spatial_filter->back_clip_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.back_clip_on [BS] set+1 %hu != %hu", spatial_filter->back_clip_on, back_clip_on);
    spatial_filter->back_clip_on--;
  }
  {
    BITCODE_BD back_clip_z;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "back_clip_z", &back_clip_z, NULL)
        && back_clip_z == spatial_filter->back_clip_z)
      pass ();
    else
      fail ("SPATIAL_FILTER.back_clip_z [BD] %g != %g", spatial_filter->back_clip_z, back_clip_z);
    back_clip_z++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "back_clip_z", &back_clip_z, 0)
        && back_clip_z == spatial_filter->back_clip_z)
      pass ();
    else
      fail ("SPATIAL_FILTER.back_clip_z [BD] set+1 %g != %g", spatial_filter->back_clip_z, back_clip_z);
    spatial_filter->back_clip_z--;
  }
  {
    BITCODE_2RD* clip_verts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "num_clip_verts", &count, NULL)
        && dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "clip_verts", &clip_verts, NULL)
        && clip_verts == spatial_filter->clip_verts)
      pass ();
    else
      fail ("SPATIAL_FILTER.clip_verts [2RD*] * %u num_clip_verts", count);
  }
  {
    BITCODE_BS display_boundary_on;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "display_boundary_on", &display_boundary_on, NULL)
        && display_boundary_on == spatial_filter->display_boundary_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.display_boundary_on [BS] %hu != %hu", spatial_filter->display_boundary_on, display_boundary_on);
    display_boundary_on++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "display_boundary_on", &display_boundary_on, 0)
        && display_boundary_on == spatial_filter->display_boundary_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.display_boundary_on [BS] set+1 %hu != %hu", spatial_filter->display_boundary_on, display_boundary_on);
    spatial_filter->display_boundary_on--;
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "extrusion", &extrusion, NULL)
        && !memcmp (&extrusion, &spatial_filter->extrusion, sizeof (BITCODE_BE)))
        pass ();
    else
        fail ("SPATIAL_FILTER.extrusion [BE]");
  }
  {
    BITCODE_BS front_clip_on;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "front_clip_on", &front_clip_on, NULL)
        && front_clip_on == spatial_filter->front_clip_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.front_clip_on [BS] %hu != %hu", spatial_filter->front_clip_on, front_clip_on);
    front_clip_on++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "front_clip_on", &front_clip_on, 0)
        && front_clip_on == spatial_filter->front_clip_on)
      pass ();
    else
      fail ("SPATIAL_FILTER.front_clip_on [BS] set+1 %hu != %hu", spatial_filter->front_clip_on, front_clip_on);
    spatial_filter->front_clip_on--;
  }
  {
    BITCODE_BD front_clip_z;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "front_clip_z", &front_clip_z, NULL)
        && front_clip_z == spatial_filter->front_clip_z)
      pass ();
    else
      fail ("SPATIAL_FILTER.front_clip_z [BD] %g != %g", spatial_filter->front_clip_z, front_clip_z);
    front_clip_z++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "front_clip_z", &front_clip_z, 0)
        && front_clip_z == spatial_filter->front_clip_z)
      pass ();
    else
      fail ("SPATIAL_FILTER.front_clip_z [BD] set+1 %g != %g", spatial_filter->front_clip_z, front_clip_z);
    spatial_filter->front_clip_z--;
  }
  {
    BITCODE_BD* inverse_transform;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "inverse_transform", &inverse_transform, NULL)
        && !memcmp (&inverse_transform, &spatial_filter->inverse_transform, sizeof (BITCODE_BD*)))
        pass ();
    else
        fail ("SPATIAL_FILTER.inverse_transform [BD*]");
  }
  {
    BITCODE_BS num_clip_verts;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "num_clip_verts", &num_clip_verts, NULL)
        && num_clip_verts == spatial_filter->num_clip_verts)
      pass ();
    else
      fail ("SPATIAL_FILTER.num_clip_verts [BS] %hu != %hu", spatial_filter->num_clip_verts, num_clip_verts);
    num_clip_verts++;
    if (dwg_dynapi_entity_set_value (spatial_filter, "SPATIAL_FILTER", "num_clip_verts", &num_clip_verts, 0)
        && num_clip_verts == spatial_filter->num_clip_verts)
      pass ();
    else
      fail ("SPATIAL_FILTER.num_clip_verts [BS] set+1 %hu != %hu", spatial_filter->num_clip_verts, num_clip_verts);
    spatial_filter->num_clip_verts--;
  }
  {
    BITCODE_3BD origin;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "origin", &origin, NULL)
        && !memcmp (&origin, &spatial_filter->origin, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("SPATIAL_FILTER.origin [3BD]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "parent", &parent, NULL)
        && !memcmp (&parent, &spatial_filter->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SPATIAL_FILTER.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD* transform;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "num_transform", &count, NULL)
        && dwg_dynapi_entity_value (spatial_filter, "SPATIAL_FILTER", "transform", &transform, NULL)
        && transform == spatial_filter->transform)
      pass ();
    else
      fail ("SPATIAL_FILTER.transform [BD*] * %u num_transform", count);
  }
  if (failed && (is_class_unstable ("SPATIAL_FILTER") || is_class_debugging ("SPATIAL_FILTER")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SPATIAL_FILTER", failed);
      failed = 0;
    }
  return failed;
}
static int test_SPATIAL_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SPATIAL_INDEX *restrict spatial_index = obj->tio.object->tio.SPATIAL_INDEX;
  failed = 0;
  if (!obj_obj || !spatial_index)
    {
      fail ("NULL SPATIAL_INDEX");
      return 1;
    }
  {
    BITCODE_TF bindata;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "bindata", &bindata, NULL)
        && !memcmp (&bindata, &spatial_index->bindata, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("SPATIAL_INDEX.bindata [TF]");
  }
  {
    BITCODE_BL bindata_size;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "bindata_size", &bindata_size, NULL)
        && bindata_size == spatial_index->bindata_size)
      pass ();
    else
      fail ("SPATIAL_INDEX.bindata_size [BL] %u != %u", spatial_index->bindata_size, bindata_size);
    bindata_size++;
    if (dwg_dynapi_entity_set_value (spatial_index, "SPATIAL_INDEX", "bindata_size", &bindata_size, 0)
        && bindata_size == spatial_index->bindata_size)
      pass ();
    else
      fail ("SPATIAL_INDEX.bindata_size [BL] set+1 %u != %u", spatial_index->bindata_size, bindata_size);
    spatial_index->bindata_size--;
  }
  {
    BITCODE_H* hdls;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "num_hdls", &count, NULL)
        && dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "hdls", &hdls, NULL)
        && hdls == spatial_index->hdls)
      pass ();
    else
      fail ("SPATIAL_INDEX.hdls [H*] * %u num_hdls", count);
  }
  {
    BITCODE_TIMEBLL last_updated;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "last_updated", &last_updated, NULL)
        && !memcmp (&last_updated, &spatial_index->last_updated, sizeof (BITCODE_TIMEBLL)))
        pass ();
    else
        fail ("SPATIAL_INDEX.last_updated [TIMEBLL]");
  }
  {
    BITCODE_BD num1;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "num1", &num1, NULL)
        && num1 == spatial_index->num1)
      pass ();
    else
      fail ("SPATIAL_INDEX.num1 [BD] %g != %g", spatial_index->num1, num1);
    num1++;
    if (dwg_dynapi_entity_set_value (spatial_index, "SPATIAL_INDEX", "num1", &num1, 0)
        && num1 == spatial_index->num1)
      pass ();
    else
      fail ("SPATIAL_INDEX.num1 [BD] set+1 %g != %g", spatial_index->num1, num1);
    spatial_index->num1--;
  }
  {
    BITCODE_BL num_hdls;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "num_hdls", &num_hdls, NULL)
        && num_hdls == spatial_index->num_hdls)
      pass ();
    else
      fail ("SPATIAL_INDEX.num_hdls [BL] %u != %u", spatial_index->num_hdls, num_hdls);
    num_hdls++;
    if (dwg_dynapi_entity_set_value (spatial_index, "SPATIAL_INDEX", "num_hdls", &num_hdls, 0)
        && num_hdls == spatial_index->num_hdls)
      pass ();
    else
      fail ("SPATIAL_INDEX.num_hdls [BL] set+1 %u != %u", spatial_index->num_hdls, num_hdls);
    spatial_index->num_hdls--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (spatial_index, "SPATIAL_INDEX", "parent", &parent, NULL)
        && !memcmp (&parent, &spatial_index->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SPATIAL_INDEX.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("SPATIAL_INDEX") || is_class_debugging ("SPATIAL_INDEX")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SPATIAL_INDEX", failed);
      failed = 0;
    }
  return failed;
}
static int test_STYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_STYLE *restrict style = obj->tio.object->tio.STYLE;
  failed = 0;
  if (!obj_obj || !style)
    {
      fail ("NULL STYLE");
      return 1;
    }
  {
    BITCODE_T bigfont_file;
    if (dwg_dynapi_entity_value (style, "STYLE", "bigfont_file", &bigfont_file, NULL)
        && bigfont_file
           ? strEQ ((char *)bigfont_file, (char *)style->bigfont_file)
           : !style->bigfont_file)
      pass ();
    else
      fail ("STYLE.bigfont_file [T] '%s' <> '%s'", bigfont_file, style->bigfont_file);
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (style, "STYLE", "flag", &flag, NULL)
        && flag == style->flag)
      pass ();
    else
      fail ("STYLE.flag [RC] %u != %u", style->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "flag", &flag, 0)
        && flag == style->flag)
      pass ();
    else
      fail ("STYLE.flag [RC] set+1 %u != %u", style->flag, flag);
    style->flag--;
  }
  {
    BITCODE_T font_file;
    if (dwg_dynapi_entity_value (style, "STYLE", "font_file", &font_file, NULL)
        && font_file
           ? strEQ ((char *)font_file, (char *)style->font_file)
           : !style->font_file)
      pass ();
    else
      fail ("STYLE.font_file [T] '%s' <> '%s'", font_file, style->font_file);
  }
  {
    BITCODE_RC generation;
    if (dwg_dynapi_entity_value (style, "STYLE", "generation", &generation, NULL)
        && generation == style->generation)
      pass ();
    else
      fail ("STYLE.generation [RC] %u != %u", style->generation, generation);
    generation++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "generation", &generation, 0)
        && generation == style->generation)
      pass ();
    else
      fail ("STYLE.generation [RC] set+1 %u != %u", style->generation, generation);
    style->generation--;
  }
  {
    BITCODE_B is_shape;
    if (dwg_dynapi_entity_value (style, "STYLE", "is_shape", &is_shape, NULL)
        && is_shape == style->is_shape)
      pass ();
    else
      fail ("STYLE.is_shape [B] " FORMAT_B " != " FORMAT_B "", style->is_shape, is_shape);
    is_shape++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "is_shape", &is_shape, 0)
        && is_shape == style->is_shape)
      pass ();
    else
      fail ("STYLE.is_shape [B] set+1 " FORMAT_B " != " FORMAT_B "", style->is_shape, is_shape);
    style->is_shape--;
  }
  {
    BITCODE_B is_vertical;
    if (dwg_dynapi_entity_value (style, "STYLE", "is_vertical", &is_vertical, NULL)
        && is_vertical == style->is_vertical)
      pass ();
    else
      fail ("STYLE.is_vertical [B] " FORMAT_B " != " FORMAT_B "", style->is_vertical, is_vertical);
    is_vertical++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "is_vertical", &is_vertical, 0)
        && is_vertical == style->is_vertical)
      pass ();
    else
      fail ("STYLE.is_vertical [B] set+1 " FORMAT_B " != " FORMAT_B "", style->is_vertical, is_vertical);
    style->is_vertical--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (style, "STYLE", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == style->is_xref_dep)
      pass ();
    else
      fail ("STYLE.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", style->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == style->is_xref_dep)
      pass ();
    else
      fail ("STYLE.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", style->is_xref_dep, is_xref_dep);
    style->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (style, "STYLE", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == style->is_xref_ref)
      pass ();
    else
      fail ("STYLE.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", style->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == style->is_xref_ref)
      pass ();
    else
      fail ("STYLE.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", style->is_xref_ref, is_xref_ref);
    style->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (style, "STYLE", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == style->is_xref_resolved)
      pass ();
    else
      fail ("STYLE.is_xref_resolved [BS] %hu != %hu", style->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == style->is_xref_resolved)
      pass ();
    else
      fail ("STYLE.is_xref_resolved [BS] set+1 %hu != %hu", style->is_xref_resolved, is_xref_resolved);
    style->is_xref_resolved--;
  }
  {
    BITCODE_BD last_height;
    if (dwg_dynapi_entity_value (style, "STYLE", "last_height", &last_height, NULL)
        && last_height == style->last_height)
      pass ();
    else
      fail ("STYLE.last_height [BD] %g != %g", style->last_height, last_height);
    last_height++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "last_height", &last_height, 0)
        && last_height == style->last_height)
      pass ();
    else
      fail ("STYLE.last_height [BD] set+1 %g != %g", style->last_height, last_height);
    style->last_height--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (style, "STYLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)style->name)
           : !style->name)
      pass ();
    else
      fail ("STYLE.name [TV] '%s' <> '%s'", name, style->name);
  }
  {
    BITCODE_BD oblique_angle;
    if (dwg_dynapi_entity_value (style, "STYLE", "oblique_angle", &oblique_angle, NULL)
        && oblique_angle == style->oblique_angle)
      pass ();
    else
      fail ("STYLE.oblique_angle [BD] %g != %g", style->oblique_angle, oblique_angle);
    oblique_angle++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "oblique_angle", &oblique_angle, 0)
        && oblique_angle == style->oblique_angle)
      pass ();
    else
      fail ("STYLE.oblique_angle [BD] set+1 %g != %g", style->oblique_angle, oblique_angle);
    style->oblique_angle--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (style, "STYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &style->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("STYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD text_size;
    if (dwg_dynapi_entity_value (style, "STYLE", "text_size", &text_size, NULL)
        && text_size == style->text_size)
      pass ();
    else
      fail ("STYLE.text_size [BD] %g != %g", style->text_size, text_size);
    text_size++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "text_size", &text_size, 0)
        && text_size == style->text_size)
      pass ();
    else
      fail ("STYLE.text_size [BD] set+1 %g != %g", style->text_size, text_size);
    style->text_size--;
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (style, "STYLE", "used", &used, NULL)
        && used == style->used)
      pass ();
    else
      fail ("STYLE.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", style->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "used", &used, 0)
        && used == style->used)
      pass ();
    else
      fail ("STYLE.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", style->used, used);
    style->used--;
  }
  {
    BITCODE_BD width_factor;
    if (dwg_dynapi_entity_value (style, "STYLE", "width_factor", &width_factor, NULL)
        && width_factor == style->width_factor)
      pass ();
    else
      fail ("STYLE.width_factor [BD] %g != %g", style->width_factor, width_factor);
    width_factor++;
    if (dwg_dynapi_entity_set_value (style, "STYLE", "width_factor", &width_factor, 0)
        && width_factor == style->width_factor)
      pass ();
    else
      fail ("STYLE.width_factor [BD] set+1 %g != %g", style->width_factor, width_factor);
    style->width_factor--;
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (style, "STYLE", "xref", &xref, NULL)
        && !memcmp (&xref, &style->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("STYLE.xref [H]");
  }
  if (failed && (is_class_unstable ("STYLE") || is_class_debugging ("STYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "STYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_STYLE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_STYLE_CONTROL *restrict style_control = obj->tio.object->tio.STYLE_CONTROL;
  failed = 0;
  if (!obj_obj || !style_control)
    {
      fail ("NULL STYLE_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "entries", &entries, NULL)
        && entries == style_control->entries)
      pass ();
    else
      fail ("STYLE_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == style_control->flags_r11)
      pass ();
    else
      fail ("STYLE_CONTROL.flags_r11 [RS] %hu != %hu", style_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (style_control, "STYLE_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == style_control->flags_r11)
      pass ();
    else
      fail ("STYLE_CONTROL.flags_r11 [RS] set+1 %hu != %hu", style_control->flags_r11, flags_r11);
    style_control->flags_r11--;
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == style_control->num_entries)
      pass ();
    else
      fail ("STYLE_CONTROL.num_entries [BS] %hu != %hu", style_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (style_control, "STYLE_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == style_control->num_entries)
      pass ();
    else
      fail ("STYLE_CONTROL.num_entries [BS] set+1 %hu != %hu", style_control->num_entries, num_entries);
    style_control->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (style_control, "STYLE_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &style_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("STYLE_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("STYLE_CONTROL") || is_class_debugging ("STYLE_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "STYLE_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_SUN (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SUN *restrict sun = obj->tio.object->tio.SUN;
  failed = 0;
  if (!obj_obj || !sun)
    {
      fail ("NULL SUN");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (sun, "SUN", "class_version", &class_version, NULL)
        && class_version == sun->class_version)
      pass ();
    else
      fail ("SUN.class_version [BL] %u != %u", sun->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "class_version", &class_version, 0)
        && class_version == sun->class_version)
      pass ();
    else
      fail ("SUN.class_version [BL] set+1 %u != %u", sun->class_version, class_version);
    sun->class_version--;
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value (sun, "SUN", "color", &color, NULL)
        && !memcmp (&color, &sun->color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("SUN.color [CMC]");
  }
  {
    BITCODE_B has_shadow;
    if (dwg_dynapi_entity_value (sun, "SUN", "has_shadow", &has_shadow, NULL)
        && has_shadow == sun->has_shadow)
      pass ();
    else
      fail ("SUN.has_shadow [B] " FORMAT_B " != " FORMAT_B "", sun->has_shadow, has_shadow);
    has_shadow++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "has_shadow", &has_shadow, 0)
        && has_shadow == sun->has_shadow)
      pass ();
    else
      fail ("SUN.has_shadow [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->has_shadow, has_shadow);
    sun->has_shadow--;
  }
  {
    BITCODE_BD intensity;
    if (dwg_dynapi_entity_value (sun, "SUN", "intensity", &intensity, NULL)
        && intensity == sun->intensity)
      pass ();
    else
      fail ("SUN.intensity [BD] %g != %g", sun->intensity, intensity);
    intensity++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "intensity", &intensity, 0)
        && intensity == sun->intensity)
      pass ();
    else
      fail ("SUN.intensity [BD] set+1 %g != %g", sun->intensity, intensity);
    sun->intensity--;
  }
  {
    BITCODE_B is_dst;
    if (dwg_dynapi_entity_value (sun, "SUN", "is_dst", &is_dst, NULL)
        && is_dst == sun->is_dst)
      pass ();
    else
      fail ("SUN.is_dst [B] " FORMAT_B " != " FORMAT_B "", sun->is_dst, is_dst);
    is_dst++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "is_dst", &is_dst, 0)
        && is_dst == sun->is_dst)
      pass ();
    else
      fail ("SUN.is_dst [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->is_dst, is_dst);
    sun->is_dst--;
  }
  {
    BITCODE_B is_on;
    if (dwg_dynapi_entity_value (sun, "SUN", "is_on", &is_on, NULL)
        && is_on == sun->is_on)
      pass ();
    else
      fail ("SUN.is_on [B] " FORMAT_B " != " FORMAT_B "", sun->is_on, is_on);
    is_on++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "is_on", &is_on, 0)
        && is_on == sun->is_on)
      pass ();
    else
      fail ("SUN.is_on [B] set+1 " FORMAT_B " != " FORMAT_B "", sun->is_on, is_on);
    sun->is_on--;
  }
  {
    BITCODE_BL julian_day;
    if (dwg_dynapi_entity_value (sun, "SUN", "julian_day", &julian_day, NULL)
        && julian_day == sun->julian_day)
      pass ();
    else
      fail ("SUN.julian_day [BL] %u != %u", sun->julian_day, julian_day);
    julian_day++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "julian_day", &julian_day, 0)
        && julian_day == sun->julian_day)
      pass ();
    else
      fail ("SUN.julian_day [BL] set+1 %u != %u", sun->julian_day, julian_day);
    sun->julian_day--;
  }
  {
    BITCODE_BL msecs;
    if (dwg_dynapi_entity_value (sun, "SUN", "msecs", &msecs, NULL)
        && msecs == sun->msecs)
      pass ();
    else
      fail ("SUN.msecs [BL] %u != %u", sun->msecs, msecs);
    msecs++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "msecs", &msecs, 0)
        && msecs == sun->msecs)
      pass ();
    else
      fail ("SUN.msecs [BL] set+1 %u != %u", sun->msecs, msecs);
    sun->msecs--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (sun, "SUN", "parent", &parent, NULL)
        && !memcmp (&parent, &sun->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SUN.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BS shadow_mapsize;
    if (dwg_dynapi_entity_value (sun, "SUN", "shadow_mapsize", &shadow_mapsize, NULL)
        && shadow_mapsize == sun->shadow_mapsize)
      pass ();
    else
      fail ("SUN.shadow_mapsize [BS] %hu != %hu", sun->shadow_mapsize, shadow_mapsize);
    shadow_mapsize++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "shadow_mapsize", &shadow_mapsize, 0)
        && shadow_mapsize == sun->shadow_mapsize)
      pass ();
    else
      fail ("SUN.shadow_mapsize [BS] set+1 %hu != %hu", sun->shadow_mapsize, shadow_mapsize);
    sun->shadow_mapsize--;
  }
  {
    BITCODE_RC shadow_softness;
    if (dwg_dynapi_entity_value (sun, "SUN", "shadow_softness", &shadow_softness, NULL)
        && shadow_softness == sun->shadow_softness)
      pass ();
    else
      fail ("SUN.shadow_softness [RC] %u != %u", sun->shadow_softness, shadow_softness);
    shadow_softness++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "shadow_softness", &shadow_softness, 0)
        && shadow_softness == sun->shadow_softness)
      pass ();
    else
      fail ("SUN.shadow_softness [RC] set+1 %u != %u", sun->shadow_softness, shadow_softness);
    sun->shadow_softness--;
  }
  {
    BITCODE_BL shadow_type;
    if (dwg_dynapi_entity_value (sun, "SUN", "shadow_type", &shadow_type, NULL)
        && shadow_type == sun->shadow_type)
      pass ();
    else
      fail ("SUN.shadow_type [BL] %u != %u", sun->shadow_type, shadow_type);
    shadow_type++;
    if (dwg_dynapi_entity_set_value (sun, "SUN", "shadow_type", &shadow_type, 0)
        && shadow_type == sun->shadow_type)
      pass ();
    else
      fail ("SUN.shadow_type [BL] set+1 %u != %u", sun->shadow_type, shadow_type);
    sun->shadow_type--;
  }
  if (failed && (is_class_unstable ("SUN") || is_class_debugging ("SUN")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SUN", failed);
      failed = 0;
    }
  return failed;
}
static int test_SUNSTUDY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_SUNSTUDY *restrict sunstudy = obj->tio.object->tio.SUNSTUDY;
  failed = 0;
  if (!obj_obj || !sunstudy)
    {
      fail ("NULL SUNSTUDY");
      return 1;
    }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "class_version", &class_version, NULL)
        && class_version == sunstudy->class_version)
      pass ();
    else
      fail ("SUNSTUDY.class_version [BL] %u != %u", sunstudy->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "class_version", &class_version, 0)
        && class_version == sunstudy->class_version)
      pass ();
    else
      fail ("SUNSTUDY.class_version [BL] set+1 %u != %u", sunstudy->class_version, class_version);
    sunstudy->class_version--;
  }
  {
    Dwg_SUNSTUDY_Dates* dates;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "num_dates", &count, NULL)
        && dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "dates", &dates, NULL)
        && dates == sunstudy->dates)
      pass ();
    else
      fail ("SUNSTUDY.dates [Dwg_SUNSTUDY_Dates*] * %u num_dates", count);
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)sunstudy->description)
           : !sunstudy->description)
      pass ();
    else
      fail ("SUNSTUDY.description [T] '%s' <> '%s'", description, sunstudy->description);
  }
  {
    BITCODE_BL end_time;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "end_time", &end_time, NULL)
        && end_time == sunstudy->end_time)
      pass ();
    else
      fail ("SUNSTUDY.end_time [BL] %u != %u", sunstudy->end_time, end_time);
    end_time++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "end_time", &end_time, 0)
        && end_time == sunstudy->end_time)
      pass ();
    else
      fail ("SUNSTUDY.end_time [BL] set+1 %u != %u", sunstudy->end_time, end_time);
    sunstudy->end_time--;
  }
  {
    BITCODE_B* hours;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "num_hours", &count, NULL)
        && dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "hours", &hours, NULL)
        && hours == sunstudy->hours)
      pass ();
    else
      fail ("SUNSTUDY.hours [B*] * %u num_hours", count);
  }
  {
    BITCODE_BL interval;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "interval", &interval, NULL)
        && interval == sunstudy->interval)
      pass ();
    else
      fail ("SUNSTUDY.interval [BL] %u != %u", sunstudy->interval, interval);
    interval++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "interval", &interval, 0)
        && interval == sunstudy->interval)
      pass ();
    else
      fail ("SUNSTUDY.interval [BL] set+1 %u != %u", sunstudy->interval, interval);
    sunstudy->interval--;
  }
  {
    BITCODE_B label_viewports;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "label_viewports", &label_viewports, NULL)
        && label_viewports == sunstudy->label_viewports)
      pass ();
    else
      fail ("SUNSTUDY.label_viewports [B] " FORMAT_B " != " FORMAT_B "", sunstudy->label_viewports, label_viewports);
    label_viewports++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "label_viewports", &label_viewports, 0)
        && label_viewports == sunstudy->label_viewports)
      pass ();
    else
      fail ("SUNSTUDY.label_viewports [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->label_viewports, label_viewports);
    sunstudy->label_viewports--;
  }
  {
    BITCODE_B lock_viewports;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "lock_viewports", &lock_viewports, NULL)
        && lock_viewports == sunstudy->lock_viewports)
      pass ();
    else
      fail ("SUNSTUDY.lock_viewports [B] " FORMAT_B " != " FORMAT_B "", sunstudy->lock_viewports, lock_viewports);
    lock_viewports++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "lock_viewports", &lock_viewports, 0)
        && lock_viewports == sunstudy->lock_viewports)
      pass ();
    else
      fail ("SUNSTUDY.lock_viewports [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->lock_viewports, lock_viewports);
    sunstudy->lock_viewports--;
  }
  {
    BITCODE_BL num_dates;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "num_dates", &num_dates, NULL)
        && num_dates == sunstudy->num_dates)
      pass ();
    else
      fail ("SUNSTUDY.num_dates [BL] %u != %u", sunstudy->num_dates, num_dates);
    num_dates++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "num_dates", &num_dates, 0)
        && num_dates == sunstudy->num_dates)
      pass ();
    else
      fail ("SUNSTUDY.num_dates [BL] set+1 %u != %u", sunstudy->num_dates, num_dates);
    sunstudy->num_dates--;
  }
  {
    BITCODE_BL num_hours;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "num_hours", &num_hours, NULL)
        && num_hours == sunstudy->num_hours)
      pass ();
    else
      fail ("SUNSTUDY.num_hours [BL] %u != %u", sunstudy->num_hours, num_hours);
    num_hours++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "num_hours", &num_hours, 0)
        && num_hours == sunstudy->num_hours)
      pass ();
    else
      fail ("SUNSTUDY.num_hours [BL] set+1 %u != %u", sunstudy->num_hours, num_hours);
    sunstudy->num_hours--;
  }
  {
    BITCODE_BL numcols;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "numcols", &numcols, NULL)
        && numcols == sunstudy->numcols)
      pass ();
    else
      fail ("SUNSTUDY.numcols [BL] %u != %u", sunstudy->numcols, numcols);
    numcols++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "numcols", &numcols, 0)
        && numcols == sunstudy->numcols)
      pass ();
    else
      fail ("SUNSTUDY.numcols [BL] set+1 %u != %u", sunstudy->numcols, numcols);
    sunstudy->numcols--;
  }
  {
    BITCODE_BL numrows;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "numrows", &numrows, NULL)
        && numrows == sunstudy->numrows)
      pass ();
    else
      fail ("SUNSTUDY.numrows [BL] %u != %u", sunstudy->numrows, numrows);
    numrows++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "numrows", &numrows, 0)
        && numrows == sunstudy->numrows)
      pass ();
    else
      fail ("SUNSTUDY.numrows [BL] set+1 %u != %u", sunstudy->numrows, numrows);
    sunstudy->numrows--;
  }
  {
    BITCODE_BL numvports;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "numvports", &numvports, NULL)
        && numvports == sunstudy->numvports)
      pass ();
    else
      fail ("SUNSTUDY.numvports [BL] %u != %u", sunstudy->numvports, numvports);
    numvports++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "numvports", &numvports, 0)
        && numvports == sunstudy->numvports)
      pass ();
    else
      fail ("SUNSTUDY.numvports [BL] set+1 %u != %u", sunstudy->numvports, numvports);
    sunstudy->numvports--;
  }
  {
    BITCODE_BL output_type;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "output_type", &output_type, NULL)
        && output_type == sunstudy->output_type)
      pass ();
    else
      fail ("SUNSTUDY.output_type [BL] %u != %u", sunstudy->output_type, output_type);
    output_type++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "output_type", &output_type, 0)
        && output_type == sunstudy->output_type)
      pass ();
    else
      fail ("SUNSTUDY.output_type [BL] set+1 %u != %u", sunstudy->output_type, output_type);
    sunstudy->output_type--;
  }
  {
    BITCODE_H page_setup_wizard;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "page_setup_wizard", &page_setup_wizard, NULL)
        && !memcmp (&page_setup_wizard, &sunstudy->page_setup_wizard, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SUNSTUDY.page_setup_wizard [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "parent", &parent, NULL)
        && !memcmp (&parent, &sunstudy->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("SUNSTUDY.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_B select_dates_from_calendar;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "select_dates_from_calendar", &select_dates_from_calendar, NULL)
        && select_dates_from_calendar == sunstudy->select_dates_from_calendar)
      pass ();
    else
      fail ("SUNSTUDY.select_dates_from_calendar [B] " FORMAT_B " != " FORMAT_B "", sunstudy->select_dates_from_calendar, select_dates_from_calendar);
    select_dates_from_calendar++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "select_dates_from_calendar", &select_dates_from_calendar, 0)
        && select_dates_from_calendar == sunstudy->select_dates_from_calendar)
      pass ();
    else
      fail ("SUNSTUDY.select_dates_from_calendar [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->select_dates_from_calendar, select_dates_from_calendar);
    sunstudy->select_dates_from_calendar--;
  }
  {
    BITCODE_B select_range_of_dates;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "select_range_of_dates", &select_range_of_dates, NULL)
        && select_range_of_dates == sunstudy->select_range_of_dates)
      pass ();
    else
      fail ("SUNSTUDY.select_range_of_dates [B] " FORMAT_B " != " FORMAT_B "", sunstudy->select_range_of_dates, select_range_of_dates);
    select_range_of_dates++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "select_range_of_dates", &select_range_of_dates, 0)
        && select_range_of_dates == sunstudy->select_range_of_dates)
      pass ();
    else
      fail ("SUNSTUDY.select_range_of_dates [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->select_range_of_dates, select_range_of_dates);
    sunstudy->select_range_of_dates--;
  }
  {
    BITCODE_T setup_name;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "setup_name", &setup_name, NULL)
        && setup_name
           ? strEQ ((char *)setup_name, (char *)sunstudy->setup_name)
           : !sunstudy->setup_name)
      pass ();
    else
      fail ("SUNSTUDY.setup_name [T] '%s' <> '%s'", setup_name, sunstudy->setup_name);
  }
  {
    BITCODE_BL shade_plot_type;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "shade_plot_type", &shade_plot_type, NULL)
        && shade_plot_type == sunstudy->shade_plot_type)
      pass ();
    else
      fail ("SUNSTUDY.shade_plot_type [BL] %u != %u", sunstudy->shade_plot_type, shade_plot_type);
    shade_plot_type++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "shade_plot_type", &shade_plot_type, 0)
        && shade_plot_type == sunstudy->shade_plot_type)
      pass ();
    else
      fail ("SUNSTUDY.shade_plot_type [BL] set+1 %u != %u", sunstudy->shade_plot_type, shade_plot_type);
    sunstudy->shade_plot_type--;
  }
  {
    BITCODE_T sheet_set_name;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "sheet_set_name", &sheet_set_name, NULL)
        && sheet_set_name
           ? strEQ ((char *)sheet_set_name, (char *)sunstudy->sheet_set_name)
           : !sunstudy->sheet_set_name)
      pass ();
    else
      fail ("SUNSTUDY.sheet_set_name [T] '%s' <> '%s'", sheet_set_name, sunstudy->sheet_set_name);
  }
  {
    BITCODE_T sheet_subset_name;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "sheet_subset_name", &sheet_subset_name, NULL)
        && sheet_subset_name
           ? strEQ ((char *)sheet_subset_name, (char *)sunstudy->sheet_subset_name)
           : !sunstudy->sheet_subset_name)
      pass ();
    else
      fail ("SUNSTUDY.sheet_subset_name [T] '%s' <> '%s'", sheet_subset_name, sunstudy->sheet_subset_name);
  }
  {
    BITCODE_BD spacing;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "spacing", &spacing, NULL)
        && spacing == sunstudy->spacing)
      pass ();
    else
      fail ("SUNSTUDY.spacing [BD] %g != %g", sunstudy->spacing, spacing);
    spacing++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "spacing", &spacing, 0)
        && spacing == sunstudy->spacing)
      pass ();
    else
      fail ("SUNSTUDY.spacing [BD] set+1 %g != %g", sunstudy->spacing, spacing);
    sunstudy->spacing--;
  }
  {
    BITCODE_BL start_time;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "start_time", &start_time, NULL)
        && start_time == sunstudy->start_time)
      pass ();
    else
      fail ("SUNSTUDY.start_time [BL] %u != %u", sunstudy->start_time, start_time);
    start_time++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "start_time", &start_time, 0)
        && start_time == sunstudy->start_time)
      pass ();
    else
      fail ("SUNSTUDY.start_time [BL] set+1 %u != %u", sunstudy->start_time, start_time);
    sunstudy->start_time--;
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "text_style", &text_style, NULL)
        && !memcmp (&text_style, &sunstudy->text_style, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SUNSTUDY.text_style [H]");
  }
  {
    BITCODE_B use_subset;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "use_subset", &use_subset, NULL)
        && use_subset == sunstudy->use_subset)
      pass ();
    else
      fail ("SUNSTUDY.use_subset [B] " FORMAT_B " != " FORMAT_B "", sunstudy->use_subset, use_subset);
    use_subset++;
    if (dwg_dynapi_entity_set_value (sunstudy, "SUNSTUDY", "use_subset", &use_subset, 0)
        && use_subset == sunstudy->use_subset)
      pass ();
    else
      fail ("SUNSTUDY.use_subset [B] set+1 " FORMAT_B " != " FORMAT_B "", sunstudy->use_subset, use_subset);
    sunstudy->use_subset--;
  }
  {
    BITCODE_H view;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "view", &view, NULL)
        && !memcmp (&view, &sunstudy->view, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SUNSTUDY.view [H]");
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (sunstudy, "SUNSTUDY", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &sunstudy->visualstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("SUNSTUDY.visualstyle [H]");
  }
  if (failed && (is_class_unstable ("SUNSTUDY") || is_class_debugging ("SUNSTUDY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "SUNSTUDY", failed);
      failed = 0;
    }
  return failed;
}
static int test_TABLECONTENT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TABLECONTENT *restrict tablecontent = obj->tio.object->tio.TABLECONTENT;
  failed = 0;
  if (!obj_obj || !tablecontent)
    {
      fail ("NULL TABLECONTENT");
      return 1;
    }
  {
    Dwg_FormattedTableData fdata;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "fdata", &fdata, NULL)
        && !memcmp (&fdata, &tablecontent->fdata, sizeof (Dwg_FormattedTableData)))
        pass ();
    else
        fail ("TABLECONTENT.fdata [Dwg_FormattedTableData]");
  }
  {
    Dwg_LinkedData ldata;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "ldata", &ldata, NULL)
        && !memcmp (&ldata, &tablecontent->ldata, sizeof (Dwg_LinkedData)))
        pass ();
    else
        fail ("TABLECONTENT.ldata [Dwg_LinkedData]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "parent", &parent, NULL)
        && !memcmp (&parent, &tablecontent->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("TABLECONTENT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H tablestyle;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "tablestyle", &tablestyle, NULL)
        && !memcmp (&tablestyle, &tablecontent->tablestyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLECONTENT.tablestyle [H]");
  }
  {
    Dwg_LinkedTableData tdata;
    if (dwg_dynapi_entity_value (tablecontent, "TABLECONTENT", "tdata", &tdata, NULL)
        && !memcmp (&tdata, &tablecontent->tdata, sizeof (Dwg_LinkedTableData)))
        pass ();
    else
        fail ("TABLECONTENT.tdata [Dwg_LinkedTableData]");
  }
  if (failed && (is_class_unstable ("TABLECONTENT") || is_class_debugging ("TABLECONTENT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TABLECONTENT", failed);
      failed = 0;
    }
  return failed;
}
static int test_TABLEGEOMETRY (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TABLEGEOMETRY *restrict tablegeometry = obj->tio.object->tio.TABLEGEOMETRY;
  failed = 0;
  if (!obj_obj || !tablegeometry)
    {
      fail ("NULL TABLEGEOMETRY");
      return 1;
    }
  {
    Dwg_TABLEGEOMETRY_Cell* cells;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "num_cells", &count, NULL)
        && dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "cells", &cells, NULL)
        && cells == tablegeometry->cells)
      pass ();
    else
      fail ("TABLEGEOMETRY.cells [Dwg_TABLEGEOMETRY_Cell*] * %u num_cells", count);
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "num_cells", &num_cells, NULL)
        && num_cells == tablegeometry->num_cells)
      pass ();
    else
      fail ("TABLEGEOMETRY.num_cells [BL] %u != %u", tablegeometry->num_cells, num_cells);
    num_cells++;
    if (dwg_dynapi_entity_set_value (tablegeometry, "TABLEGEOMETRY", "num_cells", &num_cells, 0)
        && num_cells == tablegeometry->num_cells)
      pass ();
    else
      fail ("TABLEGEOMETRY.num_cells [BL] set+1 %u != %u", tablegeometry->num_cells, num_cells);
    tablegeometry->num_cells--;
  }
  {
    BITCODE_BL numcols;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "numcols", &numcols, NULL)
        && numcols == tablegeometry->numcols)
      pass ();
    else
      fail ("TABLEGEOMETRY.numcols [BL] %u != %u", tablegeometry->numcols, numcols);
    numcols++;
    if (dwg_dynapi_entity_set_value (tablegeometry, "TABLEGEOMETRY", "numcols", &numcols, 0)
        && numcols == tablegeometry->numcols)
      pass ();
    else
      fail ("TABLEGEOMETRY.numcols [BL] set+1 %u != %u", tablegeometry->numcols, numcols);
    tablegeometry->numcols--;
  }
  {
    BITCODE_BL numrows;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "numrows", &numrows, NULL)
        && numrows == tablegeometry->numrows)
      pass ();
    else
      fail ("TABLEGEOMETRY.numrows [BL] %u != %u", tablegeometry->numrows, numrows);
    numrows++;
    if (dwg_dynapi_entity_set_value (tablegeometry, "TABLEGEOMETRY", "numrows", &numrows, 0)
        && numrows == tablegeometry->numrows)
      pass ();
    else
      fail ("TABLEGEOMETRY.numrows [BL] set+1 %u != %u", tablegeometry->numrows, numrows);
    tablegeometry->numrows--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (tablegeometry, "TABLEGEOMETRY", "parent", &parent, NULL)
        && !memcmp (&parent, &tablegeometry->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("TABLEGEOMETRY.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("TABLEGEOMETRY") || is_class_debugging ("TABLEGEOMETRY")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TABLEGEOMETRY", failed);
      failed = 0;
    }
  return failed;
}
static int test_TABLESTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TABLESTYLE *restrict tablestyle = obj->tio.object->tio.TABLESTYLE;
  failed = 0;
  if (!obj_obj || !tablestyle)
    {
      fail ("NULL TABLESTYLE");
      return 1;
    }
  {
    BITCODE_H cellstyle;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "cellstyle", &cellstyle, NULL)
        && !memcmp (&cellstyle, &tablestyle->cellstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TABLESTYLE.cellstyle [H]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "class_version", &class_version, NULL)
        && class_version == tablestyle->class_version)
      pass ();
    else
      fail ("TABLESTYLE.class_version [BS] %hu != %hu", tablestyle->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "class_version", &class_version, 0)
        && class_version == tablestyle->class_version)
      pass ();
    else
      fail ("TABLESTYLE.class_version [BS] set+1 %hu != %hu", tablestyle->class_version, class_version);
    tablestyle->class_version--;
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "flags", &flags, NULL)
        && flags == tablestyle->flags)
      pass ();
    else
      fail ("TABLESTYLE.flags [BS] %hu != %hu", tablestyle->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "flags", &flags, 0)
        && flags == tablestyle->flags)
      pass ();
    else
      fail ("TABLESTYLE.flags [BS] set+1 %hu != %hu", tablestyle->flags, flags);
    tablestyle->flags--;
  }
  {
    BITCODE_BS flow_direction;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "flow_direction", &flow_direction, NULL)
        && flow_direction == tablestyle->flow_direction)
      pass ();
    else
      fail ("TABLESTYLE.flow_direction [BS] %hu != %hu", tablestyle->flow_direction, flow_direction);
    flow_direction++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "flow_direction", &flow_direction, 0)
        && flow_direction == tablestyle->flow_direction)
      pass ();
    else
      fail ("TABLESTYLE.flow_direction [BS] set+1 %hu != %hu", tablestyle->flow_direction, flow_direction);
    tablestyle->flow_direction--;
  }
  {
    BITCODE_BD horiz_cell_margin;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "horiz_cell_margin", &horiz_cell_margin, NULL)
        && horiz_cell_margin == tablestyle->horiz_cell_margin)
      pass ();
    else
      fail ("TABLESTYLE.horiz_cell_margin [BD] %g != %g", tablestyle->horiz_cell_margin, horiz_cell_margin);
    horiz_cell_margin++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "horiz_cell_margin", &horiz_cell_margin, 0)
        && horiz_cell_margin == tablestyle->horiz_cell_margin)
      pass ();
    else
      fail ("TABLESTYLE.horiz_cell_margin [BD] set+1 %g != %g", tablestyle->horiz_cell_margin, horiz_cell_margin);
    tablestyle->horiz_cell_margin--;
  }
  {
    BITCODE_B is_header_suppressed;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "is_header_suppressed", &is_header_suppressed, NULL)
        && is_header_suppressed == tablestyle->is_header_suppressed)
      pass ();
    else
      fail ("TABLESTYLE.is_header_suppressed [B] " FORMAT_B " != " FORMAT_B "", tablestyle->is_header_suppressed, is_header_suppressed);
    is_header_suppressed++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "is_header_suppressed", &is_header_suppressed, 0)
        && is_header_suppressed == tablestyle->is_header_suppressed)
      pass ();
    else
      fail ("TABLESTYLE.is_header_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", tablestyle->is_header_suppressed, is_header_suppressed);
    tablestyle->is_header_suppressed--;
  }
  {
    BITCODE_B is_title_suppressed;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "is_title_suppressed", &is_title_suppressed, NULL)
        && is_title_suppressed == tablestyle->is_title_suppressed)
      pass ();
    else
      fail ("TABLESTYLE.is_title_suppressed [B] " FORMAT_B " != " FORMAT_B "", tablestyle->is_title_suppressed, is_title_suppressed);
    is_title_suppressed++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "is_title_suppressed", &is_title_suppressed, 0)
        && is_title_suppressed == tablestyle->is_title_suppressed)
      pass ();
    else
      fail ("TABLESTYLE.is_title_suppressed [B] set+1 " FORMAT_B " != " FORMAT_B "", tablestyle->is_title_suppressed, is_title_suppressed);
    tablestyle->is_title_suppressed--;
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)tablestyle->name)
           : !tablestyle->name)
      pass ();
    else
      fail ("TABLESTYLE.name [T] '%s' <> '%s'", name, tablestyle->name);
  }
  {
    BITCODE_BL num_rowstyles;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "num_rowstyles", &num_rowstyles, NULL)
        && num_rowstyles == tablestyle->num_rowstyles)
      pass ();
    else
      fail ("TABLESTYLE.num_rowstyles [BL] %u != %u", tablestyle->num_rowstyles, num_rowstyles);
    num_rowstyles++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "num_rowstyles", &num_rowstyles, 0)
        && num_rowstyles == tablestyle->num_rowstyles)
      pass ();
    else
      fail ("TABLESTYLE.num_rowstyles [BL] set+1 %u != %u", tablestyle->num_rowstyles, num_rowstyles);
    tablestyle->num_rowstyles--;
  }
  {
    BITCODE_BL numoverrides;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "numoverrides", &numoverrides, NULL)
        && numoverrides == tablestyle->numoverrides)
      pass ();
    else
      fail ("TABLESTYLE.numoverrides [BL] %u != %u", tablestyle->numoverrides, numoverrides);
    numoverrides++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "numoverrides", &numoverrides, 0)
        && numoverrides == tablestyle->numoverrides)
      pass ();
    else
      fail ("TABLESTYLE.numoverrides [BL] set+1 %u != %u", tablestyle->numoverrides, numoverrides);
    tablestyle->numoverrides--;
  }
  {
    Dwg_TABLESTYLE_CellStyle ovr;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "ovr", &ovr, NULL)
        && !memcmp (&ovr, &tablestyle->ovr, sizeof (Dwg_TABLESTYLE_CellStyle)))
        pass ();
    else
        fail ("TABLESTYLE.ovr [Dwg_TABLESTYLE_CellStyle]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &tablestyle->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("TABLESTYLE.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_TABLESTYLE_rowstyles* rowstyles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "num_rowstyles", &count, NULL)
        && dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "rowstyles", &rowstyles, NULL)
        && rowstyles == tablestyle->rowstyles)
      pass ();
    else
      fail ("TABLESTYLE.rowstyles [Dwg_TABLESTYLE_rowstyles*] * %u num_rowstyles", count);
  }
  {
    Dwg_TABLESTYLE_CellStyle sty;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "sty", &sty, NULL)
        && !memcmp (&sty, &tablestyle->sty, sizeof (Dwg_TABLESTYLE_CellStyle)))
        pass ();
    else
        fail ("TABLESTYLE.sty [Dwg_TABLESTYLE_CellStyle]");
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "unknown_bl1", &unknown_bl1, NULL)
        && unknown_bl1 == tablestyle->unknown_bl1)
      pass ();
    else
      fail ("TABLESTYLE.unknown_bl1 [BL] %u != %u", tablestyle->unknown_bl1, unknown_bl1);
    unknown_bl1++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "unknown_bl1", &unknown_bl1, 0)
        && unknown_bl1 == tablestyle->unknown_bl1)
      pass ();
    else
      fail ("TABLESTYLE.unknown_bl1 [BL] set+1 %u != %u", tablestyle->unknown_bl1, unknown_bl1);
    tablestyle->unknown_bl1--;
  }
  {
    BITCODE_BL unknown_bl2;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "unknown_bl2", &unknown_bl2, NULL)
        && unknown_bl2 == tablestyle->unknown_bl2)
      pass ();
    else
      fail ("TABLESTYLE.unknown_bl2 [BL] %u != %u", tablestyle->unknown_bl2, unknown_bl2);
    unknown_bl2++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "unknown_bl2", &unknown_bl2, 0)
        && unknown_bl2 == tablestyle->unknown_bl2)
      pass ();
    else
      fail ("TABLESTYLE.unknown_bl2 [BL] set+1 %u != %u", tablestyle->unknown_bl2, unknown_bl2);
    tablestyle->unknown_bl2--;
  }
  {
    BITCODE_BL unknown_bl3;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "unknown_bl3", &unknown_bl3, NULL)
        && unknown_bl3 == tablestyle->unknown_bl3)
      pass ();
    else
      fail ("TABLESTYLE.unknown_bl3 [BL] %u != %u", tablestyle->unknown_bl3, unknown_bl3);
    unknown_bl3++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "unknown_bl3", &unknown_bl3, 0)
        && unknown_bl3 == tablestyle->unknown_bl3)
      pass ();
    else
      fail ("TABLESTYLE.unknown_bl3 [BL] set+1 %u != %u", tablestyle->unknown_bl3, unknown_bl3);
    tablestyle->unknown_bl3--;
  }
  {
    BITCODE_RC unknown_rc;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "unknown_rc", &unknown_rc, NULL)
        && unknown_rc == tablestyle->unknown_rc)
      pass ();
    else
      fail ("TABLESTYLE.unknown_rc [RC] %u != %u", tablestyle->unknown_rc, unknown_rc);
    unknown_rc++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "unknown_rc", &unknown_rc, 0)
        && unknown_rc == tablestyle->unknown_rc)
      pass ();
    else
      fail ("TABLESTYLE.unknown_rc [RC] set+1 %u != %u", tablestyle->unknown_rc, unknown_rc);
    tablestyle->unknown_rc--;
  }
  {
    BITCODE_BD vert_cell_margin;
    if (dwg_dynapi_entity_value (tablestyle, "TABLESTYLE", "vert_cell_margin", &vert_cell_margin, NULL)
        && vert_cell_margin == tablestyle->vert_cell_margin)
      pass ();
    else
      fail ("TABLESTYLE.vert_cell_margin [BD] %g != %g", tablestyle->vert_cell_margin, vert_cell_margin);
    vert_cell_margin++;
    if (dwg_dynapi_entity_set_value (tablestyle, "TABLESTYLE", "vert_cell_margin", &vert_cell_margin, 0)
        && vert_cell_margin == tablestyle->vert_cell_margin)
      pass ();
    else
      fail ("TABLESTYLE.vert_cell_margin [BD] set+1 %g != %g", tablestyle->vert_cell_margin, vert_cell_margin);
    tablestyle->vert_cell_margin--;
  }
  if (failed && (is_class_unstable ("TABLESTYLE") || is_class_debugging ("TABLESTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TABLESTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_TEXTOBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TEXTOBJECTCONTEXTDATA *restrict textobjectcontextdata = obj->tio.object->tio.TEXTOBJECTCONTEXTDATA;
  failed = 0;
  if (!obj_obj || !textobjectcontextdata)
    {
      fail ("NULL TEXTOBJECTCONTEXTDATA");
      return 1;
    }
  {
    BITCODE_2RD alignment_pt;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "alignment_pt", &alignment_pt, NULL)
        && !memcmp (&alignment_pt, &textobjectcontextdata->alignment_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("TEXTOBJECTCONTEXTDATA.alignment_pt [2RD]");
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "class_version", &class_version, NULL)
        && class_version == textobjectcontextdata->class_version)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.class_version [BS] %hu != %hu", textobjectcontextdata->class_version, class_version);
    class_version++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "class_version", &class_version, 0)
        && class_version == textobjectcontextdata->class_version)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.class_version [BS] set+1 %hu != %hu", textobjectcontextdata->class_version, class_version);
    textobjectcontextdata->class_version--;
  }
  {
    BITCODE_BS horizontal_mode;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "horizontal_mode", &horizontal_mode, NULL)
        && horizontal_mode == textobjectcontextdata->horizontal_mode)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.horizontal_mode [BS] %hu != %hu", textobjectcontextdata->horizontal_mode, horizontal_mode);
    horizontal_mode++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "horizontal_mode", &horizontal_mode, 0)
        && horizontal_mode == textobjectcontextdata->horizontal_mode)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.horizontal_mode [BS] set+1 %hu != %hu", textobjectcontextdata->horizontal_mode, horizontal_mode);
    textobjectcontextdata->horizontal_mode--;
  }
  {
    BITCODE_2RD ins_pt;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "ins_pt", &ins_pt, NULL)
        && !memcmp (&ins_pt, &textobjectcontextdata->ins_pt, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("TEXTOBJECTCONTEXTDATA.ins_pt [2RD]");
  }
  {
    BITCODE_B is_default;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "is_default", &is_default, NULL)
        && is_default == textobjectcontextdata->is_default)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.is_default [B] " FORMAT_B " != " FORMAT_B "", textobjectcontextdata->is_default, is_default);
    is_default++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "is_default", &is_default, 0)
        && is_default == textobjectcontextdata->is_default)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.is_default [B] set+1 " FORMAT_B " != " FORMAT_B "", textobjectcontextdata->is_default, is_default);
    textobjectcontextdata->is_default--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp (&parent, &textobjectcontextdata->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("TEXTOBJECTCONTEXTDATA.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "rotation", &rotation, NULL)
        && rotation == textobjectcontextdata->rotation)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.rotation [BD] %g != %g", textobjectcontextdata->rotation, rotation);
    rotation++;
    if (dwg_dynapi_entity_set_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "rotation", &rotation, 0)
        && rotation == textobjectcontextdata->rotation)
      pass ();
    else
      fail ("TEXTOBJECTCONTEXTDATA.rotation [BD] set+1 %g != %g", textobjectcontextdata->rotation, rotation);
    textobjectcontextdata->rotation--;
  }
  {
    BITCODE_H scale;
    if (dwg_dynapi_entity_value (textobjectcontextdata, "TEXTOBJECTCONTEXTDATA", "scale", &scale, NULL)
        && !memcmp (&scale, &textobjectcontextdata->scale, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("TEXTOBJECTCONTEXTDATA.scale [H]");
  }
  if (failed && (is_class_unstable ("TEXTOBJECTCONTEXTDATA") || is_class_debugging ("TEXTOBJECTCONTEXTDATA")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TEXTOBJECTCONTEXTDATA", failed);
      failed = 0;
    }
  return failed;
}
static int test_TVDEVICEPROPERTIES (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_TVDEVICEPROPERTIES *restrict tvdeviceproperties = obj->tio.object->tio.TVDEVICEPROPERTIES;
  failed = 0;
  if (!obj_obj || !tvdeviceproperties)
    {
      fail ("NULL TVDEVICEPROPERTIES");
      return 1;
    }
  {
    BITCODE_BLL alt_hlt;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "alt_hlt", &alt_hlt, NULL)
        && alt_hlt == tvdeviceproperties->alt_hlt)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.alt_hlt [BLL] " FORMAT_BLL " != " FORMAT_BLL "", tvdeviceproperties->alt_hlt, alt_hlt);
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "alt_hlt", &alt_hlt, 0)
        && alt_hlt == tvdeviceproperties->alt_hlt)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.alt_hlt [BLL] set+1 " FORMAT_BLL " != " FORMAT_BLL "", tvdeviceproperties->alt_hlt, alt_hlt);
    tvdeviceproperties->alt_hlt--;
  }
  {
    BITCODE_BLL alt_hltcolor;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "alt_hltcolor", &alt_hltcolor, NULL)
        && alt_hltcolor == tvdeviceproperties->alt_hltcolor)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.alt_hltcolor [BLL] " FORMAT_BLL " != " FORMAT_BLL "", tvdeviceproperties->alt_hltcolor, alt_hltcolor);
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "alt_hltcolor", &alt_hltcolor, 0)
        && alt_hltcolor == tvdeviceproperties->alt_hltcolor)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.alt_hltcolor [BLL] set+1 " FORMAT_BLL " != " FORMAT_BLL "", tvdeviceproperties->alt_hltcolor, alt_hltcolor);
    tvdeviceproperties->alt_hltcolor--;
  }
  {
    BITCODE_BD antialiasing_level;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "antialiasing_level", &antialiasing_level, NULL)
        && antialiasing_level == tvdeviceproperties->antialiasing_level)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.antialiasing_level [BD] %g != %g", tvdeviceproperties->antialiasing_level, antialiasing_level);
    antialiasing_level++;
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "antialiasing_level", &antialiasing_level, 0)
        && antialiasing_level == tvdeviceproperties->antialiasing_level)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.antialiasing_level [BD] set+1 %g != %g", tvdeviceproperties->antialiasing_level, antialiasing_level);
    tvdeviceproperties->antialiasing_level--;
  }
  {
    BITCODE_BD bd2;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "bd2", &bd2, NULL)
        && bd2 == tvdeviceproperties->bd2)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.bd2 [BD] %g != %g", tvdeviceproperties->bd2, bd2);
    bd2++;
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "bd2", &bd2, 0)
        && bd2 == tvdeviceproperties->bd2)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.bd2 [BD] set+1 %g != %g", tvdeviceproperties->bd2, bd2);
    tvdeviceproperties->bd2--;
  }
  {
    BITCODE_BL blending_mode;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "blending_mode", &blending_mode, NULL)
        && blending_mode == tvdeviceproperties->blending_mode)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.blending_mode [BL] %u != %u", tvdeviceproperties->blending_mode, blending_mode);
    blending_mode++;
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "blending_mode", &blending_mode, 0)
        && blending_mode == tvdeviceproperties->blending_mode)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.blending_mode [BL] set+1 %u != %u", tvdeviceproperties->blending_mode, blending_mode);
    tvdeviceproperties->blending_mode--;
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "flags", &flags, NULL)
        && flags == tvdeviceproperties->flags)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.flags [BL] %u != %u", tvdeviceproperties->flags, flags);
    flags++;
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "flags", &flags, 0)
        && flags == tvdeviceproperties->flags)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.flags [BL] set+1 %u != %u", tvdeviceproperties->flags, flags);
    tvdeviceproperties->flags--;
  }
  {
    BITCODE_BLL geom_shader_usage;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "geom_shader_usage", &geom_shader_usage, NULL)
        && geom_shader_usage == tvdeviceproperties->geom_shader_usage)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.geom_shader_usage [BLL] " FORMAT_BLL " != " FORMAT_BLL "", tvdeviceproperties->geom_shader_usage, geom_shader_usage);
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "geom_shader_usage", &geom_shader_usage, 0)
        && geom_shader_usage == tvdeviceproperties->geom_shader_usage)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.geom_shader_usage [BLL] set+1 " FORMAT_BLL " != " FORMAT_BLL "", tvdeviceproperties->geom_shader_usage, geom_shader_usage);
    tvdeviceproperties->geom_shader_usage--;
  }
  {
    BITCODE_BS max_regen_threads;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "max_regen_threads", &max_regen_threads, NULL)
        && max_regen_threads == tvdeviceproperties->max_regen_threads)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.max_regen_threads [BS] %hu != %hu", tvdeviceproperties->max_regen_threads, max_regen_threads);
    max_regen_threads++;
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "max_regen_threads", &max_regen_threads, 0)
        && max_regen_threads == tvdeviceproperties->max_regen_threads)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.max_regen_threads [BS] set+1 %hu != %hu", tvdeviceproperties->max_regen_threads, max_regen_threads);
    tvdeviceproperties->max_regen_threads--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "parent", &parent, NULL)
        && !memcmp (&parent, &tvdeviceproperties->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("TVDEVICEPROPERTIES.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BL use_lut_palette;
    if (dwg_dynapi_entity_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "use_lut_palette", &use_lut_palette, NULL)
        && use_lut_palette == tvdeviceproperties->use_lut_palette)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.use_lut_palette [BL] %u != %u", tvdeviceproperties->use_lut_palette, use_lut_palette);
    use_lut_palette++;
    if (dwg_dynapi_entity_set_value (tvdeviceproperties, "TVDEVICEPROPERTIES", "use_lut_palette", &use_lut_palette, 0)
        && use_lut_palette == tvdeviceproperties->use_lut_palette)
      pass ();
    else
      fail ("TVDEVICEPROPERTIES.use_lut_palette [BL] set+1 %u != %u", tvdeviceproperties->use_lut_palette, use_lut_palette);
    tvdeviceproperties->use_lut_palette--;
  }
  if (failed && (is_class_unstable ("TVDEVICEPROPERTIES") || is_class_debugging ("TVDEVICEPROPERTIES")))
    {
      ok ("%s failed %d tests (TODO unstable)", "TVDEVICEPROPERTIES", failed);
      failed = 0;
    }
  return failed;
}
static int test_UCS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_UCS *restrict ucs = obj->tio.object->tio.UCS;
  failed = 0;
  if (!obj_obj || !ucs)
    {
      fail ("NULL UCS");
      return 1;
    }
  {
    BITCODE_BS UCSORTHOVIEW;
    if (dwg_dynapi_entity_value (ucs, "UCS", "UCSORTHOVIEW", &UCSORTHOVIEW, NULL)
        && UCSORTHOVIEW == ucs->UCSORTHOVIEW)
      pass ();
    else
      fail ("UCS.UCSORTHOVIEW [BS] %hu != %hu", ucs->UCSORTHOVIEW, UCSORTHOVIEW);
    UCSORTHOVIEW++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "UCSORTHOVIEW", &UCSORTHOVIEW, 0)
        && UCSORTHOVIEW == ucs->UCSORTHOVIEW)
      pass ();
    else
      fail ("UCS.UCSORTHOVIEW [BS] set+1 %hu != %hu", ucs->UCSORTHOVIEW, UCSORTHOVIEW);
    ucs->UCSORTHOVIEW--;
  }
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (ucs, "UCS", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &ucs->base_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("UCS.base_ucs [H]");
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (ucs, "UCS", "flag", &flag, NULL)
        && flag == ucs->flag)
      pass ();
    else
      fail ("UCS.flag [RC] %u != %u", ucs->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "flag", &flag, 0)
        && flag == ucs->flag)
      pass ();
    else
      fail ("UCS.flag [RC] set+1 %u != %u", ucs->flag, flag);
    ucs->flag--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (ucs, "UCS", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == ucs->is_xref_dep)
      pass ();
    else
      fail ("UCS.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", ucs->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == ucs->is_xref_dep)
      pass ();
    else
      fail ("UCS.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", ucs->is_xref_dep, is_xref_dep);
    ucs->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (ucs, "UCS", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == ucs->is_xref_ref)
      pass ();
    else
      fail ("UCS.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", ucs->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == ucs->is_xref_ref)
      pass ();
    else
      fail ("UCS.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", ucs->is_xref_ref, is_xref_ref);
    ucs->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (ucs, "UCS", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == ucs->is_xref_resolved)
      pass ();
    else
      fail ("UCS.is_xref_resolved [BS] %hu != %hu", ucs->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == ucs->is_xref_resolved)
      pass ();
    else
      fail ("UCS.is_xref_resolved [BS] set+1 %hu != %hu", ucs->is_xref_resolved, is_xref_resolved);
    ucs->is_xref_resolved--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (ucs, "UCS", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)ucs->name)
           : !ucs->name)
      pass ();
    else
      fail ("UCS.name [TV] '%s' <> '%s'", name, ucs->name);
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (ucs, "UCS", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &ucs->named_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("UCS.named_ucs [H]");
  }
  {
    BITCODE_BS num_orthopts;
    if (dwg_dynapi_entity_value (ucs, "UCS", "num_orthopts", &num_orthopts, NULL)
        && num_orthopts == ucs->num_orthopts)
      pass ();
    else
      fail ("UCS.num_orthopts [BS] %hu != %hu", ucs->num_orthopts, num_orthopts);
    num_orthopts++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "num_orthopts", &num_orthopts, 0)
        && num_orthopts == ucs->num_orthopts)
      pass ();
    else
      fail ("UCS.num_orthopts [BS] set+1 %hu != %hu", ucs->num_orthopts, num_orthopts);
    ucs->num_orthopts--;
  }
  {
    Dwg_UCS_orthopts* orthopts;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (ucs, "UCS", "num_orthopts", &count, NULL)
        && dwg_dynapi_entity_value (ucs, "UCS", "orthopts", &orthopts, NULL)
        && orthopts == ucs->orthopts)
      pass ();
    else
      fail ("UCS.orthopts [Dwg_UCS_orthopts*] * %u num_orthopts", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ucs, "UCS", "parent", &parent, NULL)
        && !memcmp (&parent, &ucs->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("UCS.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value (ucs, "UCS", "ucs_elevation", &ucs_elevation, NULL)
        && ucs_elevation == ucs->ucs_elevation)
      pass ();
    else
      fail ("UCS.ucs_elevation [BD] %g != %g", ucs->ucs_elevation, ucs_elevation);
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "ucs_elevation", &ucs_elevation, 0)
        && ucs_elevation == ucs->ucs_elevation)
      pass ();
    else
      fail ("UCS.ucs_elevation [BD] set+1 %g != %g", ucs->ucs_elevation, ucs_elevation);
    ucs->ucs_elevation--;
  }
  {
    BITCODE_3BD ucsorg;
    if (dwg_dynapi_entity_value (ucs, "UCS", "ucsorg", &ucsorg, NULL)
        && !memcmp (&ucsorg, &ucs->ucsorg, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("UCS.ucsorg [3BD]");
  }
  {
    BITCODE_3BD ucsxdir;
    if (dwg_dynapi_entity_value (ucs, "UCS", "ucsxdir", &ucsxdir, NULL)
        && !memcmp (&ucsxdir, &ucs->ucsxdir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("UCS.ucsxdir [3BD]");
  }
  {
    BITCODE_3BD ucsydir;
    if (dwg_dynapi_entity_value (ucs, "UCS", "ucsydir", &ucsydir, NULL)
        && !memcmp (&ucsydir, &ucs->ucsydir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("UCS.ucsydir [3BD]");
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (ucs, "UCS", "used", &used, NULL)
        && used == ucs->used)
      pass ();
    else
      fail ("UCS.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", ucs->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (ucs, "UCS", "used", &used, 0)
        && used == ucs->used)
      pass ();
    else
      fail ("UCS.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", ucs->used, used);
    ucs->used--;
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (ucs, "UCS", "xref", &xref, NULL)
        && !memcmp (&xref, &ucs->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("UCS.xref [H]");
  }
  if (failed && (is_class_unstable ("UCS") || is_class_debugging ("UCS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "UCS", failed);
      failed = 0;
    }
  return failed;
}
static int test_UCS_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_UCS_CONTROL *restrict ucs_control = obj->tio.object->tio.UCS_CONTROL;
  failed = 0;
  if (!obj_obj || !ucs_control)
    {
      fail ("NULL UCS_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "entries", &entries, NULL)
        && entries == ucs_control->entries)
      pass ();
    else
      fail ("UCS_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == ucs_control->flags_r11)
      pass ();
    else
      fail ("UCS_CONTROL.flags_r11 [RS] %hu != %hu", ucs_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (ucs_control, "UCS_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == ucs_control->flags_r11)
      pass ();
    else
      fail ("UCS_CONTROL.flags_r11 [RS] set+1 %hu != %hu", ucs_control->flags_r11, flags_r11);
    ucs_control->flags_r11--;
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == ucs_control->num_entries)
      pass ();
    else
      fail ("UCS_CONTROL.num_entries [BS] %hu != %hu", ucs_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (ucs_control, "UCS_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == ucs_control->num_entries)
      pass ();
    else
      fail ("UCS_CONTROL.num_entries [BS] set+1 %hu != %hu", ucs_control->num_entries, num_entries);
    ucs_control->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (ucs_control, "UCS_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &ucs_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("UCS_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("UCS_CONTROL") || is_class_debugging ("UCS_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "UCS_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_VBA_PROJECT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VBA_PROJECT *restrict vba_project = obj->tio.object->tio.VBA_PROJECT;
  failed = 0;
  if (!obj_obj || !vba_project)
    {
      fail ("NULL VBA_PROJECT");
      return 1;
    }
  {
    BITCODE_TF data;
    if (dwg_dynapi_entity_value (vba_project, "VBA_PROJECT", "data", &data, NULL)
        && !memcmp (&data, &vba_project->data, sizeof (BITCODE_TF)))
        pass ();
    else
        fail ("VBA_PROJECT.data [TF]");
  }
  {
    BITCODE_BL data_size;
    if (dwg_dynapi_entity_value (vba_project, "VBA_PROJECT", "data_size", &data_size, NULL)
        && data_size == vba_project->data_size)
      pass ();
    else
      fail ("VBA_PROJECT.data_size [BL] %u != %u", vba_project->data_size, data_size);
    data_size++;
    if (dwg_dynapi_entity_set_value (vba_project, "VBA_PROJECT", "data_size", &data_size, 0)
        && data_size == vba_project->data_size)
      pass ();
    else
      fail ("VBA_PROJECT.data_size [BL] set+1 %u != %u", vba_project->data_size, data_size);
    vba_project->data_size--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vba_project, "VBA_PROJECT", "parent", &parent, NULL)
        && !memcmp (&parent, &vba_project->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("VBA_PROJECT.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("VBA_PROJECT") || is_class_debugging ("VBA_PROJECT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VBA_PROJECT", failed);
      failed = 0;
    }
  return failed;
}
static int test_VIEW (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VIEW *restrict view = obj->tio.object->tio.VIEW;
  failed = 0;
  if (!obj_obj || !view)
    {
      fail ("NULL VIEW");
      return 1;
    }
  {
    BITCODE_BS UCSORTHOVIEW;
    if (dwg_dynapi_entity_value (view, "VIEW", "UCSORTHOVIEW", &UCSORTHOVIEW, NULL)
        && UCSORTHOVIEW == view->UCSORTHOVIEW)
      pass ();
    else
      fail ("VIEW.UCSORTHOVIEW [BS] %hu != %hu", view->UCSORTHOVIEW, UCSORTHOVIEW);
    UCSORTHOVIEW++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "UCSORTHOVIEW", &UCSORTHOVIEW, 0)
        && UCSORTHOVIEW == view->UCSORTHOVIEW)
      pass ();
    else
      fail ("VIEW.UCSORTHOVIEW [BS] set+1 %hu != %hu", view->UCSORTHOVIEW, UCSORTHOVIEW);
    view->UCSORTHOVIEW--;
  }
  {
    BITCODE_2RD VIEWCTR;
    if (dwg_dynapi_entity_value (view, "VIEW", "VIEWCTR", &VIEWCTR, NULL)
        && !memcmp (&VIEWCTR, &view->VIEWCTR, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VIEW.VIEWCTR [2RD]");
  }
  {
    BITCODE_3BD VIEWDIR;
    if (dwg_dynapi_entity_value (view, "VIEW", "VIEWDIR", &VIEWDIR, NULL)
        && !memcmp (&VIEWDIR, &view->VIEWDIR, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEW.VIEWDIR [3BD]");
  }
  {
    BITCODE_4BITS VIEWMODE;
    if (dwg_dynapi_entity_value (view, "VIEW", "VIEWMODE", &VIEWMODE, NULL)
        && VIEWMODE == view->VIEWMODE)
      pass ();
    else
      fail ("VIEW.VIEWMODE [4BITS] " FORMAT_4BITS " != " FORMAT_4BITS "", view->VIEWMODE, VIEWMODE);
    if (dwg_dynapi_entity_set_value (view, "VIEW", "VIEWMODE", &VIEWMODE, 0)
        && VIEWMODE == view->VIEWMODE)
      pass ();
    else
      fail ("VIEW.VIEWMODE [4BITS] set+1 " FORMAT_4BITS " != " FORMAT_4BITS "", view->VIEWMODE, VIEWMODE);
    view->VIEWMODE--;
  }
  {
    BITCODE_BD VIEWSIZE;
    if (dwg_dynapi_entity_value (view, "VIEW", "VIEWSIZE", &VIEWSIZE, NULL)
        && VIEWSIZE == view->VIEWSIZE)
      pass ();
    else
      fail ("VIEW.VIEWSIZE [BD] %g != %g", view->VIEWSIZE, VIEWSIZE);
    VIEWSIZE++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "VIEWSIZE", &VIEWSIZE, 0)
        && VIEWSIZE == view->VIEWSIZE)
      pass ();
    else
      fail ("VIEW.VIEWSIZE [BD] set+1 %g != %g", view->VIEWSIZE, VIEWSIZE);
    view->VIEWSIZE--;
  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value (view, "VIEW", "ambient_color", &ambient_color, NULL)
        && !memcmp (&ambient_color, &view->ambient_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VIEW.ambient_color [CMC]");
  }
  {
    BITCODE_BD aspect_ratio;
    if (dwg_dynapi_entity_value (view, "VIEW", "aspect_ratio", &aspect_ratio, NULL)
        && aspect_ratio == view->aspect_ratio)
      pass ();
    else
      fail ("VIEW.aspect_ratio [BD] %g != %g", view->aspect_ratio, aspect_ratio);
    aspect_ratio++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "aspect_ratio", &aspect_ratio, 0)
        && aspect_ratio == view->aspect_ratio)
      pass ();
    else
      fail ("VIEW.aspect_ratio [BD] set+1 %g != %g", view->aspect_ratio, aspect_ratio);
    view->aspect_ratio--;
  }
  {
    BITCODE_B associated_ucs;
    if (dwg_dynapi_entity_value (view, "VIEW", "associated_ucs", &associated_ucs, NULL)
        && associated_ucs == view->associated_ucs)
      pass ();
    else
      fail ("VIEW.associated_ucs [B] " FORMAT_B " != " FORMAT_B "", view->associated_ucs, associated_ucs);
    associated_ucs++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "associated_ucs", &associated_ucs, 0)
        && associated_ucs == view->associated_ucs)
      pass ();
    else
      fail ("VIEW.associated_ucs [B] set+1 " FORMAT_B " != " FORMAT_B "", view->associated_ucs, associated_ucs);
    view->associated_ucs--;
  }
  {
    BITCODE_BD back_clip_z;
    if (dwg_dynapi_entity_value (view, "VIEW", "back_clip_z", &back_clip_z, NULL)
        && back_clip_z == view->back_clip_z)
      pass ();
    else
      fail ("VIEW.back_clip_z [BD] %g != %g", view->back_clip_z, back_clip_z);
    back_clip_z++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "back_clip_z", &back_clip_z, 0)
        && back_clip_z == view->back_clip_z)
      pass ();
    else
      fail ("VIEW.back_clip_z [BD] set+1 %g != %g", view->back_clip_z, back_clip_z);
    view->back_clip_z--;
  }
  {
    BITCODE_H background;
    if (dwg_dynapi_entity_value (view, "VIEW", "background", &background, NULL)
        && !memcmp (&background, &view->background, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEW.background [H]");
  }
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (view, "VIEW", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &view->base_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEW.base_ucs [H]");
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value (view, "VIEW", "brightness", &brightness, NULL)
        && brightness == view->brightness)
      pass ();
    else
      fail ("VIEW.brightness [BD] %g != %g", view->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "brightness", &brightness, 0)
        && brightness == view->brightness)
      pass ();
    else
      fail ("VIEW.brightness [BD] set+1 %g != %g", view->brightness, brightness);
    view->brightness--;
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value (view, "VIEW", "contrast", &contrast, NULL)
        && contrast == view->contrast)
      pass ();
    else
      fail ("VIEW.contrast [BD] %g != %g", view->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "contrast", &contrast, 0)
        && contrast == view->contrast)
      pass ();
    else
      fail ("VIEW.contrast [BD] set+1 %g != %g", view->contrast, contrast);
    view->contrast--;
  }
  {
    BITCODE_RC default_lightning_type;
    if (dwg_dynapi_entity_value (view, "VIEW", "default_lightning_type", &default_lightning_type, NULL)
        && default_lightning_type == view->default_lightning_type)
      pass ();
    else
      fail ("VIEW.default_lightning_type [RC] %u != %u", view->default_lightning_type, default_lightning_type);
    default_lightning_type++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "default_lightning_type", &default_lightning_type, 0)
        && default_lightning_type == view->default_lightning_type)
      pass ();
    else
      fail ("VIEW.default_lightning_type [RC] set+1 %u != %u", view->default_lightning_type, default_lightning_type);
    view->default_lightning_type--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (view, "VIEW", "flag", &flag, NULL)
        && flag == view->flag)
      pass ();
    else
      fail ("VIEW.flag [RC] %u != %u", view->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "flag", &flag, 0)
        && flag == view->flag)
      pass ();
    else
      fail ("VIEW.flag [RC] set+1 %u != %u", view->flag, flag);
    view->flag--;
  }
  {
    BITCODE_RS flag_3d;
    if (dwg_dynapi_entity_value (view, "VIEW", "flag_3d", &flag_3d, NULL)
        && flag_3d == view->flag_3d)
      pass ();
    else
      fail ("VIEW.flag_3d [RS] %hu != %hu", view->flag_3d, flag_3d);
    flag_3d++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "flag_3d", &flag_3d, 0)
        && flag_3d == view->flag_3d)
      pass ();
    else
      fail ("VIEW.flag_3d [RS] set+1 %hu != %hu", view->flag_3d, flag_3d);
    view->flag_3d--;
  }
  {
    BITCODE_BD front_clip_z;
    if (dwg_dynapi_entity_value (view, "VIEW", "front_clip_z", &front_clip_z, NULL)
        && front_clip_z == view->front_clip_z)
      pass ();
    else
      fail ("VIEW.front_clip_z [BD] %g != %g", view->front_clip_z, front_clip_z);
    front_clip_z++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "front_clip_z", &front_clip_z, 0)
        && front_clip_z == view->front_clip_z)
      pass ();
    else
      fail ("VIEW.front_clip_z [BD] set+1 %g != %g", view->front_clip_z, front_clip_z);
    view->front_clip_z--;
  }
  {
    BITCODE_B is_camera_plottable;
    if (dwg_dynapi_entity_value (view, "VIEW", "is_camera_plottable", &is_camera_plottable, NULL)
        && is_camera_plottable == view->is_camera_plottable)
      pass ();
    else
      fail ("VIEW.is_camera_plottable [B] " FORMAT_B " != " FORMAT_B "", view->is_camera_plottable, is_camera_plottable);
    is_camera_plottable++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "is_camera_plottable", &is_camera_plottable, 0)
        && is_camera_plottable == view->is_camera_plottable)
      pass ();
    else
      fail ("VIEW.is_camera_plottable [B] set+1 " FORMAT_B " != " FORMAT_B "", view->is_camera_plottable, is_camera_plottable);
    view->is_camera_plottable--;
  }
  {
    BITCODE_B is_pspace;
    if (dwg_dynapi_entity_value (view, "VIEW", "is_pspace", &is_pspace, NULL)
        && is_pspace == view->is_pspace)
      pass ();
    else
      fail ("VIEW.is_pspace [B] " FORMAT_B " != " FORMAT_B "", view->is_pspace, is_pspace);
    is_pspace++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "is_pspace", &is_pspace, 0)
        && is_pspace == view->is_pspace)
      pass ();
    else
      fail ("VIEW.is_pspace [B] set+1 " FORMAT_B " != " FORMAT_B "", view->is_pspace, is_pspace);
    view->is_pspace--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (view, "VIEW", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == view->is_xref_dep)
      pass ();
    else
      fail ("VIEW.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", view->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == view->is_xref_dep)
      pass ();
    else
      fail ("VIEW.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", view->is_xref_dep, is_xref_dep);
    view->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (view, "VIEW", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == view->is_xref_ref)
      pass ();
    else
      fail ("VIEW.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", view->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == view->is_xref_ref)
      pass ();
    else
      fail ("VIEW.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", view->is_xref_ref, is_xref_ref);
    view->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (view, "VIEW", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == view->is_xref_resolved)
      pass ();
    else
      fail ("VIEW.is_xref_resolved [BS] %hu != %hu", view->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == view->is_xref_resolved)
      pass ();
    else
      fail ("VIEW.is_xref_resolved [BS] set+1 %hu != %hu", view->is_xref_resolved, is_xref_resolved);
    view->is_xref_resolved--;
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value (view, "VIEW", "lens_length", &lens_length, NULL)
        && lens_length == view->lens_length)
      pass ();
    else
      fail ("VIEW.lens_length [BD] %g != %g", view->lens_length, lens_length);
    lens_length++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "lens_length", &lens_length, 0)
        && lens_length == view->lens_length)
      pass ();
    else
      fail ("VIEW.lens_length [BD] set+1 %g != %g", view->lens_length, lens_length);
    view->lens_length--;
  }
  {
    BITCODE_H livesection;
    if (dwg_dynapi_entity_value (view, "VIEW", "livesection", &livesection, NULL)
        && !memcmp (&livesection, &view->livesection, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEW.livesection [H]");
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (view, "VIEW", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)view->name)
           : !view->name)
      pass ();
    else
      fail ("VIEW.name [TV] '%s' <> '%s'", name, view->name);
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (view, "VIEW", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &view->named_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEW.named_ucs [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (view, "VIEW", "parent", &parent, NULL)
        && !memcmp (&parent, &view->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("VIEW.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value (view, "VIEW", "render_mode", &render_mode, NULL)
        && render_mode == view->render_mode)
      pass ();
    else
      fail ("VIEW.render_mode [RC] %u != %u", view->render_mode, render_mode);
    render_mode++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "render_mode", &render_mode, 0)
        && render_mode == view->render_mode)
      pass ();
    else
      fail ("VIEW.render_mode [RC] set+1 %u != %u", view->render_mode, render_mode);
    view->render_mode--;
  }
  {
    BITCODE_H sun;
    if (dwg_dynapi_entity_value (view, "VIEW", "sun", &sun, NULL)
        && !memcmp (&sun, &view->sun, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEW.sun [H]");
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value (view, "VIEW", "twist_angle", &twist_angle, NULL)
        && twist_angle == view->twist_angle)
      pass ();
    else
      fail ("VIEW.twist_angle [BD] %g != %g", view->twist_angle, twist_angle);
    twist_angle++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "twist_angle", &twist_angle, 0)
        && twist_angle == view->twist_angle)
      pass ();
    else
      fail ("VIEW.twist_angle [BD] set+1 %g != %g", view->twist_angle, twist_angle);
    view->twist_angle--;
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value (view, "VIEW", "ucs_elevation", &ucs_elevation, NULL)
        && ucs_elevation == view->ucs_elevation)
      pass ();
    else
      fail ("VIEW.ucs_elevation [BD] %g != %g", view->ucs_elevation, ucs_elevation);
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "ucs_elevation", &ucs_elevation, 0)
        && ucs_elevation == view->ucs_elevation)
      pass ();
    else
      fail ("VIEW.ucs_elevation [BD] set+1 %g != %g", view->ucs_elevation, ucs_elevation);
    view->ucs_elevation--;
  }
  {
    BITCODE_3BD ucsorg;
    if (dwg_dynapi_entity_value (view, "VIEW", "ucsorg", &ucsorg, NULL)
        && !memcmp (&ucsorg, &view->ucsorg, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEW.ucsorg [3BD]");
  }
  {
    BITCODE_3BD ucsxdir;
    if (dwg_dynapi_entity_value (view, "VIEW", "ucsxdir", &ucsxdir, NULL)
        && !memcmp (&ucsxdir, &view->ucsxdir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEW.ucsxdir [3BD]");
  }
  {
    BITCODE_3BD ucsydir;
    if (dwg_dynapi_entity_value (view, "VIEW", "ucsydir", &ucsydir, NULL)
        && !memcmp (&ucsydir, &view->ucsydir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEW.ucsydir [3BD]");
  }
  {
    BITCODE_RC unknown_r11;
    if (dwg_dynapi_entity_value (view, "VIEW", "unknown_r11", &unknown_r11, NULL)
        && unknown_r11 == view->unknown_r11)
      pass ();
    else
      fail ("VIEW.unknown_r11 [RC] %u != %u", view->unknown_r11, unknown_r11);
    unknown_r11++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "unknown_r11", &unknown_r11, 0)
        && unknown_r11 == view->unknown_r11)
      pass ();
    else
      fail ("VIEW.unknown_r11 [RC] set+1 %u != %u", view->unknown_r11, unknown_r11);
    view->unknown_r11--;
  }
  {
    BITCODE_RC unknown_r2;
    if (dwg_dynapi_entity_value (view, "VIEW", "unknown_r2", &unknown_r2, NULL)
        && unknown_r2 == view->unknown_r2)
      pass ();
    else
      fail ("VIEW.unknown_r2 [RC] %u != %u", view->unknown_r2, unknown_r2);
    unknown_r2++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "unknown_r2", &unknown_r2, 0)
        && unknown_r2 == view->unknown_r2)
      pass ();
    else
      fail ("VIEW.unknown_r2 [RC] set+1 %u != %u", view->unknown_r2, unknown_r2);
    view->unknown_r2--;
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value (view, "VIEW", "use_default_lights", &use_default_lights, NULL)
        && use_default_lights == view->use_default_lights)
      pass ();
    else
      fail ("VIEW.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", view->use_default_lights, use_default_lights);
    use_default_lights++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "use_default_lights", &use_default_lights, 0)
        && use_default_lights == view->use_default_lights)
      pass ();
    else
      fail ("VIEW.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", view->use_default_lights, use_default_lights);
    view->use_default_lights--;
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (view, "VIEW", "used", &used, NULL)
        && used == view->used)
      pass ();
    else
      fail ("VIEW.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", view->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "used", &used, 0)
        && used == view->used)
      pass ();
    else
      fail ("VIEW.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", view->used, used);
    view->used--;
  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value (view, "VIEW", "view_target", &view_target, NULL)
        && !memcmp (&view_target, &view->view_target, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VIEW.view_target [3BD]");
  }
  {
    BITCODE_BD view_width;
    if (dwg_dynapi_entity_value (view, "VIEW", "view_width", &view_width, NULL)
        && view_width == view->view_width)
      pass ();
    else
      fail ("VIEW.view_width [BD] %g != %g", view->view_width, view_width);
    view_width++;
    if (dwg_dynapi_entity_set_value (view, "VIEW", "view_width", &view_width, 0)
        && view_width == view->view_width)
      pass ();
    else
      fail ("VIEW.view_width [BD] set+1 %g != %g", view->view_width, view_width);
    view->view_width--;
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (view, "VIEW", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &view->visualstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEW.visualstyle [H]");
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (view, "VIEW", "xref", &xref, NULL)
        && !memcmp (&xref, &view->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VIEW.xref [H]");
  }
  if (failed && (is_class_unstable ("VIEW") || is_class_debugging ("VIEW")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VIEW", failed);
      failed = 0;
    }
  return failed;
}
static int test_VIEW_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VIEW_CONTROL *restrict view_control = obj->tio.object->tio.VIEW_CONTROL;
  failed = 0;
  if (!obj_obj || !view_control)
    {
      fail ("NULL VIEW_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "entries", &entries, NULL)
        && entries == view_control->entries)
      pass ();
    else
      fail ("VIEW_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == view_control->flags_r11)
      pass ();
    else
      fail ("VIEW_CONTROL.flags_r11 [RS] %hu != %hu", view_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (view_control, "VIEW_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == view_control->flags_r11)
      pass ();
    else
      fail ("VIEW_CONTROL.flags_r11 [RS] set+1 %hu != %hu", view_control->flags_r11, flags_r11);
    view_control->flags_r11--;
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == view_control->num_entries)
      pass ();
    else
      fail ("VIEW_CONTROL.num_entries [BS] %hu != %hu", view_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (view_control, "VIEW_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == view_control->num_entries)
      pass ();
    else
      fail ("VIEW_CONTROL.num_entries [BS] set+1 %hu != %hu", view_control->num_entries, num_entries);
    view_control->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (view_control, "VIEW_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &view_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("VIEW_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("VIEW_CONTROL") || is_class_debugging ("VIEW_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VIEW_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_VISUALSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VISUALSTYLE *restrict visualstyle = obj->tio.object->tio.VISUALSTYLE;
  failed = 0;
  if (!obj_obj || !visualstyle)
    {
      fail ("NULL VISUALSTYLE");
      return 1;
    }
  {
    BITCODE_B b_prop1c;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop1c", &b_prop1c, NULL)
        && b_prop1c == visualstyle->b_prop1c)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1c [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop1c, b_prop1c);
    b_prop1c++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop1c", &b_prop1c, 0)
        && b_prop1c == visualstyle->b_prop1c)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1c [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop1c, b_prop1c);
    visualstyle->b_prop1c--;
  }
  {
    BITCODE_BS b_prop1c_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop1c_int", &b_prop1c_int, NULL)
        && b_prop1c_int == visualstyle->b_prop1c_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1c_int [BS] %hu != %hu", visualstyle->b_prop1c_int, b_prop1c_int);
    b_prop1c_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop1c_int", &b_prop1c_int, 0)
        && b_prop1c_int == visualstyle->b_prop1c_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1c_int [BS] set+1 %hu != %hu", visualstyle->b_prop1c_int, b_prop1c_int);
    visualstyle->b_prop1c_int--;
  }
  {
    BITCODE_B b_prop1d;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop1d", &b_prop1d, NULL)
        && b_prop1d == visualstyle->b_prop1d)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1d [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop1d, b_prop1d);
    b_prop1d++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop1d", &b_prop1d, 0)
        && b_prop1d == visualstyle->b_prop1d)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1d [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop1d, b_prop1d);
    visualstyle->b_prop1d--;
  }
  {
    BITCODE_BS b_prop1d_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop1d_int", &b_prop1d_int, NULL)
        && b_prop1d_int == visualstyle->b_prop1d_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1d_int [BS] %hu != %hu", visualstyle->b_prop1d_int, b_prop1d_int);
    b_prop1d_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop1d_int", &b_prop1d_int, 0)
        && b_prop1d_int == visualstyle->b_prop1d_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1d_int [BS] set+1 %hu != %hu", visualstyle->b_prop1d_int, b_prop1d_int);
    visualstyle->b_prop1d_int--;
  }
  {
    BITCODE_B b_prop1e;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop1e", &b_prop1e, NULL)
        && b_prop1e == visualstyle->b_prop1e)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1e [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop1e, b_prop1e);
    b_prop1e++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop1e", &b_prop1e, 0)
        && b_prop1e == visualstyle->b_prop1e)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1e [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop1e, b_prop1e);
    visualstyle->b_prop1e--;
  }
  {
    BITCODE_BS b_prop1e_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop1e_int", &b_prop1e_int, NULL)
        && b_prop1e_int == visualstyle->b_prop1e_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1e_int [BS] %hu != %hu", visualstyle->b_prop1e_int, b_prop1e_int);
    b_prop1e_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop1e_int", &b_prop1e_int, 0)
        && b_prop1e_int == visualstyle->b_prop1e_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1e_int [BS] set+1 %hu != %hu", visualstyle->b_prop1e_int, b_prop1e_int);
    visualstyle->b_prop1e_int--;
  }
  {
    BITCODE_B b_prop1f;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop1f", &b_prop1f, NULL)
        && b_prop1f == visualstyle->b_prop1f)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1f [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop1f, b_prop1f);
    b_prop1f++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop1f", &b_prop1f, 0)
        && b_prop1f == visualstyle->b_prop1f)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1f [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop1f, b_prop1f);
    visualstyle->b_prop1f--;
  }
  {
    BITCODE_BS b_prop1f_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop1f_int", &b_prop1f_int, NULL)
        && b_prop1f_int == visualstyle->b_prop1f_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1f_int [BS] %hu != %hu", visualstyle->b_prop1f_int, b_prop1f_int);
    b_prop1f_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop1f_int", &b_prop1f_int, 0)
        && b_prop1f_int == visualstyle->b_prop1f_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop1f_int [BS] set+1 %hu != %hu", visualstyle->b_prop1f_int, b_prop1f_int);
    visualstyle->b_prop1f_int--;
  }
  {
    BITCODE_B b_prop20;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop20", &b_prop20, NULL)
        && b_prop20 == visualstyle->b_prop20)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop20 [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop20, b_prop20);
    b_prop20++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop20", &b_prop20, 0)
        && b_prop20 == visualstyle->b_prop20)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop20 [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop20, b_prop20);
    visualstyle->b_prop20--;
  }
  {
    BITCODE_BS b_prop20_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop20_int", &b_prop20_int, NULL)
        && b_prop20_int == visualstyle->b_prop20_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop20_int [BS] %hu != %hu", visualstyle->b_prop20_int, b_prop20_int);
    b_prop20_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop20_int", &b_prop20_int, 0)
        && b_prop20_int == visualstyle->b_prop20_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop20_int [BS] set+1 %hu != %hu", visualstyle->b_prop20_int, b_prop20_int);
    visualstyle->b_prop20_int--;
  }
  {
    BITCODE_B b_prop21;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop21", &b_prop21, NULL)
        && b_prop21 == visualstyle->b_prop21)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop21 [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop21, b_prop21);
    b_prop21++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop21", &b_prop21, 0)
        && b_prop21 == visualstyle->b_prop21)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop21 [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop21, b_prop21);
    visualstyle->b_prop21--;
  }
  {
    BITCODE_BS b_prop21_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop21_int", &b_prop21_int, NULL)
        && b_prop21_int == visualstyle->b_prop21_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop21_int [BS] %hu != %hu", visualstyle->b_prop21_int, b_prop21_int);
    b_prop21_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop21_int", &b_prop21_int, 0)
        && b_prop21_int == visualstyle->b_prop21_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop21_int [BS] set+1 %hu != %hu", visualstyle->b_prop21_int, b_prop21_int);
    visualstyle->b_prop21_int--;
  }
  {
    BITCODE_B b_prop22;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop22", &b_prop22, NULL)
        && b_prop22 == visualstyle->b_prop22)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop22 [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop22, b_prop22);
    b_prop22++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop22", &b_prop22, 0)
        && b_prop22 == visualstyle->b_prop22)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop22 [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop22, b_prop22);
    visualstyle->b_prop22--;
  }
  {
    BITCODE_BS b_prop22_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop22_int", &b_prop22_int, NULL)
        && b_prop22_int == visualstyle->b_prop22_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop22_int [BS] %hu != %hu", visualstyle->b_prop22_int, b_prop22_int);
    b_prop22_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop22_int", &b_prop22_int, 0)
        && b_prop22_int == visualstyle->b_prop22_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop22_int [BS] set+1 %hu != %hu", visualstyle->b_prop22_int, b_prop22_int);
    visualstyle->b_prop22_int--;
  }
  {
    BITCODE_B b_prop23;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop23", &b_prop23, NULL)
        && b_prop23 == visualstyle->b_prop23)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop23 [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop23, b_prop23);
    b_prop23++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop23", &b_prop23, 0)
        && b_prop23 == visualstyle->b_prop23)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop23 [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop23, b_prop23);
    visualstyle->b_prop23--;
  }
  {
    BITCODE_BS b_prop23_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop23_int", &b_prop23_int, NULL)
        && b_prop23_int == visualstyle->b_prop23_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop23_int [BS] %hu != %hu", visualstyle->b_prop23_int, b_prop23_int);
    b_prop23_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop23_int", &b_prop23_int, 0)
        && b_prop23_int == visualstyle->b_prop23_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop23_int [BS] set+1 %hu != %hu", visualstyle->b_prop23_int, b_prop23_int);
    visualstyle->b_prop23_int--;
  }
  {
    BITCODE_B b_prop24;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop24", &b_prop24, NULL)
        && b_prop24 == visualstyle->b_prop24)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop24 [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop24, b_prop24);
    b_prop24++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop24", &b_prop24, 0)
        && b_prop24 == visualstyle->b_prop24)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop24 [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop24, b_prop24);
    visualstyle->b_prop24--;
  }
  {
    BITCODE_BS b_prop24_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop24_int", &b_prop24_int, NULL)
        && b_prop24_int == visualstyle->b_prop24_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop24_int [BS] %hu != %hu", visualstyle->b_prop24_int, b_prop24_int);
    b_prop24_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop24_int", &b_prop24_int, 0)
        && b_prop24_int == visualstyle->b_prop24_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop24_int [BS] set+1 %hu != %hu", visualstyle->b_prop24_int, b_prop24_int);
    visualstyle->b_prop24_int--;
  }
  {
    BITCODE_B b_prop2d;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop2d", &b_prop2d, NULL)
        && b_prop2d == visualstyle->b_prop2d)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop2d [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop2d, b_prop2d);
    b_prop2d++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop2d", &b_prop2d, 0)
        && b_prop2d == visualstyle->b_prop2d)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop2d [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop2d, b_prop2d);
    visualstyle->b_prop2d--;
  }
  {
    BITCODE_BS b_prop2d_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop2d_int", &b_prop2d_int, NULL)
        && b_prop2d_int == visualstyle->b_prop2d_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop2d_int [BS] %hu != %hu", visualstyle->b_prop2d_int, b_prop2d_int);
    b_prop2d_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop2d_int", &b_prop2d_int, 0)
        && b_prop2d_int == visualstyle->b_prop2d_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop2d_int [BS] set+1 %hu != %hu", visualstyle->b_prop2d_int, b_prop2d_int);
    visualstyle->b_prop2d_int--;
  }
  {
    BITCODE_B b_prop31;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop31", &b_prop31, NULL)
        && b_prop31 == visualstyle->b_prop31)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop31 [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop31, b_prop31);
    b_prop31++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop31", &b_prop31, 0)
        && b_prop31 == visualstyle->b_prop31)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop31 [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop31, b_prop31);
    visualstyle->b_prop31--;
  }
  {
    BITCODE_BS b_prop31_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop31_int", &b_prop31_int, NULL)
        && b_prop31_int == visualstyle->b_prop31_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop31_int [BS] %hu != %hu", visualstyle->b_prop31_int, b_prop31_int);
    b_prop31_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop31_int", &b_prop31_int, 0)
        && b_prop31_int == visualstyle->b_prop31_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop31_int [BS] set+1 %hu != %hu", visualstyle->b_prop31_int, b_prop31_int);
    visualstyle->b_prop31_int--;
  }
  {
    BITCODE_B b_prop37;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop37", &b_prop37, NULL)
        && b_prop37 == visualstyle->b_prop37)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop37 [B] " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop37, b_prop37);
    b_prop37++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop37", &b_prop37, 0)
        && b_prop37 == visualstyle->b_prop37)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop37 [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->b_prop37, b_prop37);
    visualstyle->b_prop37--;
  }
  {
    BITCODE_BS b_prop37_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "b_prop37_int", &b_prop37_int, NULL)
        && b_prop37_int == visualstyle->b_prop37_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop37_int [BS] %hu != %hu", visualstyle->b_prop37_int, b_prop37_int);
    b_prop37_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "b_prop37_int", &b_prop37_int, 0)
        && b_prop37_int == visualstyle->b_prop37_int)
      pass ();
    else
      fail ("VISUALSTYLE.b_prop37_int [BS] set+1 %hu != %hu", visualstyle->b_prop37_int, b_prop37_int);
    visualstyle->b_prop37_int--;
  }
  {
    BITCODE_BD bd2007_45;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd2007_45", &bd2007_45, NULL)
        && bd2007_45 == visualstyle->bd2007_45)
      pass ();
    else
      fail ("VISUALSTYLE.bd2007_45 [BD] %g != %g", visualstyle->bd2007_45, bd2007_45);
    bd2007_45++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd2007_45", &bd2007_45, 0)
        && bd2007_45 == visualstyle->bd2007_45)
      pass ();
    else
      fail ("VISUALSTYLE.bd2007_45 [BD] set+1 %g != %g", visualstyle->bd2007_45, bd2007_45);
    visualstyle->bd2007_45--;
  }
  {
    BITCODE_BD bd_prop26;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop26", &bd_prop26, NULL)
        && bd_prop26 == visualstyle->bd_prop26)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop26 [BD] %g != %g", visualstyle->bd_prop26, bd_prop26);
    bd_prop26++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop26", &bd_prop26, 0)
        && bd_prop26 == visualstyle->bd_prop26)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop26 [BD] set+1 %g != %g", visualstyle->bd_prop26, bd_prop26);
    visualstyle->bd_prop26--;
  }
  {
    BITCODE_BS bd_prop26_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop26_int", &bd_prop26_int, NULL)
        && bd_prop26_int == visualstyle->bd_prop26_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop26_int [BS] %hu != %hu", visualstyle->bd_prop26_int, bd_prop26_int);
    bd_prop26_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop26_int", &bd_prop26_int, 0)
        && bd_prop26_int == visualstyle->bd_prop26_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop26_int [BS] set+1 %hu != %hu", visualstyle->bd_prop26_int, bd_prop26_int);
    visualstyle->bd_prop26_int--;
  }
  {
    BITCODE_BD bd_prop27;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop27", &bd_prop27, NULL)
        && bd_prop27 == visualstyle->bd_prop27)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop27 [BD] %g != %g", visualstyle->bd_prop27, bd_prop27);
    bd_prop27++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop27", &bd_prop27, 0)
        && bd_prop27 == visualstyle->bd_prop27)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop27 [BD] set+1 %g != %g", visualstyle->bd_prop27, bd_prop27);
    visualstyle->bd_prop27--;
  }
  {
    BITCODE_BS bd_prop27_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop27_int", &bd_prop27_int, NULL)
        && bd_prop27_int == visualstyle->bd_prop27_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop27_int [BS] %hu != %hu", visualstyle->bd_prop27_int, bd_prop27_int);
    bd_prop27_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop27_int", &bd_prop27_int, 0)
        && bd_prop27_int == visualstyle->bd_prop27_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop27_int [BS] set+1 %hu != %hu", visualstyle->bd_prop27_int, bd_prop27_int);
    visualstyle->bd_prop27_int--;
  }
  {
    BITCODE_BD bd_prop34;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop34", &bd_prop34, NULL)
        && bd_prop34 == visualstyle->bd_prop34)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop34 [BD] %g != %g", visualstyle->bd_prop34, bd_prop34);
    bd_prop34++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop34", &bd_prop34, 0)
        && bd_prop34 == visualstyle->bd_prop34)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop34 [BD] set+1 %g != %g", visualstyle->bd_prop34, bd_prop34);
    visualstyle->bd_prop34--;
  }
  {
    BITCODE_BS bd_prop34_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop34_int", &bd_prop34_int, NULL)
        && bd_prop34_int == visualstyle->bd_prop34_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop34_int [BS] %hu != %hu", visualstyle->bd_prop34_int, bd_prop34_int);
    bd_prop34_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop34_int", &bd_prop34_int, 0)
        && bd_prop34_int == visualstyle->bd_prop34_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop34_int [BS] set+1 %hu != %hu", visualstyle->bd_prop34_int, bd_prop34_int);
    visualstyle->bd_prop34_int--;
  }
  {
    BITCODE_BD bd_prop38;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop38", &bd_prop38, NULL)
        && bd_prop38 == visualstyle->bd_prop38)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop38 [BD] %g != %g", visualstyle->bd_prop38, bd_prop38);
    bd_prop38++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop38", &bd_prop38, 0)
        && bd_prop38 == visualstyle->bd_prop38)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop38 [BD] set+1 %g != %g", visualstyle->bd_prop38, bd_prop38);
    visualstyle->bd_prop38--;
  }
  {
    BITCODE_BS bd_prop38_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop38_int", &bd_prop38_int, NULL)
        && bd_prop38_int == visualstyle->bd_prop38_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop38_int [BS] %hu != %hu", visualstyle->bd_prop38_int, bd_prop38_int);
    bd_prop38_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop38_int", &bd_prop38_int, 0)
        && bd_prop38_int == visualstyle->bd_prop38_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop38_int [BS] set+1 %hu != %hu", visualstyle->bd_prop38_int, bd_prop38_int);
    visualstyle->bd_prop38_int--;
  }
  {
    BITCODE_BD bd_prop39;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop39", &bd_prop39, NULL)
        && bd_prop39 == visualstyle->bd_prop39)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop39 [BD] %g != %g", visualstyle->bd_prop39, bd_prop39);
    bd_prop39++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop39", &bd_prop39, 0)
        && bd_prop39 == visualstyle->bd_prop39)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop39 [BD] set+1 %g != %g", visualstyle->bd_prop39, bd_prop39);
    visualstyle->bd_prop39--;
  }
  {
    BITCODE_BS bd_prop39_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bd_prop39_int", &bd_prop39_int, NULL)
        && bd_prop39_int == visualstyle->bd_prop39_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop39_int [BS] %hu != %hu", visualstyle->bd_prop39_int, bd_prop39_int);
    bd_prop39_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bd_prop39_int", &bd_prop39_int, 0)
        && bd_prop39_int == visualstyle->bd_prop39_int)
      pass ();
    else
      fail ("VISUALSTYLE.bd_prop39_int [BS] set+1 %hu != %hu", visualstyle->bd_prop39_int, bd_prop39_int);
    visualstyle->bd_prop39_int--;
  }
  {
    BITCODE_BL bl_prop25;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop25", &bl_prop25, NULL)
        && bl_prop25 == visualstyle->bl_prop25)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop25 [BL] %u != %u", visualstyle->bl_prop25, bl_prop25);
    bl_prop25++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop25", &bl_prop25, 0)
        && bl_prop25 == visualstyle->bl_prop25)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop25 [BL] set+1 %u != %u", visualstyle->bl_prop25, bl_prop25);
    visualstyle->bl_prop25--;
  }
  {
    BITCODE_BS bl_prop25_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop25_int", &bl_prop25_int, NULL)
        && bl_prop25_int == visualstyle->bl_prop25_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop25_int [BS] %hu != %hu", visualstyle->bl_prop25_int, bl_prop25_int);
    bl_prop25_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop25_int", &bl_prop25_int, 0)
        && bl_prop25_int == visualstyle->bl_prop25_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop25_int [BS] set+1 %hu != %hu", visualstyle->bl_prop25_int, bl_prop25_int);
    visualstyle->bl_prop25_int--;
  }
  {
    BITCODE_BL bl_prop28;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop28", &bl_prop28, NULL)
        && bl_prop28 == visualstyle->bl_prop28)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop28 [BL] %u != %u", visualstyle->bl_prop28, bl_prop28);
    bl_prop28++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop28", &bl_prop28, 0)
        && bl_prop28 == visualstyle->bl_prop28)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop28 [BL] set+1 %u != %u", visualstyle->bl_prop28, bl_prop28);
    visualstyle->bl_prop28--;
  }
  {
    BITCODE_BS bl_prop28_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop28_int", &bl_prop28_int, NULL)
        && bl_prop28_int == visualstyle->bl_prop28_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop28_int [BS] %hu != %hu", visualstyle->bl_prop28_int, bl_prop28_int);
    bl_prop28_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop28_int", &bl_prop28_int, 0)
        && bl_prop28_int == visualstyle->bl_prop28_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop28_int [BS] set+1 %hu != %hu", visualstyle->bl_prop28_int, bl_prop28_int);
    visualstyle->bl_prop28_int--;
  }
  {
    BITCODE_BL bl_prop2a;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop2a", &bl_prop2a, NULL)
        && bl_prop2a == visualstyle->bl_prop2a)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2a [BL] %u != %u", visualstyle->bl_prop2a, bl_prop2a);
    bl_prop2a++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop2a", &bl_prop2a, 0)
        && bl_prop2a == visualstyle->bl_prop2a)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2a [BL] set+1 %u != %u", visualstyle->bl_prop2a, bl_prop2a);
    visualstyle->bl_prop2a--;
  }
  {
    BITCODE_BS bl_prop2a_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop2a_int", &bl_prop2a_int, NULL)
        && bl_prop2a_int == visualstyle->bl_prop2a_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2a_int [BS] %hu != %hu", visualstyle->bl_prop2a_int, bl_prop2a_int);
    bl_prop2a_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop2a_int", &bl_prop2a_int, 0)
        && bl_prop2a_int == visualstyle->bl_prop2a_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2a_int [BS] set+1 %hu != %hu", visualstyle->bl_prop2a_int, bl_prop2a_int);
    visualstyle->bl_prop2a_int--;
  }
  {
    BITCODE_BL bl_prop2b;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop2b", &bl_prop2b, NULL)
        && bl_prop2b == visualstyle->bl_prop2b)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2b [BL] %u != %u", visualstyle->bl_prop2b, bl_prop2b);
    bl_prop2b++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop2b", &bl_prop2b, 0)
        && bl_prop2b == visualstyle->bl_prop2b)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2b [BL] set+1 %u != %u", visualstyle->bl_prop2b, bl_prop2b);
    visualstyle->bl_prop2b--;
  }
  {
    BITCODE_BS bl_prop2b_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop2b_int", &bl_prop2b_int, NULL)
        && bl_prop2b_int == visualstyle->bl_prop2b_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2b_int [BS] %hu != %hu", visualstyle->bl_prop2b_int, bl_prop2b_int);
    bl_prop2b_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop2b_int", &bl_prop2b_int, 0)
        && bl_prop2b_int == visualstyle->bl_prop2b_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2b_int [BS] set+1 %hu != %hu", visualstyle->bl_prop2b_int, bl_prop2b_int);
    visualstyle->bl_prop2b_int--;
  }
  {
    BITCODE_BL bl_prop2e;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop2e", &bl_prop2e, NULL)
        && bl_prop2e == visualstyle->bl_prop2e)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2e [BL] %u != %u", visualstyle->bl_prop2e, bl_prop2e);
    bl_prop2e++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop2e", &bl_prop2e, 0)
        && bl_prop2e == visualstyle->bl_prop2e)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2e [BL] set+1 %u != %u", visualstyle->bl_prop2e, bl_prop2e);
    visualstyle->bl_prop2e--;
  }
  {
    BITCODE_BS bl_prop2e_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop2e_int", &bl_prop2e_int, NULL)
        && bl_prop2e_int == visualstyle->bl_prop2e_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2e_int [BS] %hu != %hu", visualstyle->bl_prop2e_int, bl_prop2e_int);
    bl_prop2e_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop2e_int", &bl_prop2e_int, 0)
        && bl_prop2e_int == visualstyle->bl_prop2e_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2e_int [BS] set+1 %hu != %hu", visualstyle->bl_prop2e_int, bl_prop2e_int);
    visualstyle->bl_prop2e_int--;
  }
  {
    BITCODE_BL bl_prop2f;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop2f", &bl_prop2f, NULL)
        && bl_prop2f == visualstyle->bl_prop2f)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2f [BL] %u != %u", visualstyle->bl_prop2f, bl_prop2f);
    bl_prop2f++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop2f", &bl_prop2f, 0)
        && bl_prop2f == visualstyle->bl_prop2f)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2f [BL] set+1 %u != %u", visualstyle->bl_prop2f, bl_prop2f);
    visualstyle->bl_prop2f--;
  }
  {
    BITCODE_BS bl_prop2f_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop2f_int", &bl_prop2f_int, NULL)
        && bl_prop2f_int == visualstyle->bl_prop2f_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2f_int [BS] %hu != %hu", visualstyle->bl_prop2f_int, bl_prop2f_int);
    bl_prop2f_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop2f_int", &bl_prop2f_int, 0)
        && bl_prop2f_int == visualstyle->bl_prop2f_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop2f_int [BS] set+1 %hu != %hu", visualstyle->bl_prop2f_int, bl_prop2f_int);
    visualstyle->bl_prop2f_int--;
  }
  {
    BITCODE_BL bl_prop30;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop30", &bl_prop30, NULL)
        && bl_prop30 == visualstyle->bl_prop30)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop30 [BL] %u != %u", visualstyle->bl_prop30, bl_prop30);
    bl_prop30++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop30", &bl_prop30, 0)
        && bl_prop30 == visualstyle->bl_prop30)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop30 [BL] set+1 %u != %u", visualstyle->bl_prop30, bl_prop30);
    visualstyle->bl_prop30--;
  }
  {
    BITCODE_BS bl_prop30_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop30_int", &bl_prop30_int, NULL)
        && bl_prop30_int == visualstyle->bl_prop30_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop30_int [BS] %hu != %hu", visualstyle->bl_prop30_int, bl_prop30_int);
    bl_prop30_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop30_int", &bl_prop30_int, 0)
        && bl_prop30_int == visualstyle->bl_prop30_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop30_int [BS] set+1 %hu != %hu", visualstyle->bl_prop30_int, bl_prop30_int);
    visualstyle->bl_prop30_int--;
  }
  {
    BITCODE_BL bl_prop32;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop32", &bl_prop32, NULL)
        && bl_prop32 == visualstyle->bl_prop32)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop32 [BL] %u != %u", visualstyle->bl_prop32, bl_prop32);
    bl_prop32++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop32", &bl_prop32, 0)
        && bl_prop32 == visualstyle->bl_prop32)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop32 [BL] set+1 %u != %u", visualstyle->bl_prop32, bl_prop32);
    visualstyle->bl_prop32--;
  }
  {
    BITCODE_BS bl_prop32_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "bl_prop32_int", &bl_prop32_int, NULL)
        && bl_prop32_int == visualstyle->bl_prop32_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop32_int [BS] %hu != %hu", visualstyle->bl_prop32_int, bl_prop32_int);
    bl_prop32_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "bl_prop32_int", &bl_prop32_int, 0)
        && bl_prop32_int == visualstyle->bl_prop32_int)
      pass ();
    else
      fail ("VISUALSTYLE.bl_prop32_int [BS] set+1 %hu != %hu", visualstyle->bl_prop32_int, bl_prop32_int);
    visualstyle->bl_prop32_int--;
  }
  {
    BITCODE_CMC c_prop29;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "c_prop29", &c_prop29, NULL)
        && !memcmp (&c_prop29, &visualstyle->c_prop29, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VISUALSTYLE.c_prop29 [CMC]");
  }
  {
    BITCODE_BS c_prop29_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "c_prop29_int", &c_prop29_int, NULL)
        && c_prop29_int == visualstyle->c_prop29_int)
      pass ();
    else
      fail ("VISUALSTYLE.c_prop29_int [BS] %hu != %hu", visualstyle->c_prop29_int, c_prop29_int);
    c_prop29_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "c_prop29_int", &c_prop29_int, 0)
        && c_prop29_int == visualstyle->c_prop29_int)
      pass ();
    else
      fail ("VISUALSTYLE.c_prop29_int [BS] set+1 %hu != %hu", visualstyle->c_prop29_int, c_prop29_int);
    visualstyle->c_prop29_int--;
  }
  {
    BITCODE_CMC c_prop2c;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "c_prop2c", &c_prop2c, NULL)
        && !memcmp (&c_prop2c, &visualstyle->c_prop2c, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VISUALSTYLE.c_prop2c [CMC]");
  }
  {
    BITCODE_BS c_prop2c_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "c_prop2c_int", &c_prop2c_int, NULL)
        && c_prop2c_int == visualstyle->c_prop2c_int)
      pass ();
    else
      fail ("VISUALSTYLE.c_prop2c_int [BS] %hu != %hu", visualstyle->c_prop2c_int, c_prop2c_int);
    c_prop2c_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "c_prop2c_int", &c_prop2c_int, 0)
        && c_prop2c_int == visualstyle->c_prop2c_int)
      pass ();
    else
      fail ("VISUALSTYLE.c_prop2c_int [BS] set+1 %hu != %hu", visualstyle->c_prop2c_int, c_prop2c_int);
    visualstyle->c_prop2c_int--;
  }
  {
    BITCODE_CMC c_prop33;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "c_prop33", &c_prop33, NULL)
        && !memcmp (&c_prop33, &visualstyle->c_prop33, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VISUALSTYLE.c_prop33 [CMC]");
  }
  {
    BITCODE_BS c_prop33_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "c_prop33_int", &c_prop33_int, NULL)
        && c_prop33_int == visualstyle->c_prop33_int)
      pass ();
    else
      fail ("VISUALSTYLE.c_prop33_int [BS] %hu != %hu", visualstyle->c_prop33_int, c_prop33_int);
    c_prop33_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "c_prop33_int", &c_prop33_int, 0)
        && c_prop33_int == visualstyle->c_prop33_int)
      pass ();
    else
      fail ("VISUALSTYLE.c_prop33_int [BS] set+1 %hu != %hu", visualstyle->c_prop33_int, c_prop33_int);
    visualstyle->c_prop33_int--;
  }
  {
    BITCODE_T description;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "description", &description, NULL)
        && description
           ? strEQ ((char *)description, (char *)visualstyle->description)
           : !visualstyle->description)
      pass ();
    else
      fail ("VISUALSTYLE.description [T] '%s' <> '%s'", description, visualstyle->description);
  }
  {
    BITCODE_BD display_brightness;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_brightness", &display_brightness, NULL)
        && display_brightness == visualstyle->display_brightness)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness [BD] %g != %g", visualstyle->display_brightness, display_brightness);
    display_brightness++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_brightness", &display_brightness, 0)
        && display_brightness == visualstyle->display_brightness)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness [BD] set+1 %g != %g", visualstyle->display_brightness, display_brightness);
    visualstyle->display_brightness--;
  }
  {
    BITCODE_BLd display_brightness_bl;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_brightness_bl", &display_brightness_bl, NULL)
        && display_brightness_bl == visualstyle->display_brightness_bl)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness_bl [BLd] " FORMAT_BLd " != " FORMAT_BLd "", visualstyle->display_brightness_bl, display_brightness_bl);
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_brightness_bl", &display_brightness_bl, 0)
        && display_brightness_bl == visualstyle->display_brightness_bl)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness_bl [BLd] set+1 " FORMAT_BLd " != " FORMAT_BLd "", visualstyle->display_brightness_bl, display_brightness_bl);
    visualstyle->display_brightness_bl--;
  }
  {
    BITCODE_BS display_brightness_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_brightness_int", &display_brightness_int, NULL)
        && display_brightness_int == visualstyle->display_brightness_int)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness_int [BS] %hu != %hu", visualstyle->display_brightness_int, display_brightness_int);
    display_brightness_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_brightness_int", &display_brightness_int, 0)
        && display_brightness_int == visualstyle->display_brightness_int)
      pass ();
    else
      fail ("VISUALSTYLE.display_brightness_int [BS] set+1 %hu != %hu", visualstyle->display_brightness_int, display_brightness_int);
    visualstyle->display_brightness_int--;
  }
  {
    BITCODE_BL display_settings;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_settings", &display_settings, NULL)
        && display_settings == visualstyle->display_settings)
      pass ();
    else
      fail ("VISUALSTYLE.display_settings [BL] %u != %u", visualstyle->display_settings, display_settings);
    display_settings++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_settings", &display_settings, 0)
        && display_settings == visualstyle->display_settings)
      pass ();
    else
      fail ("VISUALSTYLE.display_settings [BL] set+1 %u != %u", visualstyle->display_settings, display_settings);
    visualstyle->display_settings--;
  }
  {
    BITCODE_BS display_settings_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_settings_int", &display_settings_int, NULL)
        && display_settings_int == visualstyle->display_settings_int)
      pass ();
    else
      fail ("VISUALSTYLE.display_settings_int [BS] %hu != %hu", visualstyle->display_settings_int, display_settings_int);
    display_settings_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_settings_int", &display_settings_int, 0)
        && display_settings_int == visualstyle->display_settings_int)
      pass ();
    else
      fail ("VISUALSTYLE.display_settings_int [BS] set+1 %hu != %hu", visualstyle->display_settings_int, display_settings_int);
    visualstyle->display_settings_int--;
  }
  {
    BITCODE_BL display_shadow_type;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_shadow_type", &display_shadow_type, NULL)
        && display_shadow_type == visualstyle->display_shadow_type)
      pass ();
    else
      fail ("VISUALSTYLE.display_shadow_type [BL] %u != %u", visualstyle->display_shadow_type, display_shadow_type);
    display_shadow_type++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_shadow_type", &display_shadow_type, 0)
        && display_shadow_type == visualstyle->display_shadow_type)
      pass ();
    else
      fail ("VISUALSTYLE.display_shadow_type [BL] set+1 %u != %u", visualstyle->display_shadow_type, display_shadow_type);
    visualstyle->display_shadow_type--;
  }
  {
    BITCODE_BS display_shadow_type_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "display_shadow_type_int", &display_shadow_type_int, NULL)
        && display_shadow_type_int == visualstyle->display_shadow_type_int)
      pass ();
    else
      fail ("VISUALSTYLE.display_shadow_type_int [BS] %hu != %hu", visualstyle->display_shadow_type_int, display_shadow_type_int);
    display_shadow_type_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "display_shadow_type_int", &display_shadow_type_int, 0)
        && display_shadow_type_int == visualstyle->display_shadow_type_int)
      pass ();
    else
      fail ("VISUALSTYLE.display_shadow_type_int [BS] set+1 %hu != %hu", visualstyle->display_shadow_type_int, display_shadow_type_int);
    visualstyle->display_shadow_type_int--;
  }
  {
    BITCODE_CMC edge_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_color", &edge_color, NULL)
        && !memcmp (&edge_color, &visualstyle->edge_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VISUALSTYLE.edge_color [CMC]");
  }
  {
    BITCODE_BS edge_color_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_color_int", &edge_color_int, NULL)
        && edge_color_int == visualstyle->edge_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_color_int [BS] %hu != %hu", visualstyle->edge_color_int, edge_color_int);
    edge_color_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_color_int", &edge_color_int, 0)
        && edge_color_int == visualstyle->edge_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_color_int [BS] set+1 %hu != %hu", visualstyle->edge_color_int, edge_color_int);
    visualstyle->edge_color_int--;
  }
  {
    BITCODE_BD edge_crease_angle;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_crease_angle", &edge_crease_angle, NULL)
        && edge_crease_angle == visualstyle->edge_crease_angle)
      pass ();
    else
      fail ("VISUALSTYLE.edge_crease_angle [BD] %g != %g", visualstyle->edge_crease_angle, edge_crease_angle);
    edge_crease_angle++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_crease_angle", &edge_crease_angle, 0)
        && edge_crease_angle == visualstyle->edge_crease_angle)
      pass ();
    else
      fail ("VISUALSTYLE.edge_crease_angle [BD] set+1 %g != %g", visualstyle->edge_crease_angle, edge_crease_angle);
    visualstyle->edge_crease_angle--;
  }
  {
    BITCODE_BS edge_crease_angle_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_crease_angle_int", &edge_crease_angle_int, NULL)
        && edge_crease_angle_int == visualstyle->edge_crease_angle_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_crease_angle_int [BS] %hu != %hu", visualstyle->edge_crease_angle_int, edge_crease_angle_int);
    edge_crease_angle_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_crease_angle_int", &edge_crease_angle_int, 0)
        && edge_crease_angle_int == visualstyle->edge_crease_angle_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_crease_angle_int [BS] set+1 %hu != %hu", visualstyle->edge_crease_angle_int, edge_crease_angle_int);
    visualstyle->edge_crease_angle_int--;
  }
  {
    BITCODE_B edge_do_hide_precision;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_do_hide_precision", &edge_do_hide_precision, NULL)
        && edge_do_hide_precision == visualstyle->edge_do_hide_precision)
      pass ();
    else
      fail ("VISUALSTYLE.edge_do_hide_precision [B] " FORMAT_B " != " FORMAT_B "", visualstyle->edge_do_hide_precision, edge_do_hide_precision);
    edge_do_hide_precision++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_do_hide_precision", &edge_do_hide_precision, 0)
        && edge_do_hide_precision == visualstyle->edge_do_hide_precision)
      pass ();
    else
      fail ("VISUALSTYLE.edge_do_hide_precision [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->edge_do_hide_precision, edge_do_hide_precision);
    visualstyle->edge_do_hide_precision--;
  }
  {
    BITCODE_BS edge_do_hide_precision_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_do_hide_precision_int", &edge_do_hide_precision_int, NULL)
        && edge_do_hide_precision_int == visualstyle->edge_do_hide_precision_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_do_hide_precision_int [BS] %hu != %hu", visualstyle->edge_do_hide_precision_int, edge_do_hide_precision_int);
    edge_do_hide_precision_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_do_hide_precision_int", &edge_do_hide_precision_int, 0)
        && edge_do_hide_precision_int == visualstyle->edge_do_hide_precision_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_do_hide_precision_int [BS] set+1 %hu != %hu", visualstyle->edge_do_hide_precision_int, edge_do_hide_precision_int);
    visualstyle->edge_do_hide_precision_int--;
  }
  {
    BITCODE_BL edge_halo_gap;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_halo_gap", &edge_halo_gap, NULL)
        && edge_halo_gap == visualstyle->edge_halo_gap)
      pass ();
    else
      fail ("VISUALSTYLE.edge_halo_gap [BL] %u != %u", visualstyle->edge_halo_gap, edge_halo_gap);
    edge_halo_gap++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_halo_gap", &edge_halo_gap, 0)
        && edge_halo_gap == visualstyle->edge_halo_gap)
      pass ();
    else
      fail ("VISUALSTYLE.edge_halo_gap [BL] set+1 %u != %u", visualstyle->edge_halo_gap, edge_halo_gap);
    visualstyle->edge_halo_gap--;
  }
  {
    BITCODE_BS edge_halo_gap_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_halo_gap_int", &edge_halo_gap_int, NULL)
        && edge_halo_gap_int == visualstyle->edge_halo_gap_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_halo_gap_int [BS] %hu != %hu", visualstyle->edge_halo_gap_int, edge_halo_gap_int);
    edge_halo_gap_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_halo_gap_int", &edge_halo_gap_int, 0)
        && edge_halo_gap_int == visualstyle->edge_halo_gap_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_halo_gap_int [BS] set+1 %hu != %hu", visualstyle->edge_halo_gap_int, edge_halo_gap_int);
    visualstyle->edge_halo_gap_int--;
  }
  {
    BITCODE_CMC edge_intersection_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_intersection_color", &edge_intersection_color, NULL)
        && !memcmp (&edge_intersection_color, &visualstyle->edge_intersection_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VISUALSTYLE.edge_intersection_color [CMC]");
  }
  {
    BITCODE_BS edge_intersection_color_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_intersection_color_int", &edge_intersection_color_int, NULL)
        && edge_intersection_color_int == visualstyle->edge_intersection_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_color_int [BS] %hu != %hu", visualstyle->edge_intersection_color_int, edge_intersection_color_int);
    edge_intersection_color_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_intersection_color_int", &edge_intersection_color_int, 0)
        && edge_intersection_color_int == visualstyle->edge_intersection_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_color_int [BS] set+1 %hu != %hu", visualstyle->edge_intersection_color_int, edge_intersection_color_int);
    visualstyle->edge_intersection_color_int--;
  }
  {
    BITCODE_BL edge_intersection_ltype;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_intersection_ltype", &edge_intersection_ltype, NULL)
        && edge_intersection_ltype == visualstyle->edge_intersection_ltype)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_ltype [BL] %u != %u", visualstyle->edge_intersection_ltype, edge_intersection_ltype);
    edge_intersection_ltype++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_intersection_ltype", &edge_intersection_ltype, 0)
        && edge_intersection_ltype == visualstyle->edge_intersection_ltype)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_ltype [BL] set+1 %u != %u", visualstyle->edge_intersection_ltype, edge_intersection_ltype);
    visualstyle->edge_intersection_ltype--;
  }
  {
    BITCODE_BS edge_intersection_ltype_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_intersection_ltype_int", &edge_intersection_ltype_int, NULL)
        && edge_intersection_ltype_int == visualstyle->edge_intersection_ltype_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_ltype_int [BS] %hu != %hu", visualstyle->edge_intersection_ltype_int, edge_intersection_ltype_int);
    edge_intersection_ltype_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_intersection_ltype_int", &edge_intersection_ltype_int, 0)
        && edge_intersection_ltype_int == visualstyle->edge_intersection_ltype_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_intersection_ltype_int [BS] set+1 %hu != %hu", visualstyle->edge_intersection_ltype_int, edge_intersection_ltype_int);
    visualstyle->edge_intersection_ltype_int--;
  }
  {
    BITCODE_BL edge_isolines;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_isolines", &edge_isolines, NULL)
        && edge_isolines == visualstyle->edge_isolines)
      pass ();
    else
      fail ("VISUALSTYLE.edge_isolines [BL] %u != %u", visualstyle->edge_isolines, edge_isolines);
    edge_isolines++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_isolines", &edge_isolines, 0)
        && edge_isolines == visualstyle->edge_isolines)
      pass ();
    else
      fail ("VISUALSTYLE.edge_isolines [BL] set+1 %u != %u", visualstyle->edge_isolines, edge_isolines);
    visualstyle->edge_isolines--;
  }
  {
    BITCODE_BS edge_isolines_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_isolines_int", &edge_isolines_int, NULL)
        && edge_isolines_int == visualstyle->edge_isolines_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_isolines_int [BS] %hu != %hu", visualstyle->edge_isolines_int, edge_isolines_int);
    edge_isolines_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_isolines_int", &edge_isolines_int, 0)
        && edge_isolines_int == visualstyle->edge_isolines_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_isolines_int [BS] set+1 %hu != %hu", visualstyle->edge_isolines_int, edge_isolines_int);
    visualstyle->edge_isolines_int--;
  }
  {
    BITCODE_BL edge_jitter;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_jitter", &edge_jitter, NULL)
        && edge_jitter == visualstyle->edge_jitter)
      pass ();
    else
      fail ("VISUALSTYLE.edge_jitter [BL] %u != %u", visualstyle->edge_jitter, edge_jitter);
    edge_jitter++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_jitter", &edge_jitter, 0)
        && edge_jitter == visualstyle->edge_jitter)
      pass ();
    else
      fail ("VISUALSTYLE.edge_jitter [BL] set+1 %u != %u", visualstyle->edge_jitter, edge_jitter);
    visualstyle->edge_jitter--;
  }
  {
    BITCODE_BS edge_jitter_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_jitter_int", &edge_jitter_int, NULL)
        && edge_jitter_int == visualstyle->edge_jitter_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_jitter_int [BS] %hu != %hu", visualstyle->edge_jitter_int, edge_jitter_int);
    edge_jitter_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_jitter_int", &edge_jitter_int, 0)
        && edge_jitter_int == visualstyle->edge_jitter_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_jitter_int [BS] set+1 %hu != %hu", visualstyle->edge_jitter_int, edge_jitter_int);
    visualstyle->edge_jitter_int--;
  }
  {
    BITCODE_BS edge_model;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_model", &edge_model, NULL)
        && edge_model == visualstyle->edge_model)
      pass ();
    else
      fail ("VISUALSTYLE.edge_model [BS] %hu != %hu", visualstyle->edge_model, edge_model);
    edge_model++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_model", &edge_model, 0)
        && edge_model == visualstyle->edge_model)
      pass ();
    else
      fail ("VISUALSTYLE.edge_model [BS] set+1 %hu != %hu", visualstyle->edge_model, edge_model);
    visualstyle->edge_model--;
  }
  {
    BITCODE_BS edge_model_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_model_int", &edge_model_int, NULL)
        && edge_model_int == visualstyle->edge_model_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_model_int [BS] %hu != %hu", visualstyle->edge_model_int, edge_model_int);
    edge_model_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_model_int", &edge_model_int, 0)
        && edge_model_int == visualstyle->edge_model_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_model_int [BS] set+1 %hu != %hu", visualstyle->edge_model_int, edge_model_int);
    visualstyle->edge_model_int--;
  }
  {
    BITCODE_BL edge_modifier;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_modifier", &edge_modifier, NULL)
        && edge_modifier == visualstyle->edge_modifier)
      pass ();
    else
      fail ("VISUALSTYLE.edge_modifier [BL] %u != %u", visualstyle->edge_modifier, edge_modifier);
    edge_modifier++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_modifier", &edge_modifier, 0)
        && edge_modifier == visualstyle->edge_modifier)
      pass ();
    else
      fail ("VISUALSTYLE.edge_modifier [BL] set+1 %u != %u", visualstyle->edge_modifier, edge_modifier);
    visualstyle->edge_modifier--;
  }
  {
    BITCODE_BS edge_modifier_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_modifier_int", &edge_modifier_int, NULL)
        && edge_modifier_int == visualstyle->edge_modifier_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_modifier_int [BS] %hu != %hu", visualstyle->edge_modifier_int, edge_modifier_int);
    edge_modifier_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_modifier_int", &edge_modifier_int, 0)
        && edge_modifier_int == visualstyle->edge_modifier_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_modifier_int [BS] set+1 %hu != %hu", visualstyle->edge_modifier_int, edge_modifier_int);
    visualstyle->edge_modifier_int--;
  }
  {
    BITCODE_CMC edge_obscured_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_obscured_color", &edge_obscured_color, NULL)
        && !memcmp (&edge_obscured_color, &visualstyle->edge_obscured_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VISUALSTYLE.edge_obscured_color [CMC]");
  }
  {
    BITCODE_BS edge_obscured_color_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_obscured_color_int", &edge_obscured_color_int, NULL)
        && edge_obscured_color_int == visualstyle->edge_obscured_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_color_int [BS] %hu != %hu", visualstyle->edge_obscured_color_int, edge_obscured_color_int);
    edge_obscured_color_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_obscured_color_int", &edge_obscured_color_int, 0)
        && edge_obscured_color_int == visualstyle->edge_obscured_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_color_int [BS] set+1 %hu != %hu", visualstyle->edge_obscured_color_int, edge_obscured_color_int);
    visualstyle->edge_obscured_color_int--;
  }
  {
    BITCODE_BL edge_obscured_ltype;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_obscured_ltype", &edge_obscured_ltype, NULL)
        && edge_obscured_ltype == visualstyle->edge_obscured_ltype)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_ltype [BL] %u != %u", visualstyle->edge_obscured_ltype, edge_obscured_ltype);
    edge_obscured_ltype++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_obscured_ltype", &edge_obscured_ltype, 0)
        && edge_obscured_ltype == visualstyle->edge_obscured_ltype)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_ltype [BL] set+1 %u != %u", visualstyle->edge_obscured_ltype, edge_obscured_ltype);
    visualstyle->edge_obscured_ltype--;
  }
  {
    BITCODE_BS edge_obscured_ltype_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_obscured_ltype_int", &edge_obscured_ltype_int, NULL)
        && edge_obscured_ltype_int == visualstyle->edge_obscured_ltype_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_ltype_int [BS] %hu != %hu", visualstyle->edge_obscured_ltype_int, edge_obscured_ltype_int);
    edge_obscured_ltype_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_obscured_ltype_int", &edge_obscured_ltype_int, 0)
        && edge_obscured_ltype_int == visualstyle->edge_obscured_ltype_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_obscured_ltype_int [BS] set+1 %hu != %hu", visualstyle->edge_obscured_ltype_int, edge_obscured_ltype_int);
    visualstyle->edge_obscured_ltype_int--;
  }
  {
    BITCODE_BD edge_opacity;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_opacity", &edge_opacity, NULL)
        && edge_opacity == visualstyle->edge_opacity)
      pass ();
    else
      fail ("VISUALSTYLE.edge_opacity [BD] %g != %g", visualstyle->edge_opacity, edge_opacity);
    edge_opacity++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_opacity", &edge_opacity, 0)
        && edge_opacity == visualstyle->edge_opacity)
      pass ();
    else
      fail ("VISUALSTYLE.edge_opacity [BD] set+1 %g != %g", visualstyle->edge_opacity, edge_opacity);
    visualstyle->edge_opacity--;
  }
  {
    BITCODE_BS edge_opacity_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_opacity_int", &edge_opacity_int, NULL)
        && edge_opacity_int == visualstyle->edge_opacity_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_opacity_int [BS] %hu != %hu", visualstyle->edge_opacity_int, edge_opacity_int);
    edge_opacity_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_opacity_int", &edge_opacity_int, 0)
        && edge_opacity_int == visualstyle->edge_opacity_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_opacity_int [BS] set+1 %hu != %hu", visualstyle->edge_opacity_int, edge_opacity_int);
    visualstyle->edge_opacity_int--;
  }
  {
    BITCODE_BL edge_overhang;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_overhang", &edge_overhang, NULL)
        && edge_overhang == visualstyle->edge_overhang)
      pass ();
    else
      fail ("VISUALSTYLE.edge_overhang [BL] %u != %u", visualstyle->edge_overhang, edge_overhang);
    edge_overhang++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_overhang", &edge_overhang, 0)
        && edge_overhang == visualstyle->edge_overhang)
      pass ();
    else
      fail ("VISUALSTYLE.edge_overhang [BL] set+1 %u != %u", visualstyle->edge_overhang, edge_overhang);
    visualstyle->edge_overhang--;
  }
  {
    BITCODE_BS edge_overhang_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_overhang_int", &edge_overhang_int, NULL)
        && edge_overhang_int == visualstyle->edge_overhang_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_overhang_int [BS] %hu != %hu", visualstyle->edge_overhang_int, edge_overhang_int);
    edge_overhang_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_overhang_int", &edge_overhang_int, 0)
        && edge_overhang_int == visualstyle->edge_overhang_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_overhang_int [BS] set+1 %hu != %hu", visualstyle->edge_overhang_int, edge_overhang_int);
    visualstyle->edge_overhang_int--;
  }
  {
    BITCODE_CMC edge_silhouette_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_silhouette_color", &edge_silhouette_color, NULL)
        && !memcmp (&edge_silhouette_color, &visualstyle->edge_silhouette_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VISUALSTYLE.edge_silhouette_color [CMC]");
  }
  {
    BITCODE_BS edge_silhouette_color_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_silhouette_color_int", &edge_silhouette_color_int, NULL)
        && edge_silhouette_color_int == visualstyle->edge_silhouette_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_color_int [BS] %hu != %hu", visualstyle->edge_silhouette_color_int, edge_silhouette_color_int);
    edge_silhouette_color_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_silhouette_color_int", &edge_silhouette_color_int, 0)
        && edge_silhouette_color_int == visualstyle->edge_silhouette_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_color_int [BS] set+1 %hu != %hu", visualstyle->edge_silhouette_color_int, edge_silhouette_color_int);
    visualstyle->edge_silhouette_color_int--;
  }
  {
    BITCODE_BL edge_silhouette_width;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_silhouette_width", &edge_silhouette_width, NULL)
        && edge_silhouette_width == visualstyle->edge_silhouette_width)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_width [BL] %u != %u", visualstyle->edge_silhouette_width, edge_silhouette_width);
    edge_silhouette_width++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_silhouette_width", &edge_silhouette_width, 0)
        && edge_silhouette_width == visualstyle->edge_silhouette_width)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_width [BL] set+1 %u != %u", visualstyle->edge_silhouette_width, edge_silhouette_width);
    visualstyle->edge_silhouette_width--;
  }
  {
    BITCODE_BS edge_silhouette_width_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_silhouette_width_int", &edge_silhouette_width_int, NULL)
        && edge_silhouette_width_int == visualstyle->edge_silhouette_width_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_width_int [BS] %hu != %hu", visualstyle->edge_silhouette_width_int, edge_silhouette_width_int);
    edge_silhouette_width_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_silhouette_width_int", &edge_silhouette_width_int, 0)
        && edge_silhouette_width_int == visualstyle->edge_silhouette_width_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_silhouette_width_int [BS] set+1 %hu != %hu", visualstyle->edge_silhouette_width_int, edge_silhouette_width_int);
    visualstyle->edge_silhouette_width_int--;
  }
  {
    BITCODE_BL edge_style;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_style", &edge_style, NULL)
        && edge_style == visualstyle->edge_style)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style [BL] %u != %u", visualstyle->edge_style, edge_style);
    edge_style++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_style", &edge_style, 0)
        && edge_style == visualstyle->edge_style)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style [BL] set+1 %u != %u", visualstyle->edge_style, edge_style);
    visualstyle->edge_style--;
  }
  {
    BITCODE_BL edge_style_apply;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_style_apply", &edge_style_apply, NULL)
        && edge_style_apply == visualstyle->edge_style_apply)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_apply [BL] %u != %u", visualstyle->edge_style_apply, edge_style_apply);
    edge_style_apply++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_style_apply", &edge_style_apply, 0)
        && edge_style_apply == visualstyle->edge_style_apply)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_apply [BL] set+1 %u != %u", visualstyle->edge_style_apply, edge_style_apply);
    visualstyle->edge_style_apply--;
  }
  {
    BITCODE_BS edge_style_apply_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_style_apply_int", &edge_style_apply_int, NULL)
        && edge_style_apply_int == visualstyle->edge_style_apply_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_apply_int [BS] %hu != %hu", visualstyle->edge_style_apply_int, edge_style_apply_int);
    edge_style_apply_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_style_apply_int", &edge_style_apply_int, 0)
        && edge_style_apply_int == visualstyle->edge_style_apply_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_apply_int [BS] set+1 %hu != %hu", visualstyle->edge_style_apply_int, edge_style_apply_int);
    visualstyle->edge_style_apply_int--;
  }
  {
    BITCODE_BS edge_style_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_style_int", &edge_style_int, NULL)
        && edge_style_int == visualstyle->edge_style_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_int [BS] %hu != %hu", visualstyle->edge_style_int, edge_style_int);
    edge_style_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_style_int", &edge_style_int, 0)
        && edge_style_int == visualstyle->edge_style_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_style_int [BS] set+1 %hu != %hu", visualstyle->edge_style_int, edge_style_int);
    visualstyle->edge_style_int--;
  }
  {
    BITCODE_BL edge_width;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_width", &edge_width, NULL)
        && edge_width == visualstyle->edge_width)
      pass ();
    else
      fail ("VISUALSTYLE.edge_width [BL] %u != %u", visualstyle->edge_width, edge_width);
    edge_width++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_width", &edge_width, 0)
        && edge_width == visualstyle->edge_width)
      pass ();
    else
      fail ("VISUALSTYLE.edge_width [BL] set+1 %u != %u", visualstyle->edge_width, edge_width);
    visualstyle->edge_width--;
  }
  {
    BITCODE_BS edge_width_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_width_int", &edge_width_int, NULL)
        && edge_width_int == visualstyle->edge_width_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_width_int [BS] %hu != %hu", visualstyle->edge_width_int, edge_width_int);
    edge_width_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_width_int", &edge_width_int, 0)
        && edge_width_int == visualstyle->edge_width_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_width_int [BS] set+1 %hu != %hu", visualstyle->edge_width_int, edge_width_int);
    visualstyle->edge_width_int--;
  }
  {
    BITCODE_BL edge_wiggle;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_wiggle", &edge_wiggle, NULL)
        && edge_wiggle == visualstyle->edge_wiggle)
      pass ();
    else
      fail ("VISUALSTYLE.edge_wiggle [BL] %u != %u", visualstyle->edge_wiggle, edge_wiggle);
    edge_wiggle++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_wiggle", &edge_wiggle, 0)
        && edge_wiggle == visualstyle->edge_wiggle)
      pass ();
    else
      fail ("VISUALSTYLE.edge_wiggle [BL] set+1 %u != %u", visualstyle->edge_wiggle, edge_wiggle);
    visualstyle->edge_wiggle--;
  }
  {
    BITCODE_BS edge_wiggle_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "edge_wiggle_int", &edge_wiggle_int, NULL)
        && edge_wiggle_int == visualstyle->edge_wiggle_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_wiggle_int [BS] %hu != %hu", visualstyle->edge_wiggle_int, edge_wiggle_int);
    edge_wiggle_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "edge_wiggle_int", &edge_wiggle_int, 0)
        && edge_wiggle_int == visualstyle->edge_wiggle_int)
      pass ();
    else
      fail ("VISUALSTYLE.edge_wiggle_int [BS] set+1 %hu != %hu", visualstyle->edge_wiggle_int, edge_wiggle_int);
    visualstyle->edge_wiggle_int--;
  }
  {
    BITCODE_BS ext_lighting_model;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "ext_lighting_model", &ext_lighting_model, NULL)
        && ext_lighting_model == visualstyle->ext_lighting_model)
      pass ();
    else
      fail ("VISUALSTYLE.ext_lighting_model [BS] %hu != %hu", visualstyle->ext_lighting_model, ext_lighting_model);
    ext_lighting_model++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "ext_lighting_model", &ext_lighting_model, 0)
        && ext_lighting_model == visualstyle->ext_lighting_model)
      pass ();
    else
      fail ("VISUALSTYLE.ext_lighting_model [BS] set+1 %hu != %hu", visualstyle->ext_lighting_model, ext_lighting_model);
    visualstyle->ext_lighting_model--;
  }
  {
    BITCODE_BL face_color_mode;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_color_mode", &face_color_mode, NULL)
        && face_color_mode == visualstyle->face_color_mode)
      pass ();
    else
      fail ("VISUALSTYLE.face_color_mode [BL] %u != %u", visualstyle->face_color_mode, face_color_mode);
    face_color_mode++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_color_mode", &face_color_mode, 0)
        && face_color_mode == visualstyle->face_color_mode)
      pass ();
    else
      fail ("VISUALSTYLE.face_color_mode [BL] set+1 %u != %u", visualstyle->face_color_mode, face_color_mode);
    visualstyle->face_color_mode--;
  }
  {
    BITCODE_BS face_color_mode_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_color_mode_int", &face_color_mode_int, NULL)
        && face_color_mode_int == visualstyle->face_color_mode_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_color_mode_int [BS] %hu != %hu", visualstyle->face_color_mode_int, face_color_mode_int);
    face_color_mode_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_color_mode_int", &face_color_mode_int, 0)
        && face_color_mode_int == visualstyle->face_color_mode_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_color_mode_int [BS] set+1 %hu != %hu", visualstyle->face_color_mode_int, face_color_mode_int);
    visualstyle->face_color_mode_int--;
  }
  {
    BITCODE_BL face_lighting_model;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_lighting_model", &face_lighting_model, NULL)
        && face_lighting_model == visualstyle->face_lighting_model)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_model [BL] %u != %u", visualstyle->face_lighting_model, face_lighting_model);
    face_lighting_model++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_lighting_model", &face_lighting_model, 0)
        && face_lighting_model == visualstyle->face_lighting_model)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_model [BL] set+1 %u != %u", visualstyle->face_lighting_model, face_lighting_model);
    visualstyle->face_lighting_model--;
  }
  {
    BITCODE_BS face_lighting_model_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_lighting_model_int", &face_lighting_model_int, NULL)
        && face_lighting_model_int == visualstyle->face_lighting_model_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_model_int [BS] %hu != %hu", visualstyle->face_lighting_model_int, face_lighting_model_int);
    face_lighting_model_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_lighting_model_int", &face_lighting_model_int, 0)
        && face_lighting_model_int == visualstyle->face_lighting_model_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_model_int [BS] set+1 %hu != %hu", visualstyle->face_lighting_model_int, face_lighting_model_int);
    visualstyle->face_lighting_model_int--;
  }
  {
    BITCODE_BL face_lighting_quality;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_lighting_quality", &face_lighting_quality, NULL)
        && face_lighting_quality == visualstyle->face_lighting_quality)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_quality [BL] %u != %u", visualstyle->face_lighting_quality, face_lighting_quality);
    face_lighting_quality++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_lighting_quality", &face_lighting_quality, 0)
        && face_lighting_quality == visualstyle->face_lighting_quality)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_quality [BL] set+1 %u != %u", visualstyle->face_lighting_quality, face_lighting_quality);
    visualstyle->face_lighting_quality--;
  }
  {
    BITCODE_BS face_lighting_quality_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_lighting_quality_int", &face_lighting_quality_int, NULL)
        && face_lighting_quality_int == visualstyle->face_lighting_quality_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_quality_int [BS] %hu != %hu", visualstyle->face_lighting_quality_int, face_lighting_quality_int);
    face_lighting_quality_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_lighting_quality_int", &face_lighting_quality_int, 0)
        && face_lighting_quality_int == visualstyle->face_lighting_quality_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_lighting_quality_int [BS] set+1 %hu != %hu", visualstyle->face_lighting_quality_int, face_lighting_quality_int);
    visualstyle->face_lighting_quality_int--;
  }
  {
    BITCODE_BL face_modifier;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_modifier", &face_modifier, NULL)
        && face_modifier == visualstyle->face_modifier)
      pass ();
    else
      fail ("VISUALSTYLE.face_modifier [BL] %u != %u", visualstyle->face_modifier, face_modifier);
    face_modifier++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_modifier", &face_modifier, 0)
        && face_modifier == visualstyle->face_modifier)
      pass ();
    else
      fail ("VISUALSTYLE.face_modifier [BL] set+1 %u != %u", visualstyle->face_modifier, face_modifier);
    visualstyle->face_modifier--;
  }
  {
    BITCODE_BS face_modifier_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_modifier_int", &face_modifier_int, NULL)
        && face_modifier_int == visualstyle->face_modifier_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_modifier_int [BS] %hu != %hu", visualstyle->face_modifier_int, face_modifier_int);
    face_modifier_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_modifier_int", &face_modifier_int, 0)
        && face_modifier_int == visualstyle->face_modifier_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_modifier_int [BS] set+1 %hu != %hu", visualstyle->face_modifier_int, face_modifier_int);
    visualstyle->face_modifier_int--;
  }
  {
    BITCODE_CMC face_mono_color;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_mono_color", &face_mono_color, NULL)
        && !memcmp (&face_mono_color, &visualstyle->face_mono_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VISUALSTYLE.face_mono_color [CMC]");
  }
  {
    BITCODE_BS face_mono_color_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_mono_color_int", &face_mono_color_int, NULL)
        && face_mono_color_int == visualstyle->face_mono_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_mono_color_int [BS] %hu != %hu", visualstyle->face_mono_color_int, face_mono_color_int);
    face_mono_color_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_mono_color_int", &face_mono_color_int, 0)
        && face_mono_color_int == visualstyle->face_mono_color_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_mono_color_int [BS] set+1 %hu != %hu", visualstyle->face_mono_color_int, face_mono_color_int);
    visualstyle->face_mono_color_int--;
  }
  {
    BITCODE_BD face_opacity;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_opacity", &face_opacity, NULL)
        && face_opacity == visualstyle->face_opacity)
      pass ();
    else
      fail ("VISUALSTYLE.face_opacity [BD] %g != %g", visualstyle->face_opacity, face_opacity);
    face_opacity++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_opacity", &face_opacity, 0)
        && face_opacity == visualstyle->face_opacity)
      pass ();
    else
      fail ("VISUALSTYLE.face_opacity [BD] set+1 %g != %g", visualstyle->face_opacity, face_opacity);
    visualstyle->face_opacity--;
  }
  {
    BITCODE_BS face_opacity_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_opacity_int", &face_opacity_int, NULL)
        && face_opacity_int == visualstyle->face_opacity_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_opacity_int [BS] %hu != %hu", visualstyle->face_opacity_int, face_opacity_int);
    face_opacity_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_opacity_int", &face_opacity_int, 0)
        && face_opacity_int == visualstyle->face_opacity_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_opacity_int [BS] set+1 %hu != %hu", visualstyle->face_opacity_int, face_opacity_int);
    visualstyle->face_opacity_int--;
  }
  {
    BITCODE_BD face_specular;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_specular", &face_specular, NULL)
        && face_specular == visualstyle->face_specular)
      pass ();
    else
      fail ("VISUALSTYLE.face_specular [BD] %g != %g", visualstyle->face_specular, face_specular);
    face_specular++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_specular", &face_specular, 0)
        && face_specular == visualstyle->face_specular)
      pass ();
    else
      fail ("VISUALSTYLE.face_specular [BD] set+1 %g != %g", visualstyle->face_specular, face_specular);
    visualstyle->face_specular--;
  }
  {
    BITCODE_BS face_specular_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "face_specular_int", &face_specular_int, NULL)
        && face_specular_int == visualstyle->face_specular_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_specular_int [BS] %hu != %hu", visualstyle->face_specular_int, face_specular_int);
    face_specular_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "face_specular_int", &face_specular_int, 0)
        && face_specular_int == visualstyle->face_specular_int)
      pass ();
    else
      fail ("VISUALSTYLE.face_specular_int [BS] set+1 %hu != %hu", visualstyle->face_specular_int, face_specular_int);
    visualstyle->face_specular_int--;
  }
  {
    BITCODE_B internal_only;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "internal_only", &internal_only, NULL)
        && internal_only == visualstyle->internal_only)
      pass ();
    else
      fail ("VISUALSTYLE.internal_only [B] " FORMAT_B " != " FORMAT_B "", visualstyle->internal_only, internal_only);
    internal_only++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "internal_only", &internal_only, 0)
        && internal_only == visualstyle->internal_only)
      pass ();
    else
      fail ("VISUALSTYLE.internal_only [B] set+1 " FORMAT_B " != " FORMAT_B "", visualstyle->internal_only, internal_only);
    visualstyle->internal_only--;
  }
  {
    BITCODE_BS num_props;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "num_props", &num_props, NULL)
        && num_props == visualstyle->num_props)
      pass ();
    else
      fail ("VISUALSTYLE.num_props [BS] %hu != %hu", visualstyle->num_props, num_props);
    num_props++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "num_props", &num_props, 0)
        && num_props == visualstyle->num_props)
      pass ();
    else
      fail ("VISUALSTYLE.num_props [BS] set+1 %hu != %hu", visualstyle->num_props, num_props);
    visualstyle->num_props--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "parent", &parent, NULL)
        && !memcmp (&parent, &visualstyle->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("VISUALSTYLE.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_T strokes;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "strokes", &strokes, NULL)
        && strokes
           ? strEQ ((char *)strokes, (char *)visualstyle->strokes)
           : !visualstyle->strokes)
      pass ();
    else
      fail ("VISUALSTYLE.strokes [T] '%s' <> '%s'", strokes, visualstyle->strokes);
  }
  {
    BITCODE_BS strokes_int;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "strokes_int", &strokes_int, NULL)
        && strokes_int == visualstyle->strokes_int)
      pass ();
    else
      fail ("VISUALSTYLE.strokes_int [BS] %hu != %hu", visualstyle->strokes_int, strokes_int);
    strokes_int++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "strokes_int", &strokes_int, 0)
        && strokes_int == visualstyle->strokes_int)
      pass ();
    else
      fail ("VISUALSTYLE.strokes_int [BS] set+1 %hu != %hu", visualstyle->strokes_int, strokes_int);
    visualstyle->strokes_int--;
  }
  {
    BITCODE_BL style_type;
    if (dwg_dynapi_entity_value (visualstyle, "VISUALSTYLE", "style_type", &style_type, NULL)
        && style_type == visualstyle->style_type)
      pass ();
    else
      fail ("VISUALSTYLE.style_type [BL] %u != %u", visualstyle->style_type, style_type);
    style_type++;
    if (dwg_dynapi_entity_set_value (visualstyle, "VISUALSTYLE", "style_type", &style_type, 0)
        && style_type == visualstyle->style_type)
      pass ();
    else
      fail ("VISUALSTYLE.style_type [BL] set+1 %u != %u", visualstyle->style_type, style_type);
    visualstyle->style_type--;
  }
  if (failed && (is_class_unstable ("VISUALSTYLE") || is_class_debugging ("VISUALSTYLE")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VISUALSTYLE", failed);
      failed = 0;
    }
  return failed;
}
static int test_VPORT (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VPORT *restrict vport = obj->tio.object->tio.VPORT;
  failed = 0;
  if (!obj_obj || !vport)
    {
      fail ("NULL VPORT");
      return 1;
    }
  {
    BITCODE_B FASTZOOM;
    if (dwg_dynapi_entity_value (vport, "VPORT", "FASTZOOM", &FASTZOOM, NULL)
        && FASTZOOM == vport->FASTZOOM)
      pass ();
    else
      fail ("VPORT.FASTZOOM [B] " FORMAT_B " != " FORMAT_B "", vport->FASTZOOM, FASTZOOM);
    FASTZOOM++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "FASTZOOM", &FASTZOOM, 0)
        && FASTZOOM == vport->FASTZOOM)
      pass ();
    else
      fail ("VPORT.FASTZOOM [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->FASTZOOM, FASTZOOM);
    vport->FASTZOOM--;
  }
  {
    BITCODE_B GRIDMODE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "GRIDMODE", &GRIDMODE, NULL)
        && GRIDMODE == vport->GRIDMODE)
      pass ();
    else
      fail ("VPORT.GRIDMODE [B] " FORMAT_B " != " FORMAT_B "", vport->GRIDMODE, GRIDMODE);
    GRIDMODE++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "GRIDMODE", &GRIDMODE, 0)
        && GRIDMODE == vport->GRIDMODE)
      pass ();
    else
      fail ("VPORT.GRIDMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->GRIDMODE, GRIDMODE);
    vport->GRIDMODE--;
  }
  {
    BITCODE_2RD GRIDUNIT;
    if (dwg_dynapi_entity_value (vport, "VPORT", "GRIDUNIT", &GRIDUNIT, NULL)
        && !memcmp (&GRIDUNIT, &vport->GRIDUNIT, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VPORT.GRIDUNIT [2RD]");
  }
  {
    BITCODE_BD SNAPANG;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPANG", &SNAPANG, NULL)
        && SNAPANG == vport->SNAPANG)
      pass ();
    else
      fail ("VPORT.SNAPANG [BD] %g != %g", vport->SNAPANG, SNAPANG);
    SNAPANG++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "SNAPANG", &SNAPANG, 0)
        && SNAPANG == vport->SNAPANG)
      pass ();
    else
      fail ("VPORT.SNAPANG [BD] set+1 %g != %g", vport->SNAPANG, SNAPANG);
    vport->SNAPANG--;
  }
  {
    BITCODE_2RD SNAPBASE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPBASE", &SNAPBASE, NULL)
        && !memcmp (&SNAPBASE, &vport->SNAPBASE, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VPORT.SNAPBASE [2RD]");
  }
  {
    BITCODE_BS SNAPISOPAIR;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPISOPAIR", &SNAPISOPAIR, NULL)
        && SNAPISOPAIR == vport->SNAPISOPAIR)
      pass ();
    else
      fail ("VPORT.SNAPISOPAIR [BS] %hu != %hu", vport->SNAPISOPAIR, SNAPISOPAIR);
    SNAPISOPAIR++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "SNAPISOPAIR", &SNAPISOPAIR, 0)
        && SNAPISOPAIR == vport->SNAPISOPAIR)
      pass ();
    else
      fail ("VPORT.SNAPISOPAIR [BS] set+1 %hu != %hu", vport->SNAPISOPAIR, SNAPISOPAIR);
    vport->SNAPISOPAIR--;
  }
  {
    BITCODE_B SNAPMODE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPMODE", &SNAPMODE, NULL)
        && SNAPMODE == vport->SNAPMODE)
      pass ();
    else
      fail ("VPORT.SNAPMODE [B] " FORMAT_B " != " FORMAT_B "", vport->SNAPMODE, SNAPMODE);
    SNAPMODE++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "SNAPMODE", &SNAPMODE, 0)
        && SNAPMODE == vport->SNAPMODE)
      pass ();
    else
      fail ("VPORT.SNAPMODE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->SNAPMODE, SNAPMODE);
    vport->SNAPMODE--;
  }
  {
    BITCODE_B SNAPSTYLE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPSTYLE", &SNAPSTYLE, NULL)
        && SNAPSTYLE == vport->SNAPSTYLE)
      pass ();
    else
      fail ("VPORT.SNAPSTYLE [B] " FORMAT_B " != " FORMAT_B "", vport->SNAPSTYLE, SNAPSTYLE);
    SNAPSTYLE++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "SNAPSTYLE", &SNAPSTYLE, 0)
        && SNAPSTYLE == vport->SNAPSTYLE)
      pass ();
    else
      fail ("VPORT.SNAPSTYLE [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->SNAPSTYLE, SNAPSTYLE);
    vport->SNAPSTYLE--;
  }
  {
    BITCODE_2RD SNAPUNIT;
    if (dwg_dynapi_entity_value (vport, "VPORT", "SNAPUNIT", &SNAPUNIT, NULL)
        && !memcmp (&SNAPUNIT, &vport->SNAPUNIT, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VPORT.SNAPUNIT [2RD]");
  }
  {
    BITCODE_B UCSFOLLOW;
    if (dwg_dynapi_entity_value (vport, "VPORT", "UCSFOLLOW", &UCSFOLLOW, NULL)
        && UCSFOLLOW == vport->UCSFOLLOW)
      pass ();
    else
      fail ("VPORT.UCSFOLLOW [B] " FORMAT_B " != " FORMAT_B "", vport->UCSFOLLOW, UCSFOLLOW);
    UCSFOLLOW++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "UCSFOLLOW", &UCSFOLLOW, 0)
        && UCSFOLLOW == vport->UCSFOLLOW)
      pass ();
    else
      fail ("VPORT.UCSFOLLOW [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->UCSFOLLOW, UCSFOLLOW);
    vport->UCSFOLLOW--;
  }
  {
    BITCODE_RC UCSICON;
    if (dwg_dynapi_entity_value (vport, "VPORT", "UCSICON", &UCSICON, NULL)
        && UCSICON == vport->UCSICON)
      pass ();
    else
      fail ("VPORT.UCSICON [RC] %u != %u", vport->UCSICON, UCSICON);
    UCSICON++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "UCSICON", &UCSICON, 0)
        && UCSICON == vport->UCSICON)
      pass ();
    else
      fail ("VPORT.UCSICON [RC] set+1 %u != %u", vport->UCSICON, UCSICON);
    vport->UCSICON--;
  }
  {
    BITCODE_BS UCSORTHOVIEW;
    if (dwg_dynapi_entity_value (vport, "VPORT", "UCSORTHOVIEW", &UCSORTHOVIEW, NULL)
        && UCSORTHOVIEW == vport->UCSORTHOVIEW)
      pass ();
    else
      fail ("VPORT.UCSORTHOVIEW [BS] %hu != %hu", vport->UCSORTHOVIEW, UCSORTHOVIEW);
    UCSORTHOVIEW++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "UCSORTHOVIEW", &UCSORTHOVIEW, 0)
        && UCSORTHOVIEW == vport->UCSORTHOVIEW)
      pass ();
    else
      fail ("VPORT.UCSORTHOVIEW [BS] set+1 %hu != %hu", vport->UCSORTHOVIEW, UCSORTHOVIEW);
    vport->UCSORTHOVIEW--;
  }
  {
    BITCODE_B UCSVP;
    if (dwg_dynapi_entity_value (vport, "VPORT", "UCSVP", &UCSVP, NULL)
        && UCSVP == vport->UCSVP)
      pass ();
    else
      fail ("VPORT.UCSVP [B] " FORMAT_B " != " FORMAT_B "", vport->UCSVP, UCSVP);
    UCSVP++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "UCSVP", &UCSVP, 0)
        && UCSVP == vport->UCSVP)
      pass ();
    else
      fail ("VPORT.UCSVP [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->UCSVP, UCSVP);
    vport->UCSVP--;
  }
  {
    BITCODE_2RD VIEWCTR;
    if (dwg_dynapi_entity_value (vport, "VPORT", "VIEWCTR", &VIEWCTR, NULL)
        && !memcmp (&VIEWCTR, &vport->VIEWCTR, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VPORT.VIEWCTR [2RD]");
  }
  {
    BITCODE_3BD VIEWDIR;
    if (dwg_dynapi_entity_value (vport, "VPORT", "VIEWDIR", &VIEWDIR, NULL)
        && !memcmp (&VIEWDIR, &vport->VIEWDIR, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VPORT.VIEWDIR [3BD]");
  }
  {
    BITCODE_4BITS VIEWMODE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "VIEWMODE", &VIEWMODE, NULL)
        && VIEWMODE == vport->VIEWMODE)
      pass ();
    else
      fail ("VPORT.VIEWMODE [4BITS] " FORMAT_4BITS " != " FORMAT_4BITS "", vport->VIEWMODE, VIEWMODE);
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "VIEWMODE", &VIEWMODE, 0)
        && VIEWMODE == vport->VIEWMODE)
      pass ();
    else
      fail ("VPORT.VIEWMODE [4BITS] set+1 " FORMAT_4BITS " != " FORMAT_4BITS "", vport->VIEWMODE, VIEWMODE);
    vport->VIEWMODE--;
  }
  {
    BITCODE_BD VIEWSIZE;
    if (dwg_dynapi_entity_value (vport, "VPORT", "VIEWSIZE", &VIEWSIZE, NULL)
        && VIEWSIZE == vport->VIEWSIZE)
      pass ();
    else
      fail ("VPORT.VIEWSIZE [BD] %g != %g", vport->VIEWSIZE, VIEWSIZE);
    VIEWSIZE++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "VIEWSIZE", &VIEWSIZE, 0)
        && VIEWSIZE == vport->VIEWSIZE)
      pass ();
    else
      fail ("VPORT.VIEWSIZE [BD] set+1 %g != %g", vport->VIEWSIZE, VIEWSIZE);
    vport->VIEWSIZE--;
  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ambient_color", &ambient_color, NULL)
        && !memcmp (&ambient_color, &vport->ambient_color, sizeof (BITCODE_CMC)))
        pass ();
    else
        fail ("VPORT.ambient_color [CMC]");
  }
  {
    BITCODE_BD aspect_ratio;
    if (dwg_dynapi_entity_value (vport, "VPORT", "aspect_ratio", &aspect_ratio, NULL)
        && aspect_ratio == vport->aspect_ratio)
      pass ();
    else
      fail ("VPORT.aspect_ratio [BD] %g != %g", vport->aspect_ratio, aspect_ratio);
    aspect_ratio++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "aspect_ratio", &aspect_ratio, 0)
        && aspect_ratio == vport->aspect_ratio)
      pass ();
    else
      fail ("VPORT.aspect_ratio [BD] set+1 %g != %g", vport->aspect_ratio, aspect_ratio);
    vport->aspect_ratio--;
  }
  {
    BITCODE_BD back_clip_z;
    if (dwg_dynapi_entity_value (vport, "VPORT", "back_clip_z", &back_clip_z, NULL)
        && back_clip_z == vport->back_clip_z)
      pass ();
    else
      fail ("VPORT.back_clip_z [BD] %g != %g", vport->back_clip_z, back_clip_z);
    back_clip_z++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "back_clip_z", &back_clip_z, 0)
        && back_clip_z == vport->back_clip_z)
      pass ();
    else
      fail ("VPORT.back_clip_z [BD] set+1 %g != %g", vport->back_clip_z, back_clip_z);
    vport->back_clip_z--;
  }
  {
    BITCODE_H background;
    if (dwg_dynapi_entity_value (vport, "VPORT", "background", &background, NULL)
        && !memcmp (&background, &vport->background, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VPORT.background [H]");
  }
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value (vport, "VPORT", "base_ucs", &base_ucs, NULL)
        && !memcmp (&base_ucs, &vport->base_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VPORT.base_ucs [H]");
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value (vport, "VPORT", "brightness", &brightness, NULL)
        && brightness == vport->brightness)
      pass ();
    else
      fail ("VPORT.brightness [BD] %g != %g", vport->brightness, brightness);
    brightness++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "brightness", &brightness, 0)
        && brightness == vport->brightness)
      pass ();
    else
      fail ("VPORT.brightness [BD] set+1 %g != %g", vport->brightness, brightness);
    vport->brightness--;
  }
  {
    BITCODE_BS circle_zoom;
    if (dwg_dynapi_entity_value (vport, "VPORT", "circle_zoom", &circle_zoom, NULL)
        && circle_zoom == vport->circle_zoom)
      pass ();
    else
      fail ("VPORT.circle_zoom [BS] %hu != %hu", vport->circle_zoom, circle_zoom);
    circle_zoom++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "circle_zoom", &circle_zoom, 0)
        && circle_zoom == vport->circle_zoom)
      pass ();
    else
      fail ("VPORT.circle_zoom [BS] set+1 %hu != %hu", vport->circle_zoom, circle_zoom);
    vport->circle_zoom--;
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value (vport, "VPORT", "contrast", &contrast, NULL)
        && contrast == vport->contrast)
      pass ();
    else
      fail ("VPORT.contrast [BD] %g != %g", vport->contrast, contrast);
    contrast++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "contrast", &contrast, 0)
        && contrast == vport->contrast)
      pass ();
    else
      fail ("VPORT.contrast [BD] set+1 %g != %g", vport->contrast, contrast);
    vport->contrast--;
  }
  {
    BITCODE_RC default_lightning_type;
    if (dwg_dynapi_entity_value (vport, "VPORT", "default_lightning_type", &default_lightning_type, NULL)
        && default_lightning_type == vport->default_lightning_type)
      pass ();
    else
      fail ("VPORT.default_lightning_type [RC] %u != %u", vport->default_lightning_type, default_lightning_type);
    default_lightning_type++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "default_lightning_type", &default_lightning_type, 0)
        && default_lightning_type == vport->default_lightning_type)
      pass ();
    else
      fail ("VPORT.default_lightning_type [RC] set+1 %u != %u", vport->default_lightning_type, default_lightning_type);
    vport->default_lightning_type--;
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vport, "VPORT", "flag", &flag, NULL)
        && flag == vport->flag)
      pass ();
    else
      fail ("VPORT.flag [RC] %u != %u", vport->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "flag", &flag, 0)
        && flag == vport->flag)
      pass ();
    else
      fail ("VPORT.flag [RC] set+1 %u != %u", vport->flag, flag);
    vport->flag--;
  }
  {
    BITCODE_BD front_clip_z;
    if (dwg_dynapi_entity_value (vport, "VPORT", "front_clip_z", &front_clip_z, NULL)
        && front_clip_z == vport->front_clip_z)
      pass ();
    else
      fail ("VPORT.front_clip_z [BD] %g != %g", vport->front_clip_z, front_clip_z);
    front_clip_z++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "front_clip_z", &front_clip_z, 0)
        && front_clip_z == vport->front_clip_z)
      pass ();
    else
      fail ("VPORT.front_clip_z [BD] set+1 %g != %g", vport->front_clip_z, front_clip_z);
    vport->front_clip_z--;
  }
  {
    BITCODE_BS grid_flags;
    if (dwg_dynapi_entity_value (vport, "VPORT", "grid_flags", &grid_flags, NULL)
        && grid_flags == vport->grid_flags)
      pass ();
    else
      fail ("VPORT.grid_flags [BS] %hu != %hu", vport->grid_flags, grid_flags);
    grid_flags++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "grid_flags", &grid_flags, 0)
        && grid_flags == vport->grid_flags)
      pass ();
    else
      fail ("VPORT.grid_flags [BS] set+1 %hu != %hu", vport->grid_flags, grid_flags);
    vport->grid_flags--;
  }
  {
    BITCODE_BS grid_major;
    if (dwg_dynapi_entity_value (vport, "VPORT", "grid_major", &grid_major, NULL)
        && grid_major == vport->grid_major)
      pass ();
    else
      fail ("VPORT.grid_major [BS] %hu != %hu", vport->grid_major, grid_major);
    grid_major++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "grid_major", &grid_major, 0)
        && grid_major == vport->grid_major)
      pass ();
    else
      fail ("VPORT.grid_major [BS] set+1 %hu != %hu", vport->grid_major, grid_major);
    vport->grid_major--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (vport, "VPORT", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == vport->is_xref_dep)
      pass ();
    else
      fail ("VPORT.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", vport->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == vport->is_xref_dep)
      pass ();
    else
      fail ("VPORT.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->is_xref_dep, is_xref_dep);
    vport->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (vport, "VPORT", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == vport->is_xref_ref)
      pass ();
    else
      fail ("VPORT.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", vport->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == vport->is_xref_ref)
      pass ();
    else
      fail ("VPORT.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->is_xref_ref, is_xref_ref);
    vport->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (vport, "VPORT", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == vport->is_xref_resolved)
      pass ();
    else
      fail ("VPORT.is_xref_resolved [BS] %hu != %hu", vport->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == vport->is_xref_resolved)
      pass ();
    else
      fail ("VPORT.is_xref_resolved [BS] set+1 %hu != %hu", vport->is_xref_resolved, is_xref_resolved);
    vport->is_xref_resolved--;
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value (vport, "VPORT", "lens_length", &lens_length, NULL)
        && lens_length == vport->lens_length)
      pass ();
    else
      fail ("VPORT.lens_length [BD] %g != %g", vport->lens_length, lens_length);
    lens_length++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "lens_length", &lens_length, 0)
        && lens_length == vport->lens_length)
      pass ();
    else
      fail ("VPORT.lens_length [BD] set+1 %g != %g", vport->lens_length, lens_length);
    vport->lens_length--;
  }
  {
    BITCODE_2RD lower_left;
    if (dwg_dynapi_entity_value (vport, "VPORT", "lower_left", &lower_left, NULL)
        && !memcmp (&lower_left, &vport->lower_left, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VPORT.lower_left [2RD]");
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (vport, "VPORT", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)vport->name)
           : !vport->name)
      pass ();
    else
      fail ("VPORT.name [TV] '%s' <> '%s'", name, vport->name);
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value (vport, "VPORT", "named_ucs", &named_ucs, NULL)
        && !memcmp (&named_ucs, &vport->named_ucs, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VPORT.named_ucs [H]");
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vport, "VPORT", "parent", &parent, NULL)
        && !memcmp (&parent, &vport->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("VPORT.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value (vport, "VPORT", "render_mode", &render_mode, NULL)
        && render_mode == vport->render_mode)
      pass ();
    else
      fail ("VPORT.render_mode [RC] %u != %u", vport->render_mode, render_mode);
    render_mode++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "render_mode", &render_mode, 0)
        && render_mode == vport->render_mode)
      pass ();
    else
      fail ("VPORT.render_mode [RC] set+1 %u != %u", vport->render_mode, render_mode);
    vport->render_mode--;
  }
  {
    BITCODE_H sun;
    if (dwg_dynapi_entity_value (vport, "VPORT", "sun", &sun, NULL)
        && !memcmp (&sun, &vport->sun, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VPORT.sun [H]");
  }
  {
    BITCODE_B ucs_at_origin;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucs_at_origin", &ucs_at_origin, NULL)
        && ucs_at_origin == vport->ucs_at_origin)
      pass ();
    else
      fail ("VPORT.ucs_at_origin [B] " FORMAT_B " != " FORMAT_B "", vport->ucs_at_origin, ucs_at_origin);
    ucs_at_origin++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "ucs_at_origin", &ucs_at_origin, 0)
        && ucs_at_origin == vport->ucs_at_origin)
      pass ();
    else
      fail ("VPORT.ucs_at_origin [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->ucs_at_origin, ucs_at_origin);
    vport->ucs_at_origin--;
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucs_elevation", &ucs_elevation, NULL)
        && ucs_elevation == vport->ucs_elevation)
      pass ();
    else
      fail ("VPORT.ucs_elevation [BD] %g != %g", vport->ucs_elevation, ucs_elevation);
    ucs_elevation++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "ucs_elevation", &ucs_elevation, 0)
        && ucs_elevation == vport->ucs_elevation)
      pass ();
    else
      fail ("VPORT.ucs_elevation [BD] set+1 %g != %g", vport->ucs_elevation, ucs_elevation);
    vport->ucs_elevation--;
  }
  {
    BITCODE_3BD ucsorg;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucsorg", &ucsorg, NULL)
        && !memcmp (&ucsorg, &vport->ucsorg, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VPORT.ucsorg [3BD]");
  }
  {
    BITCODE_3BD ucsxdir;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucsxdir", &ucsxdir, NULL)
        && !memcmp (&ucsxdir, &vport->ucsxdir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VPORT.ucsxdir [3BD]");
  }
  {
    BITCODE_3BD ucsydir;
    if (dwg_dynapi_entity_value (vport, "VPORT", "ucsydir", &ucsydir, NULL)
        && !memcmp (&ucsydir, &vport->ucsydir, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VPORT.ucsydir [3BD]");
  }
  {
    BITCODE_2RD upper_right;
    if (dwg_dynapi_entity_value (vport, "VPORT", "upper_right", &upper_right, NULL)
        && !memcmp (&upper_right, &vport->upper_right, sizeof (BITCODE_2RD)))
        pass ();
    else
        fail ("VPORT.upper_right [2RD]");
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value (vport, "VPORT", "use_default_lights", &use_default_lights, NULL)
        && use_default_lights == vport->use_default_lights)
      pass ();
    else
      fail ("VPORT.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", vport->use_default_lights, use_default_lights);
    use_default_lights++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "use_default_lights", &use_default_lights, 0)
        && use_default_lights == vport->use_default_lights)
      pass ();
    else
      fail ("VPORT.use_default_lights [B] set+1 " FORMAT_B " != " FORMAT_B "", vport->use_default_lights, use_default_lights);
    vport->use_default_lights--;
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (vport, "VPORT", "used", &used, NULL)
        && used == vport->used)
      pass ();
    else
      fail ("VPORT.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", vport->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "used", &used, 0)
        && used == vport->used)
      pass ();
    else
      fail ("VPORT.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", vport->used, used);
    vport->used--;
  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value (vport, "VPORT", "view_target", &view_target, NULL)
        && !memcmp (&view_target, &vport->view_target, sizeof (BITCODE_3BD)))
        pass ();
    else
        fail ("VPORT.view_target [3BD]");
  }
  {
    BITCODE_BD view_twist;
    if (dwg_dynapi_entity_value (vport, "VPORT", "view_twist", &view_twist, NULL)
        && view_twist == vport->view_twist)
      pass ();
    else
      fail ("VPORT.view_twist [BD] %g != %g", vport->view_twist, view_twist);
    view_twist++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "view_twist", &view_twist, 0)
        && view_twist == vport->view_twist)
      pass ();
    else
      fail ("VPORT.view_twist [BD] set+1 %g != %g", vport->view_twist, view_twist);
    vport->view_twist--;
  }
  {
    BITCODE_BD view_width;
    if (dwg_dynapi_entity_value (vport, "VPORT", "view_width", &view_width, NULL)
        && view_width == vport->view_width)
      pass ();
    else
      fail ("VPORT.view_width [BD] %g != %g", vport->view_width, view_width);
    view_width++;
    if (dwg_dynapi_entity_set_value (vport, "VPORT", "view_width", &view_width, 0)
        && view_width == vport->view_width)
      pass ();
    else
      fail ("VPORT.view_width [BD] set+1 %g != %g", vport->view_width, view_width);
    vport->view_width--;
  }
  {
    BITCODE_H visualstyle;
    if (dwg_dynapi_entity_value (vport, "VPORT", "visualstyle", &visualstyle, NULL)
        && !memcmp (&visualstyle, &vport->visualstyle, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VPORT.visualstyle [H]");
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (vport, "VPORT", "xref", &xref, NULL)
        && !memcmp (&xref, &vport->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VPORT.xref [H]");
  }
  if (failed && (is_class_unstable ("VPORT") || is_class_debugging ("VPORT")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VPORT", failed);
      failed = 0;
    }
  return failed;
}
static int test_VPORT_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VPORT_CONTROL *restrict vport_control = obj->tio.object->tio.VPORT_CONTROL;
  failed = 0;
  if (!obj_obj || !vport_control)
    {
      fail ("NULL VPORT_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "entries", &entries, NULL)
        && entries == vport_control->entries)
      pass ();
    else
      fail ("VPORT_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == vport_control->flags_r11)
      pass ();
    else
      fail ("VPORT_CONTROL.flags_r11 [RS] %hu != %hu", vport_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (vport_control, "VPORT_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == vport_control->flags_r11)
      pass ();
    else
      fail ("VPORT_CONTROL.flags_r11 [RS] set+1 %hu != %hu", vport_control->flags_r11, flags_r11);
    vport_control->flags_r11--;
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == vport_control->num_entries)
      pass ();
    else
      fail ("VPORT_CONTROL.num_entries [BS] %hu != %hu", vport_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (vport_control, "VPORT_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == vport_control->num_entries)
      pass ();
    else
      fail ("VPORT_CONTROL.num_entries [BS] set+1 %hu != %hu", vport_control->num_entries, num_entries);
    vport_control->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vport_control, "VPORT_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &vport_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("VPORT_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("VPORT_CONTROL") || is_class_debugging ("VPORT_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VPORT_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_VX_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VX_CONTROL *restrict vx_control = obj->tio.object->tio.VX_CONTROL;
  failed = 0;
  if (!obj_obj || !vx_control)
    {
      fail ("NULL VX_CONTROL");
      return 1;
    }
  {
    BITCODE_H* entries;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (vx_control, "VX_CONTROL", "num_entries", &count, NULL)
        && dwg_dynapi_entity_value (vx_control, "VX_CONTROL", "entries", &entries, NULL)
        && entries == vx_control->entries)
      pass ();
    else
      fail ("VX_CONTROL.entries [H*] * %u num_entries", count);
  }
  {
    BITCODE_RS flags_r11;
    if (dwg_dynapi_entity_value (vx_control, "VX_CONTROL", "flags_r11", &flags_r11, NULL)
        && flags_r11 == vx_control->flags_r11)
      pass ();
    else
      fail ("VX_CONTROL.flags_r11 [RS] %hu != %hu", vx_control->flags_r11, flags_r11);
    flags_r11++;
    if (dwg_dynapi_entity_set_value (vx_control, "VX_CONTROL", "flags_r11", &flags_r11, 0)
        && flags_r11 == vx_control->flags_r11)
      pass ();
    else
      fail ("VX_CONTROL.flags_r11 [RS] set+1 %hu != %hu", vx_control->flags_r11, flags_r11);
    vx_control->flags_r11--;
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value (vx_control, "VX_CONTROL", "num_entries", &num_entries, NULL)
        && num_entries == vx_control->num_entries)
      pass ();
    else
      fail ("VX_CONTROL.num_entries [BS] %hu != %hu", vx_control->num_entries, num_entries);
    num_entries++;
    if (dwg_dynapi_entity_set_value (vx_control, "VX_CONTROL", "num_entries", &num_entries, 0)
        && num_entries == vx_control->num_entries)
      pass ();
    else
      fail ("VX_CONTROL.num_entries [BS] set+1 %hu != %hu", vx_control->num_entries, num_entries);
    vx_control->num_entries--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vx_control, "VX_CONTROL", "parent", &parent, NULL)
        && !memcmp (&parent, &vx_control->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("VX_CONTROL.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("VX_CONTROL") || is_class_debugging ("VX_CONTROL")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VX_CONTROL", failed);
      failed = 0;
    }
  return failed;
}
static int test_VX_TABLE_RECORD (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_VX_TABLE_RECORD *restrict vx_table_record = obj->tio.object->tio.VX_TABLE_RECORD;
  failed = 0;
  if (!obj_obj || !vx_table_record)
    {
      fail ("NULL VX_TABLE_RECORD");
      return 1;
    }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "flag", &flag, NULL)
        && flag == vx_table_record->flag)
      pass ();
    else
      fail ("VX_TABLE_RECORD.flag [RC] %u != %u", vx_table_record->flag, flag);
    flag++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "flag", &flag, 0)
        && flag == vx_table_record->flag)
      pass ();
    else
      fail ("VX_TABLE_RECORD.flag [RC] set+1 %u != %u", vx_table_record->flag, flag);
    vx_table_record->flag--;
  }
  {
    BITCODE_B is_on;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "is_on", &is_on, NULL)
        && is_on == vx_table_record->is_on)
      pass ();
    else
      fail ("VX_TABLE_RECORD.is_on [B] " FORMAT_B " != " FORMAT_B "", vx_table_record->is_on, is_on);
    is_on++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "is_on", &is_on, 0)
        && is_on == vx_table_record->is_on)
      pass ();
    else
      fail ("VX_TABLE_RECORD.is_on [B] set+1 " FORMAT_B " != " FORMAT_B "", vx_table_record->is_on, is_on);
    vx_table_record->is_on--;
  }
  {
    BITCODE_B is_xref_dep;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "is_xref_dep", &is_xref_dep, NULL)
        && is_xref_dep == vx_table_record->is_xref_dep)
      pass ();
    else
      fail ("VX_TABLE_RECORD.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", vx_table_record->is_xref_dep, is_xref_dep);
    is_xref_dep++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "is_xref_dep", &is_xref_dep, 0)
        && is_xref_dep == vx_table_record->is_xref_dep)
      pass ();
    else
      fail ("VX_TABLE_RECORD.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", vx_table_record->is_xref_dep, is_xref_dep);
    vx_table_record->is_xref_dep--;
  }
  {
    BITCODE_B is_xref_ref;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "is_xref_ref", &is_xref_ref, NULL)
        && is_xref_ref == vx_table_record->is_xref_ref)
      pass ();
    else
      fail ("VX_TABLE_RECORD.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", vx_table_record->is_xref_ref, is_xref_ref);
    is_xref_ref++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "is_xref_ref", &is_xref_ref, 0)
        && is_xref_ref == vx_table_record->is_xref_ref)
      pass ();
    else
      fail ("VX_TABLE_RECORD.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", vx_table_record->is_xref_ref, is_xref_ref);
    vx_table_record->is_xref_ref--;
  }
  {
    BITCODE_BS is_xref_resolved;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "is_xref_resolved", &is_xref_resolved, NULL)
        && is_xref_resolved == vx_table_record->is_xref_resolved)
      pass ();
    else
      fail ("VX_TABLE_RECORD.is_xref_resolved [BS] %hu != %hu", vx_table_record->is_xref_resolved, is_xref_resolved);
    is_xref_resolved++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "is_xref_resolved", &is_xref_resolved, 0)
        && is_xref_resolved == vx_table_record->is_xref_resolved)
      pass ();
    else
      fail ("VX_TABLE_RECORD.is_xref_resolved [BS] set+1 %hu != %hu", vx_table_record->is_xref_resolved, is_xref_resolved);
    vx_table_record->is_xref_resolved--;
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)vx_table_record->name)
           : !vx_table_record->name)
      pass ();
    else
      fail ("VX_TABLE_RECORD.name [TV] '%s' <> '%s'", name, vx_table_record->name);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "parent", &parent, NULL)
        && !memcmp (&parent, &vx_table_record->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("VX_TABLE_RECORD.parent [struct _dwg_object_object*]");
  }
  {
    BITCODE_H prev_entry;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "prev_entry", &prev_entry, NULL)
        && !memcmp (&prev_entry, &vx_table_record->prev_entry, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VX_TABLE_RECORD.prev_entry [H]");
  }
  {
    BITCODE_RSd unknown1;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "unknown1", &unknown1, NULL)
        && unknown1 == vx_table_record->unknown1)
      pass ();
    else
      fail ("VX_TABLE_RECORD.unknown1 [RSd] " FORMAT_RSd " != " FORMAT_RSd "", vx_table_record->unknown1, unknown1);
    unknown1++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "unknown1", &unknown1, 0)
        && unknown1 == vx_table_record->unknown1)
      pass ();
    else
      fail ("VX_TABLE_RECORD.unknown1 [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", vx_table_record->unknown1, unknown1);
    vx_table_record->unknown1--;
  }
  {
    BITCODE_RS unknown2;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "unknown2", &unknown2, NULL)
        && unknown2 == vx_table_record->unknown2)
      pass ();
    else
      fail ("VX_TABLE_RECORD.unknown2 [RS] %hu != %hu", vx_table_record->unknown2, unknown2);
    unknown2++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "unknown2", &unknown2, 0)
        && unknown2 == vx_table_record->unknown2)
      pass ();
    else
      fail ("VX_TABLE_RECORD.unknown2 [RS] set+1 %hu != %hu", vx_table_record->unknown2, unknown2);
    vx_table_record->unknown2--;
  }
  {
    BITCODE_RSd used;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "used", &used, NULL)
        && used == vx_table_record->used)
      pass ();
    else
      fail ("VX_TABLE_RECORD.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", vx_table_record->used, used);
    used++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "used", &used, 0)
        && used == vx_table_record->used)
      pass ();
    else
      fail ("VX_TABLE_RECORD.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", vx_table_record->used, used);
    vx_table_record->used--;
  }
  {
    BITCODE_H viewport;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "viewport", &viewport, NULL)
        && !memcmp (&viewport, &vx_table_record->viewport, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VX_TABLE_RECORD.viewport [H]");
  }
  {
    BITCODE_RS vport_entity_address;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "vport_entity_address", &vport_entity_address, NULL)
        && vport_entity_address == vx_table_record->vport_entity_address)
      pass ();
    else
      fail ("VX_TABLE_RECORD.vport_entity_address [RS] %hu != %hu", vx_table_record->vport_entity_address, vport_entity_address);
    vport_entity_address++;
    if (dwg_dynapi_entity_set_value (vx_table_record, "VX_TABLE_RECORD", "vport_entity_address", &vport_entity_address, 0)
        && vport_entity_address == vx_table_record->vport_entity_address)
      pass ();
    else
      fail ("VX_TABLE_RECORD.vport_entity_address [RS] set+1 %hu != %hu", vx_table_record->vport_entity_address, vport_entity_address);
    vx_table_record->vport_entity_address--;
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value (vx_table_record, "VX_TABLE_RECORD", "xref", &xref, NULL)
        && !memcmp (&xref, &vx_table_record->xref, sizeof (BITCODE_H)))
        pass ();
    else
        fail ("VX_TABLE_RECORD.xref [H]");
  }
  if (failed && (is_class_unstable ("VX_TABLE_RECORD") || is_class_debugging ("VX_TABLE_RECORD")))
    {
      ok ("%s failed %d tests (TODO unstable)", "VX_TABLE_RECORD", failed);
      failed = 0;
    }
  return failed;
}
static int test_WIPEOUTVARIABLES (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_WIPEOUTVARIABLES *restrict wipeoutvariables = obj->tio.object->tio.WIPEOUTVARIABLES;
  failed = 0;
  if (!obj_obj || !wipeoutvariables)
    {
      fail ("NULL WIPEOUTVARIABLES");
      return 1;
    }
  {
    BITCODE_BS display_frame;
    if (dwg_dynapi_entity_value (wipeoutvariables, "WIPEOUTVARIABLES", "display_frame", &display_frame, NULL)
        && display_frame == wipeoutvariables->display_frame)
      pass ();
    else
      fail ("WIPEOUTVARIABLES.display_frame [BS] %hu != %hu", wipeoutvariables->display_frame, display_frame);
    display_frame++;
    if (dwg_dynapi_entity_set_value (wipeoutvariables, "WIPEOUTVARIABLES", "display_frame", &display_frame, 0)
        && display_frame == wipeoutvariables->display_frame)
      pass ();
    else
      fail ("WIPEOUTVARIABLES.display_frame [BS] set+1 %hu != %hu", wipeoutvariables->display_frame, display_frame);
    wipeoutvariables->display_frame--;
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (wipeoutvariables, "WIPEOUTVARIABLES", "parent", &parent, NULL)
        && !memcmp (&parent, &wipeoutvariables->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("WIPEOUTVARIABLES.parent [struct _dwg_object_object*]");
  }
  if (failed && (is_class_unstable ("WIPEOUTVARIABLES") || is_class_debugging ("WIPEOUTVARIABLES")))
    {
      ok ("%s failed %d tests (TODO unstable)", "WIPEOUTVARIABLES", failed);
      failed = 0;
    }
  return failed;
}
static int test_XRECORD (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_XRECORD *restrict xrecord = obj->tio.object->tio.XRECORD;
  failed = 0;
  if (!obj_obj || !xrecord)
    {
      fail ("NULL XRECORD");
      return 1;
    }
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "cloning", &cloning, NULL)
        && cloning == xrecord->cloning)
      pass ();
    else
      fail ("XRECORD.cloning [BS] %hu != %hu", xrecord->cloning, cloning);
    cloning++;
    if (dwg_dynapi_entity_set_value (xrecord, "XRECORD", "cloning", &cloning, 0)
        && cloning == xrecord->cloning)
      pass ();
    else
      fail ("XRECORD.cloning [BS] set+1 %hu != %hu", xrecord->cloning, cloning);
    xrecord->cloning--;
  }
  {
    BITCODE_BL num_objid_handles;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "num_objid_handles", &num_objid_handles, NULL)
        && num_objid_handles == xrecord->num_objid_handles)
      pass ();
    else
      fail ("XRECORD.num_objid_handles [BL] %u != %u", xrecord->num_objid_handles, num_objid_handles);
    num_objid_handles++;
    if (dwg_dynapi_entity_set_value (xrecord, "XRECORD", "num_objid_handles", &num_objid_handles, 0)
        && num_objid_handles == xrecord->num_objid_handles)
      pass ();
    else
      fail ("XRECORD.num_objid_handles [BL] set+1 %u != %u", xrecord->num_objid_handles, num_objid_handles);
    xrecord->num_objid_handles--;
  }
  {
    BITCODE_BL num_xdata;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "num_xdata", &num_xdata, NULL)
        && num_xdata == xrecord->num_xdata)
      pass ();
    else
      fail ("XRECORD.num_xdata [BL] %u != %u", xrecord->num_xdata, num_xdata);
    num_xdata++;
    if (dwg_dynapi_entity_set_value (xrecord, "XRECORD", "num_xdata", &num_xdata, 0)
        && num_xdata == xrecord->num_xdata)
      pass ();
    else
      fail ("XRECORD.num_xdata [BL] set+1 %u != %u", xrecord->num_xdata, num_xdata);
    xrecord->num_xdata--;
  }
  {
    BITCODE_H* objid_handles;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "num_objid_handles", &count, NULL)
        && dwg_dynapi_entity_value (xrecord, "XRECORD", "objid_handles", &objid_handles, NULL)
        && objid_handles == xrecord->objid_handles)
      pass ();
    else
      fail ("XRECORD.objid_handles [H*] * %u num_objid_handles", count);
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "parent", &parent, NULL)
        && !memcmp (&parent, &xrecord->parent, sizeof (struct _dwg_object_object*)))
        pass ();
    else
        fail ("XRECORD.parent [struct _dwg_object_object*]");
  }
  {
    Dwg_Resbuf* xdata;
    BITCODE_BL count = 0;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "num_xdata", &count, NULL)
        && dwg_dynapi_entity_value (xrecord, "XRECORD", "xdata", &xdata, NULL)
        && xdata == xrecord->xdata)
      pass ();
    else
      fail ("XRECORD.xdata [Dwg_Resbuf*] * %u num_xdata", count);
  }
  {
    BITCODE_BL xdata_size;
    if (dwg_dynapi_entity_value (xrecord, "XRECORD", "xdata_size", &xdata_size, NULL)
        && xdata_size == xrecord->xdata_size)
      pass ();
    else
      fail ("XRECORD.xdata_size [BL] %u != %u", xrecord->xdata_size, xdata_size);
    xdata_size++;
    if (dwg_dynapi_entity_set_value (xrecord, "XRECORD", "xdata_size", &xdata_size, 0)
        && xdata_size == xrecord->xdata_size)
      pass ();
    else
      fail ("XRECORD.xdata_size [BL] set+1 %u != %u", xrecord->xdata_size, xdata_size);
    xrecord->xdata_size--;
  }
  if (failed && (is_class_unstable ("XRECORD") || is_class_debugging ("XRECORD")))
    {
      ok ("%s failed %d tests (TODO unstable)", "XRECORD", failed);
      failed = 0;
    }
  return failed;
}
static int test_PDFDEFINITION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_PDFDEFINITION *restrict pdfdefinition = obj->tio.object->tio.PDFDEFINITION;
  failed = 0;
  if (!obj_obj || !pdfdefinition)
    {
      fail ("NULL PDFDEFINITION");
      return 1;
    }
  {
    BITCODE_T filename;
    if (dwg_dynapi_entity_value (pdfdefinition, "PDFDEFINITION", "filename", &filename, NULL)
        && filename
           ? strEQ ((char *)filename, (char *)pdfdefinition->filename)
           : !pdfdefinition->filename)
      pass ();
    else
      fail ("PDFDEFINITION.filename [T] '%s' <> '%s'", filename, pdfdefinition->filename);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (pdfdefinition, "PDFDEFINITION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)pdfdefinition->name)
           : !pdfdefinition->name)
      pass ();
    else
      fail ("PDFDEFINITION.name [T] '%s' <> '%s'", name, pdfdefinition->name);
  }
  if (failed && (is_class_unstable ("PDFDEFINITION") || is_class_debugging ("PDFDEFINITION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "PDFDEFINITION", failed);
      failed = 0;
    }
  return failed;
}
static int test_DGNDEFINITION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DGNDEFINITION *restrict dgndefinition = obj->tio.object->tio.DGNDEFINITION;
  failed = 0;
  if (!obj_obj || !dgndefinition)
    {
      fail ("NULL DGNDEFINITION");
      return 1;
    }
  {
    BITCODE_T filename;
    if (dwg_dynapi_entity_value (dgndefinition, "DGNDEFINITION", "filename", &filename, NULL)
        && filename
           ? strEQ ((char *)filename, (char *)dgndefinition->filename)
           : !dgndefinition->filename)
      pass ();
    else
      fail ("DGNDEFINITION.filename [T] '%s' <> '%s'", filename, dgndefinition->filename);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (dgndefinition, "DGNDEFINITION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)dgndefinition->name)
           : !dgndefinition->name)
      pass ();
    else
      fail ("DGNDEFINITION.name [T] '%s' <> '%s'", name, dgndefinition->name);
  }
  if (failed && (is_class_unstable ("DGNDEFINITION") || is_class_debugging ("DGNDEFINITION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DGNDEFINITION", failed);
      failed = 0;
    }
  return failed;
}
static int test_DWFDEFINITION (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_DWFDEFINITION *restrict dwfdefinition = obj->tio.object->tio.DWFDEFINITION;
  failed = 0;
  if (!obj_obj || !dwfdefinition)
    {
      fail ("NULL DWFDEFINITION");
      return 1;
    }
  {
    BITCODE_T filename;
    if (dwg_dynapi_entity_value (dwfdefinition, "DWFDEFINITION", "filename", &filename, NULL)
        && filename
           ? strEQ ((char *)filename, (char *)dwfdefinition->filename)
           : !dwfdefinition->filename)
      pass ();
    else
      fail ("DWFDEFINITION.filename [T] '%s' <> '%s'", filename, dwfdefinition->filename);
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value (dwfdefinition, "DWFDEFINITION", "name", &name, NULL)
        && name
           ? strEQ ((char *)name, (char *)dwfdefinition->name)
           : !dwfdefinition->name)
      pass ();
    else
      fail ("DWFDEFINITION.name [T] '%s' <> '%s'", name, dwfdefinition->name);
  }
  if (failed && (is_class_unstable ("DWFDEFINITION") || is_class_debugging ("DWFDEFINITION")))
    {
      ok ("%s failed %d tests (TODO unstable)", "DWFDEFINITION", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCARRAYMODIFYPARAMETERS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCARRAYMODIFYPARAMETERS *restrict assocarraymodifyparameters = obj->tio.object->tio.ASSOCARRAYMODIFYPARAMETERS;
  failed = 0;
  if (!obj_obj || !assocarraymodifyparameters)
    {
      fail ("NULL ASSOCARRAYMODIFYPARAMETERS");
      return 1;
    }
  {
    BITCODE_T classname;
    if (dwg_dynapi_entity_value (assocarraymodifyparameters, "ASSOCARRAYMODIFYPARAMETERS", "classname", &classname, NULL)
        && classname
           ? strEQ ((char *)classname, (char *)assocarraymodifyparameters->classname)
           : !assocarraymodifyparameters->classname)
      pass ();
    else
      fail ("ASSOCARRAYMODIFYPARAMETERS.classname [T] '%s' <> '%s'", classname, assocarraymodifyparameters->classname);
  }
  if (failed && (is_class_unstable ("ASSOCARRAYMODIFYPARAMETERS") || is_class_debugging ("ASSOCARRAYMODIFYPARAMETERS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCARRAYMODIFYPARAMETERS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCARRAYPATHPARAMETERS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCARRAYPATHPARAMETERS *restrict assocarraypathparameters = obj->tio.object->tio.ASSOCARRAYPATHPARAMETERS;
  failed = 0;
  if (!obj_obj || !assocarraypathparameters)
    {
      fail ("NULL ASSOCARRAYPATHPARAMETERS");
      return 1;
    }
  {
    BITCODE_T classname;
    if (dwg_dynapi_entity_value (assocarraypathparameters, "ASSOCARRAYPATHPARAMETERS", "classname", &classname, NULL)
        && classname
           ? strEQ ((char *)classname, (char *)assocarraypathparameters->classname)
           : !assocarraypathparameters->classname)
      pass ();
    else
      fail ("ASSOCARRAYPATHPARAMETERS.classname [T] '%s' <> '%s'", classname, assocarraypathparameters->classname);
  }
  if (failed && (is_class_unstable ("ASSOCARRAYPATHPARAMETERS") || is_class_debugging ("ASSOCARRAYPATHPARAMETERS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCARRAYPATHPARAMETERS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCARRAYPOLARPARAMETERS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCARRAYPOLARPARAMETERS *restrict assocarraypolarparameters = obj->tio.object->tio.ASSOCARRAYPOLARPARAMETERS;
  failed = 0;
  if (!obj_obj || !assocarraypolarparameters)
    {
      fail ("NULL ASSOCARRAYPOLARPARAMETERS");
      return 1;
    }
  {
    BITCODE_T classname;
    if (dwg_dynapi_entity_value (assocarraypolarparameters, "ASSOCARRAYPOLARPARAMETERS", "classname", &classname, NULL)
        && classname
           ? strEQ ((char *)classname, (char *)assocarraypolarparameters->classname)
           : !assocarraypolarparameters->classname)
      pass ();
    else
      fail ("ASSOCARRAYPOLARPARAMETERS.classname [T] '%s' <> '%s'", classname, assocarraypolarparameters->classname);
  }
  if (failed && (is_class_unstable ("ASSOCARRAYPOLARPARAMETERS") || is_class_debugging ("ASSOCARRAYPOLARPARAMETERS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCARRAYPOLARPARAMETERS", failed);
      failed = 0;
    }
  return failed;
}
static int test_ASSOCARRAYRECTANGULARPARAMETERS (const Dwg_Object *obj)
{
  int error = 0;
  const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
  Dwg_Object_ASSOCARRAYRECTANGULARPARAMETERS *restrict assocarrayrectangularparameters = obj->tio.object->tio.ASSOCARRAYRECTANGULARPARAMETERS;
  failed = 0;
  if (!obj_obj || !assocarrayrectangularparameters)
    {
      fail ("NULL ASSOCARRAYRECTANGULARPARAMETERS");
      return 1;
    }
  {
    BITCODE_T classname;
    if (dwg_dynapi_entity_value (assocarrayrectangularparameters, "ASSOCARRAYRECTANGULARPARAMETERS", "classname", &classname, NULL)
        && classname
           ? strEQ ((char *)classname, (char *)assocarrayrectangularparameters->classname)
           : !assocarrayrectangularparameters->classname)
      pass ();
    else
      fail ("ASSOCARRAYRECTANGULARPARAMETERS.classname [T] '%s' <> '%s'", classname, assocarrayrectangularparameters->classname);
  }
  if (failed && (is_class_unstable ("ASSOCARRAYRECTANGULARPARAMETERS") || is_class_debugging ("ASSOCARRAYRECTANGULARPARAMETERS")))
    {
      ok ("%s failed %d tests (TODO unstable)", "ASSOCARRAYRECTANGULARPARAMETERS", failed);
      failed = 0;
    }
  return failed;
}

#line 53 "dynapi_test.c.in"
static int
test_object (const Dwg_Data *restrict dwg, const Dwg_Object *restrict obj)
{
  int error = 0;
#line 62158 "dynapi_test.c"
  /* @@for if_test_OBJECT@@ */
  if (obj->fixedtype == DWG_TYPE__3DFACE)
    error += test__3DFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE__3DLINE)
    error += test__3DLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE__3DSOLID)
    error += test__3DSOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_ALIGNMENTPARAMETERENTITY)
    error += test_ALIGNMENTPARAMETERENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARCALIGNEDTEXT)
    error += test_ARCALIGNEDTEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC_DIMENSION)
    error += test_ARC_DIMENSION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTDEF)
    error += test_ATTDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTRIB)
    error += test_ATTRIB(obj);
  else  if (obj->fixedtype == DWG_TYPE_BASEPOINTPARAMETERENTITY)
    error += test_BASEPOINTPARAMETERENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK)
    error += test_BLOCK(obj);
  else  if (obj->fixedtype == DWG_TYPE_BODY)
    error += test_BODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_CAMERA)
    error += test_CAMERA(obj);
  else  if (obj->fixedtype == DWG_TYPE_CIRCLE)
    error += test_CIRCLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DGNUNDERLAY)
    error += test_DGNUNDERLAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED)
    error += test_DIMENSION_ALIGNED(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
    error += test_DIMENSION_ANG2LN(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG3PT)
    error += test_DIMENSION_ANG3PT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_DIAMETER)
    error += test_DIMENSION_DIAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_LINEAR)
    error += test_DIMENSION_LINEAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ORDINATE)
    error += test_DIMENSION_ORDINATE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_RADIUS)
    error += test_DIMENSION_RADIUS(obj);
  else  if (obj->fixedtype == DWG_TYPE_DWFUNDERLAY)
    error += test_DWFUNDERLAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ELLIPSE)
    error += test_ELLIPSE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDBLK)
    error += test_ENDBLK(obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDREP)
    error += test_ENDREP(obj);
  else  if (obj->fixedtype == DWG_TYPE_EXTRUDEDSURFACE)
    error += test_EXTRUDEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_FLIPGRIPENTITY)
    error += test_FLIPGRIPENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_FLIPPARAMETERENTITY)
    error += test_FLIPPARAMETERENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOPOSITIONMARKER)
    error += test_GEOPOSITIONMARKER(obj);
  else  if (obj->fixedtype == DWG_TYPE_HATCH)
    error += test_HATCH(obj);
  else  if (obj->fixedtype == DWG_TYPE_HELIX)
    error += test_HELIX(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE)
    error += test_IMAGE(obj);
  else  if (obj->fixedtype == DWG_TYPE_INSERT)
    error += test_INSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_JUMP)
    error += test_JUMP(obj);
  else  if (obj->fixedtype == DWG_TYPE_LARGE_RADIAL_DIMENSION)
    error += test_LARGE_RADIAL_DIMENSION(obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADER)
    error += test_LEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHT)
    error += test_LIGHT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LINE)
    error += test_LINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LINEARGRIPENTITY)
    error += test_LINEARGRIPENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_LINEARPARAMETERENTITY)
    error += test_LINEARPARAMETERENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_LOAD)
    error += test_LOAD(obj);
  else  if (obj->fixedtype == DWG_TYPE_LOFTEDSURFACE)
    error += test_LOFTEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LWPOLYLINE)
    error += test_LWPOLYLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MESH)
    error += test_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_MINSERT)
    error += test_MINSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINE)
    error += test_MLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MPOLYGON)
    error += test_MPOLYGON(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXT)
    error += test_MTEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MULTILEADER)
    error += test_MULTILEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_NAVISWORKSMODEL)
    error += test_NAVISWORKSMODEL(obj);
  else  if (obj->fixedtype == DWG_TYPE_NURBSURFACE)
    error += test_NURBSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLE2FRAME)
    error += test_OLE2FRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLEFRAME)
    error += test_OLEFRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_PDFUNDERLAY)
    error += test_PDFUNDERLAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLANESURFACE)
    error += test_PLANESURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINT)
    error += test_POINT(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUD)
    error += test_POINTCLOUD(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDEX)
    error += test_POINTCLOUDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTPARAMETERENTITY)
    error += test_POINTPARAMETERENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLARGRIPENTITY)
    error += test_POLARGRIPENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_2D)
    error += test_POLYLINE_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_3D)
    error += test_POLYLINE_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_MESH)
    error += test_POLYLINE_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_PFACE)
    error += test_POLYLINE_PFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_R11)
    error += test_POLYLINE_R11(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY)
    error += test_PROXY_ENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_RAY)
    error += test_RAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_REGION)
    error += test_REGION(obj);
  else  if (obj->fixedtype == DWG_TYPE_REPEAT)
    error += test_REPEAT(obj);
  else  if (obj->fixedtype == DWG_TYPE_REVOLVEDSURFACE)
    error += test_REVOLVEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ROTATIONGRIPENTITY)
    error += test_ROTATIONGRIPENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ROTATIONPARAMETERENTITY)
    error += test_ROTATIONPARAMETERENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_RTEXT)
    error += test_RTEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_SECTIONOBJECT)
    error += test_SECTIONOBJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_SEQEND)
    error += test_SEQEND(obj);
  else  if (obj->fixedtype == DWG_TYPE_SHAPE)
    error += test_SHAPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID)
    error += test_SOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPLINE)
    error += test_SPLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SWEPTSURFACE)
    error += test_SWEPTSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLE)
    error += test_TABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXT)
    error += test_TEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TOLERANCE)
    error += test_TOLERANCE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TRACE)
    error += test_TRACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_2D)
    error += test_VERTEX_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_3D)
    error += test_VERTEX_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_MESH)
    error += test_VERTEX_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE)
    error += test_VERTEX_PFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE_FACE)
    error += test_VERTEX_PFACE_FACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_R11)
    error += test_VERTEX_R11(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEWPORT)
    error += test_VIEWPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VISIBILITYGRIPENTITY)
    error += test_VISIBILITYGRIPENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_VISIBILITYPARAMETERENTITY)
    error += test_VISIBILITYPARAMETERENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUT)
    error += test_WIPEOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_XLINE)
    error += test_XLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_XYGRIPENTITY)
    error += test_XYGRIPENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_XYPARAMETERENTITY)
    error += test_XYPARAMETERENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACMECOMMANDHISTORY)
    error += test_ACMECOMMANDHISTORY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACMESCOPE)
    error += test_ACMESCOPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACMESTATEMGR)
    error += test_ACMESTATEMGR(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_BOOLEAN_CLASS)
    error += test_ACSH_BOOLEAN_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_BOX_CLASS)
    error += test_ACSH_BOX_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_BREP_CLASS)
    error += test_ACSH_BREP_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_CHAMFER_CLASS)
    error += test_ACSH_CHAMFER_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_CONE_CLASS)
    error += test_ACSH_CONE_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_CYLINDER_CLASS)
    error += test_ACSH_CYLINDER_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_EXTRUSION_CLASS)
    error += test_ACSH_EXTRUSION_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_FILLET_CLASS)
    error += test_ACSH_FILLET_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_HISTORY_CLASS)
    error += test_ACSH_HISTORY_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_LOFT_CLASS)
    error += test_ACSH_LOFT_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_PYRAMID_CLASS)
    error += test_ACSH_PYRAMID_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_REVOLVE_CLASS)
    error += test_ACSH_REVOLVE_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SPHERE_CLASS)
    error += test_ACSH_SPHERE_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SWEEP_CLASS)
    error += test_ACSH_SWEEP_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_TORUS_CLASS)
    error += test_ACSH_TORUS_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_WEDGE_CLASS)
    error += test_ACSH_WEDGE_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ALDIMOBJECTCONTEXTDATA)
    error += test_ALDIMOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_ANGDIMOBJECTCONTEXTDATA)
    error += test_ANGDIMOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_ANNOTSCALEOBJECTCONTEXTDATA)
    error += test_ANNOTSCALEOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID)
    error += test_APPID(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID_CONTROL)
    error += test_APPID_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC2DCONSTRAINTGROUP)
    error += test_ASSOC2DCONSTRAINTGROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC3POINTANGULARDIMACTIONBODY)
    error += test_ASSOC3POINTANGULARDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTION)
    error += test_ASSOCACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTIONPARAM)
    error += test_ASSOCACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY)
    error += test_ASSOCALIGNEDDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYACTIONBODY)
    error += test_ASSOCARRAYACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYMODIFYACTIONBODY)
    error += test_ASSOCARRAYMODIFYACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCASMBODYACTIONPARAM)
    error += test_ASSOCASMBODYACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCBLENDSURFACEACTIONBODY)
    error += test_ASSOCBLENDSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCCOMPOUNDACTIONPARAM)
    error += test_ASSOCCOMPOUNDACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDEPENDENCY)
    error += test_ASSOCDEPENDENCY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDIMDEPENDENCYBODY)
    error += test_ASSOCDIMDEPENDENCYBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEDGEACTIONPARAM)
    error += test_ASSOCEDGEACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEDGECHAMFERACTIONBODY)
    error += test_ASSOCEDGECHAMFERACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEDGEFILLETACTIONBODY)
    error += test_ASSOCEDGEFILLETACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEXTENDSURFACEACTIONBODY)
    error += test_ASSOCEXTENDSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEXTRUDEDSURFACEACTIONBODY)
    error += test_ASSOCEXTRUDEDSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCFACEACTIONPARAM)
    error += test_ASSOCFACEACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCFILLETSURFACEACTIONBODY)
    error += test_ASSOCFILLETSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCGEOMDEPENDENCY)
    error += test_ASSOCGEOMDEPENDENCY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCLOFTEDSURFACEACTIONBODY)
    error += test_ASSOCLOFTEDSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCMLEADERACTIONBODY)
    error += test_ASSOCMLEADERACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORK)
    error += test_ASSOCNETWORK(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORKSURFACEACTIONBODY)
    error += test_ASSOCNETWORKSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOBJECTACTIONPARAM)
    error += test_ASSOCOBJECTACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOFFSETSURFACEACTIONBODY)
    error += test_ASSOCOFFSETSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCORDINATEDIMACTIONBODY)
    error += test_ASSOCORDINATEDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM)
    error += test_ASSOCOSNAPPOINTREFACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPATCHSURFACEACTIONBODY)
    error += test_ASSOCPATCHSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPATHACTIONPARAM)
    error += test_ASSOCPATHACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPERSSUBENTMANAGER)
    error += test_ASSOCPERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPLANESURFACEACTIONBODY)
    error += test_ASSOCPLANESURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPOINTREFACTIONPARAM)
    error += test_ASSOCPOINTREFACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCRESTOREENTITYSTATEACTIONBODY)
    error += test_ASSOCRESTOREENTITYSTATEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCREVOLVEDSURFACEACTIONBODY)
    error += test_ASSOCREVOLVEDSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCROTATEDDIMACTIONBODY)
    error += test_ASSOCROTATEDDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCSWEPTSURFACEACTIONBODY)
    error += test_ASSOCSWEPTSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCTRIMSURFACEACTIONBODY)
    error += test_ASSOCTRIMSURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCVALUEDEPENDENCY)
    error += test_ASSOCVALUEDEPENDENCY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCVARIABLE)
    error += test_ASSOCVARIABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCVERTEXACTIONPARAM)
    error += test_ASSOCVERTEXACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLKREFOBJECTCONTEXTDATA)
    error += test_BLKREFOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKALIGNEDCONSTRAINTPARAMETER)
    error += test_BLOCKALIGNEDCONSTRAINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKALIGNMENTGRIP)
    error += test_BLOCKALIGNMENTGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKALIGNMENTPARAMETER)
    error += test_BLOCKALIGNMENTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKANGULARCONSTRAINTPARAMETER)
    error += test_BLOCKANGULARCONSTRAINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKARRAYACTION)
    error += test_BLOCKARRAYACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKBASEPOINTPARAMETER)
    error += test_BLOCKBASEPOINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKDIAMETRICCONSTRAINTPARAMETER)
    error += test_BLOCKDIAMETRICCONSTRAINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKFLIPACTION)
    error += test_BLOCKFLIPACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKFLIPGRIP)
    error += test_BLOCKFLIPGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKFLIPPARAMETER)
    error += test_BLOCKFLIPPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKGRIPLOCATIONCOMPONENT)
    error += test_BLOCKGRIPLOCATIONCOMPONENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKHORIZONTALCONSTRAINTPARAMETER)
    error += test_BLOCKHORIZONTALCONSTRAINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLINEARCONSTRAINTPARAMETER)
    error += test_BLOCKLINEARCONSTRAINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLINEARGRIP)
    error += test_BLOCKLINEARGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLINEARPARAMETER)
    error += test_BLOCKLINEARPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLOOKUPACTION)
    error += test_BLOCKLOOKUPACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLOOKUPGRIP)
    error += test_BLOCKLOOKUPGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLOOKUPPARAMETER)
    error += test_BLOCKLOOKUPPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKMOVEACTION)
    error += test_BLOCKMOVEACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPARAMDEPENDENCYBODY)
    error += test_BLOCKPARAMDEPENDENCYBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPOINTPARAMETER)
    error += test_BLOCKPOINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPOLARGRIP)
    error += test_BLOCKPOLARGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPOLARPARAMETER)
    error += test_BLOCKPOLARPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPOLARSTRETCHACTION)
    error += test_BLOCKPOLARSTRETCHACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPROPERTIESTABLE)
    error += test_BLOCKPROPERTIESTABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPROPERTIESTABLEGRIP)
    error += test_BLOCKPROPERTIESTABLEGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKRADIALCONSTRAINTPARAMETER)
    error += test_BLOCKRADIALCONSTRAINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKREPRESENTATION)
    error += test_BLOCKREPRESENTATION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKROTATEACTION)
    error += test_BLOCKROTATEACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKROTATIONGRIP)
    error += test_BLOCKROTATIONGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKROTATIONPARAMETER)
    error += test_BLOCKROTATIONPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKSCALEACTION)
    error += test_BLOCKSCALEACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKSTRETCHACTION)
    error += test_BLOCKSTRETCHACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKUSERPARAMETER)
    error += test_BLOCKUSERPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKVERTICALCONSTRAINTPARAMETER)
    error += test_BLOCKVERTICALCONSTRAINTPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKVISIBILITYGRIP)
    error += test_BLOCKVISIBILITYGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKVISIBILITYPARAMETER)
    error += test_BLOCKVISIBILITYPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKXYGRIP)
    error += test_BLOCKXYGRIP(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKXYPARAMETER)
    error += test_BLOCKXYPARAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_CONTROL)
    error += test_BLOCK_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
    error += test_BLOCK_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_BREAKDATA)
    error += test_BREAKDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_BREAKPOINTREF)
    error += test_BREAKPOINTREF(obj);
  else  if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
    error += test_CELLSTYLEMAP(obj);
  else  if (obj->fixedtype == DWG_TYPE_CONTEXTDATAMANAGER)
    error += test_CONTEXTDATAMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_CSACDOCUMENTOPTIONS)
    error += test_CSACDOCUMENTOPTIONS(obj);
  else  if (obj->fixedtype == DWG_TYPE_CURVEPATH)
    error += test_CURVEPATH(obj);
  else  if (obj->fixedtype == DWG_TYPE_DATALINK)
    error += test_DATALINK(obj);
  else  if (obj->fixedtype == DWG_TYPE_DATATABLE)
    error += test_DATATABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DBCOLOR)
    error += test_DBCOLOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DETAILVIEWSTYLE)
    error += test_DETAILVIEWSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARY)
    error += test_DICTIONARY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYVAR)
    error += test_DICTIONARYVAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
    error += test_DICTIONARYWDFLT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMASSOC)
    error += test_DIMASSOC(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
    error += test_DIMSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE_CONTROL)
    error += test_DIMSTYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_DMDIMOBJECTCONTEXTDATA)
    error += test_DMDIMOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_DUMMY)
    error += test_DUMMY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPROXYNODE)
    error += test_DYNAMICBLOCKPROXYNODE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER)
    error += test_DYNAMICBLOCKPURGEPREVENTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
    error += test_EVALUATION_GRAPH(obj);
  else  if (obj->fixedtype == DWG_TYPE_FCFOBJECTCONTEXTDATA)
    error += test_FCFOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELD)
    error += test_FIELD(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELDLIST)
    error += test_FIELDLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEODATA)
    error += test_GEODATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOMAPIMAGE)
    error += test_GEOMAPIMAGE(obj);
  else  if (obj->fixedtype == DWG_TYPE_GRADIENT_BACKGROUND)
    error += test_GRADIENT_BACKGROUND(obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUND_PLANE_BACKGROUND)
    error += test_GROUND_PLANE_BACKGROUND(obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUP)
    error += test_GROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_IBL_BACKGROUND)
    error += test_IBL_BACKGROUND(obj);
  else  if (obj->fixedtype == DWG_TYPE_IDBUFFER)
    error += test_IDBUFFER(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF)
    error += test_IMAGEDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF_REACTOR)
    error += test_IMAGEDEF_REACTOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE_BACKGROUND)
    error += test_IMAGE_BACKGROUND(obj);
  else  if (obj->fixedtype == DWG_TYPE_INDEX)
    error += test_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER)
    error += test_LAYER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYERFILTER)
    error += test_LAYERFILTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_CONTROL)
    error += test_LAYER_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_INDEX)
    error += test_LAYER_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUT)
    error += test_LAYOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUTPRINTCONFIG)
    error += test_LAYOUTPRINTCONFIG(obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADEROBJECTCONTEXTDATA)
    error += test_LEADEROBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHTLIST)
    error += test_LIGHTLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_LONG_TRANSACTION)
    error += test_LONG_TRANSACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE)
    error += test_LTYPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE_CONTROL)
    error += test_LTYPE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MATERIAL)
    error += test_MATERIAL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MENTALRAYRENDERSETTINGS)
    error += test_MENTALRAYRENDERSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADEROBJECTCONTEXTDATA)
    error += test_MLEADEROBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
    error += test_MLEADERSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINESTYLE)
    error += test_MLINESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MOTIONPATH)
    error += test_MOTIONPATH(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXTATTRIBUTEOBJECTCONTEXTDATA)
    error += test_MTEXTATTRIBUTEOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXTOBJECTCONTEXTDATA)
    error += test_MTEXTOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_NAVISWORKSMODELDEF)
    error += test_NAVISWORKSMODELDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECT_PTR)
    error += test_OBJECT_PTR(obj);
  else  if (obj->fixedtype == DWG_TYPE_ORDDIMOBJECTCONTEXTDATA)
    error += test_ORDDIMOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_PARTIAL_VIEWING_INDEX)
    error += test_PARTIAL_VIEWING_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_PERSUBENTMGR)
    error += test_PERSUBENTMGR(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLACEHOLDER)
    error += test_PLACEHOLDER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
    error += test_PLOTSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDCOLORMAP)
    error += test_POINTCLOUDCOLORMAP(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDDEF)
    error += test_POINTCLOUDDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDDEFEX)
    error += test_POINTCLOUDDEFEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDDEF_REACTOR)
    error += test_POINTCLOUDDEF_REACTOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDDEF_REACTOR_EX)
    error += test_POINTCLOUDDEF_REACTOR_EX(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTPATH)
    error += test_POINTPATH(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_OBJECT)
    error += test_PROXY_OBJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_RADIMLGOBJECTCONTEXTDATA)
    error += test_RADIMLGOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_RADIMOBJECTCONTEXTDATA)
    error += test_RADIMOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_RAPIDRTRENDERSETTINGS)
    error += test_RAPIDRTRENDERSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_RASTERVARIABLES)
    error += test_RASTERVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERENTRY)
    error += test_RENDERENTRY(obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERENVIRONMENT)
    error += test_RENDERENVIRONMENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERGLOBAL)
    error += test_RENDERGLOBAL(obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERSETTINGS)
    error += test_RENDERSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_SCALE)
    error += test_SCALE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SECTIONVIEWSTYLE)
    error += test_SECTIONVIEWSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SECTION_MANAGER)
    error += test_SECTION_MANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_SECTION_SETTINGS)
    error += test_SECTION_SETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_SKYLIGHT_BACKGROUND)
    error += test_SKYLIGHT_BACKGROUND(obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID_BACKGROUND)
    error += test_SOLID_BACKGROUND(obj);
  else  if (obj->fixedtype == DWG_TYPE_SORTENTSTABLE)
    error += test_SORTENTSTABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_FILTER)
    error += test_SPATIAL_FILTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_INDEX)
    error += test_SPATIAL_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE)
    error += test_STYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE_CONTROL)
    error += test_STYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUN)
    error += test_SUN(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUNSTUDY)
    error += test_SUNSTUDY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLECONTENT)
    error += test_TABLECONTENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
    error += test_TABLEGEOMETRY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
    error += test_TABLESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXTOBJECTCONTEXTDATA)
    error += test_TEXTOBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_TVDEVICEPROPERTIES)
    error += test_TVDEVICEPROPERTIES(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS)
    error += test_UCS(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS_CONTROL)
    error += test_UCS_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VBA_PROJECT)
    error += test_VBA_PROJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW)
    error += test_VIEW(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW_CONTROL)
    error += test_VIEW_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VISUALSTYLE)
    error += test_VISUALSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT)
    error += test_VPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_CONTROL)
    error += test_VPORT_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VX_CONTROL)
    error += test_VX_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VX_TABLE_RECORD)
    error += test_VX_TABLE_RECORD(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUTVARIABLES)
    error += test_WIPEOUTVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_XRECORD)
    error += test_XRECORD(obj);
  else  if (obj->fixedtype == DWG_TYPE_PDFDEFINITION)
    error += test_PDFDEFINITION(obj);
  else  if (obj->fixedtype == DWG_TYPE_DGNDEFINITION)
    error += test_DGNDEFINITION(obj);
  else  if (obj->fixedtype == DWG_TYPE_DWFDEFINITION)
    error += test_DWFDEFINITION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYMODIFYPARAMETERS)
    error += test_ASSOCARRAYMODIFYPARAMETERS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYPATHPARAMETERS)
    error += test_ASSOCARRAYPATHPARAMETERS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYPOLARPARAMETERS)
    error += test_ASSOCARRAYPOLARPARAMETERS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYRECTANGULARPARAMETERS)
    error += test_ASSOCARRAYRECTANGULARPARAMETERS(obj);
  if (obj->fixedtype == DWG_TYPE__3DFACE)
    error += test__3DFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE__3DLINE)
    error += test__3DLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE__3DSOLID)
    error += test__3DSOLID (obj);
  else  if (obj->fixedtype == DWG_TYPE_ALIGNMENTPARAMETERENTITY)
    error += test_ALIGNMENTPARAMETERENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC (obj);
  else  if (obj->fixedtype == DWG_TYPE_ARCALIGNEDTEXT)
    error += test_ARCALIGNEDTEXT (obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC_DIMENSION)
    error += test_ARC_DIMENSION (obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTDEF)
    error += test_ATTDEF (obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTRIB)
    error += test_ATTRIB (obj);
  else  if (obj->fixedtype == DWG_TYPE_BASEPOINTPARAMETERENTITY)
    error += test_BASEPOINTPARAMETERENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK)
    error += test_BLOCK (obj);
  else  if (obj->fixedtype == DWG_TYPE_BODY)
    error += test_BODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_CAMERA)
    error += test_CAMERA (obj);
  else  if (obj->fixedtype == DWG_TYPE_CIRCLE)
    error += test_CIRCLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DGNUNDERLAY)
    error += test_DGNUNDERLAY (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED)
    error += test_DIMENSION_ALIGNED (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
    error += test_DIMENSION_ANG2LN (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG3PT)
    error += test_DIMENSION_ANG3PT (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_DIAMETER)
    error += test_DIMENSION_DIAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_LINEAR)
    error += test_DIMENSION_LINEAR (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ORDINATE)
    error += test_DIMENSION_ORDINATE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_RADIUS)
    error += test_DIMENSION_RADIUS (obj);
  else  if (obj->fixedtype == DWG_TYPE_DWFUNDERLAY)
    error += test_DWFUNDERLAY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ELLIPSE)
    error += test_ELLIPSE (obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDBLK)
    error += test_ENDBLK (obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDREP)
    error += test_ENDREP (obj);
  else  if (obj->fixedtype == DWG_TYPE_EXTRUDEDSURFACE)
    error += test_EXTRUDEDSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_FLIPGRIPENTITY)
    error += test_FLIPGRIPENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_FLIPPARAMETERENTITY)
    error += test_FLIPPARAMETERENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOPOSITIONMARKER)
    error += test_GEOPOSITIONMARKER (obj);
  else  if (obj->fixedtype == DWG_TYPE_HATCH)
    error += test_HATCH (obj);
  else  if (obj->fixedtype == DWG_TYPE_HELIX)
    error += test_HELIX (obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE)
    error += test_IMAGE (obj);
  else  if (obj->fixedtype == DWG_TYPE_INSERT)
    error += test_INSERT (obj);
  else  if (obj->fixedtype == DWG_TYPE_JUMP)
    error += test_JUMP (obj);
  else  if (obj->fixedtype == DWG_TYPE_LARGE_RADIAL_DIMENSION)
    error += test_LARGE_RADIAL_DIMENSION (obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADER)
    error += test_LEADER (obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHT)
    error += test_LIGHT (obj);
  else  if (obj->fixedtype == DWG_TYPE_LINE)
    error += test_LINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_LINEARGRIPENTITY)
    error += test_LINEARGRIPENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_LINEARPARAMETERENTITY)
    error += test_LINEARPARAMETERENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_LOAD)
    error += test_LOAD (obj);
  else  if (obj->fixedtype == DWG_TYPE_LOFTEDSURFACE)
    error += test_LOFTEDSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_LWPOLYLINE)
    error += test_LWPOLYLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_MESH)
    error += test_MESH (obj);
  else  if (obj->fixedtype == DWG_TYPE_MINSERT)
    error += test_MINSERT (obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINE)
    error += test_MLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_MPOLYGON)
    error += test_MPOLYGON (obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXT)
    error += test_MTEXT (obj);
  else  if (obj->fixedtype == DWG_TYPE_MULTILEADER)
    error += test_MULTILEADER (obj);
  else  if (obj->fixedtype == DWG_TYPE_NAVISWORKSMODEL)
    error += test_NAVISWORKSMODEL (obj);
  else  if (obj->fixedtype == DWG_TYPE_NURBSURFACE)
    error += test_NURBSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_OLE2FRAME)
    error += test_OLE2FRAME (obj);
  else  if (obj->fixedtype == DWG_TYPE_OLEFRAME)
    error += test_OLEFRAME (obj);
  else  if (obj->fixedtype == DWG_TYPE_PDFUNDERLAY)
    error += test_PDFUNDERLAY (obj);
  else  if (obj->fixedtype == DWG_TYPE_PLANESURFACE)
    error += test_PLANESURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINT)
    error += test_POINT (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUD)
    error += test_POINTCLOUD (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDEX)
    error += test_POINTCLOUDEX (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTPARAMETERENTITY)
    error += test_POINTPARAMETERENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLARGRIPENTITY)
    error += test_POLARGRIPENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_2D)
    error += test_POLYLINE_2D (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_3D)
    error += test_POLYLINE_3D (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_MESH)
    error += test_POLYLINE_MESH (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_PFACE)
    error += test_POLYLINE_PFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_R11)
    error += test_POLYLINE_R11 (obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY)
    error += test_PROXY_ENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_RAY)
    error += test_RAY (obj);
  else  if (obj->fixedtype == DWG_TYPE_REGION)
    error += test_REGION (obj);
  else  if (obj->fixedtype == DWG_TYPE_REPEAT)
    error += test_REPEAT (obj);
  else  if (obj->fixedtype == DWG_TYPE_REVOLVEDSURFACE)
    error += test_REVOLVEDSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_ROTATIONGRIPENTITY)
    error += test_ROTATIONGRIPENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ROTATIONPARAMETERENTITY)
    error += test_ROTATIONPARAMETERENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_RTEXT)
    error += test_RTEXT (obj);
  else  if (obj->fixedtype == DWG_TYPE_SECTIONOBJECT)
    error += test_SECTIONOBJECT (obj);
  else  if (obj->fixedtype == DWG_TYPE_SEQEND)
    error += test_SEQEND (obj);
  else  if (obj->fixedtype == DWG_TYPE_SHAPE)
    error += test_SHAPE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID)
    error += test_SOLID (obj);
  else  if (obj->fixedtype == DWG_TYPE_SPLINE)
    error += test_SPLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SWEPTSURFACE)
    error += test_SWEPTSURFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLE)
    error += test_TABLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXT)
    error += test_TEXT (obj);
  else  if (obj->fixedtype == DWG_TYPE_TOLERANCE)
    error += test_TOLERANCE (obj);
  else  if (obj->fixedtype == DWG_TYPE_TRACE)
    error += test_TRACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_2D)
    error += test_VERTEX_2D (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_3D)
    error += test_VERTEX_3D (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_MESH)
    error += test_VERTEX_MESH (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE)
    error += test_VERTEX_PFACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE_FACE)
    error += test_VERTEX_PFACE_FACE (obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_R11)
    error += test_VERTEX_R11 (obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEWPORT)
    error += test_VIEWPORT (obj);
  else  if (obj->fixedtype == DWG_TYPE_VISIBILITYGRIPENTITY)
    error += test_VISIBILITYGRIPENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_VISIBILITYPARAMETERENTITY)
    error += test_VISIBILITYPARAMETERENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUT)
    error += test_WIPEOUT (obj);
  else  if (obj->fixedtype == DWG_TYPE_XLINE)
    error += test_XLINE (obj);
  else  if (obj->fixedtype == DWG_TYPE_XYGRIPENTITY)
    error += test_XYGRIPENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_XYPARAMETERENTITY)
    error += test_XYPARAMETERENTITY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACMECOMMANDHISTORY)
    error += test_ACMECOMMANDHISTORY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACMESCOPE)
    error += test_ACMESCOPE (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACMESTATEMGR)
    error += test_ACMESTATEMGR (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_BOOLEAN_CLASS)
    error += test_ACSH_BOOLEAN_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_BOX_CLASS)
    error += test_ACSH_BOX_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_BREP_CLASS)
    error += test_ACSH_BREP_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_CHAMFER_CLASS)
    error += test_ACSH_CHAMFER_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_CONE_CLASS)
    error += test_ACSH_CONE_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_CYLINDER_CLASS)
    error += test_ACSH_CYLINDER_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_EXTRUSION_CLASS)
    error += test_ACSH_EXTRUSION_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_FILLET_CLASS)
    error += test_ACSH_FILLET_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_HISTORY_CLASS)
    error += test_ACSH_HISTORY_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_LOFT_CLASS)
    error += test_ACSH_LOFT_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_PYRAMID_CLASS)
    error += test_ACSH_PYRAMID_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_REVOLVE_CLASS)
    error += test_ACSH_REVOLVE_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SPHERE_CLASS)
    error += test_ACSH_SPHERE_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SWEEP_CLASS)
    error += test_ACSH_SWEEP_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_TORUS_CLASS)
    error += test_ACSH_TORUS_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_WEDGE_CLASS)
    error += test_ACSH_WEDGE_CLASS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ALDIMOBJECTCONTEXTDATA)
    error += test_ALDIMOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_ANGDIMOBJECTCONTEXTDATA)
    error += test_ANGDIMOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_ANNOTSCALEOBJECTCONTEXTDATA)
    error += test_ANNOTSCALEOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID)
    error += test_APPID (obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID_CONTROL)
    error += test_APPID_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC2DCONSTRAINTGROUP)
    error += test_ASSOC2DCONSTRAINTGROUP (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC3POINTANGULARDIMACTIONBODY)
    error += test_ASSOC3POINTANGULARDIMACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTION)
    error += test_ASSOCACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTIONPARAM)
    error += test_ASSOCACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY)
    error += test_ASSOCALIGNEDDIMACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYACTIONBODY)
    error += test_ASSOCARRAYACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYMODIFYACTIONBODY)
    error += test_ASSOCARRAYMODIFYACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCASMBODYACTIONPARAM)
    error += test_ASSOCASMBODYACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCBLENDSURFACEACTIONBODY)
    error += test_ASSOCBLENDSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCCOMPOUNDACTIONPARAM)
    error += test_ASSOCCOMPOUNDACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDEPENDENCY)
    error += test_ASSOCDEPENDENCY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDIMDEPENDENCYBODY)
    error += test_ASSOCDIMDEPENDENCYBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEDGEACTIONPARAM)
    error += test_ASSOCEDGEACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEDGECHAMFERACTIONBODY)
    error += test_ASSOCEDGECHAMFERACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEDGEFILLETACTIONBODY)
    error += test_ASSOCEDGEFILLETACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEXTENDSURFACEACTIONBODY)
    error += test_ASSOCEXTENDSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCEXTRUDEDSURFACEACTIONBODY)
    error += test_ASSOCEXTRUDEDSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCFACEACTIONPARAM)
    error += test_ASSOCFACEACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCFILLETSURFACEACTIONBODY)
    error += test_ASSOCFILLETSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCGEOMDEPENDENCY)
    error += test_ASSOCGEOMDEPENDENCY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCLOFTEDSURFACEACTIONBODY)
    error += test_ASSOCLOFTEDSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCMLEADERACTIONBODY)
    error += test_ASSOCMLEADERACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORK)
    error += test_ASSOCNETWORK (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORKSURFACEACTIONBODY)
    error += test_ASSOCNETWORKSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOBJECTACTIONPARAM)
    error += test_ASSOCOBJECTACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOFFSETSURFACEACTIONBODY)
    error += test_ASSOCOFFSETSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCORDINATEDIMACTIONBODY)
    error += test_ASSOCORDINATEDIMACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM)
    error += test_ASSOCOSNAPPOINTREFACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPATCHSURFACEACTIONBODY)
    error += test_ASSOCPATCHSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPATHACTIONPARAM)
    error += test_ASSOCPATHACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPERSSUBENTMANAGER)
    error += test_ASSOCPERSSUBENTMANAGER (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPLANESURFACEACTIONBODY)
    error += test_ASSOCPLANESURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPOINTREFACTIONPARAM)
    error += test_ASSOCPOINTREFACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCRESTOREENTITYSTATEACTIONBODY)
    error += test_ASSOCRESTOREENTITYSTATEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCREVOLVEDSURFACEACTIONBODY)
    error += test_ASSOCREVOLVEDSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCROTATEDDIMACTIONBODY)
    error += test_ASSOCROTATEDDIMACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCSWEPTSURFACEACTIONBODY)
    error += test_ASSOCSWEPTSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCTRIMSURFACEACTIONBODY)
    error += test_ASSOCTRIMSURFACEACTIONBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCVALUEDEPENDENCY)
    error += test_ASSOCVALUEDEPENDENCY (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCVARIABLE)
    error += test_ASSOCVARIABLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCVERTEXACTIONPARAM)
    error += test_ASSOCVERTEXACTIONPARAM (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLKREFOBJECTCONTEXTDATA)
    error += test_BLKREFOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKALIGNEDCONSTRAINTPARAMETER)
    error += test_BLOCKALIGNEDCONSTRAINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKALIGNMENTGRIP)
    error += test_BLOCKALIGNMENTGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKALIGNMENTPARAMETER)
    error += test_BLOCKALIGNMENTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKANGULARCONSTRAINTPARAMETER)
    error += test_BLOCKANGULARCONSTRAINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKARRAYACTION)
    error += test_BLOCKARRAYACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKBASEPOINTPARAMETER)
    error += test_BLOCKBASEPOINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKDIAMETRICCONSTRAINTPARAMETER)
    error += test_BLOCKDIAMETRICCONSTRAINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKFLIPACTION)
    error += test_BLOCKFLIPACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKFLIPGRIP)
    error += test_BLOCKFLIPGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKFLIPPARAMETER)
    error += test_BLOCKFLIPPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKGRIPLOCATIONCOMPONENT)
    error += test_BLOCKGRIPLOCATIONCOMPONENT (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKHORIZONTALCONSTRAINTPARAMETER)
    error += test_BLOCKHORIZONTALCONSTRAINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLINEARCONSTRAINTPARAMETER)
    error += test_BLOCKLINEARCONSTRAINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLINEARGRIP)
    error += test_BLOCKLINEARGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLINEARPARAMETER)
    error += test_BLOCKLINEARPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLOOKUPACTION)
    error += test_BLOCKLOOKUPACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLOOKUPGRIP)
    error += test_BLOCKLOOKUPGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKLOOKUPPARAMETER)
    error += test_BLOCKLOOKUPPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKMOVEACTION)
    error += test_BLOCKMOVEACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPARAMDEPENDENCYBODY)
    error += test_BLOCKPARAMDEPENDENCYBODY (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPOINTPARAMETER)
    error += test_BLOCKPOINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPOLARGRIP)
    error += test_BLOCKPOLARGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPOLARPARAMETER)
    error += test_BLOCKPOLARPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPOLARSTRETCHACTION)
    error += test_BLOCKPOLARSTRETCHACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPROPERTIESTABLE)
    error += test_BLOCKPROPERTIESTABLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKPROPERTIESTABLEGRIP)
    error += test_BLOCKPROPERTIESTABLEGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKRADIALCONSTRAINTPARAMETER)
    error += test_BLOCKRADIALCONSTRAINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKREPRESENTATION)
    error += test_BLOCKREPRESENTATION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKROTATEACTION)
    error += test_BLOCKROTATEACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKROTATIONGRIP)
    error += test_BLOCKROTATIONGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKROTATIONPARAMETER)
    error += test_BLOCKROTATIONPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKSCALEACTION)
    error += test_BLOCKSCALEACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKSTRETCHACTION)
    error += test_BLOCKSTRETCHACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKUSERPARAMETER)
    error += test_BLOCKUSERPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKVERTICALCONSTRAINTPARAMETER)
    error += test_BLOCKVERTICALCONSTRAINTPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKVISIBILITYGRIP)
    error += test_BLOCKVISIBILITYGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKVISIBILITYPARAMETER)
    error += test_BLOCKVISIBILITYPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKXYGRIP)
    error += test_BLOCKXYGRIP (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCKXYPARAMETER)
    error += test_BLOCKXYPARAMETER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_CONTROL)
    error += test_BLOCK_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
    error += test_BLOCK_HEADER (obj);
  else  if (obj->fixedtype == DWG_TYPE_BREAKDATA)
    error += test_BREAKDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_BREAKPOINTREF)
    error += test_BREAKPOINTREF (obj);
  else  if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
    error += test_CELLSTYLEMAP (obj);
  else  if (obj->fixedtype == DWG_TYPE_CONTEXTDATAMANAGER)
    error += test_CONTEXTDATAMANAGER (obj);
  else  if (obj->fixedtype == DWG_TYPE_CSACDOCUMENTOPTIONS)
    error += test_CSACDOCUMENTOPTIONS (obj);
  else  if (obj->fixedtype == DWG_TYPE_CURVEPATH)
    error += test_CURVEPATH (obj);
  else  if (obj->fixedtype == DWG_TYPE_DATALINK)
    error += test_DATALINK (obj);
  else  if (obj->fixedtype == DWG_TYPE_DATATABLE)
    error += test_DATATABLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DBCOLOR)
    error += test_DBCOLOR (obj);
  else  if (obj->fixedtype == DWG_TYPE_DETAILVIEWSTYLE)
    error += test_DETAILVIEWSTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARY)
    error += test_DICTIONARY (obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYVAR)
    error += test_DICTIONARYVAR (obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
    error += test_DICTIONARYWDFLT (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMASSOC)
    error += test_DIMASSOC (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
    error += test_DIMSTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE_CONTROL)
    error += test_DIMSTYLE_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_DMDIMOBJECTCONTEXTDATA)
    error += test_DMDIMOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_DUMMY)
    error += test_DUMMY (obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPROXYNODE)
    error += test_DYNAMICBLOCKPROXYNODE (obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER)
    error += test_DYNAMICBLOCKPURGEPREVENTER (obj);
  else  if (obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
    error += test_EVALUATION_GRAPH (obj);
  else  if (obj->fixedtype == DWG_TYPE_FCFOBJECTCONTEXTDATA)
    error += test_FCFOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELD)
    error += test_FIELD (obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELDLIST)
    error += test_FIELDLIST (obj);
  else  if (obj->fixedtype == DWG_TYPE_GEODATA)
    error += test_GEODATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOMAPIMAGE)
    error += test_GEOMAPIMAGE (obj);
  else  if (obj->fixedtype == DWG_TYPE_GRADIENT_BACKGROUND)
    error += test_GRADIENT_BACKGROUND (obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUND_PLANE_BACKGROUND)
    error += test_GROUND_PLANE_BACKGROUND (obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUP)
    error += test_GROUP (obj);
  else  if (obj->fixedtype == DWG_TYPE_IBL_BACKGROUND)
    error += test_IBL_BACKGROUND (obj);
  else  if (obj->fixedtype == DWG_TYPE_IDBUFFER)
    error += test_IDBUFFER (obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF)
    error += test_IMAGEDEF (obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF_REACTOR)
    error += test_IMAGEDEF_REACTOR (obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE_BACKGROUND)
    error += test_IMAGE_BACKGROUND (obj);
  else  if (obj->fixedtype == DWG_TYPE_INDEX)
    error += test_INDEX (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER)
    error += test_LAYER (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYERFILTER)
    error += test_LAYERFILTER (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_CONTROL)
    error += test_LAYER_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_INDEX)
    error += test_LAYER_INDEX (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUT)
    error += test_LAYOUT (obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUTPRINTCONFIG)
    error += test_LAYOUTPRINTCONFIG (obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADEROBJECTCONTEXTDATA)
    error += test_LEADEROBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHTLIST)
    error += test_LIGHTLIST (obj);
  else  if (obj->fixedtype == DWG_TYPE_LONG_TRANSACTION)
    error += test_LONG_TRANSACTION (obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE)
    error += test_LTYPE (obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE_CONTROL)
    error += test_LTYPE_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_MATERIAL)
    error += test_MATERIAL (obj);
  else  if (obj->fixedtype == DWG_TYPE_MENTALRAYRENDERSETTINGS)
    error += test_MENTALRAYRENDERSETTINGS (obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADEROBJECTCONTEXTDATA)
    error += test_MLEADEROBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
    error += test_MLEADERSTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINESTYLE)
    error += test_MLINESTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_MOTIONPATH)
    error += test_MOTIONPATH (obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXTATTRIBUTEOBJECTCONTEXTDATA)
    error += test_MTEXTATTRIBUTEOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXTOBJECTCONTEXTDATA)
    error += test_MTEXTOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_NAVISWORKSMODELDEF)
    error += test_NAVISWORKSMODELDEF (obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECT_PTR)
    error += test_OBJECT_PTR (obj);
  else  if (obj->fixedtype == DWG_TYPE_ORDDIMOBJECTCONTEXTDATA)
    error += test_ORDDIMOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_PARTIAL_VIEWING_INDEX)
    error += test_PARTIAL_VIEWING_INDEX (obj);
  else  if (obj->fixedtype == DWG_TYPE_PERSUBENTMGR)
    error += test_PERSUBENTMGR (obj);
  else  if (obj->fixedtype == DWG_TYPE_PLACEHOLDER)
    error += test_PLACEHOLDER (obj);
  else  if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
    error += test_PLOTSETTINGS (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDCOLORMAP)
    error += test_POINTCLOUDCOLORMAP (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDDEF)
    error += test_POINTCLOUDDEF (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDDEFEX)
    error += test_POINTCLOUDDEFEX (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDDEF_REACTOR)
    error += test_POINTCLOUDDEF_REACTOR (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTCLOUDDEF_REACTOR_EX)
    error += test_POINTCLOUDDEF_REACTOR_EX (obj);
  else  if (obj->fixedtype == DWG_TYPE_POINTPATH)
    error += test_POINTPATH (obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_OBJECT)
    error += test_PROXY_OBJECT (obj);
  else  if (obj->fixedtype == DWG_TYPE_RADIMLGOBJECTCONTEXTDATA)
    error += test_RADIMLGOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_RADIMOBJECTCONTEXTDATA)
    error += test_RADIMOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_RAPIDRTRENDERSETTINGS)
    error += test_RAPIDRTRENDERSETTINGS (obj);
  else  if (obj->fixedtype == DWG_TYPE_RASTERVARIABLES)
    error += test_RASTERVARIABLES (obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERENTRY)
    error += test_RENDERENTRY (obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERENVIRONMENT)
    error += test_RENDERENVIRONMENT (obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERGLOBAL)
    error += test_RENDERGLOBAL (obj);
  else  if (obj->fixedtype == DWG_TYPE_RENDERSETTINGS)
    error += test_RENDERSETTINGS (obj);
  else  if (obj->fixedtype == DWG_TYPE_SCALE)
    error += test_SCALE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SECTIONVIEWSTYLE)
    error += test_SECTIONVIEWSTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SECTION_MANAGER)
    error += test_SECTION_MANAGER (obj);
  else  if (obj->fixedtype == DWG_TYPE_SECTION_SETTINGS)
    error += test_SECTION_SETTINGS (obj);
  else  if (obj->fixedtype == DWG_TYPE_SKYLIGHT_BACKGROUND)
    error += test_SKYLIGHT_BACKGROUND (obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID_BACKGROUND)
    error += test_SOLID_BACKGROUND (obj);
  else  if (obj->fixedtype == DWG_TYPE_SORTENTSTABLE)
    error += test_SORTENTSTABLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_FILTER)
    error += test_SPATIAL_FILTER (obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_INDEX)
    error += test_SPATIAL_INDEX (obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE)
    error += test_STYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE_CONTROL)
    error += test_STYLE_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_SUN)
    error += test_SUN (obj);
  else  if (obj->fixedtype == DWG_TYPE_SUNSTUDY)
    error += test_SUNSTUDY (obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLECONTENT)
    error += test_TABLECONTENT (obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
    error += test_TABLEGEOMETRY (obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
    error += test_TABLESTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXTOBJECTCONTEXTDATA)
    error += test_TEXTOBJECTCONTEXTDATA (obj);
  else  if (obj->fixedtype == DWG_TYPE_TVDEVICEPROPERTIES)
    error += test_TVDEVICEPROPERTIES (obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS)
    error += test_UCS (obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS_CONTROL)
    error += test_UCS_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_VBA_PROJECT)
    error += test_VBA_PROJECT (obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW)
    error += test_VIEW (obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW_CONTROL)
    error += test_VIEW_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_VISUALSTYLE)
    error += test_VISUALSTYLE (obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT)
    error += test_VPORT (obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_CONTROL)
    error += test_VPORT_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_VX_CONTROL)
    error += test_VX_CONTROL (obj);
  else  if (obj->fixedtype == DWG_TYPE_VX_TABLE_RECORD)
    error += test_VX_TABLE_RECORD (obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUTVARIABLES)
    error += test_WIPEOUTVARIABLES (obj);
  else  if (obj->fixedtype == DWG_TYPE_XRECORD)
    error += test_XRECORD (obj);
  else  if (obj->fixedtype == DWG_TYPE_PDFDEFINITION)
    error += test_PDFDEFINITION (obj);
  else  if (obj->fixedtype == DWG_TYPE_DGNDEFINITION)
    error += test_DGNDEFINITION (obj);
  else  if (obj->fixedtype == DWG_TYPE_DWFDEFINITION)
    error += test_DWFDEFINITION (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYMODIFYPARAMETERS)
    error += test_ASSOCARRAYMODIFYPARAMETERS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYPATHPARAMETERS)
    error += test_ASSOCARRAYPATHPARAMETERS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYPOLARPARAMETERS)
    error += test_ASSOCARRAYPOLARPARAMETERS (obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCARRAYRECTANGULARPARAMETERS)
    error += test_ASSOCARRAYRECTANGULARPARAMETERS (obj);
#line 60 "dynapi_test.c.in"
  return error + failed;
}

/* for all fields, checks its sizeof vs _fields_size_sum */
static int
test_sizes (void)
{
  int error = 0;
  int size1, size2;
#line 63386 "dynapi_test.c"
  /* @@for test_SIZES@@ */
  size1 = sizeof (Dwg_Entity__3DFACE);
  size2 = dwg_dynapi_fields_size ("3DFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity__3DFACE): %d != "
               "dwg_dynapi_fields_size (\"3DFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity__3DLINE);
  size2 = dwg_dynapi_fields_size ("3DLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity__3DLINE): %d != "
               "dwg_dynapi_fields_size (\"3DLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity__3DSOLID);
  size2 = dwg_dynapi_fields_size ("3DSOLID");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity__3DSOLID): %d != "
               "dwg_dynapi_fields_size (\"3DSOLID\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ALIGNMENTPARAMETERENTITY);
  size2 = dwg_dynapi_fields_size ("ALIGNMENTPARAMETERENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ALIGNMENTPARAMETERENTITY): %d != "
               "dwg_dynapi_fields_size (\"ALIGNMENTPARAMETERENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ARC);
  size2 = dwg_dynapi_fields_size ("ARC");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ARC): %d != "
               "dwg_dynapi_fields_size (\"ARC\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ARCALIGNEDTEXT);
  size2 = dwg_dynapi_fields_size ("ARCALIGNEDTEXT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ARCALIGNEDTEXT): %d != "
               "dwg_dynapi_fields_size (\"ARCALIGNEDTEXT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ARC_DIMENSION);
  size2 = dwg_dynapi_fields_size ("ARC_DIMENSION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ARC_DIMENSION): %d != "
               "dwg_dynapi_fields_size (\"ARC_DIMENSION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ATTDEF);
  size2 = dwg_dynapi_fields_size ("ATTDEF");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ATTDEF): %d != "
               "dwg_dynapi_fields_size (\"ATTDEF\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ATTRIB);
  size2 = dwg_dynapi_fields_size ("ATTRIB");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ATTRIB): %d != "
               "dwg_dynapi_fields_size (\"ATTRIB\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_BASEPOINTPARAMETERENTITY);
  size2 = dwg_dynapi_fields_size ("BASEPOINTPARAMETERENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_BASEPOINTPARAMETERENTITY): %d != "
               "dwg_dynapi_fields_size (\"BASEPOINTPARAMETERENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_BLOCK);
  size2 = dwg_dynapi_fields_size ("BLOCK");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_BLOCK): %d != "
               "dwg_dynapi_fields_size (\"BLOCK\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_BODY);
  size2 = dwg_dynapi_fields_size ("BODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_BODY): %d != "
               "dwg_dynapi_fields_size (\"BODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_CAMERA);
  size2 = dwg_dynapi_fields_size ("CAMERA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_CAMERA): %d != "
               "dwg_dynapi_fields_size (\"CAMERA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_CIRCLE);
  size2 = dwg_dynapi_fields_size ("CIRCLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_CIRCLE): %d != "
               "dwg_dynapi_fields_size (\"CIRCLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DGNUNDERLAY);
  size2 = dwg_dynapi_fields_size ("DGNUNDERLAY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DGNUNDERLAY): %d != "
               "dwg_dynapi_fields_size (\"DGNUNDERLAY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_ALIGNED);
  size2 = dwg_dynapi_fields_size ("DIMENSION_ALIGNED");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_ALIGNED): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_ALIGNED\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_ANG2LN);
  size2 = dwg_dynapi_fields_size ("DIMENSION_ANG2LN");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_ANG2LN): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_ANG2LN\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_ANG3PT);
  size2 = dwg_dynapi_fields_size ("DIMENSION_ANG3PT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_ANG3PT): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_ANG3PT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_DIAMETER);
  size2 = dwg_dynapi_fields_size ("DIMENSION_DIAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_DIAMETER): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_DIAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_LINEAR);
  size2 = dwg_dynapi_fields_size ("DIMENSION_LINEAR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_LINEAR): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_LINEAR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_ORDINATE);
  size2 = dwg_dynapi_fields_size ("DIMENSION_ORDINATE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_ORDINATE): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_ORDINATE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DIMENSION_RADIUS);
  size2 = dwg_dynapi_fields_size ("DIMENSION_RADIUS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DIMENSION_RADIUS): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_RADIUS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_DWFUNDERLAY);
  size2 = dwg_dynapi_fields_size ("DWFUNDERLAY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_DWFUNDERLAY): %d != "
               "dwg_dynapi_fields_size (\"DWFUNDERLAY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ELLIPSE);
  size2 = dwg_dynapi_fields_size ("ELLIPSE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ELLIPSE): %d != "
               "dwg_dynapi_fields_size (\"ELLIPSE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ENDBLK);
  size2 = dwg_dynapi_fields_size ("ENDBLK");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ENDBLK): %d != "
               "dwg_dynapi_fields_size (\"ENDBLK\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ENDREP);
  size2 = dwg_dynapi_fields_size ("ENDREP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ENDREP): %d != "
               "dwg_dynapi_fields_size (\"ENDREP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_EXTRUDEDSURFACE);
  size2 = dwg_dynapi_fields_size ("EXTRUDEDSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_EXTRUDEDSURFACE): %d != "
               "dwg_dynapi_fields_size (\"EXTRUDEDSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_FLIPGRIPENTITY);
  size2 = dwg_dynapi_fields_size ("FLIPGRIPENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_FLIPGRIPENTITY): %d != "
               "dwg_dynapi_fields_size (\"FLIPGRIPENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_FLIPPARAMETERENTITY);
  size2 = dwg_dynapi_fields_size ("FLIPPARAMETERENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_FLIPPARAMETERENTITY): %d != "
               "dwg_dynapi_fields_size (\"FLIPPARAMETERENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_GEOPOSITIONMARKER);
  size2 = dwg_dynapi_fields_size ("GEOPOSITIONMARKER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_GEOPOSITIONMARKER): %d != "
               "dwg_dynapi_fields_size (\"GEOPOSITIONMARKER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_HATCH);
  size2 = dwg_dynapi_fields_size ("HATCH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_HATCH): %d != "
               "dwg_dynapi_fields_size (\"HATCH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_HELIX);
  size2 = dwg_dynapi_fields_size ("HELIX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_HELIX): %d != "
               "dwg_dynapi_fields_size (\"HELIX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_IMAGE);
  size2 = dwg_dynapi_fields_size ("IMAGE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_IMAGE): %d != "
               "dwg_dynapi_fields_size (\"IMAGE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_INSERT);
  size2 = dwg_dynapi_fields_size ("INSERT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_INSERT): %d != "
               "dwg_dynapi_fields_size (\"INSERT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_JUMP);
  size2 = dwg_dynapi_fields_size ("JUMP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_JUMP): %d != "
               "dwg_dynapi_fields_size (\"JUMP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LARGE_RADIAL_DIMENSION);
  size2 = dwg_dynapi_fields_size ("LARGE_RADIAL_DIMENSION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LARGE_RADIAL_DIMENSION): %d != "
               "dwg_dynapi_fields_size (\"LARGE_RADIAL_DIMENSION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LEADER);
  size2 = dwg_dynapi_fields_size ("LEADER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LEADER): %d != "
               "dwg_dynapi_fields_size (\"LEADER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LIGHT);
  size2 = dwg_dynapi_fields_size ("LIGHT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LIGHT): %d != "
               "dwg_dynapi_fields_size (\"LIGHT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LINE);
  size2 = dwg_dynapi_fields_size ("LINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LINE): %d != "
               "dwg_dynapi_fields_size (\"LINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LINEARGRIPENTITY);
  size2 = dwg_dynapi_fields_size ("LINEARGRIPENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LINEARGRIPENTITY): %d != "
               "dwg_dynapi_fields_size (\"LINEARGRIPENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LINEARPARAMETERENTITY);
  size2 = dwg_dynapi_fields_size ("LINEARPARAMETERENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LINEARPARAMETERENTITY): %d != "
               "dwg_dynapi_fields_size (\"LINEARPARAMETERENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LOAD);
  size2 = dwg_dynapi_fields_size ("LOAD");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LOAD): %d != "
               "dwg_dynapi_fields_size (\"LOAD\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LOFTEDSURFACE);
  size2 = dwg_dynapi_fields_size ("LOFTEDSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LOFTEDSURFACE): %d != "
               "dwg_dynapi_fields_size (\"LOFTEDSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_LWPOLYLINE);
  size2 = dwg_dynapi_fields_size ("LWPOLYLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_LWPOLYLINE): %d != "
               "dwg_dynapi_fields_size (\"LWPOLYLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MESH);
  size2 = dwg_dynapi_fields_size ("MESH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MESH): %d != "
               "dwg_dynapi_fields_size (\"MESH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MINSERT);
  size2 = dwg_dynapi_fields_size ("MINSERT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MINSERT): %d != "
               "dwg_dynapi_fields_size (\"MINSERT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MLINE);
  size2 = dwg_dynapi_fields_size ("MLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MLINE): %d != "
               "dwg_dynapi_fields_size (\"MLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MPOLYGON);
  size2 = dwg_dynapi_fields_size ("MPOLYGON");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MPOLYGON): %d != "
               "dwg_dynapi_fields_size (\"MPOLYGON\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MTEXT);
  size2 = dwg_dynapi_fields_size ("MTEXT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MTEXT): %d != "
               "dwg_dynapi_fields_size (\"MTEXT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_MULTILEADER);
  size2 = dwg_dynapi_fields_size ("MULTILEADER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_MULTILEADER): %d != "
               "dwg_dynapi_fields_size (\"MULTILEADER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_NAVISWORKSMODEL);
  size2 = dwg_dynapi_fields_size ("NAVISWORKSMODEL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_NAVISWORKSMODEL): %d != "
               "dwg_dynapi_fields_size (\"NAVISWORKSMODEL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_NURBSURFACE);
  size2 = dwg_dynapi_fields_size ("NURBSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_NURBSURFACE): %d != "
               "dwg_dynapi_fields_size (\"NURBSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_OLE2FRAME);
  size2 = dwg_dynapi_fields_size ("OLE2FRAME");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_OLE2FRAME): %d != "
               "dwg_dynapi_fields_size (\"OLE2FRAME\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_OLEFRAME);
  size2 = dwg_dynapi_fields_size ("OLEFRAME");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_OLEFRAME): %d != "
               "dwg_dynapi_fields_size (\"OLEFRAME\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_PDFUNDERLAY);
  size2 = dwg_dynapi_fields_size ("PDFUNDERLAY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_PDFUNDERLAY): %d != "
               "dwg_dynapi_fields_size (\"PDFUNDERLAY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_PLANESURFACE);
  size2 = dwg_dynapi_fields_size ("PLANESURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_PLANESURFACE): %d != "
               "dwg_dynapi_fields_size (\"PLANESURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POINT);
  size2 = dwg_dynapi_fields_size ("POINT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POINT): %d != "
               "dwg_dynapi_fields_size (\"POINT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POINTCLOUD);
  size2 = dwg_dynapi_fields_size ("POINTCLOUD");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POINTCLOUD): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUD\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POINTCLOUDEX);
  size2 = dwg_dynapi_fields_size ("POINTCLOUDEX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POINTCLOUDEX): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUDEX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POINTPARAMETERENTITY);
  size2 = dwg_dynapi_fields_size ("POINTPARAMETERENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POINTPARAMETERENTITY): %d != "
               "dwg_dynapi_fields_size (\"POINTPARAMETERENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLARGRIPENTITY);
  size2 = dwg_dynapi_fields_size ("POLARGRIPENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLARGRIPENTITY): %d != "
               "dwg_dynapi_fields_size (\"POLARGRIPENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_2D);
  size2 = dwg_dynapi_fields_size ("POLYLINE_2D");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_2D): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_2D\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_3D);
  size2 = dwg_dynapi_fields_size ("POLYLINE_3D");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_3D): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_3D\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_MESH);
  size2 = dwg_dynapi_fields_size ("POLYLINE_MESH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_MESH): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_MESH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_PFACE);
  size2 = dwg_dynapi_fields_size ("POLYLINE_PFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_PFACE): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_PFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_POLYLINE_R11);
  size2 = dwg_dynapi_fields_size ("POLYLINE_R11");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_POLYLINE_R11): %d != "
               "dwg_dynapi_fields_size (\"POLYLINE_R11\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_PROXY_ENTITY);
  size2 = dwg_dynapi_fields_size ("PROXY_ENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_PROXY_ENTITY): %d != "
               "dwg_dynapi_fields_size (\"PROXY_ENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_RAY);
  size2 = dwg_dynapi_fields_size ("RAY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_RAY): %d != "
               "dwg_dynapi_fields_size (\"RAY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_REGION);
  size2 = dwg_dynapi_fields_size ("REGION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_REGION): %d != "
               "dwg_dynapi_fields_size (\"REGION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_REPEAT);
  size2 = dwg_dynapi_fields_size ("REPEAT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_REPEAT): %d != "
               "dwg_dynapi_fields_size (\"REPEAT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_REVOLVEDSURFACE);
  size2 = dwg_dynapi_fields_size ("REVOLVEDSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_REVOLVEDSURFACE): %d != "
               "dwg_dynapi_fields_size (\"REVOLVEDSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ROTATIONGRIPENTITY);
  size2 = dwg_dynapi_fields_size ("ROTATIONGRIPENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ROTATIONGRIPENTITY): %d != "
               "dwg_dynapi_fields_size (\"ROTATIONGRIPENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_ROTATIONPARAMETERENTITY);
  size2 = dwg_dynapi_fields_size ("ROTATIONPARAMETERENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_ROTATIONPARAMETERENTITY): %d != "
               "dwg_dynapi_fields_size (\"ROTATIONPARAMETERENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_RTEXT);
  size2 = dwg_dynapi_fields_size ("RTEXT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_RTEXT): %d != "
               "dwg_dynapi_fields_size (\"RTEXT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SECTIONOBJECT);
  size2 = dwg_dynapi_fields_size ("SECTIONOBJECT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SECTIONOBJECT): %d != "
               "dwg_dynapi_fields_size (\"SECTIONOBJECT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SEQEND);
  size2 = dwg_dynapi_fields_size ("SEQEND");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SEQEND): %d != "
               "dwg_dynapi_fields_size (\"SEQEND\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SHAPE);
  size2 = dwg_dynapi_fields_size ("SHAPE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SHAPE): %d != "
               "dwg_dynapi_fields_size (\"SHAPE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SOLID);
  size2 = dwg_dynapi_fields_size ("SOLID");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SOLID): %d != "
               "dwg_dynapi_fields_size (\"SOLID\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SPLINE);
  size2 = dwg_dynapi_fields_size ("SPLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SPLINE): %d != "
               "dwg_dynapi_fields_size (\"SPLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_SWEPTSURFACE);
  size2 = dwg_dynapi_fields_size ("SWEPTSURFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_SWEPTSURFACE): %d != "
               "dwg_dynapi_fields_size (\"SWEPTSURFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_TABLE);
  size2 = dwg_dynapi_fields_size ("TABLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_TABLE): %d != "
               "dwg_dynapi_fields_size (\"TABLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_TEXT);
  size2 = dwg_dynapi_fields_size ("TEXT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_TEXT): %d != "
               "dwg_dynapi_fields_size (\"TEXT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_TOLERANCE);
  size2 = dwg_dynapi_fields_size ("TOLERANCE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_TOLERANCE): %d != "
               "dwg_dynapi_fields_size (\"TOLERANCE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_TRACE);
  size2 = dwg_dynapi_fields_size ("TRACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_TRACE): %d != "
               "dwg_dynapi_fields_size (\"TRACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_UNKNOWN_ENT);
  size2 = dwg_dynapi_fields_size ("UNKNOWN_ENT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_UNKNOWN_ENT): %d != "
               "dwg_dynapi_fields_size (\"UNKNOWN_ENT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_2D);
  size2 = dwg_dynapi_fields_size ("VERTEX_2D");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_2D): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_2D\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_3D);
  size2 = dwg_dynapi_fields_size ("VERTEX_3D");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_3D): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_3D\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_MESH);
  size2 = dwg_dynapi_fields_size ("VERTEX_MESH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_MESH): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_MESH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_PFACE);
  size2 = dwg_dynapi_fields_size ("VERTEX_PFACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_PFACE): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_PFACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_PFACE_FACE);
  size2 = dwg_dynapi_fields_size ("VERTEX_PFACE_FACE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_PFACE_FACE): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_PFACE_FACE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VERTEX_R11);
  size2 = dwg_dynapi_fields_size ("VERTEX_R11");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VERTEX_R11): %d != "
               "dwg_dynapi_fields_size (\"VERTEX_R11\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VIEWPORT);
  size2 = dwg_dynapi_fields_size ("VIEWPORT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VIEWPORT): %d != "
               "dwg_dynapi_fields_size (\"VIEWPORT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VISIBILITYGRIPENTITY);
  size2 = dwg_dynapi_fields_size ("VISIBILITYGRIPENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VISIBILITYGRIPENTITY): %d != "
               "dwg_dynapi_fields_size (\"VISIBILITYGRIPENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_VISIBILITYPARAMETERENTITY);
  size2 = dwg_dynapi_fields_size ("VISIBILITYPARAMETERENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_VISIBILITYPARAMETERENTITY): %d != "
               "dwg_dynapi_fields_size (\"VISIBILITYPARAMETERENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_WIPEOUT);
  size2 = dwg_dynapi_fields_size ("WIPEOUT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_WIPEOUT): %d != "
               "dwg_dynapi_fields_size (\"WIPEOUT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_XLINE);
  size2 = dwg_dynapi_fields_size ("XLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_XLINE): %d != "
               "dwg_dynapi_fields_size (\"XLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_XYGRIPENTITY);
  size2 = dwg_dynapi_fields_size ("XYGRIPENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_XYGRIPENTITY): %d != "
               "dwg_dynapi_fields_size (\"XYGRIPENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Entity_XYPARAMETERENTITY);
  size2 = dwg_dynapi_fields_size ("XYPARAMETERENTITY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Entity_XYPARAMETERENTITY): %d != "
               "dwg_dynapi_fields_size (\"XYPARAMETERENTITY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACMECOMMANDHISTORY);
  size2 = dwg_dynapi_fields_size ("ACMECOMMANDHISTORY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACMECOMMANDHISTORY): %d != "
               "dwg_dynapi_fields_size (\"ACMECOMMANDHISTORY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACMESCOPE);
  size2 = dwg_dynapi_fields_size ("ACMESCOPE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACMESCOPE): %d != "
               "dwg_dynapi_fields_size (\"ACMESCOPE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACMESTATEMGR);
  size2 = dwg_dynapi_fields_size ("ACMESTATEMGR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACMESTATEMGR): %d != "
               "dwg_dynapi_fields_size (\"ACMESTATEMGR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_BOOLEAN_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_BOOLEAN_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_BOOLEAN_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_BOOLEAN_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_BOX_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_BOX_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_BOX_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_BOX_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_BREP_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_BREP_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_BREP_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_BREP_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_CHAMFER_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_CHAMFER_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_CHAMFER_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_CHAMFER_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_CONE_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_CONE_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_CONE_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_CONE_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_CYLINDER_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_CYLINDER_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_CYLINDER_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_CYLINDER_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_EXTRUSION_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_EXTRUSION_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_EXTRUSION_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_EXTRUSION_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_FILLET_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_FILLET_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_FILLET_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_FILLET_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_HISTORY_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_HISTORY_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_HISTORY_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_HISTORY_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_LOFT_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_LOFT_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_LOFT_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_LOFT_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_PYRAMID_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_PYRAMID_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_PYRAMID_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_PYRAMID_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_REVOLVE_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_REVOLVE_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_REVOLVE_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_REVOLVE_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_SPHERE_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_SPHERE_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_SPHERE_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_SPHERE_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_SWEEP_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_SWEEP_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_SWEEP_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_SWEEP_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_TORUS_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_TORUS_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_TORUS_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_TORUS_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ACSH_WEDGE_CLASS);
  size2 = dwg_dynapi_fields_size ("ACSH_WEDGE_CLASS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ACSH_WEDGE_CLASS): %d != "
               "dwg_dynapi_fields_size (\"ACSH_WEDGE_CLASS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ALDIMOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("ALDIMOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ALDIMOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"ALDIMOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ANGDIMOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("ANGDIMOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ANGDIMOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"ANGDIMOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ANNOTSCALEOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("ANNOTSCALEOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ANNOTSCALEOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"ANNOTSCALEOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_APPID);
  size2 = dwg_dynapi_fields_size ("APPID");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_APPID): %d != "
               "dwg_dynapi_fields_size (\"APPID\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_APPID_CONTROL);
  size2 = dwg_dynapi_fields_size ("APPID_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_APPID_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"APPID_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOC2DCONSTRAINTGROUP);
  size2 = dwg_dynapi_fields_size ("ASSOC2DCONSTRAINTGROUP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOC2DCONSTRAINTGROUP): %d != "
               "dwg_dynapi_fields_size (\"ASSOC2DCONSTRAINTGROUP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOC3POINTANGULARDIMACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOC3POINTANGULARDIMACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOC3POINTANGULARDIMACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOC3POINTANGULARDIMACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCACTION);
  size2 = dwg_dynapi_fields_size ("ASSOCACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCACTION): %d != "
               "dwg_dynapi_fields_size (\"ASSOCACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCALIGNEDDIMACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCALIGNEDDIMACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCALIGNEDDIMACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCALIGNEDDIMACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCARRAYACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCARRAYACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCARRAYACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCARRAYACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCARRAYMODIFYACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCARRAYMODIFYACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCARRAYMODIFYACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCARRAYMODIFYACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCASMBODYACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCASMBODYACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCASMBODYACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCASMBODYACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCBLENDSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCBLENDSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCBLENDSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCBLENDSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCCOMPOUNDACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCCOMPOUNDACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCCOMPOUNDACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCCOMPOUNDACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCDEPENDENCY);
  size2 = dwg_dynapi_fields_size ("ASSOCDEPENDENCY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCDEPENDENCY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCDEPENDENCY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCDIMDEPENDENCYBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCDIMDEPENDENCYBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCDIMDEPENDENCYBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCDIMDEPENDENCYBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCEDGEACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCEDGEACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCEDGEACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCEDGEACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCEDGECHAMFERACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCEDGECHAMFERACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCEDGECHAMFERACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCEDGECHAMFERACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCEDGEFILLETACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCEDGEFILLETACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCEDGEFILLETACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCEDGEFILLETACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCEXTENDSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCEXTENDSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCEXTENDSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCEXTENDSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCEXTRUDEDSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCEXTRUDEDSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCEXTRUDEDSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCEXTRUDEDSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCFACEACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCFACEACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCFACEACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCFACEACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCFILLETSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCFILLETSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCFILLETSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCFILLETSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCGEOMDEPENDENCY);
  size2 = dwg_dynapi_fields_size ("ASSOCGEOMDEPENDENCY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCGEOMDEPENDENCY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCGEOMDEPENDENCY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCLOFTEDSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCLOFTEDSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCLOFTEDSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCLOFTEDSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCMLEADERACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCMLEADERACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCMLEADERACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCMLEADERACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCNETWORK);
  size2 = dwg_dynapi_fields_size ("ASSOCNETWORK");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCNETWORK): %d != "
               "dwg_dynapi_fields_size (\"ASSOCNETWORK\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCNETWORKSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCNETWORKSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCNETWORKSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCNETWORKSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCOBJECTACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCOBJECTACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCOBJECTACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCOBJECTACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCOFFSETSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCOFFSETSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCOFFSETSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCOFFSETSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCORDINATEDIMACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCORDINATEDIMACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCORDINATEDIMACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCORDINATEDIMACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCOSNAPPOINTREFACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCOSNAPPOINTREFACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCPATCHSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCPATCHSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCPATCHSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCPATCHSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCPATHACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCPATHACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCPATHACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCPATHACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCPERSSUBENTMANAGER);
  size2 = dwg_dynapi_fields_size ("ASSOCPERSSUBENTMANAGER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCPERSSUBENTMANAGER): %d != "
               "dwg_dynapi_fields_size (\"ASSOCPERSSUBENTMANAGER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCPLANESURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCPLANESURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCPLANESURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCPLANESURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCPOINTREFACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCPOINTREFACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCPOINTREFACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCPOINTREFACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCRESTOREENTITYSTATEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCRESTOREENTITYSTATEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCRESTOREENTITYSTATEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCRESTOREENTITYSTATEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCREVOLVEDSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCREVOLVEDSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCREVOLVEDSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCREVOLVEDSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCROTATEDDIMACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCROTATEDDIMACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCROTATEDDIMACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCROTATEDDIMACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCSWEPTSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCSWEPTSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCSWEPTSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCSWEPTSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCTRIMSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCTRIMSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCTRIMSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCTRIMSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCVALUEDEPENDENCY);
  size2 = dwg_dynapi_fields_size ("ASSOCVALUEDEPENDENCY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCVALUEDEPENDENCY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCVALUEDEPENDENCY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCVARIABLE);
  size2 = dwg_dynapi_fields_size ("ASSOCVARIABLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCVARIABLE): %d != "
               "dwg_dynapi_fields_size (\"ASSOCVARIABLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCVERTEXACTIONPARAM);
  size2 = dwg_dynapi_fields_size ("ASSOCVERTEXACTIONPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCVERTEXACTIONPARAM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCVERTEXACTIONPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLKREFOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("BLKREFOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLKREFOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"BLKREFOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKALIGNEDCONSTRAINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKALIGNEDCONSTRAINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKALIGNEDCONSTRAINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKALIGNEDCONSTRAINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKALIGNMENTGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKALIGNMENTGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKALIGNMENTGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKALIGNMENTGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKALIGNMENTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKALIGNMENTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKALIGNMENTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKALIGNMENTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKANGULARCONSTRAINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKANGULARCONSTRAINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKANGULARCONSTRAINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKANGULARCONSTRAINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKARRAYACTION);
  size2 = dwg_dynapi_fields_size ("BLOCKARRAYACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKARRAYACTION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKARRAYACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKBASEPOINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKBASEPOINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKBASEPOINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKBASEPOINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKDIAMETRICCONSTRAINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKDIAMETRICCONSTRAINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKDIAMETRICCONSTRAINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKDIAMETRICCONSTRAINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKFLIPACTION);
  size2 = dwg_dynapi_fields_size ("BLOCKFLIPACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKFLIPACTION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKFLIPACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKFLIPGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKFLIPGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKFLIPGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKFLIPGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKFLIPPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKFLIPPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKFLIPPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKFLIPPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKGRIPLOCATIONCOMPONENT);
  size2 = dwg_dynapi_fields_size ("BLOCKGRIPLOCATIONCOMPONENT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKGRIPLOCATIONCOMPONENT): %d != "
               "dwg_dynapi_fields_size (\"BLOCKGRIPLOCATIONCOMPONENT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKHORIZONTALCONSTRAINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKHORIZONTALCONSTRAINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKHORIZONTALCONSTRAINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKHORIZONTALCONSTRAINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKLINEARCONSTRAINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKLINEARCONSTRAINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKLINEARCONSTRAINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKLINEARCONSTRAINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKLINEARGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKLINEARGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKLINEARGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKLINEARGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKLINEARPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKLINEARPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKLINEARPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKLINEARPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKLOOKUPACTION);
  size2 = dwg_dynapi_fields_size ("BLOCKLOOKUPACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKLOOKUPACTION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKLOOKUPACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKLOOKUPGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKLOOKUPGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKLOOKUPGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKLOOKUPGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKLOOKUPPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKLOOKUPPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKLOOKUPPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKLOOKUPPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKMOVEACTION);
  size2 = dwg_dynapi_fields_size ("BLOCKMOVEACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKMOVEACTION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKMOVEACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKPARAMDEPENDENCYBODY);
  size2 = dwg_dynapi_fields_size ("BLOCKPARAMDEPENDENCYBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKPARAMDEPENDENCYBODY): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPARAMDEPENDENCYBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKPOINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKPOINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKPOINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPOINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKPOLARGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKPOLARGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKPOLARGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPOLARGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKPOLARPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKPOLARPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKPOLARPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPOLARPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKPOLARSTRETCHACTION);
  size2 = dwg_dynapi_fields_size ("BLOCKPOLARSTRETCHACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKPOLARSTRETCHACTION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPOLARSTRETCHACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKPROPERTIESTABLE);
  size2 = dwg_dynapi_fields_size ("BLOCKPROPERTIESTABLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKPROPERTIESTABLE): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPROPERTIESTABLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKPROPERTIESTABLEGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKPROPERTIESTABLEGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKPROPERTIESTABLEGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPROPERTIESTABLEGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKRADIALCONSTRAINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKRADIALCONSTRAINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKRADIALCONSTRAINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKRADIALCONSTRAINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKREPRESENTATION);
  size2 = dwg_dynapi_fields_size ("BLOCKREPRESENTATION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKREPRESENTATION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKREPRESENTATION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKROTATEACTION);
  size2 = dwg_dynapi_fields_size ("BLOCKROTATEACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKROTATEACTION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKROTATEACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKROTATIONGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKROTATIONGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKROTATIONGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKROTATIONGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKROTATIONPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKROTATIONPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKROTATIONPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKROTATIONPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKSCALEACTION);
  size2 = dwg_dynapi_fields_size ("BLOCKSCALEACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKSCALEACTION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKSCALEACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKSTRETCHACTION);
  size2 = dwg_dynapi_fields_size ("BLOCKSTRETCHACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKSTRETCHACTION): %d != "
               "dwg_dynapi_fields_size (\"BLOCKSTRETCHACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKUSERPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKUSERPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKUSERPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKUSERPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKVERTICALCONSTRAINTPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKVERTICALCONSTRAINTPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKVERTICALCONSTRAINTPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKVERTICALCONSTRAINTPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKVISIBILITYGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKVISIBILITYGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKVISIBILITYGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKVISIBILITYGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKVISIBILITYPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKVISIBILITYPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKVISIBILITYPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKVISIBILITYPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKXYGRIP);
  size2 = dwg_dynapi_fields_size ("BLOCKXYGRIP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKXYGRIP): %d != "
               "dwg_dynapi_fields_size (\"BLOCKXYGRIP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCKXYPARAMETER);
  size2 = dwg_dynapi_fields_size ("BLOCKXYPARAMETER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCKXYPARAMETER): %d != "
               "dwg_dynapi_fields_size (\"BLOCKXYPARAMETER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCK_CONTROL);
  size2 = dwg_dynapi_fields_size ("BLOCK_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCK_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"BLOCK_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BLOCK_HEADER);
  size2 = dwg_dynapi_fields_size ("BLOCK_HEADER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BLOCK_HEADER): %d != "
               "dwg_dynapi_fields_size (\"BLOCK_HEADER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BREAKDATA);
  size2 = dwg_dynapi_fields_size ("BREAKDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BREAKDATA): %d != "
               "dwg_dynapi_fields_size (\"BREAKDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_BREAKPOINTREF);
  size2 = dwg_dynapi_fields_size ("BREAKPOINTREF");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_BREAKPOINTREF): %d != "
               "dwg_dynapi_fields_size (\"BREAKPOINTREF\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_CELLSTYLEMAP);
  size2 = dwg_dynapi_fields_size ("CELLSTYLEMAP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_CELLSTYLEMAP): %d != "
               "dwg_dynapi_fields_size (\"CELLSTYLEMAP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_CONTEXTDATAMANAGER);
  size2 = dwg_dynapi_fields_size ("CONTEXTDATAMANAGER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_CONTEXTDATAMANAGER): %d != "
               "dwg_dynapi_fields_size (\"CONTEXTDATAMANAGER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_CSACDOCUMENTOPTIONS);
  size2 = dwg_dynapi_fields_size ("CSACDOCUMENTOPTIONS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_CSACDOCUMENTOPTIONS): %d != "
               "dwg_dynapi_fields_size (\"CSACDOCUMENTOPTIONS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_CURVEPATH);
  size2 = dwg_dynapi_fields_size ("CURVEPATH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_CURVEPATH): %d != "
               "dwg_dynapi_fields_size (\"CURVEPATH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DATALINK);
  size2 = dwg_dynapi_fields_size ("DATALINK");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DATALINK): %d != "
               "dwg_dynapi_fields_size (\"DATALINK\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DATATABLE);
  size2 = dwg_dynapi_fields_size ("DATATABLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DATATABLE): %d != "
               "dwg_dynapi_fields_size (\"DATATABLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DBCOLOR);
  size2 = dwg_dynapi_fields_size ("DBCOLOR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DBCOLOR): %d != "
               "dwg_dynapi_fields_size (\"DBCOLOR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DETAILVIEWSTYLE);
  size2 = dwg_dynapi_fields_size ("DETAILVIEWSTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DETAILVIEWSTYLE): %d != "
               "dwg_dynapi_fields_size (\"DETAILVIEWSTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DICTIONARY);
  size2 = dwg_dynapi_fields_size ("DICTIONARY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DICTIONARY): %d != "
               "dwg_dynapi_fields_size (\"DICTIONARY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DICTIONARYVAR);
  size2 = dwg_dynapi_fields_size ("DICTIONARYVAR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DICTIONARYVAR): %d != "
               "dwg_dynapi_fields_size (\"DICTIONARYVAR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DICTIONARYWDFLT);
  size2 = dwg_dynapi_fields_size ("DICTIONARYWDFLT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DICTIONARYWDFLT): %d != "
               "dwg_dynapi_fields_size (\"DICTIONARYWDFLT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DIMASSOC);
  size2 = dwg_dynapi_fields_size ("DIMASSOC");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DIMASSOC): %d != "
               "dwg_dynapi_fields_size (\"DIMASSOC\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DIMSTYLE);
  size2 = dwg_dynapi_fields_size ("DIMSTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DIMSTYLE): %d != "
               "dwg_dynapi_fields_size (\"DIMSTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DIMSTYLE_CONTROL);
  size2 = dwg_dynapi_fields_size ("DIMSTYLE_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DIMSTYLE_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"DIMSTYLE_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DMDIMOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("DMDIMOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DMDIMOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"DMDIMOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DUMMY);
  size2 = dwg_dynapi_fields_size ("DUMMY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DUMMY): %d != "
               "dwg_dynapi_fields_size (\"DUMMY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DYNAMICBLOCKPROXYNODE);
  size2 = dwg_dynapi_fields_size ("DYNAMICBLOCKPROXYNODE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DYNAMICBLOCKPROXYNODE): %d != "
               "dwg_dynapi_fields_size (\"DYNAMICBLOCKPROXYNODE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DYNAMICBLOCKPURGEPREVENTER);
  size2 = dwg_dynapi_fields_size ("DYNAMICBLOCKPURGEPREVENTER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DYNAMICBLOCKPURGEPREVENTER): %d != "
               "dwg_dynapi_fields_size (\"DYNAMICBLOCKPURGEPREVENTER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_EVALUATION_GRAPH);
  size2 = dwg_dynapi_fields_size ("EVALUATION_GRAPH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_EVALUATION_GRAPH): %d != "
               "dwg_dynapi_fields_size (\"EVALUATION_GRAPH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_FCFOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("FCFOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_FCFOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"FCFOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_FIELD);
  size2 = dwg_dynapi_fields_size ("FIELD");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_FIELD): %d != "
               "dwg_dynapi_fields_size (\"FIELD\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_FIELDLIST);
  size2 = dwg_dynapi_fields_size ("FIELDLIST");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_FIELDLIST): %d != "
               "dwg_dynapi_fields_size (\"FIELDLIST\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_GEODATA);
  size2 = dwg_dynapi_fields_size ("GEODATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_GEODATA): %d != "
               "dwg_dynapi_fields_size (\"GEODATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_GEOMAPIMAGE);
  size2 = dwg_dynapi_fields_size ("GEOMAPIMAGE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_GEOMAPIMAGE): %d != "
               "dwg_dynapi_fields_size (\"GEOMAPIMAGE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_GRADIENT_BACKGROUND);
  size2 = dwg_dynapi_fields_size ("GRADIENT_BACKGROUND");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_GRADIENT_BACKGROUND): %d != "
               "dwg_dynapi_fields_size (\"GRADIENT_BACKGROUND\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_GROUND_PLANE_BACKGROUND);
  size2 = dwg_dynapi_fields_size ("GROUND_PLANE_BACKGROUND");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_GROUND_PLANE_BACKGROUND): %d != "
               "dwg_dynapi_fields_size (\"GROUND_PLANE_BACKGROUND\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_GROUP);
  size2 = dwg_dynapi_fields_size ("GROUP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_GROUP): %d != "
               "dwg_dynapi_fields_size (\"GROUP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_IBL_BACKGROUND);
  size2 = dwg_dynapi_fields_size ("IBL_BACKGROUND");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_IBL_BACKGROUND): %d != "
               "dwg_dynapi_fields_size (\"IBL_BACKGROUND\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_IDBUFFER);
  size2 = dwg_dynapi_fields_size ("IDBUFFER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_IDBUFFER): %d != "
               "dwg_dynapi_fields_size (\"IDBUFFER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_IMAGEDEF);
  size2 = dwg_dynapi_fields_size ("IMAGEDEF");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_IMAGEDEF): %d != "
               "dwg_dynapi_fields_size (\"IMAGEDEF\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_IMAGEDEF_REACTOR);
  size2 = dwg_dynapi_fields_size ("IMAGEDEF_REACTOR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_IMAGEDEF_REACTOR): %d != "
               "dwg_dynapi_fields_size (\"IMAGEDEF_REACTOR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_IMAGE_BACKGROUND);
  size2 = dwg_dynapi_fields_size ("IMAGE_BACKGROUND");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_IMAGE_BACKGROUND): %d != "
               "dwg_dynapi_fields_size (\"IMAGE_BACKGROUND\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_INDEX);
  size2 = dwg_dynapi_fields_size ("INDEX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_INDEX): %d != "
               "dwg_dynapi_fields_size (\"INDEX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LAYER);
  size2 = dwg_dynapi_fields_size ("LAYER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LAYER): %d != "
               "dwg_dynapi_fields_size (\"LAYER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LAYERFILTER);
  size2 = dwg_dynapi_fields_size ("LAYERFILTER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LAYERFILTER): %d != "
               "dwg_dynapi_fields_size (\"LAYERFILTER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LAYER_CONTROL);
  size2 = dwg_dynapi_fields_size ("LAYER_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LAYER_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"LAYER_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LAYER_INDEX);
  size2 = dwg_dynapi_fields_size ("LAYER_INDEX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LAYER_INDEX): %d != "
               "dwg_dynapi_fields_size (\"LAYER_INDEX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LAYOUT);
  size2 = dwg_dynapi_fields_size ("LAYOUT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LAYOUT): %d != "
               "dwg_dynapi_fields_size (\"LAYOUT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LAYOUTPRINTCONFIG);
  size2 = dwg_dynapi_fields_size ("LAYOUTPRINTCONFIG");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LAYOUTPRINTCONFIG): %d != "
               "dwg_dynapi_fields_size (\"LAYOUTPRINTCONFIG\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LEADEROBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("LEADEROBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LEADEROBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"LEADEROBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LIGHTLIST);
  size2 = dwg_dynapi_fields_size ("LIGHTLIST");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LIGHTLIST): %d != "
               "dwg_dynapi_fields_size (\"LIGHTLIST\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LONG_TRANSACTION);
  size2 = dwg_dynapi_fields_size ("LONG_TRANSACTION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LONG_TRANSACTION): %d != "
               "dwg_dynapi_fields_size (\"LONG_TRANSACTION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LTYPE);
  size2 = dwg_dynapi_fields_size ("LTYPE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LTYPE): %d != "
               "dwg_dynapi_fields_size (\"LTYPE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_LTYPE_CONTROL);
  size2 = dwg_dynapi_fields_size ("LTYPE_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_LTYPE_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"LTYPE_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_MATERIAL);
  size2 = dwg_dynapi_fields_size ("MATERIAL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_MATERIAL): %d != "
               "dwg_dynapi_fields_size (\"MATERIAL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_MENTALRAYRENDERSETTINGS);
  size2 = dwg_dynapi_fields_size ("MENTALRAYRENDERSETTINGS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_MENTALRAYRENDERSETTINGS): %d != "
               "dwg_dynapi_fields_size (\"MENTALRAYRENDERSETTINGS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_MLEADEROBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("MLEADEROBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_MLEADEROBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"MLEADEROBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_MLEADERSTYLE);
  size2 = dwg_dynapi_fields_size ("MLEADERSTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_MLEADERSTYLE): %d != "
               "dwg_dynapi_fields_size (\"MLEADERSTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_MLINESTYLE);
  size2 = dwg_dynapi_fields_size ("MLINESTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_MLINESTYLE): %d != "
               "dwg_dynapi_fields_size (\"MLINESTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_MOTIONPATH);
  size2 = dwg_dynapi_fields_size ("MOTIONPATH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_MOTIONPATH): %d != "
               "dwg_dynapi_fields_size (\"MOTIONPATH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_MTEXTATTRIBUTEOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("MTEXTATTRIBUTEOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_MTEXTATTRIBUTEOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"MTEXTATTRIBUTEOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_MTEXTOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("MTEXTOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_MTEXTOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"MTEXTOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_NAVISWORKSMODELDEF);
  size2 = dwg_dynapi_fields_size ("NAVISWORKSMODELDEF");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_NAVISWORKSMODELDEF): %d != "
               "dwg_dynapi_fields_size (\"NAVISWORKSMODELDEF\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_OBJECT_PTR);
  size2 = dwg_dynapi_fields_size ("OBJECT_PTR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_OBJECT_PTR): %d != "
               "dwg_dynapi_fields_size (\"OBJECT_PTR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ORDDIMOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("ORDDIMOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ORDDIMOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"ORDDIMOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_PARTIAL_VIEWING_INDEX);
  size2 = dwg_dynapi_fields_size ("PARTIAL_VIEWING_INDEX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_PARTIAL_VIEWING_INDEX): %d != "
               "dwg_dynapi_fields_size (\"PARTIAL_VIEWING_INDEX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_PERSUBENTMGR);
  size2 = dwg_dynapi_fields_size ("PERSUBENTMGR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_PERSUBENTMGR): %d != "
               "dwg_dynapi_fields_size (\"PERSUBENTMGR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_PLACEHOLDER);
  size2 = dwg_dynapi_fields_size ("PLACEHOLDER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_PLACEHOLDER): %d != "
               "dwg_dynapi_fields_size (\"PLACEHOLDER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_PLOTSETTINGS);
  size2 = dwg_dynapi_fields_size ("PLOTSETTINGS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_PLOTSETTINGS): %d != "
               "dwg_dynapi_fields_size (\"PLOTSETTINGS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_POINTCLOUDCOLORMAP);
  size2 = dwg_dynapi_fields_size ("POINTCLOUDCOLORMAP");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_POINTCLOUDCOLORMAP): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUDCOLORMAP\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_POINTCLOUDDEF);
  size2 = dwg_dynapi_fields_size ("POINTCLOUDDEF");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_POINTCLOUDDEF): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUDDEF\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_POINTCLOUDDEFEX);
  size2 = dwg_dynapi_fields_size ("POINTCLOUDDEFEX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_POINTCLOUDDEFEX): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUDDEFEX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_POINTCLOUDDEF_REACTOR);
  size2 = dwg_dynapi_fields_size ("POINTCLOUDDEF_REACTOR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_POINTCLOUDDEF_REACTOR): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUDDEF_REACTOR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_POINTCLOUDDEF_REACTOR_EX);
  size2 = dwg_dynapi_fields_size ("POINTCLOUDDEF_REACTOR_EX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_POINTCLOUDDEF_REACTOR_EX): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUDDEF_REACTOR_EX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_POINTPATH);
  size2 = dwg_dynapi_fields_size ("POINTPATH");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_POINTPATH): %d != "
               "dwg_dynapi_fields_size (\"POINTPATH\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_PROXY_OBJECT);
  size2 = dwg_dynapi_fields_size ("PROXY_OBJECT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_PROXY_OBJECT): %d != "
               "dwg_dynapi_fields_size (\"PROXY_OBJECT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_RADIMLGOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("RADIMLGOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_RADIMLGOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"RADIMLGOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_RADIMOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("RADIMOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_RADIMOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"RADIMOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_RAPIDRTRENDERSETTINGS);
  size2 = dwg_dynapi_fields_size ("RAPIDRTRENDERSETTINGS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_RAPIDRTRENDERSETTINGS): %d != "
               "dwg_dynapi_fields_size (\"RAPIDRTRENDERSETTINGS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_RASTERVARIABLES);
  size2 = dwg_dynapi_fields_size ("RASTERVARIABLES");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_RASTERVARIABLES): %d != "
               "dwg_dynapi_fields_size (\"RASTERVARIABLES\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_RENDERENTRY);
  size2 = dwg_dynapi_fields_size ("RENDERENTRY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_RENDERENTRY): %d != "
               "dwg_dynapi_fields_size (\"RENDERENTRY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_RENDERENVIRONMENT);
  size2 = dwg_dynapi_fields_size ("RENDERENVIRONMENT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_RENDERENVIRONMENT): %d != "
               "dwg_dynapi_fields_size (\"RENDERENVIRONMENT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_RENDERGLOBAL);
  size2 = dwg_dynapi_fields_size ("RENDERGLOBAL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_RENDERGLOBAL): %d != "
               "dwg_dynapi_fields_size (\"RENDERGLOBAL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_RENDERSETTINGS);
  size2 = dwg_dynapi_fields_size ("RENDERSETTINGS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_RENDERSETTINGS): %d != "
               "dwg_dynapi_fields_size (\"RENDERSETTINGS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SCALE);
  size2 = dwg_dynapi_fields_size ("SCALE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SCALE): %d != "
               "dwg_dynapi_fields_size (\"SCALE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SECTIONVIEWSTYLE);
  size2 = dwg_dynapi_fields_size ("SECTIONVIEWSTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SECTIONVIEWSTYLE): %d != "
               "dwg_dynapi_fields_size (\"SECTIONVIEWSTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SECTION_MANAGER);
  size2 = dwg_dynapi_fields_size ("SECTION_MANAGER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SECTION_MANAGER): %d != "
               "dwg_dynapi_fields_size (\"SECTION_MANAGER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SECTION_SETTINGS);
  size2 = dwg_dynapi_fields_size ("SECTION_SETTINGS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SECTION_SETTINGS): %d != "
               "dwg_dynapi_fields_size (\"SECTION_SETTINGS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SKYLIGHT_BACKGROUND);
  size2 = dwg_dynapi_fields_size ("SKYLIGHT_BACKGROUND");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SKYLIGHT_BACKGROUND): %d != "
               "dwg_dynapi_fields_size (\"SKYLIGHT_BACKGROUND\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SOLID_BACKGROUND);
  size2 = dwg_dynapi_fields_size ("SOLID_BACKGROUND");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SOLID_BACKGROUND): %d != "
               "dwg_dynapi_fields_size (\"SOLID_BACKGROUND\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SORTENTSTABLE);
  size2 = dwg_dynapi_fields_size ("SORTENTSTABLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SORTENTSTABLE): %d != "
               "dwg_dynapi_fields_size (\"SORTENTSTABLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SPATIAL_FILTER);
  size2 = dwg_dynapi_fields_size ("SPATIAL_FILTER");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SPATIAL_FILTER): %d != "
               "dwg_dynapi_fields_size (\"SPATIAL_FILTER\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SPATIAL_INDEX);
  size2 = dwg_dynapi_fields_size ("SPATIAL_INDEX");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SPATIAL_INDEX): %d != "
               "dwg_dynapi_fields_size (\"SPATIAL_INDEX\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_STYLE);
  size2 = dwg_dynapi_fields_size ("STYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_STYLE): %d != "
               "dwg_dynapi_fields_size (\"STYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_STYLE_CONTROL);
  size2 = dwg_dynapi_fields_size ("STYLE_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_STYLE_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"STYLE_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SUN);
  size2 = dwg_dynapi_fields_size ("SUN");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SUN): %d != "
               "dwg_dynapi_fields_size (\"SUN\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_SUNSTUDY);
  size2 = dwg_dynapi_fields_size ("SUNSTUDY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_SUNSTUDY): %d != "
               "dwg_dynapi_fields_size (\"SUNSTUDY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_TABLECONTENT);
  size2 = dwg_dynapi_fields_size ("TABLECONTENT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_TABLECONTENT): %d != "
               "dwg_dynapi_fields_size (\"TABLECONTENT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_TABLEGEOMETRY);
  size2 = dwg_dynapi_fields_size ("TABLEGEOMETRY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_TABLEGEOMETRY): %d != "
               "dwg_dynapi_fields_size (\"TABLEGEOMETRY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_TABLESTYLE);
  size2 = dwg_dynapi_fields_size ("TABLESTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_TABLESTYLE): %d != "
               "dwg_dynapi_fields_size (\"TABLESTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_TEXTOBJECTCONTEXTDATA);
  size2 = dwg_dynapi_fields_size ("TEXTOBJECTCONTEXTDATA");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_TEXTOBJECTCONTEXTDATA): %d != "
               "dwg_dynapi_fields_size (\"TEXTOBJECTCONTEXTDATA\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_TVDEVICEPROPERTIES);
  size2 = dwg_dynapi_fields_size ("TVDEVICEPROPERTIES");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_TVDEVICEPROPERTIES): %d != "
               "dwg_dynapi_fields_size (\"TVDEVICEPROPERTIES\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_UCS);
  size2 = dwg_dynapi_fields_size ("UCS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_UCS): %d != "
               "dwg_dynapi_fields_size (\"UCS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_UCS_CONTROL);
  size2 = dwg_dynapi_fields_size ("UCS_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_UCS_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"UCS_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_UNKNOWN_OBJ);
  size2 = dwg_dynapi_fields_size ("UNKNOWN_OBJ");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_UNKNOWN_OBJ): %d != "
               "dwg_dynapi_fields_size (\"UNKNOWN_OBJ\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_VBA_PROJECT);
  size2 = dwg_dynapi_fields_size ("VBA_PROJECT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_VBA_PROJECT): %d != "
               "dwg_dynapi_fields_size (\"VBA_PROJECT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_VIEW);
  size2 = dwg_dynapi_fields_size ("VIEW");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_VIEW): %d != "
               "dwg_dynapi_fields_size (\"VIEW\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_VIEW_CONTROL);
  size2 = dwg_dynapi_fields_size ("VIEW_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_VIEW_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"VIEW_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_VISUALSTYLE);
  size2 = dwg_dynapi_fields_size ("VISUALSTYLE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_VISUALSTYLE): %d != "
               "dwg_dynapi_fields_size (\"VISUALSTYLE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_VPORT);
  size2 = dwg_dynapi_fields_size ("VPORT");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_VPORT): %d != "
               "dwg_dynapi_fields_size (\"VPORT\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_VPORT_CONTROL);
  size2 = dwg_dynapi_fields_size ("VPORT_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_VPORT_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"VPORT_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_VX_CONTROL);
  size2 = dwg_dynapi_fields_size ("VX_CONTROL");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_VX_CONTROL): %d != "
               "dwg_dynapi_fields_size (\"VX_CONTROL\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_VX_TABLE_RECORD);
  size2 = dwg_dynapi_fields_size ("VX_TABLE_RECORD");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_VX_TABLE_RECORD): %d != "
               "dwg_dynapi_fields_size (\"VX_TABLE_RECORD\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_WIPEOUTVARIABLES);
  size2 = dwg_dynapi_fields_size ("WIPEOUTVARIABLES");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_WIPEOUTVARIABLES): %d != "
               "dwg_dynapi_fields_size (\"WIPEOUTVARIABLES\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_XRECORD);
  size2 = dwg_dynapi_fields_size ("XRECORD");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_XRECORD): %d != "
               "dwg_dynapi_fields_size (\"XRECORD\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_PDFDEFINITION);
  size2 = dwg_dynapi_fields_size ("PDFDEFINITION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_PDFDEFINITION): %d != "
               "dwg_dynapi_fields_size (\"PDFDEFINITION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DGNDEFINITION);
  size2 = dwg_dynapi_fields_size ("DGNDEFINITION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DGNDEFINITION): %d != "
               "dwg_dynapi_fields_size (\"DGNDEFINITION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_DWFDEFINITION);
  size2 = dwg_dynapi_fields_size ("DWFDEFINITION");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_DWFDEFINITION): %d != "
               "dwg_dynapi_fields_size (\"DWFDEFINITION\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCARRAYMODIFYPARAMETERS);
  size2 = dwg_dynapi_fields_size ("ASSOCARRAYMODIFYPARAMETERS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCARRAYMODIFYPARAMETERS): %d != "
               "dwg_dynapi_fields_size (\"ASSOCARRAYMODIFYPARAMETERS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCARRAYPATHPARAMETERS);
  size2 = dwg_dynapi_fields_size ("ASSOCARRAYPATHPARAMETERS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCARRAYPATHPARAMETERS): %d != "
               "dwg_dynapi_fields_size (\"ASSOCARRAYPATHPARAMETERS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCARRAYPOLARPARAMETERS);
  size2 = dwg_dynapi_fields_size ("ASSOCARRAYPOLARPARAMETERS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCARRAYPOLARPARAMETERS): %d != "
               "dwg_dynapi_fields_size (\"ASSOCARRAYPOLARPARAMETERS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (Dwg_Object_ASSOCARRAYRECTANGULARPARAMETERS);
  size2 = dwg_dynapi_fields_size ("ASSOCARRAYRECTANGULARPARAMETERS");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(Dwg_Object_ASSOCARRAYRECTANGULARPARAMETERS): %d != "
               "dwg_dynapi_fields_size (\"ASSOCARRAYRECTANGULARPARAMETERS\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_3DSOLID_material);
  size2 = dwg_dynapi_fields_size ("3DSOLID_material");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_3DSOLID_material): %d != "
               "dwg_dynapi_fields_size (\"3DSOLID_material\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_3DSOLID_silhouette);
  size2 = dwg_dynapi_fields_size ("3DSOLID_silhouette");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_3DSOLID_silhouette): %d != "
               "dwg_dynapi_fields_size (\"3DSOLID_silhouette\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_3DSOLID_wire);
  size2 = dwg_dynapi_fields_size ("3DSOLID_wire");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_3DSOLID_wire): %d != "
               "dwg_dynapi_fields_size (\"3DSOLID_wire\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ACSH_HistoryNode);
  size2 = dwg_dynapi_fields_size ("ACSH_HistoryNode");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ACSH_HistoryNode): %d != "
               "dwg_dynapi_fields_size (\"ACSH_HistoryNode\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ACSH_SubentColor);
  size2 = dwg_dynapi_fields_size ("ACSH_SubentColor");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ACSH_SubentColor): %d != "
               "dwg_dynapi_fields_size (\"ACSH_SubentColor\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ACSH_SubentMaterial);
  size2 = dwg_dynapi_fields_size ("ACSH_SubentMaterial");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ACSH_SubentMaterial): %d != "
               "dwg_dynapi_fields_size (\"ACSH_SubentMaterial\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ARRAYITEMLOCATOR);
  size2 = dwg_dynapi_fields_size ("ARRAYITEMLOCATOR");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ARRAYITEMLOCATOR): %d != "
               "dwg_dynapi_fields_size (\"ARRAYITEMLOCATOR\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ASSOCACTIONBODY_action);
  size2 = dwg_dynapi_fields_size ("ASSOCACTIONBODY_action");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ASSOCACTIONBODY_action): %d != "
               "dwg_dynapi_fields_size (\"ASSOCACTIONBODY_action\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ASSOCACTION_Deps);
  size2 = dwg_dynapi_fields_size ("ASSOCACTION_Deps");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ASSOCACTION_Deps): %d != "
               "dwg_dynapi_fields_size (\"ASSOCACTION_Deps\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ASSOCARRAYITEM);
  size2 = dwg_dynapi_fields_size ("ASSOCARRAYITEM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ASSOCARRAYITEM): %d != "
               "dwg_dynapi_fields_size (\"ASSOCARRAYITEM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ASSOCPARAMBASEDACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCPARAMBASEDACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ASSOCPARAMBASEDACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCPARAMBASEDACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ASSOCSURFACEACTIONBODY);
  size2 = dwg_dynapi_fields_size ("ASSOCSURFACEACTIONBODY");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ASSOCSURFACEACTIONBODY): %d != "
               "dwg_dynapi_fields_size (\"ASSOCSURFACEACTIONBODY\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs);
  size2 = dwg_dynapi_fields_size ("AcDs");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs): %d != "
               "dwg_dynapi_fields_size (\"AcDs\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Data);
  size2 = dwg_dynapi_fields_size ("AcDs_Data");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Data): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Data\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_DataBlob);
  size2 = dwg_dynapi_fields_size ("AcDs_DataBlob");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_DataBlob): %d != "
               "dwg_dynapi_fields_size (\"AcDs_DataBlob\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_DataBlob01);
  size2 = dwg_dynapi_fields_size ("AcDs_DataBlob01");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_DataBlob01): %d != "
               "dwg_dynapi_fields_size (\"AcDs_DataBlob01\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_DataBlobRef);
  size2 = dwg_dynapi_fields_size ("AcDs_DataBlobRef");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_DataBlobRef): %d != "
               "dwg_dynapi_fields_size (\"AcDs_DataBlobRef\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_DataBlobRef_Page);
  size2 = dwg_dynapi_fields_size ("AcDs_DataBlobRef_Page");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_DataBlobRef_Page): %d != "
               "dwg_dynapi_fields_size (\"AcDs_DataBlobRef_Page\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_DataIndex);
  size2 = dwg_dynapi_fields_size ("AcDs_DataIndex");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_DataIndex): %d != "
               "dwg_dynapi_fields_size (\"AcDs_DataIndex\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_DataIndex_Entry);
  size2 = dwg_dynapi_fields_size ("AcDs_DataIndex_Entry");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_DataIndex_Entry): %d != "
               "dwg_dynapi_fields_size (\"AcDs_DataIndex_Entry\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Data_Record);
  size2 = dwg_dynapi_fields_size ("AcDs_Data_Record");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Data_Record): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Data_Record\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Data_RecordHdr);
  size2 = dwg_dynapi_fields_size ("AcDs_Data_RecordHdr");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Data_RecordHdr): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Data_RecordHdr\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Schema);
  size2 = dwg_dynapi_fields_size ("AcDs_Schema");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Schema): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Schema\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_SchemaData);
  size2 = dwg_dynapi_fields_size ("AcDs_SchemaData");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_SchemaData): %d != "
               "dwg_dynapi_fields_size (\"AcDs_SchemaData\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_SchemaData_UProp);
  size2 = dwg_dynapi_fields_size ("AcDs_SchemaData_UProp");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_SchemaData_UProp): %d != "
               "dwg_dynapi_fields_size (\"AcDs_SchemaData_UProp\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_SchemaIndex);
  size2 = dwg_dynapi_fields_size ("AcDs_SchemaIndex");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_SchemaIndex): %d != "
               "dwg_dynapi_fields_size (\"AcDs_SchemaIndex\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_SchemaIndex_Prop);
  size2 = dwg_dynapi_fields_size ("AcDs_SchemaIndex_Prop");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_SchemaIndex_Prop): %d != "
               "dwg_dynapi_fields_size (\"AcDs_SchemaIndex_Prop\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Schema_Prop);
  size2 = dwg_dynapi_fields_size ("AcDs_Schema_Prop");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Schema_Prop): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Schema_Prop\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Search);
  size2 = dwg_dynapi_fields_size ("AcDs_Search");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Search): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Search\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Search_Data);
  size2 = dwg_dynapi_fields_size ("AcDs_Search_Data");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Search_Data): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Search_Data\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Search_IdIdx);
  size2 = dwg_dynapi_fields_size ("AcDs_Search_IdIdx");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Search_IdIdx): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Search_IdIdx\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Search_IdIdxs);
  size2 = dwg_dynapi_fields_size ("AcDs_Search_IdIdxs");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Search_IdIdxs): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Search_IdIdxs\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_Segment);
  size2 = dwg_dynapi_fields_size ("AcDs_Segment");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_Segment): %d != "
               "dwg_dynapi_fields_size (\"AcDs_Segment\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_AcDs_SegmentIndex);
  size2 = dwg_dynapi_fields_size ("AcDs_SegmentIndex");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_AcDs_SegmentIndex): %d != "
               "dwg_dynapi_fields_size (\"AcDs_SegmentIndex\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_BLOCKACTION_connectionpts);
  size2 = dwg_dynapi_fields_size ("BLOCKACTION_connectionpts");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_BLOCKACTION_connectionpts): %d != "
               "dwg_dynapi_fields_size (\"BLOCKACTION_connectionpts\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_BLOCKLOOKUPACTION_lut);
  size2 = dwg_dynapi_fields_size ("BLOCKLOOKUPACTION_lut");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_BLOCKLOOKUPACTION_lut): %d != "
               "dwg_dynapi_fields_size (\"BLOCKLOOKUPACTION_lut\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_BLOCKPARAMETER_PropInfo);
  size2 = dwg_dynapi_fields_size ("BLOCKPARAMETER_PropInfo");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_BLOCKPARAMETER_PropInfo): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPARAMETER_PropInfo\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_BLOCKPARAMETER_connection);
  size2 = dwg_dynapi_fields_size ("BLOCKPARAMETER_connection");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_BLOCKPARAMETER_connection): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPARAMETER_connection\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_BLOCKPARAMVALUESET);
  size2 = dwg_dynapi_fields_size ("BLOCKPARAMVALUESET");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_BLOCKPARAMVALUESET): %d != "
               "dwg_dynapi_fields_size (\"BLOCKPARAMVALUESET\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_BLOCKVISIBILITYPARAMETER_state);
  size2 = dwg_dynapi_fields_size ("BLOCKVISIBILITYPARAMETER_state");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_BLOCKVISIBILITYPARAMETER_state): %d != "
               "dwg_dynapi_fields_size (\"BLOCKVISIBILITYPARAMETER_state\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_COMPOUNDOBJECTID);
  size2 = dwg_dynapi_fields_size ("COMPOUNDOBJECTID");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_COMPOUNDOBJECTID): %d != "
               "dwg_dynapi_fields_size (\"COMPOUNDOBJECTID\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_CONSTRAINTGROUPNODE);
  size2 = dwg_dynapi_fields_size ("CONSTRAINTGROUPNODE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_CONSTRAINTGROUPNODE): %d != "
               "dwg_dynapi_fields_size (\"CONSTRAINTGROUPNODE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_CONTEXTDATA_dict);
  size2 = dwg_dynapi_fields_size ("CONTEXTDATA_dict");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_CONTEXTDATA_dict): %d != "
               "dwg_dynapi_fields_size (\"CONTEXTDATA_dict\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_CONTEXTDATA_submgr);
  size2 = dwg_dynapi_fields_size ("CONTEXTDATA_submgr");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_CONTEXTDATA_submgr): %d != "
               "dwg_dynapi_fields_size (\"CONTEXTDATA_submgr\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_CellContentGeometry);
  size2 = dwg_dynapi_fields_size ("CellContentGeometry");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_CellContentGeometry): %d != "
               "dwg_dynapi_fields_size (\"CellContentGeometry\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_CellStyle);
  size2 = dwg_dynapi_fields_size ("CellStyle");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_CellStyle): %d != "
               "dwg_dynapi_fields_size (\"CellStyle\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ColorRamp);
  size2 = dwg_dynapi_fields_size ("ColorRamp");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ColorRamp): %d != "
               "dwg_dynapi_fields_size (\"ColorRamp\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_ContentFormat);
  size2 = dwg_dynapi_fields_size ("ContentFormat");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_ContentFormat): %d != "
               "dwg_dynapi_fields_size (\"ContentFormat\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_DATALINK_customdata);
  size2 = dwg_dynapi_fields_size ("DATALINK_customdata");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_DATALINK_customdata): %d != "
               "dwg_dynapi_fields_size (\"DATALINK_customdata\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_DATATABLE_column);
  size2 = dwg_dynapi_fields_size ("DATATABLE_column");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_DATATABLE_column): %d != "
               "dwg_dynapi_fields_size (\"DATATABLE_column\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_DATATABLE_row);
  size2 = dwg_dynapi_fields_size ("DATATABLE_row");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_DATATABLE_row): %d != "
               "dwg_dynapi_fields_size (\"DATATABLE_row\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_DIMASSOC_Ref);
  size2 = dwg_dynapi_fields_size ("DIMASSOC_Ref");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_DIMASSOC_Ref): %d != "
               "dwg_dynapi_fields_size (\"DIMASSOC_Ref\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_DIMENSION_common);
  size2 = dwg_dynapi_fields_size ("DIMENSION_common");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_DIMENSION_common): %d != "
               "dwg_dynapi_fields_size (\"DIMENSION_common\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_EVAL_Edge);
  size2 = dwg_dynapi_fields_size ("EVAL_Edge");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_EVAL_Edge): %d != "
               "dwg_dynapi_fields_size (\"EVAL_Edge\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_EVAL_Node);
  size2 = dwg_dynapi_fields_size ("EVAL_Node");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_EVAL_Node): %d != "
               "dwg_dynapi_fields_size (\"EVAL_Node\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_EvalExpr);
  size2 = dwg_dynapi_fields_size ("EvalExpr");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_EvalExpr): %d != "
               "dwg_dynapi_fields_size (\"EvalExpr\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_EvalVariant);
  size2 = dwg_dynapi_fields_size ("EvalVariant");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_EvalVariant): %d != "
               "dwg_dynapi_fields_size (\"EvalVariant\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_FIELD_ChildValue);
  size2 = dwg_dynapi_fields_size ("FIELD_ChildValue");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_FIELD_ChildValue): %d != "
               "dwg_dynapi_fields_size (\"FIELD_ChildValue\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_FileDepList_Files);
  size2 = dwg_dynapi_fields_size ("FileDepList_Files");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_FileDepList_Files): %d != "
               "dwg_dynapi_fields_size (\"FileDepList_Files\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_FormattedTableData);
  size2 = dwg_dynapi_fields_size ("FormattedTableData");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_FormattedTableData): %d != "
               "dwg_dynapi_fields_size (\"FormattedTableData\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_FormattedTableMerged);
  size2 = dwg_dynapi_fields_size ("FormattedTableMerged");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_FormattedTableMerged): %d != "
               "dwg_dynapi_fields_size (\"FormattedTableMerged\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_GEODATA_meshface);
  size2 = dwg_dynapi_fields_size ("GEODATA_meshface");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_GEODATA_meshface): %d != "
               "dwg_dynapi_fields_size (\"GEODATA_meshface\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_GEODATA_meshpt);
  size2 = dwg_dynapi_fields_size ("GEODATA_meshpt");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_GEODATA_meshpt): %d != "
               "dwg_dynapi_fields_size (\"GEODATA_meshpt\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_GridFormat);
  size2 = dwg_dynapi_fields_size ("GridFormat");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_GridFormat): %d != "
               "dwg_dynapi_fields_size (\"GridFormat\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_Color);
  size2 = dwg_dynapi_fields_size ("HATCH_Color");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_Color): %d != "
               "dwg_dynapi_fields_size (\"HATCH_Color\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_ControlPoint);
  size2 = dwg_dynapi_fields_size ("HATCH_ControlPoint");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_ControlPoint): %d != "
               "dwg_dynapi_fields_size (\"HATCH_ControlPoint\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_DefLine);
  size2 = dwg_dynapi_fields_size ("HATCH_DefLine");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_DefLine): %d != "
               "dwg_dynapi_fields_size (\"HATCH_DefLine\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_Path);
  size2 = dwg_dynapi_fields_size ("HATCH_Path");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_Path): %d != "
               "dwg_dynapi_fields_size (\"HATCH_Path\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_PathSeg);
  size2 = dwg_dynapi_fields_size ("HATCH_PathSeg");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_PathSeg): %d != "
               "dwg_dynapi_fields_size (\"HATCH_PathSeg\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_HATCH_PolylinePath);
  size2 = dwg_dynapi_fields_size ("HATCH_PolylinePath");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_HATCH_PolylinePath): %d != "
               "dwg_dynapi_fields_size (\"HATCH_PolylinePath\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LAYER_entry);
  size2 = dwg_dynapi_fields_size ("LAYER_entry");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LAYER_entry): %d != "
               "dwg_dynapi_fields_size (\"LAYER_entry\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_ArrowHead);
  size2 = dwg_dynapi_fields_size ("LEADER_ArrowHead");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_ArrowHead): %d != "
               "dwg_dynapi_fields_size (\"LEADER_ArrowHead\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_BlockLabel);
  size2 = dwg_dynapi_fields_size ("LEADER_BlockLabel");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_BlockLabel): %d != "
               "dwg_dynapi_fields_size (\"LEADER_BlockLabel\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_Break);
  size2 = dwg_dynapi_fields_size ("LEADER_Break");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_Break): %d != "
               "dwg_dynapi_fields_size (\"LEADER_Break\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_Line);
  size2 = dwg_dynapi_fields_size ("LEADER_Line");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_Line): %d != "
               "dwg_dynapi_fields_size (\"LEADER_Line\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LEADER_Node);
  size2 = dwg_dynapi_fields_size ("LEADER_Node");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LEADER_Node): %d != "
               "dwg_dynapi_fields_size (\"LEADER_Node\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LIGHTLIST_light);
  size2 = dwg_dynapi_fields_size ("LIGHTLIST_light");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LIGHTLIST_light): %d != "
               "dwg_dynapi_fields_size (\"LIGHTLIST_light\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LTYPE_dash);
  size2 = dwg_dynapi_fields_size ("LTYPE_dash");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LTYPE_dash): %d != "
               "dwg_dynapi_fields_size (\"LTYPE_dash\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LWPOLYLINE_width);
  size2 = dwg_dynapi_fields_size ("LWPOLYLINE_width");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LWPOLYLINE_width): %d != "
               "dwg_dynapi_fields_size (\"LWPOLYLINE_width\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LinkedData);
  size2 = dwg_dynapi_fields_size ("LinkedData");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LinkedData): %d != "
               "dwg_dynapi_fields_size (\"LinkedData\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_LinkedTableData);
  size2 = dwg_dynapi_fields_size ("LinkedTableData");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_LinkedTableData): %d != "
               "dwg_dynapi_fields_size (\"LinkedTableData\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MATERIAL_color);
  size2 = dwg_dynapi_fields_size ("MATERIAL_color");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MATERIAL_color): %d != "
               "dwg_dynapi_fields_size (\"MATERIAL_color\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MATERIAL_gentexture);
  size2 = dwg_dynapi_fields_size ("MATERIAL_gentexture");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MATERIAL_gentexture): %d != "
               "dwg_dynapi_fields_size (\"MATERIAL_gentexture\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MATERIAL_mapper);
  size2 = dwg_dynapi_fields_size ("MATERIAL_mapper");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MATERIAL_mapper): %d != "
               "dwg_dynapi_fields_size (\"MATERIAL_mapper\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MESH_edge);
  size2 = dwg_dynapi_fields_size ("MESH_edge");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MESH_edge): %d != "
               "dwg_dynapi_fields_size (\"MESH_edge\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLEADER_AnnotContext);
  size2 = dwg_dynapi_fields_size ("MLEADER_AnnotContext");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLEADER_AnnotContext): %d != "
               "dwg_dynapi_fields_size (\"MLEADER_AnnotContext\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLEADER_Content_Block);
  size2 = dwg_dynapi_fields_size ("MLEADER_Content_Block");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLEADER_Content_Block): %d != "
               "dwg_dynapi_fields_size (\"MLEADER_Content_Block\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLEADER_Content_MText);
  size2 = dwg_dynapi_fields_size ("MLEADER_Content_MText");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLEADER_Content_MText): %d != "
               "dwg_dynapi_fields_size (\"MLEADER_Content_MText\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLINESTYLE_line);
  size2 = dwg_dynapi_fields_size ("MLINESTYLE_line");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLINESTYLE_line): %d != "
               "dwg_dynapi_fields_size (\"MLINESTYLE_line\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLINE_line);
  size2 = dwg_dynapi_fields_size ("MLINE_line");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLINE_line): %d != "
               "dwg_dynapi_fields_size (\"MLINE_line\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_MLINE_vertex);
  size2 = dwg_dynapi_fields_size ("MLINE_vertex");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_MLINE_vertex): %d != "
               "dwg_dynapi_fields_size (\"MLINE_vertex\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_OCD_Dimension);
  size2 = dwg_dynapi_fields_size ("OCD_Dimension");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_OCD_Dimension): %d != "
               "dwg_dynapi_fields_size (\"OCD_Dimension\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_PARTIAL_VIEWING_INDEX_Entry);
  size2 = dwg_dynapi_fields_size ("PARTIAL_VIEWING_INDEX_Entry");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_PARTIAL_VIEWING_INDEX_Entry): %d != "
               "dwg_dynapi_fields_size (\"PARTIAL_VIEWING_INDEX_Entry\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_POINTCLOUDCOLORMAP_Ramp);
  size2 = dwg_dynapi_fields_size ("POINTCLOUDCOLORMAP_Ramp");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_POINTCLOUDCOLORMAP_Ramp): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUDCOLORMAP_Ramp\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_POINTCLOUDEX_Croppings);
  size2 = dwg_dynapi_fields_size ("POINTCLOUDEX_Croppings");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_POINTCLOUDEX_Croppings): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUDEX_Croppings\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_POINTCLOUD_Clippings);
  size2 = dwg_dynapi_fields_size ("POINTCLOUD_Clippings");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_POINTCLOUD_Clippings): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUD_Clippings\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_POINTCLOUD_IntensityStyle);
  size2 = dwg_dynapi_fields_size ("POINTCLOUD_IntensityStyle");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_POINTCLOUD_IntensityStyle): %d != "
               "dwg_dynapi_fields_size (\"POINTCLOUD_IntensityStyle\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_PROXY_LWPOLYLINE);
  size2 = dwg_dynapi_fields_size ("PROXY_LWPOLYLINE");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_PROXY_LWPOLYLINE): %d != "
               "dwg_dynapi_fields_size (\"PROXY_LWPOLYLINE\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_R2004_Header);
  size2 = dwg_dynapi_fields_size ("R2004_Header");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_R2004_Header): %d != "
               "dwg_dynapi_fields_size (\"R2004_Header\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_SECTION_geometrysettings);
  size2 = dwg_dynapi_fields_size ("SECTION_geometrysettings");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_SECTION_geometrysettings): %d != "
               "dwg_dynapi_fields_size (\"SECTION_geometrysettings\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_SECTION_typesettings);
  size2 = dwg_dynapi_fields_size ("SECTION_typesettings");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_SECTION_typesettings): %d != "
               "dwg_dynapi_fields_size (\"SECTION_typesettings\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_SPLINE_control_point);
  size2 = dwg_dynapi_fields_size ("SPLINE_control_point");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_SPLINE_control_point): %d != "
               "dwg_dynapi_fields_size (\"SPLINE_control_point\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_SUNSTUDY_Dates);
  size2 = dwg_dynapi_fields_size ("SUNSTUDY_Dates");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_SUNSTUDY_Dates): %d != "
               "dwg_dynapi_fields_size (\"SUNSTUDY_Dates\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_SummaryInfo_Property);
  size2 = dwg_dynapi_fields_size ("SummaryInfo_Property");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_SummaryInfo_Property): %d != "
               "dwg_dynapi_fields_size (\"SummaryInfo_Property\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLEGEOMETRY_Cell);
  size2 = dwg_dynapi_fields_size ("TABLEGEOMETRY_Cell");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLEGEOMETRY_Cell): %d != "
               "dwg_dynapi_fields_size (\"TABLEGEOMETRY_Cell\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLESTYLE_CellStyle);
  size2 = dwg_dynapi_fields_size ("TABLESTYLE_CellStyle");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLESTYLE_CellStyle): %d != "
               "dwg_dynapi_fields_size (\"TABLESTYLE_CellStyle\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLESTYLE_border);
  size2 = dwg_dynapi_fields_size ("TABLESTYLE_border");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLESTYLE_border): %d != "
               "dwg_dynapi_fields_size (\"TABLESTYLE_border\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLESTYLE_rowstyles);
  size2 = dwg_dynapi_fields_size ("TABLESTYLE_rowstyles");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLESTYLE_rowstyles): %d != "
               "dwg_dynapi_fields_size (\"TABLESTYLE_rowstyles\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_AttrDef);
  size2 = dwg_dynapi_fields_size ("TABLE_AttrDef");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_AttrDef): %d != "
               "dwg_dynapi_fields_size (\"TABLE_AttrDef\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_BreakHeight);
  size2 = dwg_dynapi_fields_size ("TABLE_BreakHeight");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_BreakHeight): %d != "
               "dwg_dynapi_fields_size (\"TABLE_BreakHeight\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_BreakRow);
  size2 = dwg_dynapi_fields_size ("TABLE_BreakRow");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_BreakRow): %d != "
               "dwg_dynapi_fields_size (\"TABLE_BreakRow\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_Cell);
  size2 = dwg_dynapi_fields_size ("TABLE_Cell");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_Cell): %d != "
               "dwg_dynapi_fields_size (\"TABLE_Cell\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_CustomDataItem);
  size2 = dwg_dynapi_fields_size ("TABLE_CustomDataItem");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_CustomDataItem): %d != "
               "dwg_dynapi_fields_size (\"TABLE_CustomDataItem\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TABLE_value);
  size2 = dwg_dynapi_fields_size ("TABLE_value");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TABLE_value): %d != "
               "dwg_dynapi_fields_size (\"TABLE_value\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableCell);
  size2 = dwg_dynapi_fields_size ("TableCell");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableCell): %d != "
               "dwg_dynapi_fields_size (\"TableCell\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableCellContent);
  size2 = dwg_dynapi_fields_size ("TableCellContent");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableCellContent): %d != "
               "dwg_dynapi_fields_size (\"TableCellContent\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableCellContent_Attr);
  size2 = dwg_dynapi_fields_size ("TableCellContent_Attr");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableCellContent_Attr): %d != "
               "dwg_dynapi_fields_size (\"TableCellContent_Attr\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableDataColumn);
  size2 = dwg_dynapi_fields_size ("TableDataColumn");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableDataColumn): %d != "
               "dwg_dynapi_fields_size (\"TableDataColumn\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_TableRow);
  size2 = dwg_dynapi_fields_size ("TableRow");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_TableRow): %d != "
               "dwg_dynapi_fields_size (\"TableRow\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_UCS_orthopts);
  size2 = dwg_dynapi_fields_size ("UCS_orthopts");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_UCS_orthopts): %d != "
               "dwg_dynapi_fields_size (\"UCS_orthopts\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_VALUEPARAM);
  size2 = dwg_dynapi_fields_size ("VALUEPARAM");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_VALUEPARAM): %d != "
               "dwg_dynapi_fields_size (\"VALUEPARAM\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (struct _dwg_VALUEPARAM_vars);
  size2 = dwg_dynapi_fields_size ("VALUEPARAM_vars");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(struct _dwg_VALUEPARAM_vars): %d != "
               "dwg_dynapi_fields_size (\"VALUEPARAM_vars\"): %d\n", size1, size2);
      error++;
    }
  size1 = sizeof (union _dwg_MLEADER_Content);
  size2 = dwg_dynapi_fields_size ("MLEADER_Content");
  if (size1 != size2)
    {
      fprintf (stderr, "sizeof(union _dwg_MLEADER_Content): %d != "
               "dwg_dynapi_fields_size (\"MLEADER_Content\"): %d\n", size1, size2);
      error++;
    }
#line 72 "dynapi_test.c.in"
  return error;
}

static int
test_dynapi (const char *filename)
{
  int error;
  Dwg_Data dwg;
  BITCODE_BL i;
  num = passed = failed = 0;

  dwg.opts = 0;
  error = test_sizes ();
  if (dwg_read_file (filename, &dwg) >= DWG_ERR_CRITICAL)
    {
      dwg_free (&dwg);
      return error + 1;
    }

  /* On cygwin32 the dynapi works fine, but the dwg->header_vars.VARS
     reference is broken somehow (some wrong offset) */
#if !defined(__CYGWIN__) || defined(__amd64__)
  error += test_header (&dwg);
#endif
  for (i = 0; i < dwg.num_objects; i++)
    {
      error += test_object (&dwg, &dwg.object[i]);
    }
  dwg_free (&dwg);
  /* This value is the return value for `main',
     so clamp it to either 0 or 1.  */
  return error ? 1 : 0;
}

int
main (int argc, char *argv[])
{
  char *input = getenv ("INPUT");
  loglevel = is_make_silent() ? 0 : 2;

  if (input == NULL)
    {
      int error = 0;
      char **ptr;
      const char *const files[] =
        {
         "example_2000.dwg",
         "example_2004.dwg",
         "example_2007.dwg",
         "example_2010.dwg",
         "example_2013.dwg",
         "example_2018.dwg",
         "example_r14.dwg",
         "2007/PolyLine3D.dwg",
         //"2018/Dynblocks.dwg",
         //"example_r13.dwg",
         //"r12/work.dwg",
         //"r11/ACEB10.dwg",
         //"r11/entities-3d.dwg",
         //"r10/entities.dwg",
         //"r9/entities.dwg",
         //"r2.10/entities.dwg",
         //"r2.6/entities.dwg",
         //"r1.4/entities.dwg",
         NULL
        };
      for (ptr = (char**)&files[0]; *ptr; ptr++)
        {
          struct stat attrib;
          if (stat (*ptr, &attrib))
            {
              char tmp[80];
              strncpy (tmp, "../test-data/", sizeof (tmp));
              strncat (tmp, *ptr, sizeof (tmp) - sizeof ("../test-data/") - 1);
              if (stat (tmp, &attrib))
                LOG_ERROR ("Env var INPUT not defined, %s not found", tmp)
              else
                error += test_dynapi (tmp);
            }
          else
            error += test_dynapi (*ptr);
        }
      return error;
    }
  else
    return test_dynapi (input);
}
